{"path": "Mathlib/CategoryTheory/Category/Preorder.lean", "imports": ["Mathlib/CategoryTheory/Equivalence.lean", "Mathlib/Data/ULift.lean", "Mathlib/Order/Hom/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Preorder.smallCategory", "code": "instance (priority := 100) smallCategory (\u03b1 : Type u) [Preorder \u03b1] : SmallCategory \u03b1 where\n  Hom U V := ULift (PLift (U \u2264 V))\n  id X := \u27e8\u27e8le_refl X\u27e9\u27e9\n  comp f g := \u27e8\u27e8le_trans _ _ _ f.down.down g.down.down\u27e9\u27e9", "start": [38, 1], "end": [50, 57], "kind": "commanddeclaration"}, {"full_name": "Preorder.Preorder.subsingleton_hom", "code": "instance Preorder.subsingleton_hom {\u03b1 : Type u} [Preorder \u03b1] (U V : \u03b1) :\n  Subsingleton (U \u27f6 V) := \u27e8fun _ _ => ULift.ext _ _ (Subsingleton.elim _ _ )\u27e9", "start": [54, 1], "end": [55, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.homOfLE", "code": "def homOfLE {x y : X} (h : x \u2264 y) : x \u27f6 y :=\n  ULift.up (PLift.up h)", "start": [65, 1], "end": [68, 24], "kind": "commanddeclaration"}, {"full_name": "LE.le.hom", "code": "alias _root_.LE.le.hom := homOfLE", "start": [71, 1], "end": [71, 34], "kind": "stdtacticaliasalias"}, {"full_name": "CategoryTheory.homOfLE_refl", "code": "@[simp]\ntheorem homOfLE_refl {x : X} : (le_refl x).hom = \ud835\udfd9 x", "start": [74, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.homOfLE_comp", "code": "@[simp]\ntheorem homOfLE_comp {x y z : X} (h : x \u2264 y) (k : y \u2264 z) :\n    homOfLE h \u226b homOfLE k = homOfLE (h.trans k)", "start": [79, 1], "end": [82, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.leOfHom", "code": "theorem leOfHom {x y : X} (h : x \u27f6 y) : x \u2264 y", "start": [85, 1], "end": [88, 14], "kind": "commanddeclaration"}, {"full_name": "Quiver.Hom.le", "code": "alias _root_.Quiver.Hom.le := leOfHom", "start": [91, 1], "end": [91, 38], "kind": "stdtacticaliasalias"}, {"full_name": "CategoryTheory.leOfHom_homOfLE", "code": "theorem leOfHom_homOfLE {x y : X} (h : x \u2264 y) : h.hom.le = h", "start": [96, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.homOfLE_leOfHom", "code": "theorem homOfLE_leOfHom {x y : X} (h : x \u27f6 y) : h.le.hom = h", "start": [103, 1], "end": [104, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.opHomOfLE", "code": "def opHomOfLE {x y : X\u1d52\u1d56} (h : unop x \u2264 unop y) : y \u27f6 x :=\n  (homOfLE h).op", "start": [107, 1], "end": [109, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.le_of_op_hom", "code": "theorem le_of_op_hom {x y : X\u1d52\u1d56} (h : x \u27f6 y) : unop y \u2264 unop x", "start": [112, 1], "end": [113, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uniqueToTop", "code": "instance uniqueToTop [OrderTop X] {x : X} : Unique (x \u27f6 \u22a4) where\n  default := homOfLE le_top\n  uniq := fun a => by rfl", "start": [116, 1], "end": [118, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uniqueFromBot", "code": "instance uniqueFromBot [OrderBot X] {x : X} : Unique (\u22a5 \u27f6 x) where\n  default := homOfLE bot_le\n  uniq := fun a => by rfl", "start": [121, 1], "end": [123, 26], "kind": "commanddeclaration"}, {"full_name": "Monotone.functor", "code": "def Monotone.functor {f : X \u2192 Y} (h : Monotone f) : X \u2964 Y where\n  obj := f\n  map g := CategoryTheory.homOfLE (h g.le)", "start": [134, 1], "end": [138, 43], "kind": "commanddeclaration"}, {"full_name": "Monotone.functor_obj", "code": "@[simp]\ntheorem Monotone.functor_obj {f : X \u2192 Y} (h : Monotone f) : h.functor.obj = f", "start": [141, 1], "end": [143, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.monotone", "code": "@[mono]\ntheorem Functor.monotone (f : X \u2964 Y) : Monotone f.obj", "start": [154, 1], "end": [157, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.to_eq", "code": "theorem Iso.to_eq {x y : X} (f : x \u2245 y) : x = y", "start": [166, 1], "end": [167, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.toOrderIso", "code": "def Equivalence.toOrderIso (e : X \u224c Y) : X \u2243o Y where\n  toFun := e.functor.obj\n  invFun := e.inverse.obj\n  left_inv a := (e.unitIso.app a).to_eq.symm\n  right_inv b := (e.counitIso.app b).to_eq\n  map_rel_iff' {a a'} :=\n    \u27e8fun h =>\n      ((Equivalence.unit e).app a \u226b e.inverse.map h.hom \u226b (Equivalence.unitInv e).app a').le,\n      fun h : a \u2264 a' => (e.functor.map h.hom).le\u27e9", "start": [170, 1], "end": [180, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.toOrderIso_apply", "code": "@[simp]\ntheorem Equivalence.toOrderIso_apply (e : X \u224c Y) (x : X) : e.toOrderIso x = e.functor.obj x", "start": [185, 1], "end": [187, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.toOrderIso_symm_apply", "code": "@[simp]\ntheorem Equivalence.toOrderIso_symm_apply (e : X \u224c Y) (y : Y) :\n    e.toOrderIso.symm y = e.inverse.obj y", "start": [190, 1], "end": [193, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/IsomorphismClasses.lean", "imports": ["Mathlib/CategoryTheory/Category/Cat.lean", "Mathlib/CategoryTheory/Groupoid.lean", "Mathlib/CategoryTheory/Types.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.IsIsomorphic", "code": "def IsIsomorphic : C \u2192 C \u2192 Prop := fun X Y => Nonempty (X \u2245 Y)", "start": [28, 1], "end": [29, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIsomorphicSetoid", "code": "def isIsomorphicSetoid : Setoid C where\n  r := IsIsomorphic\n  iseqv := \u27e8fun X => \u27e8Iso.refl X\u27e9, fun \u27e8\u03b1\u27e9 => \u27e8\u03b1.symm\u27e9, fun \u27e8\u03b1\u27e9 \u27e8\u03b2\u27e9 => \u27e8\u03b1.trans \u03b2\u27e9\u27e9", "start": [34, 1], "end": [37, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isomorphismClasses", "code": "def isomorphismClasses : Cat.{v, u} \u2964 Type u where\n  obj C := Quotient (isIsomorphicSetoid C.\u03b1)\n  map {C D} F := Quot.map F.obj fun X Y \u27e8f\u27e9 => \u27e8F.mapIso f\u27e9\n  map_id {C} := by  dsimp; apply funext; intro x\n    apply x.recOn  \u00b7 intro _ _ p\n      simp only [types_id_apply]\n    \u00b7 intro _\n      rfl\n  map_comp {C D E} f g := by dsimp; apply funext; intro x\n    apply x.recOn\n    \u00b7 intro _ _ _\n      simp only [types_id_apply]\n    \u00b7 intro _\n      rfl", "start": [42, 1], "end": [60, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.isIsomorphic_iff_nonempty_hom", "code": "theorem Groupoid.isIsomorphic_iff_nonempty_hom {C : Type u} [Groupoid.{v} C] {X Y : C} :\n    IsIsomorphic X Y \u2194 Nonempty (X \u27f6 Y)", "start": [63, 1], "end": [65, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Thin.lean", "imports": ["Mathlib/CategoryTheory/Functor/Category.lean", "Mathlib/CategoryTheory/Iso.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.thin_category", "code": "def thin_category : Category C where", "start": [35, 1], "end": [37, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.functor_thin", "code": "instance functor_thin : Quiver.IsThin (D \u2964 C) := fun _ _ =>\n  \u27e8fun \u03b1 \u03b2 => NatTrans.ext \u03b1 \u03b2 (funext fun _ => Subsingleton.elim _ _)\u27e9", "start": [49, 1], "end": [51, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.iso_of_both_ways", "code": "def iso_of_both_ways {X Y : C} (f : X \u27f6 Y) (g : Y \u27f6 X) :\n    X \u2245 Y where\n  hom := f\n  inv := g", "start": [54, 1], "end": [58, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.subsingleton_iso", "code": "instance subsingleton_iso {X Y : C} : Subsingleton (X \u2245 Y) :=\n  \u27e8by\n    intro i\u2081 i\u2082\n    ext1\n    apply Subsingleton.elim\u27e9", "start": [61, 1], "end": [65, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Determinant.lean", "imports": ["Mathlib/Data/Matrix/Block.lean", "Mathlib/Data/Matrix/Notation.lean", "Mathlib/GroupTheory/Perm/Sign.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/Data/Matrix/PEquiv.lean", "Mathlib/LinearAlgebra/Pi.lean", "Mathlib/LinearAlgebra/Alternating/Basic.lean", "Mathlib/Algebra/Algebra/Basic.lean", "Mathlib/Tactic/Ring.lean", "Mathlib/GroupTheory/Perm/Fin.lean"], "premises": [{"full_name": "Matrix.detRowAlternating", "code": "def detRowAlternating : AlternatingMap R (n \u2192 R) R n :=\n  MultilinearMap.alternatization ((MultilinearMap.mkPiAlgebra R n R).compLinearMap LinearMap.proj)", "start": [59, 1], "end": [61, 99], "kind": "commanddeclaration"}, {"full_name": "Matrix.det", "code": "abbrev det (M : Matrix n n R) : R :=\n  detRowAlternating M", "start": [64, 1], "end": [66, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_apply", "code": "theorem det_apply (M : Matrix n n R) : M.det = \u2211 \u03c3 : Perm n, Equiv.Perm.sign \u03c3 \u2022 \u220f i, M (\u03c3 i) i", "start": [69, 1], "end": [70, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_apply'", "code": "theorem det_apply' (M : Matrix n n R) : M.det = \u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f i, M (\u03c3 i) i", "start": [74, 1], "end": [75, 35], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_diagonal", "code": "@[simp]\ntheorem det_diagonal {d : n \u2192 R} : det (diagonal d) = \u220f i, d i", "start": [78, 1], "end": [88, 9], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_zero", "code": "theorem det_zero (_ : Nonempty n) : det (0 : Matrix n n R) = 0", "start": [92, 1], "end": [93, 62], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_one", "code": "@[simp]\ntheorem det_one : det (1 : Matrix n n R) = 1", "start": [96, 1], "end": [97, 93], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_isEmpty", "code": "theorem det_isEmpty [IsEmpty n] {A : Matrix n n R} : det A = 1", "start": [100, 1], "end": [100, 86], "kind": "commanddeclaration"}, {"full_name": "Matrix.coe_det_isEmpty", "code": "@[simp]\ntheorem coe_det_isEmpty [IsEmpty n] : (det : Matrix n n R \u2192 R) = Function.const _ 1", "start": [103, 1], "end": [106, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_one_of_card_eq_zero", "code": "theorem det_eq_one_of_card_eq_zero {A : Matrix n n R} (h : Fintype.card n = 0) : det A = 1", "start": [109, 1], "end": [111, 14], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_unique", "code": "@[simp]\ntheorem det_unique {n : Type*} [Unique n] [DecidableEq n] [Fintype n] (A : Matrix n n R) :\n    det A = A default default", "start": [114, 1], "end": [119, 66], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_elem_of_subsingleton", "code": "theorem det_eq_elem_of_subsingleton [Subsingleton n] (A : Matrix n n R) (k : n) :\n    det A = A k k", "start": [122, 1], "end": [125, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_elem_of_card_eq_one", "code": "theorem det_eq_elem_of_card_eq_one {A : Matrix n n R} (h : Fintype.card n = 1) (k : n) :\n    det A = A k k", "start": [128, 1], "end": [131, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_mul_aux", "code": "theorem det_mul_aux {M N : Matrix n n R} {p : n \u2192 n} (H : \u00acBijective p) :\n    (\u2211 \u03c3 : Perm n, \u03b5 \u03c3 * \u220f x, M (\u03c3 x) (p x) * N (p x) x) = 0", "start": [134, 1], "end": [147, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_mul", "code": "@[simp]\ntheorem det_mul (M N : Matrix n n R) : det (M * N) = det M * det N", "start": [150, 1], "end": [184, 81], "kind": "commanddeclaration"}, {"full_name": "Matrix.detMonoidHom", "code": "def detMonoidHom : Matrix n n R \u2192* R where\n  toFun := det\n  map_one' := det_one\n  map_mul' := det_mul", "start": [187, 1], "end": [191, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.coe_detMonoidHom", "code": "@[simp]\ntheorem coe_detMonoidHom : (detMonoidHom : Matrix n n R \u2192 R) = det", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_mul_comm", "code": "theorem det_mul_comm (M N : Matrix m m R) : det (M * N) = det (N * M)", "start": [199, 1], "end": [201, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_mul_left_comm", "code": "theorem det_mul_left_comm (M N P : Matrix m m R) : det (M * (N * P)) = det (N * (M * P))", "start": [204, 1], "end": [206, 84], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_mul_right_comm", "code": "theorem det_mul_right_comm (M N P : Matrix m m R) : det (M * N * P) = det (M * P * N)", "start": [209, 1], "end": [211, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_units_conj", "code": "theorem det_units_conj (M : (Matrix m m R)\u02e3) (N : Matrix m m R) :\n    det ((M : Matrix _ _ _) * N * (\u2191M\u207b\u00b9 : Matrix _ _ _)) = det N", "start": [215, 1], "end": [217, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_units_conj'", "code": "theorem det_units_conj' (M : (Matrix m m R)\u02e3) (N : Matrix m m R) :\n    det ((\u2191M\u207b\u00b9 : Matrix _ _ _) * N * (\u2191M : Matrix _ _ _)) = det N", "start": [221, 1], "end": [223, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_transpose", "code": "@[simp]\ntheorem det_transpose (M : Matrix n n R) : M\u1d40.det = M.det", "start": [226, 1], "end": [236, 7], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_permute", "code": "theorem det_permute (\u03c3 : Perm n) (M : Matrix n n R) :\n    (Matrix.det fun i => M (\u03c3 i)) = Perm.sign \u03c3 * M.det", "start": [239, 1], "end": [242, 101], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_submatrix_equiv_self", "code": "@[simp]\ntheorem det_submatrix_equiv_self (e : n \u2243 m) (A : Matrix m m R) :\n    det (A.submatrix e e) = det A", "start": [245, 1], "end": [256, 70], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_reindex_self", "code": "theorem det_reindex_self (e : m \u2243 n) (A : Matrix m m R) : det (reindex e e A) = det A", "start": [259, 1], "end": [265, 36], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_permutation", "code": "@[simp]\ntheorem det_permutation (\u03c3 : Perm n) :\n    Matrix.det (\u03c3.toPEquiv.toMatrix : Matrix n n R) = Perm.sign \u03c3", "start": [268, 1], "end": [273, 35], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_smul", "code": "theorem det_smul (A : Matrix n n R) (c : R) : det (c \u2022 A) = c ^ Fintype.card n * det A", "start": [276, 1], "end": [280, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_smul_of_tower", "code": "@[simp]\ntheorem det_smul_of_tower {\u03b1} [Monoid \u03b1] [DistribMulAction \u03b1 R] [IsScalarTower \u03b1 R R]\n    [SMulCommClass \u03b1 R R] (c : \u03b1) (A : Matrix n n R) : det (c \u2022 A) = c ^ Fintype.card n \u2022 det A", "start": [283, 1], "end": [286, 86], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_neg", "code": "theorem det_neg (A : Matrix n n R) : det (-A) = (-1) ^ Fintype.card n * det A", "start": [289, 1], "end": [290, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_neg_eq_smul", "code": "theorem det_neg_eq_smul (A : Matrix n n R) : det (-A) = (-1 : Units \u2124) ^ Fintype.card n \u2022 det A", "start": [293, 1], "end": [296, 56], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_mul_row", "code": "theorem det_mul_row (v : n \u2192 R) (A : Matrix n n R) :\n    det (of fun i j => v j * A i j) = (\u220f i, v i) * det A", "start": [299, 1], "end": [308, 70], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_mul_column", "code": "theorem det_mul_column (v : n \u2192 R) (A : Matrix n n R) :\n    det (of fun i j => v i * A i j) = (\u220f i, v i) * det A", "start": [311, 1], "end": [315, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_pow", "code": "@[simp]\ntheorem det_pow (M : Matrix m m R) (n : \u2115) : det (M ^ n) = det M ^ n", "start": [318, 1], "end": [320, 49], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_det", "code": "theorem _root_.RingHom.map_det (f : R \u2192+* S) (M : Matrix n n R) :\n    f M.det = Matrix.det (f.mapMatrix M)", "start": [327, 1], "end": [329, 53], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_det", "code": "theorem _root_.RingEquiv.map_det (f : R \u2243+* S) (M : Matrix n n R) :\n    f M.det = Matrix.det (f.mapMatrix M)", "start": [332, 1], "end": [334, 24], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_det", "code": "theorem _root_.AlgHom.map_det [Algebra R S] {T : Type z} [CommRing T] [Algebra R T] (f : S \u2192\u2090[R] T)\n    (M : Matrix n n S) : f M.det = Matrix.det (f.mapMatrix M)", "start": [337, 1], "end": [339, 24], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.map_det", "code": "theorem _root_.AlgEquiv.map_det [Algebra R S] {T : Type z} [CommRing T] [Algebra R T]\n    (f : S \u2243\u2090[R] T) (M : Matrix n n S) : f M.det = Matrix.det (f.mapMatrix M)", "start": [342, 1], "end": [344, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_conjTranspose", "code": "@[simp]\ntheorem det_conjTranspose [StarRing R] (M : Matrix m m R) : det M\u1d34 = star (det M)", "start": [349, 1], "end": [351, 75], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_zero_of_row_eq_zero", "code": "theorem det_eq_zero_of_row_eq_zero {A : Matrix n n R} (i : n) (h : \u2200 j, A i j = 0) : det A = 0", "start": [363, 1], "end": [364, 81], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_zero_of_column_eq_zero", "code": "theorem det_eq_zero_of_column_eq_zero {A : Matrix n n R} (j : n) (h : \u2200 i, A i j = 0) :\n    det A = 0", "start": [367, 1], "end": [370, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_zero_of_row_eq", "code": "theorem det_zero_of_row_eq (i_ne_j : i \u2260 j) (hij : M i = M j) : M.det = 0", "start": [375, 1], "end": [377, 84], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_zero_of_column_eq", "code": "theorem det_zero_of_column_eq (i_ne_j : i \u2260 j) (hij : \u2200 k, M k i = M k j) : M.det = 0", "start": [380, 1], "end": [383, 19], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_updateRow_add", "code": "theorem det_updateRow_add (M : Matrix n n R) (j : n) (u v : n \u2192 R) :\n    det (updateRow M j <| u + v) = det (updateRow M j u) + det (updateRow M j v)", "start": [388, 1], "end": [390, 69], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_updateColumn_add", "code": "theorem det_updateColumn_add (M : Matrix n n R) (j : n) (u v : n \u2192 R) :\n    det (updateColumn M j <| u + v) = det (updateColumn M j u) + det (updateColumn M j v)", "start": [393, 1], "end": [396, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_updateRow_smul", "code": "theorem det_updateRow_smul (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateRow M j <| s \u2022 u) = s * det (updateRow M j u)", "start": [399, 1], "end": [401, 70], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_updateColumn_smul", "code": "theorem det_updateColumn_smul (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateColumn M j <| s \u2022 u) = s * det (updateColumn M j u)", "start": [404, 1], "end": [407, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_updateRow_smul'", "code": "theorem det_updateRow_smul' (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateRow (s \u2022 M) j u) = s ^ (Fintype.card n - 1) * det (updateRow M j u)", "start": [410, 1], "end": [412, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_updateColumn_smul'", "code": "theorem det_updateColumn_smul' (M : Matrix n n R) (j : n) (s : R) (u : n \u2192 R) :\n    det (updateColumn (s \u2022 M) j u) = s ^ (Fintype.card n - 1) * det (updateColumn M j u)", "start": [415, 1], "end": [418, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_of_eq_mul_det_one", "code": "theorem det_eq_of_eq_mul_det_one {A B : Matrix n n R} (C : Matrix n n R) (hC : det C = 1)\n    (hA : A = B * C) : det A = det B", "start": [429, 1], "end": [434, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_of_eq_det_one_mul", "code": "theorem det_eq_of_eq_det_one_mul {A B : Matrix n n R} (C : Matrix n n R) (hC : det C = 1)\n    (hA : A = C * B) : det A = det B", "start": [437, 1], "end": [442, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_updateRow_add_self", "code": "theorem det_updateRow_add_self (A : Matrix n n R) {i j : n} (hij : i \u2260 j) :\n    det (updateRow A i (A i + A j)) = det A", "start": [445, 1], "end": [448, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_updateColumn_add_self", "code": "theorem det_updateColumn_add_self (A : Matrix n n R) {i j : n} (hij : i \u2260 j) :\n    det (updateColumn A i fun k => A k i + A k j) = det A", "start": [451, 1], "end": [454, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_updateRow_add_smul_self", "code": "theorem det_updateRow_add_smul_self (A : Matrix n n R) {i j : n} (hij : i \u2260 j) (c : R) :\n    det (updateRow A i (A i + c \u2022 A j)) = det A", "start": [457, 1], "end": [460, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_updateColumn_add_smul_self", "code": "theorem det_updateColumn_add_smul_self (A : Matrix n n R) {i j : n} (hij : i \u2260 j) (c : R) :\n    det (updateColumn A i fun k => A k i + c \u2022 A k j) = det A", "start": [463, 1], "end": [466, 45], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_of_forall_row_eq_smul_add_const_aux", "code": "theorem det_eq_of_forall_row_eq_smul_add_const_aux {A B : Matrix n n R} {s : Finset n} :\n    \u2200 (c : n \u2192 R) (_ : \u2200 i, i \u2209 s \u2192 c i = 0) (k : n) (_ : k \u2209 s)\n      (_: \u2200 i j, A i j = B i j + c i * B k j), det A = det B", "start": [469, 1], "end": [499, 84], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_of_forall_row_eq_smul_add_const", "code": "theorem det_eq_of_forall_row_eq_smul_add_const {A B : Matrix n n R} (c : n \u2192 R) (k : n)\n    (hk : c k = 0) (A_eq : \u2200 i j, A i j = B i j + c i * B k j) : det A = det B", "start": [502, 1], "end": [510, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_of_forall_row_eq_smul_add_pred_aux", "code": "theorem det_eq_of_forall_row_eq_smul_add_pred_aux {n : \u2115} (k : Fin (n + 1)) :\n    \u2200 (c : Fin n \u2192 R) (_hc : \u2200 i : Fin n, k < i.succ \u2192 c i = 0)\n      {M N : Matrix (Fin n.succ) (Fin n.succ) R} (_h0 : \u2200 j, M 0 j = N 0 j)\n      (_hsucc : \u2200 (i : Fin n) (j), M i.succ j = N i.succ j + c i * M (Fin.castSucc i) j),\n      det M = det N", "start": [513, 1], "end": [548, 89], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_of_forall_row_eq_smul_add_pred", "code": "theorem det_eq_of_forall_row_eq_smul_add_pred {n : \u2115} {A B : Matrix (Fin (n + 1)) (Fin (n + 1)) R}\n    (c : Fin n \u2192 R) (A_zero : \u2200 j, A 0 j = B 0 j)\n    (A_succ : \u2200 (i : Fin n) (j), A i.succ j = B i.succ j + c i * A (Fin.castSucc i) j) :\n    det A = det B", "start": [551, 1], "end": [557, 73], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_of_forall_col_eq_smul_add_pred", "code": "theorem det_eq_of_forall_col_eq_smul_add_pred {n : \u2115} {A B : Matrix (Fin (n + 1)) (Fin (n + 1)) R}\n    (c : Fin n \u2192 R) (A_zero : \u2200 i, A i 0 = B i 0)\n    (A_succ : \u2200 (i) (j : Fin n), A i j.succ = B i j.succ + c j * A i (Fin.castSucc j)) :\n    det A = det B", "start": [560, 1], "end": [566, 77], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_blockDiagonal", "code": "@[simp]\ntheorem det_blockDiagonal {o : Type*} [Fintype o] [DecidableEq o] (M : o \u2192 Matrix n n R) :\n    (blockDiagonal M).det = \u220f k, (M k).det", "start": [571, 1], "end": [640, 14], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_fromBlocks_zero\u2082\u2081", "code": "@[simp]\ntheorem det_fromBlocks_zero\u2082\u2081 (A : Matrix m m R) (B : Matrix m n R) (D : Matrix n n R) :\n    (Matrix.fromBlocks A B 0 D).det = A.det * D.det", "start": [643, 1], "end": [696, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_fromBlocks_zero\u2081\u2082", "code": "@[simp]\ntheorem det_fromBlocks_zero\u2081\u2082 (A : Matrix m m R) (C : Matrix n m R) (D : Matrix n n R) :\n    (Matrix.fromBlocks A 0 C D).det = A.det * D.det", "start": [699, 1], "end": [706, 19], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_succ_column_zero", "code": "theorem det_succ_column_zero {n : \u2115} (A : Matrix (Fin n.succ) (Fin n.succ) R) :\n    det A = \u2211 i : Fin n.succ, (-1) ^ (i : \u2115) * A i 0 * det (A.submatrix i.succAbove Fin.succ)", "start": [709, 1], "end": [738, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_succ_row_zero", "code": "theorem det_succ_row_zero {n : \u2115} (A : Matrix (Fin n.succ) (Fin n.succ) R) :\n    det A = \u2211 j : Fin n.succ, (-1) ^ (j : \u2115) * A 0 j * det (A.submatrix Fin.succ j.succAbove)", "start": [741, 1], "end": [747, 72], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_succ_row", "code": "theorem det_succ_row {n : \u2115} (A : Matrix (Fin n.succ) (Fin n.succ) R) (i : Fin n.succ) :\n    det A =\n      \u2211 j : Fin n.succ, (-1) ^ (i + j : \u2115) * A i j * det (A.submatrix i.succAbove j.succAbove)", "start": [750, 1], "end": [767, 54], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_succ_column", "code": "theorem det_succ_column {n : \u2115} (A : Matrix (Fin n.succ) (Fin n.succ) R) (j : Fin n.succ) :\n    det A =\n      \u2211 i : Fin n.succ, (-1) ^ (i + j : \u2115) * A i j * det (A.submatrix i.succAbove j.succAbove)", "start": [770, 1], "end": [776, 92], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_fin_zero", "code": "@[simp]\ntheorem det_fin_zero {A : Matrix (Fin 0) (Fin 0) R} : det A = 1", "start": [779, 1], "end": [782, 14], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_fin_one", "code": "theorem det_fin_one (A : Matrix (Fin 1) (Fin 1) R) : det A = A 0 0", "start": [785, 1], "end": [787, 15], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_fin_one_of", "code": "theorem det_fin_one_of (a : R) : det !![a] = a", "start": [790, 1], "end": [791, 16], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_fin_two", "code": "theorem det_fin_two (A : Matrix (Fin 2) (Fin 2) R) : det A = A 0 0 * A 1 1 - A 0 1 * A 1 0", "start": [794, 1], "end": [799, 7], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_fin_two_of", "code": "@[simp]\ntheorem det_fin_two_of (a b c d : R) : Matrix.det !![a, b; c, d] = a * d - b * c", "start": [802, 1], "end": [804, 16], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_fin_three", "code": "theorem det_fin_three (A : Matrix (Fin 3) (Fin 3) R) :\n    det A =\n      A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1\n      - A 0 1 * A 1 0 * A 2 2 + A 0 1 * A 1 2 * A 2 0\n      + A 0 2 * A 1 0 * A 2 1 - A 0 2 * A 1 1 * A 2 0", "start": [807, 1], "end": [817, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/MvPolynomial/Equiv.lean", "imports": ["Mathlib/Logic/Equiv/Fin.lean", "Mathlib/Data/MvPolynomial/Rename.lean", "Mathlib/Data/Polynomial/AlgebraMap.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Fin.lean", "Mathlib/Data/Finsupp/Fin.lean", "Mathlib/Data/MvPolynomial/Variables.lean"], "premises": [{"full_name": "MvPolynomial.pUnitAlgEquiv", "code": "@[simps]\ndef pUnitAlgEquiv : MvPolynomial PUnit R \u2243\u2090[R] R[X] where\n  toFun := eval\u2082 Polynomial.C fun _ => Polynomial.X\n  invFun := Polynomial.eval\u2082 MvPolynomial.C (X PUnit.unit)\n  left_inv := by\n    let f : R[X] \u2192+* MvPolynomial PUnit R := Polynomial.eval\u2082RingHom MvPolynomial.C (X PUnit.unit)\n    let g : MvPolynomial PUnit R \u2192+* R[X] := eval\u2082Hom Polynomial.C fun _ => Polynomial.X\n    show \u2200 p, f.comp g p = p\n    apply is_id\n    \u00b7 ext a\n      dsimp\n      rw [eval\u2082_C, Polynomial.eval\u2082_C]\n    \u00b7 rintro \u27e8\u27e9\n      dsimp\n      rw [eval\u2082_X, Polynomial.eval\u2082_X]\n  right_inv p :=\n    Polynomial.induction_on p (fun a => by rw [Polynomial.eval\u2082_C, MvPolynomial.eval\u2082_C])\n    (fun p q hp hq => by rw [Polynomial.eval\u2082_add, MvPolynomial.eval\u2082_add, hp, hq]) fun p n _ => by\n      rw [Polynomial.eval\u2082_mul, Polynomial.eval\u2082_pow, Polynomial.eval\u2082_X, Polynomial.eval\u2082_C,\n        eval\u2082_mul, eval\u2082_C, eval\u2082_pow, eval\u2082_X]\n  map_mul' _ _ := eval\u2082_mul _ _\n  map_add' _ _ := eval\u2082_add _ _\n  commutes' _ := eval\u2082_C _ _ _", "start": [61, 1], "end": [86, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mapEquiv", "code": "@[simps apply]\ndef mapEquiv [CommSemiring S\u2081] [CommSemiring S\u2082] (e : S\u2081 \u2243+* S\u2082) :\n    MvPolynomial \u03c3 S\u2081 \u2243+* MvPolynomial \u03c3 S\u2082 :=\n  { map (e : S\u2081 \u2192+* S\u2082) with\n    toFun := map (e : S\u2081 \u2192+* S\u2082)\n    invFun := map (e.symm : S\u2082 \u2192+* S\u2081)\n    left_inv := map_leftInverse e.left_inv\n    right_inv := map_rightInverse e.right_inv }", "start": [93, 1], "end": [101, 48], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mapEquiv_refl", "code": "@[simp]\ntheorem mapEquiv_refl : mapEquiv \u03c3 (RingEquiv.refl R) = RingEquiv.refl _", "start": [104, 1], "end": [106, 23], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mapEquiv_symm", "code": "@[simp]\ntheorem mapEquiv_symm [CommSemiring S\u2081] [CommSemiring S\u2082] (e : S\u2081 \u2243+* S\u2082) :\n    (mapEquiv \u03c3 e).symm = mapEquiv \u03c3 e.symm", "start": [109, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mapEquiv_trans", "code": "@[simp]\ntheorem mapEquiv_trans [CommSemiring S\u2081] [CommSemiring S\u2082] [CommSemiring S\u2083] (e : S\u2081 \u2243+* S\u2082)\n    (f : S\u2082 \u2243+* S\u2083) : (mapEquiv \u03c3 e).trans (mapEquiv \u03c3 f) = mapEquiv \u03c3 (e.trans f)", "start": [115, 1], "end": [120, 15], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mapAlgEquiv", "code": "@[simps apply]\ndef mapAlgEquiv (e : A\u2081 \u2243\u2090[R] A\u2082) : MvPolynomial \u03c3 A\u2081 \u2243\u2090[R] MvPolynomial \u03c3 A\u2082 :=\n  { mapAlgHom (e : A\u2081 \u2192\u2090[R] A\u2082), mapEquiv \u03c3 (e : A\u2081 \u2243+* A\u2082) with toFun := map (e : A\u2081 \u2192+* A\u2082) }", "start": [127, 1], "end": [130, 96], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mapAlgEquiv_refl", "code": "@[simp]\ntheorem mapAlgEquiv_refl : mapAlgEquiv \u03c3 (AlgEquiv.refl : A\u2081 \u2243\u2090[R] A\u2081) = AlgEquiv.refl", "start": [133, 1], "end": [135, 22], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mapAlgEquiv_symm", "code": "@[simp]\ntheorem mapAlgEquiv_symm (e : A\u2081 \u2243\u2090[R] A\u2082) : (mapAlgEquiv \u03c3 e).symm = mapAlgEquiv \u03c3 e.symm", "start": [138, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mapAlgEquiv_trans", "code": "@[simp]\ntheorem mapAlgEquiv_trans (e : A\u2081 \u2243\u2090[R] A\u2082) (f : A\u2082 \u2243\u2090[R] A\u2083) :\n    (mapAlgEquiv \u03c3 e).trans (mapAlgEquiv \u03c3 f) = mapAlgEquiv \u03c3 (e.trans f)", "start": [143, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.sumToIter", "code": "def sumToIter : MvPolynomial (Sum S\u2081 S\u2082) R \u2192+* MvPolynomial S\u2081 (MvPolynomial S\u2082 R) :=\n  eval\u2082Hom (C.comp C) fun bc => Sum.recOn bc X (C \u2218 X)", "start": [157, 1], "end": [164, 55], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.sumToIter_C", "code": "@[simp]\ntheorem sumToIter_C (a : R) : sumToIter R S\u2081 S\u2082 (C a) = C (C a)", "start": [167, 1], "end": [169, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.sumToIter_Xl", "code": "@[simp]\ntheorem sumToIter_Xl (b : S\u2081) : sumToIter R S\u2081 S\u2082 (X (Sum.inl b)) = X b", "start": [173, 1], "end": [175, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.sumToIter_Xr", "code": "@[simp]\ntheorem sumToIter_Xr (c : S\u2082) : sumToIter R S\u2081 S\u2082 (X (Sum.inr c)) = C (X c)", "start": [179, 1], "end": [181, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.iterToSum", "code": "def iterToSum : MvPolynomial S\u2081 (MvPolynomial S\u2082 R) \u2192+* MvPolynomial (Sum S\u2081 S\u2082) R :=\n  eval\u2082Hom (eval\u2082Hom C (X \u2218 Sum.inr)) (X \u2218 Sum.inl)", "start": [185, 1], "end": [192, 52], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.iterToSum_C_C", "code": "theorem iterToSum_C_C (a : R) : iterToSum R S\u2081 S\u2082 (C (C a)) = C a", "start": [195, 1], "end": [196, 47], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.iterToSum_X", "code": "theorem iterToSum_X (b : S\u2081) : iterToSum R S\u2081 S\u2082 (X b) = X (Sum.inl b)", "start": [200, 1], "end": [201, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.iterToSum_C_X", "code": "theorem iterToSum_C_X (c : S\u2082) : iterToSum R S\u2081 S\u2082 (C (X c)) = X (Sum.inr c)", "start": [205, 1], "end": [206, 47], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isEmptyAlgEquiv", "code": "@[simps!]\ndef isEmptyAlgEquiv [he : IsEmpty \u03c3] : MvPolynomial \u03c3 R \u2243\u2090[R] R :=\n  AlgEquiv.ofAlgHom (aeval (IsEmpty.elim he)) (Algebra.ofId _ _)\n    (by\n      ext\n      simp [Algebra.ofId_apply, algebraMap_eq])\n    (by\n      ext i m\n      exact IsEmpty.elim' he i)", "start": [212, 1], "end": [222, 32], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isEmptyRingEquiv", "code": "@[simps!]\ndef isEmptyRingEquiv [IsEmpty \u03c3] : MvPolynomial \u03c3 R \u2243+* R :=\n  (isEmptyAlgEquiv R \u03c3).toRingEquiv", "start": [225, 1], "end": [229, 36], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mvPolynomialEquivMvPolynomial", "code": "@[simps]\ndef mvPolynomialEquivMvPolynomial [CommSemiring S\u2083] (f : MvPolynomial S\u2081 R \u2192+* MvPolynomial S\u2082 S\u2083)\n    (g : MvPolynomial S\u2082 S\u2083 \u2192+* MvPolynomial S\u2081 R) (hfgC : (f.comp g).comp C = C)\n    (hfgX : \u2200 n, f (g (X n)) = X n) (hgfC : (g.comp f).comp C = C) (hgfX : \u2200 n, g (f (X n)) = X n) :\n    MvPolynomial S\u2081 R \u2243+* MvPolynomial S\u2082 S\u2083\n    where\n  toFun := f\n  invFun := g\n  left_inv := is_id (RingHom.comp _ _) hgfC hgfX\n  right_inv := is_id (RingHom.comp _ _) hfgC hfgX\n  map_mul' := f.map_mul\n  map_add' := f.map_add", "start": [234, 1], "end": [246, 24], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.sumRingEquiv", "code": "def sumRingEquiv : MvPolynomial (Sum S\u2081 S\u2082) R \u2243+* MvPolynomial S\u2081 (MvPolynomial S\u2082 R) := by\n  apply mvPolynomialEquivMvPolynomial R (Sum S\u2081 S\u2082) _ _ (sumToIter R S\u2081 S\u2082) (iterToSum R S\u2081 S\u2082)\n  \u00b7 refine RingHom.ext (hom_eq_hom _ _ ?hC ?hX)\n    case hC => ext1; simp only [RingHom.comp_apply, iterToSum_C_C, sumToIter_C]\n    case hX => intro; simp only [RingHom.comp_apply, iterToSum_C_X, sumToIter_Xr]\n  \u00b7 simp [iterToSum_X, sumToIter_Xl]\n  \u00b7 ext1; simp only [RingHom.comp_apply, sumToIter_C, iterToSum_C_C]\n  \u00b7 rintro \u27e8\u27e9 <;> simp only [sumToIter_Xl, iterToSum_X, sumToIter_Xr, iterToSum_C_X]", "start": [249, 1], "end": [260, 85], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.sumAlgEquiv", "code": "def sumAlgEquiv : MvPolynomial (Sum S\u2081 S\u2082) R \u2243\u2090[R] MvPolynomial S\u2081 (MvPolynomial S\u2082 R) :=\n  { sumRingEquiv R S\u2081 S\u2082 with\n    commutes' := by\n      intro r\n      have A : algebraMap R (MvPolynomial S\u2081 (MvPolynomial S\u2082 R)) r = (C (C r) : _) := rfl\n      have B : algebraMap R (MvPolynomial (Sum S\u2081 S\u2082) R) r = C r := rfl\n      simp only [sumRingEquiv, mvPolynomialEquivMvPolynomial, Equiv.toFun_as_coe_apply,\n        Equiv.coe_fn_mk, B, sumToIter_C, A] }", "start": [263, 1], "end": [274, 46], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.optionEquivLeft", "code": "@[simps!]\ndef optionEquivLeft : MvPolynomial (Option S\u2081) R \u2243\u2090[R] Polynomial (MvPolynomial S\u2081 R) :=\n  AlgEquiv.ofAlgHom (MvPolynomial.aeval fun o => o.elim Polynomial.X fun s => Polynomial.C (X s))\n    (Polynomial.aevalTower (MvPolynomial.rename some) (X none))\n    (by ext : 2 <;> simp [\u2190 Polynomial.C_eq_algebraMap]) (by ext i : 2; cases i <;> simp)", "start": [282, 1], "end": [289, 90], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.optionEquivRight", "code": "def optionEquivRight : MvPolynomial (Option S\u2081) R \u2243\u2090[R] MvPolynomial S\u2081 R[X] :=\n  AlgEquiv.ofAlgHom (MvPolynomial.aeval fun o => o.elim (C Polynomial.X) X)\n    (MvPolynomial.aevalTower (Polynomial.aeval (X none)) fun i => X (Option.some i))\n    (by\n      ext : 2 <;>\n        simp only [MvPolynomial.algebraMap_eq, Option.elim, AlgHom.coe_comp, AlgHom.id_comp,\n          IsScalarTower.coe_toAlgHom', comp_apply, aevalTower_C, Polynomial.aeval_X, aeval_X,\n          Option.elim', aevalTower_X, AlgHom.coe_id, id.def, eq_self_iff_true, imp_true_iff])\n    (by\n      ext \u27e8i\u27e9 : 2 <;>\n        simp only [Option.elim, AlgHom.coe_comp, comp_apply, aeval_X, aevalTower_C,\n          Polynomial.aeval_X, AlgHom.coe_id, id.def, aevalTower_X])", "start": [294, 1], "end": [308, 68], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.finSuccEquiv", "code": "def finSuccEquiv : MvPolynomial (Fin (n + 1)) R \u2243\u2090[R] Polynomial (MvPolynomial (Fin n) R) :=\n  (renameEquiv R (_root_.finSuccEquiv n)).trans (optionEquivLeft R (Fin n))", "start": [313, 1], "end": [317, 76], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.finSuccEquiv_eq", "code": "theorem finSuccEquiv_eq :\n    (finSuccEquiv R n : MvPolynomial (Fin (n + 1)) R \u2192+* Polynomial (MvPolynomial (Fin n) R)) =\n      eval\u2082Hom (Polynomial.C.comp (C : R \u2192+* MvPolynomial (Fin n) R)) fun i : Fin (n + 1) =>\n        Fin.cases Polynomial.X (fun k => Polynomial.C (X k)) i", "start": [320, 1], "end": [328, 52], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.finSuccEquiv_apply", "code": "@[simp]\ntheorem finSuccEquiv_apply (p : MvPolynomial (Fin (n + 1)) R) :\n    finSuccEquiv R n p =\n      eval\u2082Hom (Polynomial.C.comp (C : R \u2192+* MvPolynomial (Fin n) R))\n        (fun i : Fin (n + 1) => Fin.cases Polynomial.X (fun k => Polynomial.C (X k)) i) p", "start": [331, 1], "end": [336, 42], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.finSuccEquiv_comp_C_eq_C", "code": "theorem finSuccEquiv_comp_C_eq_C {R : Type u} [CommSemiring R] (n : \u2115) :\n    (\u2191(MvPolynomial.finSuccEquiv R n).symm : Polynomial (MvPolynomial (Fin n) R) \u2192+* _).comp\n        (Polynomial.C.comp MvPolynomial.C) =\n      (MvPolynomial.C : R \u2192+* MvPolynomial (Fin n.succ) R)", "start": [339, 1], "end": [348, 71], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.finSuccEquiv_X_zero", "code": "theorem finSuccEquiv_X_zero : finSuccEquiv R n (X 0) = Polynomial.X", "start": [354, 1], "end": [354, 79], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.finSuccEquiv_X_succ", "code": "theorem finSuccEquiv_X_succ {j : Fin n} : finSuccEquiv R n (X j.succ) = Polynomial.C (X j)", "start": [358, 1], "end": [359, 7], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.finSuccEquiv_coeff_coeff", "code": "theorem finSuccEquiv_coeff_coeff (m : Fin n \u2192\u2080 \u2115) (f : MvPolynomial (Fin (n + 1)) R) (i : \u2115) :\n    coeff m (Polynomial.coeff (finSuccEquiv R n f) i) = coeff (m.cons i) f", "start": [363, 1], "end": [386, 38], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_eq_eval_mv_eval'", "code": "theorem eval_eq_eval_mv_eval' (s : Fin n \u2192 R) (y : R) (f : MvPolynomial (Fin (n + 1)) R) :\n    eval (Fin.cons y s : Fin (n + 1) \u2192 R) f =\n      Polynomial.eval y (Polynomial.map (eval s) (finSuccEquiv R n f))", "start": [389, 1], "end": [410, 32], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_eval_eq_eval_coeff", "code": "theorem coeff_eval_eq_eval_coeff (s' : Fin n \u2192 R) (f : Polynomial (MvPolynomial (Fin n) R))\n    (i : \u2115) : Polynomial.coeff (Polynomial.map (eval s') f) i = eval s' (Polynomial.coeff f i)", "start": [413, 1], "end": [415, 35], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_coeff_finSuccEquiv", "code": "theorem support_coeff_finSuccEquiv {f : MvPolynomial (Fin (n + 1)) R} {i : \u2115} {m : Fin n \u2192\u2080 \u2115} :\n    m \u2208 (Polynomial.coeff ((finSuccEquiv R n) f) i).support \u2194 Finsupp.cons i m \u2208 f.support", "start": [418, 1], "end": [424, 70], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_coeff_finSuccEquiv_add_le", "code": "lemma totalDegree_coeff_finSuccEquiv_add_le (f : MvPolynomial (Fin (n + 1)) R) (i : \u2115)\n    (hi : (finSuccEquiv R n f).coeff i \u2260 0) :\n    totalDegree ((finSuccEquiv R n f).coeff i) + i \u2264 totalDegree f := by\n  have hf'_sup : ((finSuccEquiv R n f).coeff i).support.Nonempty := by\n    rw [Finset.nonempty_iff_ne_empty, ne_eq, support_eq_empty]\n    exact hi\n  have \u27e8\u03c3, h\u03c31, h\u03c32\u27e9 := Finset.exists_mem_eq_sup (support _) hf'_sup\n                          (fun s => Finsupp.sum s fun _ e => e)\n  let \u03c3' : Fin (n+1) \u2192\u2080 \u2115 := cons i \u03c3\n  convert le_totalDegree (s := \u03c3') _\n  \u00b7 rw [totalDegree, h\u03c32, sum_cons, add_comm]\n  \u00b7 rw [\u2190support_coeff_finSuccEquiv]\n    exact h\u03c31", "start": [427, 1], "end": [445, 14], "kind": "mathlibtacticlemma"}, {"full_name": "MvPolynomial.finSuccEquiv_support", "code": "theorem finSuccEquiv_support (f : MvPolynomial (Fin (n + 1)) R) :\n    (finSuccEquiv R n f).support = Finset.image (fun m : Fin (n + 1) \u2192\u2080 \u2115 => m 0) f.support", "start": [447, 1], "end": [458, 76], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.finSuccEquiv_support'", "code": "theorem finSuccEquiv_support' {f : MvPolynomial (Fin (n + 1)) R} {i : \u2115} :\n    Finset.image (Finsupp.cons i) (Polynomial.coeff ((finSuccEquiv R n) f) i).support =\n      f.support.filter fun m => m 0 = i", "start": [461, 1], "end": [477, 15], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_finSuccEquiv_nonempty", "code": "theorem support_finSuccEquiv_nonempty {f : MvPolynomial (Fin (n + 1)) R} (h : f \u2260 0) :\n    (finSuccEquiv R n f).support.Nonempty", "start": [480, 1], "end": [489, 21], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degree_finSuccEquiv", "code": "theorem degree_finSuccEquiv {f : MvPolynomial (Fin (n + 1)) R} (h : f \u2260 0) :\n    (finSuccEquiv R n f).degree = degreeOf 0 f", "start": [492, 1], "end": [502, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.natDegree_finSuccEquiv", "code": "theorem natDegree_finSuccEquiv (f : MvPolynomial (Fin (n + 1)) R) :\n    (finSuccEquiv R n f).natDegree = degreeOf 0 f", "start": [505, 1], "end": [511, 9], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degreeOf_coeff_finSuccEquiv", "code": "theorem degreeOf_coeff_finSuccEquiv (p : MvPolynomial (Fin (n + 1)) R) (j : Fin n) (i : \u2115) :\n    degreeOf j (Polynomial.coeff (finSuccEquiv R n p) i) \u2264 degreeOf j.succ p", "start": [514, 1], "end": [521, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/MvPolynomial/CommRing.lean", "imports": ["Mathlib/Data/MvPolynomial/Variables.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvPolynomial.instCommRingMvPolynomial", "code": "instance instCommRingMvPolynomial : CommRing (MvPolynomial \u03c3 R) :=\n  AddMonoidAlgebra.commRing", "start": [56, 1], "end": [57, 28], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_sub", "code": "theorem C_sub : (C (a - a') : MvPolynomial \u03c3 R) = C a - C a'", "start": [62, 1], "end": [63, 24], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_neg", "code": "theorem C_neg : (C (-a) : MvPolynomial \u03c3 R) = -C a", "start": [68, 1], "end": [69, 22], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_neg", "code": "@[simp]\ntheorem coeff_neg (m : \u03c3 \u2192\u2080 \u2115) (p : MvPolynomial \u03c3 R) : coeff m (-p) = -coeff m p", "start": [73, 1], "end": [75, 24], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_sub", "code": "@[simp]\ntheorem coeff_sub (m : \u03c3 \u2192\u2080 \u2115) (p q : MvPolynomial \u03c3 R) : coeff m (p - q) = coeff m p - coeff m q", "start": [78, 1], "end": [80, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_neg", "code": "@[simp]\ntheorem support_neg : (-p).support = p.support", "start": [83, 1], "end": [85, 24], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_sub", "code": "theorem support_sub [DecidableEq \u03c3] (p q : MvPolynomial \u03c3 R) :\n    (p - q).support \u2286 p.support \u222a q.support", "start": [88, 1], "end": [90, 22], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_neg", "code": "theorem degrees_neg (p : MvPolynomial \u03c3 R) : (-p).degrees = p.degrees", "start": [97, 1], "end": [98, 33], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_sub", "code": "theorem degrees_sub [DecidableEq \u03c3] (p q : MvPolynomial \u03c3 R) :\n    (p - q).degrees \u2264 p.degrees \u2294 q.degrees", "start": [101, 1], "end": [103, 88], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_neg", "code": "@[simp]\ntheorem vars_neg : (-p).vars = p.vars", "start": [110, 1], "end": [111, 69], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_sub_subset", "code": "theorem vars_sub_subset [DecidableEq \u03c3] : (p - q).vars \u2286 p.vars \u222a q.vars", "start": [114, 1], "end": [115, 67], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_sub_of_disjoint", "code": "@[simp]\ntheorem vars_sub_of_disjoint [DecidableEq \u03c3] (hpq : Disjoint p.vars q.vars) :\n    (p - q).vars = p.vars \u222a q.vars", "start": [118, 1], "end": [122, 69], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_sub", "code": "@[simp]\ntheorem eval\u2082_sub : (p - q).eval\u2082 f g = p.eval\u2082 f g - q.eval\u2082 f g", "start": [133, 1], "end": [135, 29], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_sub", "code": "theorem eval_sub (f : \u03c3 \u2192 R) : eval f (p - q) = eval f p - eval f q", "start": [138, 1], "end": [139, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_neg", "code": "@[simp]\ntheorem eval\u2082_neg : (-p).eval\u2082 f g = -p.eval\u2082 f g", "start": [141, 1], "end": [143, 27], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_neg", "code": "theorem eval_neg (f : \u03c3 \u2192 R) : eval f (-p) = -eval f p", "start": [146, 1], "end": [147, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.hom_C", "code": "theorem hom_C (f : MvPolynomial \u03c3 \u2124 \u2192+* S) (n : \u2124) : f (C n) = (n : S)", "start": [149, 1], "end": [150, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom_X", "code": "@[simp]\ntheorem eval\u2082Hom_X {R : Type u} (c : \u2124 \u2192+* S) (f : MvPolynomial R \u2124 \u2192+* S) (x : MvPolynomial R \u2124) :\n    eval\u2082 c (f \u2218 X) x = f x", "start": [154, 1], "end": [168, 34], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.homEquiv", "code": "def homEquiv : (MvPolynomial \u03c3 \u2124 \u2192+* S) \u2243 (\u03c3 \u2192 S) where\n  toFun f := f \u2218 X\n  invFun f := eval\u2082Hom (Int.castRingHom S) f\n  left_inv f := RingHom.ext <| eval\u2082Hom_X _ _\n  right_inv f := funext fun x => by simp only [coe_eval\u2082Hom, Function.comp_apply, eval\u2082_X]", "start": [172, 1], "end": [178, 91], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degreeOf_sub_lt", "code": "theorem degreeOf_sub_lt {x : \u03c3} {f g : MvPolynomial \u03c3 R} {k : \u2115} (h : 0 < k)\n    (hf : \u2200 m : \u03c3 \u2192\u2080 \u2115, m \u2208 f.support \u2192 k \u2264 m x \u2192 coeff m f = coeff m g)\n    (hg : \u2200 m : \u03c3 \u2192\u2080 \u2115, m \u2208 g.support \u2192 k \u2264 m x \u2192 coeff m f = coeff m g) :\n    degreeOf x (f - g) < k", "start": [185, 1], "end": [197, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_neg", "code": "@[simp]\ntheorem totalDegree_neg (a : MvPolynomial \u03c3 R) : (-a).totalDegree = a.totalDegree", "start": [204, 1], "end": [206, 39], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_sub", "code": "theorem totalDegree_sub (a b : MvPolynomial \u03c3 R) :\n    (a - b).totalDegree \u2264 max a.totalDegree b.totalDegree", "start": [209, 1], "end": [214, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Polynomial/Content.lean", "imports": ["Mathlib/Data/Polynomial/FieldDivision.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Polynomial/CancelLeads.lean", "Mathlib/Algebra/GCDMonoid/Finset.lean", "Mathlib/Data/Polynomial/EraseLead.lean"], "premises": [{"full_name": "Polynomial.IsPrimitive", "code": "def IsPrimitive (p : R[X]) : Prop :=\n  \u2200 r : R, C r \u2223 p \u2192 IsUnit r", "start": [41, 1], "end": [43, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isPrimitive_iff_isUnit_of_C_dvd", "code": "theorem isPrimitive_iff_isUnit_of_C_dvd {p : R[X]} : p.IsPrimitive \u2194 \u2200 r : R, C r \u2223 p \u2192 IsUnit r", "start": [46, 1], "end": [47, 10], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isPrimitive_one", "code": "@[simp]\ntheorem isPrimitive_one : IsPrimitive (1 : R[X])", "start": [51, 1], "end": [53, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.isPrimitive", "code": "theorem Monic.isPrimitive {p : R[X]} (hp : p.Monic) : p.IsPrimitive", "start": [56, 1], "end": [58, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsPrimitive.ne_zero", "code": "theorem IsPrimitive.ne_zero [Nontrivial R] {p : R[X]} (hp : p.IsPrimitive) : p \u2260 0", "start": [61, 1], "end": [63, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isPrimitive_of_dvd", "code": "theorem isPrimitive_of_dvd {p q : R[X]} (hp : IsPrimitive p) (hq : q \u2223 p) : IsPrimitive q", "start": [66, 1], "end": [67, 72], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content", "code": "def content (p : R[X]) : R :=\n  p.support.gcd p.coeff", "start": [78, 1], "end": [80, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_dvd_coeff", "code": "theorem content_dvd_coeff {p : R[X]} (n : \u2115) : p.content \u2223 p.coeff n", "start": [83, 1], "end": [88, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_C", "code": "@[simp]\ntheorem content_C {r : R} : (C r).content = normalize r", "start": [91, 1], "end": [97, 11], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_zero", "code": "@[simp]\ntheorem content_zero : content (0 : R[X]) = 0", "start": [101, 1], "end": [102, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_one", "code": "@[simp]\ntheorem content_one : content (1 : R[X]) = 1", "start": [105, 1], "end": [106, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_X_mul", "code": "theorem content_X_mul {p : R[X]} : content (X * p) = content p", "start": [109, 1], "end": [129, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_X_pow", "code": "@[simp]\ntheorem content_X_pow {k : \u2115} : content ((X : R[X]) ^ k) = 1", "start": [133, 1], "end": [137, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_X", "code": "@[simp]\ntheorem content_X : content (X : R[X]) = 1", "start": [141, 1], "end": [142, 94], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_C_mul", "code": "theorem content_C_mul (r : R) (p : R[X]) : (C r * p).content = normalize r * p.content", "start": [146, 1], "end": [149, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_monomial", "code": "@[simp]\ntheorem content_monomial {r : R} {k : \u2115} : content (monomial k r) = normalize r", "start": [153, 1], "end": [155, 72], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_eq_zero_iff", "code": "theorem content_eq_zero_iff {p : R[X]} : content p = 0 \u2194 p = 0", "start": [158, 1], "end": [168, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.normalize_content", "code": "theorem normalize_content {p : R[X]} : normalize p.content = p.content", "start": [172, 1], "end": [173, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.normUnit_content", "code": "@[simp]\ntheorem normUnit_content {p : R[X]} : normUnit (content p) = 1", "start": [176, 1], "end": [182, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_eq_gcd_range_of_lt", "code": "theorem content_eq_gcd_range_of_lt (p : R[X]) (n : \u2115) (h : p.natDegree < n) :\n    p.content = (Finset.range n).gcd p.coeff", "start": [184, 1], "end": [195, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_eq_gcd_range_succ", "code": "theorem content_eq_gcd_range_succ (p : R[X]) :\n    p.content = (Finset.range p.natDegree.succ).gcd p.coeff", "start": [198, 1], "end": [200, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_eq_gcd_leadingCoeff_content_eraseLead", "code": "theorem content_eq_gcd_leadingCoeff_content_eraseLead (p : R[X]) :\n    p.content = GCDMonoid.gcd p.leadingCoeff (eraseLead p).content", "start": [203, 1], "end": [212, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dvd_content_iff_C_dvd", "code": "theorem dvd_content_iff_C_dvd {p : R[X]} {r : R} : r \u2223 p.content \u2194 C r \u2223 p", "start": [215, 1], "end": [223, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_content_dvd", "code": "theorem C_content_dvd (p : R[X]) : C p.content \u2223 p", "start": [227, 1], "end": [228, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isPrimitive_iff_content_eq_one", "code": "theorem isPrimitive_iff_content_eq_one {p : R[X]} : p.IsPrimitive \u2194 p.content = 1", "start": [232, 1], "end": [235, 95], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsPrimitive.content_eq_one", "code": "theorem IsPrimitive.content_eq_one {p : R[X]} (hp : p.IsPrimitive) : p.content = 1", "start": [238, 1], "end": [239, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.primPart", "code": "noncomputable def primPart (p : R[X]) : R[X] :=\n  letI := Classical.decEq R\n  if p = 0 then 1 else Classical.choose (C_content_dvd p)", "start": [244, 1], "end": [248, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_C_content_mul_primPart", "code": "theorem eq_C_content_mul_primPart (p : R[X]) : p = C p.content * p.primPart", "start": [251, 1], "end": [253, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.primPart_zero", "code": "@[simp]\ntheorem primPart_zero : primPart (0 : R[X]) = 1", "start": [257, 1], "end": [259, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isPrimitive_primPart", "code": "theorem isPrimitive_primPart (p : R[X]) : p.primPart.IsPrimitive", "start": [262, 1], "end": [267, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_primPart", "code": "theorem content_primPart (p : R[X]) : p.primPart.content = 1", "start": [270, 1], "end": [271, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.primPart_ne_zero", "code": "theorem primPart_ne_zero (p : R[X]) : p.primPart \u2260 0", "start": [274, 1], "end": [275, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_primPart", "code": "theorem natDegree_primPart (p : R[X]) : p.primPart.natDegree = p.natDegree", "start": [278, 1], "end": [283, 96], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsPrimitive.primPart_eq", "code": "@[simp]\ntheorem IsPrimitive.primPart_eq {p : R[X]} (hp : p.IsPrimitive) : p.primPart = p", "start": [286, 1], "end": [288, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isUnit_primPart_C", "code": "theorem isUnit_primPart_C (r : R) : IsUnit (C r).primPart", "start": [291, 1], "end": [303, 65], "kind": "commanddeclaration"}, {"full_name": "Polynomial.primPart_dvd", "code": "theorem primPart_dvd (p : R[X]) : p.primPart \u2223 p", "start": [307, 1], "end": [308, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_primPart_eq_zero", "code": "theorem aeval_primPart_eq_zero {S : Type*} [Ring S] [IsDomain S] [Algebra R S]\n    [NoZeroSMulDivisors R S] {p : R[X]} {s : S} (hpzero : p \u2260 0) (hp : aeval s p = 0) :\n    aeval s p.primPart = 0", "start": [311, 1], "end": [318, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_primPart_eq_zero", "code": "theorem eval\u2082_primPart_eq_zero {S : Type*} [CommRing S] [IsDomain S] {f : R \u2192+* S}\n    (hinj : Function.Injective f) {p : R[X]} {s : S} (hpzero : p \u2260 0) (hp : eval\u2082 f s p = 0) :\n    eval\u2082 f s p.primPart = 0", "start": [321, 1], "end": [328, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.gcd_content_eq_of_dvd_sub", "code": "theorem gcd_content_eq_of_dvd_sub {a : R} {p q : R[X]} (h : C a \u2223 p - q) :\n    GCDMonoid.gcd a p.content = GCDMonoid.gcd a q.content", "start": [333, 1], "end": [343, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_mul_aux", "code": "theorem content_mul_aux {p q : R[X]} :\n    GCDMonoid.gcd (p * q).eraseLead.content p.leadingCoeff =\n      GCDMonoid.gcd (p.eraseLead * q).content p.leadingCoeff", "start": [346, 1], "end": [353, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.content_mul", "code": "@[simp]\ntheorem content_mul {p q : R[X]} : (p * q).content = p.content * q.content", "start": [356, 1], "end": [401, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsPrimitive.mul", "code": "theorem IsPrimitive.mul {p q : R[X]} (hp : p.IsPrimitive) (hq : q.IsPrimitive) :\n    (p * q).IsPrimitive", "start": [404, 1], "end": [406, 98], "kind": "commanddeclaration"}, {"full_name": "Polynomial.primPart_mul", "code": "@[simp]\ntheorem primPart_mul {p q : R[X]} (h0 : p * q \u2260 0) :\n    (p * q).primPart = p.primPart * q.primPart", "start": [409, 1], "end": [418, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsPrimitive.dvd_primPart_iff_dvd", "code": "theorem IsPrimitive.dvd_primPart_iff_dvd {p q : R[X]} (hp : p.IsPrimitive) (hq : q \u2260 0) :\n    p \u2223 q.primPart \u2194 p \u2223 q", "start": [421, 1], "end": [426, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_primitive_lcm_of_isPrimitive", "code": "theorem exists_primitive_lcm_of_isPrimitive {p q : R[X]} (hp : p.IsPrimitive) (hq : q.IsPrimitive) :\n    \u2203 r : R[X], r.IsPrimitive \u2227 \u2200 s : R[X], p \u2223 s \u2227 q \u2223 s \u2194 r \u2223 s", "start": [429, 1], "end": [469, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dvd_iff_content_dvd_content_and_primPart_dvd_primPart", "code": "theorem dvd_iff_content_dvd_content_and_primPart_dvd_primPart {p q : R[X]} (hq : q \u2260 0) :\n    p \u2223 q \u2194 p.content \u2223 q.content \u2227 p.primPart \u2223 q.primPart", "start": [472, 1], "end": [479, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.normalizedGcdMonoid", "code": "noncomputable instance (priority := 100) normalizedGcdMonoid : NormalizedGCDMonoid R[X] :=\n  letI := Classical.decEq R\n  normalizedGCDMonoidOfExistsLCM fun p q => by\n    rcases exists_primitive_lcm_of_isPrimitive p.isPrimitive_primPart\n        q.isPrimitive_primPart with\n      \u27e8r, rprim, hr\u27e9\n    refine' \u27e8C (lcm p.content q.content) * r, fun s => _\u27e9\n    by_cases hs : s = 0\n    \u00b7 simp [hs]\n    by_cases hpq : C (lcm p.content q.content) = 0\n    \u00b7 rw [C_eq_zero, lcm_eq_zero_iff, content_eq_zero_iff, content_eq_zero_iff] at hpq\n      rcases hpq with (hpq | hpq) <;> simp [hpq, hs]\n    iterate 3 rw [dvd_iff_content_dvd_content_and_primPart_dvd_primPart hs]\n    rw [content_mul, rprim.content_eq_one, mul_one, content_C, normalize_lcm, lcm_dvd_iff,\n      primPart_mul (mul_ne_zero hpq rprim.ne_zero), rprim.primPart_eq,\n      IsUnit.mul_left_dvd _ _ _ (isUnit_primPart_C (lcm p.content q.content)), \u2190 hr s.primPart]\n    tauto", "start": [482, 1], "end": [498, 10], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_gcd_le_left", "code": "theorem degree_gcd_le_left {p : R[X]} (hp : p \u2260 0) (q) : (gcd p q).degree \u2264 p.degree", "start": [501, 1], "end": [503, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_gcd_le_right", "code": "theorem degree_gcd_le_right (p) {q : R[X]} (hq : q \u2260 0) : (gcd p q).degree \u2264 q.degree", "start": [506, 1], "end": [508, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "imports": ["Mathlib/MeasureTheory/Measure/NullMeasurable.lean", "Mathlib/Topology/Algebra/Order/LiminfLimsup.lean", "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.ae_isMeasurablyGenerated", "code": "instance ae_isMeasurablyGenerated : IsMeasurablyGenerated \u03bc.ae :=\n  \u27e8fun _s hs =>\n    let \u27e8t, hst, htm, ht\u03bc\u27e9 := exists_measurable_superset_of_null hs\n    \u27e8t\u1d9c, compl_mem_ae_iff.2 ht\u03bc, htm.compl, compl_subset_comm.1 hst\u27e9\u27e9", "start": [112, 1], "end": [115, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_uIoc_iff", "code": "theorem ae_uIoc_iff [LinearOrder \u03b1] {a b : \u03b1} {P : \u03b1 \u2192 Prop} :\n    (\u2200\u1d50 x \u2202\u03bc, x \u2208 \u0399 a b \u2192 P x) \u2194 (\u2200\u1d50 x \u2202\u03bc, x \u2208 Ioc a b \u2192 P x) \u2227 \u2200\u1d50 x \u2202\u03bc, x \u2208 Ioc b a \u2192 P x", "start": [118, 1], "end": [121, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union", "code": "theorem measure_union (hd : Disjoint s\u2081 s\u2082) (h : MeasurableSet s\u2082) : \u03bc (s\u2081 \u222a s\u2082) = \u03bc s\u2081 + \u03bc s\u2082", "start": [124, 1], "end": [125, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union'", "code": "theorem measure_union' (hd : Disjoint s\u2081 s\u2082) (h : MeasurableSet s\u2081) : \u03bc (s\u2081 \u222a s\u2082) = \u03bc s\u2081 + \u03bc s\u2082", "start": [128, 1], "end": [129, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_inter_add_diff", "code": "theorem measure_inter_add_diff (s : Set \u03b1) (ht : MeasurableSet t) : \u03bc (s \u2229 t) + \u03bc (s \\ t) = \u03bc s", "start": [132, 1], "end": [133, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_diff_add_inter", "code": "theorem measure_diff_add_inter (s : Set \u03b1) (ht : MeasurableSet t) : \u03bc (s \\ t) + \u03bc (s \u2229 t) = \u03bc s", "start": [136, 1], "end": [137, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union_add_inter", "code": "theorem measure_union_add_inter (s : Set \u03b1) (ht : MeasurableSet t) :\n    \u03bc (s \u222a t) + \u03bc (s \u2229 t) = \u03bc s + \u03bc t", "start": [140, 1], "end": [144, 9], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union_add_inter'", "code": "theorem measure_union_add_inter' (hs : MeasurableSet s) (t : Set \u03b1) :\n    \u03bc (s \u222a t) + \u03bc (s \u2229 t) = \u03bc s + \u03bc t", "start": [147, 1], "end": [149, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_symmDiff_eq", "code": "lemma measure_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    \u03bc (s \u2206 t) = \u03bc (s \\ t) + \u03bc (t \\ s) := by\n  simpa only [symmDiff_def, sup_eq_union] using measure_union disjoint_sdiff_sdiff (ht.diff hs)", "start": [152, 1], "end": [154, 96], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.measure_symmDiff_le", "code": "lemma measure_symmDiff_le (s t u : Set \u03b1) :\n    \u03bc (s \u2206 u) \u2264 \u03bc (s \u2206 t) + \u03bc (t \u2206 u) :=\n  le_trans (\u03bc.mono $ symmDiff_triangle s t u) (measure_union_le (s \u2206 t) (t \u2206 u))", "start": [156, 1], "end": [158, 81], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.measure_add_measure_compl", "code": "theorem measure_add_measure_compl (h : MeasurableSet s) : \u03bc s + \u03bc s\u1d9c = \u03bc univ", "start": [160, 1], "end": [161, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_biUnion\u2080", "code": "theorem measure_biUnion\u2080 {s : Set \u03b2} {f : \u03b2 \u2192 Set \u03b1} (hs : s.Countable)\n    (hd : s.Pairwise (AEDisjoint \u03bc on f)) (h : \u2200 b \u2208 s, NullMeasurableSet (f b) \u03bc) :\n    \u03bc (\u22c3 b \u2208 s, f b) = \u2211' p : s, \u03bc (f p)", "start": [164, 1], "end": [169, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_biUnion", "code": "theorem measure_biUnion {s : Set \u03b2} {f : \u03b2 \u2192 Set \u03b1} (hs : s.Countable) (hd : s.PairwiseDisjoint f)\n    (h : \u2200 b \u2208 s, MeasurableSet (f b)) : \u03bc (\u22c3 b \u2208 s, f b) = \u2211' p : s, \u03bc (f p)", "start": [172, 1], "end": [174, 75], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_sUnion\u2080", "code": "theorem measure_sUnion\u2080 {S : Set (Set \u03b1)} (hs : S.Countable) (hd : S.Pairwise (AEDisjoint \u03bc))\n    (h : \u2200 s \u2208 S, NullMeasurableSet s \u03bc) : \u03bc (\u22c3\u2080 S) = \u2211' s : S, \u03bc s", "start": [177, 1], "end": [179, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_sUnion", "code": "theorem measure_sUnion {S : Set (Set \u03b1)} (hs : S.Countable) (hd : S.Pairwise Disjoint)\n    (h : \u2200 s \u2208 S, MeasurableSet s) : \u03bc (\u22c3\u2080 S) = \u2211' s : S, \u03bc s", "start": [182, 1], "end": [184, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_biUnion_finset\u2080", "code": "theorem measure_biUnion_finset\u2080 {s : Finset \u03b9} {f : \u03b9 \u2192 Set \u03b1}\n    (hd : Set.Pairwise (\u2191s) (AEDisjoint \u03bc on f)) (hm : \u2200 b \u2208 s, NullMeasurableSet (f b) \u03bc) :\n    \u03bc (\u22c3 b \u2208 s, f b) = \u2211 p in s, \u03bc (f p)", "start": [187, 1], "end": [191, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_biUnion_finset", "code": "theorem measure_biUnion_finset {s : Finset \u03b9} {f : \u03b9 \u2192 Set \u03b1} (hd : PairwiseDisjoint (\u2191s) f)\n    (hm : \u2200 b \u2208 s, MeasurableSet (f b)) : \u03bc (\u22c3 b \u2208 s, f b) = \u2211 p in s, \u03bc (f p)", "start": [194, 1], "end": [196, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tsum_meas_le_meas_iUnion_of_disjoint\u2080", "code": "theorem tsum_meas_le_meas_iUnion_of_disjoint\u2080 {\u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1)\n    {As : \u03b9 \u2192 Set \u03b1} (As_mble : \u2200 i : \u03b9, NullMeasurableSet (As i) \u03bc)\n    (As_disj : Pairwise (AEDisjoint \u03bc on As)) : (\u2211' i, \u03bc (As i)) \u2264 \u03bc (\u22c3 i, As i)", "start": [199, 1], "end": [209, 84], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tsum_meas_le_meas_iUnion_of_disjoint", "code": "theorem tsum_meas_le_meas_iUnion_of_disjoint {\u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1)\n    {As : \u03b9 \u2192 Set \u03b1} (As_mble : \u2200 i : \u03b9, MeasurableSet (As i))\n    (As_disj : Pairwise (Disjoint on As)) : (\u2211' i, \u03bc (As i)) \u2264 \u03bc (\u22c3 i, As i)", "start": [211, 1], "end": [217, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tsum_measure_preimage_singleton", "code": "theorem tsum_measure_preimage_singleton {s : Set \u03b2} (hs : s.Countable) {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 y \u2208 s, MeasurableSet (f \u207b\u00b9' {y})) : (\u2211' b : s, \u03bc (f \u207b\u00b9' {\u2191b})) = \u03bc (f \u207b\u00b9' s)", "start": [220, 1], "end": [224, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.sum_measure_preimage_singleton", "code": "theorem sum_measure_preimage_singleton (s : Finset \u03b2) {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 y \u2208 s, MeasurableSet (f \u207b\u00b9' {y})) : (\u2211 b in s, \u03bc (f \u207b\u00b9' {b})) = \u03bc (f \u207b\u00b9' \u2191s)", "start": [227, 1], "end": [232, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_diff_null'", "code": "theorem measure_diff_null' (h : \u03bc (s\u2081 \u2229 s\u2082) = 0) : \u03bc (s\u2081 \\ s\u2082) = \u03bc s\u2081", "start": [235, 1], "end": [236, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_diff_null", "code": "theorem measure_diff_null (h : \u03bc s\u2082 = 0) : \u03bc (s\u2081 \\ s\u2082) = \u03bc s\u2081", "start": [239, 1], "end": [240, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_add_diff", "code": "theorem measure_add_diff (hs : MeasurableSet s) (t : Set \u03b1) : \u03bc s + \u03bc (t \\ s) = \u03bc (s \u222a t)", "start": [243, 1], "end": [244, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_diff'", "code": "theorem measure_diff' (s : Set \u03b1) (hm : MeasurableSet t) (h_fin : \u03bc t \u2260 \u221e) :\n    \u03bc (s \\ t) = \u03bc (s \u222a t) - \u03bc t", "start": [247, 1], "end": [249, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_diff", "code": "theorem measure_diff (h : s\u2082 \u2286 s\u2081) (h\u2082 : MeasurableSet s\u2082) (h_fin : \u03bc s\u2082 \u2260 \u221e) :\n    \u03bc (s\u2081 \\ s\u2082) = \u03bc s\u2081 - \u03bc s\u2082", "start": [252, 1], "end": [253, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.le_measure_diff", "code": "theorem le_measure_diff : \u03bc s\u2081 - \u03bc s\u2082 \u2264 \u03bc (s\u2081 \\ s\u2082)", "start": [256, 1], "end": [261, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_diff_lt_of_lt_add", "code": "theorem measure_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s \u2286 t) (hs' : \u03bc s \u2260 \u221e) {\u03b5 : \u211d\u22650\u221e}\n    (h : \u03bc t < \u03bc s + \u03b5) : \u03bc (t \\ s) < \u03b5", "start": [265, 1], "end": [268, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_diff_le_iff_le_add", "code": "theorem measure_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s \u2286 t) (hs' : \u03bc s \u2260 \u221e) {\u03b5 : \u211d\u22650\u221e} :\n    \u03bc (t \\ s) \u2264 \u03b5 \u2194 \u03bc t \u2264 \u03bc s + \u03b5", "start": [271, 1], "end": [272, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_eq_measure_of_null_diff", "code": "theorem measure_eq_measure_of_null_diff {s t : Set \u03b1} (hst : s \u2286 t) (h_nulldiff : \u03bc (t \\ s) = 0) :\n    \u03bc s = \u03bc t", "start": [275, 1], "end": [277, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_eq_measure_of_between_null_diff", "code": "theorem measure_eq_measure_of_between_null_diff {s\u2081 s\u2082 s\u2083 : Set \u03b1} (h12 : s\u2081 \u2286 s\u2082) (h23 : s\u2082 \u2286 s\u2083)\n    (h_nulldiff : \u03bc (s\u2083 \\ s\u2081) = 0) : \u03bc s\u2081 = \u03bc s\u2082 \u2227 \u03bc s\u2082 = \u03bc s\u2083", "start": [280, 1], "end": [290, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_eq_measure_smaller_of_between_null_diff", "code": "theorem measure_eq_measure_smaller_of_between_null_diff {s\u2081 s\u2082 s\u2083 : Set \u03b1} (h12 : s\u2081 \u2286 s\u2082)\n    (h23 : s\u2082 \u2286 s\u2083) (h_nulldiff : \u03bc (s\u2083 \\ s\u2081) = 0) : \u03bc s\u2081 = \u03bc s\u2082", "start": [293, 1], "end": [295, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_eq_measure_larger_of_between_null_diff", "code": "theorem measure_eq_measure_larger_of_between_null_diff {s\u2081 s\u2082 s\u2083 : Set \u03b1} (h12 : s\u2081 \u2286 s\u2082)\n    (h23 : s\u2082 \u2286 s\u2083) (h_nulldiff : \u03bc (s\u2083 \\ s\u2081) = 0) : \u03bc s\u2082 = \u03bc s\u2083", "start": [298, 1], "end": [300, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_compl", "code": "theorem measure_compl (h\u2081 : MeasurableSet s) (h_fin : \u03bc s \u2260 \u221e) : \u03bc s\u1d9c = \u03bc univ - \u03bc s", "start": [303, 1], "end": [305, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.union_ae_eq_left_iff_ae_subset", "code": "@[simp]\ntheorem union_ae_eq_left_iff_ae_subset : (s \u222a t : Set \u03b1) =\u1d50[\u03bc] s \u2194 t \u2264\u1d50[\u03bc] s", "start": [308, 1], "end": [315, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.union_ae_eq_right_iff_ae_subset", "code": "@[simp]\ntheorem union_ae_eq_right_iff_ae_subset : (s \u222a t : Set \u03b1) =\u1d50[\u03bc] t \u2194 s \u2264\u1d50[\u03bc] t", "start": [318, 1], "end": [320, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_of_ae_subset_of_measure_ge", "code": "theorem ae_eq_of_ae_subset_of_measure_ge (h\u2081 : s \u2264\u1d50[\u03bc] t) (h\u2082 : \u03bc t \u2264 \u03bc s) (hsm : MeasurableSet s)\n    (ht : \u03bc t \u2260 \u221e) : s =\u1d50[\u03bc] t", "start": [323, 1], "end": [328, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_of_subset_of_measure_ge", "code": "theorem ae_eq_of_subset_of_measure_ge (h\u2081 : s \u2286 t) (h\u2082 : \u03bc t \u2264 \u03bc s) (hsm : MeasurableSet s)\n    (ht : \u03bc t \u2260 \u221e) : s =\u1d50[\u03bc] t", "start": [331, 1], "end": [334, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_iUnion_congr_of_subset", "code": "theorem measure_iUnion_congr_of_subset [Countable \u03b2] {s : \u03b2 \u2192 Set \u03b1} {t : \u03b2 \u2192 Set \u03b1}\n    (hsub : \u2200 b, s b \u2286 t b) (h_le : \u2200 b, \u03bc (t b) \u2264 \u03bc (s b)) : \u03bc (\u22c3 b, s b) = \u03bc (\u22c3 b, t b)", "start": [337, 1], "end": [362, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union_congr_of_subset", "code": "theorem measure_union_congr_of_subset {t\u2081 t\u2082 : Set \u03b1} (hs : s\u2081 \u2286 s\u2082) (hs\u03bc : \u03bc s\u2082 \u2264 \u03bc s\u2081)\n    (ht : t\u2081 \u2286 t\u2082) (ht\u03bc : \u03bc t\u2082 \u2264 \u03bc t\u2081) : \u03bc (s\u2081 \u222a t\u2081) = \u03bc (s\u2082 \u222a t\u2082)", "start": [365, 1], "end": [368, 101], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_iUnion_toMeasurable", "code": "@[simp]\ntheorem measure_iUnion_toMeasurable [Countable \u03b2] (s : \u03b2 \u2192 Set \u03b1) :\n    \u03bc (\u22c3 b, toMeasurable \u03bc (s b)) = \u03bc (\u22c3 b, s b)", "start": [371, 1], "end": [376, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_biUnion_toMeasurable", "code": "theorem measure_biUnion_toMeasurable {I : Set \u03b2} (hc : I.Countable) (s : \u03b2 \u2192 Set \u03b1) :\n    \u03bc (\u22c3 b \u2208 I, toMeasurable \u03bc (s b)) = \u03bc (\u22c3 b \u2208 I, s b)", "start": [379, 1], "end": [382, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_toMeasurable_union", "code": "@[simp]\ntheorem measure_toMeasurable_union : \u03bc (toMeasurable \u03bc s \u222a t) = \u03bc (s \u222a t)", "start": [385, 1], "end": [389, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union_toMeasurable", "code": "@[simp]\ntheorem measure_union_toMeasurable : \u03bc (s \u222a toMeasurable \u03bc t) = \u03bc (s \u222a t)", "start": [392, 1], "end": [396, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.sum_measure_le_measure_univ", "code": "theorem sum_measure_le_measure_univ {s : Finset \u03b9} {t : \u03b9 \u2192 Set \u03b1}\n    (h : \u2200 i \u2208 s, MeasurableSet (t i)) (H : Set.PairwiseDisjoint (\u2191s) t) :\n    (\u2211 i in s, \u03bc (t i)) \u2264 \u03bc (univ : Set \u03b1)", "start": [399, 1], "end": [403, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tsum_measure_le_measure_univ", "code": "theorem tsum_measure_le_measure_univ {s : \u03b9 \u2192 Set \u03b1} (hs : \u2200 i, MeasurableSet (s i))\n    (H : Pairwise (Disjoint on s)) : (\u2211' i, \u03bc (s i)) \u2264 \u03bc (univ : Set \u03b1)", "start": [406, 1], "end": [410, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure", "code": "theorem exists_nonempty_inter_of_measure_univ_lt_tsum_measure {m : MeasurableSpace \u03b1}\n    (\u03bc : Measure \u03b1) {s : \u03b9 \u2192 Set \u03b1} (hs : \u2200 i, MeasurableSet (s i))\n    (H : \u03bc (univ : Set \u03b1) < \u2211' i, \u03bc (s i)) : \u2203 (i j : _) (_h : i \u2260 j), (s i \u2229 s j).Nonempty", "start": [413, 1], "end": [422, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_nonempty_inter_of_measure_univ_lt_sum_measure", "code": "theorem exists_nonempty_inter_of_measure_univ_lt_sum_measure {m : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1)\n    {s : Finset \u03b9} {t : \u03b9 \u2192 Set \u03b1} (h : \u2200 i \u2208 s, MeasurableSet (t i))\n    (H : \u03bc (univ : Set \u03b1) < \u2211 i in s, \u03bc (t i)) :\n    \u2203 i \u2208 s, \u2203 j \u2208 s, \u2203 _h : i \u2260 j, (t i \u2229 t j).Nonempty", "start": [425, 1], "end": [435, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.nonempty_inter_of_measure_lt_add", "code": "theorem nonempty_inter_of_measure_lt_add {m : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) {s t u : Set \u03b1}\n    (ht : MeasurableSet t) (h's : s \u2286 u) (h't : t \u2286 u) (h : \u03bc u < \u03bc s + \u03bc t) :\n    (s \u2229 t).Nonempty", "start": [438, 1], "end": [447, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.nonempty_inter_of_measure_lt_add'", "code": "theorem nonempty_inter_of_measure_lt_add' {m : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) {s t u : Set \u03b1}\n    (hs : MeasurableSet s) (h's : s \u2286 u) (h't : t \u2286 u) (h : \u03bc u < \u03bc s + \u03bc t) :\n    (s \u2229 t).Nonempty", "start": [451, 1], "end": [458, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_iUnion_eq_iSup", "code": "theorem measure_iUnion_eq_iSup [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} (hd : Directed (\u00b7 \u2286 \u00b7) s) :\n    \u03bc (\u22c3 i, s i) = \u2a06 i, \u03bc (s i)", "start": [461, 1], "end": [495, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_biUnion_eq_iSup", "code": "theorem measure_biUnion_eq_iSup {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b9} (ht : t.Countable)\n    (hd : DirectedOn ((\u00b7 \u2286 \u00b7) on s) t) : \u03bc (\u22c3 i \u2208 t, s i) = \u2a06 i \u2208 t, \u03bc (s i)", "start": [499, 1], "end": [502, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_iInter_eq_iInf", "code": "theorem measure_iInter_eq_iInf [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, MeasurableSet (s i))\n    (hd : Directed (\u00b7 \u2287 \u00b7) s) (hfin : \u2203 i, \u03bc (s i) \u2260 \u221e) : \u03bc (\u22c2 i, s i) = \u2a05 i, \u03bc (s i)", "start": [505, 1], "end": [525, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_measure_iUnion", "code": "theorem tendsto_measure_iUnion [SemilatticeSup \u03b9] [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} (hm : Monotone s) :\n    Tendsto (\u03bc \u2218 s) atTop (\ud835\udcdd (\u03bc (\u22c3 n, s n)))", "start": [528, 1], "end": [533, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_measure_iInter", "code": "theorem tendsto_measure_iInter [Countable \u03b9] [SemilatticeSup \u03b9] {s : \u03b9 \u2192 Set \u03b1}\n    (hs : \u2200 n, MeasurableSet (s n)) (hm : Antitone s) (hf : \u2203 i, \u03bc (s i) \u2260 \u221e) :\n    Tendsto (\u03bc \u2218 s) atTop (\ud835\udcdd (\u03bc (\u22c2 n, s n)))", "start": [536, 1], "end": [542, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_measure_biInter_gt", "code": "theorem tendsto_measure_biInter_gt {\u03b9 : Type*} [LinearOrder \u03b9] [TopologicalSpace \u03b9]\n    [OrderTopology \u03b9] [DenselyOrdered \u03b9] [TopologicalSpace.FirstCountableTopology \u03b9] {s : \u03b9 \u2192 Set \u03b1}\n    {a : \u03b9} (hs : \u2200 r > a, MeasurableSet (s r)) (hm : \u2200 i j, a < i \u2192 i \u2264 j \u2192 s i \u2286 s j)\n    (hf : \u2203 r > a, \u03bc (s r) \u2260 \u221e) : Tendsto (\u03bc \u2218 s) (\ud835\udcdd[Ioi a] a) (\ud835\udcdd (\u03bc (\u22c2 r > a, s r)))", "start": [545, 1], "end": [580, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_limsup_eq_zero", "code": "theorem measure_limsup_eq_zero {s : \u2115 \u2192 Set \u03b1} (hs : (\u2211' i, \u03bc (s i)) \u2260 \u221e) :\n    \u03bc (limsup s atTop) = 0", "start": [583, 1], "end": [607, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_liminf_eq_zero", "code": "theorem measure_liminf_eq_zero {s : \u2115 \u2192 Set \u03b1} (h : (\u2211' i, \u03bc (s i)) \u2260 \u22a4) :\n    \u03bc (liminf s atTop) = 0", "start": [610, 1], "end": [614, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.limsup_ae_eq_of_forall_ae_eq", "code": "theorem limsup_ae_eq_of_forall_ae_eq (s : \u2115 \u2192 Set \u03b1) {t : Set \u03b1}\n    (h : \u2200 n, s n =\u1d50[\u03bc] t) : @limsup (Set \u03b1) \u2115 _ s atTop =\u1d50[\u03bc] t", "start": [617, 1], "end": [627, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.liminf_ae_eq_of_forall_ae_eq", "code": "theorem liminf_ae_eq_of_forall_ae_eq (s : \u2115 \u2192 Set \u03b1) {t : Set \u03b1}\n    (h : \u2200 n, s n =\u1d50[\u03bc] t) : @liminf (Set \u03b1) \u2115 _ s atTop =\u1d50[\u03bc] t", "start": [630, 1], "end": [640, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_if", "code": "theorem measure_if {x : \u03b2} {t : Set \u03b2} {s : Set \u03b1} :\n    \u03bc (if x \u2208 t then s else \u2205) = indicator t (fun _ => \u03bc s) x", "start": [643, 1], "end": [644, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.toMeasure", "code": "def OuterMeasure.toMeasure (m : OuterMeasure \u03b1) (h : ms \u2264 m.caratheodory) : Measure \u03b1 :=\n  Measure.ofMeasurable (fun s _ => m s) m.empty fun _f hf hd =>\n    m.iUnion_eq_of_caratheodory (fun i => h _ (hf i)) hd", "start": [653, 1], "end": [657, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.le_toOuterMeasure_caratheodory", "code": "theorem le_toOuterMeasure_caratheodory (\u03bc : Measure \u03b1) : ms \u2264 \u03bc.toOuterMeasure.caratheodory", "start": [660, 1], "end": [661, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.toMeasure_toOuterMeasure", "code": "@[simp]\ntheorem toMeasure_toOuterMeasure (m : OuterMeasure \u03b1) (h : ms \u2264 m.caratheodory) :\n    (m.toMeasure h).toOuterMeasure = m.trim", "start": [664, 1], "end": [667, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.toMeasure_apply", "code": "theorem toMeasure_apply (m : OuterMeasure \u03b1) (h : ms \u2264 m.caratheodory) {s : Set \u03b1}\n    (hs : MeasurableSet s) : m.toMeasure h s = m s", "start": [674, 1], "end": [676, 15], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.le_toMeasure_apply", "code": "theorem le_toMeasure_apply (m : OuterMeasure \u03b1) (h : ms \u2264 m.caratheodory) (s : Set \u03b1) :\n    m s \u2264 m.toMeasure h s", "start": [679, 1], "end": [681, 14], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.toMeasure_apply\u2080", "code": "theorem toMeasure_apply\u2080 (m : OuterMeasure \u03b1) (h : ms \u2264 m.caratheodory) {s : Set \u03b1}\n    (hs : NullMeasurableSet s (m.toMeasure h)) : m.toMeasure h s = m s", "start": [684, 1], "end": [691, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.toOuterMeasure_toMeasure", "code": "@[simp]\ntheorem toOuterMeasure_toMeasure {\u03bc : Measure \u03b1} :\n    \u03bc.toOuterMeasure.toMeasure (le_toOuterMeasure_caratheodory _) = \u03bc", "start": [695, 1], "end": [698, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.boundedBy_measure", "code": "theorem boundedBy_measure (\u03bc : Measure \u03b1) : OuterMeasure.boundedBy \u03bc = \u03bc.toOuterMeasure", "start": [702, 1], "end": [703, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_inter_eq_of_measure_eq", "code": "theorem measure_inter_eq_of_measure_eq {s t u : Set \u03b1} (hs : MeasurableSet s) (h : \u03bc t = \u03bc u)\n    (htu : t \u2286 u) (ht_ne_top : \u03bc t \u2260 \u221e) : \u03bc (t \u2229 s) = \u03bc (u \u2229 s)", "start": [718, 1], "end": [733, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_toMeasurable_inter", "code": "theorem measure_toMeasurable_inter {s t : Set \u03b1} (hs : MeasurableSet s) (ht : \u03bc t \u2260 \u221e) :\n    \u03bc (toMeasurable \u03bc t \u2229 s) = \u03bc (t \u2229 s)", "start": [736, 1], "end": [743, 15], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instZero", "code": "instance instZero [MeasurableSpace \u03b1] : Zero (Measure \u03b1) :=\n  \u27e8{  toOuterMeasure := 0\n      m_iUnion := fun _f _hf _hd => tsum_zero.symm\n      trimmed := OuterMeasure.trim_zero }\u27e9", "start": [748, 1], "end": [751, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.zero_toOuterMeasure", "code": "@[simp]\ntheorem zero_toOuterMeasure {_m : MeasurableSpace \u03b1} : (0 : Measure \u03b1).toOuterMeasure = 0", "start": [754, 1], "end": [756, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero {_m : MeasurableSpace \u03b1} : \u21d1(0 : Measure \u03b1) = 0", "start": [759, 1], "end": [761, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instSubsingleton", "code": "instance instSubsingleton [IsEmpty \u03b1] {m : MeasurableSpace \u03b1} : Subsingleton (Measure \u03b1) :=\n  \u27e8fun \u03bc \u03bd => by\n    ext1 s _\n    rw [eq_empty_of_isEmpty s]; simp only [measure_empty]\u27e9", "start": [764, 1], "end": [767, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.eq_zero_of_isEmpty", "code": "theorem eq_zero_of_isEmpty [IsEmpty \u03b1] {_m : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) : \u03bc = 0", "start": [770, 1], "end": [771, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instInhabited", "code": "instance instInhabited [MeasurableSpace \u03b1] : Inhabited (Measure \u03b1) :=\n  \u27e80\u27e9", "start": [774, 1], "end": [775, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instAdd", "code": "instance instAdd [MeasurableSpace \u03b1] : Add (Measure \u03b1) :=\n  \u27e8fun \u03bc\u2081 \u03bc\u2082 =>\n    { toOuterMeasure := \u03bc\u2081.toOuterMeasure + \u03bc\u2082.toOuterMeasure\n      m_iUnion := fun s hs hd =>\n        show \u03bc\u2081 (\u22c3 i, s i) + \u03bc\u2082 (\u22c3 i, s i) = \u2211' i, (\u03bc\u2081 (s i) + \u03bc\u2082 (s i)) by\n          rw [ENNReal.tsum_add, measure_iUnion hd hs, measure_iUnion hd hs]\n      trimmed := by rw [OuterMeasure.trim_add, \u03bc\u2081.trimmed, \u03bc\u2082.trimmed] }\u27e9", "start": [778, 1], "end": [784, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.add_toOuterMeasure", "code": "@[simp]\ntheorem add_toOuterMeasure {_m : MeasurableSpace \u03b1} (\u03bc\u2081 \u03bc\u2082 : Measure \u03b1) :\n    (\u03bc\u2081 + \u03bc\u2082).toOuterMeasure = \u03bc\u2081.toOuterMeasure + \u03bc\u2082.toOuterMeasure", "start": [787, 1], "end": [790, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add {_m : MeasurableSpace \u03b1} (\u03bc\u2081 \u03bc\u2082 : Measure \u03b1) : \u21d1(\u03bc\u2081 + \u03bc\u2082) = \u03bc\u2081 + \u03bc\u2082", "start": [793, 1], "end": [795, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.add_apply", "code": "theorem add_apply {_m : MeasurableSpace \u03b1} (\u03bc\u2081 \u03bc\u2082 : Measure \u03b1) (s : Set \u03b1) :\n    (\u03bc\u2081 + \u03bc\u2082) s = \u03bc\u2081 s + \u03bc\u2082 s", "start": [798, 1], "end": [800, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instSMul", "code": "instance instSMul [MeasurableSpace \u03b1] : SMul R (Measure \u03b1) :=\n  \u27e8fun c \u03bc =>\n    { toOuterMeasure := c \u2022 \u03bc.toOuterMeasure\n      m_iUnion := fun s hs hd => by\n        rw [\u2190 smul_one_smul \u211d\u22650\u221e c (_ : OuterMeasure \u03b1)]\n        conv_lhs =>\n          change OuterMeasure.measureOf\n            ((c \u2022 @OfNat.ofNat _ 1 One.toOfNat1 : \u211d\u22650\u221e) \u2022 \u03bc.toOuterMeasure) (\u22c3 i, s i)\n          change (c \u2022 @OfNat.ofNat _ 1 One.toOfNat1 : \u211d\u22650\u221e) *\n            OuterMeasure.measureOf \u03bc.toOuterMeasure (\u22c3 i, s i)\n        conv_rhs =>\n          change \u2211' i, OuterMeasure.measureOf\n            ((c \u2022 @OfNat.ofNat _ 1 One.toOfNat1 : \u211d\u22650\u221e) \u2022 \u03bc.toOuterMeasure) (s i)\n          change \u2211' i, (c \u2022 @OfNat.ofNat _ 1 One.toOfNat1 : \u211d\u22650\u221e) *\n            OuterMeasure.measureOf (\u03bc.toOuterMeasure) (s i)\n        simp_rw [measure_iUnion hd hs, ENNReal.tsum_mul_left]\n      trimmed := by rw [OuterMeasure.trim_smul, \u03bc.trimmed] }\u27e9", "start": [810, 1], "end": [826, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.smul_toOuterMeasure", "code": "@[simp]\ntheorem smul_toOuterMeasure {_m : MeasurableSpace \u03b1} (c : R) (\u03bc : Measure \u03b1) :\n    (c \u2022 \u03bc).toOuterMeasure = c \u2022 \u03bc.toOuterMeasure", "start": [829, 1], "end": [832, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.coe_smul", "code": "@[simp, norm_cast]\ntheorem coe_smul {_m : MeasurableSpace \u03b1} (c : R) (\u03bc : Measure \u03b1) : \u21d1(c \u2022 \u03bc) = c \u2022 \u21d1\u03bc", "start": [835, 1], "end": [837, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.smul_apply", "code": "@[simp]\ntheorem smul_apply {_m : MeasurableSpace \u03b1} (c : R) (\u03bc : Measure \u03b1) (s : Set \u03b1) :\n    (c \u2022 \u03bc) s = c \u2022 \u03bc s", "start": [840, 1], "end": [843, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instSMulCommClass", "code": "instance instSMulCommClass [SMulCommClass R R' \u211d\u22650\u221e] [MeasurableSpace \u03b1] :\n    SMulCommClass R R' (Measure \u03b1) :=\n  \u27e8fun _ _ _ => ext fun _ _ => smul_comm _ _ _\u27e9", "start": [846, 1], "end": [848, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instIsScalarTower", "code": "instance instIsScalarTower [SMul R R'] [IsScalarTower R R' \u211d\u22650\u221e] [MeasurableSpace \u03b1] :\n    IsScalarTower R R' (Measure \u03b1) :=\n  \u27e8fun _ _ _ => ext fun _ _ => smul_assoc _ _ _\u27e9", "start": [851, 1], "end": [853, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instIsCentralScalar", "code": "instance instIsCentralScalar [SMul R\u1d50\u1d52\u1d56 \u211d\u22650\u221e] [IsCentralScalar R \u211d\u22650\u221e] [MeasurableSpace \u03b1] :\n    IsCentralScalar R (Measure \u03b1) :=\n  \u27e8fun _ _ => ext fun _ _ => op_smul_eq_smul _ _\u27e9", "start": [856, 1], "end": [858, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instMulAction", "code": "instance instMulAction [Monoid R] [MulAction R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]\n    [MeasurableSpace \u03b1] : MulAction R (Measure \u03b1) :=\n  Injective.mulAction _ toOuterMeasure_injective smul_toOuterMeasure", "start": [863, 1], "end": [865, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instAddCommMonoid", "code": "instance instAddCommMonoid [MeasurableSpace \u03b1] : AddCommMonoid (Measure \u03b1) :=\n  toOuterMeasure_injective.addCommMonoid toOuterMeasure zero_toOuterMeasure add_toOuterMeasure\n    fun _ _ => smul_toOuterMeasure _ _", "start": [868, 1], "end": [870, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.coeAddHom", "code": "def coeAddHom {_ : MeasurableSpace \u03b1} : Measure \u03b1 \u2192+ Set \u03b1 \u2192 \u211d\u22650\u221e where\n  toFun := (\u21d1)\n  map_zero' := coe_zero\n  map_add' := coe_add", "start": [873, 1], "end": [877, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.coe_finset_sum", "code": "@[simp]\ntheorem coe_finset_sum {_m : MeasurableSpace \u03b1} (I : Finset \u03b9) (\u03bc : \u03b9 \u2192 Measure \u03b1) :\n    \u21d1(\u2211 i in I, \u03bc i) = \u2211 i in I, \u21d1(\u03bc i)", "start": [880, 1], "end": [882, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.finset_sum_apply", "code": "theorem finset_sum_apply {m : MeasurableSpace \u03b1} (I : Finset \u03b9) (\u03bc : \u03b9 \u2192 Measure \u03b1) (s : Set \u03b1) :\n    (\u2211 i in I, \u03bc i) s = \u2211 i in I, \u03bc i s", "start": [885, 1], "end": [886, 84], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instDistribMulAction", "code": "instance instDistribMulAction [Monoid R] [DistribMulAction R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]\n    [MeasurableSpace \u03b1] : DistribMulAction R (Measure \u03b1) :=\n  Injective.distribMulAction \u27e8\u27e8toOuterMeasure, zero_toOuterMeasure\u27e9, add_toOuterMeasure\u27e9\n    toOuterMeasure_injective smul_toOuterMeasure", "start": [889, 1], "end": [892, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instModule", "code": "instance instModule [Semiring R] [Module R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e] [MeasurableSpace \u03b1] :\n    Module R (Measure \u03b1) :=\n  Injective.module R \u27e8\u27e8toOuterMeasure, zero_toOuterMeasure\u27e9, add_toOuterMeasure\u27e9\n    toOuterMeasure_injective smul_toOuterMeasure", "start": [895, 1], "end": [898, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.coe_nnreal_smul_apply", "code": "theorem coe_nnreal_smul_apply {_m : MeasurableSpace \u03b1} (c : \u211d\u22650) (\u03bc : Measure \u03b1) (s : Set \u03b1) :\n    (c \u2022 \u03bc) s = c * \u03bc s", "start": [905, 1], "end": [907, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.nnreal_smul_coe_apply", "code": "@[simp]\ntheorem nnreal_smul_coe_apply {_m : MeasurableSpace \u03b1} (c : \u211d\u22650) (\u03bc : Measure \u03b1) (s : Set \u03b1) :\n    c \u2022 \u03bc s = c * \u03bc s", "start": [910, 1], "end": [913, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ae_smul_measure_iff", "code": "theorem ae_smul_measure_iff {p : \u03b1 \u2192 Prop} {c : \u211d\u22650\u221e} (hc : c \u2260 0) :\n    (\u2200\u1d50 x \u2202c \u2022 \u03bc, p x) \u2194 \u2200\u1d50 x \u2202\u03bc, p x", "start": [915, 1], "end": [918, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_eq_left_of_subset_of_measure_add_eq", "code": "theorem measure_eq_left_of_subset_of_measure_add_eq {s t : Set \u03b1} (h : (\u03bc + \u03bd) t \u2260 \u221e) (h' : s \u2286 t)\n    (h'' : (\u03bc + \u03bd) s = (\u03bc + \u03bd) t) : \u03bc s = \u03bc t", "start": [921, 1], "end": [930, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_eq_right_of_subset_of_measure_add_eq", "code": "theorem measure_eq_right_of_subset_of_measure_add_eq {s t : Set \u03b1} (h : (\u03bc + \u03bd) t \u2260 \u221e) (h' : s \u2286 t)\n    (h'' : (\u03bc + \u03bd) s = (\u03bc + \u03bd) t) : \u03bd s = \u03bd t", "start": [933, 1], "end": [936, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_toMeasurable_add_inter_left", "code": "theorem measure_toMeasurable_add_inter_left {s t : Set \u03b1} (hs : MeasurableSet s)\n    (ht : (\u03bc + \u03bd) t \u2260 \u221e) : \u03bc (toMeasurable (\u03bc + \u03bd) t \u2229 s) = \u03bc (t \u2229 s)", "start": [939, 1], "end": [947, 15], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_toMeasurable_add_inter_right", "code": "theorem measure_toMeasurable_add_inter_right {s t : Set \u03b1} (hs : MeasurableSet s)\n    (ht : (\u03bc + \u03bd) t \u2260 \u221e) : \u03bd (toMeasurable (\u03bc + \u03bd) t \u2229 s) = \u03bd (t \u2229 s)", "start": [950, 1], "end": [953, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instPartialOrder", "code": "instance instPartialOrder [MeasurableSpace \u03b1] : PartialOrder (Measure \u03b1) where\n  le m\u2081 m\u2082 := \u2200 s, MeasurableSet s \u2192 m\u2081 s \u2264 m\u2082 s\n  le_refl m s _hs := le_rfl\n  le_trans m\u2081 m\u2082 m\u2083 h\u2081 h\u2082 s hs := le_trans (h\u2081 s hs) (h\u2082 s hs)\n  le_antisymm m\u2081 m\u2082 h\u2081 h\u2082 := ext fun s hs => le_antisymm (h\u2081 s hs) (h\u2082 s hs)", "start": [959, 1], "end": [969, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_iff", "code": "theorem le_iff : \u03bc\u2081 \u2264 \u03bc\u2082 \u2194 \u2200 s, MeasurableSet s \u2192 \u03bc\u2081 s \u2264 \u03bc\u2082 s", "start": [972, 1], "end": [973, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.toOuterMeasure_le", "code": "theorem toOuterMeasure_le : \u03bc\u2081.toOuterMeasure \u2264 \u03bc\u2082.toOuterMeasure \u2194 \u03bc\u2081 \u2264 \u03bc\u2082", "start": [976, 1], "end": [977, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_iff'", "code": "theorem le_iff' : \u03bc\u2081 \u2264 \u03bc\u2082 \u2194 \u2200 s, \u03bc\u2081 s \u2264 \u03bc\u2082 s", "start": [980, 1], "end": [981, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.lt_iff", "code": "theorem lt_iff : \u03bc < \u03bd \u2194 \u03bc \u2264 \u03bd \u2227 \u2203 s, MeasurableSet s \u2227 \u03bc s < \u03bd s", "start": [984, 1], "end": [986, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.lt_iff'", "code": "theorem lt_iff' : \u03bc < \u03bd \u2194 \u03bc \u2264 \u03bd \u2227 \u2203 s, \u03bc s < \u03bd s", "start": [989, 1], "end": [990, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.covariantAddLE", "code": "instance covariantAddLE [MeasurableSpace \u03b1] :\n    CovariantClass (Measure \u03b1) (Measure \u03b1) (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _\u03bd _\u03bc\u2081 _\u03bc\u2082 h\u03bc s hs => add_le_add_left (h\u03bc s hs) _\u27e9", "start": [993, 1], "end": [995, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_add_left", "code": "protected theorem le_add_left (h : \u03bc \u2264 \u03bd) : \u03bc \u2264 \u03bd' + \u03bd", "start": [998, 1], "end": [998, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_add_right", "code": "protected theorem le_add_right (h : \u03bc \u2264 \u03bd) : \u03bc \u2264 \u03bd + \u03bd'", "start": [1001, 1], "end": [1001, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sInf_caratheodory", "code": "theorem sInf_caratheodory (s : Set \u03b1) (hs : MeasurableSet s) :\n    MeasurableSet[(sInf (toOuterMeasure '' m)).caratheodory] s", "start": [1008, 1], "end": [1021, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sInf_apply", "code": "theorem sInf_apply (hs : MeasurableSet s) : sInf m s = sInf (toOuterMeasure '' m) s", "start": [1027, 1], "end": [1028, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_sInf_le", "code": "private theorem measure_sInf_le (h : \u03bc \u2208 m) : sInf m \u2264 \u03bc", "start": [1031, 1], "end": [1033, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_le_sInf", "code": "private theorem measure_le_sInf (h : \u2200 \u03bc' \u2208 m, \u03bc \u2264 \u03bc') : \u03bc \u2264 sInf m", "start": [1035, 1], "end": [1038, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instCompleteSemilatticeInf", "code": "instance instCompleteSemilatticeInf [MeasurableSpace \u03b1] : CompleteSemilatticeInf (Measure \u03b1) :=\n  { (by infer_instance : PartialOrder (Measure \u03b1)),\n    (by infer_instance :\n      InfSet (Measure \u03b1)) with\n    sInf_le := fun _s _a => measure_sInf_le\n    le_sInf := fun _s _a => measure_le_sInf }", "start": [1040, 1], "end": [1045, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instCompleteLattice", "code": "instance instCompleteLattice [MeasurableSpace \u03b1] : CompleteLattice (Measure \u03b1) :=\n  { \n    completeLatticeOfCompleteSemilatticeInf (Measure \u03b1) with\n    bot := 0\n    bot_le := fun _a _s _hs => bot_le }", "start": [1048, 1], "end": [1061, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.toMeasure_top", "code": "@[simp]\ntheorem _root_.MeasureTheory.OuterMeasure.toMeasure_top [MeasurableSpace \u03b1] :\n    (\u22a4 : OuterMeasure \u03b1).toMeasure (by rw [OuterMeasure.top_caratheodory]; exact le_top) =\n      (\u22a4 : Measure \u03b1)", "start": [1066, 1], "end": [1072, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.toOuterMeasure_top", "code": "@[simp]\ntheorem toOuterMeasure_top [MeasurableSpace \u03b1] :\n    (\u22a4 : Measure \u03b1).toOuterMeasure = (\u22a4 : OuterMeasure \u03b1)", "start": [1075, 1], "end": [1078, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.top_add", "code": "@[simp]\ntheorem top_add : \u22a4 + \u03bc = \u22a4", "start": [1081, 1], "end": [1083, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.add_top", "code": "@[simp]\ntheorem add_top : \u03bc + \u22a4 = \u22a4", "start": [1086, 1], "end": [1088, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.zero_le", "code": "protected theorem zero_le {_m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) : 0 \u2264 \u03bc", "start": [1091, 1], "end": [1092, 9], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.nonpos_iff_eq_zero'", "code": "theorem nonpos_iff_eq_zero' : \u03bc \u2264 0 \u2194 \u03bc = 0", "start": [1095, 1], "end": [1096, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_univ_eq_zero", "code": "@[simp]\ntheorem measure_univ_eq_zero : \u03bc univ = 0 \u2194 \u03bc = 0", "start": [1099, 1], "end": [1102, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_univ_ne_zero", "code": "theorem measure_univ_ne_zero : \u03bc univ \u2260 0 \u2194 \u03bc \u2260 0", "start": [1105, 1], "end": [1106, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_univ_pos", "code": "@[simp]\ntheorem measure_univ_pos : 0 < \u03bc univ \u2194 \u03bc \u2260 0", "start": [1111, 1], "end": [1113, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.liftLinear", "code": "def liftLinear {m0 : MeasurableSpace \u03b1} (f : OuterMeasure \u03b1 \u2192\u2097[\u211d\u22650\u221e] OuterMeasure \u03b2)\n    (hf : \u2200 \u03bc : Measure \u03b1, \u2039_\u203a \u2264 (f \u03bc.toOuterMeasure).caratheodory) : Measure \u03b1 \u2192\u2097[\u211d\u22650\u221e] Measure \u03b2\n    where\n  toFun \u03bc := (f \u03bc.toOuterMeasure).toMeasure (hf \u03bc)\n  map_add' \u03bc\u2081 \u03bc\u2082 := ext fun s hs => by\n    simp only [map_add, coe_add, Pi.add_apply, toMeasure_apply, add_toOuterMeasure,\n      OuterMeasure.coe_add, hs]\n  map_smul' c \u03bc := ext fun s hs => by\n    simp only [LinearMap.map_smul\u209b\u2097, coe_smul, Pi.smul_apply,\n      toMeasure_apply, smul_toOuterMeasure (R := \u211d\u22650\u221e), OuterMeasure.coe_smul (R := \u211d\u22650\u221e),\n      smul_apply, hs]", "start": [1119, 1], "end": [1131, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.liftLinear_apply", "code": "@[simp]\ntheorem liftLinear_apply {f : OuterMeasure \u03b1 \u2192\u2097[\u211d\u22650\u221e] OuterMeasure \u03b2} (hf) {s : Set \u03b2}\n    (hs : MeasurableSet s) : liftLinear f hf \u03bc s = f \u03bc.toOuterMeasure s", "start": [1134, 1], "end": [1137, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_liftLinear_apply", "code": "theorem le_liftLinear_apply {f : OuterMeasure \u03b1 \u2192\u2097[\u211d\u22650\u221e] OuterMeasure \u03b2} (hf) (s : Set \u03b2) :\n    f \u03bc.toOuterMeasure s \u2264 liftLinear f hf \u03bc s", "start": [1140, 1], "end": [1142, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map\u2097", "code": "def map\u2097 [MeasurableSpace \u03b1] (f : \u03b1 \u2192 \u03b2) : Measure \u03b1 \u2192\u2097[\u211d\u22650\u221e] Measure \u03b2 :=\n  if hf : Measurable f then\n    liftLinear (OuterMeasure.map f) fun \u03bc _s hs t =>\n      le_toOuterMeasure_caratheodory \u03bc _ (hf hs) (f \u207b\u00b9' t)\n  else 0", "start": [1145, 1], "end": [1151, 9], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map\u2097_congr", "code": "theorem map\u2097_congr {f g : \u03b1 \u2192 \u03b2} (hf : Measurable f) (hg : Measurable g) (h : f =\u1d50[\u03bc] g) :\n    map\u2097 f \u03bc = map\u2097 g \u03bc", "start": [1154, 1], "end": [1158, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map", "code": "irreducible_def map [MeasurableSpace \u03b1] (f : \u03b1 \u2192 \u03b2) (\u03bc : Measure \u03b1) : Measure \u03b2 :=\n  if hf : AEMeasurable f \u03bc then map\u2097 (hf.mk f) \u03bc else 0", "start": [1161, 1], "end": [1164, 56], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "MeasureTheory.Measure.map\u2097_mk_apply_of_aemeasurable", "code": "theorem map\u2097_mk_apply_of_aemeasurable {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc) :\n    map\u2097 (hf.mk f) \u03bc = map f \u03bc", "start": [1167, 1], "end": [1168, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map\u2097_apply_of_measurable", "code": "theorem map\u2097_apply_of_measurable {f : \u03b1 \u2192 \u03b2} (hf : Measurable f) (\u03bc : Measure \u03b1) :\n    map\u2097 f \u03bc = map f \u03bc", "start": [1171, 1], "end": [1174, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_add", "code": "@[simp]\ntheorem map_add (\u03bc \u03bd : Measure \u03b1) {f : \u03b1 \u2192 \u03b2} (hf : Measurable f) :\n    (\u03bc + \u03bd).map f = \u03bc.map f + \u03bd.map f", "start": [1177, 1], "end": [1179, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_zero", "code": "@[simp]\ntheorem map_zero (f : \u03b1 \u2192 \u03b2) : (0 : Measure \u03b1).map f = 0", "start": [1182, 1], "end": [1184, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_of_not_aemeasurable", "code": "theorem map_of_not_aemeasurable {f : \u03b1 \u2192 \u03b2} {\u03bc : Measure \u03b1} (hf : \u00acAEMeasurable f \u03bc) :\n    \u03bc.map f = 0", "start": [1187, 1], "end": [1188, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_congr", "code": "theorem map_congr {f g : \u03b1 \u2192 \u03b2} (h : f =\u1d50[\u03bc] g) : Measure.map f \u03bc = Measure.map g \u03bc", "start": [1191, 1], "end": [1198, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_smul", "code": "@[simp]\nprotected theorem map_smul (c : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    (c \u2022 \u03bc).map f = c \u2022 \u03bc.map f", "start": [1201, 1], "end": [1216, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_smul_nnreal", "code": "@[simp]\nprotected theorem map_smul_nnreal (c : \u211d\u22650) (\u03bc : Measure \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    (c \u2022 \u03bc).map f = c \u2022 \u03bc.map f", "start": [1219, 1], "end": [1222, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_apply_of_aemeasurable", "code": "@[simp]\ntheorem map_apply_of_aemeasurable {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc) {s : Set \u03b2}\n    (hs : MeasurableSet s) : \u03bc.map f s = \u03bc (f \u207b\u00b9' s)", "start": [1225, 1], "end": [1232, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_apply", "code": "@[simp]\ntheorem map_apply {f : \u03b1 \u2192 \u03b2} (hf : Measurable f) {s : Set \u03b2} (hs : MeasurableSet s) :\n    \u03bc.map f s = \u03bc (f \u207b\u00b9' s)", "start": [1235, 1], "end": [1238, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_toOuterMeasure", "code": "theorem map_toOuterMeasure {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc) :\n    (\u03bc.map f).toOuterMeasure = (OuterMeasure.map f \u03bc.toOuterMeasure).trim", "start": [1241, 1], "end": [1245, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_id", "code": "@[simp]\ntheorem map_id : map id \u03bc = \u03bc", "start": [1248, 1], "end": [1250, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_id'", "code": "@[simp]\ntheorem map_id' : map (fun x => x) \u03bc = \u03bc", "start": [1253, 1], "end": [1255, 9], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_map", "code": "theorem map_map {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : Measurable g) (hf : Measurable f) :\n    (\u03bc.map f).map g = \u03bc.map (g \u2218 f)", "start": [1258, 1], "end": [1260, 75], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_mono", "code": "@[mono]\ntheorem map_mono {f : \u03b1 \u2192 \u03b2} (h : \u03bc \u2264 \u03bd) (hf : Measurable f) : \u03bc.map f \u2264 \u03bd.map f", "start": [1263, 1], "end": [1265, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_map_apply", "code": "theorem le_map_apply {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc) (s : Set \u03b2) : \u03bc (f \u207b\u00b9' s) \u2264 \u03bc.map f s", "start": [1268, 1], "end": [1276, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.preimage_null_of_map_null", "code": "theorem preimage_null_of_map_null {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc) {s : Set \u03b2}\n    (hs : \u03bc.map f s = 0) : \u03bc (f \u207b\u00b9' s) = 0", "start": [1280, 1], "end": [1283, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.tendsto_ae_map", "code": "theorem tendsto_ae_map {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc) : Tendsto f \u03bc.ae (\u03bc.map f).ae", "start": [1286, 1], "end": [1287, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.comap\u2097", "code": "def comap\u2097 [MeasurableSpace \u03b1] (f : \u03b1 \u2192 \u03b2) : Measure \u03b2 \u2192\u2097[\u211d\u22650\u221e] Measure \u03b1 :=\n  if hf : Injective f \u2227 \u2200 s, MeasurableSet s \u2192 MeasurableSet (f '' s) then\n    liftLinear (OuterMeasure.comap f) fun \u03bc s hs t => by\n      simp only [OuterMeasure.comap_apply, image_inter hf.1, image_diff hf.1]\n      apply le_toOuterMeasure_caratheodory\n      exact hf.2 s hs\n  else 0", "start": [1290, 1], "end": [1301, 9], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.comap\u2097_apply", "code": "theorem comap\u2097_apply {\u03b2} [MeasurableSpace \u03b1] {m\u03b2 : MeasurableSpace \u03b2} (f : \u03b1 \u2192 \u03b2)\n    (hfi : Injective f) (hf : \u2200 s, MeasurableSet s \u2192 MeasurableSet (f '' s)) (\u03bc : Measure \u03b2)\n    (hs : MeasurableSet s) : comap\u2097 f \u03bc s = \u03bc (f '' s)", "start": [1304, 1], "end": [1308, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.comap", "code": "def comap [MeasurableSpace \u03b1] (f : \u03b1 \u2192 \u03b2) (\u03bc : Measure \u03b2) : Measure \u03b1 :=\n  if hf : Injective f \u2227 \u2200 s, MeasurableSet s \u2192 NullMeasurableSet (f '' s) \u03bc then\n    (OuterMeasure.comap f \u03bc.toOuterMeasure).toMeasure fun s hs t => by\n      simp only [OuterMeasure.comap_apply, image_inter hf.1, image_diff hf.1]\n      exact (measure_inter_add_diff\u2080 _ (hf.2 s hs)).symm\n  else 0", "start": [1311, 1], "end": [1318, 9], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.comap_apply\u2080", "code": "theorem comap_apply\u2080 [MeasurableSpace \u03b1] (f : \u03b1 \u2192 \u03b2) (\u03bc : Measure \u03b2) (hfi : Injective f)\n    (hf : \u2200 s, MeasurableSet s \u2192 NullMeasurableSet (f '' s) \u03bc)\n    (hs : NullMeasurableSet s (comap f \u03bc)) : comap f \u03bc s = \u03bc (f '' s)", "start": [1321, 1], "end": [1325, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_comap_apply", "code": "theorem le_comap_apply {\u03b2} [MeasurableSpace \u03b1] {m\u03b2 : MeasurableSpace \u03b2} (f : \u03b1 \u2192 \u03b2) (\u03bc : Measure \u03b2)\n    (hfi : Injective f) (hf : \u2200 s, MeasurableSet s \u2192 NullMeasurableSet (f '' s) \u03bc) (s : Set \u03b1) :\n    \u03bc (f '' s) \u2264 comap f \u03bc s", "start": [1328, 1], "end": [1332, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.comap_apply", "code": "theorem comap_apply {\u03b2} [MeasurableSpace \u03b1] {_m\u03b2 : MeasurableSpace \u03b2} (f : \u03b1 \u2192 \u03b2)\n    (hfi : Injective f) (hf : \u2200 s, MeasurableSet s \u2192 MeasurableSet (f '' s)) (\u03bc : Measure \u03b2)\n    (hs : MeasurableSet s) : comap f \u03bc s = \u03bc (f '' s)", "start": [1335, 1], "end": [1338, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.comap\u2097_eq_comap", "code": "theorem comap\u2097_eq_comap {\u03b2} [MeasurableSpace \u03b1] {_m\u03b2 : MeasurableSpace \u03b2} (f : \u03b1 \u2192 \u03b2)\n    (hfi : Injective f) (hf : \u2200 s, MeasurableSet s \u2192 MeasurableSet (f '' s)) (\u03bc : Measure \u03b2)\n    (hs : MeasurableSet s) : comap\u2097 f \u03bc s = comap f \u03bc s", "start": [1341, 1], "end": [1344, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_image_eq_zero_of_comap_eq_zero", "code": "theorem measure_image_eq_zero_of_comap_eq_zero {\u03b2} [MeasurableSpace \u03b1] {_m\u03b2 : MeasurableSpace \u03b2}\n    (f : \u03b1 \u2192 \u03b2) (\u03bc : Measure \u03b2) (hfi : Injective f)\n    (hf : \u2200 s, MeasurableSet s \u2192 NullMeasurableSet (f '' s) \u03bc) {s : Set \u03b1} (hs : comap f \u03bc s = 0) :\n    \u03bc (f '' s) = 0", "start": [1347, 1], "end": [1351, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ae_eq_image_of_ae_eq_comap", "code": "theorem ae_eq_image_of_ae_eq_comap {\u03b2} [MeasurableSpace \u03b1] {m\u03b2 : MeasurableSpace \u03b2} (f : \u03b1 \u2192 \u03b2)\n    (\u03bc : Measure \u03b2) (hfi : Injective f) (hf : \u2200 s, MeasurableSet s \u2192 NullMeasurableSet (f '' s) \u03bc)\n    {s t : Set \u03b1} (hst : s =\u1d50[comap f \u03bc] t) : f '' s =\u1d50[\u03bc] f '' t", "start": [1354, 1], "end": [1369, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.NullMeasurableSet.image", "code": "theorem NullMeasurableSet.image {\u03b2} [MeasurableSpace \u03b1] {m\u03b2 : MeasurableSpace \u03b2} (f : \u03b1 \u2192 \u03b2)\n    (\u03bc : Measure \u03b2) (hfi : Injective f) (hf : \u2200 s, MeasurableSet s \u2192 NullMeasurableSet (f '' s) \u03bc)\n    {s : Set \u03b1} (hs : NullMeasurableSet s (\u03bc.comap f)) : NullMeasurableSet (f '' s) \u03bc", "start": [1372, 1], "end": [1381, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.comap_preimage", "code": "theorem comap_preimage {\u03b2} [MeasurableSpace \u03b1] {m\u03b2 : MeasurableSpace \u03b2} (f : \u03b1 \u2192 \u03b2) (\u03bc : Measure \u03b2)\n    {s : Set \u03b2} (hf : Injective f) (hf' : Measurable f)\n    (h : \u2200 t, MeasurableSet t \u2192 NullMeasurableSet (f '' t) \u03bc) (hs : MeasurableSet s) :\n    \u03bc.comap f (f \u207b\u00b9' s) = \u03bc (s \u2229 range f)", "start": [1384, 1], "end": [1388, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MeasurableSet.nullMeasurableSet_subtype_coe", "code": "theorem MeasurableSet.nullMeasurableSet_subtype_coe {t : Set s} (hs : NullMeasurableSet s \u03bc)\n    (ht : MeasurableSet t) : NullMeasurableSet ((\u2191) '' t) \u03bc", "start": [1398, 1], "end": [1414, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.NullMeasurableSet.subtype_coe", "code": "theorem NullMeasurableSet.subtype_coe {t : Set s} (hs : NullMeasurableSet s \u03bc)\n    (ht : NullMeasurableSet t (\u03bc.comap Subtype.val)) : NullMeasurableSet (((\u2191) : s \u2192 \u03b1) '' t) \u03bc", "start": [1417, 1], "end": [1420, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_subtype_coe_le_comap", "code": "theorem measure_subtype_coe_le_comap (hs : NullMeasurableSet s \u03bc) (t : Set s) :\n    \u03bc (((\u2191) : s \u2192 \u03b1) '' t) \u2264 \u03bc.comap Subtype.val t", "start": [1423, 1], "end": [1426, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_subtype_coe_eq_zero_of_comap_eq_zero", "code": "theorem measure_subtype_coe_eq_zero_of_comap_eq_zero (hs : NullMeasurableSet s \u03bc) {t : Set s}\n    (ht : \u03bc.comap Subtype.val t = 0) : \u03bc (((\u2191) : s \u2192 \u03b1) '' t) = 0", "start": [1429, 1], "end": [1431, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.Subtype.measureSpace", "code": "instance Subtype.measureSpace : MeasureSpace (Subtype p) :=\n  { Subtype.instMeasurableSpace with\n    volume := Measure.comap Subtype.val volume }", "start": [1450, 1], "end": [1452, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.Subtype.volume_def", "code": "theorem Subtype.volume_def : (volume : Measure s) = volume.comap Subtype.val", "start": [1455, 1], "end": [1456, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.Subtype.volume_univ", "code": "theorem Subtype.volume_univ (hs : NullMeasurableSet s) : volume (univ : Set s) = volume s", "start": [1459, 1], "end": [1464, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.volume_subtype_coe_le_volume", "code": "theorem volume_subtype_coe_le_volume (hs : NullMeasurableSet s) (t : Set s) :\n    volume (((\u2191) : s \u2192 \u03b1) '' t) \u2264 volume t", "start": [1467, 1], "end": [1469, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.volume_subtype_coe_eq_zero_of_volume_eq_zero", "code": "theorem volume_subtype_coe_eq_zero_of_volume_eq_zero (hs : NullMeasurableSet s) {t : Set s}\n    (ht : volume t = 0) : volume (((\u2191) : s \u2192 \u03b1) '' t) = 0", "start": [1472, 1], "end": [1474, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict\u2097", "code": "def restrict\u2097 {m0 : MeasurableSpace \u03b1} (s : Set \u03b1) : Measure \u03b1 \u2192\u2097[\u211d\u22650\u221e] Measure \u03b1 :=\n  liftLinear (OuterMeasure.restrict s) fun \u03bc s' hs' t => by\n    suffices \u03bc (s \u2229 t) = \u03bc (s \u2229 t \u2229 s') + \u03bc ((s \u2229 t) \\ s') by\n      simpa [\u2190 Set.inter_assoc, Set.inter_comm _ s, \u2190 inter_diff_assoc]\n    exact le_toOuterMeasure_caratheodory _ _ hs' _", "start": [1494, 1], "end": [1499, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict", "code": "def restrict {_m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) (s : Set \u03b1) : Measure \u03b1 :=\n  restrict\u2097 s \u03bc", "start": [1502, 1], "end": [1504, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict\u2097_apply", "code": "@[simp]\ntheorem restrict\u2097_apply {_m0 : MeasurableSpace \u03b1} (s : Set \u03b1) (\u03bc : Measure \u03b1) :\n    restrict\u2097 s \u03bc = \u03bc.restrict s", "start": [1507, 1], "end": [1510, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_toOuterMeasure_eq_toOuterMeasure_restrict", "code": "theorem restrict_toOuterMeasure_eq_toOuterMeasure_restrict (h : MeasurableSet s) :\n    (\u03bc.restrict s).toOuterMeasure = OuterMeasure.restrict s \u03bc.toOuterMeasure", "start": [1513, 1], "end": [1518, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_apply\u2080", "code": "theorem restrict_apply\u2080 (ht : NullMeasurableSet t (\u03bc.restrict s)) : \u03bc.restrict s t = \u03bc (t \u2229 s)", "start": [1521, 1], "end": [1526, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_apply", "code": "@[simp]\ntheorem restrict_apply (ht : MeasurableSet t) : \u03bc.restrict s t = \u03bc (t \u2229 s)", "start": [1529, 1], "end": [1534, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_mono'", "code": "theorem restrict_mono' {_m0 : MeasurableSpace \u03b1} \u2983s s' : Set \u03b1\u2984 \u2983\u03bc \u03bd : Measure \u03b1\u2984 (hs : s \u2264\u1d50[\u03bc] s')\n    (h\u03bc\u03bd : \u03bc \u2264 \u03bd) : \u03bc.restrict s \u2264 \u03bd.restrict s'", "start": [1537, 1], "end": [1544, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_mono", "code": "@[mono]\ntheorem restrict_mono {_m0 : MeasurableSpace \u03b1} \u2983s s' : Set \u03b1\u2984 (hs : s \u2286 s') \u2983\u03bc \u03bd : Measure \u03b1\u2984\n    (h\u03bc\u03bd : \u03bc \u2264 \u03bd) : \u03bc.restrict s \u2264 \u03bd.restrict s'", "start": [1548, 1], "end": [1552, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_mono_ae", "code": "theorem restrict_mono_ae (h : s \u2264\u1d50[\u03bc] t) : \u03bc.restrict s \u2264 \u03bc.restrict t", "start": [1555, 1], "end": [1556, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_congr_set", "code": "theorem restrict_congr_set (h : s =\u1d50[\u03bc] t) : \u03bc.restrict s = \u03bc.restrict t", "start": [1559, 1], "end": [1560, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_apply'", "code": "@[simp]\ntheorem restrict_apply' (hs : MeasurableSet s) : \u03bc.restrict s t = \u03bc (t \u2229 s)", "start": [1563, 1], "end": [1569, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_apply\u2080'", "code": "theorem restrict_apply\u2080' (hs : NullMeasurableSet s \u03bc) : \u03bc.restrict s t = \u03bc (t \u2229 s)", "start": [1572, 1], "end": [1575, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_le_self", "code": "theorem restrict_le_self : \u03bc.restrict s \u2264 \u03bc", "start": [1578, 1], "end": [1581, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_eq_self", "code": "theorem restrict_eq_self (h : s \u2286 t) : \u03bc.restrict t s = \u03bc s", "start": [1587, 1], "end": [1593, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_apply_self", "code": "@[simp]\ntheorem restrict_apply_self (s : Set \u03b1) : (\u03bc.restrict s) s = \u03bc s", "start": [1597, 1], "end": [1599, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_apply_univ", "code": "theorem restrict_apply_univ (s : Set \u03b1) : \u03bc.restrict s univ = \u03bc s", "start": [1604, 1], "end": [1605, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_restrict_apply", "code": "theorem le_restrict_apply (s t : Set \u03b1) : \u03bc (t \u2229 s) \u2264 \u03bc.restrict s t", "start": [1608, 1], "end": [1611, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_apply_superset", "code": "theorem restrict_apply_superset (h : s \u2286 t) : \u03bc.restrict s t = \u03bc s", "start": [1615, 1], "end": [1617, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_add", "code": "@[simp]\ntheorem restrict_add {_m0 : MeasurableSpace \u03b1} (\u03bc \u03bd : Measure \u03b1) (s : Set \u03b1) :\n    (\u03bc + \u03bd).restrict s = \u03bc.restrict s + \u03bd.restrict s", "start": [1620, 1], "end": [1623, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_zero", "code": "@[simp]\ntheorem restrict_zero {_m0 : MeasurableSpace \u03b1} (s : Set \u03b1) : (0 : Measure \u03b1).restrict s = 0", "start": [1626, 1], "end": [1628, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_smul", "code": "@[simp]\ntheorem restrict_smul {_m0 : MeasurableSpace \u03b1} (c : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) (s : Set \u03b1) :\n    (c \u2022 \u03bc).restrict s = c \u2022 \u03bc.restrict s", "start": [1631, 1], "end": [1634, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_restrict\u2080", "code": "theorem restrict_restrict\u2080 (hs : NullMeasurableSet s (\u03bc.restrict t)) :\n    (\u03bc.restrict t).restrict s = \u03bc.restrict (s \u2229 t)", "start": [1637, 1], "end": [1641, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_restrict", "code": "@[simp]\ntheorem restrict_restrict (hs : MeasurableSet s) : (\u03bc.restrict t).restrict s = \u03bc.restrict (s \u2229 t)", "start": [1644, 1], "end": [1646, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_restrict_of_subset", "code": "theorem restrict_restrict_of_subset (h : s \u2286 t) : (\u03bc.restrict t).restrict s = \u03bc.restrict s", "start": [1649, 1], "end": [1652, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_restrict\u2080'", "code": "theorem restrict_restrict\u2080' (ht : NullMeasurableSet t \u03bc) :\n    (\u03bc.restrict t).restrict s = \u03bc.restrict (s \u2229 t)", "start": [1655, 1], "end": [1657, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_restrict'", "code": "theorem restrict_restrict' (ht : MeasurableSet t) :\n    (\u03bc.restrict t).restrict s = \u03bc.restrict (s \u2229 t)", "start": [1660, 1], "end": [1662, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_comm", "code": "theorem restrict_comm (hs : MeasurableSet s) :\n    (\u03bc.restrict t).restrict s = (\u03bc.restrict s).restrict t", "start": [1665, 1], "end": [1667, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_apply_eq_zero", "code": "theorem restrict_apply_eq_zero (ht : MeasurableSet t) : \u03bc.restrict s t = 0 \u2194 \u03bc (t \u2229 s) = 0", "start": [1670, 1], "end": [1671, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_inter_eq_zero_of_restrict", "code": "theorem measure_inter_eq_zero_of_restrict (h : \u03bc.restrict s t = 0) : \u03bc (t \u2229 s) = 0", "start": [1674, 1], "end": [1675, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_apply_eq_zero'", "code": "theorem restrict_apply_eq_zero' (hs : MeasurableSet s) : \u03bc.restrict s t = 0 \u2194 \u03bc (t \u2229 s) = 0", "start": [1678, 1], "end": [1679, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_eq_zero", "code": "@[simp]\ntheorem restrict_eq_zero : \u03bc.restrict s = 0 \u2194 \u03bc s = 0", "start": [1682, 1], "end": [1684, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict.neZero", "code": "instance restrict.neZero [NeZero (\u03bc s)] : NeZero (\u03bc.restrict s) :=\n  \u27e8mt restrict_eq_zero.mp <| NeZero.ne _\u27e9", "start": [1687, 1], "end": [1689, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_zero_set", "code": "theorem restrict_zero_set {s : Set \u03b1} (h : \u03bc s = 0) : \u03bc.restrict s = 0", "start": [1691, 1], "end": [1692, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_empty", "code": "@[simp]\ntheorem restrict_empty : \u03bc.restrict \u2205 = 0", "start": [1695, 1], "end": [1697, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_univ", "code": "@[simp]\ntheorem restrict_univ : \u03bc.restrict univ = \u03bc", "start": [1700, 1], "end": [1702, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_inter_add_diff\u2080", "code": "theorem restrict_inter_add_diff\u2080 (s : Set \u03b1) (ht : NullMeasurableSet t \u03bc) :\n    \u03bc.restrict (s \u2229 t) + \u03bc.restrict (s \\ t) = \u03bc.restrict s", "start": [1705, 1], "end": [1709, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_inter_add_diff", "code": "theorem restrict_inter_add_diff (s : Set \u03b1) (ht : MeasurableSet t) :\n    \u03bc.restrict (s \u2229 t) + \u03bc.restrict (s \\ t) = \u03bc.restrict s", "start": [1712, 1], "end": [1714, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_union_add_inter\u2080", "code": "theorem restrict_union_add_inter\u2080 (s : Set \u03b1) (ht : NullMeasurableSet t \u03bc) :\n    \u03bc.restrict (s \u222a t) + \u03bc.restrict (s \u2229 t) = \u03bc.restrict s + \u03bc.restrict t", "start": [1717, 1], "end": [1720, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_union_add_inter", "code": "theorem restrict_union_add_inter (s : Set \u03b1) (ht : MeasurableSet t) :\n    \u03bc.restrict (s \u222a t) + \u03bc.restrict (s \u2229 t) = \u03bc.restrict s + \u03bc.restrict t", "start": [1723, 1], "end": [1725, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_union_add_inter'", "code": "theorem restrict_union_add_inter' (hs : MeasurableSet s) (t : Set \u03b1) :\n    \u03bc.restrict (s \u222a t) + \u03bc.restrict (s \u2229 t) = \u03bc.restrict s + \u03bc.restrict t", "start": [1728, 1], "end": [1730, 84], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_union\u2080", "code": "theorem restrict_union\u2080 (h : AEDisjoint \u03bc s t) (ht : NullMeasurableSet t \u03bc) :\n    \u03bc.restrict (s \u222a t) = \u03bc.restrict s + \u03bc.restrict t", "start": [1733, 1], "end": [1735, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_union", "code": "theorem restrict_union (h : Disjoint s t) (ht : MeasurableSet t) :\n    \u03bc.restrict (s \u222a t) = \u03bc.restrict s + \u03bc.restrict t", "start": [1738, 1], "end": [1740, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_union'", "code": "theorem restrict_union' (h : Disjoint s t) (hs : MeasurableSet s) :\n    \u03bc.restrict (s \u222a t) = \u03bc.restrict s + \u03bc.restrict t", "start": [1743, 1], "end": [1745, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_add_restrict_compl", "code": "@[simp]\ntheorem restrict_add_restrict_compl (hs : MeasurableSet s) :\n    \u03bc.restrict s + \u03bc.restrict s\u1d9c = \u03bc", "start": [1748, 1], "end": [1752, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_compl_add_restrict", "code": "@[simp]\ntheorem restrict_compl_add_restrict (hs : MeasurableSet s) : \u03bc.restrict s\u1d9c + \u03bc.restrict s = \u03bc", "start": [1755, 1], "end": [1757, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_union_le", "code": "theorem restrict_union_le (s s' : Set \u03b1) : \u03bc.restrict (s \u222a s') \u2264 \u03bc.restrict s + \u03bc.restrict s'", "start": [1760, 1], "end": [1763, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_iUnion_apply_ae", "code": "theorem restrict_iUnion_apply_ae [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} (hd : Pairwise (AEDisjoint \u03bc on s))\n    (hm : \u2200 i, NullMeasurableSet (s i) \u03bc) {t : Set \u03b1} (ht : MeasurableSet t) :\n    \u03bc.restrict (\u22c3 i, s i) t = \u2211' i, \u03bc.restrict (s i) t", "start": [1766, 1], "end": [1772, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_iUnion_apply", "code": "theorem restrict_iUnion_apply [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} (hd : Pairwise (Disjoint on s))\n    (hm : \u2200 i, MeasurableSet (s i)) {t : Set \u03b1} (ht : MeasurableSet t) :\n    \u03bc.restrict (\u22c3 i, s i) t = \u2211' i, \u03bc.restrict (s i) t", "start": [1775, 1], "end": [1778, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_iUnion_apply_eq_iSup", "code": "theorem restrict_iUnion_apply_eq_iSup [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} (hd : Directed (\u00b7 \u2286 \u00b7) s)\n    {t : Set \u03b1} (ht : MeasurableSet t) : \u03bc.restrict (\u22c3 i, s i) t = \u2a06 i, \u03bc.restrict (s i) t", "start": [1781, 1], "end": [1785, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_map", "code": "theorem restrict_map {f : \u03b1 \u2192 \u03b2} (hf : Measurable f) {s : Set \u03b2} (hs : MeasurableSet s) :\n    (\u03bc.map f).restrict s = (\u03bc.restrict <| f \u207b\u00b9' s).map f", "start": [1788, 1], "end": [1792, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_toMeasurable", "code": "theorem restrict_toMeasurable (h : \u03bc s \u2260 \u221e) : \u03bc.restrict (toMeasurable \u03bc s) = \u03bc.restrict s", "start": [1795, 1], "end": [1798, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_eq_self_of_ae_mem", "code": "theorem restrict_eq_self_of_ae_mem {_m0 : MeasurableSpace \u03b1} \u2983s : Set \u03b1\u2984 \u2983\u03bc : Measure \u03b1\u2984\n    (hs : \u2200\u1d50 x \u2202\u03bc, x \u2208 s) : \u03bc.restrict s = \u03bc", "start": [1801, 1], "end": [1805, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_congr_meas", "code": "theorem restrict_congr_meas (hs : MeasurableSet s) :\n    \u03bc.restrict s = \u03bd.restrict s \u2194 \u2200 (t) (_ : t \u2286 s), MeasurableSet t \u2192 \u03bc t = \u03bd t", "start": [1809, 1], "end": [1814, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_congr_mono", "code": "theorem restrict_congr_mono (hs : s \u2286 t) (h : \u03bc.restrict t = \u03bd.restrict t) :\n    \u03bc.restrict s = \u03bd.restrict s", "start": [1817, 1], "end": [1819, 75], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_union_congr", "code": "theorem restrict_union_congr :\n    \u03bc.restrict (s \u222a t) = \u03bd.restrict (s \u222a t) \u2194\n      \u03bc.restrict s = \u03bd.restrict s \u2227 \u03bc.restrict t = \u03bd.restrict t", "start": [1822, 1], "end": [1846, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_finset_biUnion_congr", "code": "theorem restrict_finset_biUnion_congr {s : Finset \u03b9} {t : \u03b9 \u2192 Set \u03b1} :\n    \u03bc.restrict (\u22c3 i \u2208 s, t i) = \u03bd.restrict (\u22c3 i \u2208 s, t i) \u2194\n      \u2200 i \u2208 s, \u03bc.restrict (t i) = \u03bd.restrict (t i)", "start": [1850, 1], "end": [1855, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_iUnion_congr", "code": "theorem restrict_iUnion_congr [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} :\n    \u03bc.restrict (\u22c3 i, s i) = \u03bd.restrict (\u22c3 i, s i) \u2194 \u2200 i, \u03bc.restrict (s i) = \u03bd.restrict (s i)", "start": [1858, 1], "end": [1865, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_biUnion_congr", "code": "theorem restrict_biUnion_congr {s : Set \u03b9} {t : \u03b9 \u2192 Set \u03b1} (hc : s.Countable) :\n    \u03bc.restrict (\u22c3 i \u2208 s, t i) = \u03bd.restrict (\u22c3 i \u2208 s, t i) \u2194\n      \u2200 i \u2208 s, \u03bc.restrict (t i) = \u03bd.restrict (t i)", "start": [1868, 1], "end": [1872, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_sUnion_congr", "code": "theorem restrict_sUnion_congr {S : Set (Set \u03b1)} (hc : S.Countable) :\n    \u03bc.restrict (\u22c3\u2080 S) = \u03bd.restrict (\u22c3\u2080 S) \u2194 \u2200 s \u2208 S, \u03bc.restrict s = \u03bd.restrict s", "start": [1875, 1], "end": [1877, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_sInf_eq_sInf_restrict", "code": "theorem restrict_sInf_eq_sInf_restrict {m0 : MeasurableSpace \u03b1} {m : Set (Measure \u03b1)}\n    (hm : m.Nonempty) (ht : MeasurableSet t) :\n    (sInf m).restrict t = sInf ((fun \u03bc : Measure \u03b1 => \u03bc.restrict t) '' m)", "start": [1880, 1], "end": [1888, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.exists_mem_of_measure_ne_zero_of_ae", "code": "theorem exists_mem_of_measure_ne_zero_of_ae (hs : \u03bc s \u2260 0) {p : \u03b1 \u2192 Prop}\n    (hp : \u2200\u1d50 x \u2202\u03bc.restrict s, p x) : \u2203 x, x \u2208 s \u2227 p x", "start": [1891, 1], "end": [1894, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_iff_of_iUnion_eq_univ", "code": "theorem ext_iff_of_iUnion_eq_univ [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} (hs : \u22c3 i, s i = univ) :\n    \u03bc = \u03bd \u2194 \u2200 i, \u03bc.restrict (s i) = \u03bd.restrict (s i)", "start": [1900, 1], "end": [1904, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_of_iUnion_eq_univ", "code": "alias \u27e8_, ext_of_iUnion_eq_univ\u27e9 := ext_iff_of_iUnion_eq_univ", "start": [1907, 1], "end": [1907, 62], "kind": "stdtacticaliasaliaslr"}, {"full_name": "MeasureTheory.Measure.ext_iff_of_biUnion_eq_univ", "code": "theorem ext_iff_of_biUnion_eq_univ {S : Set \u03b9} {s : \u03b9 \u2192 Set \u03b1} (hc : S.Countable)\n    (hs : \u22c3 i \u2208 S, s i = univ) : \u03bc = \u03bd \u2194 \u2200 i \u2208 S, \u03bc.restrict (s i) = \u03bd.restrict (s i)", "start": [1910, 1], "end": [1914, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_of_biUnion_eq_univ", "code": "alias \u27e8_, ext_of_biUnion_eq_univ\u27e9 := ext_iff_of_biUnion_eq_univ", "start": [1917, 1], "end": [1917, 64], "kind": "stdtacticaliasaliaslr"}, {"full_name": "MeasureTheory.Measure.ext_iff_of_sUnion_eq_univ", "code": "theorem ext_iff_of_sUnion_eq_univ {S : Set (Set \u03b1)} (hc : S.Countable) (hs : \u22c3\u2080 S = univ) :\n    \u03bc = \u03bd \u2194 \u2200 s \u2208 S, \u03bc.restrict s = \u03bd.restrict s", "start": [1920, 1], "end": [1924, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_of_sUnion_eq_univ", "code": "alias \u27e8_, ext_of_sUnion_eq_univ\u27e9 := ext_iff_of_sUnion_eq_univ", "start": [1927, 1], "end": [1927, 62], "kind": "stdtacticaliasaliaslr"}, {"full_name": "MeasureTheory.Measure.ext_of_generateFrom_of_cover", "code": "theorem ext_of_generateFrom_of_cover {S T : Set (Set \u03b1)} (h_gen : \u2039_\u203a = generateFrom S)\n    (hc : T.Countable) (h_inter : IsPiSystem S) (hU : \u22c3\u2080 T = univ) (htop : \u2200 t \u2208 T, \u03bc t \u2260 \u221e)\n    (ST_eq : \u2200 t \u2208 T, \u2200 s \u2208 S, \u03bc (s \u2229 t) = \u03bd (s \u2229 t)) (T_eq : \u2200 t \u2208 T, \u03bc t = \u03bd t) : \u03bc = \u03bd", "start": [1930, 1], "end": [1946, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_of_generateFrom_of_cover_subset", "code": "theorem ext_of_generateFrom_of_cover_subset {S T : Set (Set \u03b1)} (h_gen : \u2039_\u203a = generateFrom S)\n    (h_inter : IsPiSystem S) (h_sub : T \u2286 S) (hc : T.Countable) (hU : \u22c3\u2080 T = univ)\n    (htop : \u2200 s \u2208 T, \u03bc s \u2260 \u221e) (h_eq : \u2200 s \u2208 S, \u03bc s = \u03bd s) : \u03bc = \u03bd", "start": [1949, 1], "end": [1958, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_of_generateFrom_of_iUnion", "code": "theorem ext_of_generateFrom_of_iUnion (C : Set (Set \u03b1)) (B : \u2115 \u2192 Set \u03b1) (hA : \u2039_\u203a = generateFrom C)\n    (hC : IsPiSystem C) (h1B : \u22c3 i, B i = univ) (h2B : \u2200 i, B i \u2208 C) (h\u03bcB : \u2200 i, \u03bc (B i) \u2260 \u221e)\n    (h_eq : \u2200 s \u2208 C, \u03bc s = \u03bd s) : \u03bc = \u03bd", "start": [1961, 1], "end": [1972, 14], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sum", "code": "def sum (f : \u03b9 \u2192 Measure \u03b1) : Measure \u03b1 :=\n  (OuterMeasure.sum fun i => (f i).toOuterMeasure).toMeasure <|\n    le_trans (le_iInf fun _ => le_toOuterMeasure_caratheodory _)\n      (OuterMeasure.le_sum_caratheodory _)", "start": [1977, 1], "end": [1981, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_sum_apply", "code": "theorem le_sum_apply (f : \u03b9 \u2192 Measure \u03b1) (s : Set \u03b1) : \u2211' i, f i s \u2264 sum f s", "start": [1984, 1], "end": [1985, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sum_apply", "code": "@[simp]\ntheorem sum_apply (f : \u03b9 \u2192 Measure \u03b1) {s : Set \u03b1} (hs : MeasurableSet s) : sum f s = \u2211' i, f i s", "start": [1988, 1], "end": [1990, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_sum", "code": "theorem le_sum (\u03bc : \u03b9 \u2192 Measure \u03b1) (i : \u03b9) : \u03bc i \u2264 sum \u03bc", "start": [1993, 1], "end": [1994, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sum_apply_eq_zero", "code": "@[simp]\ntheorem sum_apply_eq_zero [Countable \u03b9] {\u03bc : \u03b9 \u2192 Measure \u03b1} {s : Set \u03b1} :\n    sum \u03bc s = 0 \u2194 \u2200 i, \u03bc i s = 0", "start": [1997, 1], "end": [2006, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sum_apply_eq_zero'", "code": "theorem sum_apply_eq_zero' {\u03bc : \u03b9 \u2192 Measure \u03b1} {s : Set \u03b1} (hs : MeasurableSet s) :\n    sum \u03bc s = 0 \u2194 \u2200 i, \u03bc i s = 0", "start": [2010, 1], "end": [2011, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sum_comm", "code": "theorem sum_comm {\u03b9' : Type*} (\u03bc : \u03b9 \u2192 \u03b9' \u2192 Measure \u03b1) :\n    (sum fun n => sum (\u03bc n)) = sum fun m => sum fun n => \u03bc n m", "start": [2014, 1], "end": [2018, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ae_sum_iff", "code": "theorem ae_sum_iff [Countable \u03b9] {\u03bc : \u03b9 \u2192 Measure \u03b1} {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1d50 x \u2202sum \u03bc, p x) \u2194 \u2200 i, \u2200\u1d50 x \u2202\u03bc i, p x", "start": [2021, 1], "end": [2023, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ae_sum_iff'", "code": "theorem ae_sum_iff' {\u03bc : \u03b9 \u2192 Measure \u03b1} {p : \u03b1 \u2192 Prop} (h : MeasurableSet { x | p x }) :\n    (\u2200\u1d50 x \u2202sum \u03bc, p x) \u2194 \u2200 i, \u2200\u1d50 x \u2202\u03bc i, p x", "start": [2026, 1], "end": [2028, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sum_fintype", "code": "@[simp]\ntheorem sum_fintype [Fintype \u03b9] (\u03bc : \u03b9 \u2192 Measure \u03b1) : sum \u03bc = \u2211 i, \u03bc i", "start": [2031, 1], "end": [2034, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sum_coe_finset", "code": "@[simp, nolint simpNF]\ntheorem sum_coe_finset (s : Finset \u03b9) (\u03bc : \u03b9 \u2192 Measure \u03b1) :\n    (sum fun i : s => \u03bc i) = \u2211 i in s, \u03bc i", "start": [2039, 1], "end": [2041, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ae_sum_eq", "code": "@[simp]\ntheorem ae_sum_eq [Countable \u03b9] (\u03bc : \u03b9 \u2192 Measure \u03b1) : (sum \u03bc).ae = \u2a06 i, (\u03bc i).ae", "start": [2044, 1], "end": [2046, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sum_bool", "code": "theorem sum_bool (f : Bool \u2192 Measure \u03b1) : sum f = f true + f false", "start": [2050, 1], "end": [2051, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sum_cond", "code": "theorem sum_cond (\u03bc \u03bd : Measure \u03b1) : (sum fun b => cond b \u03bc \u03bd) = \u03bc + \u03bd", "start": [2055, 1], "end": [2056, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_sum", "code": "@[simp]\ntheorem restrict_sum (\u03bc : \u03b9 \u2192 Measure \u03b1) {s : Set \u03b1} (hs : MeasurableSet s) :\n    (sum \u03bc).restrict s = sum fun i => (\u03bc i).restrict s", "start": [2059, 1], "end": [2062, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sum_of_empty", "code": "theorem sum_of_empty [IsEmpty \u03b9] (\u03bc : \u03b9 \u2192 Measure \u03b1) : sum \u03bc = 0", "start": [2066, 1], "end": [2067, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sum_add_sum_compl", "code": "theorem sum_add_sum_compl (s : Set \u03b9) (\u03bc : \u03b9 \u2192 Measure \u03b1) :\n    ((sum fun i : s => \u03bc i) + sum fun i : \u21a5s\u1d9c => \u03bc i) = sum \u03bc", "start": [2070, 1], "end": [2074, 84], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sum_congr", "code": "theorem sum_congr {\u03bc \u03bd : \u2115 \u2192 Measure \u03b1} (h : \u2200 n, \u03bc n = \u03bd n) : sum \u03bc = sum \u03bd", "start": [2077, 1], "end": [2078, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sum_add_sum", "code": "theorem sum_add_sum (\u03bc \u03bd : \u2115 \u2192 Measure \u03b1) : sum \u03bc + sum \u03bd = sum fun n => \u03bc n + \u03bd n", "start": [2081, 1], "end": [2084, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_iUnion_ae", "code": "theorem restrict_iUnion_ae [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} (hd : Pairwise (AEDisjoint \u03bc on s))\n    (hm : \u2200 i, NullMeasurableSet (s i) \u03bc) : \u03bc.restrict (\u22c3 i, s i) = sum fun i => \u03bc.restrict (s i)", "start": [2089, 1], "end": [2091, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_iUnion", "code": "theorem restrict_iUnion [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} (hd : Pairwise (Disjoint on s))\n    (hm : \u2200 i, MeasurableSet (s i)) : \u03bc.restrict (\u22c3 i, s i) = sum fun i => \u03bc.restrict (s i)", "start": [2094, 1], "end": [2096, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_iUnion_le", "code": "theorem restrict_iUnion_le [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} :\n    \u03bc.restrict (\u22c3 i, s i) \u2264 sum fun i => \u03bc.restrict (s i)", "start": [2099, 1], "end": [2103, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.AbsolutelyContinuous", "code": "def AbsolutelyContinuous {_m0 : MeasurableSpace \u03b1} (\u03bc \u03bd : Measure \u03b1) : Prop :=\n  \u2200 \u2983s : Set \u03b1\u2984, \u03bd s = 0 \u2192 \u03bc s = 0", "start": [2109, 1], "end": [2112, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.absolutelyContinuous_of_le", "code": "theorem absolutelyContinuous_of_le (h : \u03bc \u2264 \u03bd) : \u03bc \u226a \u03bd", "start": [2119, 1], "end": [2120, 45], "kind": "commanddeclaration"}, {"full_name": "LE.le.absolutelyContinuous", "code": "alias _root_.LE.le.absolutelyContinuous := absolutelyContinuous_of_le", "start": [2123, 1], "end": [2123, 70], "kind": "stdtacticaliasalias"}, {"full_name": "MeasureTheory.Measure.absolutelyContinuous_of_eq", "code": "theorem absolutelyContinuous_of_eq (h : \u03bc = \u03bd) : \u03bc \u226a \u03bd", "start": [2126, 1], "end": [2127, 28], "kind": "commanddeclaration"}, {"full_name": "Eq.absolutelyContinuous", "code": "alias _root_.Eq.absolutelyContinuous := absolutelyContinuous_of_eq", "start": [2130, 1], "end": [2130, 67], "kind": "stdtacticaliasalias"}, {"full_name": "MeasureTheory.Measure.AbsolutelyContinuous.mk", "code": "theorem mk (h : \u2200 \u2983s : Set \u03b1\u2984, MeasurableSet s \u2192 \u03bd s = 0 \u2192 \u03bc s = 0) : \u03bc \u226a \u03bd", "start": [2135, 1], "end": [2138, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.AbsolutelyContinuous.refl", "code": "@[refl]\nprotected theorem refl {_m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) : \u03bc \u226a \u03bc", "start": [2141, 1], "end": [2143, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.AbsolutelyContinuous.rfl", "code": "protected theorem rfl : \u03bc \u226a \u03bc", "start": [2146, 1], "end": [2146, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.AbsolutelyContinuous.instIsRefl", "code": "instance instIsRefl [MeasurableSpace \u03b1] : IsRefl (Measure \u03b1) (\u00b7 \u226a \u00b7) :=\n  \u27e8fun _ => AbsolutelyContinuous.rfl\u27e9", "start": [2149, 1], "end": [2150, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.AbsolutelyContinuous.trans", "code": "@[trans]\nprotected theorem trans (h1 : \u03bc\u2081 \u226a \u03bc\u2082) (h2 : \u03bc\u2082 \u226a \u03bc\u2083) : \u03bc\u2081 \u226a \u03bc\u2083", "start": [2153, 1], "end": [2154, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.AbsolutelyContinuous.map", "code": "@[mono]\nprotected theorem map (h : \u03bc \u226a \u03bd) {f : \u03b1 \u2192 \u03b2} (hf : Measurable f) : \u03bc.map f \u226a \u03bd.map f", "start": [2157, 1], "end": [2159, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.AbsolutelyContinuous.smul", "code": "protected theorem smul [Monoid R] [DistribMulAction R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]\n    (h : \u03bc \u226a \u03bd) (c : R) : c \u2022 \u03bc \u226a \u03bd", "start": [2162, 1], "end": [2164, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.absolutelyContinuous_of_le_smul", "code": "theorem absolutelyContinuous_of_le_smul {\u03bc' : Measure \u03b1} {c : \u211d\u22650\u221e} (h\u03bc'_le : \u03bc' \u2264 c \u2022 \u03bc) :\n    \u03bc' \u226a \u03bc", "start": [2169, 1], "end": [2171, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ae_le_iff_absolutelyContinuous", "code": "theorem ae_le_iff_absolutelyContinuous : \u03bc.ae \u2264 \u03bd.ae \u2194 \u03bc \u226a \u03bd", "start": [2174, 1], "end": [2177, 46], "kind": "commanddeclaration"}, {"full_name": "LE.le.absolutelyContinuous_of_ae", "code": "alias \u27e8_root_.LE.le.absolutelyContinuous_of_ae, AbsolutelyContinuous.ae_le\u27e9 :=\n  ae_le_iff_absolutelyContinuous", "start": [2180, 1], "end": [2181, 33], "kind": "stdtacticaliasaliaslr"}, {"full_name": "MeasureTheory.Measure.AbsolutelyContinuous.ae_le", "code": "alias \u27e8_root_.LE.le.absolutelyContinuous_of_ae, AbsolutelyContinuous.ae_le\u27e9 :=\n  ae_le_iff_absolutelyContinuous", "start": [2180, 1], "end": [2181, 33], "kind": "stdtacticaliasaliaslr"}, {"full_name": "MeasureTheory.Measure.ae_mono'", "code": "alias ae_mono' := AbsolutelyContinuous.ae_le", "start": [2185, 1], "end": [2185, 45], "kind": "stdtacticaliasalias"}, {"full_name": "MeasureTheory.Measure.AbsolutelyContinuous.ae_eq", "code": "theorem AbsolutelyContinuous.ae_eq (h : \u03bc \u226a \u03bd) {f g : \u03b1 \u2192 \u03b4} (h' : f =\u1d50[\u03bd] g) : f =\u1d50[\u03bc] g", "start": [2188, 1], "end": [2189, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving", "code": "structure QuasiMeasurePreserving {m0 : MeasurableSpace \u03b1} (f : \u03b1 \u2192 \u03b2)\n  (\u03bca : Measure \u03b1 := by volume_tac)\n  (\u03bcb : Measure \u03b2 := by volume_tac) : Prop where\n  protected measurable : Measurable f\n  protected absolutelyContinuous : \u03bca.map f \u226a \u03bcb", "start": [2195, 1], "end": [2201, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.id", "code": "protected theorem id {_m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) : QuasiMeasurePreserving id \u03bc \u03bc", "start": [2208, 1], "end": [2209, 47], "kind": "commanddeclaration"}, {"full_name": "Measurable.quasiMeasurePreserving", "code": "protected theorem _root_.Measurable.quasiMeasurePreserving\n    {_m0 : MeasurableSpace \u03b1} (hf : Measurable f) (\u03bc : Measure \u03b1) :\n    QuasiMeasurePreserving f \u03bc (\u03bc.map f)", "start": [2214, 1], "end": [2217, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.mono_left", "code": "theorem mono_left (h : QuasiMeasurePreserving f \u03bca \u03bcb) (ha : \u03bca' \u226a \u03bca) :\n    QuasiMeasurePreserving f \u03bca' \u03bcb", "start": [2220, 1], "end": [2222, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.mono_right", "code": "theorem mono_right (h : QuasiMeasurePreserving f \u03bca \u03bcb) (ha : \u03bcb \u226a \u03bcb') :\n    QuasiMeasurePreserving f \u03bca \u03bcb'", "start": [2225, 1], "end": [2227, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.mono", "code": "@[mono]\ntheorem mono (ha : \u03bca' \u226a \u03bca) (hb : \u03bcb \u226a \u03bcb') (h : QuasiMeasurePreserving f \u03bca \u03bcb) :\n    QuasiMeasurePreserving f \u03bca' \u03bcb'", "start": [2230, 1], "end": [2233, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.comp", "code": "protected theorem comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : QuasiMeasurePreserving g \u03bcb \u03bcc)\n    (hf : QuasiMeasurePreserving f \u03bca \u03bcb) : QuasiMeasurePreserving (g \u2218 f) \u03bca \u03bcc", "start": [2236, 1], "end": [2240, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.iterate", "code": "protected theorem iterate {f : \u03b1 \u2192 \u03b1} (hf : QuasiMeasurePreserving f \u03bca \u03bca) :\n    \u2200 n, QuasiMeasurePreserving f^[n] \u03bca \u03bca", "start": [2243, 1], "end": [2246, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.aemeasurable", "code": "protected theorem aemeasurable (hf : QuasiMeasurePreserving f \u03bca \u03bcb) : AEMeasurable f \u03bca", "start": [2249, 1], "end": [2250, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.ae_map_le", "code": "theorem ae_map_le (h : QuasiMeasurePreserving f \u03bca \u03bcb) : (\u03bca.map f).ae \u2264 \u03bcb.ae", "start": [2253, 1], "end": [2254, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.tendsto_ae", "code": "theorem tendsto_ae (h : QuasiMeasurePreserving f \u03bca \u03bcb) : Tendsto f \u03bca.ae \u03bcb.ae", "start": [2257, 1], "end": [2258, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.ae", "code": "theorem ae (h : QuasiMeasurePreserving f \u03bca \u03bcb) {p : \u03b2 \u2192 Prop} (hg : \u2200\u1d50 x \u2202\u03bcb, p x) :\n    \u2200\u1d50 x \u2202\u03bca, p (f x)", "start": [2261, 1], "end": [2263, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.ae_eq", "code": "theorem ae_eq (h : QuasiMeasurePreserving f \u03bca \u03bcb) {g\u2081 g\u2082 : \u03b2 \u2192 \u03b4} (hg : g\u2081 =\u1d50[\u03bcb] g\u2082) :\n    g\u2081 \u2218 f =\u1d50[\u03bca] g\u2082 \u2218 f", "start": [2266, 1], "end": [2268, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.preimage_null", "code": "theorem preimage_null (h : QuasiMeasurePreserving f \u03bca \u03bcb) {s : Set \u03b2} (hs : \u03bcb s = 0) :\n    \u03bca (f \u207b\u00b9' s) = 0", "start": [2271, 1], "end": [2273, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.preimage_mono_ae", "code": "theorem preimage_mono_ae {s t : Set \u03b2} (hf : QuasiMeasurePreserving f \u03bca \u03bcb) (h : s \u2264\u1d50[\u03bcb] t) :\n    f \u207b\u00b9' s \u2264\u1d50[\u03bca] f \u207b\u00b9' t", "start": [2276, 1], "end": [2279, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.preimage_ae_eq", "code": "theorem preimage_ae_eq {s t : Set \u03b2} (hf : QuasiMeasurePreserving f \u03bca \u03bcb) (h : s =\u1d50[\u03bcb] t) :\n    f \u207b\u00b9' s =\u1d50[\u03bca] f \u207b\u00b9' t", "start": [2282, 1], "end": [2284, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.preimage_iterate_ae_eq", "code": "theorem preimage_iterate_ae_eq {s : Set \u03b1} {f : \u03b1 \u2192 \u03b1} (hf : QuasiMeasurePreserving f \u03bc \u03bc) (k : \u2115)\n    (hs : f \u207b\u00b9' s =\u1d50[\u03bc] s) : f^[k] \u207b\u00b9' s =\u1d50[\u03bc] s", "start": [2287, 1], "end": [2291, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.image_zpow_ae_eq", "code": "theorem image_zpow_ae_eq {s : Set \u03b1} {e : \u03b1 \u2243 \u03b1} (he : QuasiMeasurePreserving e \u03bc \u03bc)\n    (he' : QuasiMeasurePreserving e.symm \u03bc \u03bc) (k : \u2124) (hs : e '' s =\u1d50[\u03bc] s) :\n    (\u21d1(e ^ k)) '' s =\u1d50[\u03bc] s", "start": [2294, 1], "end": [2308, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.limsup_preimage_iterate_ae_eq", "code": "theorem limsup_preimage_iterate_ae_eq {f : \u03b1 \u2192 \u03b1} (hf : QuasiMeasurePreserving f \u03bc \u03bc)\n    (hs : f \u207b\u00b9' s =\u1d50[\u03bc] s) : @limsup (Set \u03b1) \u2115 _ (fun n => (preimage f)^[n] s) atTop =\u1d50[\u03bc] s", "start": [2311, 1], "end": [2319, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.liminf_preimage_iterate_ae_eq", "code": "theorem liminf_preimage_iterate_ae_eq {f : \u03b1 \u2192 \u03b1} (hf : QuasiMeasurePreserving f \u03bc \u03bc)\n    (hs : f \u207b\u00b9' s =\u1d50[\u03bc] s) : @liminf (Set \u03b1) \u2115 _ (fun n => (preimage f)^[n] s) atTop =\u1d50[\u03bc] s", "start": [2322, 1], "end": [2329, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.exists_preimage_eq_of_preimage_ae", "code": "theorem exists_preimage_eq_of_preimage_ae {f : \u03b1 \u2192 \u03b1} (h : QuasiMeasurePreserving f \u03bc \u03bc)\n    (hs : MeasurableSet s) (hs' : f \u207b\u00b9' s =\u1d50[\u03bc] s) :\n    \u2203 t : Set \u03b1, MeasurableSet t \u2227 t =\u1d50[\u03bc] s \u2227 f \u207b\u00b9' t = t", "start": [2332, 1], "end": [2343, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.smul_ae_eq_of_ae_eq", "code": "@[to_additive]\ntheorem smul_ae_eq_of_ae_eq {G \u03b1 : Type*} [Group G] [MulAction G \u03b1] [MeasurableSpace \u03b1]\n    {s t : Set \u03b1} {\u03bc : Measure \u03b1} (g : G)\n    (h_qmp : QuasiMeasurePreserving ((\u00b7 \u2022 \u00b7) g\u207b\u00b9 : \u03b1 \u2192 \u03b1) \u03bc \u03bc)\n    (h_ae_eq : s =\u1d50[\u03bc] t) : (g \u2022 s : Set \u03b1) =\u1d50[\u03bc] (g \u2022 t : Set \u03b1)", "start": [2348, 1], "end": [2353, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.pairwise_aedisjoint_of_aedisjoint_forall_ne_one", "code": "@[to_additive]\ntheorem pairwise_aedisjoint_of_aedisjoint_forall_ne_one {G \u03b1 : Type*} [Group G] [MulAction G \u03b1]\n    [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (h_ae_disjoint : \u2200 (g) (_ : g \u2260 (1 : G)), AEDisjoint \u03bc (g \u2022 s) s)\n    (h_qmp : \u2200 g : G, QuasiMeasurePreserving ((\u00b7 \u2022 \u00b7) g : \u03b1 \u2192 \u03b1) \u03bc \u03bc) :\n    Pairwise (AEDisjoint \u03bc on fun g : G => g \u2022 s)", "start": [2363, 1], "end": [2378, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.cofinite", "code": "def cofinite {m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) : Filter \u03b1 where\n  sets := { s | \u03bc s\u1d9c < \u221e }\n  univ_sets := by simp\n  inter_sets {s t} hs ht := by\n    simp only [compl_inter, mem_setOf_eq]\n    calc\n      \u03bc (s\u1d9c \u222a t\u1d9c) \u2264 \u03bc s\u1d9c + \u03bc t\u1d9c := measure_union_le _ _\n      _ < \u221e := ENNReal.add_lt_top.2 \u27e8hs, ht\u27e9\n  sets_of_superset {s t} hs hst := lt_of_le_of_lt (measure_mono <| compl_subset_compl.2 hst) hs", "start": [2386, 1], "end": [2395, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.mem_cofinite", "code": "theorem mem_cofinite : s \u2208 \u03bc.cofinite \u2194 \u03bc s\u1d9c < \u221e", "start": [2398, 1], "end": [2399, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.compl_mem_cofinite", "code": "theorem compl_mem_cofinite : s\u1d9c \u2208 \u03bc.cofinite \u2194 \u03bc s < \u221e", "start": [2402, 1], "end": [2402, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.eventually_cofinite", "code": "theorem eventually_cofinite {p : \u03b1 \u2192 Prop} : (\u2200\u1da0 x in \u03bc.cofinite, p x) \u2194 \u03bc { x | \u00acp x } < \u221e", "start": [2405, 1], "end": [2406, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.preimage", "code": "theorem NullMeasurableSet.preimage {\u03bd : Measure \u03b2} {f : \u03b1 \u2192 \u03b2} {t : Set \u03b2}\n    (ht : NullMeasurableSet t \u03bd) (hf : QuasiMeasurePreserving f \u03bc \u03bd) :\n    NullMeasurableSet (f \u207b\u00b9' t) \u03bc", "start": [2415, 1], "end": [2421, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.mono_ac", "code": "theorem NullMeasurableSet.mono_ac (h : NullMeasurableSet s \u03bc) (hle : \u03bd \u226a \u03bc) :\n    NullMeasurableSet s \u03bd", "start": [2424, 1], "end": [2426, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.mono", "code": "theorem NullMeasurableSet.mono (h : NullMeasurableSet s \u03bc) (hle : \u03bd \u2264 \u03bc) : NullMeasurableSet s \u03bd", "start": [2429, 1], "end": [2430, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.preimage", "code": "theorem AEDisjoint.preimage {\u03bd : Measure \u03b2} {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b2} (ht : AEDisjoint \u03bd s t)\n    (hf : QuasiMeasurePreserving f \u03bc \u03bd) : AEDisjoint \u03bc (f \u207b\u00b9' s) (f \u207b\u00b9' t)", "start": [2433, 1], "end": [2435, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_bot", "code": "@[simp]\ntheorem ae_eq_bot : \u03bc.ae = \u22a5 \u2194 \u03bc = 0", "start": [2438, 1], "end": [2440, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_neBot", "code": "@[simp]\ntheorem ae_neBot : \u03bc.ae.NeBot \u2194 \u03bc \u2260 0", "start": [2443, 1], "end": [2445, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ae.neBot", "code": "instance Measure.ae.neBot [NeZero \u03bc] : \u03bc.ae.NeBot := ae_neBot.2 <| NeZero.ne \u03bc", "start": [2448, 1], "end": [2448, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_zero", "code": "@[simp]\ntheorem ae_zero {_m0 : MeasurableSpace \u03b1} : (0 : Measure \u03b1).ae = \u22a5", "start": [2450, 1], "end": [2452, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_mono", "code": "@[mono]\ntheorem ae_mono (h : \u03bc \u2264 \u03bd) : \u03bc.ae \u2264 \u03bd.ae", "start": [2455, 1], "end": [2457, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem_ae_map_iff", "code": "theorem mem_ae_map_iff {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc) {s : Set \u03b2} (hs : MeasurableSet s) :\n    s \u2208 (\u03bc.map f).ae \u2194 f \u207b\u00b9' s \u2208 \u03bc.ae", "start": [2460, 1], "end": [2462, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem_ae_of_mem_ae_map", "code": "theorem mem_ae_of_mem_ae_map {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc) {s : Set \u03b2}\n    (hs : s \u2208 (\u03bc.map f).ae) : f \u207b\u00b9' s \u2208 \u03bc.ae", "start": [2465, 1], "end": [2467, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_map_iff", "code": "theorem ae_map_iff {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc) {p : \u03b2 \u2192 Prop}\n    (hp : MeasurableSet { x | p x }) : (\u2200\u1d50 y \u2202\u03bc.map f, p y) \u2194 \u2200\u1d50 x \u2202\u03bc, p (f x)", "start": [2470, 1], "end": [2472, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_of_ae_map", "code": "theorem ae_of_ae_map {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc) {p : \u03b2 \u2192 Prop} (h : \u2200\u1d50 y \u2202\u03bc.map f, p y) :\n    \u2200\u1d50 x \u2202\u03bc, p (f x)", "start": [2475, 1], "end": [2477, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_map_mem_range", "code": "theorem ae_map_mem_range {m0 : MeasurableSpace \u03b1} (f : \u03b1 \u2192 \u03b2) (hf : MeasurableSet (range f))\n    (\u03bc : Measure \u03b1) : \u2200\u1d50 x \u2202\u03bc.map f, x \u2208 range f", "start": [2480, 1], "end": [2487, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_iUnion_eq", "code": "@[simp]\ntheorem ae_restrict_iUnion_eq [Countable \u03b9] (s : \u03b9 \u2192 Set \u03b1) :\n    (\u03bc.restrict (\u22c3 i, s i)).ae = \u2a06 i, (\u03bc.restrict (s i)).ae", "start": [2490, 1], "end": [2494, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_union_eq", "code": "@[simp]\ntheorem ae_restrict_union_eq (s t : Set \u03b1) :\n    (\u03bc.restrict (s \u222a t)).ae = (\u03bc.restrict s).ae \u2294 (\u03bc.restrict t).ae", "start": [2497, 1], "end": [2500, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_biUnion_eq", "code": "theorem ae_restrict_biUnion_eq (s : \u03b9 \u2192 Set \u03b1) {t : Set \u03b9} (ht : t.Countable) :\n    (\u03bc.restrict (\u22c3 i \u2208 t, s i)).ae = \u2a06 i \u2208 t, (\u03bc.restrict (s i)).ae", "start": [2503, 1], "end": [2506, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_biUnion_finset_eq", "code": "theorem ae_restrict_biUnion_finset_eq (s : \u03b9 \u2192 Set \u03b1) (t : Finset \u03b9) :\n    (\u03bc.restrict (\u22c3 i \u2208 t, s i)).ae = \u2a06 i \u2208 t, (\u03bc.restrict (s i)).ae", "start": [2509, 1], "end": [2511, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_iUnion_iff", "code": "theorem ae_restrict_iUnion_iff [Countable \u03b9] (s : \u03b9 \u2192 Set \u03b1) (p : \u03b1 \u2192 Prop) :\n    (\u2200\u1d50 x \u2202\u03bc.restrict (\u22c3 i, s i), p x) \u2194 \u2200 i, \u2200\u1d50 x \u2202\u03bc.restrict (s i), p x", "start": [2514, 1], "end": [2515, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_union_iff", "code": "theorem ae_restrict_union_iff (s t : Set \u03b1) (p : \u03b1 \u2192 Prop) :\n    (\u2200\u1d50 x \u2202\u03bc.restrict (s \u222a t), p x) \u2194 (\u2200\u1d50 x \u2202\u03bc.restrict s, p x) \u2227 \u2200\u1d50 x \u2202\u03bc.restrict t, p x", "start": [2518, 1], "end": [2519, 101], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_biUnion_iff", "code": "theorem ae_restrict_biUnion_iff (s : \u03b9 \u2192 Set \u03b1) {t : Set \u03b9} (ht : t.Countable) (p : \u03b1 \u2192 Prop) :\n    (\u2200\u1d50 x \u2202\u03bc.restrict (\u22c3 i \u2208 t, s i), p x) \u2194 \u2200 i \u2208 t, \u2200\u1d50 x \u2202\u03bc.restrict (s i), p x", "start": [2522, 1], "end": [2524, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_biUnion_finset_iff", "code": "@[simp]\ntheorem ae_restrict_biUnion_finset_iff (s : \u03b9 \u2192 Set \u03b1) (t : Finset \u03b9) (p : \u03b1 \u2192 Prop) :\n    (\u2200\u1d50 x \u2202\u03bc.restrict (\u22c3 i \u2208 t, s i), p x) \u2194 \u2200 i \u2208 t, \u2200\u1d50 x \u2202\u03bc.restrict (s i), p x", "start": [2527, 1], "end": [2530, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_restrict_iUnion_iff", "code": "theorem ae_eq_restrict_iUnion_iff [Countable \u03b9] (s : \u03b9 \u2192 Set \u03b1) (f g : \u03b1 \u2192 \u03b4) :\n    f =\u1d50[\u03bc.restrict (\u22c3 i, s i)] g \u2194 \u2200 i, f =\u1d50[\u03bc.restrict (s i)] g", "start": [2533, 1], "end": [2535, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_restrict_biUnion_iff", "code": "theorem ae_eq_restrict_biUnion_iff (s : \u03b9 \u2192 Set \u03b1) {t : Set \u03b9} (ht : t.Countable) (f g : \u03b1 \u2192 \u03b4) :\n    f =\u1d50[\u03bc.restrict (\u22c3 i \u2208 t, s i)] g \u2194 \u2200 i \u2208 t, f =\u1d50[\u03bc.restrict (s i)] g", "start": [2538, 1], "end": [2540, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_restrict_biUnion_finset_iff", "code": "theorem ae_eq_restrict_biUnion_finset_iff (s : \u03b9 \u2192 Set \u03b1) (t : Finset \u03b9) (f g : \u03b1 \u2192 \u03b4) :\n    f =\u1d50[\u03bc.restrict (\u22c3 i \u2208 t, s i)] g \u2194 \u2200 i \u2208 t, f =\u1d50[\u03bc.restrict (s i)] g", "start": [2543, 1], "end": [2545, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_uIoc_eq", "code": "theorem ae_restrict_uIoc_eq [LinearOrder \u03b1] (a b : \u03b1) :\n    (\u03bc.restrict (\u0399 a b)).ae = (\u03bc.restrict (Ioc a b)).ae \u2294 (\u03bc.restrict (Ioc b a)).ae", "start": [2548, 1], "end": [2550, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_uIoc_iff", "code": "theorem ae_restrict_uIoc_iff [LinearOrder \u03b1] {a b : \u03b1} {P : \u03b1 \u2192 Prop} :\n    (\u2200\u1d50 x \u2202\u03bc.restrict (\u0399 a b), P x) \u2194\n      (\u2200\u1d50 x \u2202\u03bc.restrict (Ioc a b), P x) \u2227 \u2200\u1d50 x \u2202\u03bc.restrict (Ioc b a), P x", "start": [2553, 1], "end": [2557, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_iff", "code": "theorem ae_restrict_iff {p : \u03b1 \u2192 Prop} (hp : MeasurableSet { x | p x }) :\n    (\u2200\u1d50 x \u2202\u03bc.restrict s, p x) \u2194 \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 p x", "start": [2560, 1], "end": [2563, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_imp_of_ae_restrict", "code": "theorem ae_imp_of_ae_restrict {s : Set \u03b1} {p : \u03b1 \u2192 Prop} (h : \u2200\u1d50 x \u2202\u03bc.restrict s, p x) :\n    \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 p x", "start": [2566, 1], "end": [2569, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_iff'", "code": "theorem ae_restrict_iff' {p : \u03b1 \u2192 Prop} (hs : MeasurableSet s) :\n    (\u2200\u1d50 x \u2202\u03bc.restrict s, p x) \u2194 \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 p x", "start": [2572, 1], "end": [2575, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.restrict", "code": "theorem _root_.Filter.EventuallyEq.restrict {f g : \u03b1 \u2192 \u03b4} {s : Set \u03b1} (hfg : f =\u1d50[\u03bc] g) :\n    f =\u1d50[\u03bc.restrict s] g", "start": [2578, 1], "end": [2583, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_mem", "code": "theorem ae_restrict_mem (hs : MeasurableSet s) : \u2200\u1d50 x \u2202\u03bc.restrict s, x \u2208 s", "start": [2586, 1], "end": [2587, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_mem\u2080", "code": "theorem ae_restrict_mem\u2080 (hs : NullMeasurableSet s \u03bc) : \u2200\u1d50 x \u2202\u03bc.restrict s, x \u2208 s", "start": [2590, 1], "end": [2593, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_of_ae", "code": "theorem ae_restrict_of_ae {s : Set \u03b1} {p : \u03b1 \u2192 Prop} (h : \u2200\u1d50 x \u2202\u03bc, p x) : \u2200\u1d50 x \u2202\u03bc.restrict s, p x", "start": [2596, 1], "end": [2597, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_iff'\u2080", "code": "theorem ae_restrict_iff'\u2080 {p : \u03b1 \u2192 Prop} (hs : NullMeasurableSet s \u03bc) :\n    (\u2200\u1d50 x \u2202\u03bc.restrict s, p x) \u2194 \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 p x", "start": [2600, 1], "end": [2603, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_of_ae_restrict_of_subset", "code": "theorem ae_restrict_of_ae_restrict_of_subset {s t : Set \u03b1} {p : \u03b1 \u2192 Prop} (hst : s \u2286 t)\n    (h : \u2200\u1d50 x \u2202\u03bc.restrict t, p x) : \u2200\u1d50 x \u2202\u03bc.restrict s, p x", "start": [2606, 1], "end": [2608, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_of_ae_restrict_of_ae_restrict_compl", "code": "theorem ae_of_ae_restrict_of_ae_restrict_compl (t : Set \u03b1) {p : \u03b1 \u2192 Prop}\n    (ht : \u2200\u1d50 x \u2202\u03bc.restrict t, p x) (htc : \u2200\u1d50 x \u2202\u03bc.restrict t\u1d9c, p x) : \u2200\u1d50 x \u2202\u03bc, p x", "start": [2611, 1], "end": [2620, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem_map_restrict_ae_iff", "code": "theorem mem_map_restrict_ae_iff {\u03b2} {s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} (hs : MeasurableSet s) :\n    t \u2208 Filter.map f (\u03bc.restrict s).ae \u2194 \u03bc ((f \u207b\u00b9' t)\u1d9c \u2229 s) = 0", "start": [2624, 1], "end": [2626, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_smul_measure", "code": "theorem ae_smul_measure {p : \u03b1 \u2192 Prop} [Monoid R] [DistribMulAction R \u211d\u22650\u221e]\n    [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e] (h : \u2200\u1d50 x \u2202\u03bc, p x) (c : R) : \u2200\u1d50 x \u2202c \u2022 \u03bc, p x", "start": [2629, 1], "end": [2631, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_add_measure_iff", "code": "theorem ae_add_measure_iff {p : \u03b1 \u2192 Prop} {\u03bd} :\n    (\u2200\u1d50 x \u2202\u03bc + \u03bd, p x) \u2194 (\u2200\u1d50 x \u2202\u03bc, p x) \u2227 \u2200\u1d50 x \u2202\u03bd, p x", "start": [2634, 1], "end": [2636, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_comp'", "code": "theorem ae_eq_comp' {\u03bd : Measure \u03b2} {f : \u03b1 \u2192 \u03b2} {g g' : \u03b2 \u2192 \u03b4} (hf : AEMeasurable f \u03bc)\n    (h : g =\u1d50[\u03bd] g') (h2 : \u03bc.map f \u226a \u03bd) : g \u2218 f =\u1d50[\u03bc] g' \u2218 f", "start": [2639, 1], "end": [2641, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.ae_eq_comp", "code": "theorem Measure.QuasiMeasurePreserving.ae_eq_comp {\u03bd : Measure \u03b2} {f : \u03b1 \u2192 \u03b2} {g g' : \u03b2 \u2192 \u03b4}\n    (hf : QuasiMeasurePreserving f \u03bc \u03bd) (h : g =\u1d50[\u03bd] g') : g \u2218 f =\u1d50[\u03bc] g' \u2218 f", "start": [2644, 1], "end": [2646, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_comp", "code": "theorem ae_eq_comp {f : \u03b1 \u2192 \u03b2} {g g' : \u03b2 \u2192 \u03b4} (hf : AEMeasurable f \u03bc) (h : g =\u1d50[\u03bc.map f] g') :\n    g \u2218 f =\u1d50[\u03bc] g' \u2218 f", "start": [2649, 1], "end": [2651, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.sub_ae_eq_zero", "code": "theorem sub_ae_eq_zero {\u03b2} [AddGroup \u03b2] (f g : \u03b1 \u2192 \u03b2) : f - g =\u1d50[\u03bc] 0 \u2194 f =\u1d50[\u03bc] g", "start": [2654, 1], "end": [2657, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.le_ae_restrict", "code": "theorem le_ae_restrict : \u03bc.ae \u2293 \ud835\udcdf s \u2264 (\u03bc.restrict s).ae", "start": [2660, 1], "end": [2661, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_eq", "code": "@[simp]\ntheorem ae_restrict_eq (hs : MeasurableSet s) : (\u03bc.restrict s).ae = \u03bc.ae \u2293 \ud835\udcdf s", "start": [2664, 1], "end": [2669, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_eq_bot", "code": "theorem ae_restrict_eq_bot {s} : (\u03bc.restrict s).ae = \u22a5 \u2194 \u03bc s = 0", "start": [2673, 1], "end": [2674, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_neBot", "code": "theorem ae_restrict_neBot {s} : (\u03bc.restrict s).ae.NeBot \u2194 \u03bc s \u2260 0", "start": [2677, 1], "end": [2678, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.self_mem_ae_restrict", "code": "theorem self_mem_ae_restrict {s} (hs : MeasurableSet s) : s \u2208 (\u03bc.restrict s).ae", "start": [2681, 1], "end": [2683, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_of_ae_eq_of_ae_restrict", "code": "theorem ae_restrict_of_ae_eq_of_ae_restrict {s t} (hst : s =\u1d50[\u03bc] t) {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1d50 x \u2202\u03bc.restrict s, p x) \u2192 \u2200\u1d50 x \u2202\u03bc.restrict t, p x", "start": [2686, 1], "end": [2689, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_restrict_congr_set", "code": "theorem ae_restrict_congr_set {s t} (hst : s =\u1d50[\u03bc] t) {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1d50 x \u2202\u03bc.restrict s, p x) \u2194 \u2200\u1d50 x \u2202\u03bc.restrict t, p x", "start": [2692, 1], "end": [2696, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_setOf_frequently_eq_zero", "code": "theorem measure_setOf_frequently_eq_zero {p : \u2115 \u2192 \u03b1 \u2192 Prop} (hp : \u2211' i, \u03bc { x | p i x } \u2260 \u221e) :\n    \u03bc { x | \u2203\u1da0 n in atTop, p n x } = 0", "start": [2699, 1], "end": [2705, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eventually_not_mem", "code": "theorem ae_eventually_not_mem {s : \u2115 \u2192 Set \u03b1} (hs : (\u2211' i, \u03bc (s i)) \u2260 \u221e) :\n    \u2200\u1d50 x \u2202\u03bc, \u2200\u1da0 n in atTop, x \u2209 s n", "start": [2708, 1], "end": [2712, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurable.measure_preimage_eq_measure_restrict_preimage_of_ae_compl_eq_const", "code": "lemma NullMeasurable.measure_preimage_eq_measure_restrict_preimage_of_ae_compl_eq_const\n    {\u03b2 : Type*} [MeasurableSpace \u03b2] {b : \u03b2} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (f_mble : NullMeasurable f (\u03bc.restrict s)) (hs : f =\u1d50[Measure.restrict \u03bc s\u1d9c] (fun _ \u21a6 b))\n    {t : Set \u03b2} (t_mble : MeasurableSet t) (ht : b \u2209 t) :\n    \u03bc (f \u207b\u00b9' t) = \u03bc.restrict s (f \u207b\u00b9' t) := by\n  rw [Measure.restrict_apply\u2080 (f_mble t_mble)]\n  simp only [EventuallyEq, Filter.Eventually, Pi.zero_apply, Measure.ae,\n             MeasurableSet.compl_iff, Filter.mem_mk, mem_setOf_eq] at hs\n  rw [Measure.restrict_apply\u2080] at hs\n  \u00b7 apply le_antisymm _ (measure_mono (inter_subset_left _ _))\n    apply (measure_mono (Eq.symm (inter_union_compl (f \u207b\u00b9' t) s)).le).trans\n    apply (measure_union_le _ _).trans\n    have obs : \u03bc ((f \u207b\u00b9' t) \u2229 s\u1d9c) = 0 := by\n      apply le_antisymm _ (zero_le _)\n      rw [\u2190 hs]\n      apply measure_mono (inter_subset_inter_left _ _)\n      intro x hx hfx\n      simp only [mem_preimage, mem_setOf_eq] at hx hfx\n      exact ht (hfx \u25b8 hx)\n    simp only [obs, add_zero, le_refl]\n  \u00b7 exact NullMeasurableSet.of_null hs", "start": [2715, 1], "end": [2735, 39], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.biSup_measure_Iic", "code": "theorem biSup_measure_Iic [Preorder \u03b1] {s : Set \u03b1} (hsc : s.Countable)\n    (hst : \u2200 x : \u03b1, \u2203 y \u2208 s, x \u2264 y) (hdir : DirectedOn (\u00b7 \u2264 \u00b7) s) :\n    \u2a06 x \u2208 s, \u03bc (Iic x) = \u03bc univ", "start": [2739, 1], "end": [2746, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_measure_Ico_atTop", "code": "theorem tendsto_measure_Ico_atTop [SemilatticeSup \u03b1] [NoMaxOrder \u03b1]\n    [(atTop : Filter \u03b1).IsCountablyGenerated] (\u03bc : Measure \u03b1) (a : \u03b1) :\n    Tendsto (fun x => \u03bc (Ico a x)) atTop (\ud835\udcdd (\u03bc (Ici a)))", "start": [2749, 1], "end": [2765, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_measure_Ioc_atBot", "code": "theorem tendsto_measure_Ioc_atBot [SemilatticeInf \u03b1] [NoMinOrder \u03b1]\n    [(atBot : Filter \u03b1).IsCountablyGenerated] (\u03bc : Measure \u03b1) (a : \u03b1) :\n    Tendsto (fun x => \u03bc (Ioc x a)) atBot (\ud835\udcdd (\u03bc (Iic a)))", "start": [2768, 1], "end": [2784, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_measure_Iic_atTop", "code": "theorem tendsto_measure_Iic_atTop [SemilatticeSup \u03b1] [(atTop : Filter \u03b1).IsCountablyGenerated]\n    (\u03bc : Measure \u03b1) : Tendsto (fun x => \u03bc (Iic x)) atTop (\ud835\udcdd (\u03bc univ))", "start": [2787, 1], "end": [2803, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_measure_Ici_atBot", "code": "theorem tendsto_measure_Ici_atBot [SemilatticeInf \u03b1] [h : (atBot : Filter \u03b1).IsCountablyGenerated]\n    (\u03bc : Measure \u03b1) : Tendsto (fun x => \u03bc (Ici x)) atBot (\ud835\udcdd (\u03bc univ))", "start": [2806, 1], "end": [2808, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Iio_ae_eq_Iic'", "code": "theorem Iio_ae_eq_Iic' (ha : \u03bc {a} = 0) : Iio a =\u1d50[\u03bc] Iic a", "start": [2813, 1], "end": [2814, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Ioi_ae_eq_Ici'", "code": "theorem Ioi_ae_eq_Ici' (ha : \u03bc {a} = 0) : Ioi a =\u1d50[\u03bc] Ici a", "start": [2817, 1], "end": [2818, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Ioo_ae_eq_Ioc'", "code": "theorem Ioo_ae_eq_Ioc' (hb : \u03bc {b} = 0) : Ioo a b =\u1d50[\u03bc] Ioc a b", "start": [2821, 1], "end": [2822, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Ioc_ae_eq_Icc'", "code": "theorem Ioc_ae_eq_Icc' (ha : \u03bc {a} = 0) : Ioc a b =\u1d50[\u03bc] Icc a b", "start": [2825, 1], "end": [2826, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Ioo_ae_eq_Ico'", "code": "theorem Ioo_ae_eq_Ico' (ha : \u03bc {a} = 0) : Ioo a b =\u1d50[\u03bc] Ico a b", "start": [2829, 1], "end": [2830, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Ioo_ae_eq_Icc'", "code": "theorem Ioo_ae_eq_Icc' (ha : \u03bc {a} = 0) (hb : \u03bc {b} = 0) : Ioo a b =\u1d50[\u03bc] Icc a b", "start": [2833, 1], "end": [2834, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Ico_ae_eq_Icc'", "code": "theorem Ico_ae_eq_Icc' (hb : \u03bc {b} = 0) : Ico a b =\u1d50[\u03bc] Icc a b", "start": [2837, 1], "end": [2838, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Ico_ae_eq_Ioc'", "code": "theorem Ico_ae_eq_Ioc' (ha : \u03bc {a} = 0) (hb : \u03bc {b} = 0) : Ico a b =\u1d50[\u03bc] Ioc a b", "start": [2841, 1], "end": [2842, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.IsFiniteMeasure", "code": "class IsFiniteMeasure (\u03bc : Measure \u03b1) : Prop where\n  measure_univ_lt_top : \u03bc univ < \u221e", "start": [2849, 1], "end": [2851, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.not_isFiniteMeasure_iff", "code": "theorem not_isFiniteMeasure_iff : \u00acIsFiniteMeasure \u03bc \u2194 \u03bc Set.univ = \u221e", "start": [2855, 1], "end": [2858, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Restrict.isFiniteMeasure", "code": "instance Restrict.isFiniteMeasure (\u03bc : Measure \u03b1) [hs : Fact (\u03bc s < \u221e)] :\n    IsFiniteMeasure (\u03bc.restrict s) :=\n  \u27e8by simpa using hs.elim\u27e9", "start": [2861, 1], "end": [2863, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_lt_top", "code": "theorem measure_lt_top (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] (s : Set \u03b1) : \u03bc s < \u221e", "start": [2866, 1], "end": [2867, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.isFiniteMeasureRestrict", "code": "instance isFiniteMeasureRestrict (\u03bc : Measure \u03b1) (s : Set \u03b1) [h : IsFiniteMeasure \u03bc] :\n    IsFiniteMeasure (\u03bc.restrict s) :=\n  \u27e8by simpa using measure_lt_top \u03bc s\u27e9", "start": [2870, 1], "end": [2872, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_ne_top", "code": "theorem measure_ne_top (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] (s : Set \u03b1) : \u03bc s \u2260 \u221e", "start": [2875, 1], "end": [2876, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_compl_le_add_of_le_add", "code": "theorem measure_compl_le_add_of_le_add [IsFiniteMeasure \u03bc] (hs : MeasurableSet s)\n    (ht : MeasurableSet t) {\u03b5 : \u211d\u22650\u221e} (h : \u03bc s \u2264 \u03bc t + \u03b5) : \u03bc t\u1d9c \u2264 \u03bc s\u1d9c + \u03b5", "start": [2879, 1], "end": [2886, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_compl_le_add_iff", "code": "theorem measure_compl_le_add_iff [IsFiniteMeasure \u03bc] (hs : MeasurableSet s) (ht : MeasurableSet t)\n    {\u03b5 : \u211d\u22650\u221e} : \u03bc s\u1d9c \u2264 \u03bc t\u1d9c + \u03b5 \u2194 \u03bc t \u2264 \u03bc s + \u03b5", "start": [2890, 1], "end": [2893, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measureUnivNNReal", "code": "def measureUnivNNReal (\u03bc : Measure \u03b1) : \u211d\u22650 :=\n  (\u03bc univ).toNNReal", "start": [2896, 1], "end": [2898, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.coe_measureUnivNNReal", "code": "@[simp]\ntheorem coe_measureUnivNNReal (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] :\n    \u2191(measureUnivNNReal \u03bc) = \u03bc univ", "start": [2901, 1], "end": [2904, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.isFiniteMeasureZero", "code": "instance isFiniteMeasureZero : IsFiniteMeasure (0 : Measure \u03b1) :=\n  \u27e8by simp\u27e9", "start": [2907, 1], "end": [2908, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.isFiniteMeasureOfIsEmpty", "code": "instance (priority := 100) isFiniteMeasureOfIsEmpty [IsEmpty \u03b1] : IsFiniteMeasure \u03bc := by\n  rw [eq_zero_of_isEmpty \u03bc]\n  infer_instance", "start": [2911, 1], "end": [2913, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measureUnivNNReal_zero", "code": "@[simp]\ntheorem measureUnivNNReal_zero : measureUnivNNReal (0 : Measure \u03b1) = 0", "start": [2916, 1], "end": [2918, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.isFiniteMeasureAdd", "code": "instance isFiniteMeasureAdd [IsFiniteMeasure \u03bc] [IsFiniteMeasure \u03bd] : IsFiniteMeasure (\u03bc + \u03bd) where\n  measure_univ_lt_top := by\n    rw [Measure.coe_add, Pi.add_apply, ENNReal.add_lt_top]\n    exact \u27e8measure_lt_top _ _, measure_lt_top _ _\u27e9", "start": [2921, 1], "end": [2924, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.isFiniteMeasureSMulNNReal", "code": "instance isFiniteMeasureSMulNNReal [IsFiniteMeasure \u03bc] {r : \u211d\u22650} : IsFiniteMeasure (r \u2022 \u03bc) where\n  measure_univ_lt_top := ENNReal.mul_lt_top ENNReal.coe_ne_top (measure_ne_top _ _)", "start": [2927, 1], "end": [2928, 84], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.IsFiniteMeasure.average", "code": "instance IsFiniteMeasure.average : IsFiniteMeasure ((\u03bc univ)\u207b\u00b9 \u2022 \u03bc) where\n  measure_univ_lt_top := by\n    rw [smul_apply, smul_eq_mul, \u2190 ENNReal.div_eq_inv_mul]\n    exact ENNReal.div_self_le_one.trans_lt ENNReal.one_lt_top", "start": [2931, 1], "end": [2934, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.isFiniteMeasureSMulOfNNRealTower", "code": "instance isFiniteMeasureSMulOfNNRealTower {R} [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e]\n    [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e] [IsFiniteMeasure \u03bc] {r : R} : IsFiniteMeasure (r \u2022 \u03bc) := by\n  rw [\u2190 smul_one_smul \u211d\u22650 r \u03bc]\n  infer_instance", "start": [2936, 1], "end": [2939, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.isFiniteMeasure_of_le", "code": "theorem isFiniteMeasure_of_le (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] (h : \u03bd \u2264 \u03bc) : IsFiniteMeasure \u03bd", "start": [2942, 1], "end": [2943, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.isFiniteMeasure_map", "code": "@[instance]\ntheorem Measure.isFiniteMeasure_map {m : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc]\n    (f : \u03b1 \u2192 \u03b2) : IsFiniteMeasure (\u03bc.map f)", "start": [2946, 1], "end": [2954, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measureUnivNNReal_eq_zero", "code": "@[simp]\ntheorem measureUnivNNReal_eq_zero [IsFiniteMeasure \u03bc] : measureUnivNNReal \u03bc = 0 \u2194 \u03bc = 0", "start": [2957, 1], "end": [2960, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measureUnivNNReal_pos", "code": "theorem measureUnivNNReal_pos [IsFiniteMeasure \u03bc] (h\u03bc : \u03bc \u2260 0) : 0 < measureUnivNNReal \u03bc", "start": [2963, 1], "end": [2965, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_of_add_le_add_left", "code": "theorem Measure.le_of_add_le_add_left [IsFiniteMeasure \u03bc] (A2 : \u03bc + \u03bd\u2081 \u2264 \u03bc + \u03bd\u2082) : \u03bd\u2081 \u2264 \u03bd\u2082", "start": [2968, 1], "end": [2971, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.summable_measure_toReal", "code": "theorem summable_measure_toReal [h\u03bc : IsFiniteMeasure \u03bc] {f : \u2115 \u2192 Set \u03b1}\n    (hf\u2081 : \u2200 i : \u2115, MeasurableSet (f i)) (hf\u2082 : Pairwise (Disjoint on f)) :\n    Summable fun x => (\u03bc (f x)).toReal", "start": [2974, 1], "end": [2979, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_univ_iff_measure_eq", "code": "theorem ae_eq_univ_iff_measure_eq [IsFiniteMeasure \u03bc] (hs : NullMeasurableSet s \u03bc) :\n    s =\u1d50[\u03bc] univ \u2194 \u03bc s = \u03bc univ", "start": [2982, 1], "end": [2989, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_iff_measure_eq", "code": "theorem ae_iff_measure_eq [IsFiniteMeasure \u03bc] {p : \u03b1 \u2192 Prop}\n    (hp : NullMeasurableSet { a | p a } \u03bc) : (\u2200\u1d50 a \u2202\u03bc, p a) \u2194 \u03bc { a | p a } = \u03bc univ", "start": [2992, 1], "end": [2994, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_mem_iff_measure_eq", "code": "theorem ae_mem_iff_measure_eq [IsFiniteMeasure \u03bc] {s : Set \u03b1} (hs : NullMeasurableSet s \u03bc) :\n    (\u2200\u1d50 a \u2202\u03bc, a \u2208 s) \u2194 \u03bc s = \u03bc univ", "start": [2997, 1], "end": [2999, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.abs_toReal_measure_sub_le_measure_symmDiff'", "code": "theorem abs_toReal_measure_sub_le_measure_symmDiff'\n    (hs : MeasurableSet s) (ht : MeasurableSet t) (hs' : \u03bc s \u2260 \u221e) (ht' : \u03bc t \u2260 \u221e) :\n    |(\u03bc s).toReal - (\u03bc t).toReal| \u2264 (\u03bc (s \u2206 t)).toReal", "start": [3002, 1], "end": [3014, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.abs_toReal_measure_sub_le_measure_symmDiff", "code": "theorem abs_toReal_measure_sub_le_measure_symmDiff [IsFiniteMeasure \u03bc]\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    |(\u03bc s).toReal - (\u03bc t).toReal| \u2264 (\u03bc (s \u2206 t)).toReal", "start": [3016, 1], "end": [3019, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.IsProbabilityMeasure", "code": "class IsProbabilityMeasure (\u03bc : Measure \u03b1) : Prop where\n  measure_univ : \u03bc univ = 1", "start": [3025, 1], "end": [3027, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure", "code": "instance (priority := 100) IsProbabilityMeasure.toIsFiniteMeasure (\u03bc : Measure \u03b1)\n    [IsProbabilityMeasure \u03bc] : IsFiniteMeasure \u03bc :=\n  \u27e8by simp only [measure_univ, ENNReal.one_lt_top]\u27e9", "start": [3035, 1], "end": [3037, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.IsProbabilityMeasure.ne_zero", "code": "theorem IsProbabilityMeasure.ne_zero (\u03bc : Measure \u03b1) [IsProbabilityMeasure \u03bc] : \u03bc \u2260 0", "start": [3040, 1], "end": [3041, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.IsProbabilityMeasure.neZero", "code": "instance (priority := 100) IsProbabilityMeasure.neZero (\u03bc : Measure \u03b1) [IsProbabilityMeasure \u03bc] :\n    NeZero \u03bc := \u27e8IsProbabilityMeasure.ne_zero \u03bc\u27e9", "start": [3044, 1], "end": [3045, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.IsProbabilityMeasure.ae_neBot", "code": "theorem IsProbabilityMeasure.ae_neBot [IsProbabilityMeasure \u03bc] : NeBot \u03bc.ae", "start": [3048, 1], "end": [3048, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.prob_add_prob_compl", "code": "theorem prob_add_prob_compl [IsProbabilityMeasure \u03bc] (h : MeasurableSet s) : \u03bc s + \u03bc s\u1d9c = 1", "start": [3051, 1], "end": [3052, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.prob_le_one", "code": "theorem prob_le_one [IsProbabilityMeasure \u03bc] : \u03bc s \u2264 1", "start": [3055, 1], "end": [3056, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.isProbabilityMeasureSMul", "code": "instance isProbabilityMeasureSMul [IsFiniteMeasure \u03bc] [NeZero \u03bc] :\n    IsProbabilityMeasure ((\u03bc univ)\u207b\u00b9 \u2022 \u03bc) :=\n  \u27e8ENNReal.inv_mul_cancel (NeZero.ne (\u03bc univ)) (measure_ne_top _ _)\u27e9", "start": [3060, 1], "end": [3062, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.isProbabilityMeasure_map", "code": "theorem isProbabilityMeasure_map [IsProbabilityMeasure \u03bc] {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc) :\n    IsProbabilityMeasure (map f \u03bc)", "start": [3065, 1], "end": [3067, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.one_le_prob_iff", "code": "@[simp]\ntheorem one_le_prob_iff [IsProbabilityMeasure \u03bc] : 1 \u2264 \u03bc s \u2194 \u03bc s = 1", "start": [3070, 1], "end": [3072, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.prob_compl_eq_one_sub", "code": "theorem prob_compl_eq_one_sub [IsProbabilityMeasure \u03bc] (hs : MeasurableSet s) : \u03bc s\u1d9c = 1 - \u03bc s", "start": [3075, 1], "end": [3079, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.prob_compl_eq_zero_iff", "code": "@[simp]\ntheorem prob_compl_eq_zero_iff [IsProbabilityMeasure \u03bc] (hs : MeasurableSet s) :\n    \u03bc s\u1d9c = 0 \u2194 \u03bc s = 1", "start": [3082, 1], "end": [3085, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.prob_compl_eq_one_iff", "code": "@[simp]\ntheorem prob_compl_eq_one_iff [IsProbabilityMeasure \u03bc] (hs : MeasurableSet s) :\n    \u03bc s\u1d9c = 1 \u2194 \u03bc s = 0", "start": [3088, 1], "end": [3090, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NoAtoms", "code": "class NoAtoms {m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) : Prop where\n  measure_singleton : \u2200 x, \u03bc {x} = 0", "start": [3097, 1], "end": [3103, 37], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.measure_zero", "code": "theorem _root_.Set.Subsingleton.measure_zero {\u03b1 : Type*} {_m : MeasurableSpace \u03b1} {s : Set \u03b1}\n    (hs : s.Subsingleton) (\u03bc : Measure \u03b1) [NoAtoms \u03bc] : \u03bc s = 0", "start": [3113, 1], "end": [3115, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_singleton'", "code": "theorem Measure.restrict_singleton' {a : \u03b1} : \u03bc.restrict {a} = 0", "start": [3118, 1], "end": [3119, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict.instNoAtoms", "code": "instance Measure.restrict.instNoAtoms (s : Set \u03b1) : NoAtoms (\u03bc.restrict s) := by\n  refine' \u27e8fun x => _\u27e9\n  obtain \u27e8t, hxt, ht1, ht2\u27e9 := exists_measurable_superset_of_null (measure_singleton x : \u03bc {x} = 0)\n  apply measure_mono_null hxt\n  rw [Measure.restrict_apply ht1]\n  apply measure_mono_null (inter_subset_left t s) ht2", "start": [3122, 1], "end": [3127, 54], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.measure_zero", "code": "theorem _root_.Set.Countable.measure_zero {\u03b1 : Type*} {m : MeasurableSpace \u03b1} {s : Set \u03b1}\n    (h : s.Countable) (\u03bc : Measure \u03b1) [NoAtoms \u03bc] : \u03bc s = 0", "start": [3130, 1], "end": [3134, 7], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.ae_not_mem", "code": "theorem _root_.Set.Countable.ae_not_mem {\u03b1 : Type*} {m : MeasurableSpace \u03b1} {s : Set \u03b1}\n    (h : s.Countable) (\u03bc : Measure \u03b1) [NoAtoms \u03bc] : \u2200\u1d50 x \u2202\u03bc, x \u2209 s", "start": [3137, 1], "end": [3139, 64], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.measure_zero", "code": "theorem _root_.Set.Finite.measure_zero {\u03b1 : Type*} {_m : MeasurableSpace \u03b1} {s : Set \u03b1}\n    (h : s.Finite) (\u03bc : Measure \u03b1) [NoAtoms \u03bc] : \u03bc s = 0", "start": [3142, 1], "end": [3144, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.measure_zero", "code": "theorem _root_.Finset.measure_zero {\u03b1 : Type*} {_m : MeasurableSpace \u03b1} (s : Finset \u03b1)\n    (\u03bc : Measure \u03b1) [NoAtoms \u03bc] : \u03bc s = 0", "start": [3147, 1], "end": [3149, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.insert_ae_eq_self", "code": "theorem insert_ae_eq_self (a : \u03b1) (s : Set \u03b1) : (insert a s : Set \u03b1) =\u1d50[\u03bc] s", "start": [3152, 1], "end": [3153, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Iio_ae_eq_Iic", "code": "theorem Iio_ae_eq_Iic : Iio a =\u1d50[\u03bc] Iic a", "start": [3160, 1], "end": [3161, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Ioi_ae_eq_Ici", "code": "theorem Ioi_ae_eq_Ici : Ioi a =\u1d50[\u03bc] Ici a", "start": [3164, 1], "end": [3165, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Ioo_ae_eq_Ioc", "code": "theorem Ioo_ae_eq_Ioc : Ioo a b =\u1d50[\u03bc] Ioc a b", "start": [3168, 1], "end": [3169, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Ioc_ae_eq_Icc", "code": "theorem Ioc_ae_eq_Icc : Ioc a b =\u1d50[\u03bc] Icc a b", "start": [3172, 1], "end": [3173, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Ioo_ae_eq_Ico", "code": "theorem Ioo_ae_eq_Ico : Ioo a b =\u1d50[\u03bc] Ico a b", "start": [3176, 1], "end": [3177, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Ioo_ae_eq_Icc", "code": "theorem Ioo_ae_eq_Icc : Ioo a b =\u1d50[\u03bc] Icc a b", "start": [3180, 1], "end": [3181, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Ico_ae_eq_Icc", "code": "theorem Ico_ae_eq_Icc : Ico a b =\u1d50[\u03bc] Icc a b", "start": [3184, 1], "end": [3185, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Ico_ae_eq_Ioc", "code": "theorem Ico_ae_eq_Ioc : Ico a b =\u1d50[\u03bc] Ioc a b", "start": [3188, 1], "end": [3189, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.restrict_Iio_eq_restrict_Iic", "code": "theorem restrict_Iio_eq_restrict_Iic : \u03bc.restrict (Iio a) = \u03bc.restrict (Iic a)", "start": [3192, 1], "end": [3193, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.restrict_Ioi_eq_restrict_Ici", "code": "theorem restrict_Ioi_eq_restrict_Ici : \u03bc.restrict (Ioi a) = \u03bc.restrict (Ici a)", "start": [3195, 1], "end": [3196, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.restrict_Ioo_eq_restrict_Ioc", "code": "theorem restrict_Ioo_eq_restrict_Ioc : \u03bc.restrict (Ioo a b) = \u03bc.restrict (Ioc a b)", "start": [3198, 1], "end": [3199, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.restrict_Ioc_eq_restrict_Icc", "code": "theorem restrict_Ioc_eq_restrict_Icc : \u03bc.restrict (Ioc a b) = \u03bc.restrict (Icc a b)", "start": [3201, 1], "end": [3202, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.restrict_Ioo_eq_restrict_Ico", "code": "theorem restrict_Ioo_eq_restrict_Ico : \u03bc.restrict (Ioo a b) = \u03bc.restrict (Ico a b)", "start": [3204, 1], "end": [3205, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.restrict_Ioo_eq_restrict_Icc", "code": "theorem restrict_Ioo_eq_restrict_Icc : \u03bc.restrict (Ioo a b) = \u03bc.restrict (Icc a b)", "start": [3207, 1], "end": [3208, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.restrict_Ico_eq_restrict_Icc", "code": "theorem restrict_Ico_eq_restrict_Icc : \u03bc.restrict (Ico a b) = \u03bc.restrict (Icc a b)", "start": [3210, 1], "end": [3211, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.restrict_Ico_eq_restrict_Ioc", "code": "theorem restrict_Ico_eq_restrict_Ioc : \u03bc.restrict (Ico a b) = \u03bc.restrict (Ioc a b)", "start": [3213, 1], "end": [3214, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.uIoc_ae_eq_interval", "code": "theorem uIoc_ae_eq_interval [LinearOrder \u03b1] {a b : \u03b1} : \u0399 a b =\u1d50[\u03bc] [[a, b]]", "start": [3220, 1], "end": [3221, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ite_ae_eq_of_measure_zero", "code": "theorem ite_ae_eq_of_measure_zero {\u03b3} (f : \u03b1 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b3) (s : Set \u03b1) (hs_zero : \u03bc s = 0) :\n    (fun x => ite (x \u2208 s) (f x) (g x)) =\u1d50[\u03bc] g", "start": [3226, 1], "end": [3232, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ite_ae_eq_of_measure_compl_zero", "code": "theorem ite_ae_eq_of_measure_compl_zero {\u03b3} (f : \u03b1 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b3) (s : Set \u03b1)\n    (hs_zero : \u03bc s\u1d9c = 0) : (fun x => ite (x \u2208 s) (f x) (g x)) =\u1d50[\u03bc] f", "start": [3235, 1], "end": [3241, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteAtFilter", "code": "def FiniteAtFilter {_m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) (f : Filter \u03b1) : Prop :=\n  \u2203 s \u2208 f, \u03bc s < \u221e", "start": [3246, 1], "end": [3249, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.finiteAtFilter_of_finite", "code": "theorem finiteAtFilter_of_finite {_m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc]\n    (f : Filter \u03b1) : \u03bc.FiniteAtFilter f", "start": [3252, 1], "end": [3254, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteAtFilter.exists_mem_basis", "code": "theorem FiniteAtFilter.exists_mem_basis {f : Filter \u03b1} (h\u03bc : FiniteAtFilter \u03bc f) {p : \u03b9 \u2192 Prop}\n    {s : \u03b9 \u2192 Set \u03b1} (hf : f.HasBasis p s) : \u2203 i, p i \u2227 \u03bc (s i) < \u221e", "start": [3257, 1], "end": [3259, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.finiteAtBot", "code": "theorem finiteAtBot {m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) : \u03bc.FiniteAtFilter \u22a5", "start": [3262, 1], "end": [3263, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteSpanningSetsIn", "code": "structure FiniteSpanningSetsIn {m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) (C : Set (Set \u03b1)) where\n  protected set : \u2115 \u2192 Set \u03b1\n  protected set_mem : \u2200 i, set i \u2208 C\n  protected finite : \u2200 i, \u03bc (set i) < \u221e\n  protected spanning : \u22c3 i, set i = univ", "start": [3266, 1], "end": [3276, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SigmaFinite", "code": "class SigmaFinite {m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) : Prop where\n  out' : Nonempty (\u03bc.FiniteSpanningSetsIn univ)", "start": [3287, 1], "end": [3290, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.sigmaFinite_iff", "code": "theorem sigmaFinite_iff : SigmaFinite \u03bc \u2194 Nonempty (\u03bc.FiniteSpanningSetsIn univ)", "start": [3294, 1], "end": [3295, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SigmaFinite.out", "code": "theorem SigmaFinite.out (h : SigmaFinite \u03bc) : Nonempty (\u03bc.FiniteSpanningSetsIn univ)", "start": [3298, 1], "end": [3299, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.toFiniteSpanningSetsIn", "code": "def Measure.toFiniteSpanningSetsIn (\u03bc : Measure \u03b1) [h : SigmaFinite \u03bc] :\n    \u03bc.FiniteSpanningSetsIn { s | MeasurableSet s } where\n  set n := toMeasurable \u03bc (h.out.some.set n)\n  set_mem n := measurableSet_toMeasurable _ _\n  finite n := by\n    rw [measure_toMeasurable]\n    exact h.out.some.finite n\n  spanning := eq_univ_of_subset (iUnion_mono fun n => subset_toMeasurable _ _) h.out.some.spanning", "start": [3302, 1], "end": [3310, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.spanningSets", "code": "def spanningSets (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] (i : \u2115) : Set \u03b1 :=\n  Accumulate \u03bc.toFiniteSpanningSetsIn.set i", "start": [3313, 1], "end": [3317, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.monotone_spanningSets", "code": "theorem monotone_spanningSets (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] : Monotone (spanningSets \u03bc)", "start": [3320, 1], "end": [3321, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measurable_spanningSets", "code": "theorem measurable_spanningSets (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] (i : \u2115) :\n    MeasurableSet (spanningSets \u03bc i)", "start": [3324, 1], "end": [3326, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_spanningSets_lt_top", "code": "theorem measure_spanningSets_lt_top (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] (i : \u2115) :\n    \u03bc (spanningSets \u03bc i) < \u221e", "start": [3329, 1], "end": [3331, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.iUnion_spanningSets", "code": "theorem iUnion_spanningSets (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] : \u22c3 i : \u2115, spanningSets \u03bc i = univ", "start": [3334, 1], "end": [3335, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.isCountablySpanning_spanningSets", "code": "theorem isCountablySpanning_spanningSets (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] :\n    IsCountablySpanning (range (spanningSets \u03bc))", "start": [3338, 1], "end": [3340, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.spanningSetsIndex", "code": "def spanningSetsIndex (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] (x : \u03b1) : \u2115 :=\n  Nat.find <| iUnion_eq_univ_iff.1 (iUnion_spanningSets \u03bc) x", "start": [3343, 1], "end": [3345, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measurable_spanningSetsIndex", "code": "theorem measurable_spanningSetsIndex (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] :\n    Measurable (spanningSetsIndex \u03bc)", "start": [3348, 1], "end": [3350, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.preimage_spanningSetsIndex_singleton", "code": "theorem preimage_spanningSetsIndex_singleton (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] (n : \u2115) :\n    spanningSetsIndex \u03bc \u207b\u00b9' {n} = disjointed (spanningSets \u03bc) n", "start": [3353, 1], "end": [3355, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.spanningSetsIndex_eq_iff", "code": "theorem spanningSetsIndex_eq_iff (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] {x : \u03b1} {n : \u2115} :\n    spanningSetsIndex \u03bc x = n \u2194 x \u2208 disjointed (spanningSets \u03bc) n", "start": [3358, 1], "end": [3360, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem_disjointed_spanningSetsIndex", "code": "theorem mem_disjointed_spanningSetsIndex (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] (x : \u03b1) :\n    x \u2208 disjointed (spanningSets \u03bc) (spanningSetsIndex \u03bc x)", "start": [3363, 1], "end": [3365, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem_spanningSetsIndex", "code": "theorem mem_spanningSetsIndex (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] (x : \u03b1) :\n    x \u2208 spanningSets \u03bc (spanningSetsIndex \u03bc x)", "start": [3368, 1], "end": [3370, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem_spanningSets_of_index_le", "code": "theorem mem_spanningSets_of_index_le (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] (x : \u03b1) {n : \u2115}\n    (hn : spanningSetsIndex \u03bc x \u2264 n) : x \u2208 spanningSets \u03bc n", "start": [3373, 1], "end": [3375, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.eventually_mem_spanningSets", "code": "theorem eventually_mem_spanningSets (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] (x : \u03b1) :\n    \u2200\u1da0 n in atTop, x \u2208 spanningSets \u03bc n", "start": [3378, 1], "end": [3380, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.iSup_restrict_spanningSets", "code": "theorem iSup_restrict_spanningSets [SigmaFinite \u03bc] (hs : MeasurableSet s) :\n    \u2a06 i, \u03bc.restrict (spanningSets \u03bc i) s = \u03bc s", "start": [3385, 1], "end": [3390, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.exists_subset_measure_lt_top", "code": "theorem exists_subset_measure_lt_top [SigmaFinite \u03bc] {r : \u211d\u22650\u221e} (hs : MeasurableSet s)\n    (h's : r < \u03bc s) : \u2203 t, MeasurableSet t \u2227 t \u2286 s \u2227 r < \u03bc t \u2227 \u03bc t < \u221e", "start": [3394, 1], "end": [3404, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.forall_measure_inter_spanningSets_eq_zero", "code": "theorem forall_measure_inter_spanningSets_eq_zero [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}\n    [SigmaFinite \u03bc] (s : Set \u03b1) : (\u2200 n, \u03bc (s \u2229 spanningSets \u03bc n) = 0) \u2194 \u03bc s = 0", "start": [3407, 1], "end": [3413, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.exists_measure_inter_spanningSets_pos", "code": "theorem exists_measure_inter_spanningSets_pos [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} [SigmaFinite \u03bc]\n    (s : Set \u03b1) : (\u2203 n, 0 < \u03bc (s \u2229 spanningSets \u03bc n)) \u2194 0 < \u03bc s", "start": [3416, 1], "end": [3422, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.finite_const_le_meas_of_disjoint_iUnion\u2080", "code": "theorem finite_const_le_meas_of_disjoint_iUnion\u2080 {\u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1)\n    {\u03b5 : \u211d\u22650\u221e} (\u03b5_pos : 0 < \u03b5) {As : \u03b9 \u2192 Set \u03b1} (As_mble : \u2200 i : \u03b9, NullMeasurableSet (As i) \u03bc)\n    (As_disj : Pairwise (AEDisjoint \u03bc on As)) (Union_As_finite : \u03bc (\u22c3 i, As i) \u2260 \u221e) :\n    Set.Finite { i : \u03b9 | \u03b5 \u2264 \u03bc (As i) }", "start": [3425, 1], "end": [3433, 14], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.finite_const_le_meas_of_disjoint_iUnion", "code": "theorem finite_const_le_meas_of_disjoint_iUnion {\u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1)\n    {\u03b5 : \u211d\u22650\u221e} (\u03b5_pos : 0 < \u03b5) {As : \u03b9 \u2192 Set \u03b1} (As_mble : \u2200 i : \u03b9, MeasurableSet (As i))\n    (As_disj : Pairwise (Disjoint on As)) (Union_As_finite : \u03bc (\u22c3 i, As i) \u2260 \u221e) :\n    Set.Finite { i : \u03b9 | \u03b5 \u2264 \u03bc (As i) }", "start": [3435, 1], "end": [3442, 66], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.meas_eq_top", "code": "theorem _root_.Set.Infinite.meas_eq_top [MeasurableSingletonClass \u03b1]\n    {s : Set \u03b1} (hs : s.Infinite) (h' : \u2203 \u03b5, \u03b5 \u2260 0 \u2227 \u2200 x \u2208 s, \u03b5 \u2264 \u03bc {x}) : \u03bc s = \u221e", "start": [3445, 1], "end": [3455, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top\u2080", "code": "theorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top\u2080 {\u03b9 : Type*} [MeasurableSpace \u03b1]\n    (\u03bc : Measure \u03b1) {As : \u03b9 \u2192 Set \u03b1} (As_mble : \u2200 i : \u03b9, NullMeasurableSet (As i) \u03bc)\n    (As_disj : Pairwise (AEDisjoint \u03bc on As)) (Union_As_finite : \u03bc (\u22c3 i, As i) \u2260 \u221e) :\n    Set.Countable { i : \u03b9 | 0 < \u03bc (As i) }", "start": [3457, 1], "end": [3475, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top", "code": "theorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top {\u03b9 : Type*} [MeasurableSpace \u03b1]\n    (\u03bc : Measure \u03b1) {As : \u03b9 \u2192 Set \u03b1} (As_mble : \u2200 i : \u03b9, MeasurableSet (As i))\n    (As_disj : Pairwise (Disjoint on As)) (Union_As_finite : \u03bc (\u22c3 i, As i) \u2260 \u221e) :\n    Set.Countable { i : \u03b9 | 0 < \u03bc (As i) }", "start": [3477, 1], "end": [3484, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.countable_meas_pos_of_disjoint_iUnion\u2080", "code": "theorem countable_meas_pos_of_disjoint_iUnion\u2080 {\u03b9 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}\n    [SigmaFinite \u03bc] {As : \u03b9 \u2192 Set \u03b1} (As_mble : \u2200 i : \u03b9, NullMeasurableSet (As i) \u03bc)\n    (As_disj : Pairwise (AEDisjoint \u03bc on As)) :\n    Set.Countable { i : \u03b9 | 0 < \u03bc (As i) }", "start": [3487, 1], "end": [3505, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.countable_meas_pos_of_disjoint_iUnion", "code": "theorem countable_meas_pos_of_disjoint_iUnion {\u03b9 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}\n    [SigmaFinite \u03bc] {As : \u03b9 \u2192 Set \u03b1} (As_mble : \u2200 i : \u03b9, MeasurableSet (As i))\n    (As_disj : Pairwise (Disjoint on As)) : Set.Countable { i : \u03b9 | 0 < \u03bc (As i) }", "start": [3507, 1], "end": [3513, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.countable_meas_level_set_pos\u2080", "code": "theorem countable_meas_level_set_pos\u2080 {\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}\n    [SigmaFinite \u03bc] [MeasurableSpace \u03b2] [MeasurableSingletonClass \u03b2] {g : \u03b1 \u2192 \u03b2}\n    (g_mble : NullMeasurable g \u03bc) : Set.Countable { t : \u03b2 | 0 < \u03bc { a : \u03b1 | g a = t } }", "start": [3516, 1], "end": [3523, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.countable_meas_level_set_pos", "code": "theorem countable_meas_level_set_pos {\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}\n    [SigmaFinite \u03bc] [MeasurableSpace \u03b2] [MeasurableSingletonClass \u03b2] {g : \u03b1 \u2192 \u03b2}\n    (g_mble : Measurable g) : Set.Countable { t : \u03b2 | 0 < \u03bc { a : \u03b1 | g a = t } }", "start": [3525, 1], "end": [3528, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_toMeasurable_inter_of_cover", "code": "theorem measure_toMeasurable_inter_of_cover {s : Set \u03b1} (hs : MeasurableSet s) {t : Set \u03b1}\n    {v : \u2115 \u2192 Set \u03b1} (hv : t \u2286 \u22c3 n, v n) (h'v : \u2200 n, \u03bc (t \u2229 v n) \u2260 \u221e) :\n    \u03bc (toMeasurable \u03bc t \u2229 s) = \u03bc (t \u2229 s)", "start": [3531, 1], "end": [3595, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_toMeasurable_of_cover", "code": "theorem restrict_toMeasurable_of_cover {s : Set \u03b1} {v : \u2115 \u2192 Set \u03b1} (hv : s \u2286 \u22c3 n, v n)\n    (h'v : \u2200 n, \u03bc (s \u2229 v n) \u2260 \u221e) : \u03bc.restrict (toMeasurable \u03bc s) = \u03bc.restrict s", "start": [3598, 1], "end": [3601, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_toMeasurable_inter_of_sigmaFinite", "code": "theorem measure_toMeasurable_inter_of_sigmaFinite [SigmaFinite \u03bc] {s : Set \u03b1} (hs : MeasurableSet s)\n    (t : Set \u03b1) : \u03bc (toMeasurable \u03bc t \u2229 s) = \u03bc (t \u2229 s)", "start": [3604, 1], "end": [3616, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_toMeasurable_of_sigmaFinite", "code": "@[simp]\ntheorem restrict_toMeasurable_of_sigmaFinite [SigmaFinite \u03bc] (s : Set \u03b1) :\n    \u03bc.restrict (toMeasurable \u03bc s) = \u03bc.restrict s", "start": [3620, 1], "end": [3625, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteSpanningSetsIn.mono'", "code": "protected def mono' (h : \u03bc.FiniteSpanningSetsIn C) (hC : C \u2229 { s | \u03bc s < \u221e } \u2286 D) :\n    \u03bc.FiniteSpanningSetsIn D :=\n  \u27e8h.set, fun i => hC \u27e8h.set_mem i, h.finite i\u27e9, h.finite, h.spanning\u27e9", "start": [3632, 1], "end": [3636, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteSpanningSetsIn.mono", "code": "protected def mono (h : \u03bc.FiniteSpanningSetsIn C) (hC : C \u2286 D) : \u03bc.FiniteSpanningSetsIn D :=\n  h.mono' fun _s hs => hC hs.1", "start": [3639, 1], "end": [3641, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteSpanningSetsIn.sigmaFinite", "code": "protected theorem sigmaFinite (h : \u03bc.FiniteSpanningSetsIn C) : SigmaFinite \u03bc", "start": [3644, 1], "end": [3647, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteSpanningSetsIn.ext", "code": "protected theorem ext {\u03bd : Measure \u03b1} {C : Set (Set \u03b1)} (hA : \u2039_\u203a = generateFrom C)\n    (hC : IsPiSystem C) (h : \u03bc.FiniteSpanningSetsIn C) (h_eq : \u2200 s \u2208 C, \u03bc s = \u03bd s) : \u03bc = \u03bd", "start": [3650, 1], "end": [3654, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteSpanningSetsIn.isCountablySpanning", "code": "protected theorem isCountablySpanning (h : \u03bc.FiniteSpanningSetsIn C) : IsCountablySpanning C", "start": [3657, 1], "end": [3658, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sigmaFinite_of_countable", "code": "theorem sigmaFinite_of_countable {S : Set (Set \u03b1)} (hc : S.Countable) (h\u03bc : \u2200 s \u2208 S, \u03bc s < \u221e)\n    (hU : \u22c3\u2080 S = univ) : SigmaFinite \u03bc", "start": [3663, 1], "end": [3667, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteSpanningSetsIn.ofLE", "code": "def FiniteSpanningSetsIn.ofLE (h : \u03bd \u2264 \u03bc) {C : Set (Set \u03b1)} (S : \u03bc.FiniteSpanningSetsIn C) :\n    \u03bd.FiniteSpanningSetsIn C where\n  set := S.set\n  set_mem := S.set_mem\n  finite n := lt_of_le_of_lt (le_iff'.1 h _) (S.finite n)\n  spanning := S.spanning", "start": [3670, 1], "end": [3677, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sigmaFinite_of_le", "code": "theorem sigmaFinite_of_le (\u03bc : Measure \u03b1) [hs : SigmaFinite \u03bc] (h : \u03bd \u2264 \u03bc) : SigmaFinite \u03bd", "start": [3680, 1], "end": [3681, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.add_right_inj", "code": "@[simp] lemma add_right_inj (\u03bc \u03bd\u2081 \u03bd\u2082 : Measure \u03b1) [SigmaFinite \u03bc] :\n    \u03bc + \u03bd\u2081 = \u03bc + \u03bd\u2082 \u2194 \u03bd\u2081 = \u03bd\u2082 := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 by rw [h]\u27e9\n  rw [ext_iff_of_iUnion_eq_univ (iUnion_spanningSets \u03bc)]\n  intro i\n  ext s hs\n  rw [\u2190 ENNReal.add_right_inj (measure_mono (inter_subset_right s _) |>.trans_lt <|\n    measure_spanningSets_lt_top \u03bc i).ne]\n  simp [Measure.ext_iff'] at h\n  simp [hs, h]", "start": [3684, 1], "end": [3693, 15], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.Measure.add_left_inj", "code": "@[simp] lemma add_left_inj (\u03bc \u03bd\u2081 \u03bd\u2082 : Measure \u03b1) [SigmaFinite \u03bc] :\n    \u03bd\u2081 + \u03bc = \u03bd\u2082 + \u03bc \u2194 \u03bd\u2081 = \u03bd\u2082 := by rw [add_comm _ \u03bc, add_comm _ \u03bc, \u03bc.add_right_inj]", "start": [3695, 1], "end": [3696, 85], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.IsFiniteMeasure.toSigmaFinite", "code": "instance (priority := 100) IsFiniteMeasure.toSigmaFinite {_m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] : SigmaFinite \u03bc :=\n  \u27e8\u27e8\u27e8fun _ => univ, fun _ => trivial, fun _ => measure_lt_top \u03bc _, iUnion_const _\u27e9\u27e9\u27e9", "start": [3700, 1], "end": [3703, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.sigmaFinite_bot_iff", "code": "theorem sigmaFinite_bot_iff (\u03bc : @Measure \u03b1 \u22a5) : SigmaFinite \u03bc \u2194 IsFiniteMeasure \u03bc", "start": [3706, 1], "end": [3725, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Restrict.sigmaFinite", "code": "instance Restrict.sigmaFinite (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] (s : Set \u03b1) :\n    SigmaFinite (\u03bc.restrict s) := by\n  refine' \u27e8\u27e8\u27e8spanningSets \u03bc, fun _ => trivial, fun i => _, iUnion_spanningSets \u03bc\u27e9\u27e9\u27e9\n  rw [Measure.restrict_apply (measurable_spanningSets \u03bc i)]\n  exact (measure_mono <| inter_subset_left _ _).trans_lt (measure_spanningSets_lt_top \u03bc i)", "start": [3728, 1], "end": [3732, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.sum.sigmaFinite", "code": "instance sum.sigmaFinite {\u03b9} [Finite \u03b9] (\u03bc : \u03b9 \u2192 Measure \u03b1) [\u2200 i, SigmaFinite (\u03bc i)] :\n    SigmaFinite (sum \u03bc) := by\n  cases nonempty_fintype \u03b9\n  have : \u2200 n, MeasurableSet (\u22c2 i : \u03b9, spanningSets (\u03bc i) n) := fun n =>\n    MeasurableSet.iInter fun i => measurable_spanningSets (\u03bc i) n\n  refine' \u27e8\u27e8\u27e8fun n => \u22c2 i, spanningSets (\u03bc i) n, fun _ => trivial, fun n => _, _\u27e9\u27e9\u27e9\n  \u00b7 rw [sum_apply _ (this n), tsum_fintype, ENNReal.sum_lt_top_iff]\n    rintro i -\n    exact (measure_mono <| iInter_subset _ i).trans_lt (measure_spanningSets_lt_top (\u03bc i) n)\n  \u00b7 rw [iUnion_iInter_of_monotone]\n    simp_rw [iUnion_spanningSets, iInter_univ]\n    exact fun i => monotone_spanningSets (\u03bc i)", "start": [3735, 1], "end": [3746, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Add.sigmaFinite", "code": "instance Add.sigmaFinite (\u03bc \u03bd : Measure \u03b1) [SigmaFinite \u03bc] [SigmaFinite \u03bd] :\n    SigmaFinite (\u03bc + \u03bd) := by\n  rw [\u2190 sum_cond]\n  refine' @sum.sigmaFinite _ _ _ _ _ (Bool.rec _ _) <;> simpa", "start": [3749, 1], "end": [3752, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SMul.sigmaFinite", "code": "instance SMul.sigmaFinite {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] (c : \u211d\u22650) :\n    MeasureTheory.SigmaFinite (c \u2022 \u03bc) where\n  out' :=\n  \u27e8{  set := spanningSets \u03bc\n      set_mem := fun _ \u21a6 trivial\n      finite := by\n        intro i\n        simp only [smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n          nnreal_smul_coe_apply]\n        exact ENNReal.mul_lt_top ENNReal.coe_ne_top (measure_spanningSets_lt_top \u03bc i).ne\n      spanning := iUnion_spanningSets \u03bc }\u27e9", "start": [3755, 1], "end": [3765, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SigmaFinite.of_map", "code": "theorem SigmaFinite.of_map (\u03bc : Measure \u03b1) {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc)\n    (h : SigmaFinite (\u03bc.map f)) : SigmaFinite \u03bc", "start": [3767, 1], "end": [3772, 73], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.sigmaFinite_map", "code": "theorem _root_.MeasurableEquiv.sigmaFinite_map {\u03bc : Measure \u03b1} (f : \u03b1 \u2243\u1d50 \u03b2) (h : SigmaFinite \u03bc) :\n    SigmaFinite (\u03bc.map f)", "start": [3775, 1], "end": [3778, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_of_forall_measure_lt_top_ae_restrict'", "code": "theorem ae_of_forall_measure_lt_top_ae_restrict' {\u03bc : Measure \u03b1} (\u03bd : Measure \u03b1) [SigmaFinite \u03bc]\n    [SigmaFinite \u03bd] (P : \u03b1 \u2192 Prop)\n    (h : \u2200 s, MeasurableSet s \u2192 \u03bc s < \u221e \u2192 \u03bd s < \u221e \u2192 \u2200\u1d50 x \u2202\u03bc.restrict s, P x) : \u2200\u1d50 x \u2202\u03bc, P x", "start": [3781, 1], "end": [3793, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_of_forall_measure_lt_top_ae_restrict", "code": "theorem ae_of_forall_measure_lt_top_ae_restrict {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] (P : \u03b1 \u2192 Prop)\n    (h : \u2200 s, MeasurableSet s \u2192 \u03bc s < \u221e \u2192 \u2200\u1d50 x \u2202\u03bc.restrict s, P x) : \u2200\u1d50 x \u2202\u03bc, P x", "start": [3796, 1], "end": [3800, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.IsLocallyFiniteMeasure", "code": "class IsLocallyFiniteMeasure [TopologicalSpace \u03b1] (\u03bc : Measure \u03b1) : Prop where\n  finiteAtNhds : \u2200 x, \u03bc.FiniteAtFilter (\ud835\udcdd x)", "start": [3803, 1], "end": [3805, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.IsFiniteMeasure.toIsLocallyFiniteMeasure", "code": "instance (priority := 100) IsFiniteMeasure.toIsLocallyFiniteMeasure [TopologicalSpace \u03b1]\n    (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] : IsLocallyFiniteMeasure \u03bc :=\n  \u27e8fun _ => finiteAtFilter_of_finite _ _\u27e9", "start": [3810, 1], "end": [3812, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.finiteAt_nhds", "code": "theorem Measure.finiteAt_nhds [TopologicalSpace \u03b1] (\u03bc : Measure \u03b1) [IsLocallyFiniteMeasure \u03bc]\n    (x : \u03b1) : \u03bc.FiniteAtFilter (\ud835\udcdd x)", "start": [3815, 1], "end": [3817, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.smul_finite", "code": "theorem Measure.smul_finite (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] {c : \u211d\u22650\u221e} (hc : c \u2260 \u221e) :\n    IsFiniteMeasure (c \u2022 \u03bc)", "start": [3820, 1], "end": [3823, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.exists_isOpen_measure_lt_top", "code": "theorem Measure.exists_isOpen_measure_lt_top [TopologicalSpace \u03b1] (\u03bc : Measure \u03b1)\n    [IsLocallyFiniteMeasure \u03bc] (x : \u03b1) : \u2203 s : Set \u03b1, x \u2208 s \u2227 IsOpen s \u2227 \u03bc s < \u221e", "start": [3826, 1], "end": [3829, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.isLocallyFiniteMeasureSMulNNReal", "code": "instance isLocallyFiniteMeasureSMulNNReal [TopologicalSpace \u03b1] (\u03bc : Measure \u03b1)\n    [IsLocallyFiniteMeasure \u03bc] (c : \u211d\u22650) : IsLocallyFiniteMeasure (c \u2022 \u03bc) := by\n  refine' \u27e8fun x => _\u27e9\n  rcases \u03bc.exists_isOpen_measure_lt_top x with \u27e8o, xo, o_open, \u03bco\u27e9\n  refine' \u27e8o, o_open.mem_nhds xo, _\u27e9\n  apply ENNReal.mul_lt_top _ \u03bco.ne\n  simp", "start": [3832, 1], "end": [3838, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.isTopologicalBasis_isOpen_lt_top", "code": "protected theorem Measure.isTopologicalBasis_isOpen_lt_top [TopologicalSpace \u03b1]\n    (\u03bc : Measure \u03b1) [IsLocallyFiniteMeasure \u03bc] :\n    TopologicalSpace.IsTopologicalBasis { s | IsOpen s \u2227 \u03bc s < \u221e }", "start": [3841, 1], "end": [3848, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.IsFiniteMeasureOnCompacts", "code": "class IsFiniteMeasureOnCompacts [TopologicalSpace \u03b1] (\u03bc : Measure \u03b1) : Prop where\n  protected lt_top_of_isCompact : \u2200 \u2983K : Set \u03b1\u2984, IsCompact K \u2192 \u03bc K < \u221e", "start": [3851, 1], "end": [3853, 71], "kind": "commanddeclaration"}, {"full_name": "IsCompact.measure_lt_top", "code": "theorem _root_.IsCompact.measure_lt_top [TopologicalSpace \u03b1] {\u03bc : Measure \u03b1}\n    [IsFiniteMeasureOnCompacts \u03bc] \u2983K : Set \u03b1\u2984 (hK : IsCompact K) : \u03bc K < \u221e", "start": [3857, 1], "end": [3860, 51], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.measure_lt_top", "code": "theorem _root_.Bornology.IsBounded.measure_lt_top [PseudoMetricSpace \u03b1] [ProperSpace \u03b1]\n    {\u03bc : Measure \u03b1} [IsFiniteMeasureOnCompacts \u03bc] \u2983s : Set \u03b1\u2984 (hs : Bornology.IsBounded s) :\n    \u03bc s < \u221e", "start": [3863, 1], "end": [3870, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_closedBall_lt_top", "code": "theorem measure_closedBall_lt_top [PseudoMetricSpace \u03b1] [ProperSpace \u03b1] {\u03bc : Measure \u03b1}\n    [IsFiniteMeasureOnCompacts \u03bc] {x : \u03b1} {r : \u211d} : \u03bc (Metric.closedBall x r) < \u221e", "start": [3873, 1], "end": [3875, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_ball_lt_top", "code": "theorem measure_ball_lt_top [PseudoMetricSpace \u03b1] [ProperSpace \u03b1] {\u03bc : Measure \u03b1}\n    [IsFiniteMeasureOnCompacts \u03bc] {x : \u03b1} {r : \u211d} : \u03bc (Metric.ball x r) < \u221e", "start": [3878, 1], "end": [3880, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.IsFiniteMeasureOnCompacts.smul", "code": "protected theorem IsFiniteMeasureOnCompacts.smul [TopologicalSpace \u03b1] (\u03bc : Measure \u03b1)\n    [IsFiniteMeasureOnCompacts \u03bc] {c : \u211d\u22650\u221e} (hc : c \u2260 \u221e) : IsFiniteMeasureOnCompacts (c \u2022 \u03bc)", "start": [3883, 1], "end": [3885, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.CompactSpace.isFiniteMeasure", "code": "theorem CompactSpace.isFiniteMeasure [TopologicalSpace \u03b1] [CompactSpace \u03b1]\n    [IsFiniteMeasureOnCompacts \u03bc] : IsFiniteMeasure \u03bc", "start": [3888, 1], "end": [3892, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SigmaFinite.of_isFiniteMeasureOnCompacts", "code": "instance (priority := 100) SigmaFinite.of_isFiniteMeasureOnCompacts [TopologicalSpace \u03b1]\n    [SigmaCompactSpace \u03b1] (\u03bc : Measure \u03b1) [IsFiniteMeasureOnCompacts \u03bc] : SigmaFinite \u03bc :=\n  \u27e8\u27e8{   set := compactCovering \u03b1\n        set_mem := fun _ => trivial\n        finite := fun n => (isCompact_compactCovering \u03b1 n).measure_lt_top\n        spanning := iUnion_compactCovering \u03b1 }\u27e9\u27e9", "start": [3895, 1], "end": [3900, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.sigmaFinite_of_locallyFinite", "code": "instance (priority := 100) sigmaFinite_of_locallyFinite [TopologicalSpace \u03b1]\n    [SecondCountableTopology \u03b1] [IsLocallyFiniteMeasure \u03bc] : SigmaFinite \u03bc := by\n  choose s hsx hs\u03bc using \u03bc.finiteAt_nhds\n  rcases TopologicalSpace.countable_cover_nhds hsx with \u27e8t, htc, htU\u27e9\n  refine' Measure.sigmaFinite_of_countable (htc.image s) (ball_image_iff.2 fun x _ => hs\u03bc x) _\n  rwa [sUnion_image]", "start": [3903, 1], "end": [3908, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.isLocallyFiniteMeasure_of_isFiniteMeasureOnCompacts", "code": "theorem isLocallyFiniteMeasure_of_isFiniteMeasureOnCompacts [TopologicalSpace \u03b1]\n    [WeaklyLocallyCompactSpace \u03b1] [IsFiniteMeasureOnCompacts \u03bc] : IsLocallyFiniteMeasure \u03bc", "start": [3911, 1], "end": [3917, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_pos_measure_of_cover", "code": "theorem exists_pos_measure_of_cover [Countable \u03b9] {U : \u03b9 \u2192 Set \u03b1} (hU : \u22c3 i, U i = univ)\n    (h\u03bc : \u03bc \u2260 0) : \u2203 i, 0 < \u03bc (U i)", "start": [3920, 1], "end": [3924, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_pos_preimage_ball", "code": "theorem exists_pos_preimage_ball [PseudoMetricSpace \u03b4] (f : \u03b1 \u2192 \u03b4) (x : \u03b4) (h\u03bc : \u03bc \u2260 0) :\n    \u2203 n : \u2115, 0 < \u03bc (f \u207b\u00b9' Metric.ball x n)", "start": [3927, 1], "end": [3929, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_pos_ball", "code": "theorem exists_pos_ball [PseudoMetricSpace \u03b1] (x : \u03b1) (h\u03bc : \u03bc \u2260 0) :\n    \u2203 n : \u2115, 0 < \u03bc (Metric.ball x n)", "start": [3932, 1], "end": [3934, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.null_of_locally_null", "code": "theorem null_of_locally_null [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1] (s : Set \u03b1)\n    (hs : \u2200 x \u2208 s, \u2203 u \u2208 \ud835\udcdd[s] x, \u03bc u = 0) : \u03bc s = 0", "start": [3937, 1], "end": [3941, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_mem_forall_mem_nhdsWithin_pos_measure", "code": "theorem exists_mem_forall_mem_nhdsWithin_pos_measure [TopologicalSpace \u03b1]\n    [SecondCountableTopology \u03b1] {s : Set \u03b1} (hs : \u03bc s \u2260 0) : \u2203 x \u2208 s, \u2200 t \u2208 \ud835\udcdd[s] x, 0 < \u03bc t", "start": [3944, 1], "end": [3946, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_ne_forall_mem_nhds_pos_measure_preimage", "code": "theorem exists_ne_forall_mem_nhds_pos_measure_preimage {\u03b2} [TopologicalSpace \u03b2] [T1Space \u03b2]\n    [SecondCountableTopology \u03b2] [Nonempty \u03b2] {f : \u03b1 \u2192 \u03b2} (h : \u2200 b, \u2203\u1d50 x \u2202\u03bc, f x \u2260 b) :\n    \u2203 a b : \u03b2, a \u2260 b \u2227 (\u2200 s \u2208 \ud835\udcdd a, 0 < \u03bc (f \u207b\u00b9' s)) \u2227 \u2200 t \u2208 \ud835\udcdd b, 0 < \u03bc (f \u207b\u00b9' t)", "start": [3949, 1], "end": [3961, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ext_on_measurableSpace_of_generate_finite", "code": "theorem ext_on_measurableSpace_of_generate_finite {\u03b1} (m\u2080 : MeasurableSpace \u03b1) {\u03bc \u03bd : Measure \u03b1}\n    [IsFiniteMeasure \u03bc] (C : Set (Set \u03b1)) (h\u03bc\u03bd : \u2200 s \u2208 C, \u03bc s = \u03bd s) {m : MeasurableSpace \u03b1}\n    (h : m \u2264 m\u2080) (hA : m = MeasurableSpace.generateFrom C) (hC : IsPiSystem C)\n    (h_univ : \u03bc Set.univ = \u03bd Set.univ) {s : Set \u03b1} (hs : MeasurableSet[m] s) : \u03bc s = \u03bd s", "start": [3964, 1], "end": [3981, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ext_of_generate_finite", "code": "theorem ext_of_generate_finite (C : Set (Set \u03b1)) (hA : m0 = generateFrom C) (hC : IsPiSystem C)\n    [IsFiniteMeasure \u03bc] (h\u03bc\u03bd : \u2200 s \u2208 C, \u03bc s = \u03bd s) (h_univ : \u03bc univ = \u03bd univ) : \u03bc = \u03bd", "start": [3984, 1], "end": [3989, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteSpanningSetsIn.disjointed", "code": "protected def FiniteSpanningSetsIn.disjointed {\u03bc : Measure \u03b1}\n    (S : \u03bc.FiniteSpanningSetsIn { s | MeasurableSet s }) :\n    \u03bc.FiniteSpanningSetsIn { s | MeasurableSet s } :=\n  \u27e8disjointed S.set, MeasurableSet.disjointed S.set_mem, fun n =>\n    lt_of_le_of_lt (measure_mono (disjointed_subset S.set n)) (S.finite _),\n    S.spanning \u25b8 iUnion_disjointed\u27e9", "start": [3996, 1], "end": [4004, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteSpanningSetsIn.disjointed_set_eq", "code": "theorem FiniteSpanningSetsIn.disjointed_set_eq {\u03bc : Measure \u03b1}\n    (S : \u03bc.FiniteSpanningSetsIn { s | MeasurableSet s }) : S.disjointed.set = disjointed S.set", "start": [4007, 1], "end": [4009, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.exists_eq_disjoint_finiteSpanningSetsIn", "code": "theorem exists_eq_disjoint_finiteSpanningSetsIn (\u03bc \u03bd : Measure \u03b1) [SigmaFinite \u03bc] [SigmaFinite \u03bd] :\n    \u2203 (S : \u03bc.FiniteSpanningSetsIn { s | MeasurableSet s })\n      (T : \u03bd.FiniteSpanningSetsIn { s | MeasurableSet s }),\n      S.set = T.set \u2227 Pairwise (Disjoint on S.set)", "start": [4012, 1], "end": [4018, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteAtFilter.filter_mono", "code": "theorem filter_mono (h : f \u2264 g) : \u03bc.FiniteAtFilter g \u2192 \u03bc.FiniteAtFilter f", "start": [4027, 1], "end": [4028, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteAtFilter.inf_of_left", "code": "theorem inf_of_left (h : \u03bc.FiniteAtFilter f) : \u03bc.FiniteAtFilter (f \u2293 g)", "start": [4031, 1], "end": [4032, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteAtFilter.inf_of_right", "code": "theorem inf_of_right (h : \u03bc.FiniteAtFilter g) : \u03bc.FiniteAtFilter (f \u2293 g)", "start": [4035, 1], "end": [4036, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteAtFilter.inf_ae_iff", "code": "@[simp]\ntheorem inf_ae_iff : \u03bc.FiniteAtFilter (f \u2293 \u03bc.ae) \u2194 \u03bc.FiniteAtFilter f", "start": [4039, 1], "end": [4044, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteAtFilter.of_inf_ae", "code": "alias \u27e8of_inf_ae, _\u27e9 := inf_ae_iff", "start": [4047, 1], "end": [4047, 35], "kind": "stdtacticaliasaliaslr"}, {"full_name": "MeasureTheory.Measure.FiniteAtFilter.filter_mono_ae", "code": "theorem filter_mono_ae (h : f \u2293 \u03bc.ae \u2264 g) (hg : \u03bc.FiniteAtFilter g) : \u03bc.FiniteAtFilter f", "start": [4050, 1], "end": [4051, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteAtFilter.measure_mono", "code": "protected theorem measure_mono (h : \u03bc \u2264 \u03bd) : \u03bd.FiniteAtFilter f \u2192 \u03bc.FiniteAtFilter f", "start": [4054, 1], "end": [4055, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteAtFilter.mono", "code": "@[mono]\nprotected theorem mono (hf : f \u2264 g) (h\u03bc : \u03bc \u2264 \u03bd) : \u03bd.FiniteAtFilter g \u2192 \u03bc.FiniteAtFilter f", "start": [4058, 1], "end": [4060, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteAtFilter.eventually", "code": "protected theorem eventually (h : \u03bc.FiniteAtFilter f) : \u2200\u1da0 s in f.smallSets, \u03bc s < \u221e", "start": [4063, 1], "end": [4064, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.FiniteAtFilter.filterSup", "code": "theorem filterSup : \u03bc.FiniteAtFilter f \u2192 \u03bc.FiniteAtFilter g \u2192 \u03bc.FiniteAtFilter (f \u2294 g)", "start": [4067, 1], "end": [4069, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.finiteAt_nhdsWithin", "code": "theorem finiteAt_nhdsWithin [TopologicalSpace \u03b1] {_m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1)\n    [IsLocallyFiniteMeasure \u03bc] (x : \u03b1) (s : Set \u03b1) : \u03bc.FiniteAtFilter (\ud835\udcdd[s] x)", "start": [4074, 1], "end": [4076, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.finiteAt_principal", "code": "@[simp]\ntheorem finiteAt_principal : \u03bc.FiniteAtFilter (\ud835\udcdf s) \u2194 \u03bc s < \u221e", "start": [4079, 1], "end": [4081, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.isLocallyFiniteMeasure_of_le", "code": "theorem isLocallyFiniteMeasure_of_le [TopologicalSpace \u03b1] {_m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}\n    [H : IsLocallyFiniteMeasure \u03bc] (h : \u03bd \u2264 \u03bc) : IsLocallyFiniteMeasure \u03bd", "start": [4084, 1], "end": [4087, 34], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.map_apply", "code": "nonrec theorem map_apply (\u03bc : Measure \u03b1) (s : Set \u03b2) : \u03bc.map f s = \u03bc (f \u207b\u00b9' s)", "start": [4102, 1], "end": [4116, 86], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.map_comap", "code": "theorem map_comap (\u03bc : Measure \u03b2) : (comap f \u03bc).map f = \u03bc.restrict (range f)", "start": [4119, 1], "end": [4122, 62], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.comap_apply", "code": "theorem comap_apply (\u03bc : Measure \u03b2) (s : Set \u03b1) : comap f \u03bc s = \u03bc (f '' s)", "start": [4125, 1], "end": [4131, 63], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.ae_map_iff", "code": "theorem ae_map_iff {p : \u03b2 \u2192 Prop} {\u03bc : Measure \u03b1} : (\u2200\u1d50 x \u2202\u03bc.map f, p x) \u2194 \u2200\u1d50 x \u2202\u03bc, p (f x)", "start": [4135, 1], "end": [4136, 54], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.restrict_map", "code": "theorem restrict_map (\u03bc : Measure \u03b1) (s : Set \u03b2) :\n    (\u03bc.map f).restrict s = (\u03bc.restrict <| f \u207b\u00b9' s).map f", "start": [4139, 1], "end": [4141, 71], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.comap_preimage", "code": "protected theorem comap_preimage (\u03bc : Measure \u03b2) {s : Set \u03b2} (hs : MeasurableSet s) :\n    \u03bc.comap f (f \u207b\u00b9' s) = \u03bc (s \u2229 range f)", "start": [4144, 1], "end": [4147, 69], "kind": "commanddeclaration"}, {"full_name": "comap_subtype_coe_apply", "code": "theorem comap_subtype_coe_apply {_m0 : MeasurableSpace \u03b1} {s : Set \u03b1} (hs : MeasurableSet s)\n    (\u03bc : Measure \u03b1) (t : Set s) : comap (\u2191) \u03bc t = \u03bc ((\u2191) '' t)", "start": [4154, 1], "end": [4156, 55], "kind": "commanddeclaration"}, {"full_name": "map_comap_subtype_coe", "code": "theorem map_comap_subtype_coe {m0 : MeasurableSpace \u03b1} {s : Set \u03b1} (hs : MeasurableSet s)\n    (\u03bc : Measure \u03b1) : (comap (\u2191) \u03bc).map ((\u2191) : s \u2192 \u03b1) = \u03bc.restrict s", "start": [4159, 1], "end": [4161, 73], "kind": "commanddeclaration"}, {"full_name": "ae_restrict_iff_subtype", "code": "theorem ae_restrict_iff_subtype {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : MeasurableSet s) {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1d50 x \u2202\u03bc.restrict s, p x) \u2194 \u2200\u1d50 (x : s) \u2202comap ((\u2191) : s \u2192 \u03b1) \u03bc, p x", "start": [4164, 1], "end": [4167, 83], "kind": "commanddeclaration"}, {"full_name": "SetCoe.measureSpace", "code": "instance SetCoe.measureSpace (s : Set \u03b1) : MeasureSpace s :=\n  \u27e8comap ((\u2191) : s \u2192 \u03b1) volume\u27e9", "start": [4177, 1], "end": [4178, 31], "kind": "commanddeclaration"}, {"full_name": "volume_set_coe_def", "code": "theorem volume_set_coe_def (s : Set \u03b1) : (volume : Measure s) = comap ((\u2191) : s \u2192 \u03b1) volume", "start": [4181, 1], "end": [4182, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.map_coe_volume", "code": "theorem MeasurableSet.map_coe_volume {s : Set \u03b1} (hs : MeasurableSet s) :\n    volume.map ((\u2191) : s \u2192 \u03b1) = restrict volume s", "start": [4185, 1], "end": [4187, 100], "kind": "commanddeclaration"}, {"full_name": "volume_image_subtype_coe", "code": "theorem volume_image_subtype_coe {s : Set \u03b1} (hs : MeasurableSet s) (t : Set s) :\n    volume ((\u2191) '' t : Set \u03b1) = volume t", "start": [4190, 1], "end": [4192, 45], "kind": "commanddeclaration"}, {"full_name": "volume_preimage_coe", "code": "@[simp]\ntheorem volume_preimage_coe (hs : NullMeasurableSet s) (ht : MeasurableSet t) :\n    volume (((\u2191) : s \u2192 \u03b1) \u207b\u00b9' t) = volume (t \u2229 s)", "start": [4195, 1], "end": [4202, 54], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.map_apply", "code": "protected theorem map_apply (f : \u03b1 \u2243\u1d50 \u03b2) (s : Set \u03b2) : \u03bc.map f s = \u03bc (f \u207b\u00b9' s)", "start": [4216, 1], "end": [4219, 38], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.comap_symm", "code": "lemma comap_symm (e : \u03b1 \u2243\u1d50 \u03b2) : \u03bc.comap e.symm = \u03bc.map e := by\n  ext s hs\n  rw [e.map_apply, Measure.comap_apply _ e.symm.injective _ _ hs, image_symm]\n  exact fun t ht \u21a6 e.symm.measurableSet_image.mpr ht", "start": [4222, 1], "end": [4225, 53], "kind": "mathlibtacticlemma"}, {"full_name": "MeasurableEquiv.map_symm", "code": "lemma map_symm (e : \u03b2 \u2243\u1d50 \u03b1) : \u03bc.map e.symm = \u03bc.comap e := by\n  rw [\u2190 comap_symm, symm_symm]", "start": [4227, 1], "end": [4228, 31], "kind": "mathlibtacticlemma"}, {"full_name": "MeasurableEquiv.map_symm_map", "code": "@[simp]\ntheorem map_symm_map (e : \u03b1 \u2243\u1d50 \u03b2) : (\u03bc.map e).map e.symm = \u03bc", "start": [4230, 1], "end": [4232, 48], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.map_map_symm", "code": "@[simp]\ntheorem map_map_symm (e : \u03b1 \u2243\u1d50 \u03b2) : (\u03bd.map e.symm).map e = \u03bd", "start": [4235, 1], "end": [4237, 48], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.map_measurableEquiv_injective", "code": "theorem map_measurableEquiv_injective (e : \u03b1 \u2243\u1d50 \u03b2) : Injective (Measure.map e)", "start": [4240, 1], "end": [4243, 34], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.map_apply_eq_iff_map_symm_apply_eq", "code": "theorem map_apply_eq_iff_map_symm_apply_eq (e : \u03b1 \u2243\u1d50 \u03b2) : \u03bc.map e = \u03bd \u2194 \u03bd.map e.symm = \u03bc", "start": [4246, 1], "end": [4247, 73], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.restrict_map", "code": "theorem restrict_map (e : \u03b1 \u2243\u1d50 \u03b2) (s : Set \u03b2) :\n    (\u03bc.map e).restrict s = (\u03bc.restrict <| e \u207b\u00b9' s).map e", "start": [4250, 1], "end": [4252, 41], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.map_ae", "code": "theorem map_ae (f : \u03b1 \u2243\u1d50 \u03b2) (\u03bc : Measure \u03b1) : Filter.map f \u03bc.ae = (map f \u03bc).ae", "start": [4255, 1], "end": [4257, 63], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.quasiMeasurePreserving_symm", "code": "theorem quasiMeasurePreserving_symm (\u03bc : Measure \u03b1) (e : \u03b1 \u2243\u1d50 \u03b2) :\n    QuasiMeasurePreserving e.symm (map e \u03bc) \u03bc", "start": [4260, 1], "end": [4262, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.toMeasure_zero", "code": "theorem OuterMeasure.toMeasure_zero [MeasurableSpace \u03b1] :\n    (0 : OuterMeasure \u03b1).toMeasure (le_top.trans OuterMeasure.zero_caratheodory.symm.le) = 0", "start": [4269, 1], "end": [4272, 42], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_open_superset_measure_lt_top'", "code": "theorem exists_open_superset_measure_lt_top' (h : IsCompact s)\n    (h\u03bc : \u2200 x \u2208 s, \u03bc.FiniteAtFilter (\ud835\udcdd x)) : \u2203 (U : _) (_ : U \u2287 s), IsOpen U \u2227 \u03bc U < \u221e", "start": [4281, 1], "end": [4296, 76], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_open_superset_measure_lt_top", "code": "theorem exists_open_superset_measure_lt_top (h : IsCompact s) (\u03bc : Measure \u03b1)\n    [IsLocallyFiniteMeasure \u03bc] : \u2203 (U : _) (_ : U \u2287 s), IsOpen U \u2227 \u03bc U < \u221e", "start": [4299, 1], "end": [4303, 70], "kind": "commanddeclaration"}, {"full_name": "IsCompact.measure_lt_top_of_nhdsWithin", "code": "theorem measure_lt_top_of_nhdsWithin (h : IsCompact s) (h\u03bc : \u2200 x \u2208 s, \u03bc.FiniteAtFilter (\ud835\udcdd[s] x)) :\n    \u03bc s < \u221e", "start": [4306, 1], "end": [4309, 90], "kind": "commanddeclaration"}, {"full_name": "IsCompact.measure_zero_of_nhdsWithin", "code": "theorem measure_zero_of_nhdsWithin (hs : IsCompact s) :\n    (\u2200 a \u2208 s, \u2203 t \u2208 \ud835\udcdd[s] a, \u03bc t = 0) \u2192 \u03bc s = 0", "start": [4312, 1], "end": [4314, 72], "kind": "commanddeclaration"}, {"full_name": "isFiniteMeasureOnCompacts_of_isLocallyFiniteMeasure", "code": "instance (priority := 100) isFiniteMeasureOnCompacts_of_isLocallyFiniteMeasure [TopologicalSpace \u03b1]\n    {_ : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} [IsLocallyFiniteMeasure \u03bc] :\n    IsFiniteMeasureOnCompacts \u03bc :=\n  \u27e8fun _s hs => hs.measure_lt_top_of_nhdsWithin fun _ _ => \u03bc.finiteAt_nhdsWithin _ _\u27e9", "start": [4320, 1], "end": [4323, 86], "kind": "commanddeclaration"}, {"full_name": "isFiniteMeasure_iff_isFiniteMeasureOnCompacts_of_compactSpace", "code": "theorem isFiniteMeasure_iff_isFiniteMeasureOnCompacts_of_compactSpace [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} [CompactSpace \u03b1] :\n    IsFiniteMeasure \u03bc \u2194 IsFiniteMeasureOnCompacts \u03bc", "start": [4326, 1], "end": [4331, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.finiteSpanningSetsInCompact", "code": "def MeasureTheory.Measure.finiteSpanningSetsInCompact [TopologicalSpace \u03b1] [SigmaCompactSpace \u03b1]\n    {_ : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) [IsLocallyFiniteMeasure \u03bc] :\n    \u03bc.FiniteSpanningSetsIn { K | IsCompact K } where\n  set := compactCovering \u03b1\n  set_mem := isCompact_compactCovering \u03b1\n  finite n := (isCompact_compactCovering \u03b1 n).measure_lt_top\n  spanning := iUnion_compactCovering \u03b1", "start": [4334, 1], "end": [4342, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.finiteSpanningSetsInOpen", "code": "def MeasureTheory.Measure.finiteSpanningSetsInOpen [TopologicalSpace \u03b1] [SigmaCompactSpace \u03b1]\n    {_ : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) [IsLocallyFiniteMeasure \u03bc] :\n    \u03bc.FiniteSpanningSetsIn { K | IsOpen K } where\n  set n := ((isCompact_compactCovering \u03b1 n).exists_open_superset_measure_lt_top \u03bc).choose\n  set_mem n :=\n    ((isCompact_compactCovering \u03b1 n).exists_open_superset_measure_lt_top \u03bc).choose_spec.snd.1\n  finite n :=\n    ((isCompact_compactCovering \u03b1 n).exists_open_superset_measure_lt_top \u03bc).choose_spec.snd.2\n  spanning :=\n    eq_univ_of_subset\n      (iUnion_mono fun n =>\n        ((isCompact_compactCovering \u03b1 n).exists_open_superset_measure_lt_top \u03bc).choose_spec.fst)\n      (iUnion_compactCovering \u03b1)", "start": [4345, 1], "end": [4359, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.finiteSpanningSetsInOpen'", "code": "irreducible_def MeasureTheory.Measure.finiteSpanningSetsInOpen' [TopologicalSpace \u03b1]\n  [SecondCountableTopology \u03b1] {m : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) [IsLocallyFiniteMeasure \u03bc] :\n  \u03bc.FiniteSpanningSetsIn { K | IsOpen K } := by\n  suffices H : Nonempty (\u03bc.FiniteSpanningSetsIn { K | IsOpen K })\n  exact H.some\n  cases isEmpty_or_nonempty \u03b1\n  \u00b7 exact\n      \u27e8{  set := fun _ => \u2205\n          set_mem := fun _ => by simp\n          finite := fun _ => by simp\n          spanning := by simp }\u27e9\n  inhabit \u03b1\n  let S : Set (Set \u03b1) := { s | IsOpen s \u2227 \u03bc s < \u221e }\n  obtain \u27e8T, T_count, TS, hT\u27e9 : \u2203 T : Set (Set \u03b1), T.Countable \u2227 T \u2286 S \u2227 \u22c3\u2080 T = \u22c3\u2080 S :=\n    isOpen_sUnion_countable S fun s hs => hs.1\n  rw [\u03bc.isTopologicalBasis_isOpen_lt_top.sUnion_eq] at hT\n  have T_ne : T.Nonempty := by\n    by_contra h'T\n    rw [not_nonempty_iff_eq_empty.1 h'T, sUnion_empty] at hT\n    simpa only [\u2190 hT] using mem_univ (default : \u03b1)\n  obtain \u27e8f, hf\u27e9 : \u2203 f : \u2115 \u2192 Set \u03b1, T = range f\n  exact T_count.exists_eq_range T_ne\n  have fS : \u2200 n, f n \u2208 S := by\n    intro n\n    apply TS\n    rw [hf]\n    exact mem_range_self n\n  refine'\n    \u27e8{  set := f\n        set_mem := fun n => (fS n).1\n        finite := fun n => (fS n).2\n        spanning := _ }\u27e9\n  refine eq_univ_of_forall fun x => ?_\n  obtain \u27e8t, tT, xt\u27e9 : \u2203 t : Set \u03b1, t \u2208 range f \u2227 x \u2208 t := by\n    have : x \u2208 \u22c3\u2080 T := by simp only [hT, mem_univ]\n    simpa only [mem_sUnion, exists_prop, \u2190 hf]\n  obtain \u27e8n, rfl\u27e9 : \u2203 n : \u2115, f n = t := by simpa only using tT\n  exact mem_iUnion_of_mem _ xt", "start": [4364, 1], "end": [4403, 31], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "measure_Icc_lt_top", "code": "theorem measure_Icc_lt_top : \u03bc (Icc a b) < \u221e", "start": [4411, 1], "end": [4412, 31], "kind": "commanddeclaration"}, {"full_name": "measure_Ico_lt_top", "code": "theorem measure_Ico_lt_top : \u03bc (Ico a b) < \u221e", "start": [4415, 1], "end": [4416, 65], "kind": "commanddeclaration"}, {"full_name": "measure_Ioc_lt_top", "code": "theorem measure_Ioc_lt_top : \u03bc (Ioc a b) < \u221e", "start": [4419, 1], "end": [4420, 65], "kind": "commanddeclaration"}, {"full_name": "measure_Ioo_lt_top", "code": "theorem measure_Ioo_lt_top : \u03bc (Ioo a b) < \u221e", "start": [4423, 1], "end": [4424, 65], "kind": "commanddeclaration"}, {"full_name": "piecewise_ae_eq_restrict", "code": "theorem piecewise_ae_eq_restrict (hs : MeasurableSet s) : piecewise s f g =\u1d50[\u03bc.restrict s] f", "start": [4433, 1], "end": [4435, 69], "kind": "commanddeclaration"}, {"full_name": "piecewise_ae_eq_restrict_compl", "code": "theorem piecewise_ae_eq_restrict_compl (hs : MeasurableSet s) :\n    piecewise s f g =\u1d50[\u03bc.restrict s\u1d9c] g", "start": [4438, 1], "end": [4441, 75], "kind": "commanddeclaration"}, {"full_name": "piecewise_ae_eq_of_ae_eq_set", "code": "theorem piecewise_ae_eq_of_ae_eq_set (hst : s =\u1d50[\u03bc] t) : s.piecewise f g =\u1d50[\u03bc] t.piecewise f g", "start": [4444, 1], "end": [4445, 55], "kind": "commanddeclaration"}, {"full_name": "mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem", "code": "theorem mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem [Zero \u03b2] {t : Set \u03b2}\n    (ht : (0 : \u03b2) \u2208 t) (hs : MeasurableSet s) :\n    t \u2208 Filter.map (s.indicator f) \u03bc.ae \u2194 t \u2208 Filter.map f (\u03bc.restrict s).ae", "start": [4454, 1], "end": [4463, 83], "kind": "commanddeclaration"}, {"full_name": "mem_map_indicator_ae_iff_of_zero_nmem", "code": "theorem mem_map_indicator_ae_iff_of_zero_nmem [Zero \u03b2] {t : Set \u03b2} (ht : (0 : \u03b2) \u2209 t) :\n    t \u2208 Filter.map (s.indicator f) \u03bc.ae \u2194 \u03bc ((f \u207b\u00b9' t)\u1d9c \u222a s\u1d9c) = 0", "start": [4466, 1], "end": [4470, 96], "kind": "commanddeclaration"}, {"full_name": "map_restrict_ae_le_map_indicator_ae", "code": "theorem map_restrict_ae_le_map_indicator_ae [Zero \u03b2] (hs : MeasurableSet s) :\n    Filter.map f (\u03bc.restrict s).ae \u2264 Filter.map (s.indicator f) \u03bc.ae", "start": [4473, 1], "end": [4480, 101], "kind": "commanddeclaration"}, {"full_name": "indicator_ae_eq_restrict", "code": "theorem indicator_ae_eq_restrict (hs : MeasurableSet s) : indicator s f =\u1d50[\u03bc.restrict s] f", "start": [4485, 1], "end": [4486, 30], "kind": "commanddeclaration"}, {"full_name": "indicator_ae_eq_restrict_compl", "code": "theorem indicator_ae_eq_restrict_compl (hs : MeasurableSet s) :\n    indicator s f =\u1d50[\u03bc.restrict s\u1d9c] 0", "start": [4489, 1], "end": [4491, 36], "kind": "commanddeclaration"}, {"full_name": "indicator_ae_eq_of_restrict_compl_ae_eq_zero", "code": "theorem indicator_ae_eq_of_restrict_compl_ae_eq_zero (hs : MeasurableSet s)\n    (hf : f =\u1d50[\u03bc.restrict s\u1d9c] 0) : s.indicator f =\u1d50[\u03bc] f", "start": [4494, 1], "end": [4500, 99], "kind": "commanddeclaration"}, {"full_name": "indicator_ae_eq_zero_of_restrict_ae_eq_zero", "code": "theorem indicator_ae_eq_zero_of_restrict_ae_eq_zero (hs : MeasurableSet s)\n    (hf : f =\u1d50[\u03bc.restrict s] 0) : s.indicator f =\u1d50[\u03bc] 0", "start": [4503, 1], "end": [4509, 19], "kind": "commanddeclaration"}, {"full_name": "indicator_ae_eq_of_ae_eq_set", "code": "theorem indicator_ae_eq_of_ae_eq_set (hst : s =\u1d50[\u03bc] t) : s.indicator f =\u1d50[\u03bc] t.indicator f", "start": [4512, 1], "end": [4513, 35], "kind": "commanddeclaration"}, {"full_name": "indicator_meas_zero", "code": "theorem indicator_meas_zero (hs : \u03bc s = 0) : indicator s f =\u1d50[\u03bc] 0", "start": [4516, 1], "end": [4517, 71], "kind": "commanddeclaration"}, {"full_name": "ae_eq_restrict_iff_indicator_ae_eq", "code": "theorem ae_eq_restrict_iff_indicator_ae_eq {g : \u03b1 \u2192 \u03b2} (hs : MeasurableSet s) :\n    f =\u1d50[\u03bc.restrict s] g \u2194 s.indicator f =\u1d50[\u03bc] s.indicator g", "start": [4520, 1], "end": [4528, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/FilterBasis.lean", "imports": ["Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/Order/Filter/Bases.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "GroupFilterBasis", "code": "class GroupFilterBasis (G : Type u) [Group G] extends FilterBasis G where\n  one' : \u2200 {U}, U \u2208 sets \u2192 (1 : G) \u2208 U\n  mul' : \u2200 {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V * V \u2286 U\n  inv' : \u2200 {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V \u2286 (fun x \u21a6 x\u207b\u00b9) \u207b\u00b9' U\n  conj' : \u2200 x\u2080, \u2200 {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V \u2286 (fun x \u21a6 x\u2080 * x * x\u2080\u207b\u00b9) \u207b\u00b9' U", "start": [46, 1], "end": [54, 80], "kind": "commanddeclaration"}, {"full_name": "AddGroupFilterBasis", "code": "class AddGroupFilterBasis (A : Type u) [AddGroup A] extends FilterBasis A where\n  zero' : \u2200 {U}, U \u2208 sets \u2192 (0 : A) \u2208 U\n  add' : \u2200 {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V + V \u2286 U\n  neg' : \u2200 {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V \u2286 (fun x \u21a6 -x) \u207b\u00b9' U\n  conj' : \u2200 x\u2080, \u2200 {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V \u2286 (fun x \u21a6 x\u2080 + x + -x\u2080) \u207b\u00b9' U", "start": [57, 1], "end": [65, 79], "kind": "commanddeclaration"}, {"full_name": "groupFilterBasisOfComm", "code": "@[to_additive \"`AddGroupFilterBasis` constructor in the additive commutative group case.\"]\ndef groupFilterBasisOfComm {G : Type*} [CommGroup G] (sets : Set (Set G))\n    (nonempty : sets.Nonempty) (inter_sets : \u2200 x y, x \u2208 sets \u2192 y \u2208 sets \u2192 \u2203 z \u2208 sets, z \u2286 x \u2229 y)\n    (one : \u2200 U \u2208 sets, (1 : G) \u2208 U) (mul : \u2200 U \u2208 sets, \u2203 V \u2208 sets, V * V \u2286 U)\n    (inv : \u2200 U \u2208 sets, \u2203 V \u2208 sets, V \u2286 (fun x \u21a6 x\u207b\u00b9) \u207b\u00b9' U) : GroupFilterBasis G :=\n  { sets := sets\n    nonempty := nonempty\n    inter_sets := inter_sets _ _\n    one' := one _\n    mul' := mul _\n    inv' := inv _\n    conj' := fun x U U_in \u21a6 \u27e8U, U_in, by simp only [mul_inv_cancel_comm, preimage_id']; rfl\u27e9 }", "start": [71, 1], "end": [83, 95], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.one", "code": "@[to_additive]\ntheorem one {U : Set G} : U \u2208 B \u2192 (1 : G) \u2208 U", "start": [95, 1], "end": [97, 24], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.mul", "code": "@[to_additive]\ntheorem mul {U : Set G} : U \u2208 B \u2192 \u2203 V \u2208 B, V * V \u2286 U", "start": [101, 1], "end": [103, 24], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.inv", "code": "@[to_additive]\ntheorem inv {U : Set G} : U \u2208 B \u2192 \u2203 V \u2208 B, V \u2286 (fun x \u21a6 x\u207b\u00b9) \u207b\u00b9' U", "start": [107, 1], "end": [109, 24], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.conj", "code": "@[to_additive]\ntheorem conj : \u2200 x\u2080, \u2200 {U}, U \u2208 B \u2192 \u2203 V \u2208 B, V \u2286 (fun x \u21a6 x\u2080 * x * x\u2080\u207b\u00b9) \u207b\u00b9' U", "start": [113, 1], "end": [115, 25], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.prod_subset_self", "code": "@[to_additive]\ntheorem prod_subset_self (B : GroupFilterBasis G) {U : Set G} (h : U \u2208 B) : U \u2286 U * U", "start": [142, 1], "end": [144, 46], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.N", "code": "@[to_additive \"The neighborhood function of an `AddGroupFilterBasis`.\"]\ndef N (B : GroupFilterBasis G) : G \u2192 Filter G :=\n  fun x \u21a6 map (fun y \u21a6 x * y) B.toFilterBasis.filter", "start": [148, 1], "end": [151, 53], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.N_one", "code": "@[to_additive (attr := simp)]\ntheorem N_one (B : GroupFilterBasis G) : B.N 1 = B.toFilterBasis.filter", "start": [157, 1], "end": [159, 34], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.hasBasis", "code": "@[to_additive]\nprotected theorem hasBasis (B : GroupFilterBasis G) (x : G) :\n    HasBasis (B.N x) (fun V : Set G \u21a6 V \u2208 B) fun V \u21a6 (fun y \u21a6 x * y) '' V", "start": [165, 1], "end": [168, 54], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.topology", "code": "@[to_additive \"The topological space structure coming from an additive group filter basis.\"]\ndef topology (B : GroupFilterBasis G) : TopologicalSpace G :=\n  TopologicalSpace.mkOfNhds B.N", "start": [172, 1], "end": [175, 32], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.nhds_eq", "code": "@[to_additive]\ntheorem nhds_eq (B : GroupFilterBasis G) {x\u2080 : G} : @nhds G B.topology x\u2080 = B.N x\u2080", "start": [179, 1], "end": [200, 65], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.nhds_one_eq", "code": "@[to_additive]\ntheorem nhds_one_eq (B : GroupFilterBasis G) :\n    @nhds G B.topology (1 : G) = B.toFilterBasis.filter", "start": [204, 1], "end": [209, 15], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.nhds_hasBasis", "code": "@[to_additive]\ntheorem nhds_hasBasis (B : GroupFilterBasis G) (x\u2080 : G) :\n    HasBasis (@nhds G B.topology x\u2080) (fun V : Set G \u21a6 V \u2208 B) fun V \u21a6 (fun y \u21a6 x\u2080 * y) '' V", "start": [213, 1], "end": [217, 19], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.nhds_one_hasBasis", "code": "@[to_additive]\ntheorem nhds_one_hasBasis (B : GroupFilterBasis G) :\n    HasBasis (@nhds G B.topology 1) (fun V : Set G \u21a6 V \u2208 B) id", "start": [221, 1], "end": [225, 33], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.mem_nhds_one", "code": "@[to_additive]\ntheorem mem_nhds_one (B : GroupFilterBasis G) {U : Set G} (hU : U \u2208 B) :\n    U \u2208 @nhds G B.topology 1", "start": [229, 1], "end": [233, 28], "kind": "commanddeclaration"}, {"full_name": "GroupFilterBasis.isTopologicalGroup", "code": "@[to_additive \"If a group is endowed with a topological structure coming from a group filter basis\nthen it's a topological group.\"]\ninstance (priority := 100) isTopologicalGroup (B : GroupFilterBasis G) :\n    @TopologicalGroup G B.topology _ := by\n  letI := B.topology\n  have basis := B.nhds_one_hasBasis\n  have basis' := basis.prod basis\n  refine' TopologicalGroup.of_nhds_one _ _ _ _\n  \u00b7 rw [basis'.tendsto_iff basis]\n    suffices \u2200 U \u2208 B, \u2203 V W, (V \u2208 B \u2227 W \u2208 B) \u2227 \u2200 a b, a \u2208 V \u2192 b \u2208 W \u2192 a * b \u2208 U by simpa\n    intro U U_in\n    rcases mul U_in with \u27e8V, V_in, hV\u27e9\n    refine' \u27e8V, V, \u27e8V_in, V_in\u27e9, _\u27e9\n    intro a b a_in b_in\n    exact hV \u27e8a, b, a_in, b_in, rfl\u27e9\n  \u00b7 rw [basis.tendsto_iff basis]\n    intro U U_in\n    simpa using inv U_in\n  \u00b7 intro x\u2080\n    rw [nhds_eq, nhds_one_eq]\n    rfl\n  \u00b7 intro x\u2080\n    rw [basis.tendsto_iff basis]\n    intro U U_in\n    exact conj x\u2080 U_in", "start": [238, 1], "end": [264, 23], "kind": "commanddeclaration"}, {"full_name": "RingFilterBasis", "code": "class RingFilterBasis (R : Type u) [Ring R] extends AddGroupFilterBasis R where\n  mul' : \u2200 {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V * V \u2286 U\n  mul_left' : \u2200 (x\u2080 : R) {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V \u2286 (fun x \u21a6 x\u2080 * x) \u207b\u00b9' U\n  mul_right' : \u2200 (x\u2080 : R) {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V \u2286 (fun x \u21a6 x * x\u2080) \u207b\u00b9' U", "start": [270, 1], "end": [277, 81], "kind": "commanddeclaration"}, {"full_name": "RingFilterBasis.mul", "code": "theorem mul {U : Set R} (hU : U \u2208 B) : \u2203 V \u2208 B, V * V \u2286 U", "start": [287, 1], "end": [288, 10], "kind": "commanddeclaration"}, {"full_name": "RingFilterBasis.mul_left", "code": "theorem mul_left (x\u2080 : R) {U : Set R} (hU : U \u2208 B) : \u2203 V \u2208 B, V \u2286 (fun x \u21a6 x\u2080 * x) \u207b\u00b9' U", "start": [291, 1], "end": [292, 18], "kind": "commanddeclaration"}, {"full_name": "RingFilterBasis.mul_right", "code": "theorem mul_right (x\u2080 : R) {U : Set R} (hU : U \u2208 B) : \u2203 V \u2208 B, V \u2286 (fun x \u21a6 x * x\u2080) \u207b\u00b9' U", "start": [295, 1], "end": [296, 19], "kind": "commanddeclaration"}, {"full_name": "RingFilterBasis.topology", "code": "def topology : TopologicalSpace R :=\n  B.toAddGroupFilterBasis.topology", "start": [299, 1], "end": [302, 35], "kind": "commanddeclaration"}, {"full_name": "RingFilterBasis.isTopologicalRing", "code": "instance (priority := 100) isTopologicalRing {R : Type u} [Ring R] (B : RingFilterBasis R) :\n    @TopologicalRing R B.topology _ := by\n  let B' := B.toAddGroupFilterBasis\n  letI := B'.topology\n  have basis := B'.nhds_zero_hasBasis\n  have basis' := basis.prod basis\n  haveI := B'.isTopologicalAddGroup\n  apply TopologicalRing.of_addGroup_of_nhds_zero\n  \u00b7 rw [basis'.tendsto_iff basis]\n    suffices \u2200 U \u2208 B', \u2203 V W, (V \u2208 B' \u2227 W \u2208 B') \u2227 \u2200 a b, a \u2208 V \u2192 b \u2208 W \u2192 a * b \u2208 U by simpa\n    intro U U_in\n    rcases B.mul U_in with \u27e8V, V_in, hV\u27e9\n    refine' \u27e8V, V, \u27e8V_in, V_in\u27e9, _\u27e9\n    intro a b a_in b_in\n    exact hV \u27e8a, b, a_in, b_in, rfl\u27e9\n  \u00b7 intro x\u2080\n    rw [basis.tendsto_iff basis]\n    intro U\n    simpa using B.mul_left x\u2080\n  \u00b7 intro x\u2080\n    rw [basis.tendsto_iff basis]\n    intro U\n    simpa using B.mul_right x\u2080", "start": [305, 1], "end": [329, 31], "kind": "commanddeclaration"}, {"full_name": "ModuleFilterBasis", "code": "structure ModuleFilterBasis (R M : Type*) [CommRing R] [TopologicalSpace R] [AddCommGroup M]\n  [Module R M] extends AddGroupFilterBasis M where\n  smul' : \u2200 {U}, U \u2208 sets \u2192 \u2203 V \u2208 \ud835\udcdd (0 : R), \u2203 W \u2208 sets, V \u2022 W \u2286 U\n  smul_left' : \u2200 (x\u2080 : R) {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V \u2286 (fun x \u21a6 x\u2080 \u2022 x) \u207b\u00b9' U\n  smul_right' : \u2200 (m\u2080 : M) {U}, U \u2208 sets \u2192 \u2200\u1da0 x in \ud835\udcdd (0 : R), x \u2022 m\u2080 \u2208 U", "start": [334, 1], "end": [342, 73], "kind": "commanddeclaration"}, {"full_name": "ModuleFilterBasis.GroupFilterBasis.hasMem", "code": "instance GroupFilterBasis.hasMem : Membership (Set M) (ModuleFilterBasis R M) :=\n  \u27e8fun s B \u21a6 s \u2208 B.sets\u27e9", "start": [350, 1], "end": [351, 25], "kind": "commanddeclaration"}, {"full_name": "ModuleFilterBasis.smul", "code": "theorem smul {U : Set M} (hU : U \u2208 B) : \u2203 V \u2208 \ud835\udcdd (0 : R), \u2203 W \u2208 B, V \u2022 W \u2286 U", "start": [354, 1], "end": [355, 13], "kind": "commanddeclaration"}, {"full_name": "ModuleFilterBasis.smul_left", "code": "theorem smul_left (x\u2080 : R) {U : Set M} (hU : U \u2208 B) : \u2203 V \u2208 B, V \u2286 (fun x \u21a6 x\u2080 \u2022 x) \u207b\u00b9' U", "start": [358, 1], "end": [359, 21], "kind": "commanddeclaration"}, {"full_name": "ModuleFilterBasis.smul_right", "code": "theorem smul_right (m\u2080 : M) {U : Set M} (hU : U \u2208 B) : \u2200\u1da0 x in \ud835\udcdd (0 : R), x \u2022 m\u2080 \u2208 U", "start": [362, 1], "end": [363, 22], "kind": "commanddeclaration"}, {"full_name": "ModuleFilterBasis.topology", "code": "def topology : TopologicalSpace M :=\n  B.toAddGroupFilterBasis.topology", "start": [387, 1], "end": [390, 35], "kind": "commanddeclaration"}, {"full_name": "ModuleFilterBasis.topology'", "code": "def topology' {R M : Type*} [CommRing R] {_ : TopologicalSpace R} [AddCommGroup M] [Module R M]\n    (B : ModuleFilterBasis R M) : TopologicalSpace M :=\n  B.toAddGroupFilterBasis.topology", "start": [393, 1], "end": [398, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousSMul.of_basis_zero", "code": "theorem _root_.ContinuousSMul.of_basis_zero {\u03b9 : Type*} [TopologicalRing R] [TopologicalSpace M]\n    [TopologicalAddGroup M] {p : \u03b9 \u2192 Prop} {b : \u03b9 \u2192 Set M} (h : HasBasis (\ud835\udcdd 0) p b)\n    (hsmul : \u2200 {i}, p i \u2192 \u2203 V \u2208 \ud835\udcdd (0 : R), \u2203 (j : _) (_ : p j), V \u2022 b j \u2286 b i)\n    (hsmul_left : \u2200 (x\u2080 : R) {i}, p i \u2192 \u2203 (j : _) (_ : p j), b j \u2286 (fun x \u21a6 x\u2080 \u2022 x) \u207b\u00b9' b i)\n    (hsmul_right : \u2200 (m\u2080 : M) {i}, p i \u2192 \u2200\u1da0 x in \ud835\udcdd (0 : R), x \u2022 m\u2080 \u2208 b i) : ContinuousSMul R M", "start": [401, 1], "end": [430, 48], "kind": "commanddeclaration"}, {"full_name": "ModuleFilterBasis.continuousSMul", "code": "instance (priority := 100) continuousSMul [TopologicalRing R] :\n    @ContinuousSMul R M _ _ B.topology := by\n  let B' := B.toAddGroupFilterBasis\n  let _ := B'.topology\n  have _ := B'.isTopologicalAddGroup\n  exact ContinuousSMul.of_basis_zero B'.nhds_zero_hasBasis\n      (fun {_} => by simpa using B.smul)\n      (by simpa using B.smul_left) B.smul_right", "start": [433, 1], "end": [442, 48], "kind": "commanddeclaration"}, {"full_name": "ModuleFilterBasis.ofBases", "code": "def ofBases {R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (BR : RingFilterBasis R)\n    (BM : AddGroupFilterBasis M) (smul : \u2200 {U}, U \u2208 BM \u2192 \u2203 V \u2208 BR, \u2203 W \u2208 BM, V \u2022 W \u2286 U)\n    (smul_left : \u2200 (x\u2080 : R) {U}, U \u2208 BM \u2192 \u2203 V \u2208 BM, V \u2286 (fun x \u21a6 x\u2080 \u2022 x) \u207b\u00b9' U)\n    (smul_right : \u2200 (m\u2080 : M) {U}, U \u2208 BM \u2192 \u2203 V \u2208 BR, V \u2286 (fun x \u21a6 x \u2022 m\u2080) \u207b\u00b9' U) :\n    @ModuleFilterBasis R M _ BR.topology _ _ :=\n  let _ := BR.topology\n  { BM with\n    smul' := by\n      intro U U_in\n      rcases smul U_in with \u27e8V, V_in, W, W_in, H\u27e9\n      exact \u27e8V, BR.toAddGroupFilterBasis.mem_nhds_zero V_in, W, W_in, H\u27e9\n    smul_left' := smul_left\n    smul_right' := by\n      intro m\u2080 U U_in\n      rcases smul_right m\u2080 U_in with \u27e8V, V_in, H\u27e9\n      exact mem_of_superset (BR.toAddGroupFilterBasis.mem_nhds_zero V_in) H }", "start": [445, 1], "end": [461, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/LocallyConvex/Bounded.lean", "imports": ["Mathlib/Analysis/LocallyConvex/Basic.lean", "Mathlib/Topology/Algebra/UniformGroup.lean", "Mathlib/Topology/Bornology/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Seminorm.lean", "Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean", "Mathlib/Topology/UniformSpace/Cauchy.lean"], "premises": [{"full_name": "Bornology.IsVonNBounded", "code": "def IsVonNBounded (s : Set E) : Prop :=\n  \u2200 \u2983V\u2984, V \u2208 \ud835\udcdd (0 : E) \u2192 Absorbs \ud835\udd5c V s", "start": [64, 1], "end": [66, 39], "kind": "commanddeclaration"}, {"full_name": "Bornology.isVonNBounded_empty", "code": "@[simp]\ntheorem isVonNBounded_empty : IsVonNBounded \ud835\udd5c (\u2205 : Set E)", "start": [71, 1], "end": [72, 86], "kind": "commanddeclaration"}, {"full_name": "Bornology.isVonNBounded_iff", "code": "theorem isVonNBounded_iff (s : Set E) : IsVonNBounded \ud835\udd5c s \u2194 \u2200 V \u2208 \ud835\udcdd (0 : E), Absorbs \ud835\udd5c V s", "start": [77, 1], "end": [78, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.isVonNBounded_basis_iff", "code": "theorem _root_.Filter.HasBasis.isVonNBounded_basis_iff {q : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set E} {A : Set E}\n    (h : (\ud835\udcdd (0 : E)).HasBasis q s) : IsVonNBounded \ud835\udd5c A \u2194 \u2200 (i) (_ : q i), Absorbs \ud835\udd5c (s i) A", "start": [81, 1], "end": [85, 31], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsVonNBounded.subset", "code": "theorem IsVonNBounded.subset {s\u2081 s\u2082 : Set E} (h : s\u2081 \u2286 s\u2082) (hs\u2082 : IsVonNBounded \ud835\udd5c s\u2082) :\n    IsVonNBounded \ud835\udd5c s\u2081", "start": [88, 1], "end": [90, 60], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsVonNBounded.union", "code": "theorem IsVonNBounded.union {s\u2081 s\u2082 : Set E} (hs\u2081 : IsVonNBounded \ud835\udd5c s\u2081) (hs\u2082 : IsVonNBounded \ud835\udd5c s\u2082) :\n    IsVonNBounded \ud835\udd5c (s\u2081 \u222a s\u2082)", "start": [93, 1], "end": [95, 69], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsVonNBounded.of_topologicalSpace_le", "code": "theorem IsVonNBounded.of_topologicalSpace_le {t t' : TopologicalSpace E} (h : t \u2264 t') {s : Set E}\n    (hs : @IsVonNBounded \ud835\udd5c E _ _ _ t s) : @IsVonNBounded \ud835\udd5c E _ _ _ t' s", "start": [106, 1], "end": [110, 37], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsVonNBounded.image", "code": "theorem IsVonNBounded.image {\u03c3 : \ud835\udd5c\u2081 \u2192+* \ud835\udd5c\u2082} [RingHomSurjective \u03c3] [RingHomIsometric \u03c3] {s : Set E}\n    (hs : IsVonNBounded \ud835\udd5c\u2081 s) (f : E \u2192SL[\u03c3] F) : IsVonNBounded \ud835\udd5c\u2082 (f '' s)", "start": [120, 1], "end": [137, 54], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsVonNBounded.smul_tendsto_zero", "code": "theorem IsVonNBounded.smul_tendsto_zero {S : Set E} {\u03b5 : \u03b9 \u2192 \ud835\udd5c} {x : \u03b9 \u2192 E} {l : Filter \u03b9}\n    (hS : IsVonNBounded \ud835\udd5c S) (hxS : \u2200\u1da0 n in l, x n \u2208 S) (h\u03b5 : Tendsto \u03b5 l (\ud835\udcdd 0)) :\n    Tendsto (\u03b5 \u2022 x) l (\ud835\udcdd 0)", "start": [147, 1], "end": [158, 27], "kind": "commanddeclaration"}, {"full_name": "Bornology.isVonNBounded_of_smul_tendsto_zero", "code": "theorem isVonNBounded_of_smul_tendsto_zero {\u03b5 : \u03b9 \u2192 \ud835\udd5d} {l : Filter \u03b9} [l.NeBot]\n    (h\u03b5 : \u2200\u1da0 n in l, \u03b5 n \u2260 0) {S : Set E}\n    (H : \u2200 x : \u03b9 \u2192 E, (\u2200 n, x n \u2208 S) \u2192 Tendsto (\u03b5 \u2022 x) l (\ud835\udcdd 0)) : IsVonNBounded \ud835\udd5d S", "start": [161, 1], "end": [179, 91], "kind": "commanddeclaration"}, {"full_name": "Bornology.isVonNBounded_iff_smul_tendsto_zero", "code": "theorem isVonNBounded_iff_smul_tendsto_zero {\u03b5 : \u03b9 \u2192 \ud835\udd5d} {l : Filter \u03b9} [l.NeBot]\n    (h\u03b5 : Tendsto \u03b5 l (\ud835\udcdd[\u2260] 0)) {S : Set E} :\n    IsVonNBounded \ud835\udd5d S \u2194 \u2200 x : \u03b9 \u2192 E, (\u2200 n, x n \u2208 S) \u2192 Tendsto (\u03b5 \u2022 x) l (\ud835\udcdd 0)", "start": [182, 1], "end": [190, 74], "kind": "commanddeclaration"}, {"full_name": "Bornology.isVonNBounded_singleton", "code": "theorem isVonNBounded_singleton (x : E) : IsVonNBounded \ud835\udd5c ({x} : Set E)", "start": [201, 1], "end": [203, 35], "kind": "commanddeclaration"}, {"full_name": "Bornology.isVonNBounded_covers", "code": "theorem isVonNBounded_covers : \u22c3\u2080 setOf (IsVonNBounded \ud835\udd5c) = (Set.univ : Set E)", "start": [206, 1], "end": [209, 77], "kind": "commanddeclaration"}, {"full_name": "Bornology.vonNBornology", "code": "@[reducible]\ndef vonNBornology : Bornology E :=\n  Bornology.ofBounded (setOf (IsVonNBounded \ud835\udd5c)) (isVonNBounded_empty \ud835\udd5c E)\n    (fun _ hs _ ht => hs.subset ht) (fun _ hs _ => hs.union) isVonNBounded_singleton", "start": [215, 1], "end": [222, 85], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_iff_isVonNBounded", "code": "@[simp]\ntheorem isBounded_iff_isVonNBounded {s : Set E} :\n    @IsBounded _ (vonNBornology \ud835\udd5c E) s \u2194 IsVonNBounded \ud835\udd5c s", "start": [227, 1], "end": [230, 28], "kind": "commanddeclaration"}, {"full_name": "TotallyBounded.isVonNBounded", "code": "theorem TotallyBounded.isVonNBounded {s : Set E} (hs : TotallyBounded s) :\n    Bornology.IsVonNBounded \ud835\udd5c s", "start": [243, 1], "end": [263, 69], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.isVonNBounded_ball", "code": "theorem isVonNBounded_ball (r : \u211d) : Bornology.IsVonNBounded \ud835\udd5c (Metric.ball (0 : E) r)", "start": [274, 1], "end": [276, 70], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.isVonNBounded_closedBall", "code": "theorem isVonNBounded_closedBall (r : \u211d) :\n    Bornology.IsVonNBounded \ud835\udd5c (Metric.closedBall (0 : E) r)", "start": [279, 1], "end": [281, 89], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.isVonNBounded_iff", "code": "theorem isVonNBounded_iff (s : Set E) : Bornology.IsVonNBounded \ud835\udd5c s \u2194 Bornology.IsBounded s", "start": [284, 1], "end": [294, 68], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.isVonNBounded_iff'", "code": "theorem isVonNBounded_iff' (s : Set E) :\n    Bornology.IsVonNBounded \ud835\udd5c s \u2194 \u2203 r : \u211d, \u2200 (x : E) (_ : x \u2208 s), \u2016x\u2016 \u2264 r", "start": [297, 1], "end": [299, 67], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.image_isVonNBounded_iff", "code": "theorem image_isVonNBounded_iff (f : E' \u2192 E) (s : Set E') :\n    Bornology.IsVonNBounded \ud835\udd5c (f '' s) \u2194 \u2203 r : \u211d, \u2200 (x : E') (_ : x \u2208 s), \u2016f x\u2016 \u2264 r", "start": [302, 1], "end": [304, 51], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.vonNBornology_eq", "code": "theorem vonNBornology_eq : Bornology.vonNBornology \ud835\udd5c E = PseudoMetricSpace.toBornology", "start": [307, 1], "end": [313, 32], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.isBounded_iff_subset_smul_ball", "code": "theorem isBounded_iff_subset_smul_ball {s : Set E} :\n    Bornology.IsBounded s \u2194 \u2203 a : \ud835\udd5c, s \u2286 a \u2022 Metric.ball (0 : E) 1", "start": [316, 1], "end": [325, 77], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.isBounded_iff_subset_smul_closedBall", "code": "theorem isBounded_iff_subset_smul_closedBall {s : Set E} :\n    Bornology.IsBounded s \u2194 \u2203 a : \ud835\udd5c, s \u2286 a \u2022 Metric.closedBall (0 : E) 1", "start": [328, 1], "end": [335, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Strict.lean", "imports": ["Mathlib/Topology/Algebra/Order/Group.lean", "Mathlib/Analysis/Convex/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "StrictConvex", "code": "def StrictConvex : Prop :=\n  s.Pairwise fun x y => \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 a \u2022 x + b \u2022 y \u2208 interior s", "start": [43, 1], "end": [46, 92], "kind": "commanddeclaration"}, {"full_name": "strictConvex_iff_openSegment_subset", "code": "theorem strictConvex_iff_openSegment_subset :\n    StrictConvex \ud835\udd5c s \u2194 s.Pairwise fun x y => openSegment \ud835\udd5c x y \u2286 interior s", "start": [52, 1], "end": [54, 65], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.openSegment_subset", "code": "theorem StrictConvex.openSegment_subset (hs : StrictConvex \ud835\udd5c s) (hx : x \u2208 s) (hy : y \u2208 s)\n    (h : x \u2260 y) : openSegment \ud835\udd5c x y \u2286 interior s", "start": [57, 1], "end": [59, 51], "kind": "commanddeclaration"}, {"full_name": "strictConvex_empty", "code": "theorem strictConvex_empty : StrictConvex \ud835\udd5c (\u2205 : Set E)", "start": [62, 1], "end": [63, 19], "kind": "commanddeclaration"}, {"full_name": "strictConvex_univ", "code": "theorem strictConvex_univ : StrictConvex \ud835\udd5c (univ : Set E)", "start": [66, 1], "end": [69, 19], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.eq", "code": "protected nonrec theorem StrictConvex.eq (hs : StrictConvex \ud835\udd5c s) (hx : x \u2208 s) (hy : y \u2208 s)\n    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) (h : a \u2022 x + b \u2022 y \u2209 interior s) : x = y", "start": [72, 1], "end": [74, 40], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.inter", "code": "protected theorem StrictConvex.inter {t : Set E} (hs : StrictConvex \ud835\udd5c s) (ht : StrictConvex \ud835\udd5c t) :\n    StrictConvex \ud835\udd5c (s \u2229 t)", "start": [77, 1], "end": [81, 65], "kind": "commanddeclaration"}, {"full_name": "Directed.strictConvex_iUnion", "code": "theorem Directed.strictConvex_iUnion {\u03b9 : Sort*} {s : \u03b9 \u2192 Set E} (hdir : Directed (\u00b7 \u2286 \u00b7) s)\n    (hs : \u2200 \u2983i : \u03b9\u2984, StrictConvex \ud835\udd5c (s i)) : StrictConvex \ud835\udd5c (\u22c3 i, s i)", "start": [84, 1], "end": [91, 79], "kind": "commanddeclaration"}, {"full_name": "DirectedOn.strictConvex_sUnion", "code": "theorem DirectedOn.strictConvex_sUnion {S : Set (Set E)} (hdir : DirectedOn (\u00b7 \u2286 \u00b7) S)\n    (hS : \u2200 s \u2208 S, StrictConvex \ud835\udd5c s) : StrictConvex \ud835\udd5c (\u22c3\u2080 S)", "start": [94, 1], "end": [97, 79], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.convex", "code": "protected theorem StrictConvex.convex (hs : StrictConvex \ud835\udd5c s) : Convex \ud835\udd5c s", "start": [106, 1], "end": [108, 46], "kind": "commanddeclaration"}, {"full_name": "Convex.strictConvex_of_open", "code": "protected theorem Convex.strictConvex_of_open (h : IsOpen s) (hs : Convex \ud835\udd5c s) : StrictConvex \ud835\udd5c s", "start": [111, 1], "end": [113, 81], "kind": "commanddeclaration"}, {"full_name": "IsOpen.strictConvex_iff", "code": "theorem IsOpen.strictConvex_iff (h : IsOpen s) : StrictConvex \ud835\udd5c s \u2194 Convex \ud835\udd5c s", "start": [116, 1], "end": [117, 55], "kind": "commanddeclaration"}, {"full_name": "strictConvex_singleton", "code": "theorem strictConvex_singleton (c : E) : StrictConvex \ud835\udd5c ({c} : Set E)", "start": [120, 1], "end": [121, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.strictConvex", "code": "theorem Set.Subsingleton.strictConvex (hs : s.Subsingleton) : StrictConvex \ud835\udd5c s", "start": [124, 1], "end": [125, 16], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.linear_image", "code": "theorem StrictConvex.linear_image [Semiring \ud835\udd5d] [Module \ud835\udd5d E] [Module \ud835\udd5d F]\n    [LinearMap.CompatibleSMul E F \ud835\udd5c \ud835\udd5d] (hs : StrictConvex \ud835\udd5c s) (f : E \u2192\u2097[\ud835\udd5d] F) (hf : IsOpenMap f) :\n    StrictConvex \ud835\udd5c (f '' s)", "start": [128, 1], "end": [133, 61], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.is_linear_image", "code": "theorem StrictConvex.is_linear_image (hs : StrictConvex \ud835\udd5c s) {f : E \u2192 F} (h : IsLinearMap \ud835\udd5c f)\n    (hf : IsOpenMap f) : StrictConvex \ud835\udd5c (f '' s)", "start": [136, 1], "end": [138, 31], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.linear_preimage", "code": "theorem StrictConvex.linear_preimage {s : Set F} (hs : StrictConvex \ud835\udd5c s) (f : E \u2192\u2097[\ud835\udd5c] F)\n    (hf : Continuous f) (hfinj : Injective f) : StrictConvex \ud835\udd5c (s.preimage f)", "start": [141, 1], "end": [146, 42], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.is_linear_preimage", "code": "theorem StrictConvex.is_linear_preimage {s : Set F} (hs : StrictConvex \ud835\udd5c s) {f : E \u2192 F}\n    (h : IsLinearMap \ud835\udd5c f) (hf : Continuous f) (hfinj : Injective f) :\n    StrictConvex \ud835\udd5c (s.preimage f)", "start": [149, 1], "end": [152, 40], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.strictConvex", "code": "protected theorem Set.OrdConnected.strictConvex {s : Set \u03b2} (hs : OrdConnected s) :\n    StrictConvex \ud835\udd5c s", "start": [160, 1], "end": [166, 90], "kind": "commanddeclaration"}, {"full_name": "strictConvex_Iic", "code": "theorem strictConvex_Iic (r : \u03b2) : StrictConvex \ud835\udd5c (Iic r)", "start": [169, 1], "end": [170, 32], "kind": "commanddeclaration"}, {"full_name": "strictConvex_Ici", "code": "theorem strictConvex_Ici (r : \u03b2) : StrictConvex \ud835\udd5c (Ici r)", "start": [173, 1], "end": [174, 32], "kind": "commanddeclaration"}, {"full_name": "strictConvex_Iio", "code": "theorem strictConvex_Iio (r : \u03b2) : StrictConvex \ud835\udd5c (Iio r)", "start": [177, 1], "end": [178, 32], "kind": "commanddeclaration"}, {"full_name": "strictConvex_Ioi", "code": "theorem strictConvex_Ioi (r : \u03b2) : StrictConvex \ud835\udd5c (Ioi r)", "start": [181, 1], "end": [182, 32], "kind": "commanddeclaration"}, {"full_name": "strictConvex_Icc", "code": "theorem strictConvex_Icc (r s : \u03b2) : StrictConvex \ud835\udd5c (Icc r s)", "start": [185, 1], "end": [186, 32], "kind": "commanddeclaration"}, {"full_name": "strictConvex_Ioo", "code": "theorem strictConvex_Ioo (r s : \u03b2) : StrictConvex \ud835\udd5c (Ioo r s)", "start": [189, 1], "end": [190, 32], "kind": "commanddeclaration"}, {"full_name": "strictConvex_Ico", "code": "theorem strictConvex_Ico (r s : \u03b2) : StrictConvex \ud835\udd5c (Ico r s)", "start": [193, 1], "end": [194, 32], "kind": "commanddeclaration"}, {"full_name": "strictConvex_Ioc", "code": "theorem strictConvex_Ioc (r s : \u03b2) : StrictConvex \ud835\udd5c (Ioc r s)", "start": [197, 1], "end": [198, 32], "kind": "commanddeclaration"}, {"full_name": "strictConvex_uIcc", "code": "theorem strictConvex_uIcc (r s : \u03b2) : StrictConvex \ud835\udd5c (uIcc r s)", "start": [201, 1], "end": [202, 23], "kind": "commanddeclaration"}, {"full_name": "strictConvex_uIoc", "code": "theorem strictConvex_uIoc (r s : \u03b2) : StrictConvex \ud835\udd5c (uIoc r s)", "start": [205, 1], "end": [206, 23], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.preimage_add_right", "code": "theorem StrictConvex.preimage_add_right (hs : StrictConvex \ud835\udd5c s) (z : E) :\n    StrictConvex \ud835\udd5c ((fun x => z + x) \u207b\u00b9' s)", "start": [219, 1], "end": [225, 84], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.preimage_add_left", "code": "theorem StrictConvex.preimage_add_left (hs : StrictConvex \ud835\udd5c s) (z : E) :\n    StrictConvex \ud835\udd5c ((fun x => x + z) \u207b\u00b9' s)", "start": [228, 1], "end": [231, 54], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.add", "code": "theorem StrictConvex.add (hs : StrictConvex \ud835\udd5c s) (ht : StrictConvex \ud835\udd5c t) :\n    StrictConvex \ud835\udd5c (s + t)", "start": [244, 1], "end": [256, 80], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.add_left", "code": "theorem StrictConvex.add_left (hs : StrictConvex \ud835\udd5c s) (z : E) :\n    StrictConvex \ud835\udd5c ((fun x => z + x) '' s)", "start": [259, 1], "end": [261, 69], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.add_right", "code": "theorem StrictConvex.add_right (hs : StrictConvex \ud835\udd5c s) (z : E) :\n    StrictConvex \ud835\udd5c ((fun x => x + z) '' s)", "start": [264, 1], "end": [265, 91], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.vadd", "code": "theorem StrictConvex.vadd (hs : StrictConvex \ud835\udd5c s) (x : E) : StrictConvex \ud835\udd5c (x +\u1d65 s)", "start": [268, 1], "end": [270, 16], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.smul", "code": "theorem StrictConvex.smul (hs : StrictConvex \ud835\udd5c s) (c : \ud835\udd5d) : StrictConvex \ud835\udd5c (c \u2022 s)", "start": [280, 1], "end": [283, 71], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.affinity", "code": "theorem StrictConvex.affinity [ContinuousAdd E] (hs : StrictConvex \ud835\udd5c s) (z : E) (c : \ud835\udd5d) :\n    StrictConvex \ud835\udd5c (z +\u1d65 c \u2022 s)", "start": [286, 1], "end": [288, 21], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.preimage_smul", "code": "theorem StrictConvex.preimage_smul (hs : StrictConvex \ud835\udd5c s) (c : \ud835\udd5c) :\n    StrictConvex \ud835\udd5c ((fun z => c \u2022 z) \u207b\u00b9' s)", "start": [306, 1], "end": [316, 34], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.eq_of_openSegment_subset_frontier", "code": "theorem StrictConvex.eq_of_openSegment_subset_frontier [Nontrivial \ud835\udd5c] [DenselyOrdered \ud835\udd5c]\n    (hs : StrictConvex \ud835\udd5c s) (hx : x \u2208 s) (hy : y \u2208 s) (h : openSegment \ud835\udd5c x y \u2286 frontier s) :\n    x = y", "start": [331, 1], "end": [339, 76], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.add_smul_mem", "code": "theorem StrictConvex.add_smul_mem (hs : StrictConvex \ud835\udd5c s) (hx : x \u2208 s) (hxy : x + y \u2208 s)\n    (hy : y \u2260 0) {t : \ud835\udd5c} (ht\u2080 : 0 < t) (ht\u2081 : t < 1) : x + t \u2022 y \u2208 interior s", "start": [342, 1], "end": [348, 21], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.smul_mem_of_zero_mem", "code": "theorem StrictConvex.smul_mem_of_zero_mem (hs : StrictConvex \ud835\udd5c s) (zero_mem : (0 : E) \u2208 s)\n    (hx : x \u2208 s) (hx\u2080 : x \u2260 0) {t : \ud835\udd5c} (ht\u2080 : 0 < t) (ht\u2081 : t < 1) : t \u2022 x \u2208 interior s", "start": [351, 1], "end": [353, 71], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.add_smul_sub_mem", "code": "theorem StrictConvex.add_smul_sub_mem (h : StrictConvex \ud835\udd5c s) (hx : x \u2208 s) (hy : y \u2208 s) (hxy : x \u2260 y)\n    {t : \ud835\udd5c} (ht\u2080 : 0 < t) (ht\u2081 : t < 1) : x + t \u2022 (y - x) \u2208 interior s", "start": [356, 1], "end": [360, 38], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.affine_preimage", "code": "theorem StrictConvex.affine_preimage {s : Set F} (hs : StrictConvex \ud835\udd5c s) {f : E \u2192\u1d43[\ud835\udd5c] F}\n    (hf : Continuous f) (hfinj : Injective f) : StrictConvex \ud835\udd5c (f \u207b\u00b9' s)", "start": [363, 1], "end": [369, 42], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.affine_image", "code": "theorem StrictConvex.affine_image (hs : StrictConvex \ud835\udd5c s) {f : E \u2192\u1d43[\ud835\udd5c] F} (hf : IsOpenMap f) :\n    StrictConvex \ud835\udd5c (f '' s)", "start": [372, 1], "end": [378, 98], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.neg", "code": "theorem StrictConvex.neg (hs : StrictConvex \ud835\udd5c s) : StrictConvex \ud835\udd5c (-s)", "start": [383, 1], "end": [384, 84], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.sub", "code": "theorem StrictConvex.sub (hs : StrictConvex \ud835\udd5c s) (ht : StrictConvex \ud835\udd5c t) : StrictConvex \ud835\udd5c (s - t)", "start": [387, 1], "end": [388, 44], "kind": "commanddeclaration"}, {"full_name": "strictConvex_iff_div", "code": "theorem strictConvex_iff_div :\n    StrictConvex \ud835\udd5c s \u2194\n      s.Pairwise fun x y =>\n        \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 (a / (a + b)) \u2022 x + (b / (a + b)) \u2022 y \u2208 interior s", "start": [403, 1], "end": [412, 53], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.mem_smul_of_zero_mem", "code": "theorem StrictConvex.mem_smul_of_zero_mem (hs : StrictConvex \ud835\udd5c s) (zero_mem : (0 : E) \u2208 s)\n    (hx : x \u2208 s) (hx\u2080 : x \u2260 0) {t : \ud835\udd5c} (ht : 1 < t) : x \u2208 t \u2022 interior s", "start": [415, 1], "end": [418, 100], "kind": "commanddeclaration"}, {"full_name": "strictConvex_iff_convex", "code": "@[simp]\ntheorem strictConvex_iff_convex : StrictConvex \ud835\udd5c s \u2194 Convex \ud835\udd5c s", "start": [436, 1], "end": [439, 64], "kind": "commanddeclaration"}, {"full_name": "strictConvex_iff_ordConnected", "code": "theorem strictConvex_iff_ordConnected : StrictConvex \ud835\udd5c s \u2194 s.OrdConnected", "start": [442, 1], "end": [443, 56], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.ordConnected", "code": "alias \u27e8StrictConvex.ordConnected, _\u27e9 := strictConvex_iff_ordConnected", "start": [446, 1], "end": [446, 70], "kind": "stdtacticaliasaliaslr"}]}
{"path": "Mathlib/Analysis/Convex/Combination.lean", "imports": ["Mathlib/LinearAlgebra/AffineSpace/Basis.lean", "Mathlib/Analysis/Convex/Hull.lean", "Mathlib/Algebra/BigOperators/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.centerMass", "code": "def Finset.centerMass (t : Finset \u03b9) (w : \u03b9 \u2192 R) (z : \u03b9 \u2192 E) : E :=\n  (\u2211 i in t, w i)\u207b\u00b9 \u2022 \u2211 i in t, w i \u2022 z i", "start": [39, 1], "end": [42, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_empty", "code": "theorem Finset.centerMass_empty : (\u2205 : Finset \u03b9).centerMass w z = 0", "start": [49, 1], "end": [50, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_pair", "code": "theorem Finset.centerMass_pair (hne : i \u2260 j) :\n    ({i, j} : Finset \u03b9).centerMass w z = (w i / (w i + w j)) \u2022 z i + (w j / (w i + w j)) \u2022 z j", "start": [53, 1], "end": [55, 88], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_insert", "code": "theorem Finset.centerMass_insert (ha : i \u2209 t) (hw : \u2211 j in t, w j \u2260 0) :\n    (insert i t).centerMass w z =\n      (w i / (w i + \u2211 j in t, w j)) \u2022 z i +\n        ((\u2211 j in t, w j) / (w i + \u2211 j in t, w j)) \u2022 t.centerMass w z", "start": [60, 1], "end": [66, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_singleton", "code": "theorem Finset.centerMass_singleton (hw : w i \u2260 0) : ({i} : Finset \u03b9).centerMass w z = z i", "start": [69, 1], "end": [70, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_neg_left", "code": "@[simp] lemma Finset.centerMass_neg_left : t.centerMass (-w) z = t.centerMass w z := by\n  simp [centerMass, inv_neg]", "start": [73, 1], "end": [74, 29], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.centerMass_smul_left", "code": "lemma Finset.centerMass_smul_left {c : R'} [Module R' R] [Module R' E] [SMulCommClass R' R R]\n    [IsScalarTower R' R R] [SMulCommClass R R' E] [IsScalarTower R' R E] (hc : c \u2260 0) :\n    t.centerMass (c \u2022 w) z = t.centerMass w z := by\n  simp [centerMass, -smul_assoc, smul_assoc c, \u2190smul_sum, smul_inv\u2080, smul_smul_smul_comm, hc]", "start": [76, 1], "end": [79, 94], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.centerMass_eq_of_sum_1", "code": "theorem Finset.centerMass_eq_of_sum_1 (hw : \u2211 i in t, w i = 1) :\n    t.centerMass w z = \u2211 i in t, w i \u2022 z i", "start": [81, 1], "end": [83, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_smul", "code": "theorem Finset.centerMass_smul : (t.centerMass w fun i => c \u2022 z i) = c \u2022 t.centerMass w z", "start": [86, 1], "end": [87, 95], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_segment'", "code": "theorem Finset.centerMass_segment' (s : Finset \u03b9) (t : Finset \u03b9') (ws : \u03b9 \u2192 R) (zs : \u03b9 \u2192 E)\n    (wt : \u03b9' \u2192 R) (zt : \u03b9' \u2192 E) (hws : \u2211 i in s, ws i = 1) (hwt : \u2211 i in t, wt i = 1) (a b : R)\n    (hab : a + b = 1) : a \u2022 s.centerMass ws zs + b \u2022 t.centerMass wt zt = (s.disjSum t).centerMass\n    (Sum.elim (fun i => a * ws i) fun j => b * wt j) (Sum.elim zs zt)", "start": [90, 1], "end": [99, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_segment", "code": "theorem Finset.centerMass_segment (s : Finset \u03b9) (w\u2081 w\u2082 : \u03b9 \u2192 R) (z : \u03b9 \u2192 E)\n    (hw\u2081 : \u2211 i in s, w\u2081 i = 1) (hw\u2082 : \u2211 i in s, w\u2082 i = 1) (a b : R) (hab : a + b = 1) :\n    a \u2022 s.centerMass w\u2081 z + b \u2022 s.centerMass w\u2082 z =\n    s.centerMass (fun i => a * w\u2081 i + b * w\u2082 i) z", "start": [102, 1], "end": [111, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_ite_eq", "code": "theorem Finset.centerMass_ite_eq (hi : i \u2208 t) :\n    t.centerMass (fun j => if i = j then (1 : R) else 0) z = z i", "start": [114, 1], "end": [122, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_subset", "code": "theorem Finset.centerMass_subset {t' : Finset \u03b9} (ht : t \u2286 t') (h : \u2200 i \u2208 t', i \u2209 t \u2192 w i = 0) :\n    t.centerMass w z = t'.centerMass w z", "start": [127, 1], "end": [132, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_filter_ne_zero", "code": "theorem Finset.centerMass_filter_ne_zero :\n    (t.filter fun i => w i \u2260 0).centerMass w z = t.centerMass w z", "start": [135, 1], "end": [138, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_le_sup", "code": "theorem centerMass_le_sup {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {w : \u03b9 \u2192 R} (hw\u2080 : \u2200 i \u2208 s, 0 \u2264 w i)\n    (hw\u2081 : 0 < \u2211 i in s, w i) :\n    s.centerMass w f \u2264 s.sup' (nonempty_of_ne_empty <| by rintro rfl; simp at hw\u2081) f", "start": [143, 1], "end": [147, 81], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_le_centerMass", "code": "theorem inf_le_centerMass {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} {w : \u03b9 \u2192 R} (hw\u2080 : \u2200 i \u2208 s, 0 \u2264 w i)\n    (hw\u2081 : 0 < \u2211 i in s, w i) :\n    s.inf' (nonempty_of_ne_empty <| by rintro rfl; simp at hw\u2081) f \u2264 s.centerMass w f", "start": [150, 1], "end": [153, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_of_sum_add_sum_eq_zero", "code": "lemma Finset.centerMass_of_sum_add_sum_eq_zero {s t : Finset \u03b9}\n    (hw : \u2211 i in s, w i + \u2211 i in t, w i = 0) (hz : \u2211 i in s, w i \u2022 z i + \u2211 i in t, w i \u2022 z i = 0) :\n    s.centerMass w z = t.centerMass w z := by\n  simp [centerMass, eq_neg_of_add_eq_zero_right hw, eq_neg_of_add_eq_zero_left hz, \u2190neg_inv]", "start": [160, 1], "end": [163, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Convex.centerMass_mem", "code": "theorem Convex.centerMass_mem (hs : Convex R s) :\n    (\u2200 i \u2208 t, 0 \u2264 w i) \u2192 (0 < \u2211 i in t, w i) \u2192 (\u2200 i \u2208 t, z i \u2208 s) \u2192 t.centerMass w z \u2208 s", "start": [165, 1], "end": [187, 39], "kind": "commanddeclaration"}, {"full_name": "Convex.sum_mem", "code": "theorem Convex.sum_mem (hs : Convex R s) (h\u2080 : \u2200 i \u2208 t, 0 \u2264 w i) (h\u2081 : \u2211 i in t, w i = 1)\n    (hz : \u2200 i \u2208 t, z i \u2208 s) : (\u2211 i in t, w i \u2022 z i) \u2208 s", "start": [190, 1], "end": [193, 52], "kind": "commanddeclaration"}, {"full_name": "Convex.finsum_mem", "code": "theorem Convex.finsum_mem {\u03b9 : Sort*} {w : \u03b9 \u2192 R} {z : \u03b9 \u2192 E} {s : Set E} (hs : Convex R s)\n    (h\u2080 : \u2200 i, 0 \u2264 w i) (h\u2081 : \u2211\u1da0 i, w i = 1) (hz : \u2200 i, w i \u2260 0 \u2192 z i \u2208 s) :\n    (\u2211\u1da0 i, w i \u2022 z i) \u2208 s", "start": [196, 1], "end": [212, 36], "kind": "commanddeclaration"}, {"full_name": "convex_iff_sum_mem", "code": "theorem convex_iff_sum_mem : Convex R s \u2194 \u2200 (t : Finset E) (w : E \u2192 R),\n    (\u2200 i \u2208 t, 0 \u2264 w i) \u2192 \u2211 i in t, w i = 1 \u2192 (\u2200 x \u2208 t, x \u2208 s) \u2192 (\u2211 x in t, w x \u2022 x) \u2208 s", "start": [215, 1], "end": [231, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_mem_convexHull", "code": "theorem Finset.centerMass_mem_convexHull (t : Finset \u03b9) {w : \u03b9 \u2192 R} (hw\u2080 : \u2200 i \u2208 t, 0 \u2264 w i)\n    (hws : 0 < \u2211 i in t, w i) {z : \u03b9 \u2192 E} (hz : \u2200 i \u2208 t, z i \u2208 s) :\n    t.centerMass w z \u2208 convexHull R s", "start": [234, 1], "end": [237, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_mem_convexHull_of_nonpos", "code": "lemma Finset.centerMass_mem_convexHull_of_nonpos (t : Finset \u03b9) (hw\u2080 : \u2200 i \u2208 t, w i \u2264 0)\n    (hws : \u2211 i in t, w i < 0) (hz : \u2200 i \u2208 t, z i \u2208 s) : t.centerMass w z \u2208 convexHull R s := by\n  rw [\u2190centerMass_neg_left]\n  exact Finset.centerMass_mem_convexHull _ (\u03bb _i hi \u21a6 neg_nonneg.2 $ hw\u2080 _ hi) (by simpa) hz", "start": [240, 1], "end": [244, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.centerMass_id_mem_convexHull", "code": "theorem Finset.centerMass_id_mem_convexHull (t : Finset E) {w : E \u2192 R} (hw\u2080 : \u2200 i \u2208 t, 0 \u2264 w i)\n    (hws : 0 < \u2211 i in t, w i) : t.centerMass w id \u2208 convexHull R (t : Set E)", "start": [246, 1], "end": [250, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.centerMass_id_mem_convexHull_of_nonpos", "code": "lemma Finset.centerMass_id_mem_convexHull_of_nonpos (t : Finset E) {w : E \u2192 R}\n    (hw\u2080 : \u2200 i \u2208 t, w i \u2264 0) (hws : \u2211 i in t, w i < 0) :\n    t.centerMass w id \u2208 convexHull R (t : Set E) :=\n  t.centerMass_mem_convexHull_of_nonpos hw\u2080 hws fun _ \u21a6 mem_coe.2", "start": [253, 1], "end": [257, 66], "kind": "mathlibtacticlemma"}, {"full_name": "affineCombination_eq_centerMass", "code": "theorem affineCombination_eq_centerMass {\u03b9 : Type*} {t : Finset \u03b9} {p : \u03b9 \u2192 E} {w : \u03b9 \u2192 R}\n    (hw\u2082 : \u2211 i in t, w i = 1) : t.affineCombination R p w = centerMass t w p", "start": [259, 1], "end": [263, 34], "kind": "commanddeclaration"}, {"full_name": "affineCombination_mem_convexHull", "code": "theorem affineCombination_mem_convexHull {s : Finset \u03b9} {v : \u03b9 \u2192 E} {w : \u03b9 \u2192 R}\n    (hw\u2080 : \u2200 i \u2208 s, 0 \u2264 w i) (hw\u2081 : s.sum w = 1) :\n    s.affineCombination R v w \u2208 convexHull R (range v)", "start": [266, 1], "end": [272, 9], "kind": "commanddeclaration"}, {"full_name": "Finset.centroid_eq_centerMass", "code": "@[simp]\ntheorem Finset.centroid_eq_centerMass (s : Finset \u03b9) (hs : s.Nonempty) (p : \u03b9 \u2192 E) :\n    s.centroid R p = s.centerMass (s.centroidWeights R) p", "start": [275, 1], "end": [279, 82], "kind": "commanddeclaration"}, {"full_name": "Finset.centroid_mem_convexHull", "code": "theorem Finset.centroid_mem_convexHull (s : Finset E) (hs : s.Nonempty) :\n    s.centroid R id \u2208 convexHull R (s : Set E)", "start": [282, 1], "end": [289, 49], "kind": "commanddeclaration"}, {"full_name": "convexHull_range_eq_exists_affineCombination", "code": "theorem convexHull_range_eq_exists_affineCombination (v : \u03b9 \u2192 E) : convexHull R (range v) =\n    { x | \u2203 (s : Finset \u03b9) (w : \u03b9 \u2192 R) (_ : \u2200 i \u2208 s, 0 \u2264 w i) (_ : s.sum w = 1),\n    s.affineCombination R v w = x }", "start": [292, 1], "end": [320, 51], "kind": "commanddeclaration"}, {"full_name": "convexHull_eq", "code": "theorem convexHull_eq (s : Set E) : convexHull R s =\n    { x : E | \u2203 (\u03b9 : Type) (t : Finset \u03b9) (w : \u03b9 \u2192 R) (z : \u03b9 \u2192 E) (_ : \u2200 i \u2208 t, 0 \u2264 w i)\n    (_ : \u2211 i in t, w i = 1) (_ : \u2200 i \u2208 t, z i \u2208 s), t.centerMass w z = x }", "start": [323, 1], "end": [349, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.convexHull_eq", "code": "theorem Finset.convexHull_eq (s : Finset E) : convexHull R \u2191s =\n    { x : E | \u2203 (w : E \u2192 R) (_ : \u2200 y \u2208 s, 0 \u2264 w y) (_ : \u2211 y in s, w y = 1),\n    s.centerMass w id = x }", "start": [352, 1], "end": [371, 97], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_convexHull", "code": "theorem Finset.mem_convexHull {s : Finset E} {x : E} : x \u2208 convexHull R (s : Set E) \u2194\n    \u2203 (w : E \u2192 R) (_ : \u2200 y \u2208 s, 0 \u2264 w y) (_ : \u2211 y in s, w y = 1), s.centerMass w id = x", "start": [374, 1], "end": [376, 46], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.convexHull_eq", "code": "theorem Set.Finite.convexHull_eq {s : Set E} (hs : s.Finite) : convexHull R s =\n    { x : E | \u2203 (w : E \u2192 R) (_ : \u2200 y \u2208 s, 0 \u2264 w y) (_ : \u2211 y in hs.toFinset, w y = 1),\n    hs.toFinset.centerMass w id = x }", "start": [379, 1], "end": [383, 30], "kind": "commanddeclaration"}, {"full_name": "convexHull_eq_union_convexHull_finite_subsets", "code": "theorem convexHull_eq_union_convexHull_finite_subsets (s : Set E) :\n    convexHull R s = \u22c3 (t : Finset E) (w : \u2191t \u2286 s), convexHull R \u2191t", "start": [386, 1], "end": [399, 63], "kind": "commanddeclaration"}, {"full_name": "mk_mem_convexHull_prod", "code": "theorem mk_mem_convexHull_prod {t : Set F} {x : E} {y : F} (hx : x \u2208 convexHull R s)\n    (hy : y \u2208 convexHull R t) : (x, y) \u2208 convexHull R (s \u00d7\u02e2 t)", "start": [402, 1], "end": [441, 42], "kind": "commanddeclaration"}, {"full_name": "convexHull_prod", "code": "@[simp]\ntheorem convexHull_prod (s : Set E) (t : Set F) :\n    convexHull R (s \u00d7\u02e2 t) = convexHull R s \u00d7\u02e2 convexHull R t", "start": [444, 1], "end": [450, 62], "kind": "commanddeclaration"}, {"full_name": "convexHull_add", "code": "theorem convexHull_add (s t : Set E) : convexHull R (s + t) = convexHull R s + convexHull R t", "start": [453, 1], "end": [455, 21], "kind": "commanddeclaration"}, {"full_name": "convexHullAddMonoidHom", "code": "@[simps]\nnoncomputable def convexHullAddMonoidHom : Set E \u2192+ Set E where\n  toFun := convexHull R\n  map_add' := convexHull_add\n  map_zero' := convexHull_zero", "start": [461, 1], "end": [466, 31], "kind": "commanddeclaration"}, {"full_name": "convexHull_sub", "code": "theorem convexHull_sub (s t : Set E) : convexHull R (s - t) = convexHull R s - convexHull R t", "start": [471, 1], "end": [472, 59], "kind": "commanddeclaration"}, {"full_name": "convexHull_list_sum", "code": "theorem convexHull_list_sum (l : List (Set E)) : convexHull R l.sum = (l.map <| convexHull R).sum", "start": [475, 1], "end": [476, 46], "kind": "commanddeclaration"}, {"full_name": "convexHull_multiset_sum", "code": "theorem convexHull_multiset_sum (s : Multiset (Set E)) :\n    convexHull R s.sum = (s.map <| convexHull R).sum", "start": [479, 1], "end": [481, 50], "kind": "commanddeclaration"}, {"full_name": "convexHull_sum", "code": "theorem convexHull_sum {\u03b9} (s : Finset \u03b9) (t : \u03b9 \u2192 Set E) :\n    convexHull R (\u2211 i in s, t i) = \u2211 i in s, convexHull R (t i)", "start": [484, 1], "end": [486, 43], "kind": "commanddeclaration"}, {"full_name": "convexHull_basis_eq_stdSimplex", "code": "theorem convexHull_basis_eq_stdSimplex :\n    convexHull R (range fun i j : \u03b9 => if i = j then (1 : R) else 0) = stdSimplex R \u03b9", "start": [494, 1], "end": [503, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.convexHull_eq_image", "code": "theorem Set.Finite.convexHull_eq_image {s : Set E} (hs : s.Finite) : convexHull R s =\n    haveI := hs.fintype\n    (\u21d1(\u2211 x : s, (@LinearMap.proj R s _ (fun _ => R) _ _ x).smulRight x.1)) '' stdSimplex R s", "start": [508, 1], "end": [525, 37], "kind": "commanddeclaration"}, {"full_name": "mem_Icc_of_mem_stdSimplex", "code": "theorem mem_Icc_of_mem_stdSimplex (hf : f \u2208 stdSimplex R \u03b9) (x) : f x \u2208 Icc (0 : R) 1", "start": [528, 1], "end": [530, 80], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.convexHull_eq_nonneg_coord", "code": "theorem AffineBasis.convexHull_eq_nonneg_coord {\u03b9 : Type*} (b : AffineBasis \u03b9 R E) :\n    convexHull R (range b) = { x | \u2200 i, 0 \u2264 b.coord i x }", "start": [533, 1], "end": [553, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Affine.lean", "imports": ["Mathlib/Topology/Algebra/Group/Basic.lean", "Mathlib/Topology/Algebra/MulAction.lean", "Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AffineMap.continuous_iff", "code": "theorem continuous_iff {f : E \u2192\u1d43[R] F} : Continuous f \u2194 Continuous f.linear", "start": [36, 1], "end": [45, 34], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_continuous", "code": "@[continuity]\ntheorem lineMap_continuous [TopologicalSpace R] [ContinuousSMul R F] {p v : F} :\n    Continuous (lineMap p v : R \u2192\u1d43[R] F)", "start": [48, 1], "end": [53, 83], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothety_continuous", "code": "@[continuity]\ntheorem homothety_continuous (x : F) (t : R) : Continuous <| homothety x t", "start": [62, 1], "end": [69, 25], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothety_isOpenMap", "code": "theorem homothety_isOpenMap (x : F) (t : R) (ht : t \u2260 0) : IsOpenMap <| homothety x t", "start": [78, 1], "end": [80, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Exp.lean", "imports": ["Mathlib/Analysis/Asymptotics/Theta.lean", "Mathlib/Analysis/Complex/Basic.lean", "Mathlib/Analysis/SpecificLimits/Normed.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.exp_bound_sq", "code": "theorem exp_bound_sq (x z : \u2102) (hz : \u2016z\u2016 \u2264 1) :\n    \u2016exp (x + z) - exp x - z \u2022 exp x\u2016 \u2264 \u2016exp x\u2016 * \u2016z\u2016 ^ 2", "start": [34, 1], "end": [43, 79], "kind": "commanddeclaration"}, {"full_name": "Complex.locally_lipschitz_exp", "code": "theorem locally_lipschitz_exp {r : \u211d} (hr_nonneg : 0 \u2264 r) (hr_le : r \u2264 1) (x y : \u2102)\n    (hyx : \u2016y - x\u2016 < r) : \u2016exp y - exp x\u2016 \u2264 (1 + r) * \u2016exp x\u2016 * \u2016y - x\u2016", "start": [46, 1], "end": [62, 47], "kind": "commanddeclaration"}, {"full_name": "Complex.continuous_exp", "code": "@[continuity]\ntheorem continuous_exp : Continuous exp", "start": [67, 1], "end": [74, 14], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousOn_exp", "code": "theorem continuousOn_exp {s : Set \u2102} : ContinuousOn exp s", "start": [77, 1], "end": [78, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.cexp", "code": "theorem Filter.Tendsto.cexp {l : Filter \u03b1} {f : \u03b1 \u2192 \u2102} {z : \u2102} (hf : Tendsto f l (\ud835\udcdd z)) :\n    Tendsto (fun x => exp (f x)) l (\ud835\udcdd (exp z))", "start": [89, 1], "end": [91, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.cexp", "code": "nonrec\ntheorem ContinuousWithinAt.cexp (h : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (fun y => exp (f y)) s x", "start": [96, 1], "end": [99, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.cexp", "code": "nonrec\ntheorem ContinuousAt.cexp (h : ContinuousAt f x) : ContinuousAt (fun y => exp (f y)) x", "start": [102, 1], "end": [104, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.cexp", "code": "theorem ContinuousOn.cexp (h : ContinuousOn f s) : ContinuousOn (fun y => exp (f y)) s", "start": [107, 1], "end": [108, 28], "kind": "commanddeclaration"}, {"full_name": "Continuous.cexp", "code": "theorem Continuous.cexp (h : Continuous f) : Continuous fun y => exp (f y)", "start": [111, 1], "end": [112, 61], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_exp", "code": "@[continuity]\ntheorem continuous_exp : Continuous exp", "start": [119, 1], "end": [121, 60], "kind": "commanddeclaration"}, {"full_name": "Real.continuousOn_exp", "code": "theorem continuousOn_exp {s : Set \u211d} : ContinuousOn exp s", "start": [124, 1], "end": [125, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.exp", "code": "theorem Filter.Tendsto.exp {l : Filter \u03b1} {f : \u03b1 \u2192 \u211d} {z : \u211d} (hf : Tendsto f l (\ud835\udcdd z)) :\n    Tendsto (fun x => exp (f x)) l (\ud835\udcdd (exp z))", "start": [136, 1], "end": [138, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.exp", "code": "nonrec\ntheorem ContinuousWithinAt.exp (h : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (fun y => exp (f y)) s x", "start": [143, 1], "end": [146, 8], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.exp", "code": "nonrec\ntheorem ContinuousAt.exp (h : ContinuousAt f x) : ContinuousAt (fun y => exp (f y)) x", "start": [149, 1], "end": [151, 8], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.exp", "code": "theorem ContinuousOn.exp (h : ContinuousOn f s) : ContinuousOn (fun y => exp (f y)) s", "start": [154, 1], "end": [155, 15], "kind": "commanddeclaration"}, {"full_name": "Continuous.exp", "code": "theorem Continuous.exp (h : Continuous f) : Continuous fun y => exp (f y)", "start": [158, 1], "end": [159, 60], "kind": "commanddeclaration"}, {"full_name": "Real.exp_half", "code": "theorem exp_half (x : \u211d) : exp (x / 2) = sqrt (exp x)", "start": [168, 1], "end": [169, 86], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_exp_atTop", "code": "theorem tendsto_exp_atTop : Tendsto exp atTop atTop", "start": [172, 1], "end": [177, 38], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_exp_neg_atTop_nhds_0", "code": "theorem tendsto_exp_neg_atTop_nhds_0 : Tendsto (fun x => exp (-x)) atTop (\ud835\udcdd 0)", "start": [180, 1], "end": [183, 82], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_exp_nhds_0_nhds_1", "code": "theorem tendsto_exp_nhds_0_nhds_1 : Tendsto exp (\ud835\udcdd 0) (\ud835\udcdd 1)", "start": [186, 1], "end": [189, 7], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_exp_atBot", "code": "theorem tendsto_exp_atBot : Tendsto exp atBot (\ud835\udcdd 0)", "start": [192, 1], "end": [194, 31], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_exp_atBot_nhdsWithin", "code": "theorem tendsto_exp_atBot_nhdsWithin : Tendsto exp atBot (\ud835\udcdd[>] 0)", "start": [197, 1], "end": [198, 89], "kind": "commanddeclaration"}, {"full_name": "Real.isBoundedUnder_ge_exp_comp", "code": "@[simp]\ntheorem isBoundedUnder_ge_exp_comp (l : Filter \u03b1) (f : \u03b1 \u2192 \u211d) :\n    IsBoundedUnder (\u00b7 \u2265 \u00b7) l fun x => exp (f x)", "start": [201, 1], "end": [204, 49], "kind": "commanddeclaration"}, {"full_name": "Real.isBoundedUnder_le_exp_comp", "code": "@[simp]\ntheorem isBoundedUnder_le_exp_comp {f : \u03b1 \u2192 \u211d} :\n    (IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => exp (f x)) \u2194 IsBoundedUnder (\u00b7 \u2264 \u00b7) l f", "start": [207, 1], "end": [210, 60], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_exp_div_pow_atTop", "code": "theorem tendsto_exp_div_pow_atTop (n : \u2115) : Tendsto (fun x => exp x / x ^ n) atTop atTop", "start": [213, 1], "end": [233, 85], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_pow_mul_exp_neg_atTop_nhds_0", "code": "theorem tendsto_pow_mul_exp_neg_atTop_nhds_0 (n : \u2115) :\n    Tendsto (fun x => x ^ n * exp (-x)) atTop (\ud835\udcdd 0)", "start": [236, 1], "end": [240, 90], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_mul_exp_add_div_pow_atTop", "code": "theorem tendsto_mul_exp_add_div_pow_atTop (b c : \u211d) (n : \u2115) (hb : 0 < b) :\n    Tendsto (fun x => (b * exp x + c) / x ^ n) atTop atTop", "start": [243, 1], "end": [253, 60], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_div_pow_mul_exp_add_atTop", "code": "theorem tendsto_div_pow_mul_exp_add_atTop (b c : \u211d) (n : \u2115) (hb : 0 \u2260 b) :\n    Tendsto (fun x => x ^ n / (b * exp x + c)) atTop (\ud835\udcdd 0)", "start": [256, 1], "end": [271, 20], "kind": "commanddeclaration"}, {"full_name": "Real.expOrderIso", "code": "def expOrderIso : \u211d \u2243o Ioi (0 : \u211d) :=\n  StrictMono.orderIsoOfSurjective _ (exp_strictMono.codRestrict exp_pos) <|\n    (continuous_exp.subtype_mk _).surjective\n      (by simp only [tendsto_Ioi_atTop, Subtype.coe_mk, tendsto_exp_atTop])\n      (by simp [tendsto_exp_atBot_nhdsWithin])", "start": [274, 1], "end": [279, 47], "kind": "commanddeclaration"}, {"full_name": "Real.coe_expOrderIso_apply", "code": "@[simp]\ntheorem coe_expOrderIso_apply (x : \u211d) : (expOrderIso x : \u211d) = exp x", "start": [282, 1], "end": [284, 6], "kind": "commanddeclaration"}, {"full_name": "Real.coe_comp_expOrderIso", "code": "@[simp]\ntheorem coe_comp_expOrderIso : (\u2191) \u2218 expOrderIso = exp", "start": [287, 1], "end": [289, 6], "kind": "commanddeclaration"}, {"full_name": "Real.range_exp", "code": "@[simp]\ntheorem range_exp : range exp = Set.Ioi 0", "start": [292, 1], "end": [294, 95], "kind": "commanddeclaration"}, {"full_name": "Real.map_exp_atTop", "code": "@[simp]\ntheorem map_exp_atTop : map exp atTop = atTop", "start": [297, 1], "end": [299, 87], "kind": "commanddeclaration"}, {"full_name": "Real.comap_exp_atTop", "code": "@[simp]\ntheorem comap_exp_atTop : comap exp atTop = atTop", "start": [302, 1], "end": [304, 63], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_exp_comp_atTop", "code": "@[simp]\ntheorem tendsto_exp_comp_atTop {f : \u03b1 \u2192 \u211d} :\n    Tendsto (fun x => exp (f x)) l atTop \u2194 Tendsto f l atTop", "start": [307, 1], "end": [310, 73], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_comp_exp_atTop", "code": "theorem tendsto_comp_exp_atTop {f : \u211d \u2192 \u03b1} :\n    Tendsto (fun x => f (exp x)) atTop l \u2194 Tendsto f atTop l", "start": [313, 1], "end": [315, 70], "kind": "commanddeclaration"}, {"full_name": "Real.map_exp_atBot", "code": "@[simp]\ntheorem map_exp_atBot : map exp atBot = \ud835\udcdd[>] 0", "start": [318, 1], "end": [320, 92], "kind": "commanddeclaration"}, {"full_name": "Real.comap_exp_nhdsWithin_Ioi_zero", "code": "@[simp]\ntheorem comap_exp_nhdsWithin_Ioi_zero : comap exp (\ud835\udcdd[>] 0) = atBot", "start": [323, 1], "end": [325, 48], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_comp_exp_atBot", "code": "theorem tendsto_comp_exp_atBot {f : \u211d \u2192 \u03b1} :\n    Tendsto (fun x => f (exp x)) atBot l \u2194 Tendsto f (\ud835\udcdd[>] 0) l", "start": [328, 1], "end": [331, 6], "kind": "commanddeclaration"}, {"full_name": "Real.comap_exp_nhds_zero", "code": "@[simp]\ntheorem comap_exp_nhds_zero : comap exp (\ud835\udcdd 0) = atBot", "start": [334, 1], "end": [336, 55], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_exp_comp_nhds_zero", "code": "@[simp]\ntheorem tendsto_exp_comp_nhds_zero {f : \u03b1 \u2192 \u211d} :\n    Tendsto (fun x => exp (f x)) l (\ud835\udcdd 0) \u2194 Tendsto f l atBot", "start": [339, 1], "end": [342, 77], "kind": "commanddeclaration"}, {"full_name": "Real.openEmbedding_exp", "code": "theorem openEmbedding_exp : OpenEmbedding exp", "start": [346, 1], "end": [347, 83], "kind": "commanddeclaration"}, {"full_name": "Real.map_exp_nhds", "code": "theorem map_exp_nhds (x : \u211d) : map exp (\ud835\udcdd x) = \ud835\udcdd (exp x)", "start": [350, 1], "end": [351, 34], "kind": "commanddeclaration"}, {"full_name": "Real.comap_exp_nhds_exp", "code": "theorem comap_exp_nhds_exp (x : \u211d) : comap exp (\ud835\udcdd (exp x)) = \ud835\udcdd x", "start": [354, 1], "end": [355, 43], "kind": "commanddeclaration"}, {"full_name": "Real.isLittleO_pow_exp_atTop", "code": "theorem isLittleO_pow_exp_atTop {n : \u2115} : (fun x : \u211d => x ^ n) =o[atTop] Real.exp", "start": [357, 1], "end": [359, 56], "kind": "commanddeclaration"}, {"full_name": "Real.isBigO_exp_comp_exp_comp", "code": "@[simp]\ntheorem isBigO_exp_comp_exp_comp {f g : \u03b1 \u2192 \u211d} :\n    ((fun x => exp (f x)) =O[l] fun x => exp (g x)) \u2194 IsBoundedUnder (\u00b7 \u2264 \u00b7) l (f - g)", "start": [362, 1], "end": [366, 88], "kind": "commanddeclaration"}, {"full_name": "Real.isTheta_exp_comp_exp_comp", "code": "@[simp]\ntheorem isTheta_exp_comp_exp_comp {f g : \u03b1 \u2192 \u211d} :\n    ((fun x => exp (f x)) =\u0398[l] fun x => exp (g x)) \u2194\n      IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => |f x - g x|", "start": [370, 1], "end": [375, 42], "kind": "commanddeclaration"}, {"full_name": "Real.isLittleO_exp_comp_exp_comp", "code": "@[simp]\ntheorem isLittleO_exp_comp_exp_comp {f g : \u03b1 \u2192 \u211d} :\n    ((fun x => exp (f x)) =o[l] fun x => exp (g x)) \u2194 Tendsto (fun x => g x - f x) l atTop", "start": [379, 1], "end": [383, 55], "kind": "commanddeclaration"}, {"full_name": "Real.isLittleO_one_exp_comp", "code": "theorem isLittleO_one_exp_comp {f : \u03b1 \u2192 \u211d} :\n    ((fun _ => 1 : \u03b1 \u2192 \u211d) =o[l] fun x => exp (f x)) \u2194 Tendsto f l atTop", "start": [388, 1], "end": [390, 64], "kind": "commanddeclaration"}, {"full_name": "Real.isBigO_one_exp_comp", "code": "@[simp]\ntheorem isBigO_one_exp_comp {f : \u03b1 \u2192 \u211d} :\n    ((fun _ => 1 : \u03b1 \u2192 \u211d) =O[l] fun x => exp (f x)) \u2194 IsBoundedUnder (\u00b7 \u2265 \u00b7) l f", "start": [393, 1], "end": [398, 96], "kind": "commanddeclaration"}, {"full_name": "Real.isBigO_exp_comp_one", "code": "theorem isBigO_exp_comp_one {f : \u03b1 \u2192 \u211d} :\n    (fun x => exp (f x)) =O[l] (fun _ => 1 : \u03b1 \u2192 \u211d) \u2194 IsBoundedUnder (\u00b7 \u2264 \u00b7) l f", "start": [402, 1], "end": [406, 79], "kind": "commanddeclaration"}, {"full_name": "Real.isTheta_exp_comp_one", "code": "@[simp]\ntheorem isTheta_exp_comp_one {f : \u03b1 \u2192 \u211d} :\n    (fun x => exp (f x)) =\u0398[l] (fun _ => 1 : \u03b1 \u2192 \u211d) \u2194 IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => |f x|", "start": [410, 1], "end": [415, 62], "kind": "commanddeclaration"}, {"full_name": "Complex.comap_exp_comap_abs_atTop", "code": "theorem comap_exp_comap_abs_atTop : comap exp (comap abs atTop) = comap re atTop", "start": [423, 1], "end": [427, 55], "kind": "commanddeclaration"}, {"full_name": "Complex.comap_exp_nhds_zero", "code": "theorem comap_exp_nhds_zero : comap exp (\ud835\udcdd 0) = comap re atBot", "start": [431, 1], "end": [435, 59], "kind": "commanddeclaration"}, {"full_name": "Complex.comap_exp_nhdsWithin_zero", "code": "theorem comap_exp_nhdsWithin_zero : comap exp (\ud835\udcdd[\u2260] 0) = comap re atBot", "start": [439, 1], "end": [441, 47], "kind": "commanddeclaration"}, {"full_name": "Complex.tendsto_exp_nhds_zero_iff", "code": "theorem tendsto_exp_nhds_zero_iff {\u03b1 : Type*} {l : Filter \u03b1} {f : \u03b1 \u2192 \u2102} :\n    Tendsto (fun x => exp (f x)) l (\ud835\udcdd 0) \u2194 Tendsto (fun x => re (f x)) l atBot", "start": [444, 1], "end": [447, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.tendsto_exp_comap_re_atTop", "code": "theorem tendsto_exp_comap_re_atTop : Tendsto exp (comap re atTop) (comap abs atTop)", "start": [450, 1], "end": [452, 44], "kind": "commanddeclaration"}, {"full_name": "Complex.tendsto_exp_comap_re_atBot", "code": "theorem tendsto_exp_comap_re_atBot : Tendsto exp (comap re atBot) (\ud835\udcdd 0)", "start": [455, 1], "end": [457, 38], "kind": "commanddeclaration"}, {"full_name": "Complex.tendsto_exp_comap_re_atBot_nhdsWithin", "code": "theorem tendsto_exp_comap_re_atBot_nhdsWithin : Tendsto exp (comap re atBot) (\ud835\udcdd[\u2260] 0)", "start": [460, 1], "end": [461, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Instances/AddCircle.lean", "imports": ["Mathlib/Algebra/Ring/AddAut.lean", "Mathlib/Topology/Instances/Real.lean", "Mathlib/Algebra/Order/Floor.lean", "Mathlib/GroupTheory/OrderOfElement.lean", "Mathlib/Data/Nat/Totient.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Connected/PathConnected.lean", "Mathlib/GroupTheory/Divisible.lean", "Mathlib/Algebra/Order/ToIntervalMod.lean"], "premises": [{"full_name": "continuous_right_toIcoMod", "code": "theorem continuous_right_toIcoMod : ContinuousWithinAt (toIcoMod hp a) (Ici x) x", "start": [66, 1], "end": [81, 71], "kind": "commanddeclaration"}, {"full_name": "continuous_left_toIocMod", "code": "theorem continuous_left_toIocMod : ContinuousWithinAt (toIocMod hp a) (Iic x) x", "start": [84, 1], "end": [91, 99], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_eventuallyEq_toIocMod", "code": "theorem toIcoMod_eventuallyEq_toIocMod : toIcoMod hp a =\u1da0[\ud835\udcdd x] toIocMod hp a", "start": [96, 1], "end": [101, 86], "kind": "commanddeclaration"}, {"full_name": "continuousAt_toIcoMod", "code": "theorem continuousAt_toIcoMod : ContinuousAt (toIcoMod hp a) x", "start": [104, 1], "end": [109, 40], "kind": "commanddeclaration"}, {"full_name": "continuousAt_toIocMod", "code": "theorem continuousAt_toIocMod : ContinuousAt (toIocMod hp a) x", "start": [112, 1], "end": [117, 67], "kind": "commanddeclaration"}, {"full_name": "AddCircle", "code": "@[nolint unusedArguments]\nabbrev AddCircle [LinearOrderedAddCommGroup \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c] (p : \ud835\udd5c) :=\n  \ud835\udd5c \u29f8 zmultiples p", "start": [122, 1], "end": [125, 19], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_nsmul", "code": "theorem coe_nsmul {n : \u2115} {x : \ud835\udd5c} : (\u2191(n \u2022 x) : AddCircle p) = n \u2022 (x : AddCircle p)", "start": [134, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_zsmul", "code": "theorem coe_zsmul {n : \u2124} {x : \ud835\udd5c} : (\u2191(n \u2022 x) : AddCircle p) = n \u2022 (x : AddCircle p)", "start": [138, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_add", "code": "theorem coe_add (x y : \ud835\udd5c) : (\u2191(x + y) : AddCircle p) = (x : AddCircle p) + (y : AddCircle p)", "start": [142, 1], "end": [143, 6], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_sub", "code": "theorem coe_sub (x y : \ud835\udd5c) : (\u2191(x - y) : AddCircle p) = (x : AddCircle p) - (y : AddCircle p)", "start": [146, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_neg", "code": "theorem coe_neg {x : \ud835\udd5c} : (\u2191(-x) : AddCircle p) = -(x : AddCircle p)", "start": [150, 1], "end": [151, 6], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_eq_zero_iff", "code": "theorem coe_eq_zero_iff {x : \ud835\udd5c} : (x : AddCircle p) = 0 \u2194 \u2203 n : \u2124, n \u2022 p = x", "start": [154, 1], "end": [155, 40], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_eq_zero_of_pos_iff", "code": "theorem coe_eq_zero_of_pos_iff (hp : 0 < p) {x : \ud835\udd5c} (hx : 0 < x) :\n    (x : AddCircle p) = 0 \u2194 \u2203 n : \u2115, n \u2022 p = x", "start": [158, 1], "end": [166, 29], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_period", "code": "theorem coe_period : (p : AddCircle p) = 0", "start": [169, 1], "end": [170, 57], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_add_period", "code": "theorem coe_add_period (x : \ud835\udd5c) : ((x + p : \ud835\udd5c) : AddCircle p) = x", "start": [177, 1], "end": [178, 59], "kind": "commanddeclaration"}, {"full_name": "AddCircle.continuous_mk'", "code": "@[continuity, nolint unusedArguments]\nprotected theorem continuous_mk' :\n    Continuous (QuotientAddGroup.mk' (zmultiples p) : \ud835\udd5c \u2192 AddCircle p)", "start": [181, 1], "end": [184, 27], "kind": "commanddeclaration"}, {"full_name": "AddCircle.equivIco", "code": "def equivIco : AddCircle p \u2243 Ico a (a + p) :=\n  QuotientAddGroup.equivIcoMod hp.out a", "start": [189, 1], "end": [192, 40], "kind": "commanddeclaration"}, {"full_name": "AddCircle.equivIoc", "code": "def equivIoc : AddCircle p \u2243 Ioc a (a + p) :=\n  QuotientAddGroup.equivIocMod hp.out a", "start": [195, 1], "end": [198, 40], "kind": "commanddeclaration"}, {"full_name": "AddCircle.liftIco", "code": "def liftIco (f : \ud835\udd5c \u2192 B) : AddCircle p \u2192 B :=\n  restrict _ f \u2218 AddCircle.equivIco p a", "start": [201, 1], "end": [204, 40], "kind": "commanddeclaration"}, {"full_name": "AddCircle.liftIoc", "code": "def liftIoc (f : \ud835\udd5c \u2192 B) : AddCircle p \u2192 B :=\n  restrict _ f \u2218 AddCircle.equivIoc p a", "start": [207, 1], "end": [210, 40], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_eq_coe_iff_of_mem_Ico", "code": "theorem coe_eq_coe_iff_of_mem_Ico {x y : \ud835\udd5c} (hx : x \u2208 Ico a (a + p)) (hy : y \u2208 Ico a (a + p)) :\n    (x : AddCircle p) = y \u2194 x = y", "start": [215, 1], "end": [221, 10], "kind": "commanddeclaration"}, {"full_name": "AddCircle.liftIco_coe_apply", "code": "theorem liftIco_coe_apply {f : \ud835\udd5c \u2192 B} {x : \ud835\udd5c} (hx : x \u2208 Ico a (a + p)) :\n    liftIco p a f \u2191x = f x", "start": [224, 1], "end": [230, 6], "kind": "commanddeclaration"}, {"full_name": "AddCircle.liftIoc_coe_apply", "code": "theorem liftIoc_coe_apply {f : \ud835\udd5c \u2192 B} {x : \ud835\udd5c} (hx : x \u2208 Ioc a (a + p)) :\n    liftIoc p a f \u2191x = f x", "start": [233, 1], "end": [239, 6], "kind": "commanddeclaration"}, {"full_name": "AddCircle.continuous_equivIco_symm", "code": "@[continuity]\ntheorem continuous_equivIco_symm : Continuous (equivIco p a).symm", "start": [246, 1], "end": [248, 54], "kind": "commanddeclaration"}, {"full_name": "AddCircle.continuous_equivIoc_symm", "code": "@[continuity]\ntheorem continuous_equivIoc_symm : Continuous (equivIoc p a).symm", "start": [251, 1], "end": [253, 54], "kind": "commanddeclaration"}, {"full_name": "AddCircle.continuousAt_equivIco", "code": "theorem continuousAt_equivIco : ContinuousAt (equivIco p a) x", "start": [258, 1], "end": [261, 58], "kind": "commanddeclaration"}, {"full_name": "AddCircle.continuousAt_equivIoc", "code": "theorem continuousAt_equivIoc : ContinuousAt (equivIoc p a) x", "start": [264, 1], "end": [267, 58], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_image_Ico_eq", "code": "@[simp]\ntheorem coe_image_Ico_eq : ((\u2191) : \ud835\udd5c \u2192 AddCircle p) '' Ico a (a + p) = univ", "start": [272, 1], "end": [277, 42], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_image_Ioc_eq", "code": "@[simp]\ntheorem coe_image_Ioc_eq : ((\u2191) : \ud835\udd5c \u2192 AddCircle p) '' Ioc a (a + p) = univ", "start": [280, 1], "end": [285, 42], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_image_Icc_eq", "code": "@[simp]\ntheorem coe_image_Icc_eq : ((\u2191) : \ud835\udd5c \u2192 AddCircle p) '' Icc a (a + p) = univ", "start": [288, 1], "end": [292, 75], "kind": "commanddeclaration"}, {"full_name": "AddCircle.equivAddCircle", "code": "def equivAddCircle (hp : p \u2260 0) (hq : q \u2260 0) : AddCircle p \u2243+ AddCircle q :=\n  QuotientAddGroup.congr _ _ (AddAut.mulRight <| (Units.mk0 p hp)\u207b\u00b9 * Units.mk0 q hq) <| by\n    rw [AddMonoidHom.map_zmultiples, AddMonoidHom.coe_coe, AddAut.mulRight_apply, Units.val_mul,\n      Units.val_mk0, Units.val_inv_eq_inv_val, Units.val_mk0, mul_inv_cancel_left\u2080 hp]", "start": [301, 1], "end": [305, 87], "kind": "commanddeclaration"}, {"full_name": "AddCircle.equivAddCircle_apply_mk", "code": "@[simp]\ntheorem equivAddCircle_apply_mk (hp : p \u2260 0) (hq : q \u2260 0) (x : \ud835\udd5c) :\n    equivAddCircle p q hp hq (x : \ud835\udd5c) = (x * (p\u207b\u00b9 * q) : \ud835\udd5c)", "start": [308, 1], "end": [311, 6], "kind": "commanddeclaration"}, {"full_name": "AddCircle.equivAddCircle_symm_apply_mk", "code": "@[simp]\ntheorem equivAddCircle_symm_apply_mk (hp : p \u2260 0) (hq : q \u2260 0) (x : \ud835\udd5c) :\n    (equivAddCircle p q hp hq).symm (x : \ud835\udd5c) = (x * (q\u207b\u00b9 * p) : \ud835\udd5c)", "start": [314, 1], "end": [317, 6], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_equivIco_mk_apply", "code": "@[simp]\ntheorem coe_equivIco_mk_apply (x : \ud835\udd5c) :\n    (equivIco p 0 <| QuotientAddGroup.mk x : \ud835\udd5c) = Int.fract (x / p) * p", "start": [326, 1], "end": [329, 28], "kind": "commanddeclaration"}, {"full_name": "AddCircle.addOrderOf_period_div", "code": "theorem addOrderOf_period_div {n : \u2115} (h : 0 < n) : addOrderOf ((p / n : \ud835\udd5c) : AddCircle p) = n", "start": [349, 1], "end": [358, 50], "kind": "commanddeclaration"}, {"full_name": "AddCircle.gcd_mul_addOrderOf_div_eq", "code": "theorem gcd_mul_addOrderOf_div_eq {n : \u2115} (m : \u2115) (hn : 0 < n) :\n    m.gcd n * addOrderOf (\u2191(\u2191m / \u2191n * p) : AddCircle p) = n", "start": [363, 1], "end": [369, 13], "kind": "commanddeclaration"}, {"full_name": "AddCircle.addOrderOf_div_of_gcd_eq_one", "code": "theorem addOrderOf_div_of_gcd_eq_one {m n : \u2115} (hn : 0 < n) (h : m.gcd n = 1) :\n    addOrderOf (\u2191(\u2191m / \u2191n * p) : AddCircle p) = n", "start": [374, 1], "end": [377, 18], "kind": "commanddeclaration"}, {"full_name": "AddCircle.addOrderOf_div_of_gcd_eq_one'", "code": "theorem addOrderOf_div_of_gcd_eq_one' {m : \u2124} {n : \u2115} (hn : 0 < n) (h : m.natAbs.gcd n = 1) :\n    addOrderOf (\u2191(\u2191m / \u2191n * p) : AddCircle p) = n", "start": [380, 1], "end": [386, 44], "kind": "commanddeclaration"}, {"full_name": "AddCircle.addOrderOf_coe_rat", "code": "theorem addOrderOf_coe_rat {q : \u211a} : addOrderOf (\u2191(\u2191q * p) : AddCircle p) = q.den", "start": [389, 1], "end": [394, 51], "kind": "commanddeclaration"}, {"full_name": "AddCircle.addOrderOf_eq_pos_iff", "code": "theorem addOrderOf_eq_pos_iff {u : AddCircle p} {n : \u2115} (h : 0 < n) :\n    addOrderOf u = n \u2194 \u2203 m < n, m.gcd n = 1 \u2227 \u2191(\u2191m / \u2191n * p) = u", "start": [397, 1], "end": [421, 15], "kind": "commanddeclaration"}, {"full_name": "AddCircle.exists_gcd_eq_one_of_isOfFinAddOrder", "code": "theorem exists_gcd_eq_one_of_isOfFinAddOrder {u : AddCircle p} (h : IsOfFinAddOrder u) :\n    \u2203 m : \u2115, m.gcd (addOrderOf u) = 1 \u2227 m < addOrderOf u \u2227 \u2191((m : \ud835\udd5c) / addOrderOf u * p) = u", "start": [424, 1], "end": [427, 18], "kind": "commanddeclaration"}, {"full_name": "AddCircle.setAddOrderOfEquiv", "code": "def setAddOrderOfEquiv {n : \u2115} (hn : 0 < n) :\n    { u : AddCircle p | addOrderOf u = n } \u2243 { m | m < n \u2227 m.gcd n = 1 } :=\n  Equiv.symm <|\n    Equiv.ofBijective (fun m => \u27e8\u2191((m : \ud835\udd5c) / n * p), addOrderOf_div_of_gcd_eq_one hn m.prop.2\u27e9)\n      (by\n        refine' \u27e8fun m\u2081 m\u2082 h => Subtype.ext _, fun u => _\u27e9\n        \u00b7 simp_rw [Subtype.ext_iff] at h\n          rw [\u2190 sub_eq_zero, \u2190 coe_sub, \u2190 sub_mul, \u2190 sub_div, \u2190 Int.cast_ofNat m\u2081,\n            \u2190 Int.cast_ofNat m\u2082, \u2190 Int.cast_sub, coe_eq_zero_iff] at h\n          obtain \u27e8m, hm\u27e9 := h\n          rw [\u2190 mul_div_right_comm, eq_div_iff, mul_comm, \u2190 zsmul_eq_mul, mul_smul_comm, \u2190\n            nsmul_eq_mul, \u2190 coe_nat_zsmul, smul_smul,\n            (zsmul_strictMono_left hp.out).injective.eq_iff, mul_comm] at hm\n          swap\n          \u00b7 exact Nat.cast_ne_zero.2 hn.ne'\n          rw [\u2190 @Nat.cast_inj \u2124, \u2190 sub_eq_zero]\n          refine' Int.eq_zero_of_abs_lt_dvd \u27e8_, hm.symm\u27e9 (abs_sub_lt_iff.2 \u27e8_, _\u27e9) <;>\n            apply (Int.sub_le_self _ <| Nat.cast_nonneg _).trans_lt (Nat.cast_lt.2 _)\n          exacts [m\u2081.2.1, m\u2082.2.1]\n        obtain \u27e8m, hmn, hg, he\u27e9 := (addOrderOf_eq_pos_iff hn).mp u.2\n        exact \u27e8\u27e8m, hmn, hg\u27e9, Subtype.ext he\u27e9)", "start": [432, 1], "end": [455, 46], "kind": "commanddeclaration"}, {"full_name": "AddCircle.card_addOrderOf_eq_totient", "code": "@[simp]\ntheorem card_addOrderOf_eq_totient {n : \u2115} :\n    Nat.card { u : AddCircle p // addOrderOf u = n } = n.totient", "start": [458, 1], "end": [472, 29], "kind": "commanddeclaration"}, {"full_name": "AddCircle.finite_setOf_add_order_eq", "code": "theorem finite_setOf_add_order_eq {n : \u2115} (hn : 0 < n) :\n    { u : AddCircle p | addOrderOf u = n }.Finite", "start": [475, 1], "end": [479, 90], "kind": "commanddeclaration"}, {"full_name": "AddCircle.pathConnectedSpace", "code": "instance pathConnectedSpace : PathConnectedSpace $ AddCircle p :=\n  (inferInstance : PathConnectedSpace (Quotient _))", "start": [488, 1], "end": [489, 52], "kind": "commanddeclaration"}, {"full_name": "AddCircle.compactSpace", "code": "instance compactSpace [Fact (0 < p)] : CompactSpace <| AddCircle p := by\n  rw [\u2190 isCompact_univ_iff, \u2190 coe_image_Icc_eq p 0]\n  exact isCompact_Icc.image (AddCircle.continuous_mk' p)", "start": [491, 1], "end": [494, 57], "kind": "commanddeclaration"}, {"full_name": "UnitAddCircle", "code": "abbrev UnitAddCircle :=\n  AddCircle (1 : \u211d)", "start": [508, 1], "end": [510, 20], "kind": "commanddeclaration"}, {"full_name": "AddCircle.EndpointIdent", "code": "inductive EndpointIdent : Icc a (a + p) \u2192 Icc a (a + p) \u2192 Prop\n  | mk :\n    EndpointIdent \u27e8a, left_mem_Icc.mpr <| le_add_of_nonneg_right hp.out.le\u27e9\n      \u27e8a + p, right_mem_Icc.mpr <| le_add_of_nonneg_right hp.out.le\u27e9", "start": [527, 1], "end": [531, 69], "kind": "commanddeclaration"}, {"full_name": "AddCircle.equivIccQuot", "code": "def equivIccQuot : \ud835\udd4b \u2243 Quot (EndpointIdent p a) where\n  toFun x := Quot.mk _ <| inclusion Ico_subset_Icc_self (equivIco _ _ x)\n  invFun x :=\n    Quot.liftOn x (\u2191) <| by\n      rintro _ _ \u27e8_\u27e9\n      exact (coe_add_period p a).symm\n  left_inv := (equivIco p a).symm_apply_apply\n  right_inv :=\n    Quot.ind <| by\n      rintro \u27e8x, hx\u27e9\n      rcases ne_or_eq x (a + p) with (h | rfl)\n      \u00b7 revert x\n        dsimp only\n        intro x hx h\n        congr\n        ext1\n        apply congr_arg Subtype.val ((equivIco p a).right_inv \u27e8x, hx.1, hx.2.lt_of_ne h\u27e9)\n      \u00b7 rw [\u2190 Quot.sound EndpointIdent.mk]\n        dsimp only\n        congr\n        ext1\n        apply congr_arg Subtype.val\n          ((equivIco p a).right_inv \u27e8a, le_refl a, lt_add_of_pos_right a hp.out\u27e9)", "start": [536, 1], "end": [560, 82], "kind": "commanddeclaration"}, {"full_name": "AddCircle.equivIccQuot_comp_mk_eq_toIcoMod", "code": "theorem equivIccQuot_comp_mk_eq_toIcoMod :\n    equivIccQuot p a \u2218 Quotient.mk'' = fun x =>\n      Quot.mk _ \u27e8toIcoMod hp.out a x, Ico_subset_Icc_self <| toIcoMod_mem_Ico _ _ x\u27e9", "start": [563, 1], "end": [566, 6], "kind": "commanddeclaration"}, {"full_name": "AddCircle.equivIccQuot_comp_mk_eq_toIocMod", "code": "theorem equivIccQuot_comp_mk_eq_toIocMod :\n    equivIccQuot p a \u2218 Quotient.mk'' = fun x =>\n      Quot.mk _ \u27e8toIocMod hp.out a x, Ioc_subset_Icc_self <| toIocMod_mem_Ioc _ _ x\u27e9", "start": [569, 1], "end": [577, 62], "kind": "commanddeclaration"}, {"full_name": "AddCircle.homeoIccQuot", "code": "def homeoIccQuot : \ud835\udd4b \u2243\u209c Quot (EndpointIdent p a) where\n  toEquiv := equivIccQuot p a\n  continuous_toFun := by\n    rw [quotientMap_quotient_mk'.continuous_iff]\n    simp_rw [continuous_iff_continuousAt,\n      continuousAt_iff_continuous_left_right]\n    intro x; constructor\n    on_goal 1 => erw [equivIccQuot_comp_mk_eq_toIocMod]\n    on_goal 2 => erw [equivIccQuot_comp_mk_eq_toIcoMod]\n    all_goals\n      apply continuous_quot_mk.continuousAt.comp_continuousWithinAt\n      rw [inducing_subtype_val.continuousWithinAt_iff]\n    \u00b7 apply continuous_left_toIocMod\n    \u00b7 apply continuous_right_toIcoMod\n  continuous_invFun :=\n    continuous_quot_lift _ ((AddCircle.continuous_mk' p).comp continuous_subtype_val)", "start": [580, 1], "end": [598, 86], "kind": "commanddeclaration"}, {"full_name": "AddCircle.liftIco_eq_lift_Icc", "code": "theorem liftIco_eq_lift_Icc {f : \ud835\udd5c \u2192 B} (h : f a = f (a + p)) :\n    liftIco p a f =\n      Quot.lift (restrict (Icc a <| a + p) f)\n          (by\n            rintro _ _ \u27e8_\u27e9\n            exact h) \u2218\n        equivIccQuot p a", "start": [607, 1], "end": [614, 6], "kind": "commanddeclaration"}, {"full_name": "AddCircle.liftIco_continuous", "code": "theorem liftIco_continuous [TopologicalSpace B] {f : \ud835\udd5c \u2192 B} (hf : f a = f (a + p))\n    (hc : ContinuousOn f <| Icc a (a + p)) : Continuous (liftIco p a f)", "start": [617, 1], "end": [621, 82], "kind": "commanddeclaration"}, {"full_name": "AddCircle.liftIco_zero_coe_apply", "code": "theorem liftIco_zero_coe_apply {f : \ud835\udd5c \u2192 B} {x : \ud835\udd5c} (hx : x \u2208 Ico 0 p) : liftIco p 0 f \u2191x = f x", "start": [626, 1], "end": [627, 40], "kind": "commanddeclaration"}, {"full_name": "AddCircle.liftIco_zero_continuous", "code": "theorem liftIco_zero_continuous [TopologicalSpace B] {f : \ud835\udd5c \u2192 B} (hf : f 0 = f p)\n    (hc : ContinuousOn f <| Icc 0 p) : Continuous (liftIco p 0 f)", "start": [630, 1], "end": [632, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Group/Quotient.lean", "imports": ["Mathlib/Analysis/Normed/Group/Hom.lean", "Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/NormedSpace/Basic.lean"], "premises": [{"full_name": "normOnQuotient", "code": "noncomputable instance normOnQuotient (S : AddSubgroup M) : Norm (M \u29f8 S) where\n  norm x := sInf (norm '' { m | mk' S m = x })", "start": [102, 1], "end": [104, 47], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.quotient_norm_eq", "code": "theorem AddSubgroup.quotient_norm_eq {S : AddSubgroup M} (x : M \u29f8 S) :\n    \u2016x\u2016 = sInf (norm '' { m : M | (m : M \u29f8 S) = x })", "start": [107, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.norm_eq_infDist", "code": "theorem QuotientAddGroup.norm_eq_infDist {S : AddSubgroup M} (x : M \u29f8 S) :\n    \u2016x\u2016 = infDist 0 { m : M | (m : M \u29f8 S) = x }", "start": [112, 1], "end": [114, 89], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.norm_mk", "code": "theorem QuotientAddGroup.norm_mk {S : AddSubgroup M} (x : M) :\n    \u2016(x : M \u29f8 S)\u2016 = infDist x S", "start": [116, 1], "end": [124, 61], "kind": "commanddeclaration"}, {"full_name": "image_norm_nonempty", "code": "theorem image_norm_nonempty {S : AddSubgroup M} (x : M \u29f8 S) :\n    (norm '' { m | mk' S m = x }).Nonempty", "start": [126, 1], "end": [128, 32], "kind": "commanddeclaration"}, {"full_name": "bddBelow_image_norm", "code": "theorem bddBelow_image_norm (s : Set M) : BddBelow (norm '' s)", "start": [131, 1], "end": [132, 48], "kind": "commanddeclaration"}, {"full_name": "isGLB_quotient_norm", "code": "theorem isGLB_quotient_norm {S : AddSubgroup M} (x : M \u29f8 S) :\n    IsGLB (norm '' { m | mk' S m = x }) (\u2016x\u2016)", "start": [135, 1], "end": [137, 62], "kind": "commanddeclaration"}, {"full_name": "quotient_norm_neg", "code": "theorem quotient_norm_neg {S : AddSubgroup M} (x : M \u29f8 S) : \u2016-x\u2016 = \u2016x\u2016", "start": [139, 1], "end": [143, 86], "kind": "commanddeclaration"}, {"full_name": "quotient_norm_sub_rev", "code": "theorem quotient_norm_sub_rev {S : AddSubgroup M} (x y : M \u29f8 S) : \u2016x - y\u2016 = \u2016y - x\u2016", "start": [146, 1], "end": [147, 36], "kind": "commanddeclaration"}, {"full_name": "quotient_norm_mk_le", "code": "theorem quotient_norm_mk_le (S : AddSubgroup M) (m : M) : \u2016mk' S m\u2016 \u2264 \u2016m\u2016", "start": [150, 1], "end": [152, 65], "kind": "commanddeclaration"}, {"full_name": "quotient_norm_mk_le'", "code": "theorem quotient_norm_mk_le' (S : AddSubgroup M) (m : M) : \u2016(m : M \u29f8 S)\u2016 \u2264 \u2016m\u2016", "start": [155, 1], "end": [157, 26], "kind": "commanddeclaration"}, {"full_name": "quotient_norm_mk_eq", "code": "theorem quotient_norm_mk_eq (S : AddSubgroup M) (m : M) :\n    \u2016mk' S m\u2016 = sInf ((\u2016m + \u00b7\u2016) '' S)", "start": [160, 1], "end": [165, 54], "kind": "commanddeclaration"}, {"full_name": "quotient_norm_nonneg", "code": "theorem quotient_norm_nonneg (S : AddSubgroup M) (x : M \u29f8 S) : 0 \u2264 \u2016x\u2016", "start": [168, 1], "end": [170, 65], "kind": "commanddeclaration"}, {"full_name": "norm_mk_nonneg", "code": "theorem norm_mk_nonneg (S : AddSubgroup M) (m : M) : 0 \u2264 \u2016mk' S m\u2016", "start": [173, 1], "end": [175, 27], "kind": "commanddeclaration"}, {"full_name": "quotient_norm_eq_zero_iff", "code": "theorem quotient_norm_eq_zero_iff (S : AddSubgroup M) (m : M) :\n    \u2016mk' S m\u2016 = 0 \u2194 m \u2208 closure (S : Set M)", "start": [178, 1], "end": [183, 24], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.norm_lt_iff", "code": "theorem QuotientAddGroup.norm_lt_iff {S : AddSubgroup M} {x : M \u29f8 S} {r : \u211d} :\n    \u2016x\u2016 < r \u2194 \u2203 m : M, \u2191m = x \u2227 \u2016m\u2016 < r", "start": [186, 1], "end": [189, 6], "kind": "commanddeclaration"}, {"full_name": "norm_mk_lt", "code": "theorem norm_mk_lt {S : AddSubgroup M} (x : M \u29f8 S) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) :\n    \u2203 m : M, mk' S m = x \u2227 \u2016m\u2016 < \u2016x\u2016 + \u03b5", "start": [191, 1], "end": [195, 44], "kind": "commanddeclaration"}, {"full_name": "norm_mk_lt'", "code": "theorem norm_mk_lt' (S : AddSubgroup M) (m : M) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) :\n    \u2203 s \u2208 S, \u2016m + s\u2016 < \u2016mk' S m\u2016 + \u03b5", "start": [198, 1], "end": [205, 28], "kind": "commanddeclaration"}, {"full_name": "quotient_norm_add_le", "code": "theorem quotient_norm_add_le (S : AddSubgroup M) (x y : M \u29f8 S) : \u2016x + y\u2016 \u2264 \u2016x\u2016 + \u2016y\u2016", "start": [208, 1], "end": [214, 79], "kind": "commanddeclaration"}, {"full_name": "norm_mk_zero", "code": "theorem norm_mk_zero (S : AddSubgroup M) : \u2016(0 : M \u29f8 S)\u2016 = 0", "start": [217, 1], "end": [220, 34], "kind": "commanddeclaration"}, {"full_name": "norm_mk_eq_zero", "code": "theorem norm_mk_eq_zero (S : AddSubgroup M) (hS : IsClosed (S : Set M)) (m : M)\n    (h : \u2016mk' S m\u2016 = 0) : m \u2208 S", "start": [223, 1], "end": [226, 90], "kind": "commanddeclaration"}, {"full_name": "quotient_nhd_basis", "code": "theorem quotient_nhd_basis (S : AddSubgroup M) :\n    (\ud835\udcdd (0 : M \u29f8 S)).HasBasis (fun \u03b5 \u21a6 0 < \u03b5) fun \u03b5 \u21a6 { x | \u2016x\u2016 < \u03b5 }", "start": [229, 1], "end": [236, 38], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.seminormedAddCommGroupQuotient", "code": "noncomputable instance AddSubgroup.seminormedAddCommGroupQuotient (S : AddSubgroup M) :\n    SeminormedAddCommGroup (M \u29f8 S) where\n  dist x y := \u2016x - y\u2016\n  dist_self x := by simp only [norm_mk_zero, sub_self]\n  dist_comm := quotient_norm_sub_rev\n  dist_triangle x y z := by\n    refine le_trans ?_ (quotient_norm_add_le _ _ _)\n    exact (congr_arg norm (sub_add_sub_cancel _ _ _).symm).le\n  edist_dist x y := by exact ENNReal.coe_nnreal_eq _\n  toUniformSpace := TopologicalAddGroup.toUniformSpace (M \u29f8 S)\n  uniformity_dist := by\n    rw [uniformity_eq_comap_nhds_zero', ((quotient_nhd_basis S).comap _).eq_biInf]\n    simp only [dist, quotient_norm_sub_rev (Prod.fst _), preimage_setOf_eq]", "start": [239, 1], "end": [252, 76], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.normedAddCommGroupQuotient", "code": "noncomputable instance AddSubgroup.normedAddCommGroupQuotient (S : AddSubgroup M)\n    [IsClosed (S : Set M)] : NormedAddCommGroup (M \u29f8 S) :=\n  { AddSubgroup.seminormedAddCommGroupQuotient S, MetricSpace.ofT0PseudoMetricSpace _ with }", "start": [262, 1], "end": [265, 93], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.normedMk", "code": "noncomputable def normedMk (S : AddSubgroup M) : NormedAddGroupHom M (M \u29f8 S) :=\n  { QuotientAddGroup.mk' S with\n    bound' := \u27e81, fun m => by simpa [one_mul] using quotient_norm_mk_le _ m\u27e9 }", "start": [278, 1], "end": [281, 79], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.normedMk.apply", "code": "@[simp]\ntheorem normedMk.apply (S : AddSubgroup M) (m : M) : normedMk S m = QuotientAddGroup.mk' S m", "start": [284, 1], "end": [287, 6], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.surjective_normedMk", "code": "theorem surjective_normedMk (S : AddSubgroup M) : Function.Surjective (normedMk S)", "start": [290, 1], "end": [292, 23], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.ker_normedMk", "code": "theorem ker_normedMk (S : AddSubgroup M) : S.normedMk.ker = S", "start": [295, 1], "end": [297, 29], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.norm_normedMk_le", "code": "theorem norm_normedMk_le (S : AddSubgroup M) : \u2016S.normedMk\u2016 \u2264 1", "start": [300, 1], "end": [302, 90], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.norm_lift_apply_le", "code": "theorem _root_.QuotientAddGroup.norm_lift_apply_le {S : AddSubgroup M} (f : NormedAddGroupHom M N)\n    (hf : \u2200 x \u2208 S, f x = 0) (x : M \u29f8 S) : \u2016lift S f.toAddMonoidHom hf x\u2016 \u2264 \u2016f\u2016 * \u2016x\u2016", "start": [305, 1], "end": [314, 56], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.norm_normedMk", "code": "theorem norm_normedMk (S : AddSubgroup M) (h : (S.topologicalClosure : Set M) \u2260 univ) :\n    \u2016S.normedMk\u2016 = 1", "start": [316, 1], "end": [324, 68], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.norm_trivial_quotient_mk", "code": "theorem norm_trivial_quotient_mk (S : AddSubgroup M)\n    (h : (S.topologicalClosure : Set M) = Set.univ) : \u2016S.normedMk\u2016 = 0", "start": [327, 1], "end": [335, 89], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.IsQuotient", "code": "structure IsQuotient (f : NormedAddGroupHom M N) : Prop where\n  protected surjective : Function.Surjective f\n  protected norm : \u2200 x, \u2016f x\u2016 = sInf ((fun m => \u2016x + m\u2016) '' f.ker)", "start": [342, 1], "end": [346, 67], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.lift", "code": "noncomputable def lift {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : \u2200 s \u2208 S, f s = 0) : NormedAddGroupHom (M \u29f8 S) N :=\n  { QuotientAddGroup.lift S f.toAddMonoidHom hf with\n    bound' := \u27e8\u2016f\u2016, norm_lift_apply_le f hf\u27e9 }", "start": [349, 1], "end": [354, 47], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.lift_mk", "code": "theorem lift_mk {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : \u2200 s \u2208 S, f s = 0) (m : M) :\n    lift S f hf (S.normedMk m) = f m", "start": [357, 1], "end": [360, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.lift_unique", "code": "theorem lift_unique {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : \u2200 s \u2208 S, f s = 0) (g : NormedAddGroupHom (M \u29f8 S) N)\n    (h : g.comp S.normedMk = f) : g = lift S f hf", "start": [363, 1], "end": [370, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.isQuotientQuotient", "code": "theorem isQuotientQuotient (S : AddSubgroup M) : IsQuotient S.normedMk", "start": [373, 1], "end": [375, 92], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.IsQuotient.norm_lift", "code": "theorem IsQuotient.norm_lift {f : NormedAddGroupHom M N} (hquot : IsQuotient f) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5)\n    (n : N) : \u2203 m : M, f m = n \u2227 \u2016m\u2016 < \u2016n\u2016 + \u03b5", "start": [378, 1], "end": [387, 22], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.IsQuotient.norm_le", "code": "theorem IsQuotient.norm_le {f : NormedAddGroupHom M N} (hquot : IsQuotient f) (m : M) :\n    \u2016f m\u2016 \u2264 \u2016m\u2016", "start": [390, 1], "end": [397, 39], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.norm_lift_le", "code": "theorem norm_lift_le {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : \u2200 s \u2208 S, f s = 0) :\n    \u2016lift S f hf\u2016 \u2264 \u2016f\u2016", "start": [401, 1], "end": [404, 62], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.lift_norm_le", "code": "theorem lift_norm_le {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : \u2200 s \u2208 S, f s = 0) {c : \u211d\u22650} (fb : \u2016f\u2016 \u2264 c) :\n    \u2016lift S f hf\u2016 \u2264 c", "start": [407, 1], "end": [410, 33], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.lift_normNoninc", "code": "theorem lift_normNoninc {N : Type*} [SeminormedAddCommGroup N] (S : AddSubgroup M)\n    (f : NormedAddGroupHom M N) (hf : \u2200 s \u2208 S, f s = 0) (fb : f.NormNoninc) :\n    (lift S f hf).NormNoninc", "start": [413, 1], "end": [417, 59], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.seminormedAddCommGroup", "code": "instance Submodule.Quotient.seminormedAddCommGroup : SeminormedAddCommGroup (M \u29f8 S) :=\n  AddSubgroup.seminormedAddCommGroupQuotient S.toAddSubgroup", "start": [440, 1], "end": [441, 61], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.normedAddCommGroup", "code": "instance Submodule.Quotient.normedAddCommGroup [hS : IsClosed (S : Set M)] :\n    NormedAddCommGroup (M \u29f8 S) :=\n  @AddSubgroup.normedAddCommGroupQuotient _ _ S.toAddSubgroup hS", "start": [444, 1], "end": [446, 65], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.completeSpace", "code": "instance Submodule.Quotient.completeSpace [CompleteSpace M] : CompleteSpace (M \u29f8 S) :=\n  QuotientAddGroup.completeSpace M S.toAddSubgroup", "start": [449, 1], "end": [450, 51], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.norm_mk_lt", "code": "nonrec theorem Submodule.Quotient.norm_mk_lt {S : Submodule R M} (x : M \u29f8 S) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) :\n    \u2203 m : M, Submodule.Quotient.mk m = x \u2227 \u2016m\u2016 < \u2016x\u2016 + \u03b5", "start": [453, 1], "end": [457, 18], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.norm_mk_le", "code": "theorem Submodule.Quotient.norm_mk_le (m : M) : \u2016(Submodule.Quotient.mk m : M \u29f8 S)\u2016 \u2264 \u2016m\u2016", "start": [460, 1], "end": [461, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.normedSpace", "code": "instance Submodule.Quotient.normedSpace (\ud835\udd5c : Type*) [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c M] [SMul \ud835\udd5c R]\n    [IsScalarTower \ud835\udd5c R M] : NormedSpace \ud835\udd5c (M \u29f8 S) :=\n  { Submodule.Quotient.module' S with\n    norm_smul_le := fun k x =>\n      le_of_forall_pos_le_add fun \u03b5 h\u03b5 => by\n        have := (nhds_basis_ball.tendsto_iff nhds_basis_ball).mp\n          ((@Real.uniformContinuous_const_mul \u2016k\u2016).continuous.tendsto \u2016x\u2016) \u03b5 h\u03b5\n        simp only [mem_ball, exists_prop, dist, abs_sub_lt_iff] at this\n        rcases this with \u27e8\u03b4, h\u03b4, h\u27e9\n        obtain \u27e8a, rfl, ha\u27e9 := Submodule.Quotient.norm_mk_lt x h\u03b4\n        specialize h \u2016a\u2016 \u27e8by linarith, by linarith [Submodule.Quotient.norm_mk_le S a]\u27e9\n        calc\n          _ \u2264 \u2016k\u2016 * \u2016a\u2016 := (quotient_norm_mk_le S.toAddSubgroup (k \u2022 a)).trans_eq (norm_smul k a)\n          _ \u2264 _ := (sub_lt_iff_lt_add'.mp h.1).le }", "start": [464, 1], "end": [479, 52], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.norm_mk_lt", "code": "nonrec theorem Ideal.Quotient.norm_mk_lt {I : Ideal R} (x : R \u29f8 I) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) :\n    \u2203 r : R, Ideal.Quotient.mk I r = x \u2227 \u2016r\u2016 < \u2016x\u2016 + \u03b5", "start": [488, 1], "end": [490, 18], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.norm_mk_le", "code": "theorem Ideal.Quotient.norm_mk_le (r : R) : \u2016Ideal.Quotient.mk I r\u2016 \u2264 \u2016r\u2016", "start": [493, 1], "end": [494, 40], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.semiNormedCommRing", "code": "instance Ideal.Quotient.semiNormedCommRing : SeminormedCommRing (R \u29f8 I) where\n  dist_eq := dist_eq_norm\n  mul_comm := _root_.mul_comm\n  norm_mul x y := le_of_forall_pos_le_add fun \u03b5 h\u03b5 => by\n    have := ((nhds_basis_ball.prod_nhds nhds_basis_ball).tendsto_iff nhds_basis_ball).mp\n      (continuous_mul.tendsto (\u2016x\u2016, \u2016y\u2016)) \u03b5 h\u03b5\n    simp only [Set.mem_prod, mem_ball, and_imp, Prod.forall, exists_prop, Prod.exists] at this\n    rcases this with \u27e8\u03b5\u2081, \u03b5\u2082, \u27e8h\u2081, h\u2082\u27e9, h\u27e9\n    obtain \u27e8\u27e8a, rfl, ha\u27e9, \u27e8b, rfl, hb\u27e9\u27e9 := Ideal.Quotient.norm_mk_lt x h\u2081,\n      Ideal.Quotient.norm_mk_lt y h\u2082\n    simp only [dist, abs_sub_lt_iff] at h\n    specialize h \u2016a\u2016 \u2016b\u2016 \u27e8by linarith, by linarith [Ideal.Quotient.norm_mk_le I a]\u27e9\n      \u27e8by linarith, by linarith [Ideal.Quotient.norm_mk_le I b]\u27e9\n    calc\n      _ \u2264 \u2016a\u2016 * \u2016b\u2016 := (Ideal.Quotient.norm_mk_le I (a * b)).trans (norm_mul_le a b)\n      _ \u2264 _ := (sub_lt_iff_lt_add'.mp h.1).le", "start": [497, 1], "end": [512, 46], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.normedCommRing", "code": "instance Ideal.Quotient.normedCommRing [IsClosed (I : Set R)] : NormedCommRing (R \u29f8 I) :=\n  { Ideal.Quotient.semiNormedCommRing I, Submodule.Quotient.normedAddCommGroup I with }", "start": [515, 1], "end": [516, 88], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.normedAlgebra", "code": "instance Ideal.Quotient.normedAlgebra [NormedAlgebra \ud835\udd5c R] : NormedAlgebra \ud835\udd5c (R \u29f8 I) :=\n  { Submodule.Quotient.normedSpace I \ud835\udd5c, Ideal.Quotient.algebra \ud835\udd5c with }", "start": [521, 1], "end": [522, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/PEmpty.lean", "imports": ["Mathlib/CategoryTheory/DiscreteCategory.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.emptyEquivalence", "code": "def emptyEquivalence : Discrete.{w} PEmpty \u224c Discrete.{v} PEmpty where\n  functor :=\n    { obj := PEmpty.elim \u2218 Discrete.as\n      map := fun {X} _ _ => X.as.elim }\n  inverse :=\n    { obj := PEmpty.elim \u2218 Discrete.as\n      map := fun {X} _ _ => X.as.elim }\n  unitIso :=\n    { hom := { app := fun X => X.as.elim }\n      inv := { app := fun X => X.as.elim } }\n  counitIso :=\n    { hom := { app := fun X => X.as.elim }\n      inv := { app := fun X => X.as.elim } }", "start": [24, 1], "end": [37, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.empty", "code": "def empty : Discrete.{w} PEmpty \u2964 C :=\n  Discrete.functor PEmpty.elim", "start": [40, 1], "end": [42, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.emptyExt", "code": "def emptyExt (F G : Discrete.{w} PEmpty \u2964 C) : F \u2245 G :=\n  Discrete.natIso fun x => x.as.elim", "start": [47, 1], "end": [49, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.uniqueFromEmpty", "code": "def uniqueFromEmpty (F : Discrete.{w} PEmpty \u2964 C) : F \u2245 empty C :=\n  emptyExt _ _", "start": [52, 1], "end": [56, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.empty_ext'", "code": "theorem empty_ext' (F G : Discrete.{w} PEmpty \u2964 C) : F = G", "start": [59, 1], "end": [63, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/HasLimits.lean", "imports": ["Mathlib/CategoryTheory/Limits/IsLimit.lean", "Mathlib/CategoryTheory/Category/ULift.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.LimitCone", "code": "structure LimitCone (F : J \u2964 C) where\n  \n  cone : Cone F\n  \n  isLimit : IsLimit cone", "start": [75, 1], "end": [81, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimit", "code": "class HasLimit (F : J \u2964 C) : Prop where mk' ::\n  \n  exists_limit : Nonempty (LimitCone F)", "start": [85, 1], "end": [88, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimit.mk", "code": "theorem HasLimit.mk {F : J \u2964 C} (d : LimitCone F) : HasLimit F", "start": [91, 1], "end": [92, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.getLimitCone", "code": "def getLimitCone (F : J \u2964 C) [HasLimit F] : LimitCone F :=\n  Classical.choice <| HasLimit.exists_limit", "start": [95, 1], "end": [97, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimitsOfShape", "code": "class HasLimitsOfShape : Prop where\n  \n  has_limit : \u2200 F : J \u2964 C, HasLimit F := by infer_instance", "start": [102, 1], "end": [105, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimitsOfSize", "code": "@[pp_with_univ]\nclass HasLimitsOfSize (C : Type u) [Category.{v} C] : Prop where\n  \n  has_limits_of_shape : \u2200 (J : Type u\u2081) [Category.{v\u2081} J], HasLimitsOfShape J C := by\n    infer_instance", "start": [108, 1], "end": [115, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimits", "code": "abbrev HasLimits (C : Type u) [Category.{v} C] : Prop :=\n  HasLimitsOfSize.{v, v} C", "start": [118, 1], "end": [120, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimits.has_limits_of_shape", "code": "theorem HasLimits.has_limits_of_shape {C : Type u} [Category.{v} C] [HasLimits C] (J : Type v)\n    [Category.{v} J] : HasLimitsOfShape J C", "start": [123, 1], "end": [125, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitOfHasLimitsOfShape", "code": "instance (priority := 100) hasLimitOfHasLimitsOfShape {J : Type u\u2081} [Category.{v\u2081} J]\n    [HasLimitsOfShape J C] (F : J \u2964 C) : HasLimit F :=\n  HasLimitsOfShape.has_limit F", "start": [131, 1], "end": [133, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitsOfShapeOfHasLimits", "code": "instance (priority := 100) hasLimitsOfShapeOfHasLimits {J : Type u\u2081} [Category.{v\u2081} J]\n    [HasLimitsOfSize.{v\u2081, u\u2081} C] : HasLimitsOfShape J C :=\n  HasLimitsOfSize.has_limits_of_shape J", "start": [137, 1], "end": [139, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.cone", "code": "def limit.cone (F : J \u2964 C) [HasLimit F] : Cone F :=\n  (getLimitCone F).cone", "start": [143, 1], "end": [145, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit", "code": "def limit (F : J \u2964 C) [HasLimit F] :=\n  (limit.cone F).pt", "start": [148, 1], "end": [150, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.\u03c0", "code": "def limit.\u03c0 (F : J \u2964 C) [HasLimit F] (j : J) : limit F \u27f6 F.obj j :=\n  (limit.cone F).\u03c0.app j", "start": [153, 1], "end": [155, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.cone_x", "code": "@[simp]\ntheorem limit.cone_x {F : J \u2964 C} [HasLimit F] : (limit.cone F).pt = limit F", "start": [158, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.cone_\u03c0", "code": "@[simp]\ntheorem limit.cone_\u03c0 {F : J \u2964 C} [HasLimit F] : (limit.cone F).\u03c0.app = limit.\u03c0 _", "start": [164, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.w", "code": "@[reassoc (attr := simp)]\ntheorem limit.w (F : J \u2964 C) [HasLimit F] {j j' : J} (f : j \u27f6 j') :\n    limit.\u03c0 F j \u226b F.map f = limit.\u03c0 F j'", "start": [169, 1], "end": [172, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.isLimit", "code": "def limit.isLimit (F : J \u2964 C) [HasLimit F] : IsLimit (limit.cone F) :=\n  (getLimitCone F).isLimit", "start": [175, 1], "end": [177, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.lift", "code": "def limit.lift (F : J \u2964 C) [HasLimit F] (c : Cone F) : c.pt \u27f6 limit F :=\n  (limit.isLimit F).lift c", "start": [180, 1], "end": [182, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.isLimit_lift", "code": "@[simp]\ntheorem limit.isLimit_lift {F : J \u2964 C} [HasLimit F] (c : Cone F) :\n    (limit.isLimit F).lift c = limit.lift F c", "start": [185, 1], "end": [188, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.lift_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem limit.lift_\u03c0 {F : J \u2964 C} [HasLimit F] (c : Cone F) (j : J) :\n    limit.lift F c \u226b limit.\u03c0 F j = c.\u03c0.app j", "start": [191, 1], "end": [194, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limMap", "code": "def limMap {F G : J \u2964 C} [HasLimit F] [HasLimit G] (\u03b1 : F \u27f6 G) : limit F \u27f6 limit G :=\n  IsLimit.map _ (limit.isLimit G) \u03b1", "start": [197, 1], "end": [204, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limMap_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem limMap_\u03c0 {F G : J \u2964 C} [HasLimit F] [HasLimit G] (\u03b1 : F \u27f6 G) (j : J) :\n    limMap \u03b1 \u226b limit.\u03c0 G j = limit.\u03c0 F j \u226b \u03b1.app j", "start": [207, 1], "end": [210, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.coneMorphism", "code": "def limit.coneMorphism {F : J \u2964 C} [HasLimit F] (c : Cone F) : c \u27f6 limit.cone F :=\n  (limit.isLimit F).liftConeMorphism c", "start": [213, 1], "end": [215, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.coneMorphism_hom", "code": "@[simp]\ntheorem limit.coneMorphism_hom {F : J \u2964 C} [HasLimit F] (c : Cone F) :\n    (limit.coneMorphism c).hom = limit.lift F c", "start": [218, 1], "end": [221, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.coneMorphism_\u03c0", "code": "theorem limit.coneMorphism_\u03c0 {F : J \u2964 C} [HasLimit F] (c : Cone F) (j : J) :\n    (limit.coneMorphism c).hom \u226b limit.\u03c0 F j = c.\u03c0.app j", "start": [224, 1], "end": [225, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.conePointUniqueUpToIso_hom_comp", "code": "@[reassoc (attr := simp)]\ntheorem limit.conePointUniqueUpToIso_hom_comp {F : J \u2964 C} [HasLimit F] {c : Cone F} (hc : IsLimit c)\n    (j : J) : (IsLimit.conePointUniqueUpToIso hc (limit.isLimit _)).hom \u226b limit.\u03c0 F j = c.\u03c0.app j", "start": [228, 1], "end": [231, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.conePointUniqueUpToIso_inv_comp", "code": "@[reassoc (attr := simp)]\ntheorem limit.conePointUniqueUpToIso_inv_comp {F : J \u2964 C} [HasLimit F] {c : Cone F} (hc : IsLimit c)\n    (j : J) : (IsLimit.conePointUniqueUpToIso (limit.isLimit _) hc).inv \u226b limit.\u03c0 F j = c.\u03c0.app j", "start": [234, 1], "end": [237, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.existsUnique", "code": "theorem limit.existsUnique {F : J \u2964 C} [HasLimit F] (t : Cone F) :\n    \u2203! l : t.pt \u27f6 limit F, \u2200 j, l \u226b limit.\u03c0 F j = t.\u03c0.app j", "start": [240, 1], "end": [242, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.isoLimitCone", "code": "def limit.isoLimitCone {F : J \u2964 C} [HasLimit F] (t : LimitCone F) : limit F \u2245 t.cone.pt :=\n  IsLimit.conePointUniqueUpToIso (limit.isLimit F) t.isLimit", "start": [245, 1], "end": [248, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.isoLimitCone_hom_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem limit.isoLimitCone_hom_\u03c0 {F : J \u2964 C} [HasLimit F] (t : LimitCone F) (j : J) :\n    (limit.isoLimitCone t).hom \u226b t.cone.\u03c0.app j = limit.\u03c0 F j", "start": [251, 1], "end": [255, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.isoLimitCone_inv_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem limit.isoLimitCone_inv_\u03c0 {F : J \u2964 C} [HasLimit F] (t : LimitCone F) (j : J) :\n    (limit.isoLimitCone t).inv \u226b limit.\u03c0 F j = t.cone.\u03c0.app j", "start": [258, 1], "end": [262, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.hom_ext", "code": "@[ext]\ntheorem limit.hom_ext {F : J \u2964 C} [HasLimit F] {X : C} {f f' : X \u27f6 limit F}\n    (w : \u2200 j, f \u226b limit.\u03c0 F j = f' \u226b limit.\u03c0 F j) : f = f'", "start": [265, 1], "end": [268, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.lift_map", "code": "@[simp]\ntheorem limit.lift_map {F G : J \u2964 C} [HasLimit F] [HasLimit G] (c : Cone F) (\u03b1 : F \u27f6 G) :\n    limit.lift F c \u226b limMap \u03b1 = limit.lift G ((Cones.postcompose \u03b1).obj c)", "start": [271, 1], "end": [276, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.lift_cone", "code": "@[simp]\ntheorem limit.lift_cone {F : J \u2964 C} [HasLimit F] : limit.lift F (limit.cone F) = \ud835\udfd9 (limit F)", "start": [279, 1], "end": [281, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.homIso", "code": "def limit.homIso (F : J \u2964 C) [HasLimit F] (W : C) :\n    ULift.{u\u2081} (W \u27f6 limit F : Type v) \u2245 F.cones.obj (op W) :=\n  (limit.isLimit F).homIso W", "start": [284, 1], "end": [290, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.homIso_hom", "code": "@[simp]\ntheorem limit.homIso_hom (F : J \u2964 C) [HasLimit F] {W : C} (f : ULift (W \u27f6 limit F)) :\n    (limit.homIso F W).hom f = (const J).map f.down \u226b (limit.cone F).\u03c0", "start": [293, 1], "end": [296, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.homIso'", "code": "def limit.homIso' (F : J \u2964 C) [HasLimit F] (W : C) :\n    ULift.{u\u2081} (W \u27f6 limit F : Type v) \u2245\n      { p : \u2200 j, W \u27f6 F.obj j // \u2200 {j j' : J} (f : j \u27f6 j'), p j \u226b F.map f = p j' } :=\n  (limit.isLimit F).homIso' W", "start": [299, 1], "end": [306, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.lift_extend", "code": "theorem limit.lift_extend {F : J \u2964 C} [HasLimit F] (c : Cone F) {X : C} (f : X \u27f6 c.pt) :\n    limit.lift F (c.extend f) = f \u226b limit.lift F c", "start": [309, 1], "end": [310, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitOfIso", "code": "theorem hasLimitOfIso {F G : J \u2964 C} [HasLimit F] (\u03b1 : F \u2245 G) : HasLimit G", "start": [313, 1], "end": [328, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimit.ofConesIso", "code": "theorem HasLimit.ofConesIso {J K : Type u\u2081} [Category.{v\u2081} J] [Category.{v\u2082} K] (F : J \u2964 C)\n    (G : K \u2964 C) (h : F.cones \u2245 G.cones) [HasLimit F] : HasLimit G", "start": [333, 1], "end": [337, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimit.isoOfNatIso", "code": "def HasLimit.isoOfNatIso {F G : J \u2964 C} [HasLimit F] [HasLimit G] (w : F \u2245 G) : limit F \u2245 limit G :=\n  IsLimit.conePointsIsoOfNatIso (limit.isLimit F) (limit.isLimit G) w", "start": [340, 1], "end": [344, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimit.isoOfNatIso_hom_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem HasLimit.isoOfNatIso_hom_\u03c0 {F G : J \u2964 C} [HasLimit F] [HasLimit G] (w : F \u2245 G) (j : J) :\n    (HasLimit.isoOfNatIso w).hom \u226b limit.\u03c0 G j = limit.\u03c0 F j \u226b w.hom.app j", "start": [347, 1], "end": [350, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimit.isoOfNatIso_inv_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem HasLimit.isoOfNatIso_inv_\u03c0 {F G : J \u2964 C} [HasLimit F] [HasLimit G] (w : F \u2245 G) (j : J) :\n    (HasLimit.isoOfNatIso w).inv \u226b limit.\u03c0 F j = limit.\u03c0 G j \u226b w.inv.app j", "start": [353, 1], "end": [356, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_hom", "code": "@[reassoc (attr := simp)]\ntheorem HasLimit.lift_isoOfNatIso_hom {F G : J \u2964 C} [HasLimit F] [HasLimit G] (t : Cone F)\n    (w : F \u2245 G) :\n    limit.lift F t \u226b (HasLimit.isoOfNatIso w).hom =\n      limit.lift G ((Cones.postcompose w.hom).obj _)", "start": [359, 1], "end": [364, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimit.lift_isoOfNatIso_inv", "code": "@[reassoc (attr := simp)]\ntheorem HasLimit.lift_isoOfNatIso_inv {F G : J \u2964 C} [HasLimit F] [HasLimit G] (t : Cone G)\n    (w : F \u2245 G) :\n    limit.lift G t \u226b (HasLimit.isoOfNatIso w).inv =\n      limit.lift F ((Cones.postcompose w.inv).obj _)", "start": [367, 1], "end": [372, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimit.isoOfEquivalence", "code": "def HasLimit.isoOfEquivalence {F : J \u2964 C} [HasLimit F] {G : K \u2964 C} [HasLimit G] (e : J \u224c K)\n    (w : e.functor \u22d9 G \u2245 F) : limit F \u2245 limit G :=\n  IsLimit.conePointsIsoOfEquivalence (limit.isLimit F) (limit.isLimit G) e w", "start": [375, 1], "end": [380, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimit.isoOfEquivalence_hom_\u03c0", "code": "@[simp]\ntheorem HasLimit.isoOfEquivalence_hom_\u03c0 {F : J \u2964 C} [HasLimit F] {G : K \u2964 C} [HasLimit G]\n    (e : J \u224c K) (w : e.functor \u22d9 G \u2245 F) (k : K) :\n    (HasLimit.isoOfEquivalence e w).hom \u226b limit.\u03c0 G k =\n      limit.\u03c0 F (e.inverse.obj k) \u226b w.inv.app (e.inverse.obj k) \u226b G.map (e.counit.app k)", "start": [383, 1], "end": [390, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasLimit.isoOfEquivalence_inv_\u03c0", "code": "@[simp]\ntheorem HasLimit.isoOfEquivalence_inv_\u03c0 {F : J \u2964 C} [HasLimit F] {G : K \u2964 C} [HasLimit G]\n    (e : J \u224c K) (w : e.functor \u22d9 G \u2245 F) (j : J) :\n    (HasLimit.isoOfEquivalence e w).inv \u226b limit.\u03c0 F j =\n    limit.\u03c0 G (e.functor.obj j) \u226b w.hom.app j", "start": [393, 1], "end": [400, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.pre", "code": "def limit.pre : limit F \u27f6 limit (E \u22d9 F) :=\n  limit.lift (E \u22d9 F) ((limit.cone F).whisker E)", "start": [407, 1], "end": [410, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.pre_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem limit.pre_\u03c0 (k : K) : limit.pre F E \u226b limit.\u03c0 (E \u22d9 F) k = limit.\u03c0 F (E.obj k)", "start": [413, 1], "end": [416, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.lift_pre", "code": "@[simp]\ntheorem limit.lift_pre (c : Cone F) :\n    limit.lift F c \u226b limit.pre F E = limit.lift (E \u22d9 F) (c.whisker E)", "start": [419, 1], "end": [421, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.pre_pre", "code": "@[simp]\ntheorem limit.pre_pre [h : HasLimit (D \u22d9 E \u22d9 F)] : haveI : HasLimit ((D \u22d9 E) \u22d9 F) := h;\n    limit.pre F E \u226b limit.pre (E \u22d9 F) D = limit.pre F (D \u22d9 E)", "start": [428, 1], "end": [432, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.pre_eq", "code": "theorem limit.pre_eq (s : LimitCone (E \u22d9 F)) (t : LimitCone F) :\n    limit.pre F E =\n      (limit.isoLimitCone t).hom \u226b s.isLimit.lift (t.cone.whisker E) \u226b (limit.isoLimitCone s).inv", "start": [437, 1], "end": [444, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.post", "code": "def limit.post : G.obj (limit F) \u27f6 limit (F \u22d9 G) :=\n  limit.lift (F \u22d9 G) (G.mapCone (limit.cone F))", "start": [455, 1], "end": [458, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.post_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem limit.post_\u03c0 (j : J) : limit.post F G \u226b limit.\u03c0 (F \u22d9 G) j = G.map (limit.\u03c0 F j)", "start": [461, 1], "end": [464, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.lift_post", "code": "@[simp]\ntheorem limit.lift_post (c : Cone F) :\n    G.map (limit.lift F c) \u226b limit.post F G = limit.lift (F \u22d9 G) (G.mapCone c)", "start": [467, 1], "end": [472, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.post_post", "code": "@[simp]\ntheorem limit.post_post {E : Type u''} [Category.{v''} E] (H : D \u2964 E) [h : HasLimit ((F \u22d9 G) \u22d9 H)] :\n    haveI : HasLimit (F \u22d9 G \u22d9 H) := h\n    H.map (limit.post F G) \u226b limit.post (F \u22d9 G) H = limit.post F (G \u22d9 H)", "start": [475, 1], "end": [482, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.pre_post", "code": "theorem limit.pre_post {D : Type u'} [Category.{v'} D] (E : K \u2964 J) (F : J \u2964 C) (G : C \u2964 D)\n    [HasLimit F] [HasLimit (E \u22d9 F)] [HasLimit (F \u22d9 G)]\n    [h : HasLimit ((E \u22d9 F) \u22d9 G)] :haveI : HasLimit (E \u22d9 F \u22d9 G) := h\n    G.map (limit.pre F E) \u226b limit.post (E \u22d9 F) G = limit.post F G \u226b limit.pre (F \u22d9 G) E", "start": [487, 1], "end": [494, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitEquivalenceComp", "code": "instance hasLimitEquivalenceComp (e : K \u224c J) [HasLimit F] : HasLimit (e.functor \u22d9 F) :=\n  HasLimit.mk\n    { cone := Cone.whisker e.functor (limit.cone F)\n      isLimit := IsLimit.whiskerEquivalence (limit.isLimit F) e }", "start": [499, 1], "end": [502, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitOfEquivalenceComp", "code": "theorem hasLimitOfEquivalenceComp (e : K \u224c J) [HasLimit (e.functor \u22d9 F)] : HasLimit F", "start": [509, 1], "end": [513, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.lim", "code": "@[simps]\ndef lim : (J \u2964 C) \u2964 C where\n  obj F := limit F\n  map \u03b1 := limMap \u03b1\n  map_id F := by\n    apply Limits.limit.hom_ext; intro j\n    erw [limMap_\u03c0, Category.id_comp, Category.comp_id]\n  map_comp \u03b1 \u03b2 := by\n    apply Limits.limit.hom_ext; intro j\n    erw [assoc, IsLimit.fac, IsLimit.fac, \u2190 assoc, IsLimit.fac, assoc]; rfl", "start": [524, 1], "end": [534, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.map_pre", "code": "theorem limit.map_pre [HasLimitsOfShape K C] (E : K \u2964 J) :\n    lim.map \u03b1 \u226b limit.pre G E = limit.pre F E \u226b lim.map (whiskerLeft E \u03b1)", "start": [542, 1], "end": [545, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.map_pre'", "code": "theorem limit.map_pre' [HasLimitsOfShape K C] (F : J \u2964 C) {E\u2081 E\u2082 : K \u2964 J} (\u03b1 : E\u2081 \u27f6 E\u2082) :\n    limit.pre F E\u2082 = limit.pre F E\u2081 \u226b lim.map (whiskerRight \u03b1 F)", "start": [548, 1], "end": [550, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.id_pre", "code": "theorem limit.id_pre (F : J \u2964 C) : limit.pre F (\ud835\udfed _) = lim.map (Functor.leftUnitor F).inv", "start": [553, 1], "end": [554, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit.map_post", "code": "theorem limit.map_post {D : Type u'} [Category.{v'} D] [HasLimitsOfShape J D] (H : C \u2964 D) :\n    \n    H.map (limMap \u03b1) \u226b limit.post G H = limit.post F H \u226b limMap (whiskerRight \u03b1 H)", "start": [557, 1], "end": [562, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limYoneda", "code": "def limYoneda :\n    lim \u22d9 yoneda \u22d9 (whiskeringRight _ _ _).obj uliftFunctor.{u\u2081} \u2245 CategoryTheory.cones J C :=\n  NatIso.ofComponents fun F => NatIso.ofComponents fun W => limit.homIso F (unop W)", "start": [565, 1], "end": [572, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.constLimAdj", "code": "def constLimAdj : (const J : C \u2964 J \u2964 C) \u22a3 lim where\n  homEquiv c g :=\n    { toFun := fun f => limit.lift _ \u27e8c, f\u27e9\n      invFun := fun f =>\n        { app := fun j => f \u226b limit.\u03c0 _ _ }\n      left_inv := by aesop_cat\n      right_inv := by aesop_cat }\n  unit := { app := fun c => limit.lift _ \u27e8_, \ud835\udfd9 _\u27e9 }\n  counit := { app := fun g => { app := limit.\u03c0 _ } }\n  homEquiv_unit := by\n    intros\n    dsimp\n    ext\n    simp", "start": [575, 1], "end": [591, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limMap_mono'", "code": "instance limMap_mono' {F G : J \u2964 C} [HasLimitsOfShape J C] (\u03b1 : F \u27f6 G) [Mono \u03b1] : Mono (limMap \u03b1) :=\n  (lim : (J \u2964 C) \u2964 C).map_mono \u03b1", "start": [599, 1], "end": [600, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limMap_mono", "code": "instance limMap_mono {F G : J \u2964 C} [HasLimit F] [HasLimit G] (\u03b1 : F \u27f6 G) [\u2200 j, Mono (\u03b1.app j)] :\n    Mono (limMap \u03b1) :=\n  \u27e8fun {Z} u v h =>\n    limit.hom_ext fun j => (cancel_mono (\u03b1.app j)).1 <| by simpa using h =\u226b limit.\u03c0 _ j\u27e9", "start": [603, 1], "end": [606, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitsOfShape_of_equivalence", "code": "theorem hasLimitsOfShape_of_equivalence {J' : Type u\u2082} [Category.{v\u2082} J'] (e : J \u224c J')\n    [HasLimitsOfShape J C] : HasLimitsOfShape J' C", "start": [609, 1], "end": [615, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitsOfSizeShrink", "code": "theorem hasLimitsOfSizeShrink [HasLimitsOfSize.{max v\u2081 v\u2082, max u\u2081 u\u2082} C] :\n    HasLimitsOfSize.{v\u2081, u\u2081} C", "start": [620, 1], "end": [625, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasSmallestLimitsOfHasLimits", "code": "instance (priority := 100) hasSmallestLimitsOfHasLimits [HasLimits C] : HasLimitsOfSize.{0, 0} C :=\n  hasLimitsOfSizeShrink.{0, 0} C", "start": [628, 1], "end": [629, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ColimitCocone", "code": "structure ColimitCocone (F : J \u2964 C) where\n  \n  cocone : Cocone F\n  \n  isColimit : IsColimit cocone", "start": [636, 1], "end": [643, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimit", "code": "class HasColimit (F : J \u2964 C) : Prop where mk' ::\n  \n  exists_colimit : Nonempty (ColimitCocone F)", "start": [647, 1], "end": [650, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimit.mk", "code": "theorem HasColimit.mk {F : J \u2964 C} (d : ColimitCocone F) : HasColimit F", "start": [653, 1], "end": [654, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.getColimitCocone", "code": "def getColimitCocone (F : J \u2964 C) [HasColimit F] : ColimitCocone F :=\n  Classical.choice <| HasColimit.exists_colimit", "start": [657, 1], "end": [659, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimitsOfShape", "code": "class HasColimitsOfShape : Prop where\n  \n  has_colimit : \u2200 F : J \u2964 C, HasColimit F := by infer_instance", "start": [664, 1], "end": [667, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimitsOfSize", "code": "@[pp_with_univ]\nclass HasColimitsOfSize (C : Type u) [Category.{v} C] : Prop where\n  \n  has_colimits_of_shape : \u2200 (J : Type u\u2081) [Category.{v\u2081} J], HasColimitsOfShape J C := by\n    infer_instance", "start": [670, 1], "end": [677, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimits", "code": "abbrev HasColimits (C : Type u) [Category.{v} C] : Prop :=\n  HasColimitsOfSize.{v, v} C", "start": [680, 1], "end": [683, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimits.hasColimitsOfShape", "code": "theorem HasColimits.hasColimitsOfShape {C : Type u} [Category.{v} C] [HasColimits C] (J : Type v)\n    [Category.{v} J] : HasColimitsOfShape J C", "start": [686, 1], "end": [688, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimitOfHasColimitsOfShape", "code": "instance (priority := 100) hasColimitOfHasColimitsOfShape {J : Type u\u2081} [Category.{v\u2081} J]\n    [HasColimitsOfShape J C] (F : J \u2964 C) : HasColimit F :=\n  HasColimitsOfShape.has_colimit F", "start": [694, 1], "end": [696, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimitsOfShapeOfHasColimitsOfSize", "code": "instance (priority := 100) hasColimitsOfShapeOfHasColimitsOfSize {J : Type u\u2081} [Category.{v\u2081} J]\n    [HasColimitsOfSize.{v\u2081, u\u2081} C] : HasColimitsOfShape J C :=\n  HasColimitsOfSize.has_colimits_of_shape J", "start": [700, 1], "end": [702, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.cocone", "code": "def colimit.cocone (F : J \u2964 C) [HasColimit F] : Cocone F :=\n  (getColimitCocone F).cocone", "start": [706, 1], "end": [708, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit", "code": "def colimit (F : J \u2964 C) [HasColimit F] :=\n  (colimit.cocone F).pt", "start": [711, 1], "end": [713, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.\u03b9", "code": "def colimit.\u03b9 (F : J \u2964 C) [HasColimit F] (j : J) : F.obj j \u27f6 colimit F :=\n  (colimit.cocone F).\u03b9.app j", "start": [716, 1], "end": [718, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.cocone_\u03b9", "code": "@[simp]\ntheorem colimit.cocone_\u03b9 {F : J \u2964 C} [HasColimit F] (j : J) :\n    (colimit.cocone F).\u03b9.app j = colimit.\u03b9 _ j", "start": [721, 1], "end": [724, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.cocone_x", "code": "@[simp]\ntheorem colimit.cocone_x {F : J \u2964 C} [HasColimit F] : (colimit.cocone F).pt = colimit F", "start": [727, 1], "end": [729, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.w", "code": "@[reassoc (attr := simp)]\ntheorem colimit.w (F : J \u2964 C) [HasColimit F] {j j' : J} (f : j \u27f6 j') :\n    F.map f \u226b colimit.\u03b9 F j' = colimit.\u03b9 F j", "start": [733, 1], "end": [736, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.isColimit", "code": "def colimit.isColimit (F : J \u2964 C) [HasColimit F] : IsColimit (colimit.cocone F) :=\n  (getColimitCocone F).isColimit", "start": [739, 1], "end": [741, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.desc", "code": "def colimit.desc (F : J \u2964 C) [HasColimit F] (c : Cocone F) : colimit F \u27f6 c.pt :=\n  (colimit.isColimit F).desc c", "start": [744, 1], "end": [746, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.isColimit_desc", "code": "@[simp]\ntheorem colimit.isColimit_desc {F : J \u2964 C} [HasColimit F] (c : Cocone F) :\n    (colimit.isColimit F).desc c = colimit.desc F c", "start": [749, 1], "end": [752, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.\u03b9_desc", "code": "@[reassoc (attr := simp)]\ntheorem colimit.\u03b9_desc {F : J \u2964 C} [HasColimit F] (c : Cocone F) (j : J) :\n    colimit.\u03b9 F j \u226b colimit.desc F c = c.\u03b9.app j", "start": [755, 1], "end": [767, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimMap", "code": "def colimMap {F G : J \u2964 C} [HasColimit F] [HasColimit G] (\u03b1 : F \u27f6 G) : colimit F \u27f6 colimit G :=\n  IsColimit.map (colimit.isColimit F) _ \u03b1", "start": [770, 1], "end": [777, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.\u03b9_colimMap", "code": "@[reassoc (attr := simp)]\ntheorem \u03b9_colimMap {F G : J \u2964 C} [HasColimit F] [HasColimit G] (\u03b1 : F \u27f6 G) (j : J) :\n    colimit.\u03b9 F j \u226b colimMap \u03b1 = \u03b1.app j \u226b colimit.\u03b9 G j", "start": [780, 1], "end": [783, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.coconeMorphism", "code": "def colimit.coconeMorphism {F : J \u2964 C} [HasColimit F] (c : Cocone F) : colimit.cocone F \u27f6 c :=\n  (colimit.isColimit F).descCoconeMorphism c", "start": [786, 1], "end": [788, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.coconeMorphism_hom", "code": "@[simp]\ntheorem colimit.coconeMorphism_hom {F : J \u2964 C} [HasColimit F] (c : Cocone F) :\n    (colimit.coconeMorphism c).hom = colimit.desc F c", "start": [791, 1], "end": [794, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.\u03b9_coconeMorphism", "code": "theorem colimit.\u03b9_coconeMorphism {F : J \u2964 C} [HasColimit F] (c : Cocone F) (j : J) :\n    colimit.\u03b9 F j \u226b (colimit.coconeMorphism c).hom = c.\u03b9.app j", "start": [797, 1], "end": [798, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_hom", "code": "@[reassoc (attr := simp)]\ntheorem colimit.comp_coconePointUniqueUpToIso_hom {F : J \u2964 C} [HasColimit F] {c : Cocone F}\n    (hc : IsColimit c) (j : J) :\n    colimit.\u03b9 F j \u226b (IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) hc).hom = c.\u03b9.app j", "start": [801, 1], "end": [805, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.comp_coconePointUniqueUpToIso_inv", "code": "@[reassoc (attr := simp)]\ntheorem colimit.comp_coconePointUniqueUpToIso_inv {F : J \u2964 C} [HasColimit F] {c : Cocone F}\n    (hc : IsColimit c) (j : J) :\n    colimit.\u03b9 F j \u226b (IsColimit.coconePointUniqueUpToIso hc (colimit.isColimit _)).inv = c.\u03b9.app j", "start": [808, 1], "end": [812, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.existsUnique", "code": "theorem colimit.existsUnique {F : J \u2964 C} [HasColimit F] (t : Cocone F) :\n    \u2203! d : colimit F \u27f6 t.pt, \u2200 j, colimit.\u03b9 F j \u226b d = t.\u03b9.app j", "start": [815, 1], "end": [817, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.isoColimitCocone", "code": "def colimit.isoColimitCocone {F : J \u2964 C} [HasColimit F] (t : ColimitCocone F) :\n    colimit F \u2245 t.cocone.pt :=\n  IsColimit.coconePointUniqueUpToIso (colimit.isColimit F) t.isColimit", "start": [820, 1], "end": [825, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.isoColimitCocone_\u03b9_hom", "code": "@[reassoc (attr := simp)]\ntheorem colimit.isoColimitCocone_\u03b9_hom {F : J \u2964 C} [HasColimit F] (t : ColimitCocone F) (j : J) :\n    colimit.\u03b9 F j \u226b (colimit.isoColimitCocone t).hom = t.cocone.\u03b9.app j", "start": [828, 1], "end": [832, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.isoColimitCocone_\u03b9_inv", "code": "@[reassoc (attr := simp)]\ntheorem colimit.isoColimitCocone_\u03b9_inv {F : J \u2964 C} [HasColimit F] (t : ColimitCocone F) (j : J) :\n    t.cocone.\u03b9.app j \u226b (colimit.isoColimitCocone t).inv = colimit.\u03b9 F j", "start": [835, 1], "end": [839, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.hom_ext", "code": "@[ext]\ntheorem colimit.hom_ext {F : J \u2964 C} [HasColimit F] {X : C} {f f' : colimit F \u27f6 X}\n    (w : \u2200 j, colimit.\u03b9 F j \u226b f = colimit.\u03b9 F j \u226b f') : f = f'", "start": [842, 1], "end": [845, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.desc_cocone", "code": "@[simp]\ntheorem colimit.desc_cocone {F : J \u2964 C} [HasColimit F] :\n    colimit.desc F (colimit.cocone F) = \ud835\udfd9 (colimit F)", "start": [848, 1], "end": [851, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.homIso", "code": "def colimit.homIso (F : J \u2964 C) [HasColimit F] (W : C) :\n    ULift.{u\u2081} (colimit F \u27f6 W : Type v) \u2245 F.cocones.obj W :=\n  (colimit.isColimit F).homIso W", "start": [854, 1], "end": [860, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.homIso_hom", "code": "@[simp]\ntheorem colimit.homIso_hom (F : J \u2964 C) [HasColimit F] {W : C} (f : ULift (colimit F \u27f6 W)) :\n    (colimit.homIso F W).hom f = (colimit.cocone F).\u03b9 \u226b (const J).map f.down", "start": [863, 1], "end": [866, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.homIso'", "code": "def colimit.homIso' (F : J \u2964 C) [HasColimit F] (W : C) :\n    ULift.{u\u2081} (colimit F \u27f6 W : Type v) \u2245\n      { p : \u2200 j, F.obj j \u27f6 W // \u2200 {j j'} (f : j \u27f6 j'), F.map f \u226b p j' = p j } :=\n  (colimit.isColimit F).homIso' W", "start": [869, 1], "end": [876, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.desc_extend", "code": "theorem colimit.desc_extend (F : J \u2964 C) [HasColimit F] (c : Cocone F) {X : C} (f : c.pt \u27f6 X) :\n    colimit.desc F (c.extend f) = colimit.desc F c \u226b f", "start": [879, 1], "end": [880, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimitOfIso", "code": "theorem hasColimitOfIso {F G : J \u2964 C} [HasColimit F] (\u03b1 : G \u2245 F) : HasColimit G", "start": [885, 1], "end": [899, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimit.ofCoconesIso", "code": "theorem HasColimit.ofCoconesIso {K : Type u\u2081} [Category.{v\u2082} K] (F : J \u2964 C) (G : K \u2964 C)\n    (h : F.cocones \u2245 G.cocones) [HasColimit F] : HasColimit G", "start": [902, 1], "end": [906, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimit.isoOfNatIso", "code": "def HasColimit.isoOfNatIso {F G : J \u2964 C} [HasColimit F] [HasColimit G] (w : F \u2245 G) :\n    colimit F \u2245 colimit G :=\n  IsColimit.coconePointsIsoOfNatIso (colimit.isColimit F) (colimit.isColimit G) w", "start": [909, 1], "end": [914, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimit.isoOfNatIso_\u03b9_hom", "code": "@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_\u03b9_hom {F G : J \u2964 C} [HasColimit F] [HasColimit G] (w : F \u2245 G)\n    (j : J) : colimit.\u03b9 F j \u226b (HasColimit.isoOfNatIso w).hom = w.hom.app j \u226b colimit.\u03b9 G j", "start": [917, 1], "end": [920, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimit.isoOfNatIso_\u03b9_inv", "code": "@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_\u03b9_inv {F G : J \u2964 C} [HasColimit F] [HasColimit G] (w : F \u2245 G)\n    (j : J) : colimit.\u03b9 G j \u226b (HasColimit.isoOfNatIso w).inv = w.inv.app j \u226b colimit.\u03b9 F j", "start": [923, 1], "end": [926, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimit.isoOfNatIso_hom_desc", "code": "@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_hom_desc {F G : J \u2964 C} [HasColimit F] [HasColimit G] (t : Cocone G)\n    (w : F \u2245 G) :\n    (HasColimit.isoOfNatIso w).hom \u226b colimit.desc G t =\n      colimit.desc F ((Cocones.precompose w.hom).obj _)", "start": [929, 1], "end": [934, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimit.isoOfNatIso_inv_desc", "code": "@[reassoc (attr := simp)]\ntheorem HasColimit.isoOfNatIso_inv_desc {F G : J \u2964 C} [HasColimit F] [HasColimit G] (t : Cocone F)\n    (w : F \u2245 G) :\n    (HasColimit.isoOfNatIso w).inv \u226b colimit.desc F t =\n      colimit.desc G ((Cocones.precompose w.inv).obj _)", "start": [937, 1], "end": [942, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimit.isoOfEquivalence", "code": "def HasColimit.isoOfEquivalence {F : J \u2964 C} [HasColimit F] {G : K \u2964 C} [HasColimit G] (e : J \u224c K)\n    (w : e.functor \u22d9 G \u2245 F) : colimit F \u2245 colimit G :=\n  IsColimit.coconePointsIsoOfEquivalence (colimit.isColimit F) (colimit.isColimit G) e w", "start": [945, 1], "end": [950, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimit.isoOfEquivalence_hom_\u03c0", "code": "@[simp]\ntheorem HasColimit.isoOfEquivalence_hom_\u03c0 {F : J \u2964 C} [HasColimit F] {G : K \u2964 C} [HasColimit G]\n    (e : J \u224c K) (w : e.functor \u22d9 G \u2245 F) (j : J) :\n    colimit.\u03b9 F j \u226b (HasColimit.isoOfEquivalence e w).hom =\n      F.map (e.unit.app j) \u226b w.inv.app _ \u226b colimit.\u03b9 G _", "start": [953, 1], "end": [958, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasColimit.isoOfEquivalence_inv_\u03c0", "code": "@[simp]\ntheorem HasColimit.isoOfEquivalence_inv_\u03c0 {F : J \u2964 C} [HasColimit F] {G : K \u2964 C} [HasColimit G]\n    (e : J \u224c K) (w : e.functor \u22d9 G \u2245 F) (k : K) :\n    colimit.\u03b9 G k \u226b (HasColimit.isoOfEquivalence e w).inv =\n      G.map (e.counitInv.app k) \u226b w.hom.app (e.inverse.obj k) \u226b colimit.\u03b9 F (e.inverse.obj k)", "start": [961, 1], "end": [966, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.pre", "code": "def colimit.pre : colimit (E \u22d9 F) \u27f6 colimit F :=\n  colimit.desc (E \u22d9 F) ((colimit.cocone F).whisker E)", "start": [973, 1], "end": [976, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.\u03b9_pre", "code": "@[reassoc (attr := simp)]\ntheorem colimit.\u03b9_pre (k : K) : colimit.\u03b9 (E \u22d9 F) k \u226b colimit.pre F E = colimit.\u03b9 F (E.obj k)", "start": [979, 1], "end": [982, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.pre_desc", "code": "@[reassoc (attr := simp)]\ntheorem colimit.pre_desc (c : Cocone F) :\n    colimit.pre F E \u226b colimit.desc F c = colimit.desc (E \u22d9 F) (c.whisker E)", "start": [985, 1], "end": [988, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.pre_pre", "code": "@[simp]\ntheorem colimit.pre_pre [h : HasColimit (D \u22d9 E \u22d9 F)] :\n    haveI : HasColimit ((D \u22d9 E) \u22d9 F) := h\n    colimit.pre (E \u22d9 F) D \u226b colimit.pre F E = colimit.pre F (D \u22d9 E)", "start": [995, 1], "end": [1002, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.pre_eq", "code": "theorem colimit.pre_eq (s : ColimitCocone (E \u22d9 F)) (t : ColimitCocone F) :\n    colimit.pre F E =\n      (colimit.isoColimitCocone s).hom \u226b\n        s.isColimit.desc (t.cocone.whisker E) \u226b (colimit.isoColimitCocone t).inv", "start": [1007, 1], "end": [1015, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.post", "code": "def colimit.post : colimit (F \u22d9 G) \u27f6 G.obj (colimit F) :=\n  colimit.desc (F \u22d9 G) (G.mapCocone (colimit.cocone F))", "start": [1026, 1], "end": [1030, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.\u03b9_post", "code": "@[reassoc (attr := simp)]\ntheorem colimit.\u03b9_post (j : J) :\n    colimit.\u03b9 (F \u22d9 G) j \u226b colimit.post F G = G.map (colimit.\u03b9 F j)", "start": [1033, 1], "end": [1037, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.post_desc", "code": "@[simp]\ntheorem colimit.post_desc (c : Cocone F) :\n    colimit.post F G \u226b G.map (colimit.desc F c) = colimit.desc (F \u22d9 G) (G.mapCocone c)", "start": [1040, 1], "end": [1045, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.post_post", "code": "@[simp]\ntheorem colimit.post_post {E : Type u''} [Category.{v''} E] (H : D \u2964 E)\n    [h : HasColimit ((F \u22d9 G) \u22d9 H)] : haveI : HasColimit (F \u22d9 G \u22d9 H) := h\n    colimit.post (F \u22d9 G) H \u226b H.map (colimit.post F G) = colimit.post F (G \u22d9 H)", "start": [1048, 1], "end": [1057, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.pre_post", "code": "theorem colimit.pre_post {D : Type u'} [Category.{v'} D] (E : K \u2964 J) (F : J \u2964 C) (G : C \u2964 D)\n    [HasColimit F] [HasColimit (E \u22d9 F)] [HasColimit (F \u22d9 G)] [h : HasColimit ((E \u22d9 F) \u22d9 G)] :\n    haveI : HasColimit (E \u22d9 F \u22d9 G) := h\n    colimit.post (E \u22d9 F) G \u226b G.map (colimit.pre F E) =\n      colimit.pre (F \u22d9 G) E \u226b colimit.post F G", "start": [1062, 1], "end": [1072, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimit_equivalence_comp", "code": "instance hasColimit_equivalence_comp (e : K \u224c J) [HasColimit F] : HasColimit (e.functor \u22d9 F) :=\n  HasColimit.mk\n    { cocone := Cocone.whisker e.functor (colimit.cocone F)\n      isColimit := IsColimit.whiskerEquivalence (colimit.isColimit F) e }", "start": [1077, 1], "end": [1080, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimit_of_equivalence_comp", "code": "theorem hasColimit_of_equivalence_comp (e : K \u224c J) [HasColimit (e.functor \u22d9 F)] : HasColimit F", "start": [1083, 1], "end": [1087, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colim", "code": "@[simps] def colim : (J \u2964 C) \u2964 C where\n  obj F := colimit F\n  map \u03b1 := colimMap \u03b1", "start": [1098, 1], "end": [1102, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.\u03b9_map", "code": "@[reassoc]\ntheorem colimit.\u03b9_map (j : J) : colimit.\u03b9 F j \u226b colim.map \u03b1 = \u03b1.app j \u226b colimit.\u03b9 G j", "start": [1110, 1], "end": [1111, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.map_desc", "code": "@[simp] theorem colimit.map_desc (c : Cocone G) :\n    colimMap \u03b1 \u226b colimit.desc G c = colimit.desc F ((Cocones.precompose \u03b1).obj c)", "start": [1114, 1], "end": [1118, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.pre_map", "code": "theorem colimit.pre_map [HasColimitsOfShape K C] (E : K \u2964 J) :\n    colimit.pre F E \u226b colim.map \u03b1 = colim.map (whiskerLeft E \u03b1) \u226b colimit.pre G E", "start": [1121, 1], "end": [1125, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.pre_map'", "code": "theorem colimit.pre_map' [HasColimitsOfShape K C] (F : J \u2964 C) {E\u2081 E\u2082 : K \u2964 J} (\u03b1 : E\u2081 \u27f6 E\u2082) :\n    colimit.pre F E\u2081 = colim.map (whiskerRight \u03b1 F) \u226b colimit.pre F E\u2082", "start": [1128, 1], "end": [1130, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.pre_id", "code": "theorem colimit.pre_id (F : J \u2964 C) : colimit.pre F (\ud835\udfed _) = colim.map (Functor.leftUnitor F).hom", "start": [1133, 1], "end": [1134, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.map_post", "code": "theorem colimit.map_post {D : Type u'} [Category.{v'} D] [HasColimitsOfShape J D]\n    (H : C \u2964 D) :\n          colimit.post\n          F H \u226b\n        H.map (colim.map \u03b1) =\n      colim.map (whiskerRight \u03b1 H) \u226b colimit.post G H", "start": [1137, 1], "end": [1147, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimCoyoneda", "code": "def colimCoyoneda : colim.op \u22d9 coyoneda \u22d9 (whiskeringRight _ _ _).obj uliftFunctor.{u\u2081}\n    \u2245 CategoryTheory.cocones J C :=\n  NatIso.ofComponents fun F => NatIso.ofComponents fun W => colimit.homIso (unop F) W", "start": [1150, 1], "end": [1157, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimConstAdj", "code": "def colimConstAdj : (colim : (J \u2964 C) \u2964 C) \u22a3 const J where\n  homEquiv f c :=\n    { toFun := fun g =>\n        { app := fun _ => colimit.\u03b9 _ _ \u226b g }\n      invFun := fun g => colimit.desc _ \u27e8_, g\u27e9\n      left_inv := by aesop_cat\n      right_inv := by aesop_cat }\n  unit := { app := fun g => { app := colimit.\u03b9 _ } }\n  counit := { app := fun c => colimit.desc _ \u27e8_, \ud835\udfd9 _\u27e9 }", "start": [1160, 1], "end": [1170, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimMap_epi'", "code": "instance colimMap_epi' {F G : J \u2964 C} [HasColimitsOfShape J C] (\u03b1 : F \u27f6 G) [Epi \u03b1] :\n    Epi (colimMap \u03b1) :=\n  (colim : (J \u2964 C) \u2964 C).map_epi \u03b1", "start": [1178, 1], "end": [1180, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimMap_epi", "code": "instance colimMap_epi {F G : J \u2964 C} [HasColimit F] [HasColimit G] (\u03b1 : F \u27f6 G) [\u2200 j, Epi (\u03b1.app j)] :\n    Epi (colimMap \u03b1) :=\n  \u27e8fun {Z} u v h =>\n    colimit.hom_ext fun j => (cancel_epi (\u03b1.app j)).1 <| by simpa using colimit.\u03b9 _ j \u226b= h\u27e9", "start": [1183, 1], "end": [1186, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimitsOfShape_of_equivalence", "code": "theorem hasColimitsOfShape_of_equivalence {J' : Type u\u2082} [Category.{v\u2082} J'] (e : J \u224c J')\n    [HasColimitsOfShape J C] : HasColimitsOfShape J' C", "start": [1189, 1], "end": [1195, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimitsOfSize_shrink", "code": "theorem hasColimitsOfSize_shrink [HasColimitsOfSize.{max v\u2081 v\u2082, max u\u2081 u\u2082} C] :\n    HasColimitsOfSize.{v\u2081, u\u2081} C", "start": [1200, 1], "end": [1205, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasSmallestColimitsOfHasColimits", "code": "instance (priority := 100) hasSmallestColimitsOfHasColimits [HasColimits C] :\n    HasColimitsOfSize.{0, 0} C :=\n  hasColimitsOfSize_shrink.{0, 0} C", "start": [1208, 1], "end": [1210, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.op", "code": "def IsLimit.op {t : Cone F} (P : IsLimit t) : IsColimit t.op where\n  desc s := (P.lift s.unop).op\n  fac s j := congrArg Quiver.Hom.op (P.fac s.unop (unop j))\n  uniq s m w := by\n    dsimp\n    rw [\u2190 P.uniq s.unop m.unop]\n    \u00b7 rfl\n    \u00b7 dsimp\n      intro j\n      rw [\u2190 w]\n      rfl", "start": [1217, 1], "end": [1229, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.op", "code": "def IsColimit.op {t : Cocone F} (P : IsColimit t) : IsLimit t.op where\n  lift s := (P.desc s.unop).op\n  fac s j := congrArg Quiver.Hom.op (P.fac s.unop (unop j))\n  uniq s m w := by\n    dsimp\n    rw [\u2190 P.uniq s.unop m.unop]\n    \u00b7 rfl\n    \u00b7 dsimp\n      intro j\n      rw [\u2190 w]\n      rfl", "start": [1232, 1], "end": [1244, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.unop", "code": "def IsLimit.unop {t : Cone F.op} (P : IsLimit t) : IsColimit t.unop where\n  desc s := (P.lift s.op).unop\n  fac s j := congrArg Quiver.Hom.unop (P.fac s.op (Opposite.op j))\n  uniq s m w := by\n    dsimp\n    rw [\u2190 P.uniq s.op m.op]\n    \u00b7 rfl\n    \u00b7 dsimp\n      intro j\n      rw [\u2190 w]\n      rfl", "start": [1247, 1], "end": [1260, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.unop", "code": "def IsColimit.unop {t : Cocone F.op} (P : IsColimit t) : IsLimit t.unop where\n  lift s := (P.desc s.op).unop\n  fac s j := congrArg Quiver.Hom.unop (P.fac s.op (Opposite.op j))\n  uniq s m w := by\n    dsimp\n    rw [\u2190 P.uniq s.op m.op]\n    \u00b7 rfl\n    \u00b7 dsimp\n      intro j\n      rw [\u2190 w]\n      rfl", "start": [1263, 1], "end": [1276, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitEquivIsColimitOp", "code": "def isLimitEquivIsColimitOp {t : Cone F} : IsLimit t \u2243 IsColimit t.op :=\n  equivOfSubsingletonOfSubsingleton IsLimit.op fun P =>\n    P.unop.ofIsoLimit (Cones.ext (Iso.refl _))", "start": [1279, 1], "end": [1283, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitEquivIsLimitOp", "code": "def isColimitEquivIsLimitOp {t : Cocone F} : IsColimit t \u2243 IsLimit t.op :=\n  equivOfSubsingletonOfSubsingleton IsColimit.op fun P =>\n    P.unop.ofIsoColimit (Cocones.ext (Iso.refl _))", "start": [1286, 1], "end": [1290, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Skeletal.lean", "imports": ["Mathlib/CategoryTheory/Thin.lean", "Mathlib/CategoryTheory/Adjunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/IsomorphismClasses.lean", "Mathlib/CategoryTheory/Category/Preorder.lean"], "premises": [{"full_name": "CategoryTheory.Skeletal", "code": "def Skeletal : Prop :=\n  \u2200 \u2983X Y : C\u2984, IsIsomorphic X Y \u2192 X = Y", "start": [41, 1], "end": [43, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSkeletonOf", "code": "structure IsSkeletonOf (F : D \u2964 C) where\n  \n  skel : Skeletal D\n  \n  eqv : IsEquivalence F", "start": [46, 1], "end": [53, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.eq_of_iso", "code": "theorem Functor.eq_of_iso {F\u2081 F\u2082 : D \u2964 C} [Quiver.IsThin C] (hC : Skeletal C) (hF : F\u2081 \u2245 F\u2082) :\n    F\u2081 = F\u2082", "start": [60, 1], "end": [63, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.functor_skeletal", "code": "theorem functor_skeletal [Quiver.IsThin C] (hC : Skeletal C) : Skeletal (D \u2964 C)", "start": [66, 1], "end": [70, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Skeleton", "code": "def Skeleton : Type u\u2081 := InducedCategory C Quotient.out", "start": [75, 1], "end": [78, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.fromSkeleton", "code": "@[simps!]\nnoncomputable def fromSkeleton : Skeleton C \u2964 C :=\n  inducedFunctor _", "start": [88, 1], "end": [91, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.fromSkeleton.isEquivalence", "code": "noncomputable instance fromSkeleton.isEquivalence : IsEquivalence (fromSkeleton C) :=\n  Equivalence.ofFullyFaithfullyEssSurj (fromSkeleton C)", "start": [103, 1], "end": [104, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.skeletonEquivalence", "code": "noncomputable def skeletonEquivalence : Skeleton C \u224c C :=\n  (fromSkeleton C).asEquivalence", "start": [106, 1], "end": [108, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.skeleton_skeletal", "code": "theorem skeleton_skeletal : Skeletal (Skeleton C)", "start": [111, 1], "end": [114, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.skeletonIsSkeleton", "code": "noncomputable def skeletonIsSkeleton : IsSkeletonOf C (Skeleton C) (fromSkeleton C) where\n  skel := skeleton_skeletal C\n  eqv := fromSkeleton.isEquivalence C", "start": [117, 1], "end": [120, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.skeletonEquiv", "code": "noncomputable def Equivalence.skeletonEquiv (e : C \u224c D) : Skeleton C \u2243 Skeleton D :=\n  let f := ((skeletonEquivalence C).trans e).trans (skeletonEquivalence D).symm\n  { toFun := f.functor.obj\n    invFun := f.inverse.obj\n    left_inv := fun X => skeleton_skeletal C \u27e8(f.unitIso.app X).symm\u27e9\n    right_inv := fun Y => skeleton_skeletal D \u27e8f.counitIso.app Y\u27e9 }", "start": [127, 1], "end": [134, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton", "code": "def ThinSkeleton : Type u\u2081 :=\n  Quotient (isIsomorphicSetoid C)", "start": [139, 1], "end": [144, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.inhabitedThinSkeleton", "code": "instance inhabitedThinSkeleton [Inhabited C] : Inhabited (ThinSkeleton C) :=\n  \u27e8@Quotient.mk' C (isIsomorphicSetoid C) default\u27e9", "start": [147, 1], "end": [148, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.preorder", "code": "instance ThinSkeleton.preorder : Preorder (ThinSkeleton C)\n    where\n  le :=\n    @Quotient.lift\u2082 C C _ (isIsomorphicSetoid C) (isIsomorphicSetoid C)\n      (fun X Y => Nonempty (X \u27f6 Y))\n        (by\n          rintro _ _ _ _ \u27e8i\u2081\u27e9 \u27e8i\u2082\u27e9\n          exact\n            propext\n              \u27e8Nonempty.map fun f => i\u2081.inv \u226b f \u226b i\u2082.hom,\n                Nonempty.map fun f => i\u2081.hom \u226b f \u226b i\u2082.inv\u27e9)\n  le_refl := by\n    refine' Quotient.ind fun a => _\n    exact \u27e8\ud835\udfd9 _\u27e9\n  le_trans a b c := Quotient.inductionOn\u2083 a b c fun A B C => Nonempty.map2 (\u00b7 \u226b \u00b7)", "start": [151, 1], "end": [165, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.toThinSkeleton", "code": "@[simps]\ndef toThinSkeleton : C \u2964 ThinSkeleton C where\n  obj := @Quotient.mk' C _\n  map f := homOfLE (Nonempty.intro f)", "start": [168, 1], "end": [172, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.thin", "code": "instance thin : Quiver.IsThin (ThinSkeleton C) := fun _ _ =>\n  \u27e8by\n    rintro \u27e8\u27e8f\u2081\u27e9\u27e9 \u27e8\u27e8_\u27e9\u27e9\n    rfl\u27e9", "start": [183, 1], "end": [187, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.map", "code": "@[simps]\ndef map (F : C \u2964 D) : ThinSkeleton C \u2964 ThinSkeleton D where\n  obj := Quotient.map F.obj fun X\u2081 X\u2082 \u27e8hX\u27e9 => \u27e8F.mapIso hX\u27e9\n  map {X} {Y} := Quotient.recOnSubsingleton\u2082 X Y fun x y k => homOfLE (k.le.elim fun t => \u27e8F.map t\u27e9)", "start": [192, 1], "end": [196, 101], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.comp_toThinSkeleton", "code": "theorem comp_toThinSkeleton (F : C \u2964 D) : F \u22d9 toThinSkeleton D = toThinSkeleton C \u22d9 map F", "start": [199, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.mapNatTrans", "code": "def mapNatTrans {F\u2081 F\u2082 : C \u2964 D} (k : F\u2081 \u27f6 F\u2082) : map F\u2081 \u27f6 map F\u2082 where\n  app X := Quotient.recOnSubsingleton X fun x => \u27e8\u27e8\u27e8k.app x\u27e9\u27e9\u27e9", "start": [203, 1], "end": [205, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.map\u2082ObjMap", "code": "def map\u2082ObjMap (F : C \u2964 D \u2964 E) : ThinSkeleton C \u2192 ThinSkeleton D \u2192 ThinSkeleton E :=\n  fun x y =>\n    @Quotient.map\u2082 C D (isIsomorphicSetoid C) (isIsomorphicSetoid D) E (isIsomorphicSetoid E)\n      (fun X Y => (F.obj X).obj Y)\n          (fun X\u2081 _ \u27e8hX\u27e9 _ Y\u2082 \u27e8hY\u27e9 => \u27e8(F.obj X\u2081).mapIso hY \u226a\u226b (F.mapIso hX).app Y\u2082\u27e9) x y", "start": [219, 1], "end": [224, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.map\u2082Functor", "code": "def map\u2082Functor (F : C \u2964 D \u2964 E) : ThinSkeleton C \u2192 ThinSkeleton D \u2964 ThinSkeleton E :=\n  fun x =>\n    { obj := fun y => map\u2082ObjMap F x y\n      map := fun {y\u2081} {y\u2082} => @Quotient.recOnSubsingleton C (isIsomorphicSetoid C)\n        (fun x => (y\u2081 \u27f6 y\u2082) \u2192 (map\u2082ObjMap F x y\u2081 \u27f6 map\u2082ObjMap F x y\u2082)) _ x fun X\n          => Quotient.recOnSubsingleton\u2082 y\u2081 y\u2082 fun Y\u2081 Y\u2082 hY =>\n            homOfLE (hY.le.elim fun g => \u27e8(F.obj X).map g\u27e9) }", "start": [226, 1], "end": [233, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.map\u2082NatTrans", "code": "def map\u2082NatTrans (F : C \u2964 D \u2964 E) : {x\u2081 x\u2082 : ThinSkeleton C} \u2192 (x\u2081 \u27f6 x\u2082) \u2192\n    (map\u2082Functor F x\u2081 \u27f6 map\u2082Functor F x\u2082) := fun {x\u2081} {x\u2082} =>\n  @Quotient.recOnSubsingleton\u2082 C C (isIsomorphicSetoid C) (isIsomorphicSetoid C)\n    (fun x x' : ThinSkeleton C => (x \u27f6 x') \u2192 (map\u2082Functor F x \u27f6 map\u2082Functor F x')) _ x\u2081 x\u2082\n    (fun X\u2081 X\u2082 f => { app := fun y =>\n      Quotient.recOnSubsingleton y fun Y => homOfLE (f.le.elim fun f' => \u27e8(F.map f').app Y\u27e9) })", "start": [235, 1], "end": [242, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.map\u2082", "code": "@[simps]\ndef map\u2082 (F : C \u2964 D \u2964 E) : ThinSkeleton C \u2964 ThinSkeleton D \u2964 ThinSkeleton E where\n  obj := map\u2082Functor F\n  map := map\u2082NatTrans F", "start": [245, 1], "end": [250, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.toThinSkeleton_faithful", "code": "instance toThinSkeleton_faithful : Faithful (toThinSkeleton C) where", "start": [259, 1], "end": [259, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.fromThinSkeleton", "code": "@[simps]\nnoncomputable def fromThinSkeleton : ThinSkeleton C \u2964 C where\n  obj := Quotient.out\n  map {x} {y} :=\n    Quotient.recOnSubsingleton\u2082 x y fun X Y f =>\n      (Nonempty.some (Quotient.mk_out X)).hom \u226b f.le.some \u226b (Nonempty.some (Quotient.mk_out Y)).inv", "start": [262, 1], "end": [268, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.fromThinSkeletonEquivalence", "code": "noncomputable instance fromThinSkeletonEquivalence : IsEquivalence (fromThinSkeleton C) where\n  inverse := toThinSkeleton C\n  counitIso := NatIso.ofComponents fun X => Nonempty.some (Quotient.mk_out X)\n  unitIso := NatIso.ofComponents fun x => Quotient.recOnSubsingleton x fun X =>\n    eqToIso (Quotient.sound \u27e8(Nonempty.some (Quotient.mk_out X)).symm\u27e9)", "start": [271, 1], "end": [275, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.equivalence", "code": "noncomputable def equivalence : ThinSkeleton C \u224c C :=\n  (fromThinSkeleton C).asEquivalence", "start": [278, 1], "end": [280, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.equiv_of_both_ways", "code": "theorem equiv_of_both_ways {X Y : C} (f : X \u27f6 Y) (g : Y \u27f6 X) : X \u2248 Y", "start": [285, 1], "end": [286, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.thinSkeletonPartialOrder", "code": "instance thinSkeletonPartialOrder : PartialOrder (ThinSkeleton C) :=\n  { CategoryTheory.ThinSkeleton.preorder C with\n    le_antisymm :=\n      Quotient.ind\u2082\n        (by\n          rintro _ _ \u27e8f\u27e9 \u27e8g\u27e9\n          apply Quotient.sound (equiv_of_both_ways f g)) }", "start": [289, 1], "end": [295, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.skeletal", "code": "theorem skeletal : Skeletal (ThinSkeleton C)", "start": [298, 1], "end": [299, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.map_comp_eq", "code": "theorem map_comp_eq (F : E \u2964 D) (G : D \u2964 C) : map (F \u22d9 G) = map F \u22d9 map G", "start": [302, 1], "end": [304, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.map_id_eq", "code": "theorem map_id_eq : map (\ud835\udfed C) = \ud835\udfed (ThinSkeleton C)", "start": [307, 1], "end": [309, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.map_iso_eq", "code": "theorem map_iso_eq {F\u2081 F\u2082 : D \u2964 C} (h : F\u2081 \u2245 F\u2082) : map F\u2081 = map F\u2082", "start": [312, 1], "end": [315, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.thinSkeletonIsSkeleton", "code": "noncomputable def thinSkeletonIsSkeleton : IsSkeletonOf C (ThinSkeleton C) (fromThinSkeleton C)\n    where\n  skel := skeletal\n  eqv := ThinSkeleton.fromThinSkeletonEquivalence C", "start": [318, 1], "end": [322, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.isSkeletonOfInhabited", "code": "noncomputable instance isSkeletonOfInhabited :\n    Inhabited (IsSkeletonOf C (ThinSkeleton C) (fromThinSkeleton C)) :=\n  \u27e8thinSkeletonIsSkeleton\u27e9", "start": [325, 1], "end": [327, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ThinSkeleton.lowerAdjunction", "code": "def lowerAdjunction (R : D \u2964 C) (L : C \u2964 D) (h : L \u22a3 R) : ThinSkeleton.map L \u22a3 ThinSkeleton.map R :=\n  Adjunction.mkOfUnitCounit\n    { unit :=\n        {\n          app := fun X => by\n            letI := isIsomorphicSetoid C\n            refine' Quotient.recOnSubsingleton X fun x => homOfLE \u27e8h.unit.app x\u27e9 }\n      counit :=\n        {\n          app := fun X => by\n            letI := isIsomorphicSetoid D\n            refine' Quotient.recOnSubsingleton X fun x => homOfLE \u27e8h.counit.app x\u27e9 } }", "start": [334, 1], "end": [347, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.thinSkeletonOrderIso", "code": "noncomputable def Equivalence.thinSkeletonOrderIso [Quiver.IsThin C] (e : C \u224c \u03b1) :\n    ThinSkeleton C \u2243o \u03b1 :=\n  ((ThinSkeleton.equivalence C).trans e).toOrderIso", "start": [358, 1], "end": [364, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/Bifunctor.lean", "imports": ["Mathlib/Control/Functor.lean", "Mathlib/Data/Sum/Basic.lean", "Mathlib/Tactic/Common.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Bifunctor", "code": "class Bifunctor (F : Type u\u2080 \u2192 Type u\u2081 \u2192 Type u\u2082) where\n  bimap : \u2200 {\u03b1 \u03b1' \u03b2 \u03b2'}, (\u03b1 \u2192 \u03b1') \u2192 (\u03b2 \u2192 \u03b2') \u2192 F \u03b1 \u03b2 \u2192 F \u03b1' \u03b2'", "start": [33, 1], "end": [35, 63], "kind": "commanddeclaration"}, {"full_name": "LawfulBifunctor", "code": "class LawfulBifunctor (F : Type u\u2080 \u2192 Type u\u2081 \u2192 Type u\u2082) [Bifunctor F] : Prop where\n  id_bimap : \u2200 {\u03b1 \u03b2} (x : F \u03b1 \u03b2), bimap id id x = x\n  bimap_bimap :\n    \u2200 {\u03b1\u2080 \u03b1\u2081 \u03b1\u2082 \u03b2\u2080 \u03b2\u2081 \u03b2\u2082} (f : \u03b1\u2080 \u2192 \u03b1\u2081) (f' : \u03b1\u2081 \u2192 \u03b1\u2082) (g : \u03b2\u2080 \u2192 \u03b2\u2081) (g' : \u03b2\u2081 \u2192 \u03b2\u2082) (x : F \u03b1\u2080 \u03b2\u2080),\n      bimap f' g' (bimap f g x) = bimap (f' \u2218 f) (g' \u2218 g) x", "start": [40, 1], "end": [45, 60], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.fst", "code": "@[reducible]\ndef fst {\u03b1 \u03b1' \u03b2} (f : \u03b1 \u2192 \u03b1') : F \u03b1 \u03b2 \u2192 F \u03b1' \u03b2 :=\n  bimap f id", "start": [62, 1], "end": [65, 13], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.snd", "code": "@[reducible]\ndef snd {\u03b1 \u03b2 \u03b2'} (f : \u03b2 \u2192 \u03b2') : F \u03b1 \u03b2 \u2192 F \u03b1 \u03b2' :=\n  bimap id f", "start": [68, 1], "end": [71, 13], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.id_fst", "code": "@[higher_order fst_id]\ntheorem id_fst : \u2200 {\u03b1 \u03b2} (x : F \u03b1 \u03b2), fst id x = x", "start": [76, 1], "end": [78, 18], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.id_snd", "code": "@[higher_order snd_id]\ntheorem id_snd : \u2200 {\u03b1 \u03b2} (x : F \u03b1 \u03b2), snd id x = x", "start": [82, 1], "end": [84, 18], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.comp_fst", "code": "@[higher_order fst_comp_fst]\ntheorem comp_fst {\u03b1\u2080 \u03b1\u2081 \u03b1\u2082 \u03b2} (f : \u03b1\u2080 \u2192 \u03b1\u2081) (f' : \u03b1\u2081 \u2192 \u03b1\u2082) (x : F \u03b1\u2080 \u03b2) :\n    fst f' (fst f x) = fst (f' \u2218 f) x", "start": [88, 1], "end": [90, 68], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.fst_snd", "code": "@[higher_order fst_comp_snd]\ntheorem fst_snd {\u03b1\u2080 \u03b1\u2081 \u03b2\u2080 \u03b2\u2081} (f : \u03b1\u2080 \u2192 \u03b1\u2081) (f' : \u03b2\u2080 \u2192 \u03b2\u2081) (x : F \u03b1\u2080 \u03b2\u2080) :\n    fst f (snd f' x) = bimap f f' x", "start": [94, 1], "end": [96, 66], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.snd_fst", "code": "@[higher_order snd_comp_fst]\ntheorem snd_fst {\u03b1\u2080 \u03b1\u2081 \u03b2\u2080 \u03b2\u2081} (f : \u03b1\u2080 \u2192 \u03b1\u2081) (f' : \u03b2\u2080 \u2192 \u03b2\u2081) (x : F \u03b1\u2080 \u03b2\u2080) :\n    snd f' (fst f x) = bimap f f' x", "start": [100, 1], "end": [102, 66], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.comp_snd", "code": "@[higher_order snd_comp_snd]\ntheorem comp_snd {\u03b1 \u03b2\u2080 \u03b2\u2081 \u03b2\u2082} (g : \u03b2\u2080 \u2192 \u03b2\u2081) (g' : \u03b2\u2081 \u2192 \u03b2\u2082) (x : F \u03b1 \u03b2\u2080) :\n    snd g' (snd g x) = snd (g' \u2218 g) x", "start": [106, 1], "end": [108, 68], "kind": "commanddeclaration"}, {"full_name": "Prod.bifunctor", "code": "instance Prod.bifunctor : Bifunctor Prod where bimap := @Prod.map", "start": [120, 1], "end": [120, 66], "kind": "commanddeclaration"}, {"full_name": "Prod.lawfulBifunctor", "code": "instance Prod.lawfulBifunctor : LawfulBifunctor Prod := by\n  refine' { .. } <;> intros <;> rfl", "start": [123, 1], "end": [124, 36], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.const", "code": "instance Bifunctor.const : Bifunctor Const where bimap f _ := f", "start": [127, 1], "end": [127, 64], "kind": "commanddeclaration"}, {"full_name": "LawfulBifunctor.const", "code": "instance LawfulBifunctor.const : LawfulBifunctor Const := by refine' { .. } <;> intros <;> rfl", "start": [130, 1], "end": [130, 95], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.flip", "code": "instance Bifunctor.flip : Bifunctor (flip F) where\n  bimap {_\u03b1 \u03b1' _\u03b2 \u03b2'} f f' x := (bimap f' f x : F \u03b2' \u03b1')", "start": [133, 1], "end": [134, 57], "kind": "commanddeclaration"}, {"full_name": "LawfulBifunctor.flip", "code": "instance LawfulBifunctor.flip [LawfulBifunctor F] : LawfulBifunctor (flip F) := by\n  refine' { .. } <;> intros <;> simp [bimap, functor_norm]", "start": [137, 1], "end": [138, 59], "kind": "commanddeclaration"}, {"full_name": "Sum.bifunctor", "code": "instance Sum.bifunctor : Bifunctor Sum where bimap := @Sum.map", "start": [141, 1], "end": [141, 63], "kind": "commanddeclaration"}, {"full_name": "Sum.lawfulBifunctor", "code": "instance Sum.lawfulBifunctor : LawfulBifunctor Sum := by\n  refine' { .. } <;> aesop", "start": [144, 1], "end": [145, 27], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.functor", "code": "instance (priority := 10) Bifunctor.functor {\u03b1} : Functor (F \u03b1) where map f x := snd f x", "start": [150, 1], "end": [150, 89], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.lawfulFunctor", "code": "instance (priority := 10) Bifunctor.lawfulFunctor [LawfulBifunctor F] {\u03b1} : LawfulFunctor (F \u03b1) :=\n  by refine' { .. } <;> intros <;> simp [mapConst, Functor.map, functor_norm]", "start": [153, 1], "end": [155, 78], "kind": "commanddeclaration"}, {"full_name": "Function.bicompl.bifunctor", "code": "instance Function.bicompl.bifunctor : Bifunctor (bicompl F G H) where\n  bimap {_\u03b1 \u03b1' _\u03b2 \u03b2'} f f' x := (bimap (map f) (map f') x : F (G \u03b1') (H \u03b2'))", "start": [162, 1], "end": [163, 77], "kind": "commanddeclaration"}, {"full_name": "Function.bicompl.lawfulBifunctor", "code": "instance Function.bicompl.lawfulBifunctor [LawfulFunctor G] [LawfulFunctor H] [LawfulBifunctor F] :\n    LawfulBifunctor (bicompl F G H) := by\n  constructor <;> intros <;> simp [bimap, map_id, map_comp_map, functor_norm]", "start": [166, 1], "end": [168, 78], "kind": "commanddeclaration"}, {"full_name": "Function.bicompr.bifunctor", "code": "instance Function.bicompr.bifunctor : Bifunctor (bicompr G F) where\n  bimap {_\u03b1 \u03b1' _\u03b2 \u03b2'} f f' x := (map (bimap f f') x : G (F \u03b1' \u03b2'))", "start": [177, 1], "end": [178, 67], "kind": "commanddeclaration"}, {"full_name": "Function.bicompr.lawfulBifunctor", "code": "instance Function.bicompr.lawfulBifunctor [LawfulFunctor G] [LawfulBifunctor F] :\n    LawfulBifunctor (bicompr G F) := by\n  constructor <;> intros <;> simp [bimap, functor_norm]", "start": [181, 1], "end": [183, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Polynomial.lean", "imports": ["Mathlib/Algebra/Polynomial/BigOperators.lean", "Mathlib/Data/Polynomial/Degree/Lemmas.lean", "Mathlib/LinearAlgebra/Matrix/Determinant.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/ComputeDegree.lean"], "premises": [{"full_name": "Polynomial.natDegree_det_X_add_C_le", "code": "theorem natDegree_det_X_add_C_le (A B : Matrix n n \u03b1) :\n    natDegree (det ((X : \u03b1[X]) \u2022 A.map C + B.map C)) \u2264 Fintype.card n", "start": [39, 1], "end": [58, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_det_X_add_C_zero", "code": "theorem coeff_det_X_add_C_zero (A B : Matrix n n \u03b1) :\n    coeff (det ((X : \u03b1[X]) \u2022 A.map C + B.map C)) 0 = det B", "start": [61, 1], "end": [69, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_det_X_add_C_card", "code": "theorem coeff_det_X_add_C_card (A B : Matrix n n \u03b1) :\n    coeff (det ((X : \u03b1[X]) \u2022 A.map C + B.map C)) (Fintype.card n) = det A", "start": [72, 1], "end": [85, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_det_X_one_add_C", "code": "theorem leadingCoeff_det_X_one_add_C (A : Matrix n n \u03b1) :\n    leadingCoeff (det ((X : \u03b1[X]) \u2022 (1 : Matrix n n \u03b1[X]) + A.map C)) = 1", "start": [88, 1], "end": [101, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Polynomial/Basic.lean", "imports": ["Mathlib/RingTheory/Ideal/QuotientOperations.lean", "Mathlib/Algebra/CharP/Basic.lean", "Mathlib/RingTheory/Polynomial/Content.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/MvPolynomial/CommRing.lean", "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "Mathlib/Data/MvPolynomial/Equiv.lean", "Mathlib/Algebra/GeomSum.lean"], "premises": [{"full_name": "Polynomial.degreeLE", "code": "def degreeLE (n : WithBot \u2115) : Submodule R R[X] :=\n  \u2a05 k : \u2115, \u2a05 _ : \u2191k > n, LinearMap.ker (lcoeff R k)", "start": [53, 1], "end": [55, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degreeLT", "code": "def degreeLT (n : \u2115) : Submodule R R[X] :=\n  \u2a05 k : \u2115, \u2a05 (_ : k \u2265 n), LinearMap.ker (lcoeff R k)", "start": [58, 1], "end": [60, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_degreeLE", "code": "theorem mem_degreeLE {n : WithBot \u2115} {f : R[X]} : f \u2208 degreeLE R n \u2194 degree f \u2264 n", "start": [65, 1], "end": [66, 93], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degreeLE_mono", "code": "@[mono]\ntheorem degreeLE_mono {m n : WithBot \u2115} (H : m \u2264 n) : degreeLE R m \u2264 degreeLE R n", "start": [69, 1], "end": [71, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degreeLE_eq_span_X_pow", "code": "theorem degreeLE_eq_span_X_pow [DecidableEq R] {n : \u2115} :\n    degreeLE R n = Submodule.span R \u2191((Finset.range (n + 1)).image fun n => (X : R[X]) ^ n)", "start": [74, 1], "end": [92, 99], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_degreeLT", "code": "theorem mem_degreeLT {n : \u2115} {f : R[X]} : f \u2208 degreeLT R n \u2194 degree f < n", "start": [96, 1], "end": [106, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degreeLT_mono", "code": "@[mono]\ntheorem degreeLT_mono {m n : \u2115} (H : m \u2264 n) : degreeLT R m \u2264 degreeLT R n", "start": [109, 1], "end": [111, 80], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degreeLT_eq_span_X_pow", "code": "theorem degreeLT_eq_span_X_pow [DecidableEq R] {n : \u2115} :\n    degreeLT R n = Submodule.span R \u2191((Finset.range n).image fun n => X ^ n : Finset R[X])", "start": [114, 1], "end": [130, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degreeLTEquiv", "code": "def degreeLTEquiv (R) [Semiring R] (n : \u2115) : degreeLT R n \u2243\u2097[R] Fin n \u2192 R where\n  toFun p n := (\u2191p : R[X]).coeff n\n  invFun f :=\n    \u27e8\u2211 i : Fin n, monomial i (f i),\n      (degreeLT R n).sum_mem fun i _ =>\n        mem_degreeLT.mpr\n          (lt_of_le_of_lt (degree_monomial_le i (f i)) (WithBot.coe_lt_coe.mpr i.is_lt))\u27e9\n  map_add' p q := by\n    ext\n    dsimp\n    rw [coeff_add]\n  map_smul' x p := by\n    ext\n    dsimp\n    rw [coeff_smul]\n    rfl\n  left_inv := by\n    rintro \u27e8p, hp\u27e9\n    ext1\n    simp only [Submodule.coe_mk]\n    by_cases hp0 : p = 0\n    \u00b7 subst hp0\n      simp only [coeff_zero, LinearMap.map_zero, Finset.sum_const_zero]\n    rw [mem_degreeLT, degree_eq_natDegree hp0, Nat.cast_lt] at hp\n    conv_rhs => rw [p.as_sum_range' n hp, \u2190 Fin.sum_univ_eq_sum_range]\n  right_inv f := by\n    ext i\n    simp only [finset_sum_coeff, Submodule.coe_mk]\n    rw [Finset.sum_eq_single i, coeff_monomial, if_pos rfl]\n    \u00b7 rintro j - hji\n      rw [coeff_monomial, if_neg]\n      rwa [\u2190 Fin.ext_iff]\n    \u00b7 intro h\n      exact (h (Finset.mem_univ _)).elim", "start": [134, 1], "end": [168, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degreeLTEquiv_eq_zero_iff_eq_zero", "code": "theorem degreeLTEquiv_eq_zero_iff_eq_zero {n : \u2115} {p : R[X]} (hp : p \u2208 degreeLT R n) :\n    degreeLTEquiv _ _ \u27e8p, hp\u27e9 = 0 \u2194 p = 0", "start": [172, 1], "end": [174, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_eq_sum_degreeLTEquiv", "code": "theorem eval_eq_sum_degreeLTEquiv {n : \u2115} {p : R[X]} (hp : p \u2208 degreeLT R n) (x : R) :\n    p.eval x = \u2211 i, degreeLTEquiv _ _ \u27e8p, hp\u27e9 i * x ^ (i : \u2115)", "start": [177, 1], "end": [180, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.frange", "code": "def frange (p : R[X]) : Finset R :=\n  letI := Classical.decEq R\n  Finset.image (fun n => p.coeff n) p.support", "start": [183, 1], "end": [186, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.frange_zero", "code": "theorem frange_zero : frange (0 : R[X]) = \u2205", "start": [189, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_frange_iff", "code": "theorem mem_frange_iff {p : R[X]} {c : R} : c \u2208 p.frange \u2194 \u2203 n \u2208 p.support, c = p.coeff n", "start": [193, 1], "end": [194, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.frange_one", "code": "theorem frange_one : frange (1 : R[X]) \u2286 {1}", "start": [197, 1], "end": [204, 12], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mem_frange", "code": "theorem coeff_mem_frange (p : R[X]) (n : \u2115) (h : p.coeff n \u2260 0) : p.coeff n \u2208 p.frange", "start": [207, 1], "end": [210, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.geom_sum_X_comp_X_add_one_eq_sum", "code": "theorem geom_sum_X_comp_X_add_one_eq_sum (n : \u2115) :\n    (\u2211 i in range n, (X : R[X]) ^ i).comp (X + 1) =\n      (Finset.range n).sum fun i : \u2115 => (n.choose (i + 1) : R[X]) * X ^ i", "start": [213, 1], "end": [227, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.geom_sum", "code": "theorem Monic.geom_sum {P : R[X]} (hP : P.Monic) (hdeg : 0 < P.natDegree) {n : \u2115} (hn : n \u2260 0) :\n    (\u2211 i in range n, P ^ i).Monic", "start": [231, 1], "end": [244, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.geom_sum'", "code": "theorem Monic.geom_sum' {P : R[X]} (hP : P.Monic) (hdeg : 0 < P.degree) {n : \u2115} (hn : n \u2260 0) :\n    (\u2211 i in range n, P ^ i).Monic", "start": [247, 1], "end": [249, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_geom_sum_X", "code": "theorem monic_geom_sum_X {n : \u2115} (hn : n \u2260 0) : (\u2211 i in range n, (X : R[X]) ^ i).Monic", "start": [252, 1], "end": [255, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.restriction", "code": "def restriction (p : R[X]) : Polynomial (Subring.closure (\u2191p.frange : Set R)) :=\n  \u2211 i in p.support,\n    monomial i\n      (\u27e8p.coeff i,\n          letI := Classical.decEq R\n          if H : p.coeff i = 0 then H.symm \u25b8 (Subring.closure _).zero_mem\n          else Subring.subset_closure (p.coeff_mem_frange _ H)\u27e9 :\n        Subring.closure (\u2191p.frange : Set R))", "start": [265, 1], "end": [274, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_restriction", "code": "@[simp]\ntheorem coeff_restriction {p : R[X]} {n : \u2115} : \u2191(coeff (restriction p) n) = coeff p n", "start": [277, 1], "end": [285, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_restriction'", "code": "theorem coeff_restriction' {p : R[X]} {n : \u2115} : (coeff (restriction p) n).1 = coeff p n", "start": [289, 1], "end": [290, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_restriction", "code": "@[simp]\ntheorem support_restriction (p : R[X]) : support (restriction p) = support p", "start": [293, 1], "end": [298, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_restriction", "code": "@[simp]\ntheorem map_restriction {R : Type u} [CommRing R] (p : R[X]) :\n    p.restriction.map (algebraMap _ _) = p", "start": [301, 1], "end": [304, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_restriction", "code": "@[simp]\ntheorem degree_restriction {p : R[X]} : (restriction p).degree = p.degree", "start": [307, 1], "end": [308, 94], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_restriction", "code": "@[simp]\ntheorem natDegree_restriction {p : R[X]} : (restriction p).natDegree = p.natDegree", "start": [311, 1], "end": [313, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_restriction", "code": "@[simp]\ntheorem monic_restriction {p : R[X]} : Monic (restriction p) \u2194 Monic p", "start": [316, 1], "end": [320, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.restriction_zero", "code": "@[simp]\ntheorem restriction_zero : restriction (0 : R[X]) = 0", "start": [323, 1], "end": [325, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.restriction_one", "code": "@[simp]\ntheorem restriction_one : restriction (1 : R[X]) = 1", "start": [328, 1], "end": [330, 97], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_restriction", "code": "theorem eval\u2082_restriction {p : R[X]} :\n    eval\u2082 f x p =\n      eval\u2082 (f.comp (Subring.subtype (Subring.closure (p.frange : Set R)))) x p.restriction", "start": [335, 1], "end": [339, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toSubring", "code": "def toSubring (hp : (\u2191p.frange : Set R) \u2286 T) : T[X] :=\n  \u2211 i in p.support,\n    monomial i\n      (\u27e8p.coeff i,\n        letI := Classical.decEq R\n        if H : p.coeff i = 0 then H.symm \u25b8 T.zero_mem else hp (p.coeff_mem_frange _ H)\u27e9 : T)", "start": [346, 1], "end": [353, 93], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_toSubring", "code": "@[simp]\ntheorem coeff_toSubring {n : \u2115} : \u2191(coeff (toSubring p T hp) n) = coeff p n", "start": [358, 1], "end": [366, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_toSubring'", "code": "theorem coeff_toSubring' {n : \u2115} : (coeff (toSubring p T hp) n).1 = coeff p n", "start": [370, 1], "end": [371, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_toSubring", "code": "@[simp]\ntheorem support_toSubring : support (toSubring p T hp) = support p", "start": [374, 1], "end": [379, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_toSubring", "code": "@[simp]\ntheorem degree_toSubring : (toSubring p T hp).degree = p.degree", "start": [382, 1], "end": [383, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_toSubring", "code": "@[simp]\ntheorem natDegree_toSubring : (toSubring p T hp).natDegree = p.natDegree", "start": [386, 1], "end": [387, 96], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_toSubring", "code": "@[simp]\ntheorem monic_toSubring : Monic (toSubring p T hp) \u2194 Monic p", "start": [390, 1], "end": [393, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toSubring_zero", "code": "@[simp]\ntheorem toSubring_zero : toSubring (0 : R[X]) T (by simp [frange_zero]) = 0", "start": [396, 1], "end": [399, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toSubring_one", "code": "@[simp]\ntheorem toSubring_one :\n    toSubring (1 : R[X]) T\n        (Set.Subset.trans frange_one <| Finset.singleton_subset_set_iff.2 T.one_mem) =\n      1", "start": [402, 1], "end": [409, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_toSubring", "code": "@[simp]\ntheorem map_toSubring : (p.toSubring T hp).map (Subring.subtype T) = p", "start": [412, 1], "end": [415, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofSubring", "code": "def ofSubring (p : T[X]) : R[X] :=\n  \u2211 i in p.support, monomial i (p.coeff i : R)", "start": [422, 1], "end": [425, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_ofSubring", "code": "theorem coeff_ofSubring (p : T[X]) (n : \u2115) : coeff (ofSubring T p) n = (coeff p n : T)", "start": [428, 1], "end": [432, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.frange_ofSubring", "code": "@[simp]\ntheorem frange_ofSubring {p : T[X]} : (\u2191(p.ofSubring T).frange : Set R) \u2286 T", "start": [435, 1], "end": [443, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_ker_modByMonic", "code": "theorem mem_ker_modByMonic (hq : q.Monic) {p : R[X]} :\n    p \u2208 LinearMap.ker (modByMonicHom q) \u2194 q \u2223 p", "start": [456, 1], "end": [458, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ker_modByMonicHom", "code": "@[simp]\ntheorem ker_modByMonicHom (hq : q.Monic) :\n    LinearMap.ker (Polynomial.modByMonicHom q) = (Ideal.span {q}).restrictScalars R", "start": [461, 1], "end": [464, 85], "kind": "commanddeclaration"}, {"full_name": "Ideal.ofPolynomial", "code": "def ofPolynomial (I : Ideal R[X]) : Submodule R R[X] where\n  carrier := I.carrier\n  zero_mem' := I.zero_mem\n  add_mem' := I.add_mem\n  smul_mem' c x H := by\n    rw [\u2190 C_mul']\n    exact I.mul_mem_left _ H", "start": [481, 1], "end": [488, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_ofPolynomial", "code": "theorem mem_ofPolynomial (x) : x \u2208 I.ofPolynomial \u2194 x \u2208 I", "start": [493, 1], "end": [494, 10], "kind": "commanddeclaration"}, {"full_name": "Ideal.degreeLE", "code": "def degreeLE (n : WithBot \u2115) : Submodule R R[X] :=\n  Polynomial.degreeLE R n \u2293 I.ofPolynomial", "start": [499, 1], "end": [502, 43], "kind": "commanddeclaration"}, {"full_name": "Ideal.leadingCoeffNth", "code": "def leadingCoeffNth (n : \u2115) : Ideal R :=\n  (I.degreeLE n).map <| lcoeff R n", "start": [505, 1], "end": [508, 35], "kind": "commanddeclaration"}, {"full_name": "Ideal.leadingCoeff", "code": "def leadingCoeff : Ideal R :=\n  \u2a06 n : \u2115, I.leadingCoeffNth n", "start": [511, 1], "end": [514, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.polynomial_mem_ideal_of_coeff_mem_ideal", "code": "theorem polynomial_mem_ideal_of_coeff_mem_ideal (I : Ideal R[X]) (p : R[X])\n    (hp : \u2200 n : \u2115, p.coeff n \u2208 I.comap (C : R \u2192+* R[X])) : p \u2208 I", "start": [523, 1], "end": [526, 81], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_map_C_iff", "code": "theorem mem_map_C_iff {I : Ideal R} {f : R[X]} :\n    f \u2208 (Ideal.map (C : R \u2192+* R[X]) I : Ideal R[X]) \u2194 \u2200 n : \u2115, f.coeff n \u2208 I", "start": [529, 1], "end": [552, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ker_mapRingHom", "code": "theorem _root_.Polynomial.ker_mapRingHom (f : R \u2192+* S) :\n    LinearMap.ker (Polynomial.mapRingHom f).toSemilinearMap = f.ker.map (C : R \u2192+* R[X])", "start": [556, 1], "end": [562, 7], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_leadingCoeffNth", "code": "theorem mem_leadingCoeffNth (n : \u2115) (x) :\n    x \u2208 I.leadingCoeffNth n \u2194 \u2203 p \u2208 I, degree p \u2264 n \u2227 p.leadingCoeff = x", "start": [567, 1], "end": [586, 80], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_leadingCoeffNth_zero", "code": "theorem mem_leadingCoeffNth_zero (x) : x \u2208 I.leadingCoeffNth 0 \u2194 C x \u2208 I", "start": [589, 1], "end": [594, 58], "kind": "commanddeclaration"}, {"full_name": "Ideal.leadingCoeffNth_mono", "code": "theorem leadingCoeffNth_mono {m n : \u2115} (H : m \u2264 n) : I.leadingCoeffNth m \u2264 I.leadingCoeffNth n", "start": [597, 1], "end": [604, 47], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_leadingCoeff", "code": "theorem mem_leadingCoeff (x) : x \u2208 I.leadingCoeff \u2194 \u2203 p \u2208 I, Polynomial.leadingCoeff p = x", "start": [607, 1], "end": [618, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_prod_mem_ideal_pow_tsub", "code": "theorem _root_.Polynomial.coeff_prod_mem_ideal_pow_tsub {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 R[X])\n    (I : Ideal R) (n : \u03b9 \u2192 \u2115) (h : \u2200 i \u2208 s, \u2200 (k), (f i).coeff k \u2208 I ^ (n i - k)) (k : \u2115) :\n    (s.prod f).coeff k \u2208 I ^ (s.sum n - k)", "start": [621, 1], "end": [639, 76], "kind": "commanddeclaration"}, {"full_name": "Ideal.polynomial_not_isField", "code": "theorem polynomial_not_isField : \u00acIsField R[X]", "start": [648, 1], "end": [656, 17], "kind": "commanddeclaration"}, {"full_name": "Ideal.eq_zero_of_constant_mem_of_maximal", "code": "theorem eq_zero_of_constant_mem_of_maximal (hR : IsField R) (I : Ideal R[X]) [hI : I.IsMaximal]\n    (x : R) (hx : C x \u2208 I) : x = 0", "start": [659, 1], "end": [665, 57], "kind": "commanddeclaration"}, {"full_name": "Ideal.isPrime_map_C_iff_isPrime", "code": "theorem isPrime_map_C_iff_isPrime (P : Ideal R) :\n    IsPrime (map (C : R \u2192+* R[X]) P : Ideal R[X]) \u2194 IsPrime P", "start": [674, 1], "end": [727, 57], "kind": "commanddeclaration"}, {"full_name": "Ideal.isPrime_map_C_of_isPrime", "code": "theorem isPrime_map_C_of_isPrime {P : Ideal R} (H : IsPrime P) :\n    IsPrime (map (C : R \u2192+* R[X]) P : Ideal R[X])", "start": [731, 1], "end": [734, 38], "kind": "commanddeclaration"}, {"full_name": "Ideal.is_fg_degreeLE", "code": "theorem is_fg_degreeLE [IsNoetherianRing R] (I : Ideal R[X]) (n : \u2115) :\n    Submodule.FG (I.degreeLE n)", "start": [738, 1], "end": [743, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.prime_C_iff", "code": "theorem prime_C_iff : Prime (C r) \u2194 Prime r", "start": [761, 1], "end": [769, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.prime_C_iff_of_fintype", "code": "private theorem prime_C_iff_of_fintype {R : Type u} (\u03c3 : Type v) {r : R} [CommRing R] [Fintype \u03c3] :\n    Prime (C r : MvPolynomial \u03c3 R) \u2194 Prime r", "start": [779, 1], "end": [797, 38], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.prime_C_iff", "code": "theorem prime_C_iff : Prime (C r : MvPolynomial \u03c3 R) \u2194 Prime r", "start": [800, 1], "end": [818, 89], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.prime_rename_iff", "code": "theorem prime_rename_iff (s : Set \u03c3) {p : MvPolynomial s R} :\n    Prime (rename ((\u2191) : s \u2192 \u03c3) p) \u2194 Prime (p : MvPolynomial s R)", "start": [824, 1], "end": [845, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isNoetherianRing", "code": "protected theorem Polynomial.isNoetherianRing [inst : IsNoetherianRing R] : IsNoetherianRing R[X]", "start": [888, 1], "end": [962, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_irreducible_of_degree_pos", "code": "theorem exists_irreducible_of_degree_pos {R : Type u} [CommRing R] [IsDomain R] [WfDvdMonoid R]\n    {f : R[X]} (hf : 0 < f.degree) : \u2203 g, Irreducible g \u2227 g \u2223 f", "start": [969, 1], "end": [972, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_irreducible_of_natDegree_pos", "code": "theorem exists_irreducible_of_natDegree_pos {R : Type u} [CommRing R] [IsDomain R] [WfDvdMonoid R]\n    {f : R[X]} (hf : 0 < f.natDegree) : \u2203 g, Irreducible g \u2227 g \u2223 f", "start": [975, 1], "end": [979, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_irreducible_of_natDegree_ne_zero", "code": "theorem exists_irreducible_of_natDegree_ne_zero {R : Type u} [CommRing R] [IsDomain R]\n    [WfDvdMonoid R] {f : R[X]} (hf : f.natDegree \u2260 0) : \u2203 g, Irreducible g \u2227 g \u2223 f", "start": [982, 1], "end": [984, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.linearIndependent_powers_iff_aeval", "code": "theorem linearIndependent_powers_iff_aeval (f : M \u2192\u2097[R] M) (v : M) :\n    (LinearIndependent R fun n : \u2115 => (f ^ n) v) \u2194 \u2200 p : R[X], aeval f p v = 0 \u2192 p = 0", "start": [987, 1], "end": [992, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.disjoint_ker_aeval_of_coprime", "code": "theorem disjoint_ker_aeval_of_coprime (f : M \u2192\u2097[R] M) {p q : R[X]} (hpq : IsCoprime p q) :\n    Disjoint (LinearMap.ker (aeval f p)) (LinearMap.ker (aeval f q))", "start": [997, 1], "end": [1004, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sup_aeval_range_eq_top_of_coprime", "code": "theorem sup_aeval_range_eq_top_of_coprime (f : M \u2192\u2097[R] M) {p q : R[X]} (hpq : IsCoprime p q) :\n    LinearMap.range (aeval f p) \u2294 LinearMap.range (aeval f q) = \u22a4", "start": [1007, 1], "end": [1018, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sup_ker_aeval_le_ker_aeval_mul", "code": "theorem sup_ker_aeval_le_ker_aeval_mul {f : M \u2192\u2097[R] M} {p q : R[X]} :\n    LinearMap.ker (aeval f p) \u2294 LinearMap.ker (aeval f q) \u2264 LinearMap.ker (aeval f (p * q))", "start": [1021, 1], "end": [1029, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sup_ker_aeval_eq_ker_aeval_mul_of_coprime", "code": "theorem sup_ker_aeval_eq_ker_aeval_mul_of_coprime (f : M \u2192\u2097[R] M) {p q : R[X]}\n    (hpq : IsCoprime p q) :\n    LinearMap.ker (aeval f p) \u2294 LinearMap.ker (aeval f q) = LinearMap.ker (aeval f (p * q))", "start": [1032, 1], "end": [1055, 94], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isNoetherianRing_fin_0", "code": "theorem isNoetherianRing_fin_0 [IsNoetherianRing R] :\n    IsNoetherianRing (MvPolynomial (Fin 0) R)", "start": [1062, 1], "end": [1065, 54], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isNoetherianRing_fin", "code": "theorem isNoetherianRing_fin [IsNoetherianRing R] :\n    \u2200 {n : \u2115}, IsNoetherianRing (MvPolynomial (Fin n) R)", "start": [1068, 1], "end": [1074, 85], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isNoetherianRing", "code": "instance isNoetherianRing [Finite \u03c3] [IsNoetherianRing R] :\n    IsNoetherianRing (MvPolynomial \u03c3 R) := by\n  cases nonempty_fintype \u03c3\n  exact\n    @isNoetherianRing_of_ringEquiv (MvPolynomial (Fin (Fintype.card \u03c3)) R) _ _ _\n      (renameEquiv R (Fintype.equivFin \u03c3).symm).toRingEquiv isNoetherianRing_fin", "start": [1077, 1], "end": [1084, 81], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.noZeroDivisors_fin", "code": "theorem noZeroDivisors_fin (R : Type u) [CommSemiring R] [NoZeroDivisors R] :\n    \u2200 n : \u2115, NoZeroDivisors (MvPolynomial (Fin n) R)", "start": [1087, 1], "end": [1098, 88], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.noZeroDivisors_of_finite", "code": "theorem noZeroDivisors_of_finite (R : Type u) (\u03c3 : Type v) [CommSemiring R] [Finite \u03c3]\n    [NoZeroDivisors R] : NoZeroDivisors (MvPolynomial \u03c3 R)", "start": [1101, 1], "end": [1110, 97], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_mvPolynomial_eq_eval\u2082", "code": "theorem map_mvPolynomial_eq_eval\u2082 {S : Type*} [CommRing S] [Finite \u03c3] (\u03d5 : MvPolynomial \u03c3 R \u2192+* S)\n    (p : MvPolynomial \u03c3 R) :\n    \u03d5 p = MvPolynomial.eval\u2082 (\u03d5.comp MvPolynomial.C) (fun s => \u03d5 (MvPolynomial.X s)) p", "start": [1140, 1], "end": [1148, 92], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mem_ideal_of_coeff_mem_ideal", "code": "theorem mem_ideal_of_coeff_mem_ideal (I : Ideal (MvPolynomial \u03c3 R)) (p : MvPolynomial \u03c3 R)\n    (hcoe : \u2200 m : \u03c3 \u2192\u2080 \u2115, p.coeff m \u2208 I.comap (C : R \u2192+* MvPolynomial \u03c3 R)) : p \u2208 I", "start": [1151, 1], "end": [1161, 39], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mem_map_C_iff", "code": "theorem mem_map_C_iff {I : Ideal R} {f : MvPolynomial \u03c3 R} :\n    f \u2208 (Ideal.map (C : R \u2192+* MvPolynomial \u03c3 R) I : Ideal (MvPolynomial \u03c3 R)) \u2194\n      \u2200 m : \u03c3 \u2192\u2080 \u2115, f.coeff m \u2208 I", "start": [1164, 1], "end": [1193, 15], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.ker_map", "code": "theorem ker_map (f : R \u2192+* S) :\n    RingHom.ker (map f : MvPolynomial \u03c3 R \u2192+* MvPolynomial \u03c3 S) =\n    Ideal.map (C : R \u2192+* MvPolynomial \u03c3 R) (RingHom.ker f)", "start": [1198, 1], "end": [1203, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.uniqueFactorizationMonoid", "code": "instance (priority := 100) uniqueFactorizationMonoid : UniqueFactorizationMonoid D[X] := by\n  letI := Classical.decEq (Associates D)\n  letI := Classical.decEq D\n  haveI : NormalizationMonoid D := Inhabited.default\n  haveI := toNormalizedGCDMonoid D\n  exact ufm_of_gcd_of_wfDvdMonoid", "start": [1217, 1], "end": [1222, 34], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.uniqueFactorizationMonoid_of_fintype", "code": "private theorem uniqueFactorizationMonoid_of_fintype [Fintype \u03c3] :\n    UniqueFactorizationMonoid (MvPolynomial \u03c3 D)", "start": [1240, 1], "end": [1250, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/MvPolynomial.lean", "imports": ["Mathlib/Data/MvPolynomial/Basic.lean", "Mathlib/LinearAlgebra/Matrix/Determinant.lean", "Mathlib/Data/MvPolynomial/CommRing.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.mvPolynomialX", "code": "noncomputable def mvPolynomialX [CommSemiring R] : Matrix m n (MvPolynomial (m \u00d7 n) R) :=\n  of fun i j => MvPolynomial.X (i, j)", "start": [32, 1], "end": [34, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.mvPolynomialX_apply", "code": "@[simp]\ntheorem mvPolynomialX_apply [CommSemiring R] (i j) :\n    mvPolynomialX m n R i j = MvPolynomial.X (i, j)", "start": [38, 1], "end": [41, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.mvPolynomialX_map_eval\u2082", "code": "theorem mvPolynomialX_map_eval\u2082 [CommSemiring R] [CommSemiring S] (f : R \u2192+* S) (A : Matrix m n S) :\n    (mvPolynomialX m n R).map (MvPolynomial.eval\u2082 f fun p : m \u00d7 n => A p.1 p.2) = A", "start": [46, 1], "end": [53, 76], "kind": "commanddeclaration"}, {"full_name": "Matrix.mvPolynomialX_mapMatrix_eval", "code": "theorem mvPolynomialX_mapMatrix_eval [Fintype m] [DecidableEq m] [CommSemiring R]\n    (A : Matrix m m R) :\n    (MvPolynomial.eval fun p : m \u00d7 m => A p.1 p.2).mapMatrix (mvPolynomialX m m R) = A", "start": [56, 1], "end": [60, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.mvPolynomialX_mapMatrix_aeval", "code": "theorem mvPolynomialX_mapMatrix_aeval [Fintype m] [DecidableEq m] [CommSemiring R] [CommSemiring S]\n    [Algebra R S] (A : Matrix m m S) :\n    (MvPolynomial.aeval fun p : m \u00d7 m => A p.1 p.2).mapMatrix (mvPolynomialX m m R) = A", "start": [65, 1], "end": [69, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_mvPolynomialX_ne_zero", "code": "theorem det_mvPolynomialX_ne_zero [DecidableEq m] [Fintype m] [CommRing R] [Nontrivial R] :\n    det (mvPolynomialX m m R) \u2260 0", "start": [74, 1], "end": [80, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/Trim.lean", "imports": ["Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.Measure.trim", "code": "noncomputable\ndef Measure.trim {m m0 : MeasurableSpace \u03b1} (\u03bc : @Measure \u03b1 m0) (hm : m \u2264 m0) : @Measure \u03b1 m :=\n  @OuterMeasure.toMeasure \u03b1 m \u03bc.toOuterMeasure (hm.trans (le_toOuterMeasure_caratheodory \u03bc))", "start": [24, 1], "end": [33, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.trim_eq_self", "code": "@[simp]\ntheorem trim_eq_self [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} : \u03bc.trim le_rfl = \u03bc", "start": [36, 1], "end": [38, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.toOuterMeasure_trim_eq_trim_toOuterMeasure", "code": "theorem toOuterMeasure_trim_eq_trim_toOuterMeasure (\u03bc : Measure \u03b1) (hm : m \u2264 m0) :\n    @Measure.toOuterMeasure _ m (\u03bc.trim hm) = @OuterMeasure.trim _ m \u03bc.toOuterMeasure", "start": [43, 1], "end": [45, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.zero_trim", "code": "@[simp]\ntheorem zero_trim (hm : m \u2264 m0) : (0 : Measure \u03b1).trim hm = (0 : @Measure \u03b1 m)", "start": [48, 1], "end": [50, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.trim_measurableSet_eq", "code": "theorem trim_measurableSet_eq (hm : m \u2264 m0) (hs : @MeasurableSet \u03b1 m s) : \u03bc.trim hm s = \u03bc s", "start": [53, 1], "end": [54, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.le_trim", "code": "theorem le_trim (hm : m \u2264 m0) : \u03bc s \u2264 \u03bc.trim hm s", "start": [57, 1], "end": [59, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_eq_zero_of_trim_eq_zero", "code": "theorem measure_eq_zero_of_trim_eq_zero (hm : m \u2264 m0) (h : \u03bc.trim hm s = 0) : \u03bc s = 0", "start": [62, 1], "end": [63, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_trim_toMeasurable_eq_zero", "code": "theorem measure_trim_toMeasurable_eq_zero {hm : m \u2264 m0} (hs : \u03bc.trim hm s = 0) :\n    \u03bc (@toMeasurable \u03b1 m (\u03bc.trim hm) s) = 0", "start": [66, 1], "end": [68, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_of_ae_trim", "code": "theorem ae_of_ae_trim (hm : m \u2264 m0) {\u03bc : Measure \u03b1} {P : \u03b1 \u2192 Prop} (h : \u2200\u1d50 x \u2202\u03bc.trim hm, P x) :\n    \u2200\u1d50 x \u2202\u03bc, P x", "start": [71, 1], "end": [73, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_of_ae_eq_trim", "code": "theorem ae_eq_of_ae_eq_trim {E} {hm : m \u2264 m0} {f\u2081 f\u2082 : \u03b1 \u2192 E}\n    (h12 : f\u2081 =\u1da0[@Measure.ae \u03b1 m (\u03bc.trim hm)] f\u2082) : f\u2081 =\u1d50[\u03bc] f\u2082", "start": [76, 1], "end": [78, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_le_of_ae_le_trim", "code": "theorem ae_le_of_ae_le_trim {E} [LE E] {hm : m \u2264 m0} {f\u2081 f\u2082 : \u03b1 \u2192 E}\n    (h12 : f\u2081 \u2264\u1da0[@Measure.ae \u03b1 m (\u03bc.trim hm)] f\u2082) : f\u2081 \u2264\u1d50[\u03bc] f\u2082", "start": [81, 1], "end": [83, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.trim_trim", "code": "theorem trim_trim {m\u2081 m\u2082 : MeasurableSpace \u03b1} {hm\u2081\u2082 : m\u2081 \u2264 m\u2082} {hm\u2082 : m\u2082 \u2264 m0} :\n    (\u03bc.trim hm\u2082).trim hm\u2081\u2082 = \u03bc.trim (hm\u2081\u2082.trans hm\u2082)", "start": [86, 1], "end": [90, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.restrict_trim", "code": "theorem restrict_trim (hm : m \u2264 m0) (\u03bc : Measure \u03b1) (hs : @MeasurableSet \u03b1 m s) :\n    @Measure.restrict \u03b1 m (\u03bc.trim hm) s = (\u03bc.restrict s).trim hm", "start": [93, 1], "end": [98, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.isFiniteMeasure_trim", "code": "instance isFiniteMeasure_trim (hm : m \u2264 m0) [IsFiniteMeasure \u03bc] : IsFiniteMeasure (\u03bc.trim hm) where\n  measure_univ_lt_top := by\n    rw [trim_measurableSet_eq hm (@MeasurableSet.univ _ m)]\n    exact measure_lt_top _ _", "start": [101, 1], "end": [104, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.sigmaFiniteTrim_mono", "code": "theorem sigmaFiniteTrim_mono {m m\u2082 m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} (hm : m \u2264 m0)\n    (hm\u2082 : m\u2082 \u2264 m) [SigmaFinite (\u03bc.trim (hm\u2082.trans hm))] : SigmaFinite (\u03bc.trim hm)", "start": [107, 1], "end": [123, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.sigmaFinite_trim_bot_iff", "code": "theorem sigmaFinite_trim_bot_iff : SigmaFinite (\u03bc.trim bot_le) \u2194 IsFiniteMeasure \u03bc", "start": [126, 1], "end": [130, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/UniformConvergence.lean", "imports": ["Mathlib/Analysis/LocallyConvex/Bounded.lean", "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean", "Mathlib/Topology/Algebra/FilterBasis.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UniformFun.one_apply", "code": "@[to_additive (attr := simp)]\nlemma UniformFun.one_apply [Monoid \u03b2] : (1 : \u03b1 \u2192\u1d64 \u03b2) x = 1 := Pi.one_apply x", "start": [104, 1], "end": [105, 77], "kind": "mathlibtacticlemma"}, {"full_name": "UniformOnFun.one_apply", "code": "@[to_additive (attr := simp)]\nlemma UniformOnFun.one_apply [Monoid \u03b2] : (1 : \u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) x = 1 := Pi.one_apply x", "start": [107, 1], "end": [108, 82], "kind": "mathlibtacticlemma"}, {"full_name": "UniformFun.mul_apply", "code": "@[to_additive (attr := simp)]\nlemma UniformFun.mul_apply [Monoid \u03b2] : (f * g : \u03b1 \u2192\u1d64 \u03b2) x = f x * g x := Pi.mul_apply f g x", "start": [110, 1], "end": [111, 93], "kind": "mathlibtacticlemma"}, {"full_name": "UniformOnFun.mul_apply", "code": "@[to_additive (attr := simp)]\nlemma UniformOnFun.mul_apply [Monoid \u03b2] : (f * g : \u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) x = f x * g x := Pi.mul_apply f g x", "start": [113, 1], "end": [114, 98], "kind": "mathlibtacticlemma"}, {"full_name": "UniformFun.inv_apply", "code": "@[to_additive (attr := simp)]\nlemma UniformFun.inv_apply [Group \u03b2] : (f : \u03b1 \u2192\u1d64 \u03b2)\u207b\u00b9 x = (f x)\u207b\u00b9 := Pi.inv_apply f x", "start": [116, 1], "end": [117, 86], "kind": "mathlibtacticlemma"}, {"full_name": "UniformOnFun.inv_apply", "code": "@[to_additive (attr := simp)]\nlemma UniformOnFun.inv_apply [Group \u03b2] : (f : \u03b1 \u2192\u1d64[\ud835\udd16] \u03b2)\u207b\u00b9 x = (f x)\u207b\u00b9 := Pi.inv_apply f x", "start": [119, 1], "end": [120, 91], "kind": "mathlibtacticlemma"}, {"full_name": "UniformFun.div_apply", "code": "@[to_additive (attr := simp)]\nlemma UniformFun.div_apply [Group \u03b2] : (f / g : \u03b1 \u2192\u1d64 \u03b2) x = f x / g x := Pi.div_apply f g x", "start": [122, 1], "end": [123, 92], "kind": "mathlibtacticlemma"}, {"full_name": "UniformOnFun.div_apply", "code": "@[to_additive (attr := simp)]\nlemma UniformOnFun.div_apply [Group \u03b2] : (f / g : \u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) x = f x / g x := Pi.div_apply f g x", "start": [125, 1], "end": [126, 97], "kind": "mathlibtacticlemma"}, {"full_name": "UniformFun.hasBasis_nhds_one_of_basis", "code": "@[to_additive]\nprotected theorem UniformFun.hasBasis_nhds_one_of_basis {p : \u03b9 \u2192 Prop} {b : \u03b9 \u2192 Set G}\n    (h : (\ud835\udcdd 1 : Filter G).HasBasis p b) :\n    (\ud835\udcdd 1 : Filter (\u03b1 \u2192\u1d64 G)).HasBasis p fun i => { f : \u03b1 \u2192\u1d64 G | \u2200 x, f x \u2208 b i }", "start": [146, 1], "end": [154, 24], "kind": "commanddeclaration"}, {"full_name": "UniformFun.hasBasis_nhds_one", "code": "@[to_additive]\nprotected theorem UniformFun.hasBasis_nhds_one :\n    (\ud835\udcdd 1 : Filter (\u03b1 \u2192\u1d64 G)).HasBasis (fun V : Set G => V \u2208 (\ud835\udcdd 1 : Filter G)) fun V =>\n      { f : \u03b1 \u2192 G | \u2200 x, f x \u2208 V }", "start": [158, 1], "end": [162, 55], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.hasBasis_nhds_one_of_basis", "code": "@[to_additive]\nprotected theorem UniformOnFun.hasBasis_nhds_one_of_basis (\ud835\udd16 : Set <| Set \u03b1) (h\ud835\udd16\u2081 : \ud835\udd16.Nonempty)\n    (h\ud835\udd16\u2082 : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16) {p : \u03b9 \u2192 Prop} {b : \u03b9 \u2192 Set G}\n    (h : (\ud835\udcdd 1 : Filter G).HasBasis p b) :\n    (\ud835\udcdd 1 : Filter (\u03b1 \u2192\u1d64[\ud835\udd16] G)).HasBasis (fun Si : Set \u03b1 \u00d7 \u03b9 => Si.1 \u2208 \ud835\udd16 \u2227 p Si.2) fun Si =>\n      { f : \u03b1 \u2192\u1d64[\ud835\udd16] G | \u2200 x \u2208 Si.1, f x \u2208 b Si.2 }", "start": [179, 1], "end": [189, 26], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.hasBasis_nhds_one", "code": "@[to_additive]\nprotected theorem UniformOnFun.hasBasis_nhds_one (\ud835\udd16 : Set <| Set \u03b1) (h\ud835\udd16\u2081 : \ud835\udd16.Nonempty)\n    (h\ud835\udd16\u2082 : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16) :\n    (\ud835\udcdd 1 : Filter (\u03b1 \u2192\u1d64[\ud835\udd16] G)).HasBasis\n      (fun SV : Set \u03b1 \u00d7 Set G => SV.1 \u2208 \ud835\udd16 \u2227 SV.2 \u2208 (\ud835\udcdd 1 : Filter G)) fun SV =>\n      { f : \u03b1 \u2192\u1d64[\ud835\udd16] G | \u2200 x \u2208 SV.1, f x \u2208 SV.2 }", "start": [193, 1], "end": [199, 67], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.continuousSMul_induced_of_image_bounded", "code": "theorem UniformOnFun.continuousSMul_induced_of_image_bounded (h\ud835\udd16\u2081 : \ud835\udd16.Nonempty)\n    (h\ud835\udd16\u2082 : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16) (\u03c6 : hom) (h\u03c6 : Inducing \u03c6)\n    (h : \u2200 u : H, \u2200 s \u2208 \ud835\udd16, Bornology.IsVonNBounded \ud835\udd5c ((\u03c6 u : \u03b1 \u2192 E) '' s)) :\n    ContinuousSMul \ud835\udd5c H", "start": [211, 1], "end": [262, 50], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.continuousSMul_submodule_of_image_bounded", "code": "theorem UniformOnFun.continuousSMul_submodule_of_image_bounded (h\ud835\udd16\u2081 : \ud835\udd16.Nonempty)\n    (h\ud835\udd16\u2082 : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16) (H : Submodule \ud835\udd5c (\u03b1 \u2192\u1d64[\ud835\udd16] E))\n    (h : \u2200 u \u2208 H, \u2200 s \u2208 \ud835\udd16, Bornology.IsVonNBounded \ud835\udd5c (u '' s)) :\n    @ContinuousSMul \ud835\udd5c H _ _ ((UniformOnFun.topologicalSpace \u03b1 E \ud835\udd16).induced ((\u2191) : H \u2192 \u03b1 \u2192\u1d64[\ud835\udd16] E))", "start": [265, 1], "end": [277, 92], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Topology.lean", "imports": ["Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/Topology/Algebra/Affine.lean", "Mathlib/Topology/Connected/PathConnected.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Convex/Combination.lean", "Mathlib/Analysis/Convex/Strict.lean"], "premises": [{"full_name": "Real.convex_iff_isPreconnected", "code": "theorem Real.convex_iff_isPreconnected {s : Set \u211d} : Convex \u211d s \u2194 IsPreconnected s", "start": [31, 1], "end": [32, 69], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.convex", "code": "alias \u27e8_, IsPreconnected.convex\u27e9 := Real.convex_iff_isPreconnected", "start": [35, 1], "end": [35, 67], "kind": "stdtacticaliasaliaslr"}, {"full_name": "stdSimplex_subset_closedBall", "code": "theorem stdSimplex_subset_closedBall : stdSimplex \u211d \u03b9 \u2286 Metric.closedBall 0 1", "start": [45, 1], "end": [50, 43], "kind": "commanddeclaration"}, {"full_name": "bounded_stdSimplex", "code": "theorem bounded_stdSimplex : IsBounded (stdSimplex \u211d \u03b9)", "start": [55, 1], "end": [57, 81], "kind": "commanddeclaration"}, {"full_name": "isClosed_stdSimplex", "code": "theorem isClosed_stdSimplex : IsClosed (stdSimplex \u211d \u03b9)", "start": [60, 1], "end": [64, 93], "kind": "commanddeclaration"}, {"full_name": "isCompact_stdSimplex", "code": "theorem isCompact_stdSimplex : IsCompact (stdSimplex \u211d \u03b9)", "start": [67, 1], "end": [69, 88], "kind": "commanddeclaration"}, {"full_name": "segment_subset_closure_openSegment", "code": "theorem segment_subset_closure_openSegment : [x -[\ud835\udd5c] y] \u2286 closure (openSegment \ud835\udd5c x y)", "start": [83, 1], "end": [85, 59], "kind": "commanddeclaration"}, {"full_name": "closure_openSegment", "code": "@[simp]\ntheorem closure_openSegment (x y : E) : closure (openSegment \ud835\udd5c x y) = [x -[\ud835\udd5c] y]", "start": [96, 1], "end": [100, 51], "kind": "commanddeclaration"}, {"full_name": "Convex.combo_interior_closure_subset_interior", "code": "theorem Convex.combo_interior_closure_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 < a) (hb : 0 \u2264 b) (hab : a + b = 1) : a \u2022 interior s + b \u2022 closure s \u2286 interior s", "start": [110, 1], "end": [120, 74], "kind": "commanddeclaration"}, {"full_name": "Convex.combo_interior_self_subset_interior", "code": "theorem Convex.combo_interior_self_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 < a) (hb : 0 \u2264 b) (hab : a + b = 1) : a \u2022 interior s + b \u2022 s \u2286 interior s", "start": [124, 1], "end": [131, 74], "kind": "commanddeclaration"}, {"full_name": "Convex.combo_closure_interior_subset_interior", "code": "theorem Convex.combo_closure_interior_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 \u2264 a) (hb : 0 < b) (hab : a + b = 1) : a \u2022 closure s + b \u2022 interior s \u2286 interior s", "start": [135, 1], "end": [140, 77], "kind": "commanddeclaration"}, {"full_name": "Convex.combo_self_interior_subset_interior", "code": "theorem Convex.combo_self_interior_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 \u2264 a) (hb : 0 < b) (hab : a + b = 1) : a \u2022 s + b \u2022 interior s \u2286 interior s", "start": [143, 1], "end": [148, 74], "kind": "commanddeclaration"}, {"full_name": "Convex.combo_interior_closure_mem_interior", "code": "theorem Convex.combo_interior_closure_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 interior s) (hy : y \u2208 closure s) {a b : \ud835\udd5c} (ha : 0 < a) (hb : 0 \u2264 b)\n    (hab : a + b = 1) : a \u2022 x + b \u2022 y \u2208 interior s", "start": [151, 1], "end": [155, 62], "kind": "commanddeclaration"}, {"full_name": "Convex.combo_interior_self_mem_interior", "code": "theorem Convex.combo_interior_self_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 interior s) (hy : y \u2208 s) {a b : \ud835\udd5c} (ha : 0 < a) (hb : 0 \u2264 b) (hab : a + b = 1) :\n    a \u2022 x + b \u2022 y \u2208 interior s", "start": [158, 1], "end": [161, 74], "kind": "commanddeclaration"}, {"full_name": "Convex.combo_closure_interior_mem_interior", "code": "theorem Convex.combo_closure_interior_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 closure s) (hy : y \u2208 interior s) {a b : \ud835\udd5c} (ha : 0 \u2264 a) (hb : 0 < b)\n    (hab : a + b = 1) : a \u2022 x + b \u2022 y \u2208 interior s", "start": [164, 1], "end": [168, 62], "kind": "commanddeclaration"}, {"full_name": "Convex.combo_self_interior_mem_interior", "code": "theorem Convex.combo_self_interior_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 s)\n    (hy : y \u2208 interior s) {a b : \ud835\udd5c} (ha : 0 \u2264 a) (hb : 0 < b) (hab : a + b = 1) :\n    a \u2022 x + b \u2022 y \u2208 interior s", "start": [171, 1], "end": [174, 74], "kind": "commanddeclaration"}, {"full_name": "Convex.openSegment_interior_closure_subset_interior", "code": "theorem Convex.openSegment_interior_closure_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 interior s) (hy : y \u2208 closure s) : openSegment \ud835\udd5c x y \u2286 interior s", "start": [177, 1], "end": [180, 66], "kind": "commanddeclaration"}, {"full_name": "Convex.openSegment_interior_self_subset_interior", "code": "theorem Convex.openSegment_interior_self_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 interior s) (hy : y \u2208 s) : openSegment \ud835\udd5c x y \u2286 interior s", "start": [183, 1], "end": [185, 73], "kind": "commanddeclaration"}, {"full_name": "Convex.openSegment_closure_interior_subset_interior", "code": "theorem Convex.openSegment_closure_interior_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 closure s) (hy : y \u2208 interior s) : openSegment \ud835\udd5c x y \u2286 interior s", "start": [188, 1], "end": [191, 66], "kind": "commanddeclaration"}, {"full_name": "Convex.openSegment_self_interior_subset_interior", "code": "theorem Convex.openSegment_self_interior_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 s) (hy : y \u2208 interior s) : openSegment \ud835\udd5c x y \u2286 interior s", "start": [194, 1], "end": [196, 73], "kind": "commanddeclaration"}, {"full_name": "Convex.add_smul_sub_mem_interior'", "code": "theorem Convex.add_smul_sub_mem_interior' {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 closure s) (hy : y \u2208 interior s) {t : \ud835\udd5c} (ht : t \u2208 Ioc (0 : \ud835\udd5c) 1) :\n    x + t \u2022 (y - x) \u2208 interior s", "start": [199, 1], "end": [206, 34], "kind": "commanddeclaration"}, {"full_name": "Convex.add_smul_sub_mem_interior", "code": "theorem Convex.add_smul_sub_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 s)\n    (hy : y \u2208 interior s) {t : \ud835\udd5c} (ht : t \u2208 Ioc (0 : \ud835\udd5c) 1) : x + t \u2022 (y - x) \u2208 interior s", "start": [209, 1], "end": [212, 58], "kind": "commanddeclaration"}, {"full_name": "Convex.add_smul_mem_interior'", "code": "theorem Convex.add_smul_mem_interior' {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 closure s)\n    (hy : x + y \u2208 interior s) {t : \ud835\udd5c} (ht : t \u2208 Ioc (0 : \ud835\udd5c) 1) : x + t \u2022 y \u2208 interior s", "start": [215, 1], "end": [218, 76], "kind": "commanddeclaration"}, {"full_name": "Convex.add_smul_mem_interior", "code": "theorem Convex.add_smul_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 s)\n    (hy : x + y \u2208 interior s) {t : \ud835\udd5c} (ht : t \u2208 Ioc (0 : \ud835\udd5c) 1) : x + t \u2022 y \u2208 interior s", "start": [221, 1], "end": [224, 54], "kind": "commanddeclaration"}, {"full_name": "Convex.interior", "code": "protected theorem Convex.interior {s : Set E} (hs : Convex \ud835\udd5c s) : Convex \ud835\udd5c (interior s)", "start": [227, 1], "end": [230, 84], "kind": "commanddeclaration"}, {"full_name": "Convex.closure", "code": "protected theorem Convex.closure {s : Set E} (hs : Convex \ud835\udd5c s) : Convex \ud835\udd5c (closure s)", "start": [233, 1], "end": [239, 96], "kind": "commanddeclaration"}, {"full_name": "Convex.strictConvex'", "code": "protected theorem Convex.strictConvex' {s : Set E} (hs : Convex \ud835\udd5c s)\n    (h : (s \\ interior s).Pairwise fun x y => \u2203 c : \ud835\udd5c, lineMap x y c \u2208 interior s) :\n    StrictConvex \ud835\udd5c s", "start": [244, 1], "end": [259, 56], "kind": "commanddeclaration"}, {"full_name": "Convex.strictConvex", "code": "protected theorem Convex.strictConvex {s : Set E} (hs : Convex \ud835\udd5c s)\n    (h : (s \\ interior s).Pairwise fun x y => ([x -[\ud835\udd5c] y] \\ frontier s).Nonempty) :\n    StrictConvex \ud835\udd5c s", "start": [262, 1], "end": [272, 70], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isCompact_convexHull", "code": "theorem Set.Finite.isCompact_convexHull {s : Set E} (hs : s.Finite) :\n    IsCompact (convexHull \u211d s)", "start": [282, 1], "end": [288, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isClosed_convexHull", "code": "theorem Set.Finite.isClosed_convexHull [T2Space E] {s : Set E} (hs : s.Finite) :\n    IsClosed (convexHull \u211d s)", "start": [291, 1], "end": [294, 35], "kind": "commanddeclaration"}, {"full_name": "Convex.closure_subset_image_homothety_interior_of_one_lt", "code": "theorem Convex.closure_subset_image_homothety_interior_of_one_lt {s : Set E} (hs : Convex \u211d s)\n    {x : E} (hx : x \u2208 interior s) (t : \u211d) (ht : 1 < t) :\n    closure s \u2286 homothety x t '' interior s", "start": [299, 1], "end": [313, 30], "kind": "commanddeclaration"}, {"full_name": "Convex.closure_subset_interior_image_homothety_of_one_lt", "code": "theorem Convex.closure_subset_interior_image_homothety_of_one_lt {s : Set E} (hs : Convex \u211d s)\n    {x : E} (hx : x \u2208 interior s) (t : \u211d) (ht : 1 < t) :\n    closure s \u2286 interior (homothety x t '' s)", "start": [316, 1], "end": [324, 77], "kind": "commanddeclaration"}, {"full_name": "Convex.subset_interior_image_homothety_of_one_lt", "code": "theorem Convex.subset_interior_image_homothety_of_one_lt {s : Set E} (hs : Convex \u211d s) {x : E}\n    (hx : x \u2208 interior s) (t : \u211d) (ht : 1 < t) : s \u2286 interior (homothety x t '' s)", "start": [327, 1], "end": [333, 87], "kind": "commanddeclaration"}, {"full_name": "JoinedIn_of_segment_subset", "code": "theorem JoinedIn_of_segment_subset {E : Type*} [AddCommGroup E] [Module \u211d E]\n    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul \u211d E]\n    {x y : E} {s : Set E} (h : [x -[\u211d] y] \u2286 s) : JoinedIn s x y", "start": [336, 1], "end": [342, 30], "kind": "commanddeclaration"}, {"full_name": "Convex.isPathConnected", "code": "protected theorem Convex.isPathConnected {s : Set E} (hconv : Convex \u211d s) (hne : s.Nonempty) :\n    IsPathConnected s", "start": [344, 1], "end": [349, 80], "kind": "commanddeclaration"}, {"full_name": "Convex.isConnected", "code": "protected theorem Convex.isConnected {s : Set E} (h : Convex \u211d s) (hne : s.Nonempty) :\n    IsConnected s", "start": [352, 1], "end": [355, 38], "kind": "commanddeclaration"}, {"full_name": "Convex.isPreconnected", "code": "protected theorem Convex.isPreconnected {s : Set E} (h : Convex \u211d s) : IsPreconnected s", "start": [358, 1], "end": [361, 39], "kind": "commanddeclaration"}, {"full_name": "TopologicalAddGroup.pathConnectedSpace", "code": "protected theorem TopologicalAddGroup.pathConnectedSpace : PathConnectedSpace E", "start": [364, 1], "end": [369, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CharZero/Quotient.lean", "imports": ["Mathlib/GroupTheory/QuotientGroup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div", "code": "theorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p / z : R) \u2208 AddSubgroup.zmultiples p", "start": [19, 1], "end": [40, 17], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div", "code": "theorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p / n : R) \u2208 AddSubgroup.zmultiples p", "start": [43, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff", "code": "theorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p / z : R)", "start": [55, 1], "end": [65, 63], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.zmultiples_nsmul_eq_nsmul_iff", "code": "theorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p / n : R)", "start": [68, 1], "end": [72, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Exp.lean", "Mathlib/Tactic/Positivity/Core.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.continuous_sin", "code": "@[continuity]\ntheorem continuous_sin : Continuous sin", "start": [51, 1], "end": [54, 13], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousOn_sin", "code": "theorem continuousOn_sin {s : Set \u2102} : ContinuousOn sin s", "start": [57, 1], "end": [58, 30], "kind": "commanddeclaration"}, {"full_name": "Complex.continuous_cos", "code": "@[continuity]\ntheorem continuous_cos : Continuous cos", "start": [61, 1], "end": [64, 13], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousOn_cos", "code": "theorem continuousOn_cos {s : Set \u2102} : ContinuousOn cos s", "start": [67, 1], "end": [68, 30], "kind": "commanddeclaration"}, {"full_name": "Complex.continuous_sinh", "code": "@[continuity]\ntheorem continuous_sinh : Continuous sinh", "start": [71, 1], "end": [74, 13], "kind": "commanddeclaration"}, {"full_name": "Complex.continuous_cosh", "code": "@[continuity]\ntheorem continuous_cosh : Continuous cosh", "start": [77, 1], "end": [80, 13], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_sin", "code": "@[continuity]\ntheorem continuous_sin : Continuous sin", "start": [89, 1], "end": [91, 85], "kind": "commanddeclaration"}, {"full_name": "Real.continuousOn_sin", "code": "theorem continuousOn_sin {s} : ContinuousOn sin s", "start": [94, 1], "end": [95, 30], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_cos", "code": "@[continuity]\ntheorem continuous_cos : Continuous cos", "start": [98, 1], "end": [100, 85], "kind": "commanddeclaration"}, {"full_name": "Real.continuousOn_cos", "code": "theorem continuousOn_cos {s} : ContinuousOn cos s", "start": [103, 1], "end": [104, 30], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_sinh", "code": "@[continuity]\ntheorem continuous_sinh : Continuous sinh", "start": [107, 1], "end": [109, 86], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_cosh", "code": "@[continuity]\ntheorem continuous_cosh : Continuous cosh", "start": [112, 1], "end": [114, 86], "kind": "commanddeclaration"}, {"full_name": "Real.exists_cos_eq_zero", "code": "theorem exists_cos_eq_zero : 0 \u2208 cos '' Icc (1 : \u211d) 2", "start": [121, 1], "end": [123, 49], "kind": "commanddeclaration"}, {"full_name": "Real.pi", "code": "protected noncomputable def pi : \u211d :=\n  2 * Classical.choose exists_cos_eq_zero", "start": [126, 1], "end": [129, 42], "kind": "commanddeclaration"}, {"full_name": "Real.cos_pi_div_two", "code": "@[simp]\ntheorem cos_pi_div_two : cos (\u03c0 / 2) = 0", "start": [135, 1], "end": [138, 53], "kind": "commanddeclaration"}, {"full_name": "Real.one_le_pi_div_two", "code": "theorem one_le_pi_div_two : (1 : \u211d) \u2264 \u03c0 / 2", "start": [141, 1], "end": [143, 55], "kind": "commanddeclaration"}, {"full_name": "Real.pi_div_two_le_two", "code": "theorem pi_div_two_le_two : \u03c0 / 2 \u2264 2", "start": [146, 1], "end": [148, 55], "kind": "commanddeclaration"}, {"full_name": "Real.two_le_pi", "code": "theorem two_le_pi : (2 : \u211d) \u2264 \u03c0", "start": [151, 1], "end": [153, 65], "kind": "commanddeclaration"}, {"full_name": "Real.pi_le_four", "code": "theorem pi_le_four : \u03c0 \u2264 4", "start": [156, 1], "end": [160, 32], "kind": "commanddeclaration"}, {"full_name": "Real.pi_pos", "code": "theorem pi_pos : 0 < \u03c0", "start": [163, 1], "end": [164, 41], "kind": "commanddeclaration"}, {"full_name": "Real.Mathlib.Meta.Positivity.evalExp", "code": "@[positivity \u03c0]\ndef evalExp : Mathlib.Meta.Positivity.PositivityExt where eval {_ _} _ _ _ := do\n  pure (.positive (q(Real.pi_pos) : Lean.Expr))", "start": [170, 1], "end": [173, 48], "kind": "commanddeclaration"}, {"full_name": "Real.pi_ne_zero", "code": "theorem pi_ne_zero : \u03c0 \u2260 0", "start": [178, 1], "end": [179, 18], "kind": "commanddeclaration"}, {"full_name": "Real.pi_div_two_pos", "code": "theorem pi_div_two_pos : 0 < \u03c0 / 2", "start": [182, 1], "end": [183, 18], "kind": "commanddeclaration"}, {"full_name": "Real.two_pi_pos", "code": "theorem two_pi_pos : 0 < 2 * \u03c0", "start": [186, 1], "end": [186, 55], "kind": "commanddeclaration"}, {"full_name": "NNReal.pi", "code": "noncomputable def pi : \u211d\u22650 :=\n  \u27e8\u03c0, Real.pi_pos.le\u27e9", "start": [197, 1], "end": [199, 22], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_real_pi", "code": "@[simp]\ntheorem coe_real_pi : (pi : \u211d) = \u03c0", "start": [202, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.pi_pos", "code": "theorem pi_pos : 0 < pi", "start": [207, 1], "end": [207, 57], "kind": "commanddeclaration"}, {"full_name": "NNReal.pi_ne_zero", "code": "theorem pi_ne_zero : pi \u2260 0", "start": [210, 1], "end": [211, 13], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pi", "code": "@[simp]\ntheorem sin_pi : sin \u03c0 = 0", "start": [220, 1], "end": [222, 97], "kind": "commanddeclaration"}, {"full_name": "Real.cos_pi", "code": "@[simp]\ntheorem cos_pi : cos \u03c0 = -1", "start": [225, 1], "end": [228, 11], "kind": "commanddeclaration"}, {"full_name": "Real.sin_two_pi", "code": "@[simp]\ntheorem sin_two_pi : sin (2 * \u03c0) = 0", "start": [231, 1], "end": [232, 67], "kind": "commanddeclaration"}, {"full_name": "Real.cos_two_pi", "code": "@[simp]\ntheorem cos_two_pi : cos (2 * \u03c0) = 1", "start": [235, 1], "end": [236, 67], "kind": "commanddeclaration"}, {"full_name": "Real.sin_antiperiodic", "code": "theorem sin_antiperiodic : Function.Antiperiodic sin \u03c0", "start": [239, 1], "end": [239, 76], "kind": "commanddeclaration"}, {"full_name": "Real.sin_periodic", "code": "theorem sin_periodic : Function.Periodic sin (2 * \u03c0)", "start": [242, 1], "end": [243, 28], "kind": "commanddeclaration"}, {"full_name": "Real.sin_add_pi", "code": "@[simp]\ntheorem sin_add_pi (x : \u211d) : sin (x + \u03c0) = -sin x", "start": [246, 1], "end": [248, 21], "kind": "commanddeclaration"}, {"full_name": "Real.sin_add_two_pi", "code": "@[simp]\ntheorem sin_add_two_pi (x : \u211d) : sin (x + 2 * \u03c0) = sin x", "start": [251, 1], "end": [253, 17], "kind": "commanddeclaration"}, {"full_name": "Real.sin_sub_pi", "code": "@[simp]\ntheorem sin_sub_pi (x : \u211d) : sin (x - \u03c0) = -sin x", "start": [256, 1], "end": [258, 28], "kind": "commanddeclaration"}, {"full_name": "Real.sin_sub_two_pi", "code": "@[simp]\ntheorem sin_sub_two_pi (x : \u211d) : sin (x - 2 * \u03c0) = sin x", "start": [261, 1], "end": [263, 24], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pi_sub", "code": "@[simp]\ntheorem sin_pi_sub (x : \u211d) : sin (\u03c0 - x) = sin x", "start": [266, 1], "end": [268, 57], "kind": "commanddeclaration"}, {"full_name": "Real.sin_two_pi_sub", "code": "@[simp]\ntheorem sin_two_pi_sub (x : \u211d) : sin (2 * \u03c0 - x) = -sin x", "start": [271, 1], "end": [273, 35], "kind": "commanddeclaration"}, {"full_name": "Real.sin_nat_mul_pi", "code": "@[simp]\ntheorem sin_nat_mul_pi (n : \u2115) : sin (n * \u03c0) = 0", "start": [276, 1], "end": [278, 52], "kind": "commanddeclaration"}, {"full_name": "Real.sin_int_mul_pi", "code": "@[simp]\ntheorem sin_int_mul_pi (n : \u2124) : sin (n * \u03c0) = 0", "start": [281, 1], "end": [283, 52], "kind": "commanddeclaration"}, {"full_name": "Real.sin_add_nat_mul_two_pi", "code": "@[simp]\ntheorem sin_add_nat_mul_two_pi (x : \u211d) (n : \u2115) : sin (x + n * (2 * \u03c0)) = sin x", "start": [286, 1], "end": [288, 27], "kind": "commanddeclaration"}, {"full_name": "Real.sin_add_int_mul_two_pi", "code": "@[simp]\ntheorem sin_add_int_mul_two_pi (x : \u211d) (n : \u2124) : sin (x + n * (2 * \u03c0)) = sin x", "start": [291, 1], "end": [293, 27], "kind": "commanddeclaration"}, {"full_name": "Real.sin_sub_nat_mul_two_pi", "code": "@[simp]\ntheorem sin_sub_nat_mul_two_pi (x : \u211d) (n : \u2115) : sin (x - n * (2 * \u03c0)) = sin x", "start": [296, 1], "end": [298, 32], "kind": "commanddeclaration"}, {"full_name": "Real.sin_sub_int_mul_two_pi", "code": "@[simp]\ntheorem sin_sub_int_mul_two_pi (x : \u211d) (n : \u2124) : sin (x - n * (2 * \u03c0)) = sin x", "start": [301, 1], "end": [303, 32], "kind": "commanddeclaration"}, {"full_name": "Real.sin_nat_mul_two_pi_sub", "code": "@[simp]\ntheorem sin_nat_mul_two_pi_sub (x : \u211d) (n : \u2115) : sin (n * (2 * \u03c0) - x) = -sin x", "start": [306, 1], "end": [308, 44], "kind": "commanddeclaration"}, {"full_name": "Real.sin_int_mul_two_pi_sub", "code": "@[simp]\ntheorem sin_int_mul_two_pi_sub (x : \u211d) (n : \u2124) : sin (n * (2 * \u03c0) - x) = -sin x", "start": [311, 1], "end": [313, 44], "kind": "commanddeclaration"}, {"full_name": "Real.cos_antiperiodic", "code": "theorem cos_antiperiodic : Function.Antiperiodic cos \u03c0", "start": [316, 1], "end": [316, 76], "kind": "commanddeclaration"}, {"full_name": "Real.cos_periodic", "code": "theorem cos_periodic : Function.Periodic cos (2 * \u03c0)", "start": [319, 1], "end": [320, 28], "kind": "commanddeclaration"}, {"full_name": "Real.cos_add_pi", "code": "@[simp]\ntheorem cos_add_pi (x : \u211d) : cos (x + \u03c0) = -cos x", "start": [323, 1], "end": [325, 21], "kind": "commanddeclaration"}, {"full_name": "Real.cos_add_two_pi", "code": "@[simp]\ntheorem cos_add_two_pi (x : \u211d) : cos (x + 2 * \u03c0) = cos x", "start": [328, 1], "end": [330, 17], "kind": "commanddeclaration"}, {"full_name": "Real.cos_sub_pi", "code": "@[simp]\ntheorem cos_sub_pi (x : \u211d) : cos (x - \u03c0) = -cos x", "start": [333, 1], "end": [335, 28], "kind": "commanddeclaration"}, {"full_name": "Real.cos_sub_two_pi", "code": "@[simp]\ntheorem cos_sub_two_pi (x : \u211d) : cos (x - 2 * \u03c0) = cos x", "start": [338, 1], "end": [340, 24], "kind": "commanddeclaration"}, {"full_name": "Real.cos_pi_sub", "code": "@[simp]\ntheorem cos_pi_sub (x : \u211d) : cos (\u03c0 - x) = -cos x", "start": [343, 1], "end": [345, 39], "kind": "commanddeclaration"}, {"full_name": "Real.cos_two_pi_sub", "code": "@[simp]\ntheorem cos_two_pi_sub (x : \u211d) : cos (2 * \u03c0 - x) = cos x", "start": [348, 1], "end": [350, 35], "kind": "commanddeclaration"}, {"full_name": "Real.cos_nat_mul_two_pi", "code": "@[simp]\ntheorem cos_nat_mul_two_pi (n : \u2115) : cos (n * (2 * \u03c0)) = 1", "start": [353, 1], "end": [355, 45], "kind": "commanddeclaration"}, {"full_name": "Real.cos_int_mul_two_pi", "code": "@[simp]\ntheorem cos_int_mul_two_pi (n : \u2124) : cos (n * (2 * \u03c0)) = 1", "start": [358, 1], "end": [360, 45], "kind": "commanddeclaration"}, {"full_name": "Real.cos_add_nat_mul_two_pi", "code": "@[simp]\ntheorem cos_add_nat_mul_two_pi (x : \u211d) (n : \u2115) : cos (x + n * (2 * \u03c0)) = cos x", "start": [363, 1], "end": [365, 27], "kind": "commanddeclaration"}, {"full_name": "Real.cos_add_int_mul_two_pi", "code": "@[simp]\ntheorem cos_add_int_mul_two_pi (x : \u211d) (n : \u2124) : cos (x + n * (2 * \u03c0)) = cos x", "start": [368, 1], "end": [370, 27], "kind": "commanddeclaration"}, {"full_name": "Real.cos_sub_nat_mul_two_pi", "code": "@[simp]\ntheorem cos_sub_nat_mul_two_pi (x : \u211d) (n : \u2115) : cos (x - n * (2 * \u03c0)) = cos x", "start": [373, 1], "end": [375, 32], "kind": "commanddeclaration"}, {"full_name": "Real.cos_sub_int_mul_two_pi", "code": "@[simp]\ntheorem cos_sub_int_mul_two_pi (x : \u211d) (n : \u2124) : cos (x - n * (2 * \u03c0)) = cos x", "start": [378, 1], "end": [380, 32], "kind": "commanddeclaration"}, {"full_name": "Real.cos_nat_mul_two_pi_sub", "code": "@[simp]\ntheorem cos_nat_mul_two_pi_sub (x : \u211d) (n : \u2115) : cos (n * (2 * \u03c0) - x) = cos x", "start": [383, 1], "end": [385, 44], "kind": "commanddeclaration"}, {"full_name": "Real.cos_int_mul_two_pi_sub", "code": "@[simp]\ntheorem cos_int_mul_two_pi_sub (x : \u211d) (n : \u2124) : cos (n * (2 * \u03c0) - x) = cos x", "start": [388, 1], "end": [390, 44], "kind": "commanddeclaration"}, {"full_name": "Real.cos_nat_mul_two_pi_add_pi", "code": "theorem cos_nat_mul_two_pi_add_pi (n : \u2115) : cos (n * (2 * \u03c0) + \u03c0) = -1", "start": [394, 1], "end": [395, 90], "kind": "commanddeclaration"}, {"full_name": "Real.cos_int_mul_two_pi_add_pi", "code": "theorem cos_int_mul_two_pi_add_pi (n : \u2124) : cos (n * (2 * \u03c0) + \u03c0) = -1", "start": [399, 1], "end": [400, 90], "kind": "commanddeclaration"}, {"full_name": "Real.cos_nat_mul_two_pi_sub_pi", "code": "theorem cos_nat_mul_two_pi_sub_pi (n : \u2115) : cos (n * (2 * \u03c0) - \u03c0) = -1", "start": [404, 1], "end": [405, 90], "kind": "commanddeclaration"}, {"full_name": "Real.cos_int_mul_two_pi_sub_pi", "code": "theorem cos_int_mul_two_pi_sub_pi (n : \u2124) : cos (n * (2 * \u03c0) - \u03c0) = -1", "start": [409, 1], "end": [410, 90], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pos_of_pos_of_lt_pi", "code": "theorem sin_pos_of_pos_of_lt_pi {x : \u211d} (h0x : 0 < x) (hxp : x < \u03c0) : 0 < sin x", "start": [413, 1], "end": [419, 65], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pos_of_mem_Ioo", "code": "theorem sin_pos_of_mem_Ioo {x : \u211d} (hx : x \u2208 Ioo 0 \u03c0) : 0 < sin x", "start": [422, 1], "end": [423, 36], "kind": "commanddeclaration"}, {"full_name": "Real.sin_nonneg_of_mem_Icc", "code": "theorem sin_nonneg_of_mem_Icc {x : \u211d} (hx : x \u2208 Icc 0 \u03c0) : 0 \u2264 sin x", "start": [426, 1], "end": [430, 54], "kind": "commanddeclaration"}, {"full_name": "Real.sin_nonneg_of_nonneg_of_le_pi", "code": "theorem sin_nonneg_of_nonneg_of_le_pi {x : \u211d} (h0x : 0 \u2264 x) (hxp : x \u2264 \u03c0) : 0 \u2264 sin x", "start": [433, 1], "end": [434, 35], "kind": "commanddeclaration"}, {"full_name": "Real.sin_neg_of_neg_of_neg_pi_lt", "code": "theorem sin_neg_of_neg_of_neg_pi_lt {x : \u211d} (hx0 : x < 0) (hpx : -\u03c0 < x) : sin x < 0", "start": [437, 1], "end": [438, 82], "kind": "commanddeclaration"}, {"full_name": "Real.sin_nonpos_of_nonnpos_of_neg_pi_le", "code": "theorem sin_nonpos_of_nonnpos_of_neg_pi_le {x : \u211d} (hx0 : x \u2264 0) (hpx : -\u03c0 \u2264 x) : sin x \u2264 0", "start": [441, 1], "end": [442, 94], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pi_div_two", "code": "@[simp]\ntheorem sin_pi_div_two : sin (\u03c0 / 2) = 1", "start": [445, 1], "end": [451, 71], "kind": "commanddeclaration"}, {"full_name": "Real.sin_add_pi_div_two", "code": "theorem sin_add_pi_div_two (x : \u211d) : sin (x + \u03c0 / 2) = cos x", "start": [454, 1], "end": [454, 82], "kind": "commanddeclaration"}, {"full_name": "Real.sin_sub_pi_div_two", "code": "theorem sin_sub_pi_div_two (x : \u211d) : sin (x - \u03c0 / 2) = -cos x", "start": [457, 1], "end": [457, 99], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pi_div_two_sub", "code": "theorem sin_pi_div_two_sub (x : \u211d) : sin (\u03c0 / 2 - x) = cos x", "start": [460, 1], "end": [460, 98], "kind": "commanddeclaration"}, {"full_name": "Real.cos_add_pi_div_two", "code": "theorem cos_add_pi_div_two (x : \u211d) : cos (x + \u03c0 / 2) = -sin x", "start": [463, 1], "end": [463, 83], "kind": "commanddeclaration"}, {"full_name": "Real.cos_sub_pi_div_two", "code": "theorem cos_sub_pi_div_two (x : \u211d) : cos (x - \u03c0 / 2) = sin x", "start": [466, 1], "end": [466, 98], "kind": "commanddeclaration"}, {"full_name": "Real.cos_pi_div_two_sub", "code": "theorem cos_pi_div_two_sub (x : \u211d) : cos (\u03c0 / 2 - x) = sin x", "start": [469, 1], "end": [470, 46], "kind": "commanddeclaration"}, {"full_name": "Real.cos_pos_of_mem_Ioo", "code": "theorem cos_pos_of_mem_Ioo {x : \u211d} (hx : x \u2208 Ioo (-(\u03c0 / 2)) (\u03c0 / 2)) : 0 < cos x", "start": [473, 1], "end": [474, 85], "kind": "commanddeclaration"}, {"full_name": "Real.cos_nonneg_of_mem_Icc", "code": "theorem cos_nonneg_of_mem_Icc {x : \u211d} (hx : x \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)) : 0 \u2264 cos x", "start": [477, 1], "end": [478, 88], "kind": "commanddeclaration"}, {"full_name": "Real.cos_nonneg_of_neg_pi_div_two_le_of_le", "code": "theorem cos_nonneg_of_neg_pi_div_two_le_of_le {x : \u211d} (hl : -(\u03c0 / 2) \u2264 x) (hu : x \u2264 \u03c0 / 2) :\n    0 \u2264 cos x", "start": [481, 1], "end": [483, 33], "kind": "commanddeclaration"}, {"full_name": "Real.cos_neg_of_pi_div_two_lt_of_lt", "code": "theorem cos_neg_of_pi_div_two_lt_of_lt {x : \u211d} (hx\u2081 : \u03c0 / 2 < x) (hx\u2082 : x < \u03c0 + \u03c0 / 2) :\n    cos x < 0", "start": [486, 1], "end": [488, 76], "kind": "commanddeclaration"}, {"full_name": "Real.cos_nonpos_of_pi_div_two_le_of_le", "code": "theorem cos_nonpos_of_pi_div_two_le_of_le {x : \u211d} (hx\u2081 : \u03c0 / 2 \u2264 x) (hx\u2082 : x \u2264 \u03c0 + \u03c0 / 2) :\n    cos x \u2264 0", "start": [491, 1], "end": [493, 82], "kind": "commanddeclaration"}, {"full_name": "Real.sin_eq_sqrt_one_sub_cos_sq", "code": "theorem sin_eq_sqrt_one_sub_cos_sq {x : \u211d} (hl : 0 \u2264 x) (hu : x \u2264 \u03c0) :\n    sin x = sqrt (1 - cos x ^ 2)", "start": [496, 1], "end": [498, 93], "kind": "commanddeclaration"}, {"full_name": "Real.cos_eq_sqrt_one_sub_sin_sq", "code": "theorem cos_eq_sqrt_one_sub_sin_sq {x : \u211d} (hl : -(\u03c0 / 2) \u2264 x) (hu : x \u2264 \u03c0 / 2) :\n    cos x = sqrt (1 - sin x ^ 2)", "start": [501, 1], "end": [503, 88], "kind": "commanddeclaration"}, {"full_name": "Real.sin_eq_zero_iff_of_lt_of_lt", "code": "theorem sin_eq_zero_iff_of_lt_of_lt {x : \u211d} (hx\u2081 : -\u03c0 < x) (hx\u2082 : x < \u03c0) : sin x = 0 \u2194 x = 0", "start": [506, 1], "end": [512, 24], "kind": "commanddeclaration"}, {"full_name": "Real.sin_eq_zero_iff", "code": "theorem sin_eq_zero_iff {x : \u211d} : sin x = 0 \u2194 \u2203 n : \u2124, (n : \u211d) * \u03c0 = x", "start": [515, 1], "end": [523, 42], "kind": "commanddeclaration"}, {"full_name": "Real.sin_ne_zero_iff", "code": "theorem sin_ne_zero_iff {x : \u211d} : sin x \u2260 0 \u2194 \u2200 n : \u2124, (n : \u211d) * \u03c0 \u2260 x", "start": [526, 1], "end": [527, 50], "kind": "commanddeclaration"}, {"full_name": "Real.sin_eq_zero_iff_cos_eq", "code": "theorem sin_eq_zero_iff_cos_eq {x : \u211d} : sin x = 0 \u2194 cos x = 1 \u2228 cos x = -1", "start": [530, 1], "end": [532, 78], "kind": "commanddeclaration"}, {"full_name": "Real.cos_eq_one_iff", "code": "theorem cos_eq_one_iff (x : \u211d) : cos x = 1 \u2194 \u2203 n : \u2124, (n : \u211d) * (2 * \u03c0) = x", "start": [535, 1], "end": [548, 46], "kind": "commanddeclaration"}, {"full_name": "Real.cos_eq_one_iff_of_lt_of_lt", "code": "theorem cos_eq_one_iff_of_lt_of_lt {x : \u211d} (hx\u2081 : -(2 * \u03c0) < x) (hx\u2082 : x < 2 * \u03c0) :\n    cos x = 1 \u2194 x = 0", "start": [551, 1], "end": [559, 32], "kind": "commanddeclaration"}, {"full_name": "Real.cos_lt_cos_of_nonneg_of_le_pi_div_two", "code": "theorem cos_lt_cos_of_nonneg_of_le_pi_div_two {x y : \u211d} (hx\u2081 : 0 \u2264 x) (hy\u2082 : y \u2264 \u03c0 / 2)\n    (hxy : x < y) : cos y < cos x", "start": [562, 1], "end": [567, 12], "kind": "commanddeclaration"}, {"full_name": "Real.cos_lt_cos_of_nonneg_of_le_pi", "code": "theorem cos_lt_cos_of_nonneg_of_le_pi {x y : \u211d} (hx\u2081 : 0 \u2264 x) (hy\u2082 : y \u2264 \u03c0) (hxy : x < y) :\n    cos y < cos x", "start": [570, 1], "end": [589, 20], "kind": "commanddeclaration"}, {"full_name": "Real.strictAntiOn_cos", "code": "theorem strictAntiOn_cos : StrictAntiOn cos (Icc 0 \u03c0)", "start": [592, 1], "end": [593, 46], "kind": "commanddeclaration"}, {"full_name": "Real.cos_le_cos_of_nonneg_of_le_pi", "code": "theorem cos_le_cos_of_nonneg_of_le_pi {x y : \u211d} (hx\u2081 : 0 \u2264 x) (hy\u2082 : y \u2264 \u03c0) (hxy : x \u2264 y) :\n    cos y \u2264 cos x", "start": [596, 1], "end": [598, 79], "kind": "commanddeclaration"}, {"full_name": "Real.sin_lt_sin_of_lt_of_le_pi_div_two", "code": "theorem sin_lt_sin_of_lt_of_le_pi_div_two {x y : \u211d} (hx\u2081 : -(\u03c0 / 2) \u2264 x) (hy\u2082 : y \u2264 \u03c0 / 2)\n    (hxy : x < y) : sin x < sin y", "start": [601, 1], "end": [604, 51], "kind": "commanddeclaration"}, {"full_name": "Real.strictMonoOn_sin", "code": "theorem strictMonoOn_sin : StrictMonoOn sin (Icc (-(\u03c0 / 2)) (\u03c0 / 2))", "start": [607, 1], "end": [608, 50], "kind": "commanddeclaration"}, {"full_name": "Real.sin_le_sin_of_le_of_le_pi_div_two", "code": "theorem sin_le_sin_of_le_of_le_pi_div_two {x y : \u211d} (hx\u2081 : -(\u03c0 / 2) \u2264 x) (hy\u2082 : y \u2264 \u03c0 / 2)\n    (hxy : x \u2264 y) : sin x \u2264 sin y", "start": [611, 1], "end": [613, 79], "kind": "commanddeclaration"}, {"full_name": "Real.injOn_sin", "code": "theorem injOn_sin : InjOn sin (Icc (-(\u03c0 / 2)) (\u03c0 / 2))", "start": [616, 1], "end": [617, 25], "kind": "commanddeclaration"}, {"full_name": "Real.injOn_cos", "code": "theorem injOn_cos : InjOn cos (Icc 0 \u03c0)", "start": [620, 1], "end": [621, 25], "kind": "commanddeclaration"}, {"full_name": "Real.surjOn_sin", "code": "theorem surjOn_sin : SurjOn sin (Icc (-(\u03c0 / 2)) (\u03c0 / 2)) (Icc (-1) 1)", "start": [624, 1], "end": [626, 87], "kind": "commanddeclaration"}, {"full_name": "Real.surjOn_cos", "code": "theorem surjOn_cos : SurjOn cos (Icc 0 \u03c0) (Icc (-1) 1)", "start": [629, 1], "end": [630, 100], "kind": "commanddeclaration"}, {"full_name": "Real.sin_mem_Icc", "code": "theorem sin_mem_Icc (x : \u211d) : sin x \u2208 Icc (-1 : \u211d) 1", "start": [633, 1], "end": [634, 35], "kind": "commanddeclaration"}, {"full_name": "Real.cos_mem_Icc", "code": "theorem cos_mem_Icc (x : \u211d) : cos x \u2208 Icc (-1 : \u211d) 1", "start": [637, 1], "end": [638, 35], "kind": "commanddeclaration"}, {"full_name": "Real.mapsTo_sin", "code": "theorem mapsTo_sin (s : Set \u211d) : MapsTo sin s (Icc (-1 : \u211d) 1)", "start": [641, 1], "end": [641, 91], "kind": "commanddeclaration"}, {"full_name": "Real.mapsTo_cos", "code": "theorem mapsTo_cos (s : Set \u211d) : MapsTo cos s (Icc (-1 : \u211d) 1)", "start": [644, 1], "end": [644, 91], "kind": "commanddeclaration"}, {"full_name": "Real.bijOn_sin", "code": "theorem bijOn_sin : BijOn sin (Icc (-(\u03c0 / 2)) (\u03c0 / 2)) (Icc (-1) 1)", "start": [647, 1], "end": [648, 40], "kind": "commanddeclaration"}, {"full_name": "Real.bijOn_cos", "code": "theorem bijOn_cos : BijOn cos (Icc 0 \u03c0) (Icc (-1) 1)", "start": [651, 1], "end": [652, 40], "kind": "commanddeclaration"}, {"full_name": "Real.range_cos", "code": "@[simp]\ntheorem range_cos : range cos = (Icc (-1) 1 : Set \u211d)", "start": [655, 1], "end": [657, 75], "kind": "commanddeclaration"}, {"full_name": "Real.range_sin", "code": "@[simp]\ntheorem range_sin : range sin = (Icc (-1) 1 : Set \u211d)", "start": [660, 1], "end": [662, 75], "kind": "commanddeclaration"}, {"full_name": "Real.range_cos_infinite", "code": "theorem range_cos_infinite : (range Real.cos).Infinite", "start": [665, 1], "end": [667, 35], "kind": "commanddeclaration"}, {"full_name": "Real.range_sin_infinite", "code": "theorem range_sin_infinite : (range Real.sin).Infinite", "start": [670, 1], "end": [672, 35], "kind": "commanddeclaration"}, {"full_name": "Real.sqrtTwoAddSeries", "code": "@[simp]\nnoncomputable def sqrtTwoAddSeries (x : \u211d) : \u2115 \u2192 \u211d\n  | 0 => x\n  | n + 1 => sqrt (2 + sqrtTwoAddSeries x n)", "start": [679, 1], "end": [685, 45], "kind": "commanddeclaration"}, {"full_name": "Real.sqrtTwoAddSeries_zero", "code": "theorem sqrtTwoAddSeries_zero : sqrtTwoAddSeries x 0 = x", "start": [688, 1], "end": [688, 68], "kind": "commanddeclaration"}, {"full_name": "Real.sqrtTwoAddSeries_one", "code": "theorem sqrtTwoAddSeries_one : sqrtTwoAddSeries 0 1 = sqrt 2", "start": [691, 1], "end": [691, 72], "kind": "commanddeclaration"}, {"full_name": "Real.sqrtTwoAddSeries_two", "code": "theorem sqrtTwoAddSeries_two : sqrtTwoAddSeries 0 2 = sqrt (2 + sqrt 2)", "start": [694, 1], "end": [694, 83], "kind": "commanddeclaration"}, {"full_name": "Real.sqrtTwoAddSeries_zero_nonneg", "code": "theorem sqrtTwoAddSeries_zero_nonneg : \u2200 n : \u2115, 0 \u2264 sqrtTwoAddSeries 0 n", "start": [697, 1], "end": [699, 27], "kind": "commanddeclaration"}, {"full_name": "Real.sqrtTwoAddSeries_nonneg", "code": "theorem sqrtTwoAddSeries_nonneg {x : \u211d} (h : 0 \u2264 x) : \u2200 n : \u2115, 0 \u2264 sqrtTwoAddSeries x n", "start": [702, 1], "end": [704, 27], "kind": "commanddeclaration"}, {"full_name": "Real.sqrtTwoAddSeries_lt_two", "code": "theorem sqrtTwoAddSeries_lt_two : \u2200 n : \u2115, sqrtTwoAddSeries 0 n < 2", "start": [707, 1], "end": [714, 68], "kind": "commanddeclaration"}, {"full_name": "Real.sqrtTwoAddSeries_succ", "code": "theorem sqrtTwoAddSeries_succ (x : \u211d) :\n    \u2200 n : \u2115, sqrtTwoAddSeries x (n + 1) = sqrtTwoAddSeries (sqrt (2 + x)) n", "start": [717, 1], "end": [720, 83], "kind": "commanddeclaration"}, {"full_name": "Real.sqrtTwoAddSeries_monotone_left", "code": "theorem sqrtTwoAddSeries_monotone_left {x y : \u211d} (h : x \u2264 y) :\n    \u2200 n : \u2115, sqrtTwoAddSeries x n \u2264 sqrtTwoAddSeries y n", "start": [723, 1], "end": [728, 80], "kind": "commanddeclaration"}, {"full_name": "Real.cos_pi_over_two_pow", "code": "@[simp]\ntheorem cos_pi_over_two_pow : \u2200 n : \u2115, cos (\u03c0 / 2 ^ (n + 1)) = sqrtTwoAddSeries 0 n / 2", "start": [731, 1], "end": [752, 40], "kind": "commanddeclaration"}, {"full_name": "Real.sin_sq_pi_over_two_pow", "code": "theorem sin_sq_pi_over_two_pow (n : \u2115) :\n    sin (\u03c0 / 2 ^ (n + 1)) ^ 2 = 1 - (sqrtTwoAddSeries 0 n / 2) ^ 2", "start": [755, 1], "end": [757, 35], "kind": "commanddeclaration"}, {"full_name": "Real.sin_sq_pi_over_two_pow_succ", "code": "theorem sin_sq_pi_over_two_pow_succ (n : \u2115) :\n    sin (\u03c0 / 2 ^ (n + 2)) ^ 2 = 1 / 2 - sqrtTwoAddSeries 0 n / 4", "start": [760, 1], "end": [766, 65], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pi_over_two_pow_succ", "code": "@[simp]\ntheorem sin_pi_over_two_pow_succ (n : \u2115) :\n    sin (\u03c0 / 2 ^ (n + 2)) = sqrt (2 - sqrtTwoAddSeries 0 n) / 2", "start": [769, 1], "end": [784, 23], "kind": "commanddeclaration"}, {"full_name": "Real.cos_pi_div_four", "code": "@[simp]\ntheorem cos_pi_div_four : cos (\u03c0 / 4) = sqrt 2 / 2", "start": [787, 1], "end": [792, 9], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pi_div_four", "code": "@[simp]\ntheorem sin_pi_div_four : sin (\u03c0 / 4) = sqrt 2 / 2", "start": [795, 1], "end": [800, 9], "kind": "commanddeclaration"}, {"full_name": "Real.cos_pi_div_eight", "code": "@[simp]\ntheorem cos_pi_div_eight : cos (\u03c0 / 8) = sqrt (2 + sqrt 2) / 2", "start": [803, 1], "end": [808, 9], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pi_div_eight", "code": "@[simp]\ntheorem sin_pi_div_eight : sin (\u03c0 / 8) = sqrt (2 - sqrt 2) / 2", "start": [811, 1], "end": [816, 9], "kind": "commanddeclaration"}, {"full_name": "Real.cos_pi_div_sixteen", "code": "@[simp]\ntheorem cos_pi_div_sixteen : cos (\u03c0 / 16) = sqrt (2 + sqrt (2 + sqrt 2)) / 2", "start": [819, 1], "end": [824, 9], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pi_div_sixteen", "code": "@[simp]\ntheorem sin_pi_div_sixteen : sin (\u03c0 / 16) = sqrt (2 - sqrt (2 + sqrt 2)) / 2", "start": [827, 1], "end": [832, 9], "kind": "commanddeclaration"}, {"full_name": "Real.cos_pi_div_thirty_two", "code": "@[simp]\ntheorem cos_pi_div_thirty_two : cos (\u03c0 / 32) = sqrt (2 + sqrt (2 + sqrt (2 + sqrt 2))) / 2", "start": [835, 1], "end": [840, 9], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pi_div_thirty_two", "code": "@[simp]\ntheorem sin_pi_div_thirty_two : sin (\u03c0 / 32) = sqrt (2 - sqrt (2 + sqrt (2 + sqrt 2))) / 2", "start": [843, 1], "end": [848, 9], "kind": "commanddeclaration"}, {"full_name": "Real.cos_pi_div_three", "code": "@[simp]\ntheorem cos_pi_div_three : cos (\u03c0 / 3) = 1 / 2", "start": [852, 1], "end": [864, 22], "kind": "commanddeclaration"}, {"full_name": "Real.sq_cos_pi_div_six", "code": "theorem sq_cos_pi_div_six : cos (\u03c0 / 6) ^ 2 = 3 / 4", "start": [867, 1], "end": [876, 7], "kind": "commanddeclaration"}, {"full_name": "Real.cos_pi_div_six", "code": "@[simp]\ntheorem cos_pi_div_six : cos (\u03c0 / 6) = sqrt 3 / 2", "start": [879, 1], "end": [891, 13], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pi_div_six", "code": "@[simp]\ntheorem sin_pi_div_six : sin (\u03c0 / 6) = 1 / 2", "start": [894, 1], "end": [899, 7], "kind": "commanddeclaration"}, {"full_name": "Real.sq_sin_pi_div_three", "code": "theorem sq_sin_pi_div_three : sin (\u03c0 / 3) ^ 2 = 3 / 4", "start": [902, 1], "end": [907, 7], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pi_div_three", "code": "@[simp]\ntheorem sin_pi_div_three : sin (\u03c0 / 3) = sqrt 3 / 2", "start": [910, 1], "end": [915, 7], "kind": "commanddeclaration"}, {"full_name": "Real.sinOrderIso", "code": "def sinOrderIso : Icc (-(\u03c0 / 2)) (\u03c0 / 2) \u2243o Icc (-1 : \u211d) 1 :=\n  (strictMonoOn_sin.orderIso _ _).trans <| OrderIso.setCongr _ _ bijOn_sin.image_eq", "start": [920, 1], "end": [922, 84], "kind": "commanddeclaration"}, {"full_name": "Real.coe_sinOrderIso_apply", "code": "@[simp]\ntheorem coe_sinOrderIso_apply (x : Icc (-(\u03c0 / 2)) (\u03c0 / 2)) : (sinOrderIso x : \u211d) = sin x", "start": [925, 1], "end": [927, 6], "kind": "commanddeclaration"}, {"full_name": "Real.sinOrderIso_apply", "code": "theorem sinOrderIso_apply (x : Icc (-(\u03c0 / 2)) (\u03c0 / 2)) : sinOrderIso x = \u27e8sin x, sin_mem_Icc x\u27e9", "start": [930, 1], "end": [931, 6], "kind": "commanddeclaration"}, {"full_name": "Real.tan_pi_div_four", "code": "@[simp]\ntheorem tan_pi_div_four : tan (\u03c0 / 4) = 1", "start": [934, 1], "end": [938, 30], "kind": "commanddeclaration"}, {"full_name": "Real.tan_pi_div_two", "code": "@[simp]\ntheorem tan_pi_div_two : tan (\u03c0 / 2) = 0", "start": [941, 1], "end": [942, 73], "kind": "commanddeclaration"}, {"full_name": "Real.tan_pos_of_pos_of_lt_pi_div_two", "code": "theorem tan_pos_of_pos_of_lt_pi_div_two {x : \u211d} (h0x : 0 < x) (hxp : x < \u03c0 / 2) : 0 < tan x", "start": [945, 1], "end": [947, 100], "kind": "commanddeclaration"}, {"full_name": "Real.tan_nonneg_of_nonneg_of_le_pi_div_two", "code": "theorem tan_nonneg_of_nonneg_of_le_pi_div_two {x : \u211d} (h0x : 0 \u2264 x) (hxp : x \u2264 \u03c0 / 2) : 0 \u2264 tan x", "start": [950, 1], "end": [954, 40], "kind": "commanddeclaration"}, {"full_name": "Real.tan_neg_of_neg_of_pi_div_two_lt", "code": "theorem tan_neg_of_neg_of_pi_div_two_lt {x : \u211d} (hx0 : x < 0) (hpx : -(\u03c0 / 2) < x) : tan x < 0", "start": [957, 1], "end": [958, 95], "kind": "commanddeclaration"}, {"full_name": "Real.tan_nonpos_of_nonpos_of_neg_pi_div_two_le", "code": "theorem tan_nonpos_of_nonpos_of_neg_pi_div_two_le {x : \u211d} (hx0 : x \u2264 0) (hpx : -(\u03c0 / 2) \u2264 x) :\n    tan x \u2264 0", "start": [961, 1], "end": [963, 95], "kind": "commanddeclaration"}, {"full_name": "Real.tan_lt_tan_of_nonneg_of_lt_pi_div_two", "code": "theorem tan_lt_tan_of_nonneg_of_lt_pi_div_two {x y : \u211d} (hx\u2081 : 0 \u2264 x) (hy\u2082 : y < \u03c0 / 2)\n    (hxy : x < y) : tan x < tan y", "start": [966, 1], "end": [973, 46], "kind": "commanddeclaration"}, {"full_name": "Real.tan_lt_tan_of_lt_of_lt_pi_div_two", "code": "theorem tan_lt_tan_of_lt_of_lt_pi_div_two {x y : \u211d} (hx\u2081 : -(\u03c0 / 2) < x) (hy\u2082 : y < \u03c0 / 2)\n    (hxy : x < y) : tan x < tan y", "start": [976, 1], "end": [992, 78], "kind": "commanddeclaration"}, {"full_name": "Real.strictMonoOn_tan", "code": "theorem strictMonoOn_tan : StrictMonoOn tan (Ioo (-(\u03c0 / 2)) (\u03c0 / 2))", "start": [995, 1], "end": [996, 46], "kind": "commanddeclaration"}, {"full_name": "Real.injOn_tan", "code": "theorem injOn_tan : InjOn tan (Ioo (-(\u03c0 / 2)) (\u03c0 / 2))", "start": [999, 1], "end": [1000, 25], "kind": "commanddeclaration"}, {"full_name": "Real.tan_inj_of_lt_of_lt_pi_div_two", "code": "theorem tan_inj_of_lt_of_lt_pi_div_two {x y : \u211d} (hx\u2081 : -(\u03c0 / 2) < x) (hx\u2082 : x < \u03c0 / 2)\n    (hy\u2081 : -(\u03c0 / 2) < y) (hy\u2082 : y < \u03c0 / 2) (hxy : tan x = tan y) : x = y", "start": [1003, 1], "end": [1005, 38], "kind": "commanddeclaration"}, {"full_name": "Real.tan_periodic", "code": "theorem tan_periodic : Function.Periodic tan \u03c0", "start": [1008, 1], "end": [1009, 97], "kind": "commanddeclaration"}, {"full_name": "Real.tan_pi", "code": "@[simp]\ntheorem tan_pi : tan \u03c0 = 0", "start": [1013, 1], "end": [1014, 64], "kind": "commanddeclaration"}, {"full_name": "Real.tan_add_pi", "code": "theorem tan_add_pi (x : \u211d) : tan (x + \u03c0) = tan x", "start": [1016, 1], "end": [1017, 17], "kind": "commanddeclaration"}, {"full_name": "Real.tan_sub_pi", "code": "theorem tan_sub_pi (x : \u211d) : tan (x - \u03c0) = tan x", "start": [1020, 1], "end": [1021, 24], "kind": "commanddeclaration"}, {"full_name": "Real.tan_pi_sub", "code": "theorem tan_pi_sub (x : \u211d) : tan (\u03c0 - x) = -tan x", "start": [1024, 1], "end": [1025, 35], "kind": "commanddeclaration"}, {"full_name": "Real.tan_pi_div_two_sub", "code": "theorem tan_pi_div_two_sub (x : \u211d) : tan (\u03c0 / 2 - x) = (tan x)\u207b\u00b9", "start": [1028, 1], "end": [1029, 95], "kind": "commanddeclaration"}, {"full_name": "Real.tan_nat_mul_pi", "code": "theorem tan_nat_mul_pi (n : \u2115) : tan (n * \u03c0) = 0", "start": [1032, 1], "end": [1033, 39], "kind": "commanddeclaration"}, {"full_name": "Real.tan_int_mul_pi", "code": "theorem tan_int_mul_pi (n : \u2124) : tan (n * \u03c0) = 0", "start": [1036, 1], "end": [1037, 39], "kind": "commanddeclaration"}, {"full_name": "Real.tan_add_nat_mul_pi", "code": "theorem tan_add_nat_mul_pi (x : \u211d) (n : \u2115) : tan (x + n * \u03c0) = tan x", "start": [1040, 1], "end": [1041, 27], "kind": "commanddeclaration"}, {"full_name": "Real.tan_add_int_mul_pi", "code": "theorem tan_add_int_mul_pi (x : \u211d) (n : \u2124) : tan (x + n * \u03c0) = tan x", "start": [1044, 1], "end": [1045, 27], "kind": "commanddeclaration"}, {"full_name": "Real.tan_sub_nat_mul_pi", "code": "theorem tan_sub_nat_mul_pi (x : \u211d) (n : \u2115) : tan (x - n * \u03c0) = tan x", "start": [1048, 1], "end": [1049, 32], "kind": "commanddeclaration"}, {"full_name": "Real.tan_sub_int_mul_pi", "code": "theorem tan_sub_int_mul_pi (x : \u211d) (n : \u2124) : tan (x - n * \u03c0) = tan x", "start": [1052, 1], "end": [1053, 32], "kind": "commanddeclaration"}, {"full_name": "Real.tan_nat_mul_pi_sub", "code": "theorem tan_nat_mul_pi_sub (x : \u211d) (n : \u2115) : tan (n * \u03c0 - x) = -tan x", "start": [1056, 1], "end": [1057, 44], "kind": "commanddeclaration"}, {"full_name": "Real.tan_int_mul_pi_sub", "code": "theorem tan_int_mul_pi_sub (x : \u211d) (n : \u2124) : tan (n * \u03c0 - x) = -tan x", "start": [1060, 1], "end": [1061, 44], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_sin_pi_div_two", "code": "theorem tendsto_sin_pi_div_two : Tendsto sin (\ud835\udcdd[<] (\u03c0 / 2)) (\ud835\udcdd 1)", "start": [1064, 1], "end": [1066, 7], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_cos_pi_div_two", "code": "theorem tendsto_cos_pi_div_two : Tendsto cos (\ud835\udcdd[<] (\u03c0 / 2)) (\ud835\udcdd[>] 0)", "start": [1069, 1], "end": [1074, 96], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_tan_pi_div_two", "code": "theorem tendsto_tan_pi_div_two : Tendsto tan (\ud835\udcdd[<] (\u03c0 / 2)) atTop", "start": [1077, 1], "end": [1080, 67], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_sin_neg_pi_div_two", "code": "theorem tendsto_sin_neg_pi_div_two : Tendsto sin (\ud835\udcdd[>] (-(\u03c0 / 2))) (\ud835\udcdd (-1))", "start": [1083, 1], "end": [1085, 7], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_cos_neg_pi_div_two", "code": "theorem tendsto_cos_neg_pi_div_two : Tendsto cos (\ud835\udcdd[>] (-(\u03c0 / 2))) (\ud835\udcdd[>] 0)", "start": [1088, 1], "end": [1093, 95], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_tan_neg_pi_div_two", "code": "theorem tendsto_tan_neg_pi_div_two : Tendsto tan (\ud835\udcdd[>] (-(\u03c0 / 2))) atBot", "start": [1096, 1], "end": [1099, 67], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_eq_zero_iff_cos_eq", "code": "theorem sin_eq_zero_iff_cos_eq {z : \u2102} : sin z = 0 \u2194 cos z = 1 \u2228 cos z = -1", "start": [1108, 1], "end": [1110, 78], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_pi_div_two", "code": "@[simp]\ntheorem cos_pi_div_two : cos (\u03c0 / 2) = 0", "start": [1113, 1], "end": [1117, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_pi_div_two", "code": "@[simp]\ntheorem sin_pi_div_two : sin (\u03c0 / 2) = 1", "start": [1120, 1], "end": [1124, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_pi", "code": "@[simp]\ntheorem sin_pi : sin \u03c0 = 0", "start": [1127, 1], "end": [1128, 70], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_pi", "code": "@[simp]\ntheorem cos_pi : cos \u03c0 = -1", "start": [1131, 1], "end": [1132, 71], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_two_pi", "code": "@[simp]\ntheorem sin_two_pi : sin (2 * \u03c0) = 0", "start": [1135, 1], "end": [1136, 67], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_two_pi", "code": "@[simp]\ntheorem cos_two_pi : cos (2 * \u03c0) = 1", "start": [1139, 1], "end": [1140, 67], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_antiperiodic", "code": "theorem sin_antiperiodic : Function.Antiperiodic sin \u03c0", "start": [1143, 1], "end": [1143, 76], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_periodic", "code": "theorem sin_periodic : Function.Periodic sin (2 * \u03c0)", "start": [1146, 1], "end": [1147, 28], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_add_pi", "code": "theorem sin_add_pi (x : \u2102) : sin (x + \u03c0) = -sin x", "start": [1150, 1], "end": [1151, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_add_two_pi", "code": "theorem sin_add_two_pi (x : \u2102) : sin (x + 2 * \u03c0) = sin x", "start": [1154, 1], "end": [1155, 17], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_sub_pi", "code": "theorem sin_sub_pi (x : \u2102) : sin (x - \u03c0) = -sin x", "start": [1158, 1], "end": [1159, 28], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_sub_two_pi", "code": "theorem sin_sub_two_pi (x : \u2102) : sin (x - 2 * \u03c0) = sin x", "start": [1162, 1], "end": [1163, 24], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_pi_sub", "code": "theorem sin_pi_sub (x : \u2102) : sin (\u03c0 - x) = sin x", "start": [1166, 1], "end": [1167, 57], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_two_pi_sub", "code": "theorem sin_two_pi_sub (x : \u2102) : sin (2 * \u03c0 - x) = -sin x", "start": [1170, 1], "end": [1171, 35], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_nat_mul_pi", "code": "theorem sin_nat_mul_pi (n : \u2115) : sin (n * \u03c0) = 0", "start": [1174, 1], "end": [1175, 52], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_int_mul_pi", "code": "theorem sin_int_mul_pi (n : \u2124) : sin (n * \u03c0) = 0", "start": [1178, 1], "end": [1179, 52], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_add_nat_mul_two_pi", "code": "theorem sin_add_nat_mul_two_pi (x : \u2102) (n : \u2115) : sin (x + n * (2 * \u03c0)) = sin x", "start": [1182, 1], "end": [1183, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_add_int_mul_two_pi", "code": "theorem sin_add_int_mul_two_pi (x : \u2102) (n : \u2124) : sin (x + n * (2 * \u03c0)) = sin x", "start": [1186, 1], "end": [1187, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_sub_nat_mul_two_pi", "code": "theorem sin_sub_nat_mul_two_pi (x : \u2102) (n : \u2115) : sin (x - n * (2 * \u03c0)) = sin x", "start": [1190, 1], "end": [1191, 32], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_sub_int_mul_two_pi", "code": "theorem sin_sub_int_mul_two_pi (x : \u2102) (n : \u2124) : sin (x - n * (2 * \u03c0)) = sin x", "start": [1194, 1], "end": [1195, 32], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_nat_mul_two_pi_sub", "code": "theorem sin_nat_mul_two_pi_sub (x : \u2102) (n : \u2115) : sin (n * (2 * \u03c0) - x) = -sin x", "start": [1198, 1], "end": [1199, 44], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_int_mul_two_pi_sub", "code": "theorem sin_int_mul_two_pi_sub (x : \u2102) (n : \u2124) : sin (n * (2 * \u03c0) - x) = -sin x", "start": [1202, 1], "end": [1203, 44], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_antiperiodic", "code": "theorem cos_antiperiodic : Function.Antiperiodic cos \u03c0", "start": [1206, 1], "end": [1206, 76], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_periodic", "code": "theorem cos_periodic : Function.Periodic cos (2 * \u03c0)", "start": [1209, 1], "end": [1210, 28], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_add_pi", "code": "theorem cos_add_pi (x : \u2102) : cos (x + \u03c0) = -cos x", "start": [1213, 1], "end": [1214, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_add_two_pi", "code": "theorem cos_add_two_pi (x : \u2102) : cos (x + 2 * \u03c0) = cos x", "start": [1217, 1], "end": [1218, 17], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_sub_pi", "code": "theorem cos_sub_pi (x : \u2102) : cos (x - \u03c0) = -cos x", "start": [1221, 1], "end": [1222, 28], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_sub_two_pi", "code": "theorem cos_sub_two_pi (x : \u2102) : cos (x - 2 * \u03c0) = cos x", "start": [1225, 1], "end": [1226, 24], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_pi_sub", "code": "theorem cos_pi_sub (x : \u2102) : cos (\u03c0 - x) = -cos x", "start": [1229, 1], "end": [1230, 39], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_two_pi_sub", "code": "theorem cos_two_pi_sub (x : \u2102) : cos (2 * \u03c0 - x) = cos x", "start": [1233, 1], "end": [1234, 35], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_nat_mul_two_pi", "code": "theorem cos_nat_mul_two_pi (n : \u2115) : cos (n * (2 * \u03c0)) = 1", "start": [1237, 1], "end": [1238, 45], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_int_mul_two_pi", "code": "theorem cos_int_mul_two_pi (n : \u2124) : cos (n * (2 * \u03c0)) = 1", "start": [1241, 1], "end": [1242, 45], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_add_nat_mul_two_pi", "code": "theorem cos_add_nat_mul_two_pi (x : \u2102) (n : \u2115) : cos (x + n * (2 * \u03c0)) = cos x", "start": [1245, 1], "end": [1246, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_add_int_mul_two_pi", "code": "theorem cos_add_int_mul_two_pi (x : \u2102) (n : \u2124) : cos (x + n * (2 * \u03c0)) = cos x", "start": [1249, 1], "end": [1250, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_sub_nat_mul_two_pi", "code": "theorem cos_sub_nat_mul_two_pi (x : \u2102) (n : \u2115) : cos (x - n * (2 * \u03c0)) = cos x", "start": [1253, 1], "end": [1254, 32], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_sub_int_mul_two_pi", "code": "theorem cos_sub_int_mul_two_pi (x : \u2102) (n : \u2124) : cos (x - n * (2 * \u03c0)) = cos x", "start": [1257, 1], "end": [1258, 32], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_nat_mul_two_pi_sub", "code": "theorem cos_nat_mul_two_pi_sub (x : \u2102) (n : \u2115) : cos (n * (2 * \u03c0) - x) = cos x", "start": [1261, 1], "end": [1262, 44], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_int_mul_two_pi_sub", "code": "theorem cos_int_mul_two_pi_sub (x : \u2102) (n : \u2124) : cos (n * (2 * \u03c0) - x) = cos x", "start": [1265, 1], "end": [1266, 44], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_nat_mul_two_pi_add_pi", "code": "theorem cos_nat_mul_two_pi_add_pi (n : \u2115) : cos (n * (2 * \u03c0) + \u03c0) = -1", "start": [1269, 1], "end": [1270, 90], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_int_mul_two_pi_add_pi", "code": "theorem cos_int_mul_two_pi_add_pi (n : \u2124) : cos (n * (2 * \u03c0) + \u03c0) = -1", "start": [1273, 1], "end": [1274, 90], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_nat_mul_two_pi_sub_pi", "code": "theorem cos_nat_mul_two_pi_sub_pi (n : \u2115) : cos (n * (2 * \u03c0) - \u03c0) = -1", "start": [1277, 1], "end": [1278, 90], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_int_mul_two_pi_sub_pi", "code": "theorem cos_int_mul_two_pi_sub_pi (n : \u2124) : cos (n * (2 * \u03c0) - \u03c0) = -1", "start": [1281, 1], "end": [1282, 90], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_add_pi_div_two", "code": "theorem sin_add_pi_div_two (x : \u2102) : sin (x + \u03c0 / 2) = cos x", "start": [1285, 1], "end": [1285, 82], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_sub_pi_div_two", "code": "theorem sin_sub_pi_div_two (x : \u2102) : sin (x - \u03c0 / 2) = -cos x", "start": [1288, 1], "end": [1288, 99], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_pi_div_two_sub", "code": "theorem sin_pi_div_two_sub (x : \u2102) : sin (\u03c0 / 2 - x) = cos x", "start": [1291, 1], "end": [1291, 98], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_add_pi_div_two", "code": "theorem cos_add_pi_div_two (x : \u2102) : cos (x + \u03c0 / 2) = -sin x", "start": [1294, 1], "end": [1294, 83], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_sub_pi_div_two", "code": "theorem cos_sub_pi_div_two (x : \u2102) : cos (x - \u03c0 / 2) = sin x", "start": [1297, 1], "end": [1297, 98], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_pi_div_two_sub", "code": "theorem cos_pi_div_two_sub (x : \u2102) : cos (\u03c0 / 2 - x) = sin x", "start": [1300, 1], "end": [1301, 46], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_periodic", "code": "theorem tan_periodic : Function.Periodic tan \u03c0", "start": [1304, 1], "end": [1305, 78], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_add_pi", "code": "theorem tan_add_pi (x : \u2102) : tan (x + \u03c0) = tan x", "start": [1308, 1], "end": [1309, 17], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_sub_pi", "code": "theorem tan_sub_pi (x : \u2102) : tan (x - \u03c0) = tan x", "start": [1312, 1], "end": [1313, 24], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_pi_sub", "code": "theorem tan_pi_sub (x : \u2102) : tan (\u03c0 - x) = -tan x", "start": [1316, 1], "end": [1317, 35], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_pi_div_two_sub", "code": "theorem tan_pi_div_two_sub (x : \u2102) : tan (\u03c0 / 2 - x) = (tan x)\u207b\u00b9", "start": [1320, 1], "end": [1321, 95], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_nat_mul_pi", "code": "theorem tan_nat_mul_pi (n : \u2115) : tan (n * \u03c0) = 0", "start": [1324, 1], "end": [1325, 39], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_int_mul_pi", "code": "theorem tan_int_mul_pi (n : \u2124) : tan (n * \u03c0) = 0", "start": [1328, 1], "end": [1329, 39], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_add_nat_mul_pi", "code": "theorem tan_add_nat_mul_pi (x : \u2102) (n : \u2115) : tan (x + n * \u03c0) = tan x", "start": [1332, 1], "end": [1333, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_add_int_mul_pi", "code": "theorem tan_add_int_mul_pi (x : \u2102) (n : \u2124) : tan (x + n * \u03c0) = tan x", "start": [1336, 1], "end": [1337, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_sub_nat_mul_pi", "code": "theorem tan_sub_nat_mul_pi (x : \u2102) (n : \u2115) : tan (x - n * \u03c0) = tan x", "start": [1340, 1], "end": [1341, 32], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_sub_int_mul_pi", "code": "theorem tan_sub_int_mul_pi (x : \u2102) (n : \u2124) : tan (x - n * \u03c0) = tan x", "start": [1344, 1], "end": [1345, 32], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_nat_mul_pi_sub", "code": "theorem tan_nat_mul_pi_sub (x : \u2102) (n : \u2115) : tan (n * \u03c0 - x) = -tan x", "start": [1348, 1], "end": [1349, 44], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_int_mul_pi_sub", "code": "theorem tan_int_mul_pi_sub (x : \u2102) (n : \u2124) : tan (n * \u03c0 - x) = -tan x", "start": [1352, 1], "end": [1353, 44], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_antiperiodic", "code": "theorem exp_antiperiodic : Function.Antiperiodic exp (\u03c0 * I)", "start": [1356, 1], "end": [1356, 93], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_periodic", "code": "theorem exp_periodic : Function.Periodic exp (2 * \u03c0 * I)", "start": [1359, 1], "end": [1360, 59], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_mul_I_antiperiodic", "code": "theorem exp_mul_I_antiperiodic : Function.Antiperiodic (fun x => exp (x * I)) \u03c0", "start": [1363, 1], "end": [1364, 90], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_mul_I_periodic", "code": "theorem exp_mul_I_periodic : Function.Periodic (fun x => exp (x * I)) (2 * \u03c0)", "start": [1368, 1], "end": [1369, 34], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_pi_mul_I", "code": "@[simp]\ntheorem exp_pi_mul_I : exp (\u03c0 * I) = -1", "start": [1373, 1], "end": [1375, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_two_pi_mul_I", "code": "@[simp]\ntheorem exp_two_pi_mul_I : exp (2 * \u03c0 * I) = 1", "start": [1379, 1], "end": [1381, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_nat_mul_two_pi_mul_I", "code": "@[simp]\ntheorem exp_nat_mul_two_pi_mul_I (n : \u2115) : exp (n * (2 * \u03c0 * I)) = 1", "start": [1385, 1], "end": [1387, 45], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_int_mul_two_pi_mul_I", "code": "@[simp]\ntheorem exp_int_mul_two_pi_mul_I (n : \u2124) : exp (n * (2 * \u03c0 * I)) = 1", "start": [1391, 1], "end": [1393, 45], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_add_pi_mul_I", "code": "@[simp]\ntheorem exp_add_pi_mul_I (z : \u2102) : exp (z + \u03c0 * I) = -exp z", "start": [1397, 1], "end": [1399, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_sub_pi_mul_I", "code": "@[simp]\ntheorem exp_sub_pi_mul_I (z : \u2102) : exp (z - \u03c0 * I) = -exp z", "start": [1403, 1], "end": [1405, 28], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le", "code": "theorem abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le {a b : \u211d} (ha : a \u2264 0) {z : \u2102} (hz : |z.im| \u2264 b)\n    (hb : b \u2264 \u03c0 / 2) :\n    abs (exp (a * (exp z + exp (-z)))) \u2264 Real.exp (a * Real.cos b * Real.exp |z.re|)", "start": [1409, 1], "end": [1425, 90], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Instances/Sign.lean", "imports": ["Mathlib/Topology/Order/Basic.lean", "Mathlib/Data/Sign.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "continuousAt_sign_of_pos", "code": "theorem continuousAt_sign_of_pos {a : \u03b1} (h : 0 < a) : ContinuousAt SignType.sign a", "start": [32, 1], "end": [35, 73], "kind": "commanddeclaration"}, {"full_name": "continuousAt_sign_of_neg", "code": "theorem continuousAt_sign_of_neg {a : \u03b1} (h : a < 0) : ContinuousAt SignType.sign a", "start": [38, 1], "end": [41, 73], "kind": "commanddeclaration"}, {"full_name": "continuousAt_sign_of_ne_zero", "code": "theorem continuousAt_sign_of_ne_zero {a : \u03b1} (h : a \u2260 0) : ContinuousAt SignType.sign a", "start": [50, 1], "end": [53, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Group/AddCircle.lean", "imports": ["Mathlib/Analysis/Normed/Group/Quotient.lean", "Mathlib/Topology/Instances/AddCircle.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddCircle.norm_coe_mul", "code": "@[simp]\ntheorem norm_coe_mul (x : \u211d) (t : \u211d) :\n    \u2016(\u2191(t * x) : AddCircle (t * p))\u2016 = |t| * \u2016(x : AddCircle p)\u2016", "start": [43, 1], "end": [68, 17], "kind": "commanddeclaration"}, {"full_name": "AddCircle.norm_neg_period", "code": "theorem norm_neg_period (x : \u211d) : \u2016(x : AddCircle (-p))\u2016 = \u2016(x : AddCircle p)\u2016", "start": [71, 1], "end": [75, 54], "kind": "commanddeclaration"}, {"full_name": "AddCircle.norm_eq_of_zero", "code": "@[simp]\ntheorem norm_eq_of_zero {x : \u211d} : \u2016(x : AddCircle (0 : \u211d))\u2016 = |x|", "start": [78, 1], "end": [83, 74], "kind": "commanddeclaration"}, {"full_name": "AddCircle.norm_eq", "code": "theorem norm_eq {x : \u211d} : \u2016(x : AddCircle p)\u2016 = |x - round (p\u207b\u00b9 * x) * p|", "start": [86, 1], "end": [118, 9], "kind": "commanddeclaration"}, {"full_name": "AddCircle.norm_eq'", "code": "theorem norm_eq' (hp : 0 < p) {x : \u211d} : \u2016(x : AddCircle p)\u2016 = p * |p\u207b\u00b9 * x - round (p\u207b\u00b9 * x)|", "start": [121, 1], "end": [125, 80], "kind": "commanddeclaration"}, {"full_name": "AddCircle.norm_le_half_period", "code": "theorem norm_le_half_period {x : AddCircle p} (hp : p \u2260 0) : \u2016x\u2016 \u2264 |p| / 2", "start": [128, 1], "end": [133, 32], "kind": "commanddeclaration"}, {"full_name": "AddCircle.norm_half_period_eq", "code": "@[simp]\ntheorem norm_half_period_eq : \u2016(\u2191(p / 2) : AddCircle p)\u2016 = |p| / 2", "start": [136, 1], "end": [140, 78], "kind": "commanddeclaration"}, {"full_name": "AddCircle.norm_coe_eq_abs_iff", "code": "theorem norm_coe_eq_abs_iff {x : \u211d} (hp : p \u2260 0) : \u2016(x : AddCircle p)\u2016 = |x| \u2194 |x| \u2264 |p| / 2", "start": [143, 1], "end": [165, 15], "kind": "commanddeclaration"}, {"full_name": "AddCircle.closedBall_eq_univ_of_half_period_le", "code": "theorem closedBall_eq_univ_of_half_period_le (hp : p \u2260 0) (x : AddCircle p) {\u03b5 : \u211d}\n    (h\u03b5 : |p| / 2 \u2264 \u03b5) : closedBall x \u03b5 = univ", "start": [170, 1], "end": [173, 88], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_real_preimage_closedBall_period_zero", "code": "@[simp]\ntheorem coe_real_preimage_closedBall_period_zero (x \u03b5 : \u211d) :\n    (\u2191) \u207b\u00b9' closedBall (x : AddCircle (0 : \u211d)) \u03b5 = closedBall x \u03b5", "start": [176, 1], "end": [182, 72], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_real_preimage_closedBall_eq_iUnion", "code": "theorem coe_real_preimage_closedBall_eq_iUnion (x \u03b5 : \u211d) :\n    (\u2191) \u207b\u00b9' closedBall (x : AddCircle p) \u03b5 = \u22c3 z : \u2124, closedBall (x + z \u2022 p) \u03b5", "start": [185, 1], "end": [196, 46], "kind": "commanddeclaration"}, {"full_name": "AddCircle.coe_real_preimage_closedBall_inter_eq", "code": "theorem coe_real_preimage_closedBall_inter_eq {x \u03b5 : \u211d} (s : Set \u211d)\n    (hs : s \u2286 closedBall x (|p| / 2)) :\n    (\u2191) \u207b\u00b9' closedBall (x : AddCircle p) \u03b5 \u2229 s = if \u03b5 < |p| / 2 then closedBall x \u03b5 \u2229 s else s", "start": [199, 1], "end": [239, 45], "kind": "commanddeclaration"}, {"full_name": "AddCircle.norm_div_nat_cast", "code": "theorem norm_div_nat_cast {m n : \u2115} :\n    \u2016(\u2191(\u2191m / \u2191n * p) : AddCircle p)\u2016 = p * (\u2191(min (m % n) (n - m % n)) / n)", "start": [246, 1], "end": [249, 61], "kind": "commanddeclaration"}, {"full_name": "AddCircle.exists_norm_eq_of_isOfFinAddOrder", "code": "theorem exists_norm_eq_of_isOfFinAddOrder {u : AddCircle p} (hu : IsOfFinAddOrder u) :\n    \u2203 k : \u2115, \u2016u\u2016 = p * (k / addOrderOf u)", "start": [252, 1], "end": [258, 31], "kind": "commanddeclaration"}, {"full_name": "AddCircle.le_add_order_smul_norm_of_isOfFinAddOrder", "code": "theorem le_add_order_smul_norm_of_isOfFinAddOrder {u : AddCircle p} (hu : IsOfFinAddOrder u)\n    (hu' : u \u2260 0) : p \u2264 addOrderOf u \u2022 \u2016u\u2016", "start": [261, 1], "end": [271, 77], "kind": "commanddeclaration"}, {"full_name": "UnitAddCircle.norm_eq", "code": "theorem norm_eq {x : \u211d} : \u2016(x : UnitAddCircle)\u2016 = |x - round x|", "start": [280, 1], "end": [280, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/TensorProduct/Tower.lean", "imports": ["Mathlib/Algebra/Algebra/Tower.lean", "Mathlib/LinearAlgebra/TensorProduct.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TensorProduct.AlgebraTensorModule.smul_eq_lsmul_rTensor", "code": "theorem smul_eq_lsmul_rTensor (a : A) (x : M \u2297[R] N) : a \u2022 x = (lsmul R R M a).rTensor N x", "start": [80, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.curry", "code": "@[simps]\nnonrec def curry (f : M \u2297[R] N \u2192\u2097[A] P) : M \u2192\u2097[A] N \u2192\u2097[R] P :=\n  { curry (f.restrictScalars R) with\n    toFun := curry (f.restrictScalars R)\n    map_smul' := fun c x => LinearMap.ext fun y => f.map_smul c (x \u2297\u209c y) }", "start": [84, 1], "end": [92, 75], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.restrictScalars_curry", "code": "theorem restrictScalars_curry (f : M \u2297[R] N \u2192\u2097[A] P) :\n    restrictScalars R (curry f) = TensorProduct.curry (f.restrictScalars R)", "start": [96, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.curry_injective", "code": "@[ext high]\nnonrec theorem curry_injective : Function.Injective (curry : (M \u2297 N \u2192\u2097[A] P) \u2192 M \u2192\u2097[A] N \u2192\u2097[R] P)", "start": [101, 1], "end": [109, 71], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.ext", "code": "theorem ext {g h : M \u2297[R] N \u2192\u2097[A] P} (H : \u2200 x y, g (x \u2297\u209c y) = h (x \u2297\u209c y)) : g = h", "start": [112, 1], "end": [113, 38], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.lift", "code": "nonrec def lift (f : M \u2192\u2097[A] N \u2192\u2097[R] P) : M \u2297[R] N \u2192\u2097[A] P :=\n  { lift (f.restrictScalars R) with\n    map_smul' := fun c =>\n      show\n        \u2200 x : M \u2297[R] N,\n          (lift (f.restrictScalars R)).comp (lsmul R R _ c) x =\n            (lsmul R R _ c).comp (lift (f.restrictScalars R)) x\n        from\n        ext_iff.1 <|\n          TensorProduct.ext' fun x y => by\n            simp only [comp_apply, Algebra.lsmul_coe, smul_tmul', lift.tmul,\n              coe_restrictScalars, f.map_smul, smul_apply] }", "start": [116, 1], "end": [132, 61], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.lift_apply", "code": "@[simp]\ntheorem lift_apply (f : M \u2192\u2097[A] N \u2192\u2097[R] P) (a : M \u2297[R] N) :\n    AlgebraTensorModule.lift f a = TensorProduct.lift (LinearMap.restrictScalars R f) a", "start": [136, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.lift_tmul", "code": "@[simp]\ntheorem lift_tmul (f : M \u2192\u2097[A] N \u2192\u2097[R] P) (x : M) (y : N) : lift f (x \u2297\u209c y) = f x y", "start": [141, 1], "end": [143, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.uncurry", "code": "@[simps]\ndef uncurry : (M \u2192\u2097[A] N \u2192\u2097[R] P) \u2192\u2097[B] M \u2297[R] N \u2192\u2097[A] P where\n  toFun := lift\n  map_add' _ _ := ext fun x y => by simp only [lift_tmul, add_apply]\n  map_smul' _ _ := ext fun x y => by simp only [lift_tmul, smul_apply, RingHom.id_apply]", "start": [148, 1], "end": [157, 89], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.lcurry", "code": "@[simps]\ndef lcurry : (M \u2297[R] N \u2192\u2097[A] P) \u2192\u2097[B] M \u2192\u2097[A] N \u2192\u2097[R] P where\n  toFun := curry\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [161, 1], "end": [169, 23], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.lift.equiv", "code": "def lift.equiv : (M \u2192\u2097[A] N \u2192\u2097[R] P) \u2243\u2097[B] M \u2297[R] N \u2192\u2097[A] P :=\n  LinearEquiv.ofLinear (uncurry R A B M N P) (lcurry R A B M N P)\n    (LinearMap.ext fun _ => ext fun x y => lift_tmul _ x y)\n    (LinearMap.ext fun f => LinearMap.ext fun x => LinearMap.ext fun y => lift_tmul f x y)", "start": [173, 1], "end": [181, 91], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.mk", "code": "@[simps! apply]\nnonrec def mk : M \u2192\u2097[A] N \u2192\u2097[R] M \u2297[R] N :=\n  { mk R M N with map_smul' := fun _ _ => rfl }", "start": [185, 1], "end": [190, 48], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.map", "code": "def map (f : M \u2192\u2097[A] P) (g : N \u2192\u2097[R] Q) : M \u2297[R] N \u2192\u2097[A] P \u2297[R] Q :=\n  lift <|\n    { toFun := fun h => h \u2218\u2097 g,\n      map_add' := fun h\u2081 h\u2082 => LinearMap.add_comp g h\u2082 h\u2081,\n      map_smul' := fun c h => LinearMap.smul_comp c h g } \u2218\u2097 mk R A P Q \u2218\u2097 f", "start": [196, 1], "end": [201, 77], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.map_tmul", "code": "@[simp] theorem map_tmul (f : M \u2192\u2097[A] P) (g : N \u2192\u2097[R] Q) (m : M) (n : N) :\n    map f g (m \u2297\u209c n) = f m \u2297\u209c g n", "start": [203, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.map_id", "code": "@[simp]\ntheorem map_id : map (id : M \u2192\u2097[A] M) (id : N \u2192\u2097[R] N) = .id", "start": [207, 1], "end": [209, 21], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.map_comp", "code": "theorem map_comp (f\u2082 : P \u2192\u2097[A] P') (f\u2081 : M \u2192\u2097[A] P) (g\u2082 : Q \u2192\u2097[R] Q') (g\u2081 : N \u2192\u2097[R] Q) :\n    map (f\u2082.comp f\u2081) (g\u2082.comp g\u2081) = (map f\u2082 g\u2082).comp (map f\u2081 g\u2081)", "start": [211, 1], "end": [213, 21], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.map_one", "code": "@[simp]\nprotected theorem map_one : map (1 : M \u2192\u2097[A] M) (1 : N \u2192\u2097[R] N) = 1", "start": [215, 1], "end": [216, 78], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.map_mul", "code": "protected theorem map_mul (f\u2081 f\u2082 : M \u2192\u2097[A] M) (g\u2081 g\u2082 : N \u2192\u2097[R] N) :\n    map (f\u2081 * f\u2082) (g\u2081 * g\u2082) = map f\u2081 g\u2081 * map f\u2082 g\u2082", "start": [218, 1], "end": [219, 72], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.map_add_left", "code": "theorem map_add_left (f\u2081 f\u2082 : M \u2192\u2097[A] P) (g : N \u2192\u2097[R] Q) :\n    map (f\u2081 + f\u2082) g = map f\u2081 g + map f\u2082 g", "start": [221, 1], "end": [225, 25], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.map_add_right", "code": "theorem map_add_right (f : M \u2192\u2097[A] P) (g\u2081 g\u2082 : N \u2192\u2097[R] Q) :\n    map f (g\u2081 + g\u2082) = map f g\u2081 + map f g\u2082", "start": [227, 1], "end": [231, 25], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.map_smul_right", "code": "theorem map_smul_right (r : R) (f : M \u2192\u2097[A] P) (g : N \u2192\u2097[R] Q) : map f (r \u2022 g) = r \u2022 map f g", "start": [233, 1], "end": [236, 27], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.map_smul_left", "code": "theorem map_smul_left (b : B) (f : M \u2192\u2097[A] P) (g : N \u2192\u2097[R] Q) : map (b \u2022 f) g = b \u2022 map f g", "start": [238, 1], "end": [241, 28], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.mapBilinear", "code": "def mapBilinear : (M \u2192\u2097[A] P) \u2192\u2097[B] (N \u2192\u2097[R] Q) \u2192\u2097[R] (M \u2297[R] N \u2192\u2097[A] P \u2297[R] Q) :=\n  LinearMap.mk\u2082' _ _ map map_add_left map_smul_left map_add_right map_smul_right", "start": [245, 1], "end": [247, 81], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.mapBilinear_apply", "code": "@[simp]\ntheorem mapBilinear_apply (f : M \u2192\u2097[A] P) (g : N \u2192\u2097[R] Q) :\n    mapBilinear R A B M N P Q f g = map f g", "start": [251, 1], "end": [254, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.homTensorHomMap", "code": "def homTensorHomMap : ((M \u2192\u2097[A] P) \u2297[R] (N \u2192\u2097[R] Q)) \u2192\u2097[B] (M \u2297[R] N \u2192\u2097[A] P \u2297[R] Q) :=\n  lift <| mapBilinear R A B M N P Q", "start": [258, 1], "end": [260, 36], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.homTensorHomMap_apply", "code": "@[simp] theorem homTensorHomMap_apply (f : M \u2192\u2097[A] P) (g : N \u2192\u2097[R] Q) :\n    homTensorHomMap R A B M N P Q (f \u2297\u209c g) = map f g", "start": [264, 1], "end": [266, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.congr", "code": "def congr (f : M \u2243\u2097[A] P) (g : N \u2243\u2097[R] Q) : (M \u2297[R] N) \u2243\u2097[A] (P \u2297[R] Q) :=\n  LinearEquiv.ofLinear (map f g) (map f.symm g.symm)\n    (ext fun _m _n => congr_arg\u2082 (\u00b7 \u2297\u209c \u00b7) (f.apply_symm_apply _) (g.apply_symm_apply _))\n    (ext fun _m _n => congr_arg\u2082 (\u00b7 \u2297\u209c \u00b7) (f.symm_apply_apply _) (g.symm_apply_apply _))", "start": [268, 1], "end": [272, 89], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.congr_refl", "code": "@[simp]\ntheorem congr_refl : congr (.refl A M) (.refl R N) = .refl A _", "start": [274, 1], "end": [276, 46], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.congr_trans", "code": "theorem congr_trans (f\u2081 : M \u2243\u2097[A] P) (f\u2082 : P \u2243\u2097[A] P') (g\u2081 : N \u2243\u2097[R] Q) (g\u2082 : Q \u2243\u2097[R] Q') :\n    congr (f\u2081.trans f\u2082) (g\u2081.trans g\u2082) = (congr f\u2081 g\u2081).trans (congr f\u2082 g\u2082)", "start": [278, 1], "end": [280, 56], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.congr_symm", "code": "theorem congr_symm (f : M \u2243\u2097[A] P) (g : N \u2243\u2097[R] Q) : congr f.symm g.symm = (congr f g).symm", "start": [282, 1], "end": [282, 99], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.congr_one", "code": "@[simp]\ntheorem congr_one : congr (1 : M \u2243\u2097[A] M) (1 : N \u2243\u2097[R] N) = 1", "start": [284, 1], "end": [285, 76], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.congr_mul", "code": "theorem congr_mul (f\u2081 f\u2082 : M \u2243\u2097[A] M) (g\u2081 g\u2082 : N \u2243\u2097[R] N) :\n    congr (f\u2081 * f\u2082) (g\u2081 * g\u2082) = congr f\u2081 g\u2081 * congr f\u2082 g\u2082", "start": [287, 1], "end": [288, 81], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.congr_tmul", "code": "@[simp] theorem congr_tmul (f : M \u2243\u2097[A] P) (g : N \u2243\u2097[R] Q) (m : M) (n : N) :\n    congr f g (m \u2297\u209c n) = f m \u2297\u209c g n", "start": [290, 1], "end": [292, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.congr_symm_tmul", "code": "@[simp] theorem congr_symm_tmul (f : M \u2243\u2097[A] P) (g : N \u2243\u2097[R] Q) (p : P) (q : Q) :\n    (congr f g).symm (p \u2297\u209c q) = f.symm p \u2297\u209c g.symm q", "start": [294, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.rid", "code": "protected def rid : M \u2297[R] R \u2243\u2097[A] M :=\n  LinearEquiv.ofLinear\n    (lift <| Algebra.lsmul _ _ _ |>.toLinearMap |>.flip)\n    (mk R A M R |>.flip 1)\n    (LinearMap.ext <| one_smul _)\n    (ext <| fun _ _ => smul_tmul _ _ _ |>.trans <| congr_arg _ <| mul_one _)", "start": [300, 1], "end": [306, 77], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.rid_eq_rid", "code": "theorem rid_eq_rid : AlgebraTensorModule.rid R R M = TensorProduct.rid R M", "start": [308, 1], "end": [309, 73], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.rid_tmul", "code": "@[simp]\ntheorem rid_tmul (r : R) (m : M) : AlgebraTensorModule.rid R A M (m \u2297\u209c r) = r \u2022 m", "start": [313, 1], "end": [314, 89], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.assoc", "code": "def assoc : (M \u2297[A] P) \u2297[R] Q \u2243\u2097[B] M \u2297[A] (P \u2297[R] Q) :=\n  LinearEquiv.ofLinear\n    (lift <| lift <| lcurry R A B P Q _ \u2218\u2097 mk A B M (P \u2297[R] Q))\n    (lift <| uncurry R A B P Q _ \u2218\u2097 curry (mk R B _ Q))\n    (by ext; rfl)\n    (by ext; rfl)", "start": [339, 1], "end": [350, 18], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.assoc_tmul", "code": "@[simp]\ntheorem assoc_tmul (m : M) (p : P) (q : Q) :\n    assoc R A B M P Q ((m \u2297\u209c p) \u2297\u209c q) = m \u2297\u209c (p \u2297\u209c q)", "start": [356, 1], "end": [359, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.assoc_symm_tmul", "code": "@[simp]\ntheorem assoc_symm_tmul (m : M) (p : P) (q : Q) :\n    (assoc R A B M P Q).symm (m \u2297\u209c (p \u2297\u209c q)) = (m \u2297\u209c p) \u2297\u209c q", "start": [361, 1], "end": [364, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.leftComm", "code": "def leftComm : M \u2297[A] (P \u2297[R] Q) \u2243\u2097[A] P \u2297[A] (M \u2297[R] Q) :=\n  let e\u2081 := (assoc R A A M P Q).symm\n  let e\u2082 := congr (TensorProduct.comm A M P) (1 : Q \u2243\u2097[R] Q)\n  let e\u2083 := assoc R A A P M Q\n  e\u2081 \u226a\u226b\u2097 e\u2082 \u226a\u226b\u2097 e\u2083", "start": [370, 1], "end": [375, 19], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.leftComm_tmul", "code": "@[simp]\ntheorem leftComm_tmul (m : M) (p : P) (q : Q) :\n    leftComm R A M P Q (m \u2297\u209c (p \u2297\u209c q)) = p \u2297\u209c (m \u2297\u209c q)", "start": [379, 1], "end": [382, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.leftComm_symm_tmul", "code": "@[simp]\ntheorem leftComm_symm_tmul (m : M) (p : P) (q : Q):\n    (leftComm R A M P Q).symm (p \u2297\u209c (m \u2297\u209c q)) = m \u2297\u209c (p \u2297\u209c q)", "start": [384, 1], "end": [387, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.rightComm", "code": "def rightComm : (M \u2297[A] P) \u2297[R] Q \u2243\u2097[A] (M \u2297[R] Q) \u2297[A] P :=\n  LinearEquiv.ofLinear\n    (lift <| TensorProduct.lift <| LinearMap.flip <|\n      lcurry R A A M Q ((M \u2297[R] Q) \u2297[A] P) \u2218\u2097 (mk A A (M \u2297[R] Q) P).flip)\n    (TensorProduct.lift <| lift <| LinearMap.flip <|\n      (TensorProduct.lcurry A M P ((M \u2297[A] P) \u2297[R] Q)).restrictScalars R\n        \u2218\u2097 (mk R A (M \u2297[A] P) Q).flip)\n    (TensorProduct.ext <| ext <| fun m q => LinearMap.ext <| fun p => Eq.refl <|\n      (m \u2297\u209c[R] q) \u2297\u209c[A] p)\n    (curry_injective <| TensorProduct.ext' <| fun m p => LinearMap.ext <| fun q => Eq.refl <|\n      (m \u2297\u209c[A] p) \u2297\u209c[R] q)", "start": [393, 1], "end": [406, 27], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.rightComm_tmul", "code": "@[simp]\ntheorem rightComm_tmul (m : M) (p : P) (q : Q) :\n    rightComm R A M P Q ((m \u2297\u209c p) \u2297\u209c q) = (m \u2297\u209c q) \u2297\u209c p", "start": [410, 1], "end": [413, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.rightComm_symm_tmul", "code": "@[simp]\ntheorem rightComm_symm_tmul (m : M) (p : P) (q : Q):\n    (rightComm R A M P Q).symm ((m \u2297\u209c q) \u2297\u209c p) = (m \u2297\u209c p) \u2297\u209c q", "start": [415, 1], "end": [418, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.tensorTensorTensorComm", "code": "def tensorTensorTensorComm :\n    (M \u2297[R] N) \u2297[A] (P \u2297[R] Q) \u2243\u2097[A] (M \u2297[A] P) \u2297[R] (N \u2297[R] Q) :=\n(assoc R A A (M \u2297[R] N) P Q).symm\n  \u226a\u226b\u2097 congr (rightComm R A M P N).symm (1 : Q \u2243\u2097[R] Q)\n  \u226a\u226b\u2097 assoc R _ _ (M \u2297[A] P) N Q", "start": [424, 1], "end": [429, 33], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.tensorTensorTensorComm_tmul", "code": "@[simp]\ntheorem tensorTensorTensorComm_tmul (m : M) (n : N) (p : P) (q : Q) :\n    tensorTensorTensorComm R A M N P Q ((m \u2297\u209c n) \u2297\u209c (p \u2297\u209c q)) = (m \u2297\u209c p) \u2297\u209c (n \u2297\u209c q)", "start": [433, 1], "end": [436, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.AlgebraTensorModule.tensorTensorTensorComm_symm_tmul", "code": "@[simp]\ntheorem tensorTensorTensorComm_symm_tmul (m : M) (n : N) (p : P) (q : Q) :\n    (tensorTensorTensorComm R A M N P Q).symm ((m \u2297\u209c p) \u2297\u209c (n \u2297\u209c q)) = (m \u2297\u209c n) \u2297\u209c (p \u2297\u209c q)", "start": [438, 1], "end": [441, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "imports": ["Mathlib/CategoryTheory/EpiMono.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/HasLimits.lean", "Mathlib/CategoryTheory/Category/Preorder.lean", "Mathlib/CategoryTheory/PEmpty.lean"], "premises": [{"full_name": "CategoryTheory.Limits.asEmptyCone", "code": "@[simps]\ndef asEmptyCone (X : C) : Cone (Functor.empty.{0} C) :=\n  { pt := X\n    \u03c0 :=\n    { app := by aesop_cat } }", "start": [31, 1], "end": [36, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.asEmptyCocone", "code": "@[simps]\ndef asEmptyCocone (X : C) : Cocone (Functor.empty.{0} C) :=\n  { pt := X\n    \u03b9 :=\n    { app := by aesop_cat } }", "start": [39, 1], "end": [44, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal", "code": "abbrev IsTerminal (X : C) :=\n  IsLimit (asEmptyCone X)", "start": [47, 1], "end": [49, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial", "code": "abbrev IsInitial (X : C) :=\n  IsColimit (asEmptyCocone X)", "start": [52, 1], "end": [54, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isTerminalEquivUnique", "code": "def isTerminalEquivUnique (F : Discrete.{0} PEmpty.{1} \u2964 C) (Y : C) :\n    IsLimit (\u27e8Y, by aesop_cat, by aesop_cat\u27e9 : Cone F) \u2243 \u2200 X : C, Unique (X \u27f6 Y) where\n  toFun t X :=\n    { default := t.lift \u27e8X, \u27e8by aesop_cat, by aesop_cat\u27e9\u27e9\n      uniq := fun f =>\n        t.uniq \u27e8X, \u27e8by aesop_cat, by aesop_cat\u27e9\u27e9 f (by aesop_cat) }\n  invFun u :=\n    { lift := fun s => (u s.pt).default\n      uniq := fun s _ _ => (u s.pt).2 _ }\n  left_inv := by dsimp [Function.LeftInverse]; intro x; simp only [eq_iff_true_of_subsingleton]\n  right_inv := by\n    dsimp [Function.RightInverse,Function.LeftInverse]\n    intro u; funext X; simp only", "start": [57, 1], "end": [70, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal.ofUnique", "code": "def IsTerminal.ofUnique (Y : C) [h : \u2200 X : C, Unique (X \u27f6 Y)] : IsTerminal Y where\n  lift s := (h s.pt).default\n  fac := fun _ \u27e8j\u27e9 => j.elim", "start": [73, 1], "end": [77, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal.ofUniqueHom", "code": "def IsTerminal.ofUniqueHom {Y : C} (h : \u2200 X : C, X \u27f6 Y) (uniq : \u2200 (X : C) (m : X \u27f6 Y), m = h X) :\n    IsTerminal Y :=\n  have : \u2200 X : C, Unique (X \u27f6 Y) := fun X \u21a6 \u27e8\u27e8h X\u27e9, uniq X\u27e9\n  IsTerminal.ofUnique Y", "start": [80, 1], "end": [85, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isTerminalTop", "code": "def isTerminalTop {\u03b1 : Type*} [Preorder \u03b1] [OrderTop \u03b1] : IsTerminal (\u22a4 : \u03b1) :=\n  IsTerminal.ofUnique _", "start": [87, 1], "end": [89, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal.ofIso", "code": "def IsTerminal.ofIso {Y Z : C} (hY : IsTerminal Y) (i : Y \u2245 Z) : IsTerminal Z :=\n  IsLimit.ofIsoLimit hY\n    { hom := { hom := i.hom }\n      inv := { hom := i.inv } }", "start": [92, 1], "end": [96, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isInitialEquivUnique", "code": "def isInitialEquivUnique (F : Discrete.{0} PEmpty.{1} \u2964 C) (X : C) :\n    IsColimit (\u27e8X, \u27e8by aesop_cat, by aesop_cat\u27e9\u27e9 : Cocone F) \u2243 \u2200 Y : C, Unique (X \u27f6 Y) where\n  toFun t X :=\n    { default := t.desc \u27e8X, \u27e8by aesop_cat, by aesop_cat\u27e9\u27e9\n      uniq := fun f => t.uniq \u27e8X, \u27e8by aesop_cat, by aesop_cat\u27e9\u27e9 f (by aesop_cat) }\n  invFun u :=\n    { desc := fun s => (u s.pt).default\n      uniq := fun s _ _ => (u s.pt).2 _ }\n  left_inv := by dsimp [Function.LeftInverse]; intro; simp only [eq_iff_true_of_subsingleton]\n  right_inv := by\n    dsimp [Function.RightInverse,Function.LeftInverse]\n    intro; funext; simp only", "start": [99, 1], "end": [111, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.ofUnique", "code": "def IsInitial.ofUnique (X : C) [h : \u2200 Y : C, Unique (X \u27f6 Y)] : IsInitial X where\n  desc s := (h s.pt).default\n  fac := fun _ \u27e8j\u27e9 => j.elim", "start": [114, 1], "end": [118, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.ofUniqueHom", "code": "def IsInitial.ofUniqueHom {X : C} (h : \u2200 Y : C, X \u27f6 Y) (uniq : \u2200 (Y : C) (m : X \u27f6 Y), m = h Y) :\n    IsInitial X :=\n  have : \u2200 Y : C, Unique (X \u27f6 Y) := fun Y \u21a6 \u27e8\u27e8h Y\u27e9, uniq Y\u27e9\n  IsInitial.ofUnique X", "start": [121, 1], "end": [126, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isInitialBot", "code": "def isInitialBot {\u03b1 : Type*} [Preorder \u03b1] [OrderBot \u03b1] : IsInitial (\u22a5 : \u03b1) :=\n  IsInitial.ofUnique _", "start": [128, 1], "end": [130, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.ofIso", "code": "def IsInitial.ofIso {X Y : C} (hX : IsInitial X) (i : X \u2245 Y) : IsInitial Y :=\n  IsColimit.ofIsoColimit hX\n    { hom := { hom := i.hom }\n      inv := { hom := i.inv } }", "start": [133, 1], "end": [137, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal.from", "code": "def IsTerminal.from {X : C} (t : IsTerminal X) (Y : C) : Y \u27f6 X :=\n  t.lift (asEmptyCone Y)", "start": [140, 1], "end": [142, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal.hom_ext", "code": "theorem IsTerminal.hom_ext {X Y : C} (t : IsTerminal X) (f g : Y \u27f6 X) : f = g", "start": [145, 1], "end": [147, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal.comp_from", "code": "@[simp]\ntheorem IsTerminal.comp_from {Z : C} (t : IsTerminal Z) {X Y : C} (f : X \u27f6 Y) :\n    f \u226b t.from Y = t.from X", "start": [150, 1], "end": [153, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal.from_self", "code": "@[simp]\ntheorem IsTerminal.from_self {X : C} (t : IsTerminal X) : t.from X = \ud835\udfd9 X", "start": [156, 1], "end": [158, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.to", "code": "def IsInitial.to {X : C} (t : IsInitial X) (Y : C) : X \u27f6 Y :=\n  t.desc (asEmptyCocone Y)", "start": [161, 1], "end": [163, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.hom_ext", "code": "theorem IsInitial.hom_ext {X Y : C} (t : IsInitial X) (f g : X \u27f6 Y) : f = g", "start": [166, 1], "end": [168, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.to_comp", "code": "@[simp]\ntheorem IsInitial.to_comp {X : C} (t : IsInitial X) {Y Z : C} (f : Y \u27f6 Z) : t.to Y \u226b f = t.to Z", "start": [171, 1], "end": [173, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.to_self", "code": "@[simp]\ntheorem IsInitial.to_self {X : C} (t : IsInitial X) : t.to X = \ud835\udfd9 X", "start": [176, 1], "end": [178, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal.isSplitMono_from", "code": "theorem IsTerminal.isSplitMono_from {X Y : C} (t : IsTerminal X) (f : X \u27f6 Y) : IsSplitMono f", "start": [181, 1], "end": [183, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.isSplitEpi_to", "code": "theorem IsInitial.isSplitEpi_to {X Y : C} (t : IsInitial X) (f : Y \u27f6 X) : IsSplitEpi f", "start": [186, 1], "end": [188, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal.mono_from", "code": "theorem IsTerminal.mono_from {X Y : C} (t : IsTerminal X) (f : X \u27f6 Y) : Mono f", "start": [191, 1], "end": [193, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.epi_to", "code": "theorem IsInitial.epi_to {X Y : C} (t : IsInitial X) (f : Y \u27f6 X) : Epi f", "start": [196, 1], "end": [198, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal.uniqueUpToIso", "code": "@[simps]\ndef IsTerminal.uniqueUpToIso {T T' : C} (hT : IsTerminal T) (hT' : IsTerminal T') : T \u2245 T' where\n  hom := hT'.from _\n  inv := hT.from _", "start": [201, 1], "end": [205, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.uniqueUpToIso", "code": "@[simps]\ndef IsInitial.uniqueUpToIso {I I' : C} (hI : IsInitial I) (hI' : IsInitial I') : I \u2245 I' where\n  hom := hI.to _\n  inv := hI'.to _", "start": [208, 1], "end": [212, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasTerminal", "code": "abbrev HasTerminal :=\n  HasLimitsOfShape (Discrete.{0} PEmpty) C", "start": [217, 1], "end": [221, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasInitial", "code": "abbrev HasInitial :=\n  HasColimitsOfShape (Discrete.{0} PEmpty) C", "start": [224, 1], "end": [228, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitChangeEmptyCone", "code": "def isLimitChangeEmptyCone {c\u2081 : Cone F\u2081} (hl : IsLimit c\u2081) (c\u2082 : Cone F\u2082) (hi : c\u2081.pt \u2245 c\u2082.pt) :\n    IsLimit c\u2082 where\n  lift c := hl.lift \u27e8c.pt, by aesop_cat, by aesop_cat\u27e9 \u226b hi.hom\n  uniq c f _ := by\n    dsimp\n    rw [\u2190 hl.uniq _ (f \u226b hi.inv) _]\n    \u00b7 simp only [Category.assoc, Iso.inv_hom_id, Category.comp_id]\n    \u00b7 aesop_cat", "start": [235, 1], "end": [244, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitEmptyConeEquiv", "code": "def isLimitEmptyConeEquiv (c\u2081 : Cone F\u2081) (c\u2082 : Cone F\u2082) (h : c\u2081.pt \u2245 c\u2082.pt) :\n    IsLimit c\u2081 \u2243 IsLimit c\u2082 where\n  toFun hl := isLimitChangeEmptyCone C hl c\u2082 h\n  invFun hl := isLimitChangeEmptyCone C hl c\u2081 h.symm\n  left_inv := by dsimp [Function.LeftInverse]; intro; simp only [eq_iff_true_of_subsingleton]\n  right_inv := by\n    dsimp [Function.LeftInverse,Function.RightInverse]; intro; funext\n    simp only [eq_iff_true_of_subsingleton]", "start": [247, 1], "end": [256, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasTerminalChangeDiagram", "code": "theorem hasTerminalChangeDiagram (h : HasLimit F\u2081) : HasLimit F\u2082", "start": [259, 1], "end": [261, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasTerminalChangeUniverse", "code": "theorem hasTerminalChangeUniverse [h : HasLimitsOfShape (Discrete.{w} PEmpty) C] :\n    HasLimitsOfShape (Discrete.{w'} PEmpty) C where", "start": [264, 1], "end": [266, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitChangeEmptyCocone", "code": "def isColimitChangeEmptyCocone {c\u2081 : Cocone F\u2081} (hl : IsColimit c\u2081) (c\u2082 : Cocone F\u2082)\n    (hi : c\u2081.pt \u2245 c\u2082.pt) : IsColimit c\u2082 where\n  desc c := hi.inv \u226b hl.desc \u27e8c.pt, by aesop_cat, by aesop_cat\u27e9\n  uniq c f _ := by\n    dsimp\n    rw [\u2190 hl.uniq _ (hi.hom \u226b f) _]\n    \u00b7 simp only [Iso.inv_hom_id_assoc]\n    \u00b7 aesop_cat", "start": [269, 1], "end": [278, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitEmptyCoconeEquiv", "code": "def isColimitEmptyCoconeEquiv (c\u2081 : Cocone F\u2081) (c\u2082 : Cocone F\u2082) (h : c\u2081.pt \u2245 c\u2082.pt) :\n    IsColimit c\u2081 \u2243 IsColimit c\u2082 where\n  toFun hl := isColimitChangeEmptyCocone C hl c\u2082 h\n  invFun hl := isColimitChangeEmptyCocone C hl c\u2081 h.symm\n  left_inv := by dsimp [Function.LeftInverse]; intro; simp only [eq_iff_true_of_subsingleton]\n  right_inv := by\n    dsimp [Function.LeftInverse,Function.RightInverse]; intro; funext\n    simp only [eq_iff_true_of_subsingleton]", "start": [281, 1], "end": [290, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasInitialChangeDiagram", "code": "theorem hasInitialChangeDiagram (h : HasColimit F\u2081) : HasColimit F\u2082", "start": [293, 1], "end": [295, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasInitialChangeUniverse", "code": "theorem hasInitialChangeUniverse [h : HasColimitsOfShape (Discrete.{w} PEmpty) C] :\n    HasColimitsOfShape (Discrete.{w'} PEmpty) C where", "start": [298, 1], "end": [300, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.terminal", "code": "abbrev terminal [HasTerminal C] : C :=\n  limit (Functor.empty.{0} C)", "start": [305, 1], "end": [310, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.initial", "code": "abbrev initial [HasInitial C] : C :=\n  colimit (Functor.empty.{0} C)", "start": [313, 1], "end": [318, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasTerminal_of_unique", "code": "theorem hasTerminal_of_unique (X : C) [h : \u2200 Y : C, Unique (Y \u27f6 X)] : HasTerminal C", "start": [331, 1], "end": [334, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal.hasTerminal", "code": "theorem IsTerminal.hasTerminal {X : C} (h : IsTerminal X) : HasTerminal C", "start": [337, 1], "end": [339, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasInitial_of_unique", "code": "theorem hasInitial_of_unique (X : C) [h : \u2200 Y : C, Unique (X \u27f6 Y)] : HasInitial C", "start": [342, 1], "end": [345, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.hasInitial", "code": "theorem IsInitial.hasInitial {X : C} (h : IsInitial X) : HasInitial C where", "start": [348, 1], "end": [350, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.terminal.from", "code": "abbrev terminal.from [HasTerminal C] (P : C) : P \u27f6 \u22a4_ C :=\n  limit.lift (Functor.empty C) (asEmptyCone P)", "start": [353, 1], "end": [355, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.initial.to", "code": "abbrev initial.to [HasInitial C] (P : C) : \u22a5_ C \u27f6 P :=\n  colimit.desc (Functor.empty C) (asEmptyCocone P)", "start": [358, 1], "end": [360, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.terminalIsTerminal", "code": "def terminalIsTerminal [HasTerminal C] : IsTerminal (\u22a4_ C) where\n  lift s := terminal.from _", "start": [363, 1], "end": [365, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.initialIsInitial", "code": "def initialIsInitial [HasInitial C] : IsInitial (\u22a5_ C) where\n  desc s := initial.to _", "start": [368, 1], "end": [370, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.uniqueToTerminal", "code": "instance uniqueToTerminal [HasTerminal C] (P : C) : Unique (P \u27f6 \u22a4_ C) :=\n  isTerminalEquivUnique _ (\u22a4_ C) terminalIsTerminal P", "start": [373, 1], "end": [374, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.uniqueFromInitial", "code": "instance uniqueFromInitial [HasInitial C] (P : C) : Unique (\u22a5_ C \u27f6 P) :=\n  isInitialEquivUnique _ (\u22a5_ C) initialIsInitial P", "start": [377, 1], "end": [378, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.terminal.comp_from", "code": "@[simp]\ntheorem terminal.comp_from [HasTerminal C] {P Q : C} (f : P \u27f6 Q) :\n    f \u226b terminal.from Q = terminal.from P", "start": [381, 1], "end": [383, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.initial.to_comp", "code": "@[simp]\ntheorem initial.to_comp [HasInitial C] {P Q : C} (f : P \u27f6 Q) : initial.to P \u226b f = initial.to Q", "start": [386, 1], "end": [388, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.initialIsoIsInitial", "code": "@[simp]\ndef initialIsoIsInitial [HasInitial C] {P : C} (t : IsInitial P) : \u22a5_ C \u2245 P :=\n  initialIsInitial.uniqueUpToIso t", "start": [391, 1], "end": [394, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.terminalIsoIsTerminal", "code": "@[simp]\ndef terminalIsoIsTerminal [HasTerminal C] {P : C} (t : IsTerminal P) : \u22a4_ C \u2245 P :=\n  terminalIsTerminal.uniqueUpToIso t", "start": [397, 1], "end": [400, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.terminal.isSplitMono_from", "code": "instance terminal.isSplitMono_from {Y : C} [HasTerminal C] (f : \u22a4_ C \u27f6 Y) : IsSplitMono f :=\n  IsTerminal.isSplitMono_from terminalIsTerminal _", "start": [403, 1], "end": [405, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.initial.isSplitEpi_to", "code": "instance initial.isSplitEpi_to {Y : C} [HasInitial C] (f : Y \u27f6 \u22a5_ C) : IsSplitEpi f :=\n  IsInitial.isSplitEpi_to initialIsInitial _", "start": [408, 1], "end": [410, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.terminalOpOfInitial", "code": "def terminalOpOfInitial {X : C} (t : IsInitial X) : IsTerminal (Opposite.op X) where\n  lift s := (t.to s.pt.unop).op\n  uniq s m _ := Quiver.Hom.unop_inj (t.hom_ext _ _)", "start": [413, 1], "end": [416, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.terminalUnopOfInitial", "code": "def terminalUnopOfInitial {X : C\u1d52\u1d56} (t : IsInitial X) : IsTerminal X.unop where\n  lift s := (t.to (Opposite.op s.pt)).unop\n  uniq s m _ := Quiver.Hom.op_inj (t.hom_ext _ _)", "start": [419, 1], "end": [422, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.initialOpOfTerminal", "code": "def initialOpOfTerminal {X : C} (t : IsTerminal X) : IsInitial (Opposite.op X) where\n  desc s := (t.from s.pt.unop).op\n  uniq s m _ := Quiver.Hom.unop_inj (t.hom_ext _ _)", "start": [425, 1], "end": [428, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.initialUnopOfTerminal", "code": "def initialUnopOfTerminal {X : C\u1d52\u1d56} (t : IsTerminal X) : IsInitial X.unop where\n  desc s := (t.from (Opposite.op s.pt)).unop\n  uniq s m _ := Quiver.Hom.op_inj (t.hom_ext _ _)", "start": [431, 1], "end": [434, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasInitial_op_of_hasTerminal", "code": "instance hasInitial_op_of_hasTerminal [HasTerminal C] : HasInitial C\u1d52\u1d56 :=\n  (initialOpOfTerminal terminalIsTerminal).hasInitial", "start": [437, 1], "end": [438, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasTerminal_op_of_hasInitial", "code": "instance hasTerminal_op_of_hasInitial [HasInitial C] : HasTerminal C\u1d52\u1d56 :=\n  (terminalOpOfInitial initialIsInitial).hasTerminal", "start": [441, 1], "end": [442, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasTerminal_of_hasInitial_op", "code": "theorem hasTerminal_of_hasInitial_op [HasInitial C\u1d52\u1d56] : HasTerminal C", "start": [445, 1], "end": [446, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasInitial_of_hasTerminal_op", "code": "theorem hasInitial_of_hasTerminal_op [HasTerminal C\u1d52\u1d56] : HasInitial C", "start": [449, 1], "end": [450, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitConstTerminal", "code": "@[simps hom]\ndef limitConstTerminal {J : Type*} [Category J] {C : Type*} [Category C] [HasTerminal C] :\n    limit ((CategoryTheory.Functor.const J).obj (\u22a4_ C)) \u2245 \u22a4_ C where\n  hom := terminal.from _\n  inv :=\n    limit.lift ((CategoryTheory.Functor.const J).obj (\u22a4_ C))\n      { pt := \u22a4_ C\n        \u03c0 := { app := fun j => terminal.from _ } }", "start": [461, 1], "end": [469, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitConstTerminal_inv_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem limitConstTerminal_inv_\u03c0 {J : Type*} [Category J] {C : Type*} [Category C] [HasTerminal C]\n    {j : J} :\n    limitConstTerminal.inv \u226b limit.\u03c0 ((CategoryTheory.Functor.const J).obj (\u22a4_ C)) j =\n      terminal.from _", "start": [472, 1], "end": [476, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimitConstInitial", "code": "@[simps inv]\ndef colimitConstInitial {J : Type*} [Category J] {C : Type*} [Category C] [HasInitial C] :\n    colimit ((CategoryTheory.Functor.const J).obj (\u22a5_ C)) \u2245 \u22a5_ C where\n  hom :=\n    colimit.desc ((CategoryTheory.Functor.const J).obj (\u22a5_ C))\n      { pt := \u22a5_ C\n        \u03b9 := { app := fun j => initial.to _ } }\n  inv := initial.to _", "start": [487, 1], "end": [495, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.\u03b9_colimitConstInitial_hom", "code": "@[reassoc (attr := simp)]\ntheorem \u03b9_colimitConstInitial_hom {J : Type*} [Category J] {C : Type*} [Category C] [HasInitial C]\n    {j : J} :\n    colimit.\u03b9 ((CategoryTheory.Functor.const J).obj (\u22a5_ C)) j \u226b colimitConstInitial.hom =\n      initial.to _", "start": [498, 1], "end": [502, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.InitialMonoClass", "code": "class InitialMonoClass (C : Type u\u2081) [Category.{v\u2081} C] : Prop where\n  \n  isInitial_mono_from : \u2200 {I} (X : C) (hI : IsInitial I), Mono (hI.to X)", "start": [505, 1], "end": [516, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.mono_from", "code": "theorem IsInitial.mono_from [InitialMonoClass C] {I} {X : C} (hI : IsInitial I) (f : I \u27f6 X) :\n    Mono f", "start": [519, 1], "end": [522, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.initial.mono_from", "code": "instance (priority := 100) initial.mono_from [HasInitial C] [InitialMonoClass C] (X : C)\n    (f : \u22a5_ C \u27f6 X) : Mono f :=\n  initialIsInitial.mono_from f", "start": [525, 1], "end": [527, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.InitialMonoClass.of_isInitial", "code": "theorem InitialMonoClass.of_isInitial {I : C} (hI : IsInitial I) (h : \u2200 X, Mono (hI.to X)) :\n    InitialMonoClass C where", "start": [530, 1], "end": [536, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.InitialMonoClass.of_initial", "code": "theorem InitialMonoClass.of_initial [HasInitial C] (h : \u2200 X : C, Mono (initial.to X)) :\n    InitialMonoClass C", "start": [539, 1], "end": [543, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.InitialMonoClass.of_isTerminal", "code": "theorem InitialMonoClass.of_isTerminal {I T : C} (hI : IsInitial I) (hT : IsTerminal T)\n    (_ : Mono (hI.to T)) : InitialMonoClass C", "start": [546, 1], "end": [550, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.InitialMonoClass.of_terminal", "code": "theorem InitialMonoClass.of_terminal [HasInitial C] [HasTerminal C] (h : Mono (initial.to (\u22a4_ C))) :\n    InitialMonoClass C", "start": [553, 1], "end": [557, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.terminalComparison", "code": "def terminalComparison [HasTerminal C] [HasTerminal D] : G.obj (\u22a4_ C) \u27f6 \u22a4_ D :=\n  terminal.from _", "start": [564, 1], "end": [570, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.initialComparison", "code": "def initialComparison [HasInitial C] [HasInitial D] : \u22a5_ D \u27f6 G.obj (\u22a5_ C) :=\n  initial.to _", "start": [574, 1], "end": [579, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coneOfDiagramInitial", "code": "@[simps]\ndef coneOfDiagramInitial {X : J} (tX : IsInitial X) (F : J \u2964 C) : Cone F where\n  pt := F.obj X\n  \u03c0 :=\n    { app := fun j => F.map (tX.to j)\n      naturality := fun j j' k => by\n        dsimp\n        rw [\u2190 F.map_comp, Category.id_comp, tX.hom_ext (tX.to j \u226b k) (tX.to j')] }", "start": [586, 1], "end": [595, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitOfDiagramInitial", "code": "def limitOfDiagramInitial {X : J} (tX : IsInitial X) (F : J \u2964 C) :\n    IsLimit (coneOfDiagramInitial tX F) where\n  lift s := s.\u03c0.app X\n  uniq s m w := by\n    conv_lhs => dsimp\n    simp_rw [\u2190 w X, coneOfDiagramInitial_\u03c0_app, tX.hom_ext (tX.to X) (\ud835\udfd9 _)]\n    dsimp; simp", "start": [598, 1], "end": [606, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitOfInitial", "code": "@[reducible]\ndef limitOfInitial (F : J \u2964 C) [HasInitial J] [HasLimit F] : limit F \u2245 F.obj (\u22a5_ J) :=\n  IsLimit.conePointUniqueUpToIso (limit.isLimit _) (limitOfDiagramInitial initialIsInitial F)", "start": [611, 1], "end": [615, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coneOfDiagramTerminal", "code": "@[simps]\ndef coneOfDiagramTerminal {X : J} (hX : IsTerminal X) (F : J \u2964 C)\n    [\u2200 (i j : J) (f : i \u27f6 j), IsIso (F.map f)] : Cone F where\n  pt := F.obj X\n  \u03c0 :=\n    { app := fun i => inv (F.map (hX.from _))\n      naturality := by\n        intro i j f\n        dsimp\n        simp only [IsIso.eq_inv_comp, IsIso.comp_inv_eq, Category.id_comp, \u2190 F.map_comp,\n          hX.hom_ext (hX.from i) (f \u226b hX.from j)] }", "start": [618, 1], "end": [631, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitOfDiagramTerminal", "code": "def limitOfDiagramTerminal {X : J} (hX : IsTerminal X) (F : J \u2964 C)\n    [\u2200 (i j : J) (f : i \u27f6 j), IsIso (F.map f)] : IsLimit (coneOfDiagramTerminal hX F) where\n  lift S := S.\u03c0.app _", "start": [634, 1], "end": [638, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitOfTerminal", "code": "@[reducible]\ndef limitOfTerminal (F : J \u2964 C) [HasTerminal J] [HasLimit F]\n    [\u2200 (i j : J) (f : i \u27f6 j), IsIso (F.map f)] : limit F \u2245 F.obj (\u22a4_ J) :=\n  IsLimit.conePointUniqueUpToIso (limit.isLimit _) (limitOfDiagramTerminal terminalIsTerminal F)", "start": [642, 1], "end": [647, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coconeOfDiagramTerminal", "code": "@[simps]\ndef coconeOfDiagramTerminal {X : J} (tX : IsTerminal X) (F : J \u2964 C) : Cocone F where\n  pt := F.obj X\n  \u03b9 :=\n    { app := fun j => F.map (tX.from j)\n      naturality := fun j j' k => by\n        dsimp\n        rw [\u2190 F.map_comp, Category.comp_id, tX.hom_ext (k \u226b tX.from j') (tX.from j)] }", "start": [650, 1], "end": [659, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimitOfDiagramTerminal", "code": "def colimitOfDiagramTerminal {X : J} (tX : IsTerminal X) (F : J \u2964 C) :\n    IsColimit (coconeOfDiagramTerminal tX F) where\n  desc s := s.\u03b9.app X\n  uniq s m w := by\n    conv_rhs => dsimp rw [\u2190 w X, coconeOfDiagramTerminal_\u03b9_app, tX.hom_ext (tX.from X) (\ud835\udfd9 _)]\n    simp", "start": [662, 1], "end": [670, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimitOfTerminal", "code": "@[reducible]\ndef colimitOfTerminal (F : J \u2964 C) [HasTerminal J] [HasColimit F] : colimit F \u2245 F.obj (\u22a4_ J) :=\n  IsColimit.coconePointUniqueUpToIso (colimit.isColimit _)\n    (colimitOfDiagramTerminal terminalIsTerminal F)", "start": [674, 1], "end": [679, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coconeOfDiagramInitial", "code": "@[simps]\ndef coconeOfDiagramInitial {X : J} (hX : IsInitial X) (F : J \u2964 C)\n    [\u2200 (i j : J) (f : i \u27f6 j), IsIso (F.map f)] : Cocone F where\n  pt := F.obj X\n  \u03b9 :=\n    { app := fun i => inv (F.map (hX.to _))\n      naturality := by\n        intro i j f\n        dsimp\n        simp only [IsIso.eq_inv_comp, IsIso.comp_inv_eq, Category.comp_id, \u2190 F.map_comp,\n          hX.hom_ext (hX.to i \u226b f) (hX.to j)] }", "start": [682, 1], "end": [695, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimitOfDiagramInitial", "code": "def colimitOfDiagramInitial {X : J} (hX : IsInitial X) (F : J \u2964 C)\n    [\u2200 (i j : J) (f : i \u27f6 j), IsIso (F.map f)] : IsColimit (coconeOfDiagramInitial hX F) where\n  desc S := S.\u03b9.app _", "start": [698, 1], "end": [702, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimitOfInitial", "code": "@[reducible]\ndef colimitOfInitial (F : J \u2964 C) [HasInitial J] [HasColimit F]\n    [\u2200 (i j : J) (f : i \u27f6 j), IsIso (F.map f)] : colimit F \u2245 F.obj (\u22a5_ J) :=\n  IsColimit.coconePointUniqueUpToIso (colimit.isColimit _)\n    (colimitOfDiagramInitial initialIsInitial _)", "start": [706, 1], "end": [712, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_\u03c0_of_isInitial", "code": "theorem isIso_\u03c0_of_isInitial {j : J} (I : IsInitial j) (F : J \u2964 C) [HasLimit F] :\n    IsIso (limit.\u03c0 F j)", "start": [715, 1], "end": [719, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_\u03c0_initial", "code": "instance isIso_\u03c0_initial [HasInitial J] (F : J \u2964 C) [HasLimit F] : IsIso (limit.\u03c0 F (\u22a5_ J)) :=\n  isIso_\u03c0_of_isInitial initialIsInitial F", "start": [722, 1], "end": [723, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_\u03c0_of_isTerminal", "code": "theorem isIso_\u03c0_of_isTerminal {j : J} (I : IsTerminal j) (F : J \u2964 C) [HasLimit F]\n    [\u2200 (i j : J) (f : i \u27f6 j), IsIso (F.map f)] : IsIso (limit.\u03c0 F j)", "start": [726, 1], "end": [728, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_\u03c0_terminal", "code": "instance isIso_\u03c0_terminal [HasTerminal J] (F : J \u2964 C) [HasLimit F]\n    [\u2200 (i j : J) (f : i \u27f6 j), IsIso (F.map f)] : IsIso (limit.\u03c0 F (\u22a4_ J)) :=\n  isIso_\u03c0_of_isTerminal terminalIsTerminal F", "start": [731, 1], "end": [733, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_\u03b9_of_isTerminal", "code": "theorem isIso_\u03b9_of_isTerminal {j : J} (I : IsTerminal j) (F : J \u2964 C) [HasColimit F] :\n    IsIso (colimit.\u03b9 F j)", "start": [736, 1], "end": [740, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_\u03b9_terminal", "code": "instance isIso_\u03b9_terminal [HasTerminal J] (F : J \u2964 C) [HasColimit F] : IsIso (colimit.\u03b9 F (\u22a4_ J)) :=\n  isIso_\u03b9_of_isTerminal terminalIsTerminal F", "start": [743, 1], "end": [744, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_\u03b9_of_isInitial", "code": "theorem isIso_\u03b9_of_isInitial {j : J} (I : IsInitial j) (F : J \u2964 C) [HasColimit F]\n    [\u2200 (i j : J) (f : i \u27f6 j), IsIso (F.map f)] : IsIso (colimit.\u03b9 F j)", "start": [747, 1], "end": [755, 5], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_\u03b9_initial", "code": "instance isIso_\u03b9_initial [HasInitial J] (F : J \u2964 C) [HasColimit F]\n    [\u2200 (i j : J) (f : i \u27f6 j), IsIso (F.map f)] : IsIso (colimit.\u03b9 F (\u22a5_ J)) :=\n  isIso_\u03b9_of_isInitial initialIsInitial F", "start": [758, 1], "end": [760, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/PUnit.lean", "imports": ["Mathlib/CategoryTheory/DiscreteCategory.lean", "Mathlib/CategoryTheory/Functor/Const.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.star", "code": "@[simps!]\ndef star : C \u2964 Discrete PUnit.{w + 1} :=\n  (Functor.const _).obj \u27e8\u27e8\u27e9\u27e9", "start": [29, 1], "end": [32, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.punitExt", "code": "@[simps!]\ndef punitExt (F G : C \u2964 Discrete PUnit.{w + 1}) : F \u2245 G :=\n  NatIso.ofComponents fun X => eqToIso (by simp only [eq_iff_true_of_subsingleton])", "start": [38, 1], "end": [41, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.punit_ext'", "code": "theorem punit_ext' (F G : C \u2964 Discrete PUnit.{w + 1}) : F = G", "start": [46, 1], "end": [49, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.fromPUnit", "code": "abbrev fromPUnit (X : C) : Discrete PUnit.{w + 1} \u2964 C :=\n  (Functor.const _).obj X", "start": [52, 1], "end": [54, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.equiv", "code": "@[simps]\ndef equiv : Discrete PUnit.{w + 1} \u2964 C \u224c C where\n  functor :=\n    { obj := fun F => F.obj \u27e8\u27e8\u27e9\u27e9\n      map := fun \u03b8 => \u03b8.app \u27e8\u27e8\u27e9\u27e9 }\n  inverse := Functor.const _\n  unitIso := NatIso.ofComponents fun X => Discrete.natIso fun i => Iso.refl _\n  counitIso := NatIso.ofComponents Iso.refl", "start": [57, 1], "end": [65, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.equiv_punit_iff_unique", "code": "theorem equiv_punit_iff_unique :\n    Nonempty (C \u224c Discrete PUnit.{w + 1}) \u2194 Nonempty C \u2227 \u2200 x y : C, Nonempty <| Unique (x \u27f6 y)", "start": [70, 1], "end": [102, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/EssentiallySmall.lean", "imports": ["Mathlib/Logic/Small/Basic.lean", "Mathlib/CategoryTheory/Skeletal.lean", "Mathlib/CategoryTheory/Category/ULift.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.EssentiallySmall", "code": "class EssentiallySmall (C : Type u) [Category.{v} C] : Prop where\n  \n  equiv_smallCategory : \u2203 (S : Type w) (_ : SmallCategory S), Nonempty (C \u224c S)", "start": [34, 1], "end": [38, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.EssentiallySmall.mk'", "code": "theorem EssentiallySmall.mk' {C : Type u} [Category.{v} C] {S : Type w} [SmallCategory S]\n    (e : C \u224c S) : EssentiallySmall.{w} C", "start": [41, 1], "end": [44, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SmallModel", "code": "def SmallModel (C : Type u) [Category.{v} C] [EssentiallySmall.{w} C] : Type w :=\n  Classical.choose (@EssentiallySmall.equiv_smallCategory C _ _)", "start": [47, 1], "end": [51, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.smallCategorySmallModel", "code": "noncomputable instance smallCategorySmallModel (C : Type u) [Category.{v} C]\n    [EssentiallySmall.{w} C] : SmallCategory (SmallModel C) :=\n  Classical.choose (Classical.choose_spec (@EssentiallySmall.equiv_smallCategory C _ _))", "start": [54, 1], "end": [56, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.equivSmallModel", "code": "noncomputable def equivSmallModel (C : Type u) [Category.{v} C] [EssentiallySmall.{w} C] :\n    C \u224c SmallModel C :=\n  Nonempty.some\n    (Classical.choose_spec (Classical.choose_spec (@EssentiallySmall.equiv_smallCategory C _ _)))", "start": [59, 1], "end": [65, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.essentiallySmall_congr", "code": "theorem essentiallySmall_congr {C : Type u} [Category.{v} C] {D : Type u'} [Category.{v'} D]\n    (e : C \u224c D) : EssentiallySmall.{w} C \u2194 EssentiallySmall.{w} D", "start": [68, 1], "end": [76, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.essentiallySmallOfSmall", "code": "theorem Discrete.essentiallySmallOfSmall {\u03b1 : Type u} [Small.{w} \u03b1] :\n    EssentiallySmall.{w} (Discrete \u03b1)", "start": [79, 1], "end": [81, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.essentiallySmallSelf", "code": "theorem essentiallySmallSelf : EssentiallySmall.{max w v u} C", "start": [84, 1], "end": [85, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LocallySmall", "code": "class LocallySmall (C : Type u) [Category.{v} C] : Prop where\n  \n  hom_small : \u2200 X Y : C, Small.{w} (X \u27f6 Y) := by infer_instance", "start": [88, 1], "end": [94, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.locallySmall_congr", "code": "theorem locallySmall_congr {C : Type u} [Category.{v} C] {D : Type u'} [Category.{v'} D]\n    (e : C \u224c D) : LocallySmall.{w} C \u2194 LocallySmall.{w} D", "start": [100, 1], "end": [114, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.locallySmall_self", "code": "instance (priority := 100) locallySmall_self (C : Type u) [Category.{v} C] : LocallySmall.{v} C\n    where", "start": [117, 1], "end": [118, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.locallySmall_max", "code": "theorem locallySmall_max {C : Type u} [Category.{v} C] : LocallySmall.{max v w} C\n    where", "start": [121, 1], "end": [123, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.locallySmall_of_essentiallySmall", "code": "instance (priority := 100) locallySmall_of_essentiallySmall (C : Type u) [Category.{v} C]\n    [EssentiallySmall.{w} C] : LocallySmall.{w} C :=\n  (locallySmall_congr (equivSmallModel C)).mpr (CategoryTheory.locallySmall_self _)", "start": [125, 1], "end": [127, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShrinkHoms", "code": "def ShrinkHoms (C : Type u) :=\n  C", "start": [130, 1], "end": [135, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShrinkHoms.toShrinkHoms", "code": "def toShrinkHoms {C' : Type*} (X : C') : ShrinkHoms C' :=\n  X", "start": [145, 1], "end": [147, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShrinkHoms.fromShrinkHoms", "code": "def fromShrinkHoms {C' : Type*} (X : ShrinkHoms C') : C' :=\n  X", "start": [150, 1], "end": [152, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShrinkHoms.to_from", "code": "@[simp]\ntheorem to_from (X : C') : fromShrinkHoms (toShrinkHoms X) = X", "start": [155, 1], "end": [157, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShrinkHoms.from_to", "code": "@[simp]\ntheorem from_to (X : ShrinkHoms C') : toShrinkHoms (fromShrinkHoms X) = X", "start": [160, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShrinkHoms.functor", "code": "@[simps]\nnoncomputable def functor : C \u2964 ShrinkHoms C\n    where\n  obj X := toShrinkHoms X\n  map {X Y} f := equivShrink (X \u27f6 Y) f", "start": [176, 1], "end": [181, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShrinkHoms.inverse", "code": "@[simps]\nnoncomputable def inverse : ShrinkHoms C \u2964 C\n    where\n  obj X := fromShrinkHoms X\n  map {X Y} f := (equivShrink (fromShrinkHoms X \u27f6 fromShrinkHoms Y)).symm f", "start": [184, 1], "end": [189, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShrinkHoms.equivalence", "code": "@[simps!]\nnoncomputable def equivalence : C \u224c ShrinkHoms C :=\n  Equivalence.mk (functor C) (inverse C)\n    (NatIso.ofComponents fun X => Iso.refl X)\n    (NatIso.ofComponents fun X => Iso.refl X)", "start": [192, 1], "end": [198, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.essentiallySmall_iff", "code": "theorem essentiallySmall_iff (C : Type u) [Category.{v} C] :\n    EssentiallySmall.{w} C \u2194 Small.{w} (Skeleton C) \u2227 LocallySmall.{w} C", "start": [203, 1], "end": [226, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.essentiallySmall_of_small_of_locallySmall", "code": "theorem essentiallySmall_of_small_of_locallySmall [Small.{w} C] [LocallySmall.{w} C] :\n    EssentiallySmall.{w} C", "start": [229, 1], "end": [231, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.locallySmall_of_thin", "code": "instance (priority := 100) locallySmall_of_thin {C : Type u} [Category.{v} C] [Quiver.IsThin C] :\n    LocallySmall.{w} C where", "start": [233, 1], "end": [236, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.essentiallySmall_iff_of_thin", "code": "theorem essentiallySmall_iff_of_thin {C : Type u} [Category.{v} C] [Quiver.IsThin C] :\n    EssentiallySmall.{w} C \u2194 Small.{w} (Skeleton C)", "start": [239, 1], "end": [244, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Equiv/Functor.lean", "imports": ["Mathlib/Control/Bifunctor.lean", "Mathlib/Logic/Equiv/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Functor.mapEquiv", "code": "def mapEquiv (h : \u03b1 \u2243 \u03b2) : f \u03b1 \u2243 f \u03b2 where\n  toFun := map h\n  invFun := map h.symm\n  left_inv x := by simp [map_map]\n  right_inv x := by simp [map_map]", "start": [37, 1], "end": [42, 35], "kind": "commanddeclaration"}, {"full_name": "Functor.mapEquiv_apply", "code": "@[simp]\ntheorem mapEquiv_apply (h : \u03b1 \u2243 \u03b2) (x : f \u03b1) : (mapEquiv f h : f \u03b1 \u2243 f \u03b2) x = map h x", "start": [45, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "Functor.mapEquiv_symm_apply", "code": "@[simp]\ntheorem mapEquiv_symm_apply (h : \u03b1 \u2243 \u03b2) (y : f \u03b2) :\n    (mapEquiv f h : f \u03b1 \u2243 f \u03b2).symm y = map h.symm y", "start": [50, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "Functor.mapEquiv_refl", "code": "@[simp]\ntheorem mapEquiv_refl : mapEquiv f (Equiv.refl \u03b1) = Equiv.refl (f \u03b1)", "start": [56, 1], "end": [60, 31], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.mapEquiv", "code": "def mapEquiv (h : \u03b1 \u2243 \u03b2) (h' : \u03b1' \u2243 \u03b2') : F \u03b1 \u03b1' \u2243 F \u03b2 \u03b2' where\n  toFun := bimap h h'\n  invFun := bimap h.symm h'.symm\n  left_inv x := by simp [bimap_bimap, id_bimap]\n  right_inv x := by simp [bimap_bimap, id_bimap]", "start": [69, 1], "end": [74, 49], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.mapEquiv_apply", "code": "@[simp]\ntheorem mapEquiv_apply (h : \u03b1 \u2243 \u03b2) (h' : \u03b1' \u2243 \u03b2') (x : F \u03b1 \u03b1') :\n    (mapEquiv F h h' : F \u03b1 \u03b1' \u2243 F \u03b2 \u03b2') x = bimap h h' x", "start": [77, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.mapEquiv_symm_apply", "code": "@[simp]\ntheorem mapEquiv_symm_apply (h : \u03b1 \u2243 \u03b2) (h' : \u03b1' \u2243 \u03b2') (y : F \u03b2 \u03b2') :\n    (mapEquiv F h h' : F \u03b1 \u03b1' \u2243 F \u03b2 \u03b2').symm y = bimap h.symm h'.symm y", "start": [83, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "Bifunctor.mapEquiv_refl_refl", "code": "@[simp]\ntheorem mapEquiv_refl_refl : mapEquiv F (Equiv.refl \u03b1) (Equiv.refl \u03b1') = Equiv.refl (F \u03b1 \u03b1')", "start": [89, 1], "end": [92, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Matrix/Invertible.lean", "imports": ["Mathlib/Data/Matrix/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.invOf_mul_self_assoc", "code": "protected theorem invOf_mul_self_assoc (A : Matrix n n \u03b1) (B : Matrix n m \u03b1) [Invertible A] :\n    \u215f A * (A * B) = B", "start": [40, 1], "end": [42, 84], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_invOf_self_assoc", "code": "protected theorem mul_invOf_self_assoc (A : Matrix n n \u03b1) (B : Matrix n m \u03b1) [Invertible A] :\n    A * (\u215f A * B) = B", "start": [45, 1], "end": [47, 84], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_invOf_mul_self_cancel", "code": "protected theorem mul_invOf_mul_self_cancel (A : Matrix m n \u03b1) (B : Matrix n n \u03b1) [Invertible B] :\n    A * \u215f B * B = A", "start": [50, 1], "end": [52, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_mul_invOf_self_cancel", "code": "protected theorem mul_mul_invOf_self_cancel (A : Matrix m n \u03b1) (B : Matrix n n \u03b1) [Invertible B] :\n    A * B * \u215f B = A", "start": [55, 1], "end": [57, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.invertibleConjTranspose", "code": "instance invertibleConjTranspose [Invertible A] : Invertible A\u1d34 := Invertible.star _", "start": [68, 1], "end": [69, 85], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_invOf", "code": "lemma conjTranspose_invOf [Invertible A] [Invertible A\u1d34] : (\u215fA)\u1d34 = \u215f(A\u1d34) := star_invOf _", "start": [71, 1], "end": [71, 89], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.invertibleOfInvertibleConjTranspose", "code": "def invertibleOfInvertibleConjTranspose [Invertible A\u1d34] : Invertible A := by\n  rw [\u2190 conjTranspose_conjTranspose A, \u2190 star_eq_conjTranspose]\n  infer_instance", "start": [73, 1], "end": [76, 17], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_conjTranspose", "code": "@[simp] lemma isUnit_conjTranspose : IsUnit A\u1d34 \u2194 IsUnit A := isUnit_star", "start": [79, 1], "end": [79, 73], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.invertibleTranspose", "code": "instance invertibleTranspose [Invertible A] : Invertible A\u1d40 where\n  invOf := (\u215fA)\u1d40\n  invOf_mul_self := by rw [\u2190transpose_mul, mul_invOf_self, transpose_one]\n  mul_invOf_self := by rw [\u2190transpose_mul, invOf_mul_self, transpose_one]", "start": [89, 1], "end": [93, 74], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_invOf", "code": "lemma transpose_invOf [Invertible A] [Invertible A\u1d40] : (\u215fA)\u1d40 = \u215f(A\u1d40) := by\n  letI := invertibleTranspose A\n  convert (rfl : _ = \u215f(A\u1d40))", "start": [96, 1], "end": [98, 28], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.invertibleOfInvertibleTranspose", "code": "def invertibleOfInvertibleTranspose [Invertible A\u1d40] : Invertible A where\n  invOf := (\u215f(A\u1d40))\u1d40\n  invOf_mul_self := by rw [\u2190transpose_one, \u2190 mul_invOf_self A\u1d40, transpose_mul, transpose_transpose]\n  mul_invOf_self := by rw [\u2190transpose_one, \u2190 invOf_mul_self A\u1d40, transpose_mul, transpose_transpose]", "start": [100, 1], "end": [104, 100], "kind": "commanddeclaration"}, {"full_name": "Matrix.transposeInvertibleEquivInvertible", "code": "@[simps]\ndef transposeInvertibleEquivInvertible : Invertible A\u1d40 \u2243 Invertible A where\n  toFun := @invertibleOfInvertibleTranspose _ _ _ _ _ _\n  invFun := @invertibleTranspose _ _ _ _ _ _\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _", "start": [107, 1], "end": [114, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_transpose", "code": "@[simp] lemma isUnit_transpose : IsUnit A\u1d40 \u2194 IsUnit A := by\n  simp only [\u2190 nonempty_invertible_iff_isUnit,\n    (transposeInvertibleEquivInvertible A).nonempty_congr]", "start": [116, 1], "end": [118, 59], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/MvPolynomial.lean", "Mathlib/Algebra/Regular/Basic.lean", "Mathlib/RingTheory/Polynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Matrix/Polynomial.lean"], "premises": [{"full_name": "Matrix.cramerMap", "code": "def cramerMap (i : n) : \u03b1 :=\n  (A.updateColumn i b).det", "start": [68, 1], "end": [75, 27], "kind": "commanddeclaration"}, {"full_name": "Matrix.cramerMap_is_linear", "code": "theorem cramerMap_is_linear (i : n) : IsLinearMap \u03b1 fun b => cramerMap A b i", "start": [78, 1], "end": [80, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.cramer_is_linear", "code": "theorem cramer_is_linear : IsLinearMap \u03b1 (cramerMap A)", "start": [83, 1], "end": [86, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.cramer", "code": "def cramer (A : Matrix n n \u03b1) : (n \u2192 \u03b1) \u2192\u2097[\u03b1] (n \u2192 \u03b1) :=\n  IsLinearMap.mk' (cramerMap A) (cramer_is_linear A)", "start": [89, 1], "end": [96, 53], "kind": "commanddeclaration"}, {"full_name": "Matrix.cramer_apply", "code": "theorem cramer_apply (i : n) : cramer A b i = (A.updateColumn i b).det", "start": [99, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.cramer_transpose_apply", "code": "theorem cramer_transpose_apply (i : n) : cramer A\u1d40 b i = (A.updateRow i b).det", "start": [103, 1], "end": [104, 59], "kind": "commanddeclaration"}, {"full_name": "Matrix.cramer_transpose_row_self", "code": "theorem cramer_transpose_row_self (i : n) : A\u1d40.cramer (A i) = Pi.single i A.det", "start": [107, 1], "end": [117, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.cramer_row_self", "code": "theorem cramer_row_self (i : n) (h : \u2200 j, b j = A j i) : A.cramer b = Pi.single i A.det", "start": [120, 1], "end": [123, 17], "kind": "commanddeclaration"}, {"full_name": "Matrix.cramer_one", "code": "@[simp]\ntheorem cramer_one : cramer (1 : Matrix n n \u03b1) = 1", "start": [126, 1], "end": [133, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.cramer_smul", "code": "theorem cramer_smul (r : \u03b1) (A : Matrix n n \u03b1) :\n    cramer (r \u2022 A) = r ^ (Fintype.card n - 1) \u2022 cramer A", "start": [136, 1], "end": [138, 72], "kind": "commanddeclaration"}, {"full_name": "Matrix.cramer_subsingleton_apply", "code": "@[simp]\ntheorem cramer_subsingleton_apply [Subsingleton n] (A : Matrix n n \u03b1) (b : n \u2192 \u03b1) (i : n) :\n    cramer A b i = b i", "start": [141, 1], "end": [143, 99], "kind": "commanddeclaration"}, {"full_name": "Matrix.cramer_zero", "code": "theorem cramer_zero [Nontrivial n] : cramer (0 : Matrix n n \u03b1) = 0", "start": [146, 1], "end": [151, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.sum_cramer", "code": "theorem sum_cramer {\u03b2} (s : Finset \u03b2) (f : \u03b2 \u2192 n \u2192 \u03b1) :\n    (\u2211 x in s, cramer A (f x)) = cramer A (\u2211 x in s, f x)", "start": [154, 1], "end": [157, 31], "kind": "commanddeclaration"}, {"full_name": "Matrix.sum_cramer_apply", "code": "theorem sum_cramer_apply {\u03b2} (s : Finset \u03b2) (f : n \u2192 \u03b2 \u2192 \u03b1) (i : n) :\n    (\u2211 x in s, cramer A (fun j => f j x) i) = cramer A (fun j : n => \u2211 x in s, f j x) i", "start": [160, 1], "end": [171, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.cramer_submatrix_equiv", "code": "theorem cramer_submatrix_equiv (A : Matrix m m \u03b1) (e : n \u2243 m) (b : n \u2192 \u03b1) :\n    cramer (A.submatrix e e) b = cramer A (b \u2218 e.symm) \u2218 e", "start": [174, 1], "end": [178, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.cramer_reindex", "code": "theorem cramer_reindex (e : m \u2243 n) (A : Matrix m m \u03b1) (b : n \u2192 \u03b1) :\n    cramer (reindex e e A) b = cramer A (b \u2218 e) \u2218 e.symm", "start": [181, 1], "end": [183, 31], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate", "code": "def adjugate (A : Matrix n n \u03b1) : Matrix n n \u03b1 :=\n  of fun i => cramer A\u1d40 (Pi.single i 1)", "start": [198, 1], "end": [207, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_def", "code": "theorem adjugate_def (A : Matrix n n \u03b1) : adjugate A = of fun i => cramer A\u1d40 (Pi.single i 1)", "start": [210, 1], "end": [211, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_apply", "code": "theorem adjugate_apply (A : Matrix n n \u03b1) (i j : n) :\n    adjugate A i j = (A.updateRow j (Pi.single i 1)).det", "start": [214, 1], "end": [216, 83], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_transpose", "code": "theorem adjugate_transpose (A : Matrix n n \u03b1) : (adjugate A)\u1d40 = adjugate A\u1d40", "start": [219, 1], "end": [246, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_submatrix_equiv_self", "code": "@[simp]\ntheorem adjugate_submatrix_equiv_self (e : n \u2243 m) (A : Matrix m m \u03b1) :\n    adjugate (A.submatrix e e) = (adjugate A).submatrix e e", "start": [249, 1], "end": [258, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_reindex", "code": "theorem adjugate_reindex (e : m \u2243 n) (A : Matrix m m \u03b1) :\n    adjugate (reindex e e A) = reindex e e (adjugate A)", "start": [261, 1], "end": [263, 36], "kind": "commanddeclaration"}, {"full_name": "Matrix.cramer_eq_adjugate_mulVec", "code": "theorem cramer_eq_adjugate_mulVec (A : Matrix n n \u03b1) (b : n \u2192 \u03b1) :\n    cramer A b = A.adjugate.mulVec b", "start": [266, 1], "end": [280, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_adjugate_apply", "code": "theorem mul_adjugate_apply (A : Matrix n n \u03b1) (i j k) :\n    A i k * adjugate A k j = cramer A\u1d40 (Pi.single k (A i k)) j", "start": [283, 1], "end": [286, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_adjugate", "code": "theorem mul_adjugate (A : Matrix n n \u03b1) : A * adjugate A = A.det \u2022 (1 : Matrix n n \u03b1)", "start": [289, 1], "end": [292, 99], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_mul", "code": "theorem adjugate_mul (A : Matrix n n \u03b1) : adjugate A * A = A.det \u2022 (1 : Matrix n n \u03b1)", "start": [295, 1], "end": [299, 83], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_smul", "code": "theorem adjugate_smul (r : \u03b1) (A : Matrix n n \u03b1) :\n    adjugate (r \u2022 A) = r ^ (Fintype.card n - 1) \u2022 adjugate A", "start": [302, 1], "end": [305, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_cramer", "code": "@[simp]\ntheorem mulVec_cramer (A : Matrix n n \u03b1) (b : n \u2192 \u03b1) : A.mulVec (cramer A b) = A.det \u2022 b", "start": [308, 1], "end": [313, 93], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_subsingleton", "code": "theorem adjugate_subsingleton [Subsingleton n] (A : Matrix n n \u03b1) : adjugate A = 1", "start": [316, 1], "end": [318, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_eq_one_of_card_eq_one", "code": "theorem adjugate_eq_one_of_card_eq_one {A : Matrix n n \u03b1} (h : Fintype.card n = 1) :\n    adjugate A = 1", "start": [321, 1], "end": [324, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_zero", "code": "@[simp]\ntheorem adjugate_zero [Nontrivial n] : adjugate (0 : Matrix n n \u03b1) = 0", "start": [327, 1], "end": [333, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_one", "code": "@[simp]\ntheorem adjugate_one : adjugate (1 : Matrix n n \u03b1) = 1", "start": [336, 1], "end": [339, 66], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_diagonal", "code": "@[simp]\ntheorem adjugate_diagonal (v : n \u2192 \u03b1) :\n    adjugate (diagonal v) = diagonal fun i => \u220f j in Finset.univ.erase i, v j", "start": [342, 1], "end": [354, 57], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_adjugate", "code": "theorem _root_.RingHom.map_adjugate {R S : Type*} [CommRing R] [CommRing S] (f : R \u2192+* S)\n    (M : Matrix n n R) : f.mapMatrix M.adjugate = Matrix.adjugate (f.mapMatrix M)", "start": [357, 1], "end": [364, 83], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_adjugate", "code": "theorem _root_.AlgHom.map_adjugate {R A B : Type*} [CommSemiring R] [CommRing A] [CommRing B]\n    [Algebra R A] [Algebra R B] (f : A \u2192\u2090[R] B) (M : Matrix n n A) :\n    f.mapMatrix M.adjugate = Matrix.adjugate (f.mapMatrix M)", "start": [367, 1], "end": [370, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_adjugate", "code": "theorem det_adjugate (A : Matrix n n \u03b1) : (adjugate A).det = A.det ^ (Fintype.card n - 1)", "start": [373, 1], "end": [389, 77], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_fin_zero", "code": "@[simp]\ntheorem adjugate_fin_zero (A : Matrix (Fin 0) (Fin 0) \u03b1) : adjugate A = 0", "start": [392, 1], "end": [394, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_fin_one", "code": "@[simp]\ntheorem adjugate_fin_one (A : Matrix (Fin 1) (Fin 1) \u03b1) : adjugate A = 1", "start": [397, 1], "end": [399, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_fin_two", "code": "theorem adjugate_fin_two (A : Matrix (Fin 2) (Fin 2) \u03b1) :\n    adjugate A = !![A 1 1, -A 0 1; -A 1 0, A 0 0]", "start": [402, 1], "end": [413, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_fin_two_of", "code": "@[simp]\ntheorem adjugate_fin_two_of (a b c d : \u03b1) : adjugate !![a, b; c, d] = !![d, -b; -c, a]", "start": [416, 1], "end": [418, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_fin_succ_eq_det_submatrix", "code": "theorem adjugate_fin_succ_eq_det_submatrix {n : \u2115} (A : Matrix (Fin n.succ) (Fin n.succ) \u03b1) (i j) :\n    adjugate A i j = (-1) ^ (j + i : \u2115) * det (A.submatrix j.succAbove i.succAbove)", "start": [421, 1], "end": [425, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_sum_mul_adjugate_row", "code": "theorem det_eq_sum_mul_adjugate_row (A : Matrix n n \u03b1) (i : n) :\n    det A = \u2211 j : n, A i j * adjugate A j i", "start": [428, 1], "end": [439, 86], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_sum_mul_adjugate_col", "code": "theorem det_eq_sum_mul_adjugate_col (A : Matrix n n \u03b1) (j : n) :\n    det A = \u2211 i : n, A i j * adjugate A j i", "start": [442, 1], "end": [444, 90], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_conjTranspose", "code": "theorem adjugate_conjTranspose [StarRing \u03b1] (A : Matrix n n \u03b1) : A.adjugate\u1d34 = adjugate A\u1d34", "start": [447, 1], "end": [450, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.isRegular_of_isLeftRegular_det", "code": "theorem isRegular_of_isLeftRegular_det {A : Matrix n n \u03b1} (hA : IsLeftRegular A.det) :\n    IsRegular A", "start": [453, 1], "end": [465, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_mul_distrib_aux", "code": "theorem adjugate_mul_distrib_aux (A B : Matrix n n \u03b1) (hA : IsLeftRegular A.det)\n    (hB : IsLeftRegular B.det) : adjugate (A * B) = adjugate B * adjugate A", "start": [468, 1], "end": [476, 86], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_mul_distrib", "code": "theorem adjugate_mul_distrib (A B : Matrix n n \u03b1) : adjugate (A * B) = adjugate B * adjugate A", "start": [479, 1], "end": [501, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_pow", "code": "@[simp]\ntheorem adjugate_pow (A : Matrix n n \u03b1) (k : \u2115) : adjugate (A ^ k) = adjugate A ^ k", "start": [504, 1], "end": [508, 55], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_smul_adjugate_adjugate", "code": "theorem det_smul_adjugate_adjugate (A : Matrix n n \u03b1) :\n    det A \u2022 adjugate (adjugate A) = det A ^ (Fintype.card n - 1) \u2022 A", "start": [511, 1], "end": [517, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_adjugate", "code": "theorem adjugate_adjugate (A : Matrix n n \u03b1) (h : Fintype.card n \u2260 1) :\n    adjugate (adjugate A) = det A ^ (Fintype.card n - 2) \u2022 A", "start": [520, 1], "end": [542, 66], "kind": "commanddeclaration"}, {"full_name": "Matrix.adjugate_adjugate'", "code": "theorem adjugate_adjugate' (A : Matrix n n \u03b1) [Nontrivial n] :\n    adjugate (adjugate A) = det A ^ (Fintype.card n - 2) \u2022 A", "start": [545, 1], "end": [548, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Reindex.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Determinant.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.reindexLinearEquiv", "code": "def reindexLinearEquiv (e\u2098 : m \u2243 m') (e\u2099 : n \u2243 n') : Matrix m n A \u2243\u2097[R] Matrix m' n' A :=\n  { reindex e\u2098 e\u2099 with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }", "start": [41, 1], "end": [46, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexLinearEquiv_apply", "code": "@[simp]\ntheorem reindexLinearEquiv_apply (e\u2098 : m \u2243 m') (e\u2099 : n \u2243 n') (M : Matrix m n A) :\n    reindexLinearEquiv R A e\u2098 e\u2099 M = reindex e\u2098 e\u2099 M", "start": [49, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexLinearEquiv_symm", "code": "@[simp]\ntheorem reindexLinearEquiv_symm (e\u2098 : m \u2243 m') (e\u2099 : n \u2243 n') :\n    (reindexLinearEquiv R A e\u2098 e\u2099).symm = reindexLinearEquiv R A e\u2098.symm e\u2099.symm", "start": [55, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexLinearEquiv_refl_refl", "code": "@[simp]\ntheorem reindexLinearEquiv_refl_refl :\n    reindexLinearEquiv R A (Equiv.refl m) (Equiv.refl n) = LinearEquiv.refl R _", "start": [61, 1], "end": [64, 31], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexLinearEquiv_trans", "code": "theorem reindexLinearEquiv_trans (e\u2081 : m \u2243 m') (e\u2082 : n \u2243 n') (e\u2081' : m' \u2243 m'') (e\u2082' : n' \u2243 n'') :\n    (reindexLinearEquiv R A e\u2081 e\u2082).trans (reindexLinearEquiv R A e\u2081' e\u2082') =\n      (reindexLinearEquiv R A (e\u2081.trans e\u2081') (e\u2082.trans e\u2082') : _ \u2243\u2097[R] _)", "start": [67, 1], "end": [71, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexLinearEquiv_comp", "code": "theorem reindexLinearEquiv_comp (e\u2081 : m \u2243 m') (e\u2082 : n \u2243 n') (e\u2081' : m' \u2243 m'') (e\u2082' : n' \u2243 n'') :\n    reindexLinearEquiv R A e\u2081' e\u2082' \u2218 reindexLinearEquiv R A e\u2081 e\u2082 =\n      reindexLinearEquiv R A (e\u2081.trans e\u2081') (e\u2082.trans e\u2082')", "start": [74, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexLinearEquiv_comp_apply", "code": "theorem reindexLinearEquiv_comp_apply (e\u2081 : m \u2243 m') (e\u2082 : n \u2243 n') (e\u2081' : m' \u2243 m'') (e\u2082' : n' \u2243 n'')\n    (M : Matrix m n A) :\n    (reindexLinearEquiv R A e\u2081' e\u2082') (reindexLinearEquiv R A e\u2081 e\u2082 M) =\n      reindexLinearEquiv R A (e\u2081.trans e\u2081') (e\u2082.trans e\u2082') M", "start": [81, 1], "end": [85, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexLinearEquiv_one", "code": "theorem reindexLinearEquiv_one [DecidableEq m] [DecidableEq m'] [One A] (e : m \u2243 m') :\n    reindexLinearEquiv R A e e (1 : Matrix m m A) = 1", "start": [88, 1], "end": [90, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexLinearEquiv_mul", "code": "theorem reindexLinearEquiv_mul [Fintype n] [Fintype n'] (e\u2098 : m \u2243 m') (e\u2099 : n \u2243 n') (e\u2092 : o \u2243 o')\n    (M : Matrix m n A) (N : Matrix n o A) :\n    reindexLinearEquiv R A e\u2098 e\u2099 M * reindexLinearEquiv R A e\u2099 e\u2092 N =\n      reindexLinearEquiv R A e\u2098 e\u2092 (M * N)", "start": [99, 1], "end": [103, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_reindexLinearEquiv_one", "code": "theorem mul_reindexLinearEquiv_one [Fintype n] [DecidableEq o] (e\u2081 : o \u2243 n) (e\u2082 : o \u2243 n')\n    (M : Matrix m n A) :\n    M * (reindexLinearEquiv R A e\u2081 e\u2082 1) =\n      reindexLinearEquiv R A (Equiv.refl m) (e\u2081.symm.trans e\u2082) M", "start": [106, 1], "end": [111, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexAlgEquiv", "code": "def reindexAlgEquiv (e : m \u2243 n) : Matrix m m R \u2243\u2090[R] Matrix n n R :=\n  { reindexLinearEquiv R R e e with\n    toFun := reindex e e\n    map_mul' := fun a b => (reindexLinearEquiv_mul R R e e e a b).symm\n    commutes' := fun r => by simp [algebraMap, Algebra.toRingHom, submatrix_smul _ 1] }", "start": [120, 1], "end": [128, 88], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexAlgEquiv_apply", "code": "@[simp]\ntheorem reindexAlgEquiv_apply (e : m \u2243 n) (M : Matrix m m R) :\n    reindexAlgEquiv R e M = reindex e e M", "start": [131, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexAlgEquiv_symm", "code": "@[simp]\ntheorem reindexAlgEquiv_symm (e : m \u2243 n) : (reindexAlgEquiv R e).symm = reindexAlgEquiv R e.symm", "start": [137, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexAlgEquiv_refl", "code": "@[simp]\ntheorem reindexAlgEquiv_refl : reindexAlgEquiv R (Equiv.refl m) = AlgEquiv.refl", "start": [142, 1], "end": [144, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexAlgEquiv_mul", "code": "theorem reindexAlgEquiv_mul (e : m \u2243 n) (M : Matrix m m R) (N : Matrix m m R) :\n    reindexAlgEquiv R e (M * N) = reindexAlgEquiv R e M * reindexAlgEquiv R e N", "start": [147, 1], "end": [149, 36], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_reindexLinearEquiv_self", "code": "theorem det_reindexLinearEquiv_self [CommRing R] [Fintype m] [DecidableEq m] [Fintype n]\n    [DecidableEq n] (e : m \u2243 n) (M : Matrix m m R) : det (reindexLinearEquiv R R e e M) = det M", "start": [154, 1], "end": [160, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_reindexAlgEquiv", "code": "theorem det_reindexAlgEquiv [CommRing R] [Fintype m] [DecidableEq m] [Fintype n] [DecidableEq n]\n    (e : m \u2243 n) (A : Matrix m m R) : det (reindexAlgEquiv R e A) = det A", "start": [163, 1], "end": [169, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/AEMeasurable.lean", "imports": ["Mathlib/MeasureTheory/Measure/Trim.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subsingleton.aemeasurable", "code": "@[nontriviality, measurability]\ntheorem Subsingleton.aemeasurable [Subsingleton \u03b1] : AEMeasurable f \u03bc", "start": [26, 1], "end": [28, 39], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_of_subsingleton_codomain", "code": "@[nontriviality, measurability]\ntheorem aemeasurable_of_subsingleton_codomain [Subsingleton \u03b2] : AEMeasurable f \u03bc", "start": [31, 1], "end": [33, 55], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_zero_measure", "code": "@[simp, measurability]\ntheorem aemeasurable_zero_measure : AEMeasurable f (0 : Measure \u03b1)", "start": [36, 1], "end": [39, 52], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_id''", "code": "theorem aemeasurable_id'' (\u03bc : Measure \u03b1) {m : MeasurableSpace \u03b1} (hm : m \u2264 m0) :\n    @AEMeasurable \u03b1 \u03b1 m m0 id \u03bc", "start": [42, 1], "end": [44, 62], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.mono_ac", "code": "lemma mono_ac (hf : AEMeasurable f \u03bd) (h\u03bc\u03bd : \u03bc \u226a \u03bd) : AEMeasurable f \u03bc :=\n  \u27e8hf.mk f, hf.measurable_mk, h\u03bc\u03bd.ae_le hf.ae_eq_mk\u27e9", "start": [49, 1], "end": [50, 53], "kind": "mathlibtacticlemma"}, {"full_name": "AEMeasurable.mono_measure", "code": "theorem mono_measure (h : AEMeasurable f \u03bc) (h' : \u03bd \u2264 \u03bc) : AEMeasurable f \u03bd", "start": [52, 1], "end": [53, 36], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.mono_set", "code": "theorem mono_set {s t} (h : s \u2286 t) (ht : AEMeasurable f (\u03bc.restrict t)) :\n    AEMeasurable f (\u03bc.restrict s)", "start": [56, 1], "end": [58, 43], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.mono'", "code": "protected theorem mono' (h : AEMeasurable f \u03bc) (h' : \u03bd \u226a \u03bc) : AEMeasurable f \u03bd", "start": [61, 1], "end": [62, 43], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.ae_mem_imp_eq_mk", "code": "theorem ae_mem_imp_eq_mk {s} (h : AEMeasurable f (\u03bc.restrict s)) :\n    \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 f x = h.mk f x", "start": [65, 1], "end": [67, 35], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.ae_inf_principal_eq_mk", "code": "theorem ae_inf_principal_eq_mk {s} (h : AEMeasurable f (\u03bc.restrict s)) : f =\u1da0[\u03bc.ae \u2293 \ud835\udcdf s] h.mk f", "start": [70, 1], "end": [71, 28], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.sum_measure", "code": "@[measurability]\ntheorem sum_measure [Countable \u03b9] {\u03bc : \u03b9 \u2192 Measure \u03b1} (h : \u2200 i, AEMeasurable f (\u03bc i)) :\n    AEMeasurable f (sum \u03bc)", "start": [74, 1], "end": [111, 41], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_sum_measure_iff", "code": "@[simp]\ntheorem _root_.aemeasurable_sum_measure_iff [Countable \u03b9] {\u03bc : \u03b9 \u2192 Measure \u03b1} :\n    AEMeasurable f (sum \u03bc) \u2194 \u2200 i, AEMeasurable f (\u03bc i)", "start": [114, 1], "end": [117, 56], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_add_measure_iff", "code": "@[simp]\ntheorem _root_.aemeasurable_add_measure_iff :\n    AEMeasurable f (\u03bc + \u03bd) \u2194 AEMeasurable f \u03bc \u2227 AEMeasurable f \u03bd", "start": [120, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.add_measure", "code": "@[measurability]\ntheorem add_measure {f : \u03b1 \u2192 \u03b2} (h\u03bc : AEMeasurable f \u03bc) (h\u03bd : AEMeasurable f \u03bd) :\n    AEMeasurable f (\u03bc + \u03bd)", "start": [127, 1], "end": [130, 42], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.iUnion", "code": "@[measurability]\nprotected theorem iUnion [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1}\n    (h : \u2200 i, AEMeasurable f (\u03bc.restrict (s i))) : AEMeasurable f (\u03bc.restrict (\u22c3 i, s i))", "start": [133, 1], "end": [136, 53], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_iUnion_iff", "code": "@[simp]\ntheorem _root_.aemeasurable_iUnion_iff [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} :\n    AEMeasurable f (\u03bc.restrict (\u22c3 i, s i)) \u2194 \u2200 i, AEMeasurable f (\u03bc.restrict (s i))", "start": [139, 1], "end": [142, 95], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_union_iff", "code": "@[simp]\ntheorem _root_.aemeasurable_union_iff {s t : Set \u03b1} :\n    AEMeasurable f (\u03bc.restrict (s \u222a t)) \u2194\n      AEMeasurable f (\u03bc.restrict s) \u2227 AEMeasurable f (\u03bc.restrict t)", "start": [145, 1], "end": [149, 92], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.smul_measure", "code": "@[measurability]\ntheorem smul_measure [Monoid R] [DistribMulAction R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]\n    (h : AEMeasurable f \u03bc) (c : R) : AEMeasurable f (c \u2022 \u03bc)", "start": [152, 1], "end": [155, 58], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.comp_aemeasurable", "code": "theorem comp_aemeasurable {f : \u03b1 \u2192 \u03b4} {g : \u03b4 \u2192 \u03b2} (hg : AEMeasurable g (\u03bc.map f))\n    (hf : AEMeasurable f \u03bc) : AEMeasurable (g \u2218 f) \u03bc", "start": [158, 1], "end": [161, 72], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.comp_measurable", "code": "theorem comp_measurable {f : \u03b1 \u2192 \u03b4} {g : \u03b4 \u2192 \u03b2} (hg : AEMeasurable g (\u03bc.map f))\n    (hf : Measurable f) : AEMeasurable (g \u2218 f) \u03bc", "start": [164, 1], "end": [166, 39], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.comp_quasiMeasurePreserving", "code": "theorem comp_quasiMeasurePreserving {\u03bd : Measure \u03b4} {f : \u03b1 \u2192 \u03b4} {g : \u03b4 \u2192 \u03b2} (hg : AEMeasurable g \u03bd)\n    (hf : QuasiMeasurePreserving f \u03bc \u03bd) : AEMeasurable (g \u2218 f) \u03bc", "start": [169, 1], "end": [171, 67], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.map_map_of_aemeasurable", "code": "theorem map_map_of_aemeasurable {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : AEMeasurable g (Measure.map f \u03bc))\n    (hf : AEMeasurable f \u03bc) : (\u03bc.map f).map g = \u03bc.map (g \u2218 f)", "start": [174, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.prod_mk", "code": "@[measurability]\ntheorem prod_mk {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    AEMeasurable (fun x => (f x, g x)) \u03bc", "start": [189, 1], "end": [193, 50], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.exists_ae_eq_range_subset", "code": "theorem exists_ae_eq_range_subset (H : AEMeasurable f \u03bc) {t : Set \u03b2} (ht : \u2200\u1d50 x \u2202\u03bc, f x \u2208 t)\n    (h\u2080 : t.Nonempty) : \u2203 g, Measurable g \u2227 range g \u2286 t \u2227 f =\u1d50[\u03bc] g", "start": [196, 1], "end": [218, 78], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.exists_measurable_nonneg", "code": "theorem exists_measurable_nonneg {\u03b2} [Preorder \u03b2] [Zero \u03b2] {m\u03b2 : MeasurableSpace \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (hf : AEMeasurable f \u03bc) (f_nn : \u2200\u1d50 t \u2202\u03bc, 0 \u2264 f t) : \u2203 g, Measurable g \u2227 0 \u2264 g \u2227 f =\u1d50[\u03bc] g", "start": [221, 1], "end": [224, 67], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.subtype_mk", "code": "theorem subtype_mk (h : AEMeasurable f \u03bc) {s : Set \u03b2} {hfs : \u2200 x, f x \u2208 s} :\n    AEMeasurable (codRestrict f s hfs) \u03bc", "start": [227, 1], "end": [234, 26], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.nullMeasurable", "code": "protected theorem nullMeasurable (h : AEMeasurable f \u03bc) : NullMeasurable f \u03bc", "start": [237, 1], "end": [239, 35], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_const'", "code": "theorem aemeasurable_const' (h : \u2200\u1d50 (x) (y) \u2202\u03bc, f x = f y) : AEMeasurable f \u03bc", "start": [244, 1], "end": [249, 66], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_uIoc_iff", "code": "theorem aemeasurable_uIoc_iff [LinearOrder \u03b1] {f : \u03b1 \u2192 \u03b2} {a b : \u03b1} :\n    (AEMeasurable f <| \u03bc.restrict <| \u0399 a b) \u2194\n      (AEMeasurable f <| \u03bc.restrict <| Ioc a b) \u2227 (AEMeasurable f <| \u03bc.restrict <| Ioc b a)", "start": [252, 1], "end": [255, 48], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_iff_measurable", "code": "theorem aemeasurable_iff_measurable [\u03bc.IsComplete] : AEMeasurable f \u03bc \u2194 Measurable f", "start": [258, 1], "end": [259, 78], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.aemeasurable_map_iff", "code": "theorem MeasurableEmbedding.aemeasurable_map_iff {g : \u03b2 \u2192 \u03b3} (hf : MeasurableEmbedding f) :\n    AEMeasurable g (\u03bc.map f) \u2194 AEMeasurable (g \u2218 f) \u03bc", "start": [262, 1], "end": [267, 40], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.aemeasurable_comp_iff", "code": "theorem MeasurableEmbedding.aemeasurable_comp_iff {g : \u03b2 \u2192 \u03b3} (hg : MeasurableEmbedding g)\n    {\u03bc : Measure \u03b1} : AEMeasurable (g \u2218 f) \u03bc \u2194 AEMeasurable f \u03bc", "start": [270, 1], "end": [275, 68], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_restrict_iff_comap_subtype", "code": "theorem aemeasurable_restrict_iff_comap_subtype {s : Set \u03b1} (hs : MeasurableSet s) {\u03bc : Measure \u03b1}\n    {f : \u03b1 \u2192 \u03b2} : AEMeasurable f (\u03bc.restrict s) \u2194 AEMeasurable (f \u2218 (\u2191) : s \u2192 \u03b2) (comap (\u2191) \u03bc)", "start": [278, 1], "end": [280, 93], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_one", "code": "@[to_additive] theorem aemeasurable_one [One \u03b2] : AEMeasurable (fun _ : \u03b1 => (1 : \u03b2)) \u03bc", "start": [283, 1], "end": [285, 30], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_smul_measure_iff", "code": "@[simp]\ntheorem aemeasurable_smul_measure_iff {c : \u211d\u22650\u221e} (hc : c \u2260 0) :\n    AEMeasurable f (c \u2022 \u03bc) \u2194 AEMeasurable f \u03bc", "start": [289, 1], "end": [293, 70], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_of_aemeasurable_trim", "code": "theorem aemeasurable_of_aemeasurable_trim {\u03b1} {m m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    (hm : m \u2264 m0) {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f (\u03bc.trim hm)) : AEMeasurable f \u03bc", "start": [296, 1], "end": [298, 89], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_restrict_of_measurable_subtype", "code": "theorem aemeasurable_restrict_of_measurable_subtype {s : Set \u03b1} (hs : MeasurableSet s)\n    (hf : Measurable fun x : s => f x) : AEMeasurable f (\u03bc.restrict s)", "start": [301, 1], "end": [303, 65], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_map_equiv_iff", "code": "theorem aemeasurable_map_equiv_iff (e : \u03b1 \u2243\u1d50 \u03b2) {f : \u03b2 \u2192 \u03b3} :\n    AEMeasurable f (\u03bc.map e) \u2194 AEMeasurable (f \u2218 e) \u03bc", "start": [306, 1], "end": [308, 45], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.restrict", "code": "theorem AEMeasurable.restrict (hfm : AEMeasurable f \u03bc) {s} : AEMeasurable f (\u03bc.restrict s)", "start": [313, 1], "end": [314, 77], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_Ioi_of_forall_Ioc", "code": "theorem aemeasurable_Ioi_of_forall_Ioc {\u03b2} {m\u03b2 : MeasurableSpace \u03b2} [LinearOrder \u03b1]\n    [(atTop : Filter \u03b1).IsCountablyGenerated] {x : \u03b1} {g : \u03b1 \u2192 \u03b2}\n    (g_meas : \u2200 t > x, AEMeasurable g (\u03bc.restrict (Ioc x t))) :\n    AEMeasurable g (\u03bc.restrict (Ioi x))", "start": [317, 1], "end": [331, 36], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_indicator_iff", "code": "theorem aemeasurable_indicator_iff {s} (hs : MeasurableSet s) :\n    AEMeasurable (indicator s f) \u03bc \u2194 AEMeasurable f (\u03bc.restrict s)", "start": [338, 1], "end": [349, 55], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_indicator_iff\u2080", "code": "theorem aemeasurable_indicator_iff\u2080 {s} (hs : NullMeasurableSet s \u03bc) :\n    AEMeasurable (indicator s f) \u03bc \u2194 AEMeasurable f (\u03bc.restrict s)", "start": [352, 1], "end": [356, 30], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_indicator_const_iff", "code": "lemma aemeasurable_indicator_const_iff {s} [MeasurableSingletonClass \u03b2] (b : \u03b2) [NeZero b] :\n    AEMeasurable (s.indicator (fun _ \u21a6 b)) \u03bc \u2194 NullMeasurableSet s \u03bc := by\n  constructor <;> intro h\n  \u00b7 convert h.nullMeasurable (MeasurableSet.singleton (0 : \u03b2)).compl\n    rw [indicator_const_preimage_eq_union s {0}\u1d9c b]\n    simp [NeZero.ne b]\n  \u00b7 exact (aemeasurable_indicator_iff\u2080 h).mpr aemeasurable_const", "start": [358, 1], "end": [366, 65], "kind": "mathlibtacticlemma"}, {"full_name": "AEMeasurable.indicator", "code": "@[measurability]\ntheorem AEMeasurable.indicator (hfm : AEMeasurable f \u03bc) {s} (hs : MeasurableSet s) :\n    AEMeasurable (s.indicator f) \u03bc", "start": [368, 1], "end": [371, 51], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.indicator\u2080", "code": "theorem AEMeasurable.indicator\u2080 (hfm : AEMeasurable f \u03bc) {s} (hs : NullMeasurableSet s \u03bc) :\n    AEMeasurable (s.indicator f) \u03bc", "start": [374, 1], "end": [376, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_map_of_aemeasurable", "code": "theorem MeasureTheory.Measure.restrict_map_of_aemeasurable {f : \u03b1 \u2192 \u03b4} (hf : AEMeasurable f \u03bc)\n    {s : Set \u03b4} (hs : MeasurableSet s) : (\u03bc.map f).restrict s = (\u03bc.restrict <| f \u207b\u00b9' s).map f", "start": [380, 1], "end": [394, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_mono_of_aemeasurable", "code": "theorem MeasureTheory.Measure.map_mono_of_aemeasurable {f : \u03b1 \u2192 \u03b4} (h : \u03bc \u2264 \u03bd)\n    (hf : AEMeasurable f \u03bd) : \u03bc.map f \u2264 \u03bd.map f", "start": [397, 1], "end": [399, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurable.aemeasurable", "code": "lemma MeasureTheory.NullMeasurable.aemeasurable {f : \u03b1 \u2192 \u03b2}\n    [hc : MeasurableSpace.CountablyGenerated \u03b2] (h : NullMeasurable f \u03bc) : AEMeasurable f \u03bc := by\n  nontriviality \u03b2; inhabit \u03b2\n  rcases hc.1 with \u27e8S, hSc, rfl\u27e9\n  choose! T hTf hTm hTeq using fun s hs \u21a6 (h <| .basic s hs).exists_measurable_subset_ae_eq\n  choose! U hUf hUm hUeq using fun s hs \u21a6 (h <| .basic s hs).exists_measurable_superset_ae_eq\n  set v := \u22c3 s \u2208 S, U s \\ T s\n  have hvm : MeasurableSet v := .biUnion hSc fun s hs \u21a6 (hUm s hs).diff (hTm s hs)\n  have hv\u03bc : \u03bc v = 0 := (measure_biUnion_null_iff hSc).2 fun s hs \u21a6 ae_le_set.1 <|\n    ((hUeq s hs).trans (hTeq s hs).symm).le\n  refine \u27e8v.piecewise (fun _ \u21a6 default) f, ?_, measure_mono_null (fun x \u21a6\n    not_imp_comm.2 fun hxv \u21a6 (piecewise_eq_of_not_mem _ _ _ hxv).symm) hv\u03bc\u27e9\n  refine measurable_of_restrict_of_restrict_compl hvm ?_ ?_\n  \u00b7 rw [restrict_piecewise]\n    apply measurable_const\n  \u00b7 rw [restrict_piecewise_compl, restrict_eq]\n    refine measurable_generateFrom fun s hs \u21a6 .of_subtype_image ?_\n    rw [preimage_comp, Subtype.image_preimage_coe]\n    convert (hTm s hs).diff hvm using 1\n    refine Set.ext fun x \u21a6 and_congr_left fun hxv \u21a6 \u27e8fun hx \u21a6 ?_, fun hx \u21a6 hTf s hs hx\u27e9\n    exact by_contra fun hx' \u21a6 hxv <| mem_biUnion hs \u27e8hUf s hs hx, hx'\u27e9", "start": [402, 1], "end": [424, 71], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.NullMeasurable.aemeasurable_of_aerange", "code": "lemma MeasureTheory.NullMeasurable.aemeasurable_of_aerange {f : \u03b1 \u2192 \u03b2} {t : Set \u03b2}\n    [MeasurableSpace.CountablyGenerated t] (h : NullMeasurable f \u03bc) (hft : \u2200\u1d50 x \u2202\u03bc, f x \u2208 t) :\n    AEMeasurable f \u03bc := by\n  rcases eq_empty_or_nonempty t with rfl | hne\n  \u00b7 obtain rfl : \u03bc = 0 := by simpa using hft\n    apply aemeasurable_zero_measure\n  \u00b7 rw [\u2190 \u03bc.ae_completion] at hft\n    obtain \u27e8f', hf'm, hf't, hff'\u27e9 :\n        \u2203 f' : \u03b1 \u2192 \u03b2, NullMeasurable f' \u03bc \u2227 range f' \u2286 t \u2227 f =\u1d50[\u03bc] f' :=\n      h.measurable'.aemeasurable.exists_ae_eq_range_subset hft hne\n    rw [range_subset_iff] at hf't\n    lift f' to \u03b1 \u2192 t using hf't\n    replace hf'm : NullMeasurable f' \u03bc := hf'm.measurable'.subtype_mk\n    exact (measurable_subtype_coe.comp_aemeasurable hf'm.aemeasurable).congr hff'.symm", "start": [426, 1], "end": [443, 87], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Real/EReal.lean", "imports": ["Mathlib/Data/Real/ENNReal.lean", "Mathlib/Data/Real/Basic.lean", "Mathlib/Data/Sign.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EReal", "code": "def EReal := WithBot (WithTop \u211d)\n  deriving Bot, Zero, One, Nontrivial, AddMonoid, PartialOrder", "start": [56, 1], "end": [58, 63], "kind": "commanddeclaration"}, {"full_name": "Real.toEReal", "code": "@[coe] def Real.toEReal : \u211d \u2192 EReal := some \u2218 some", "start": [77, 1], "end": [78, 51], "kind": "commanddeclaration"}, {"full_name": "EReal.decidableLT", "code": "instance decidableLT : DecidableRel ((\u00b7 < \u00b7) : EReal \u2192 EReal \u2192 Prop) :=\n  WithBot.decidableLT", "start": [84, 1], "end": [85, 22], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_strictMono", "code": "theorem coe_strictMono : StrictMono Real.toEReal", "start": [93, 1], "end": [94, 53], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_injective", "code": "theorem coe_injective : Injective Real.toEReal", "start": [97, 1], "end": [98, 27], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_le_coe_iff", "code": "@[simp, norm_cast]\nprotected theorem coe_le_coe_iff {x y : \u211d} : (x : EReal) \u2264 (y : EReal) \u2194 x \u2264 y", "start": [101, 1], "end": [103, 27], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_lt_coe_iff", "code": "@[simp, norm_cast]\nprotected theorem coe_lt_coe_iff {x y : \u211d} : (x : EReal) < (y : EReal) \u2194 x < y", "start": [106, 1], "end": [108, 27], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_eq_coe_iff", "code": "@[simp, norm_cast]\nprotected theorem coe_eq_coe_iff {x y : \u211d} : (x : EReal) = (y : EReal) \u2194 x = y", "start": [111, 1], "end": [113, 23], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ne_coe_iff", "code": "protected theorem coe_ne_coe_iff {x y : \u211d} : (x : EReal) \u2260 (y : EReal) \u2194 x \u2260 y", "start": [116, 1], "end": [117, 23], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toEReal", "code": "@[coe] def _root_.ENNReal.toEReal : \u211d\u22650\u221e \u2192 EReal\n  | \u22a4 => \u22a4\n  | .some x => x.1", "start": [120, 1], "end": [123, 19], "kind": "commanddeclaration"}, {"full_name": "EReal.hasCoeENNReal", "code": "instance hasCoeENNReal : Coe \u211d\u22650\u221e EReal :=\n  \u27e8ENNReal.toEReal\u27e9", "start": [126, 1], "end": [127, 20], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : ((0 : \u211d) : EReal) = 0", "start": [132, 1], "end": [133, 48], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one : ((1 : \u211d) : EReal) = 1", "start": [136, 1], "end": [137, 47], "kind": "commanddeclaration"}, {"full_name": "EReal.rec", "code": "@[elab_as_elim]\nprotected def rec {C : EReal \u2192 Sort*} (h_bot : C \u22a5) (h_real : \u2200 a : \u211d, C a) (h_top : C \u22a4) :\n    \u2200 a : EReal, C a\n  | \u22a5 => h_bot\n  | (a : \u211d) => h_real a\n  | \u22a4 => h_top", "start": [140, 1], "end": [151, 15], "kind": "commanddeclaration"}, {"full_name": "EReal.mul", "code": "protected def mul : EReal \u2192 EReal \u2192 EReal\n  | \u22a5, \u22a5 => \u22a4\n  | \u22a5, \u22a4 => \u22a5\n  | \u22a5, (y : \u211d) => if 0 < y then \u22a5 else if y = 0 then 0 else \u22a4\n  | \u22a4, \u22a5 => \u22a5\n  | \u22a4, \u22a4 => \u22a4\n  | \u22a4, (y : \u211d) => if 0 < y then \u22a4 else if y = 0 then 0 else \u22a5\n  | (x : \u211d), \u22a4 => if 0 < x then \u22a4 else if x = 0 then 0 else \u22a5\n  | (x : \u211d), \u22a5 => if 0 < x then \u22a5 else if x = 0 then 0 else \u22a4\n  | (x : \u211d), (y : \u211d) => (x * y : \u211d)", "start": [154, 1], "end": [165, 36], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (x y : \u211d) : (\u2191(x * y) : EReal) = x * y", "start": [170, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.induction\u2082", "code": "@[elab_as_elim]\ntheorem induction\u2082 {P : EReal \u2192 EReal \u2192 Prop} (top_top : P \u22a4 \u22a4) (top_pos : \u2200 x : \u211d, 0 < x \u2192 P \u22a4 x)\n    (top_zero : P \u22a4 0) (top_neg : \u2200 x : \u211d, x < 0 \u2192 P \u22a4 x) (top_bot : P \u22a4 \u22a5)\n    (pos_top : \u2200 x : \u211d, 0 < x \u2192 P x \u22a4) (pos_bot : \u2200 x : \u211d, 0 < x \u2192 P x \u22a5) (zero_top : P 0 \u22a4)\n    (coe_coe : \u2200 x y : \u211d, P x y) (zero_bot : P 0 \u22a5) (neg_top : \u2200 x : \u211d, x < 0 \u2192 P x \u22a4)\n    (neg_bot : \u2200 x : \u211d, x < 0 \u2192 P x \u22a5) (bot_top : P \u22a5 \u22a4) (bot_pos : \u2200 x : \u211d, 0 < x \u2192 P \u22a5 x)\n    (bot_zero : P \u22a5 0) (bot_neg : \u2200 x : \u211d, x < 0 \u2192 P \u22a5 x) (bot_bot : P \u22a5 \u22a5) : \u2200 x y, P x y", "start": [175, 1], "end": [200, 20], "kind": "commanddeclaration"}, {"full_name": "EReal.induction\u2082_symm", "code": "@[elab_as_elim]\ntheorem induction\u2082_symm {P : EReal \u2192 EReal \u2192 Prop} (symm : Symmetric P) (top_top : P \u22a4 \u22a4)\n    (top_pos : \u2200 x : \u211d, 0 < x \u2192 P \u22a4 x) (top_zero : P \u22a4 0) (top_neg : \u2200 x : \u211d, x < 0 \u2192 P \u22a4 x)\n    (top_bot : P \u22a4 \u22a5) (pos_bot : \u2200 x : \u211d, 0 < x \u2192 P x \u22a5) (coe_coe : \u2200 x y : \u211d, P x y)\n    (zero_bot : P 0 \u22a5) (neg_bot : \u2200 x : \u211d, x < 0 \u2192 P x \u22a5) (bot_bot : P \u22a5 \u22a5) : \u2200 x y, P x y", "start": [203, 1], "end": [212, 94], "kind": "commanddeclaration"}, {"full_name": "EReal.mul_comm", "code": "protected theorem mul_comm (x y : EReal) : x * y = y * x", "start": [221, 1], "end": [224, 38], "kind": "commanddeclaration"}, {"full_name": "EReal.one_mul", "code": "protected theorem one_mul : \u2200 x : EReal, 1 * x = x", "start": [227, 1], "end": [230, 50], "kind": "commanddeclaration"}, {"full_name": "EReal.zero_mul", "code": "protected theorem zero_mul : \u2200 x : EReal, 0 * x = 0", "start": [232, 1], "end": [235, 51], "kind": "commanddeclaration"}, {"full_name": "EReal.canLift", "code": "instance canLift : CanLift EReal \u211d (\u2191) fun r => r \u2260 \u22a4 \u2227 r \u2260 \u22a5 where\n  prf x hx := by\n    induction x using EReal.rec\n    \u00b7 simp at hx\n    \u00b7 simp\n    \u00b7 simp at hx", "start": [245, 1], "end": [250, 17], "kind": "commanddeclaration"}, {"full_name": "EReal.toReal", "code": "def toReal : EReal \u2192 \u211d\n  | \u22a5 => 0\n  | \u22a4 => 0\n  | (x : \u211d) => x", "start": [253, 1], "end": [257, 17], "kind": "commanddeclaration"}, {"full_name": "EReal.toReal_top", "code": "@[simp]\ntheorem toReal_top : toReal \u22a4 = 0", "start": [260, 1], "end": [262, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.toReal_bot", "code": "@[simp]\ntheorem toReal_bot : toReal \u22a5 = 0", "start": [265, 1], "end": [267, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.toReal_zero", "code": "@[simp]\ntheorem toReal_zero : toReal 0 = 0", "start": [270, 1], "end": [272, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.toReal_one", "code": "@[simp]\ntheorem toReal_one : toReal 1 = 1", "start": [275, 1], "end": [277, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.toReal_coe", "code": "@[simp]\ntheorem toReal_coe (x : \u211d) : toReal (x : EReal) = x", "start": [280, 1], "end": [282, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.bot_lt_coe", "code": "@[simp]\ntheorem bot_lt_coe (x : \u211d) : (\u22a5 : EReal) < x", "start": [285, 1], "end": [287, 23], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ne_bot", "code": "@[simp]\ntheorem coe_ne_bot (x : \u211d) : (x : EReal) \u2260 \u22a5", "start": [290, 1], "end": [292, 21], "kind": "commanddeclaration"}, {"full_name": "EReal.bot_ne_coe", "code": "@[simp]\ntheorem bot_ne_coe (x : \u211d) : (\u22a5 : EReal) \u2260 x", "start": [295, 1], "end": [297, 20], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_lt_top", "code": "@[simp]\ntheorem coe_lt_top (x : \u211d) : (x : EReal) < \u22a4", "start": [300, 1], "end": [302, 47], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ne_top", "code": "@[simp]\ntheorem coe_ne_top (x : \u211d) : (x : EReal) \u2260 \u22a4", "start": [305, 1], "end": [307, 20], "kind": "commanddeclaration"}, {"full_name": "EReal.top_ne_coe", "code": "@[simp]\ntheorem top_ne_coe (x : \u211d) : (\u22a4 : EReal) \u2260 x", "start": [310, 1], "end": [312, 21], "kind": "commanddeclaration"}, {"full_name": "EReal.bot_lt_zero", "code": "@[simp]\ntheorem bot_lt_zero : (\u22a5 : EReal) < 0", "start": [315, 1], "end": [317, 15], "kind": "commanddeclaration"}, {"full_name": "EReal.bot_ne_zero", "code": "@[simp]\ntheorem bot_ne_zero : (\u22a5 : EReal) \u2260 0", "start": [320, 1], "end": [322, 22], "kind": "commanddeclaration"}, {"full_name": "EReal.zero_ne_bot", "code": "@[simp]\ntheorem zero_ne_bot : (0 : EReal) \u2260 \u22a5", "start": [325, 1], "end": [327, 15], "kind": "commanddeclaration"}, {"full_name": "EReal.zero_lt_top", "code": "@[simp]\ntheorem zero_lt_top : (0 : EReal) < \u22a4", "start": [330, 1], "end": [332, 15], "kind": "commanddeclaration"}, {"full_name": "EReal.zero_ne_top", "code": "@[simp]\ntheorem zero_ne_top : (0 : EReal) \u2260 \u22a4", "start": [335, 1], "end": [337, 15], "kind": "commanddeclaration"}, {"full_name": "EReal.top_ne_zero", "code": "@[simp]\ntheorem top_ne_zero : (\u22a4 : EReal) \u2260 0", "start": [340, 1], "end": [342, 22], "kind": "commanddeclaration"}, {"full_name": "EReal.range_coe", "code": "theorem range_coe : range Real.toEReal = {\u22a5, \u22a4}\u1d9c", "start": [345, 1], "end": [347, 39], "kind": "commanddeclaration"}, {"full_name": "EReal.range_coe_eq_Ioo", "code": "theorem range_coe_eq_Ioo : range Real.toEReal = Ioo \u22a5 \u22a4", "start": [349, 1], "end": [351, 39], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add (x y : \u211d) : (\u2191(x + y) : EReal) = x + y", "start": [353, 1], "end": [355, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_nsmul", "code": "@[norm_cast]\ntheorem coe_nsmul (n : \u2115) (x : \u211d) : (\u2191(n \u2022 x) : EReal) = n \u2022 (x : EReal)", "start": [360, 1], "end": [362, 67], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_eq_zero", "code": "@[simp, norm_cast]\ntheorem coe_eq_zero {x : \u211d} : (x : EReal) = 0 \u2194 x = 0", "start": [368, 1], "end": [370, 23], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_eq_one", "code": "@[simp, norm_cast]\ntheorem coe_eq_one {x : \u211d} : (x : EReal) = 1 \u2194 x = 1", "start": [373, 1], "end": [375, 23], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ne_zero", "code": "theorem coe_ne_zero {x : \u211d} : (x : EReal) \u2260 0 \u2194 x \u2260 0", "start": [378, 1], "end": [379, 23], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ne_one", "code": "theorem coe_ne_one {x : \u211d} : (x : EReal) \u2260 1 \u2194 x \u2260 1", "start": [382, 1], "end": [383, 23], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_nonneg", "code": "@[simp, norm_cast]\nprotected theorem coe_nonneg {x : \u211d} : (0 : EReal) \u2264 x \u2194 0 \u2264 x", "start": [386, 1], "end": [388, 23], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_nonpos", "code": "@[simp, norm_cast]\nprotected theorem coe_nonpos {x : \u211d} : (x : EReal) \u2264 0 \u2194 x \u2264 0", "start": [391, 1], "end": [393, 23], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_pos", "code": "@[simp, norm_cast]\nprotected theorem coe_pos {x : \u211d} : (0 : EReal) < x \u2194 0 < x", "start": [396, 1], "end": [398, 23], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_neg'", "code": "@[simp, norm_cast]\nprotected theorem coe_neg' {x : \u211d} : (x : EReal) < 0 \u2194 x < 0", "start": [401, 1], "end": [403, 23], "kind": "commanddeclaration"}, {"full_name": "EReal.toReal_le_toReal", "code": "theorem toReal_le_toReal {x y : EReal} (h : x \u2264 y) (hx : x \u2260 \u22a5) (hy : y \u2260 \u22a4) :\n    x.toReal \u2264 y.toReal", "start": [406, 1], "end": [410, 16], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_toReal", "code": "theorem coe_toReal {x : EReal} (hx : x \u2260 \u22a4) (h'x : x \u2260 \u22a5) : (x.toReal : EReal) = x", "start": [413, 1], "end": [415, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.le_coe_toReal", "code": "theorem le_coe_toReal {x : EReal} (h : x \u2260 \u22a4) : x \u2264 x.toReal", "start": [418, 1], "end": [421, 41], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_toReal_le", "code": "theorem coe_toReal_le {x : EReal} (h : x \u2260 \u22a5) : \u2191x.toReal \u2264 x", "start": [424, 1], "end": [427, 41], "kind": "commanddeclaration"}, {"full_name": "EReal.eq_top_iff_forall_lt", "code": "theorem eq_top_iff_forall_lt (x : EReal) : x = \u22a4 \u2194 \u2200 y : \u211d, (y : EReal) < x", "start": [430, 1], "end": [436, 38], "kind": "commanddeclaration"}, {"full_name": "EReal.eq_bot_iff_forall_lt", "code": "theorem eq_bot_iff_forall_lt (x : EReal) : x = \u22a5 \u2194 \u2200 y : \u211d, x < (y : EReal)", "start": [439, 1], "end": [445, 38], "kind": "commanddeclaration"}, {"full_name": "EReal.toReal_coe_ennreal", "code": "@[simp]\ntheorem toReal_coe_ennreal : \u2200 {x : \u211d\u22650\u221e}, toReal (x : EReal) = ENNReal.toReal x", "start": [450, 1], "end": [453, 19], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_ofReal", "code": "@[simp]\ntheorem coe_ennreal_ofReal {x : \u211d} : (ENNReal.ofReal x : EReal) = max x 0", "start": [456, 1], "end": [458, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_nnreal_eq_coe_real", "code": "theorem coe_nnreal_eq_coe_real (x : \u211d\u22650) : ((x : \u211d\u22650\u221e) : EReal) = (x : \u211d)", "start": [461, 1], "end": [462, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_zero", "code": "@[simp, norm_cast]\ntheorem coe_ennreal_zero : ((0 : \u211d\u22650\u221e) : EReal) = 0", "start": [465, 1], "end": [467, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_one", "code": "@[simp, norm_cast]\ntheorem coe_ennreal_one : ((1 : \u211d\u22650\u221e) : EReal) = 1", "start": [470, 1], "end": [472, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_top", "code": "@[simp, norm_cast]\ntheorem coe_ennreal_top : ((\u22a4 : \u211d\u22650\u221e) : EReal) = \u22a4", "start": [475, 1], "end": [477, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_strictMono", "code": "theorem coe_ennreal_strictMono : StrictMono ((\u2191) : \u211d\u22650\u221e \u2192 EReal)", "start": [480, 1], "end": [481, 86], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_injective", "code": "theorem coe_ennreal_injective : Injective ((\u2191) : \u211d\u22650\u221e \u2192 EReal)", "start": [484, 1], "end": [485, 35], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_eq_top_iff", "code": "@[simp]\ntheorem coe_ennreal_eq_top_iff {x : \u211d\u22650\u221e} : (x : EReal) = \u22a4 \u2194 x = \u22a4", "start": [488, 1], "end": [490, 36], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_nnreal_ne_top", "code": "theorem coe_nnreal_ne_top (x : \u211d\u22650) : ((x : \u211d\u22650\u221e) : EReal) \u2260 \u22a4", "start": [493, 1], "end": [493, 79], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_nnreal_lt_top", "code": "@[simp]\ntheorem coe_nnreal_lt_top (x : \u211d\u22650) : ((x : \u211d\u22650\u221e) : EReal) < \u22a4", "start": [496, 1], "end": [497, 79], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_le_coe_ennreal_iff", "code": "@[simp, norm_cast]\ntheorem coe_ennreal_le_coe_ennreal_iff {x y : \u211d\u22650\u221e} : (x : EReal) \u2264 (y : EReal) \u2194 x \u2264 y", "start": [500, 1], "end": [502, 35], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_lt_coe_ennreal_iff", "code": "@[simp, norm_cast]\ntheorem coe_ennreal_lt_coe_ennreal_iff {x y : \u211d\u22650\u221e} : (x : EReal) < (y : EReal) \u2194 x < y", "start": [505, 1], "end": [507, 35], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_eq_coe_ennreal_iff", "code": "@[simp, norm_cast]\ntheorem coe_ennreal_eq_coe_ennreal_iff {x y : \u211d\u22650\u221e} : (x : EReal) = (y : EReal) \u2194 x = y", "start": [510, 1], "end": [512, 31], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_ne_coe_ennreal_iff", "code": "theorem coe_ennreal_ne_coe_ennreal_iff {x y : \u211d\u22650\u221e} : (x : EReal) \u2260 (y : EReal) \u2194 x \u2260 y", "start": [515, 1], "end": [516, 31], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_eq_zero", "code": "@[simp, norm_cast]\ntheorem coe_ennreal_eq_zero {x : \u211d\u22650\u221e} : (x : EReal) = 0 \u2194 x = 0", "start": [519, 1], "end": [521, 58], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_eq_one", "code": "@[simp, norm_cast]\ntheorem coe_ennreal_eq_one {x : \u211d\u22650\u221e} : (x : EReal) = 1 \u2194 x = 1", "start": [524, 1], "end": [526, 57], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_ne_zero", "code": "@[norm_cast]\ntheorem coe_ennreal_ne_zero {x : \u211d\u22650\u221e} : (x : EReal) \u2260 0 \u2194 x \u2260 0", "start": [529, 1], "end": [531, 26], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_ne_one", "code": "@[norm_cast]\ntheorem coe_ennreal_ne_one {x : \u211d\u22650\u221e} : (x : EReal) \u2260 1 \u2194 x \u2260 1", "start": [534, 1], "end": [536, 25], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_nonneg", "code": "theorem coe_ennreal_nonneg (x : \u211d\u22650\u221e) : (0 : EReal) \u2264 x", "start": [539, 1], "end": [540, 47], "kind": "commanddeclaration"}, {"full_name": "EReal.range_coe_ennreal", "code": "@[simp] theorem range_coe_ennreal : range ((\u2191) : \u211d\u22650\u221e \u2192 EReal) = Set.Ici 0", "start": [543, 1], "end": [547, 65], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_pos", "code": "@[simp, norm_cast]\ntheorem coe_ennreal_pos {x : \u211d\u22650\u221e} : (0 : EReal) < x \u2194 0 < x", "start": [551, 1], "end": [553, 58], "kind": "commanddeclaration"}, {"full_name": "EReal.bot_lt_coe_ennreal", "code": "@[simp]\ntheorem bot_lt_coe_ennreal (x : \u211d\u22650\u221e) : (\u22a5 : EReal) < x", "start": [556, 1], "end": [558, 49], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_ne_bot", "code": "@[simp]\ntheorem coe_ennreal_ne_bot (x : \u211d\u22650\u221e) : (x : EReal) \u2260 \u22a5", "start": [561, 1], "end": [563, 29], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_add", "code": "@[simp, norm_cast]\ntheorem coe_ennreal_add (x y : ENNReal) : ((x + y : \u211d\u22650\u221e) : EReal) = x + y", "start": [566, 1], "end": [568, 30], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_top_mul", "code": "private theorem coe_ennreal_top_mul (x : \u211d\u22650) : ((\u22a4 * x : \u211d\u22650\u221e) : EReal) = \u22a4 * x", "start": [571, 1], "end": [575, 58], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_mul", "code": "@[simp, norm_cast]\ntheorem coe_ennreal_mul : \u2200 x y : \u211d\u22650\u221e, ((x * y : \u211d\u22650\u221e) : EReal) = (x : EReal) * y", "start": [577, 1], "end": [584, 89], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_nsmul", "code": "@[norm_cast]\ntheorem coe_ennreal_nsmul (n : \u2115) (x : \u211d\u22650\u221e) : (\u2191(n \u2022 x) : EReal) = n \u2022 (x : EReal)", "start": [587, 1], "end": [589, 77], "kind": "commanddeclaration"}, {"full_name": "EReal.exists_rat_btwn_of_lt", "code": "theorem exists_rat_btwn_of_lt :\n    \u2200 {a b : EReal}, a < b \u2192 \u2203 x : \u211a, a < (x : \u211d) \u2227 ((x : \u211d) : EReal) < b", "start": [597, 1], "end": [609, 47], "kind": "commanddeclaration"}, {"full_name": "EReal.lt_iff_exists_rat_btwn", "code": "theorem lt_iff_exists_rat_btwn {a b : EReal} :\n    a < b \u2194 \u2203 x : \u211a, a < (x : \u211d) \u2227 ((x : \u211d) : EReal) < b", "start": [612, 1], "end": [614, 74], "kind": "commanddeclaration"}, {"full_name": "EReal.lt_iff_exists_real_btwn", "code": "theorem lt_iff_exists_real_btwn {a b : EReal} : a < b \u2194 \u2203 x : \u211d, a < x \u2227 (x : EReal) < b", "start": [617, 1], "end": [621, 37], "kind": "commanddeclaration"}, {"full_name": "EReal.neTopBotEquivReal", "code": "def neTopBotEquivReal : ({\u22a5, \u22a4}\u1d9c : Set EReal) \u2243 \u211d where\n  toFun x := EReal.toReal x\n  invFun x := \u27e8x, by simp\u27e9\n  left_inv := fun \u27e8x, hx\u27e9 => by\n    lift x to \u211d\n    \u00b7 simpa [not_or, and_comm] using hx\n    \u00b7 simp\n  right_inv x := by simp", "start": [624, 1], "end": [632, 25], "kind": "commanddeclaration"}, {"full_name": "EReal.add_bot", "code": "@[simp]\ntheorem add_bot (x : EReal) : x + \u22a5 = \u22a5", "start": [637, 1], "end": [639, 20], "kind": "commanddeclaration"}, {"full_name": "EReal.bot_add", "code": "@[simp]\ntheorem bot_add (x : EReal) : \u22a5 + x = \u22a5", "start": [642, 1], "end": [644, 20], "kind": "commanddeclaration"}, {"full_name": "EReal.add_eq_bot_iff", "code": "@[simp]\ntheorem add_eq_bot_iff {x y : EReal} : x + y = \u22a5 \u2194 x = \u22a5 \u2228 y = \u22a5", "start": [647, 1], "end": [649, 21], "kind": "commanddeclaration"}, {"full_name": "EReal.bot_lt_add_iff", "code": "@[simp]\ntheorem bot_lt_add_iff {x y : EReal} : \u22a5 < x + y \u2194 \u22a5 < x \u2227 \u22a5 < y", "start": [652, 1], "end": [654, 35], "kind": "commanddeclaration"}, {"full_name": "EReal.top_add_top", "code": "@[simp]\ntheorem top_add_top : (\u22a4 : EReal) + \u22a4 = \u22a4", "start": [657, 1], "end": [659, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.top_add_coe", "code": "@[simp]\ntheorem top_add_coe (x : \u211d) : (\u22a4 : EReal) + x = \u22a4", "start": [662, 1], "end": [664, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_add_top", "code": "@[simp]\ntheorem coe_add_top (x : \u211d) : (x : EReal) + \u22a4 = \u22a4", "start": [667, 1], "end": [669, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.toReal_add", "code": "theorem toReal_add {x y : EReal} (hx : x \u2260 \u22a4) (h'x : x \u2260 \u22a5) (hy : y \u2260 \u22a4) (h'y : y \u2260 \u22a5) :\n    toReal (x + y) = toReal x + toReal y", "start": [672, 1], "end": [676, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.addLECancellable_coe", "code": "theorem addLECancellable_coe (x : \u211d) : AddLECancellable (x : EReal)", "start": [679, 1], "end": [685, 78], "kind": "commanddeclaration"}, {"full_name": "EReal.add_lt_add_right_coe", "code": "theorem add_lt_add_right_coe {x y : EReal} (h : x < y) (z : \u211d) : x + z < y + z", "start": [688, 1], "end": [689, 74], "kind": "commanddeclaration"}, {"full_name": "EReal.add_lt_add_left_coe", "code": "theorem add_lt_add_left_coe {x y : EReal} (h : x < y) (z : \u211d) : (z : EReal) + x < z + y", "start": [692, 1], "end": [693, 50], "kind": "commanddeclaration"}, {"full_name": "EReal.add_lt_add", "code": "theorem add_lt_add {x y z t : EReal} (h1 : x < y) (h2 : z < t) : x + z < y + t", "start": [696, 1], "end": [701, 42], "kind": "commanddeclaration"}, {"full_name": "EReal.add_lt_add_of_lt_of_le'", "code": "theorem add_lt_add_of_lt_of_le' {x y z t : EReal} (h : x < y) (h' : z \u2264 t) (hbot : t \u2260 \u22a5)\n    (htop : t = \u22a4 \u2192 z = \u22a4 \u2192 x = \u22a5) : x + z < y + t", "start": [704, 1], "end": [712, 27], "kind": "commanddeclaration"}, {"full_name": "EReal.add_lt_add_of_lt_of_le", "code": "theorem add_lt_add_of_lt_of_le {x y z t : EReal} (h : x < y) (h' : z \u2264 t) (hz : z \u2260 \u22a5)\n    (ht : t \u2260 \u22a4) : x + z < y + t", "start": [714, 1], "end": [718, 87], "kind": "commanddeclaration"}, {"full_name": "EReal.add_lt_top", "code": "theorem add_lt_top {x y : EReal} (hx : x \u2260 \u22a4) (hy : y \u2260 \u22a4) : x + y < \u22a4", "start": [721, 1], "end": [723, 45], "kind": "commanddeclaration"}, {"full_name": "EReal.neg", "code": "protected def neg : EReal \u2192 EReal\n  | \u22a5 => \u22a4\n  | \u22a4 => \u22a5\n  | (x : \u211d) => (-x : \u211d)", "start": [737, 1], "end": [741, 24], "kind": "commanddeclaration"}, {"full_name": "EReal.neg_top", "code": "@[simp]\ntheorem neg_top : -(\u22a4 : EReal) = \u22a5", "start": [749, 1], "end": [751, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.neg_bot", "code": "@[simp]\ntheorem neg_bot : -(\u22a5 : EReal) = \u22a4", "start": [754, 1], "end": [756, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_neg", "code": "@[simp, norm_cast] theorem coe_neg (x : \u211d) : (\u2191(-x) : EReal) = -\u2191x", "start": [759, 1], "end": [759, 74], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_sub", "code": "@[simp, norm_cast] theorem coe_sub (x y : \u211d) : (\u2191(x - y) : EReal) = x - y", "start": [763, 1], "end": [763, 81], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_zsmul", "code": "@[norm_cast]\ntheorem coe_zsmul (n : \u2124) (x : \u211d) : (\u2191(n \u2022 x) : EReal) = n \u2022 (x : EReal)", "start": [766, 1], "end": [768, 67], "kind": "commanddeclaration"}, {"full_name": "EReal.toReal_neg", "code": "@[simp]\ntheorem toReal_neg : \u2200 {a : EReal}, toReal (-a) = -toReal a", "start": [778, 1], "end": [782, 19], "kind": "commanddeclaration"}, {"full_name": "EReal.neg_eq_top_iff", "code": "@[simp]\ntheorem neg_eq_top_iff {x : EReal} : -x = \u22a4 \u2194 x = \u22a5", "start": [785, 1], "end": [787, 28], "kind": "commanddeclaration"}, {"full_name": "EReal.neg_eq_bot_iff", "code": "@[simp]\ntheorem neg_eq_bot_iff {x : EReal} : -x = \u22a5 \u2194 x = \u22a4", "start": [790, 1], "end": [792, 28], "kind": "commanddeclaration"}, {"full_name": "EReal.neg_eq_zero_iff", "code": "@[simp]\ntheorem neg_eq_zero_iff {x : EReal} : -x = 0 \u2194 x = 0", "start": [795, 1], "end": [797, 33], "kind": "commanddeclaration"}, {"full_name": "EReal.neg_strictAnti", "code": "theorem neg_strictAnti : StrictAnti (- \u00b7 : EReal \u2192 EReal)", "start": [800, 1], "end": [803, 60], "kind": "commanddeclaration"}, {"full_name": "EReal.neg_le_neg_iff", "code": "@[simp] theorem neg_le_neg_iff {a b : EReal} : -a \u2264 -b \u2194 b \u2264 a", "start": [805, 1], "end": [805, 91], "kind": "commanddeclaration"}, {"full_name": "EReal.neg_lt_neg_iff", "code": "@[simp] theorem neg_lt_neg_iff {a b : EReal} : -a < -b \u2194 b < a", "start": [809, 1], "end": [809, 91], "kind": "commanddeclaration"}, {"full_name": "EReal.neg_le", "code": "protected theorem neg_le {a b : EReal} : -a \u2264 b \u2194 -b \u2264 a", "start": [811, 1], "end": [813, 32], "kind": "commanddeclaration"}, {"full_name": "EReal.neg_le_of_neg_le", "code": "protected theorem neg_le_of_neg_le {a b : EReal} (h : -a \u2264 b) : -b \u2264 a", "start": [816, 1], "end": [817, 92], "kind": "commanddeclaration"}, {"full_name": "EReal.le_neg_of_le_neg", "code": "theorem le_neg_of_le_neg {a b : EReal} (h : a \u2264 -b) : b \u2264 -a", "start": [820, 1], "end": [822, 43], "kind": "commanddeclaration"}, {"full_name": "EReal.negOrderIso", "code": "def negOrderIso : EReal \u2243o EReal\u1d52\u1d48 :=\n  { Equiv.neg EReal with\n    toFun := fun x => OrderDual.toDual (-x)\n    invFun := fun x => -OrderDual.ofDual x\n    map_rel_iff' := neg_le_neg_iff }", "start": [825, 1], "end": [830, 37], "kind": "commanddeclaration"}, {"full_name": "EReal.neg_lt_iff_neg_lt", "code": "theorem neg_lt_iff_neg_lt {a b : EReal} : -a < b \u2194 -b < a", "start": [833, 1], "end": [834, 33], "kind": "commanddeclaration"}, {"full_name": "EReal.neg_lt_of_neg_lt", "code": "theorem neg_lt_of_neg_lt {a b : EReal} (h : -a < b) : -b < a", "start": [837, 1], "end": [837, 86], "kind": "commanddeclaration"}, {"full_name": "EReal.bot_sub", "code": "@[simp]\ntheorem bot_sub (x : EReal) : \u22a5 - x = \u22a5", "start": [848, 1], "end": [850, 12], "kind": "commanddeclaration"}, {"full_name": "EReal.sub_top", "code": "@[simp]\ntheorem sub_top (x : EReal) : x - \u22a4 = \u22a5", "start": [853, 1], "end": [855, 12], "kind": "commanddeclaration"}, {"full_name": "EReal.top_sub_bot", "code": "@[simp]\ntheorem top_sub_bot : (\u22a4 : EReal) - \u22a5 = \u22a4", "start": [858, 1], "end": [860, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.top_sub_coe", "code": "@[simp]\ntheorem top_sub_coe (x : \u211d) : (\u22a4 : EReal) - x = \u22a4", "start": [863, 1], "end": [865, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_sub_bot", "code": "@[simp]\ntheorem coe_sub_bot (x : \u211d) : (x : EReal) - \u22a5 = \u22a4", "start": [868, 1], "end": [870, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.sub_le_sub", "code": "theorem sub_le_sub {x y z t : EReal} (h : x \u2264 y) (h' : t \u2264 z) : x - z \u2264 y - t", "start": [873, 1], "end": [874, 37], "kind": "commanddeclaration"}, {"full_name": "EReal.sub_lt_sub_of_lt_of_le", "code": "theorem sub_lt_sub_of_lt_of_le {x y z t : EReal} (h : x < y) (h' : z \u2264 t) (hz : z \u2260 \u22a5)\n    (ht : t \u2260 \u22a4) : x - t < y - z", "start": [877, 1], "end": [879, 79], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal", "code": "theorem coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal (x : \u211d) :\n    (x : EReal) = Real.toNNReal x - Real.toNNReal (-x)", "start": [882, 1], "end": [891, 25], "kind": "commanddeclaration"}, {"full_name": "EReal.toReal_sub", "code": "theorem toReal_sub {x y : EReal} (hx : x \u2260 \u22a4) (h'x : x \u2260 \u22a5) (hy : y \u2260 \u22a4) (h'y : y \u2260 \u22a5) :\n    toReal (x - y) = toReal x - toReal y", "start": [894, 1], "end": [898, 6], "kind": "commanddeclaration"}, {"full_name": "EReal.top_mul_top", "code": "@[simp] theorem top_mul_top : (\u22a4 : EReal) * \u22a4 = \u22a4", "start": [903, 1], "end": [903, 57], "kind": "commanddeclaration"}, {"full_name": "EReal.top_mul_bot", "code": "@[simp] theorem top_mul_bot : (\u22a4 : EReal) * \u22a5 = \u22a5", "start": [906, 1], "end": [906, 57], "kind": "commanddeclaration"}, {"full_name": "EReal.bot_mul_top", "code": "@[simp] theorem bot_mul_top : (\u22a5 : EReal) * \u22a4 = \u22a5", "start": [909, 1], "end": [909, 57], "kind": "commanddeclaration"}, {"full_name": "EReal.bot_mul_bot", "code": "@[simp] theorem bot_mul_bot : (\u22a5 : EReal) * \u22a5 = \u22a4", "start": [912, 1], "end": [912, 57], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_mul_top_of_pos", "code": "theorem coe_mul_top_of_pos {x : \u211d} (h : 0 < x) : (x : EReal) * \u22a4 = \u22a4", "start": [915, 1], "end": [916, 11], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_mul_top_of_neg", "code": "theorem coe_mul_top_of_neg {x : \u211d} (h : x < 0) : (x : EReal) * \u22a4 = \u22a5", "start": [919, 1], "end": [920, 40], "kind": "commanddeclaration"}, {"full_name": "EReal.top_mul_coe_of_pos", "code": "theorem top_mul_coe_of_pos {x : \u211d} (h : 0 < x) : (\u22a4 : EReal) * x = \u22a4", "start": [923, 1], "end": [924, 11], "kind": "commanddeclaration"}, {"full_name": "EReal.top_mul_coe_of_neg", "code": "theorem top_mul_coe_of_neg {x : \u211d} (h : x < 0) : (\u22a4 : EReal) * x = \u22a5", "start": [927, 1], "end": [928, 40], "kind": "commanddeclaration"}, {"full_name": "EReal.mul_top_of_pos", "code": "theorem mul_top_of_pos : \u2200 {x : EReal}, 0 < x \u2192 x * \u22a4 = \u22a4", "start": [931, 1], "end": [934, 16], "kind": "commanddeclaration"}, {"full_name": "EReal.mul_top_of_neg", "code": "theorem mul_top_of_neg : \u2200 {x : EReal}, x < 0 \u2192 x * \u22a4 = \u22a5", "start": [937, 1], "end": [940, 32], "kind": "commanddeclaration"}, {"full_name": "EReal.top_mul_of_pos", "code": "theorem top_mul_of_pos {x : EReal} (h : 0 < x) : \u22a4 * x = \u22a4", "start": [943, 1], "end": [945, 25], "kind": "commanddeclaration"}, {"full_name": "EReal.top_mul_of_neg", "code": "theorem top_mul_of_neg {x : EReal} (h : x < 0) : \u22a4 * x = \u22a5", "start": [948, 1], "end": [950, 25], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_mul_bot_of_pos", "code": "theorem coe_mul_bot_of_pos {x : \u211d} (h : 0 < x) : (x : EReal) * \u22a5 = \u22a5", "start": [953, 1], "end": [954, 11], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_mul_bot_of_neg", "code": "theorem coe_mul_bot_of_neg {x : \u211d} (h : x < 0) : (x : EReal) * \u22a5 = \u22a4", "start": [957, 1], "end": [958, 40], "kind": "commanddeclaration"}, {"full_name": "EReal.bot_mul_coe_of_pos", "code": "theorem bot_mul_coe_of_pos {x : \u211d} (h : 0 < x) : (\u22a5 : EReal) * x = \u22a5", "start": [961, 1], "end": [962, 11], "kind": "commanddeclaration"}, {"full_name": "EReal.bot_mul_coe_of_neg", "code": "theorem bot_mul_coe_of_neg {x : \u211d} (h : x < 0) : (\u22a5 : EReal) * x = \u22a4", "start": [965, 1], "end": [966, 40], "kind": "commanddeclaration"}, {"full_name": "EReal.mul_bot_of_pos", "code": "theorem mul_bot_of_pos : \u2200 {x : EReal}, 0 < x \u2192 x * \u22a5 = \u22a5", "start": [969, 1], "end": [972, 16], "kind": "commanddeclaration"}, {"full_name": "EReal.mul_bot_of_neg", "code": "theorem mul_bot_of_neg : \u2200 {x : EReal}, x < 0 \u2192 x * \u22a5 = \u22a4", "start": [975, 1], "end": [978, 32], "kind": "commanddeclaration"}, {"full_name": "EReal.bot_mul_of_pos", "code": "theorem bot_mul_of_pos {x : EReal} (h : 0 < x) : \u22a5 * x = \u22a5", "start": [981, 1], "end": [983, 25], "kind": "commanddeclaration"}, {"full_name": "EReal.bot_mul_of_neg", "code": "theorem bot_mul_of_neg {x : EReal} (h : x < 0) : \u22a5 * x = \u22a4", "start": [986, 1], "end": [988, 25], "kind": "commanddeclaration"}, {"full_name": "EReal.toReal_mul", "code": "theorem toReal_mul {x y : EReal} : toReal (x * y) = toReal x * toReal y", "start": [991, 1], "end": [999, 47], "kind": "commanddeclaration"}, {"full_name": "EReal.induction\u2082_neg_left", "code": "@[elab_as_elim]\ntheorem induction\u2082_neg_left {P : EReal \u2192 EReal \u2192 Prop} (neg_left : \u2200 {x y}, P x y \u2192 P (-x) y)\n    (top_top : P \u22a4 \u22a4) (top_pos : \u2200 x : \u211d, 0 < x \u2192 P \u22a4 x)\n    (top_zero : P \u22a4 0) (top_neg : \u2200 x : \u211d, x < 0 \u2192 P \u22a4 x) (top_bot : P \u22a4 \u22a5)\n    (zero_top : P 0 \u22a4) (zero_bot : P 0 \u22a5)\n    (pos_top : \u2200 x : \u211d, 0 < x \u2192 P x \u22a4) (pos_bot : \u2200 x : \u211d, 0 < x \u2192 P x \u22a5)\n    (coe_coe : \u2200 x y : \u211d, P x y) : \u2200 x y, P x y", "start": [1002, 1], "end": [1017, 62], "kind": "commanddeclaration"}, {"full_name": "EReal.induction\u2082_symm_neg", "code": "@[elab_as_elim]\ntheorem induction\u2082_symm_neg {P : EReal \u2192 EReal \u2192 Prop}\n    (symm : Symmetric P) (neg_left : \u2200 {x y}, P x y \u2192 P (-x) y) (top_top : P \u22a4 \u22a4)\n    (top_pos : \u2200 x : \u211d, 0 < x \u2192 P \u22a4 x) (top_zero : P \u22a4 0) (coe_coe : \u2200 x y : \u211d, P x y) :\n    \u2200 x y, P x y", "start": [1019, 1], "end": [1032, 59], "kind": "commanddeclaration"}, {"full_name": "EReal.neg_mul", "code": "protected theorem neg_mul (x y : EReal) : -x * y = -(x * y)", "start": [1034, 1], "end": [1045, 43], "kind": "commanddeclaration"}, {"full_name": "EReal.abs", "code": "protected def abs : EReal \u2192 \u211d\u22650\u221e\n  | \u22a5 => \u22a4\n  | \u22a4 => \u22a4\n  | (x : \u211d) => ENNReal.ofReal |x|", "start": [1057, 1], "end": [1062, 34], "kind": "commanddeclaration"}, {"full_name": "EReal.abs_top", "code": "@[simp] theorem abs_top : (\u22a4 : EReal).abs = \u22a4", "start": [1065, 1], "end": [1065, 53], "kind": "commanddeclaration"}, {"full_name": "EReal.abs_bot", "code": "@[simp] theorem abs_bot : (\u22a5 : EReal).abs = \u22a4", "start": [1068, 1], "end": [1068, 53], "kind": "commanddeclaration"}, {"full_name": "EReal.abs_def", "code": "theorem abs_def (x : \u211d) : (x : EReal).abs = ENNReal.ofReal |x|", "start": [1071, 1], "end": [1071, 70], "kind": "commanddeclaration"}, {"full_name": "EReal.abs_coe_lt_top", "code": "theorem abs_coe_lt_top (x : \u211d) : (x : EReal).abs < \u22a4", "start": [1074, 1], "end": [1075, 24], "kind": "commanddeclaration"}, {"full_name": "EReal.abs_eq_zero_iff", "code": "@[simp]\ntheorem abs_eq_zero_iff {x : EReal} : x.abs = 0 \u2194 x = 0", "start": [1078, 1], "end": [1083, 58], "kind": "commanddeclaration"}, {"full_name": "EReal.abs_zero", "code": "@[simp]\ntheorem abs_zero : (0 : EReal).abs = 0", "start": [1086, 1], "end": [1087, 66], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_abs", "code": "@[simp]\ntheorem coe_abs (x : \u211d) : ((x : EReal).abs : EReal) = (|x| : \u211d)", "start": [1090, 1], "end": [1092, 65], "kind": "commanddeclaration"}, {"full_name": "EReal.abs_neg", "code": "@[simp]\nprotected theorem abs_neg : \u2200 x : EReal, (-x).abs = x.abs", "start": [1095, 1], "end": [1099, 60], "kind": "commanddeclaration"}, {"full_name": "EReal.abs_mul", "code": "@[simp]\ntheorem abs_mul (x y : EReal) : (x * y).abs = x.abs * y.abs", "start": [1101, 1], "end": [1112, 62], "kind": "commanddeclaration"}, {"full_name": "EReal.sign_top", "code": "theorem sign_top : sign (\u22a4 : EReal) = 1", "start": [1119, 1], "end": [1119, 47], "kind": "commanddeclaration"}, {"full_name": "EReal.sign_bot", "code": "theorem sign_bot : sign (\u22a5 : EReal) = -1", "start": [1122, 1], "end": [1122, 48], "kind": "commanddeclaration"}, {"full_name": "EReal.sign_coe", "code": "@[simp]\ntheorem sign_coe (x : \u211d) : sign (x : EReal) = sign x", "start": [1125, 1], "end": [1127, 67], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_coe_sign", "code": "@[simp, norm_cast]\ntheorem coe_coe_sign (x : SignType) : ((x : \u211d) : EReal) = x", "start": [1130, 1], "end": [1131, 82], "kind": "commanddeclaration"}, {"full_name": "EReal.sign_neg", "code": "@[simp] theorem sign_neg : \u2200 x : EReal, sign (-x) = -sign x", "start": [1133, 1], "end": [1136, 68], "kind": "commanddeclaration"}, {"full_name": "EReal.sign_mul", "code": "@[simp]\ntheorem sign_mul (x y : EReal) : sign (x * y) = sign x * sign y", "start": [1138, 1], "end": [1147, 63], "kind": "commanddeclaration"}, {"full_name": "EReal.sign_mul_abs", "code": "@[simp] protected theorem sign_mul_abs : \u2200 x : EReal, (sign x * x.abs : EReal) = x", "start": [1150, 1], "end": [1153, 82], "kind": "commanddeclaration"}, {"full_name": "EReal.abs_mul_sign", "code": "@[simp] protected theorem abs_mul_sign (x : EReal) : (x.abs * sign x : EReal) = x", "start": [1156, 1], "end": [1157, 42], "kind": "commanddeclaration"}, {"full_name": "EReal.sign_eq_and_abs_eq_iff_eq", "code": "theorem sign_eq_and_abs_eq_iff_eq {x y : EReal} :\n    x.abs = y.abs \u2227 sign x = sign y \u2194 x = y", "start": [1159, 1], "end": [1165, 21], "kind": "commanddeclaration"}, {"full_name": "EReal.le_iff_sign", "code": "theorem le_iff_sign {x y : EReal} :\n    x \u2264 y \u2194 sign x < sign y \u2228\n      sign x = SignType.neg \u2227 sign y = SignType.neg \u2227 y.abs \u2264 x.abs \u2228\n        sign x = SignType.zero \u2227 sign y = SignType.zero \u2228\n          sign x = SignType.pos \u2227 sign y = SignType.pos \u2227 x.abs \u2264 y.abs", "start": [1168, 1], "end": [1183, 64], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_pow", "code": "@[simp, norm_cast]\ntheorem coe_pow (x : \u211d) (n : \u2115) : (\u2191(x ^ n) : EReal) = (x : EReal) ^ n", "start": [1206, 1], "end": [1208, 55], "kind": "commanddeclaration"}, {"full_name": "EReal.coe_ennreal_pow", "code": "@[simp, norm_cast]\ntheorem coe_ennreal_pow (x : \u211d\u22650\u221e) (n : \u2115) : (\u2191(x ^ n) : EReal) = (x : EReal) ^ n", "start": [1211, 1], "end": [1213, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rat/Encodable.lean", "imports": ["Mathlib/Data/Nat/GCD/Basic.lean", "Mathlib/Data/Rat/Init.lean", "Mathlib/Logic/Encodable/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Topology/Algebra/Equicontinuity.lean", "imports": ["Mathlib/Topology/Algebra/UniformConvergence.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "equicontinuous_of_equicontinuousAt_one", "code": "@[to_additive]\ntheorem equicontinuous_of_equicontinuousAt_one {\u03b9 G M hom : Type*} [TopologicalSpace G]\n    [UniformSpace M] [Group G] [Group M] [TopologicalGroup G] [UniformGroup M]\n    [MonoidHomClass hom G M] (F : \u03b9 \u2192 hom)\n    (hf : EquicontinuousAt ((\u2191) \u2218 F) (1 : G)) :\n    Equicontinuous ((\u2191) \u2218 F)", "start": [19, 1], "end": [31, 44], "kind": "commanddeclaration"}, {"full_name": "uniformEquicontinuous_of_equicontinuousAt_one", "code": "@[to_additive]\ntheorem uniformEquicontinuous_of_equicontinuousAt_one {\u03b9 G M hom : Type*} [UniformSpace G]\n    [UniformSpace M] [Group G] [Group M] [UniformGroup G] [UniformGroup M] [MonoidHomClass hom G M]\n    (F : \u03b9 \u2192 hom) (hf : EquicontinuousAt ((\u2191) \u2218 F) (1 : G)) :\n    UniformEquicontinuous ((\u2191) \u2218 F)", "start": [35, 1], "end": [46, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Module/LocallyConvex.lean", "imports": ["Mathlib/Analysis/Convex/Topology.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LocallyConvexSpace", "code": "class LocallyConvexSpace (\ud835\udd5c E : Type*) [OrderedSemiring \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E]\n    [TopologicalSpace E] : Prop where\n  convex_basis : \u2200 x : E, (\ud835\udcdd x).HasBasis (fun s : Set E => s \u2208 \ud835\udcdd x \u2227 Convex \ud835\udd5c s) id", "start": [42, 1], "end": [46, 84], "kind": "commanddeclaration"}, {"full_name": "locallyConvexSpace_iff", "code": "theorem locallyConvexSpace_iff :\n    LocallyConvexSpace \ud835\udd5c E \u2194 \u2200 x : E, (\ud835\udcdd x).HasBasis (fun s : Set E => s \u2208 \ud835\udcdd x \u2227 Convex \ud835\udd5c s) id", "start": [51, 1], "end": [53, 72], "kind": "commanddeclaration"}, {"full_name": "LocallyConvexSpace.ofBases", "code": "theorem LocallyConvexSpace.ofBases {\u03b9 : Type*} (b : E \u2192 \u03b9 \u2192 Set E) (p : E \u2192 \u03b9 \u2192 Prop)\n    (hbasis : \u2200 x : E, (\ud835\udcdd x).HasBasis (p x) (b x)) (hconvex : \u2200 x i, p x i \u2192 Convex \ud835\udd5c (b x i)) :\n    LocallyConvexSpace \ud835\udd5c E", "start": [56, 1], "end": [63, 101], "kind": "commanddeclaration"}, {"full_name": "LocallyConvexSpace.convex_basis_zero", "code": "theorem LocallyConvexSpace.convex_basis_zero [LocallyConvexSpace \ud835\udd5c E] :\n    (\ud835\udcdd 0 : Filter E).HasBasis (fun s => s \u2208 (\ud835\udcdd 0 : Filter E) \u2227 Convex \ud835\udd5c s) id", "start": [66, 1], "end": [68, 36], "kind": "commanddeclaration"}, {"full_name": "locallyConvexSpace_iff_exists_convex_subset", "code": "theorem locallyConvexSpace_iff_exists_convex_subset :\n    LocallyConvexSpace \ud835\udd5c E \u2194 \u2200 x : E, \u2200 U \u2208 \ud835\udcdd x, \u2203 S \u2208 \ud835\udcdd x, Convex \ud835\udd5c S \u2227 S \u2286 U", "start": [71, 1], "end": [73, 76], "kind": "commanddeclaration"}, {"full_name": "LocallyConvexSpace.ofBasisZero", "code": "theorem LocallyConvexSpace.ofBasisZero {\u03b9 : Type*} (b : \u03b9 \u2192 Set E) (p : \u03b9 \u2192 Prop)\n    (hbasis : (\ud835\udcdd 0).HasBasis p b) (hconvex : \u2200 i, p i \u2192 Convex \ud835\udd5c (b i)) :\n    LocallyConvexSpace \ud835\udd5c E", "start": [83, 1], "end": [89, 21], "kind": "commanddeclaration"}, {"full_name": "locallyConvexSpace_iff_zero", "code": "theorem locallyConvexSpace_iff_zero : LocallyConvexSpace \ud835\udd5c E \u2194\n    (\ud835\udcdd 0 : Filter E).HasBasis (fun s : Set E => s \u2208 (\ud835\udcdd 0 : Filter E) \u2227 Convex \ud835\udd5c s) id", "start": [92, 1], "end": [95, 65], "kind": "commanddeclaration"}, {"full_name": "locallyConvexSpace_iff_exists_convex_subset_zero", "code": "theorem locallyConvexSpace_iff_exists_convex_subset_zero :\n    LocallyConvexSpace \ud835\udd5c E \u2194 \u2200 U \u2208 (\ud835\udcdd 0 : Filter E), \u2203 S \u2208 (\ud835\udcdd 0 : Filter E), Convex \ud835\udd5c S \u2227 S \u2286 U", "start": [98, 1], "end": [100, 56], "kind": "commanddeclaration"}, {"full_name": "LocallyConvexSpace.toLocallyConnectedSpace", "code": "instance (priority := 100) LocallyConvexSpace.toLocallyConnectedSpace [Module \u211d E]\n    [ContinuousSMul \u211d E] [LocallyConvexSpace \u211d E] : LocallyConnectedSpace E :=\n  locallyConnectedSpace_of_connected_bases _ _\n    (fun x => @LocallyConvexSpace.convex_basis \u211d _ _ _ _ _ _ x) fun _ _ hs => hs.2.isPreconnected", "start": [104, 1], "end": [107, 98], "kind": "commanddeclaration"}, {"full_name": "LocallyConvexSpace.convex_open_basis_zero", "code": "theorem LocallyConvexSpace.convex_open_basis_zero [LocallyConvexSpace \ud835\udd5c E] :\n    (\ud835\udcdd 0 : Filter E).HasBasis (fun s => (0 : E) \u2208 s \u2227 IsOpen s \u2227 Convex \ud835\udd5c s) id", "start": [117, 1], "end": [123, 64], "kind": "commanddeclaration"}, {"full_name": "Disjoint.exists_open_convexes", "code": "theorem Disjoint.exists_open_convexes [LocallyConvexSpace \ud835\udd5c E] {s t : Set E} (disj : Disjoint s t)\n    (hs\u2081 : Convex \ud835\udd5c s) (hs\u2082 : IsCompact s) (ht\u2081 : Convex \ud835\udd5c t) (ht\u2082 : IsClosed t) :\n    \u2203 u v, IsOpen u \u2227 IsOpen v \u2227 Convex \ud835\udd5c u \u2227 Convex \ud835\udd5c v \u2227 s \u2286 u \u2227 t \u2286 v \u2227 Disjoint u v", "start": [128, 1], "end": [142, 11], "kind": "commanddeclaration"}, {"full_name": "locallyConvexSpace_sInf", "code": "theorem locallyConvexSpace_sInf {ts : Set (TopologicalSpace E)}\n    (h : \u2200 t \u2208 ts, @LocallyConvexSpace \ud835\udd5c E _ _ _ t) : @LocallyConvexSpace \ud835\udd5c E _ _ _ (sInf ts)", "start": [152, 1], "end": [161, 94], "kind": "commanddeclaration"}, {"full_name": "locallyConvexSpace_iInf", "code": "theorem locallyConvexSpace_iInf {ts' : \u03b9 \u2192 TopologicalSpace E}\n    (h' : \u2200 i, @LocallyConvexSpace \ud835\udd5c E _ _ _ (ts' i)) :\n    @LocallyConvexSpace \ud835\udd5c E _ _ _ (\u2a05 i, ts' i)", "start": [164, 1], "end": [168, 25], "kind": "commanddeclaration"}, {"full_name": "locallyConvexSpace_inf", "code": "theorem locallyConvexSpace_inf {t\u2081 t\u2082 : TopologicalSpace E} (h\u2081 : @LocallyConvexSpace \ud835\udd5c E _ _ _ t\u2081)\n    (h\u2082 : @LocallyConvexSpace \ud835\udd5c E _ _ _ t\u2082) : @LocallyConvexSpace \ud835\udd5c E _ _ _ (t\u2081 \u2293 t\u2082)", "start": [171, 1], "end": [175, 25], "kind": "commanddeclaration"}, {"full_name": "locallyConvexSpace_induced", "code": "theorem locallyConvexSpace_induced {t : TopologicalSpace F} [LocallyConvexSpace \ud835\udd5c F]\n    (f : E \u2192\u2097[\ud835\udd5c] F) : @LocallyConvexSpace \ud835\udd5c E _ _ _ (t.induced f)", "start": [178, 1], "end": [185, 57], "kind": "commanddeclaration"}, {"full_name": "Pi.locallyConvexSpace", "code": "instance Pi.locallyConvexSpace {\u03b9 : Type*} {X : \u03b9 \u2192 Type*} [\u2200 i, AddCommMonoid (X i)]\n    [\u2200 i, TopologicalSpace (X i)] [\u2200 i, Module \ud835\udd5c (X i)] [\u2200 i, LocallyConvexSpace \ud835\udd5c (X i)] :\n    LocallyConvexSpace \ud835\udd5c (\u2200 i, X i) :=\n  locallyConvexSpace_iInf fun i => locallyConvexSpace_induced (LinearMap.proj i)", "start": [188, 1], "end": [191, 81], "kind": "commanddeclaration"}, {"full_name": "Prod.locallyConvexSpace", "code": "instance Prod.locallyConvexSpace [TopologicalSpace E] [TopologicalSpace F] [LocallyConvexSpace \ud835\udd5c E]\n    [LocallyConvexSpace \ud835\udd5c F] : LocallyConvexSpace \ud835\udd5c (E \u00d7 F) :=\nlocallyConvexSpace_inf (t\u2081 := induced Prod.fst _) (t\u2082 := induced Prod.snd _)\n    (locallyConvexSpace_induced (LinearMap.fst _ _ _))\n    (locallyConvexSpace_induced (LinearMap.snd _ _ _))", "start": [194, 1], "end": [199, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/Equicontinuity.lean", "imports": ["Mathlib/Topology/MetricSpace/Basic.lean", "Mathlib/Topology/UniformSpace/Equicontinuity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Metric.equicontinuousAt_iff_right", "code": "theorem equicontinuousAt_iff_right {\u03b9 : Type*} [TopologicalSpace \u03b2] {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {x\u2080 : \u03b2} :\n    EquicontinuousAt F x\u2080 \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 x in \ud835\udcdd x\u2080, \u2200 i, dist (F i x\u2080) (F i x) < \u03b5", "start": [43, 1], "end": [47, 51], "kind": "commanddeclaration"}, {"full_name": "Metric.equicontinuousAt_iff", "code": "theorem equicontinuousAt_iff {\u03b9 : Type*} [PseudoMetricSpace \u03b2] {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {x\u2080 : \u03b2} :\n    EquicontinuousAt F x\u2080 \u2194 \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x, dist x x\u2080 < \u03b4 \u2192 \u2200 i, dist (F i x\u2080) (F i x) < \u03b5", "start": [50, 1], "end": [53, 61], "kind": "commanddeclaration"}, {"full_name": "Metric.equicontinuousAt_iff_pair", "code": "protected theorem equicontinuousAt_iff_pair {\u03b9 : Type*} [TopologicalSpace \u03b2] {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1}\n    {x\u2080 : \u03b2} :\n    EquicontinuousAt F x\u2080 \u2194\n      \u2200 \u03b5 > 0, \u2203 U \u2208 \ud835\udcdd x\u2080, \u2200 x \u2208 U, \u2200 x' \u2208 U, \u2200 i, dist (F i x) (F i x') < \u03b5", "start": [56, 1], "end": [69, 52], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformEquicontinuous_iff_right", "code": "theorem uniformEquicontinuous_iff_right {\u03b9 : Type*} [UniformSpace \u03b2] {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} :\n    UniformEquicontinuous F \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 xy : \u03b2 \u00d7 \u03b2 in \ud835\udce4 \u03b2, \u2200 i, dist (F i xy.1) (F i xy.2) < \u03b5", "start": [72, 1], "end": [76, 56], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformEquicontinuous_iff", "code": "theorem uniformEquicontinuous_iff {\u03b9 : Type*} [PseudoMetricSpace \u03b2] {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} :\n    UniformEquicontinuous F \u2194\n      \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x y, dist x y < \u03b4 \u2192 \u2200 i, dist (F i x) (F i y) < \u03b5", "start": [79, 1], "end": [84, 72], "kind": "commanddeclaration"}, {"full_name": "Metric.equicontinuousAt_of_continuity_modulus", "code": "theorem equicontinuousAt_of_continuity_modulus {\u03b9 : Type*} [TopologicalSpace \u03b2] {x\u2080 : \u03b2}\n    (b : \u03b2 \u2192 \u211d) (b_lim : Tendsto b (\ud835\udcdd x\u2080) (\ud835\udcdd 0)) (F : \u03b9 \u2192 \u03b2 \u2192 \u03b1)\n    (H : \u2200\u1da0 x in \ud835\udcdd x\u2080, \u2200 i, dist (F i x\u2080) (F i x) \u2264 b x) : EquicontinuousAt F x\u2080", "start": [87, 1], "end": [97, 44], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformEquicontinuous_of_continuity_modulus", "code": "theorem uniformEquicontinuous_of_continuity_modulus {\u03b9 : Type*} [PseudoMetricSpace \u03b2] (b : \u211d \u2192 \u211d)\n    (b_lim : Tendsto b (\ud835\udcdd 0) (\ud835\udcdd 0)) (F : \u03b9 \u2192 \u03b2 \u2192 \u03b1)\n    (H : \u2200 (x y : \u03b2) (i), dist (F i x) (F i y) \u2264 b (dist x y)) : UniformEquicontinuous F", "start": [100, 1], "end": [114, 78], "kind": "commanddeclaration"}, {"full_name": "Metric.equicontinuous_of_continuity_modulus", "code": "theorem equicontinuous_of_continuity_modulus {\u03b9 : Type*} [PseudoMetricSpace \u03b2] (b : \u211d \u2192 \u211d)\n    (b_lim : Tendsto b (\ud835\udcdd 0) (\ud835\udcdd 0)) (F : \u03b9 \u2192 \u03b2 \u2192 \u03b1)\n    (H : \u2200 (x y : \u03b2) (i), dist (F i x) (F i y) \u2264 b (dist x y)) : Equicontinuous F", "start": [117, 1], "end": [122, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "imports": ["Mathlib/Analysis/Normed/Group/AddCircle.lean", "Mathlib/Topology/Instances/Sign.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "Mathlib/Algebra/CharZero/Quotient.lean"], "premises": [{"full_name": "Real.Angle", "code": "def Angle : Type :=\n  AddCircle (2 * \u03c0)", "start": [28, 1], "end": [30, 20], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe", "code": "@[coe]\nprotected def coe (r : \u211d) : Angle := QuotientAddGroup.mk r", "start": [46, 1], "end": [48, 59], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.continuous_coe", "code": "@[continuity]\ntheorem continuous_coe : Continuous ((\u2191) : \u211d \u2192 Angle)", "start": [56, 1], "end": [58, 26], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coeHom", "code": "def coeHom : \u211d \u2192+ Angle :=\n  QuotientAddGroup.mk' _", "start": [61, 1], "end": [63, 25], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_coeHom", "code": "@[simp]\ntheorem coe_coeHom : (coeHom : \u211d \u2192 Angle) = ((\u2191) : \u211d \u2192 Angle)", "start": [66, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.induction_on", "code": "@[elab_as_elim]\nprotected theorem induction_on {p : Angle \u2192 Prop} (\u03b8 : Angle) (h : \u2200 x : \u211d, p x) : p \u03b8", "start": [71, 1], "end": [75, 28], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u2191(0 : \u211d) = (0 : Angle)", "start": [78, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_add", "code": "@[simp]\ntheorem coe_add (x y : \u211d) : \u2191(x + y : \u211d) = (\u2191x + \u2191y : Angle)", "start": [83, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_neg", "code": "@[simp]\ntheorem coe_neg (x : \u211d) : \u2191(-x : \u211d) = -(\u2191x : Angle)", "start": [88, 1], "end": [90, 6], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_sub", "code": "@[simp]\ntheorem coe_sub (x y : \u211d) : \u2191(x - y : \u211d) = (\u2191x - \u2191y : Angle)", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_nsmul", "code": "theorem coe_nsmul (n : \u2115) (x : \u211d) : \u2191(n \u2022 x : \u211d) = n \u2022 (\u2191x : Angle)", "start": [98, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_zsmul", "code": "theorem coe_zsmul (z : \u2124) (x : \u211d) : \u2191(z \u2022 x : \u211d) = z \u2022 (\u2191x : Angle)", "start": [102, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_nat_mul_eq_nsmul", "code": "@[simp, norm_cast]\ntheorem coe_nat_mul_eq_nsmul (x : \u211d) (n : \u2115) : \u2191((n : \u211d) * x) = n \u2022 (\u2191x : Angle)", "start": [106, 1], "end": [108, 55], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_int_mul_eq_zsmul", "code": "@[simp, norm_cast]\ntheorem coe_int_mul_eq_zsmul (x : \u211d) (n : \u2124) : \u2191((n : \u211d) * x : \u211d) = n \u2022 (\u2191x : Angle)", "start": [111, 1], "end": [113, 55], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.angle_eq_iff_two_pi_dvd_sub", "code": "theorem angle_eq_iff_two_pi_dvd_sub {\u03c8 \u03b8 : \u211d} : (\u03b8 : Angle) = \u03c8 \u2194 \u2203 k : \u2124, \u03b8 - \u03c8 = 2 * \u03c0 * k", "start": [116, 1], "end": [122, 90], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_two_pi", "code": "@[simp]\ntheorem coe_two_pi : \u2191(2 * \u03c0 : \u211d) = (0 : Angle)", "start": [125, 1], "end": [127, 77], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.neg_coe_pi", "code": "@[simp]\ntheorem neg_coe_pi : -(\u03c0 : Angle) = \u03c0", "start": [130, 1], "end": [134, 33], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_nsmul_coe_div_two", "code": "@[simp]\ntheorem two_nsmul_coe_div_two (\u03b8 : \u211d) : (2 : \u2115) \u2022 (\u2191(\u03b8 / 2) : Angle) = \u03b8", "start": [137, 1], "end": [139, 42], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_zsmul_coe_div_two", "code": "@[simp]\ntheorem two_zsmul_coe_div_two (\u03b8 : \u211d) : (2 : \u2124) \u2022 (\u2191(\u03b8 / 2) : Angle) = \u03b8", "start": [142, 1], "end": [144, 42], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_nsmul_neg_pi_div_two", "code": "theorem two_nsmul_neg_pi_div_two : (2 : \u2115) \u2022 (\u2191(-\u03c0 / 2) : Angle) = \u03c0", "start": [148, 1], "end": [149, 50], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_zsmul_neg_pi_div_two", "code": "theorem two_zsmul_neg_pi_div_two : (2 : \u2124) \u2022 (\u2191(-\u03c0 / 2) : Angle) = \u03c0", "start": [153, 1], "end": [154, 56], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sub_coe_pi_eq_add_coe_pi", "code": "theorem sub_coe_pi_eq_add_coe_pi (\u03b8 : Angle) : \u03b8 - \u03c0 = \u03b8 + \u03c0", "start": [157, 1], "end": [158, 34], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_nsmul_coe_pi", "code": "@[simp]\ntheorem two_nsmul_coe_pi : (2 : \u2115) \u2022 (\u03c0 : Angle) = 0", "start": [161, 1], "end": [162, 89], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_zsmul_coe_pi", "code": "@[simp]\ntheorem two_zsmul_coe_pi : (2 : \u2124) \u2022 (\u03c0 : Angle) = 0", "start": [165, 1], "end": [166, 89], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_pi_add_coe_pi", "code": "@[simp]\ntheorem coe_pi_add_coe_pi : (\u03c0 : Real.Angle) + \u03c0 = 0", "start": [169, 1], "end": [170, 94], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.zsmul_eq_iff", "code": "theorem zsmul_eq_iff {\u03c8 \u03b8 : Angle} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (2 * \u03c0 / z : \u211d)", "start": [173, 1], "end": [175, 52], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.nsmul_eq_iff", "code": "theorem nsmul_eq_iff {\u03c8 \u03b8 : Angle} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (2 * \u03c0 / n : \u211d)", "start": [178, 1], "end": [180, 52], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_zsmul_eq_iff", "code": "theorem two_zsmul_eq_iff {\u03c8 \u03b8 : Angle} : (2 : \u2124) \u2022 \u03c8 = (2 : \u2124) \u2022 \u03b8 \u2194 \u03c8 = \u03b8 \u2228 \u03c8 = \u03b8 + \u2191\u03c0", "start": [183, 1], "end": [188, 45], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_nsmul_eq_iff", "code": "theorem two_nsmul_eq_iff {\u03c8 \u03b8 : Angle} : (2 : \u2115) \u2022 \u03c8 = (2 : \u2115) \u2022 \u03b8 \u2194 \u03c8 = \u03b8 \u2228 \u03c8 = \u03b8 + \u2191\u03c0", "start": [191, 1], "end": [192, 62], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_nsmul_eq_zero_iff", "code": "theorem two_nsmul_eq_zero_iff {\u03b8 : Angle} : (2 : \u2115) \u2022 \u03b8 = 0 \u2194 \u03b8 = 0 \u2228 \u03b8 = \u03c0", "start": [195, 1], "end": [196, 36], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_nsmul_ne_zero_iff", "code": "theorem two_nsmul_ne_zero_iff {\u03b8 : Angle} : (2 : \u2115) \u2022 \u03b8 \u2260 0 \u2194 \u03b8 \u2260 0 \u2227 \u03b8 \u2260 \u03c0", "start": [199, 1], "end": [200, 41], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_zsmul_eq_zero_iff", "code": "theorem two_zsmul_eq_zero_iff {\u03b8 : Angle} : (2 : \u2124) \u2022 \u03b8 = 0 \u2194 \u03b8 = 0 \u2228 \u03b8 = \u03c0", "start": [203, 1], "end": [204, 58], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_zsmul_ne_zero_iff", "code": "theorem two_zsmul_ne_zero_iff {\u03b8 : Angle} : (2 : \u2124) \u2022 \u03b8 \u2260 0 \u2194 \u03b8 \u2260 0 \u2227 \u03b8 \u2260 \u03c0", "start": [207, 1], "end": [208, 41], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.eq_neg_self_iff", "code": "theorem eq_neg_self_iff {\u03b8 : Angle} : \u03b8 = -\u03b8 \u2194 \u03b8 = 0 \u2228 \u03b8 = \u03c0", "start": [211, 1], "end": [212, 68], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.ne_neg_self_iff", "code": "theorem ne_neg_self_iff {\u03b8 : Angle} : \u03b8 \u2260 -\u03b8 \u2194 \u03b8 \u2260 0 \u2227 \u03b8 \u2260 \u03c0", "start": [215, 1], "end": [216, 39], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.neg_eq_self_iff", "code": "theorem neg_eq_self_iff {\u03b8 : Angle} : -\u03b8 = \u03b8 \u2194 \u03b8 = 0 \u2228 \u03b8 = \u03c0", "start": [219, 1], "end": [219, 97], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.neg_ne_self_iff", "code": "theorem neg_ne_self_iff {\u03b8 : Angle} : -\u03b8 \u2260 \u03b8 \u2194 \u03b8 \u2260 0 \u2227 \u03b8 \u2260 \u03c0", "start": [222, 1], "end": [223, 39], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_nsmul_eq_pi_iff", "code": "theorem two_nsmul_eq_pi_iff {\u03b8 : Angle} : (2 : \u2115) \u2022 \u03b8 = \u03c0 \u2194 \u03b8 = (\u03c0 / 2 : \u211d) \u2228 \u03b8 = (-\u03c0 / 2 : \u211d)", "start": [226, 1], "end": [233, 58], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_zsmul_eq_pi_iff", "code": "theorem two_zsmul_eq_pi_iff {\u03b8 : Angle} : (2 : \u2124) \u2022 \u03b8 = \u03c0 \u2194 \u03b8 = (\u03c0 / 2 : \u211d) \u2228 \u03b8 = (-\u03c0 / 2 : \u211d)", "start": [236, 1], "end": [237, 51], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_eq_iff_coe_eq_or_eq_neg", "code": "theorem cos_eq_iff_coe_eq_or_eq_neg {\u03b8 \u03c8 : \u211d} :\n    cos \u03b8 = cos \u03c8 \u2194 (\u03b8 : Angle) = \u03c8 \u2228 (\u03b8 : Angle) = -\u03c8", "start": [240, 1], "end": [261, 16], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_eq_iff_coe_eq_or_add_eq_pi", "code": "theorem sin_eq_iff_coe_eq_or_add_eq_pi {\u03b8 \u03c8 : \u211d} :\n    sin \u03b8 = sin \u03c8 \u2194 (\u03b8 : Angle) = \u03c8 \u2228 (\u03b8 : Angle) + \u03c8 = \u03c0", "start": [264, 1], "end": [286, 16], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_sin_inj", "code": "theorem cos_sin_inj {\u03b8 \u03c8 : \u211d} (Hcos : cos \u03b8 = cos \u03c8) (Hsin : sin \u03b8 = sin \u03c8) : (\u03b8 : Angle) = \u03c8", "start": [289, 1], "end": [299, 32], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin", "code": "def sin (\u03b8 : Angle) : \u211d :=\n  sin_periodic.lift \u03b8", "start": [302, 1], "end": [304, 22], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_coe", "code": "@[simp]\ntheorem sin_coe (x : \u211d) : sin (x : Angle) = Real.sin x", "start": [307, 1], "end": [309, 6], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.continuous_sin", "code": "@[continuity]\ntheorem continuous_sin : Continuous sin", "start": [312, 1], "end": [314, 41], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos", "code": "def cos (\u03b8 : Angle) : \u211d :=\n  cos_periodic.lift \u03b8", "start": [317, 1], "end": [319, 22], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_coe", "code": "@[simp]\ntheorem cos_coe (x : \u211d) : cos (x : Angle) = Real.cos x", "start": [322, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.continuous_cos", "code": "@[continuity]\ntheorem continuous_cos : Continuous cos", "start": [327, 1], "end": [329, 41], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_eq_real_cos_iff_eq_or_eq_neg", "code": "theorem cos_eq_real_cos_iff_eq_or_eq_neg {\u03b8 : Angle} {\u03c8 : \u211d} :\n    cos \u03b8 = Real.cos \u03c8 \u2194 \u03b8 = \u03c8 \u2228 \u03b8 = -\u03c8", "start": [332, 1], "end": [335, 36], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_eq_iff_eq_or_eq_neg", "code": "theorem cos_eq_iff_eq_or_eq_neg {\u03b8 \u03c8 : Angle} : cos \u03b8 = cos \u03c8 \u2194 \u03b8 = \u03c8 \u2228 \u03b8 = -\u03c8", "start": [338, 1], "end": [340, 41], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_eq_real_sin_iff_eq_or_add_eq_pi", "code": "theorem sin_eq_real_sin_iff_eq_or_add_eq_pi {\u03b8 : Angle} {\u03c8 : \u211d} :\n    sin \u03b8 = Real.sin \u03c8 \u2194 \u03b8 = \u03c8 \u2228 \u03b8 + \u03c8 = \u03c0", "start": [343, 1], "end": [346, 39], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_eq_iff_eq_or_add_eq_pi", "code": "theorem sin_eq_iff_eq_or_add_eq_pi {\u03b8 \u03c8 : Angle} : sin \u03b8 = sin \u03c8 \u2194 \u03b8 = \u03c8 \u2228 \u03b8 + \u03c8 = \u03c0", "start": [349, 1], "end": [351, 44], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_zero", "code": "@[simp]\ntheorem sin_zero : sin (0 : Angle) = 0", "start": [354, 1], "end": [355, 85], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_coe_pi", "code": "theorem sin_coe_pi : sin (\u03c0 : Angle) = 0", "start": [359, 1], "end": [359, 73], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_eq_zero_iff", "code": "theorem sin_eq_zero_iff {\u03b8 : Angle} : sin \u03b8 = 0 \u2194 \u03b8 = 0 \u2228 \u03b8 = \u03c0", "start": [362, 1], "end": [365, 7], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_ne_zero_iff", "code": "theorem sin_ne_zero_iff {\u03b8 : Angle} : sin \u03b8 \u2260 0 \u2194 \u03b8 \u2260 0 \u2227 \u03b8 \u2260 \u03c0", "start": [368, 1], "end": [369, 35], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_neg", "code": "@[simp]\ntheorem sin_neg (\u03b8 : Angle) : sin (-\u03b8) = -sin \u03b8", "start": [372, 1], "end": [375, 23], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_antiperiodic", "code": "theorem sin_antiperiodic : Function.Antiperiodic sin (\u03c0 : Angle)", "start": [378, 1], "end": [381, 32], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_add_pi", "code": "@[simp]\ntheorem sin_add_pi (\u03b8 : Angle) : sin (\u03b8 + \u03c0) = -sin \u03b8", "start": [384, 1], "end": [386, 21], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_sub_pi", "code": "@[simp]\ntheorem sin_sub_pi (\u03b8 : Angle) : sin (\u03b8 - \u03c0) = -sin \u03b8", "start": [389, 1], "end": [391, 28], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_zero", "code": "@[simp]\ntheorem cos_zero : cos (0 : Angle) = 1", "start": [394, 1], "end": [395, 85], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_coe_pi", "code": "theorem cos_coe_pi : cos (\u03c0 : Angle) = -1", "start": [399, 1], "end": [399, 74], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_neg", "code": "@[simp]\ntheorem cos_neg (\u03b8 : Angle) : cos (-\u03b8) = cos \u03b8", "start": [402, 1], "end": [405, 23], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_antiperiodic", "code": "theorem cos_antiperiodic : Function.Antiperiodic cos (\u03c0 : Angle)", "start": [408, 1], "end": [411, 32], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_add_pi", "code": "@[simp]\ntheorem cos_add_pi (\u03b8 : Angle) : cos (\u03b8 + \u03c0) = -cos \u03b8", "start": [414, 1], "end": [416, 21], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_sub_pi", "code": "@[simp]\ntheorem cos_sub_pi (\u03b8 : Angle) : cos (\u03b8 - \u03c0) = -cos \u03b8", "start": [419, 1], "end": [421, 28], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_eq_zero_iff", "code": "theorem cos_eq_zero_iff {\u03b8 : Angle} : cos \u03b8 = 0 \u2194 \u03b8 = (\u03c0 / 2 : \u211d) \u2228 \u03b8 = (-\u03c0 / 2 : \u211d)", "start": [424, 1], "end": [425, 82], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_add", "code": "theorem sin_add (\u03b8\u2081 \u03b8\u2082 : Real.Angle) : sin (\u03b8\u2081 + \u03b8\u2082) = sin \u03b8\u2081 * cos \u03b8\u2082 + cos \u03b8\u2081 * sin \u03b8\u2082", "start": [428, 1], "end": [431, 25], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_add", "code": "theorem cos_add (\u03b8\u2081 \u03b8\u2082 : Real.Angle) : cos (\u03b8\u2081 + \u03b8\u2082) = cos \u03b8\u2081 * cos \u03b8\u2082 - sin \u03b8\u2081 * sin \u03b8\u2082", "start": [434, 1], "end": [437, 25], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_sq_add_sin_sq", "code": "@[simp]\ntheorem cos_sq_add_sin_sq (\u03b8 : Real.Angle) : cos \u03b8 ^ 2 + sin \u03b8 ^ 2 = 1", "start": [440, 1], "end": [443, 33], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_add_pi_div_two", "code": "theorem sin_add_pi_div_two (\u03b8 : Angle) : sin (\u03b8 + \u2191(\u03c0 / 2)) = cos \u03b8", "start": [446, 1], "end": [448, 34], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_sub_pi_div_two", "code": "theorem sin_sub_pi_div_two (\u03b8 : Angle) : sin (\u03b8 - \u2191(\u03c0 / 2)) = -cos \u03b8", "start": [451, 1], "end": [453, 34], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_pi_div_two_sub", "code": "theorem sin_pi_div_two_sub (\u03b8 : Angle) : sin (\u2191(\u03c0 / 2) - \u03b8) = cos \u03b8", "start": [456, 1], "end": [458, 34], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_add_pi_div_two", "code": "theorem cos_add_pi_div_two (\u03b8 : Angle) : cos (\u03b8 + \u2191(\u03c0 / 2)) = -sin \u03b8", "start": [461, 1], "end": [463, 34], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_sub_pi_div_two", "code": "theorem cos_sub_pi_div_two (\u03b8 : Angle) : cos (\u03b8 - \u2191(\u03c0 / 2)) = sin \u03b8", "start": [466, 1], "end": [468, 34], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_pi_div_two_sub", "code": "theorem cos_pi_div_two_sub (\u03b8 : Angle) : cos (\u2191(\u03c0 / 2) - \u03b8) = sin \u03b8", "start": [471, 1], "end": [473, 34], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.abs_sin_eq_of_two_nsmul_eq", "code": "theorem abs_sin_eq_of_two_nsmul_eq {\u03b8 \u03c8 : Angle} (h : (2 : \u2115) \u2022 \u03b8 = (2 : \u2115) \u2022 \u03c8) :\n    |sin \u03b8| = |sin \u03c8|", "start": [476, 1], "end": [481, 29], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.abs_sin_eq_of_two_zsmul_eq", "code": "theorem abs_sin_eq_of_two_zsmul_eq {\u03b8 \u03c8 : Angle} (h : (2 : \u2124) \u2022 \u03b8 = (2 : \u2124) \u2022 \u03c8) :\n    |sin \u03b8| = |sin \u03c8|", "start": [484, 1], "end": [487, 37], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.abs_cos_eq_of_two_nsmul_eq", "code": "theorem abs_cos_eq_of_two_nsmul_eq {\u03b8 \u03c8 : Angle} (h : (2 : \u2115) \u2022 \u03b8 = (2 : \u2115) \u2022 \u03c8) :\n    |cos \u03b8| = |cos \u03c8|", "start": [490, 1], "end": [495, 29], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.abs_cos_eq_of_two_zsmul_eq", "code": "theorem abs_cos_eq_of_two_zsmul_eq {\u03b8 \u03c8 : Angle} (h : (2 : \u2124) \u2022 \u03b8 = (2 : \u2124) \u2022 \u03c8) :\n    |cos \u03b8| = |cos \u03c8|", "start": [498, 1], "end": [501, 37], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_toIcoMod", "code": "@[simp]\ntheorem coe_toIcoMod (\u03b8 \u03c8 : \u211d) : \u2191(toIcoMod two_pi_pos \u03c8 \u03b8) = (\u03b8 : Angle)", "start": [504, 1], "end": [508, 49], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_toIocMod", "code": "@[simp]\ntheorem coe_toIocMod (\u03b8 \u03c8 : \u211d) : \u2191(toIocMod two_pi_pos \u03c8 \u03b8) = (\u03b8 : Angle)", "start": [511, 1], "end": [515, 49], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal", "code": "def toReal (\u03b8 : Angle) : \u211d :=\n  (toIocMod_periodic two_pi_pos (-\u03c0)).lift \u03b8", "start": [518, 1], "end": [520, 45], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_coe", "code": "theorem toReal_coe (\u03b8 : \u211d) : (\u03b8 : Angle).toReal = toIocMod two_pi_pos (-\u03c0) \u03b8", "start": [523, 1], "end": [524, 6], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_coe_eq_self_iff", "code": "theorem toReal_coe_eq_self_iff {\u03b8 : \u211d} : (\u03b8 : Angle).toReal = \u03b8 \u2194 -\u03c0 < \u03b8 \u2227 \u03b8 \u2264 \u03c0", "start": [527, 1], "end": [530, 6], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_coe_eq_self_iff_mem_Ioc", "code": "theorem toReal_coe_eq_self_iff_mem_Ioc {\u03b8 : \u211d} : (\u03b8 : Angle).toReal = \u03b8 \u2194 \u03b8 \u2208 Set.Ioc (-\u03c0) \u03c0", "start": [533, 1], "end": [534, 45], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_injective", "code": "theorem toReal_injective : Function.Injective toReal", "start": [537, 1], "end": [542, 50], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_inj", "code": "@[simp]\ntheorem toReal_inj {\u03b8 \u03c8 : Angle} : \u03b8.toReal = \u03c8.toReal \u2194 \u03b8 = \u03c8", "start": [545, 1], "end": [547, 26], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_toReal", "code": "@[simp]\ntheorem coe_toReal (\u03b8 : Angle) : (\u03b8.toReal : Angle) = \u03b8", "start": [550, 1], "end": [553, 25], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.neg_pi_lt_toReal", "code": "theorem neg_pi_lt_toReal (\u03b8 : Angle) : -\u03c0 < \u03b8.toReal", "start": [556, 1], "end": [558, 31], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_le_pi", "code": "theorem toReal_le_pi (\u03b8 : Angle) : \u03b8.toReal \u2264 \u03c0", "start": [561, 1], "end": [564, 7], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.abs_toReal_le_pi", "code": "theorem abs_toReal_le_pi (\u03b8 : Angle) : |\u03b8.toReal| \u2264 \u03c0", "start": [567, 1], "end": [568, 53], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_mem_Ioc", "code": "theorem toReal_mem_Ioc (\u03b8 : Angle) : \u03b8.toReal \u2208 Set.Ioc (-\u03c0) \u03c0", "start": [571, 1], "end": [572, 39], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toIocMod_toReal", "code": "@[simp]\ntheorem toIocMod_toReal (\u03b8 : Angle) : toIocMod two_pi_pos (-\u03c0) \u03b8.toReal = \u03b8.toReal", "start": [575, 1], "end": [579, 34], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_zero", "code": "@[simp]\ntheorem toReal_zero : (0 : Angle).toReal = 0", "start": [582, 1], "end": [585, 57], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_eq_zero_iff", "code": "@[simp]\ntheorem toReal_eq_zero_iff {\u03b8 : Angle} : \u03b8.toReal = 0 \u2194 \u03b8 = 0", "start": [588, 1], "end": [591, 19], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_pi", "code": "@[simp]\ntheorem toReal_pi : (\u03c0 : Angle).toReal = \u03c0", "start": [594, 1], "end": [597, 50], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_eq_pi_iff", "code": "@[simp]\ntheorem toReal_eq_pi_iff {\u03b8 : Angle} : \u03b8.toReal = \u03c0 \u2194 \u03b8 = \u03c0", "start": [600, 1], "end": [601, 95], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.pi_ne_zero", "code": "theorem pi_ne_zero : (\u03c0 : Angle) \u2260 0", "start": [604, 1], "end": [606, 24], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_pi_div_two", "code": "@[simp]\ntheorem toReal_pi_div_two : ((\u03c0 / 2 : \u211d) : Angle).toReal = \u03c0 / 2", "start": [609, 1], "end": [611, 67], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_eq_pi_div_two_iff", "code": "@[simp]\ntheorem toReal_eq_pi_div_two_iff {\u03b8 : Angle} : \u03b8.toReal = \u03c0 / 2 \u2194 \u03b8 = (\u03c0 / 2 : \u211d)", "start": [614, 1], "end": [616, 39], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_neg_pi_div_two", "code": "@[simp]\ntheorem toReal_neg_pi_div_two : ((-\u03c0 / 2 : \u211d) : Angle).toReal = -\u03c0 / 2", "start": [619, 1], "end": [621, 67], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_eq_neg_pi_div_two_iff", "code": "@[simp]\ntheorem toReal_eq_neg_pi_div_two_iff {\u03b8 : Angle} : \u03b8.toReal = -\u03c0 / 2 \u2194 \u03b8 = (-\u03c0 / 2 : \u211d)", "start": [624, 1], "end": [626, 43], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.pi_div_two_ne_zero", "code": "theorem pi_div_two_ne_zero : ((\u03c0 / 2 : \u211d) : Angle) \u2260 0", "start": [629, 1], "end": [631, 48], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.neg_pi_div_two_ne_zero", "code": "theorem neg_pi_div_two_ne_zero : ((-\u03c0 / 2 : \u211d) : Angle) \u2260 0", "start": [634, 1], "end": [636, 64], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.abs_toReal_coe_eq_self_iff", "code": "theorem abs_toReal_coe_eq_self_iff {\u03b8 : \u211d} : |(\u03b8 : Angle).toReal| = \u03b8 \u2194 0 \u2264 \u03b8 \u2227 \u03b8 \u2264 \u03c0", "start": [639, 1], "end": [642, 25], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.abs_toReal_neg_coe_eq_self_iff", "code": "theorem abs_toReal_neg_coe_eq_self_iff {\u03b8 : \u211d} : |(-\u03b8 : Angle).toReal| = \u03b8 \u2194 0 \u2264 \u03b8 \u2227 \u03b8 \u2264 \u03c0", "start": [645, 1], "end": [651, 32], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.abs_toReal_eq_pi_div_two_iff", "code": "theorem abs_toReal_eq_pi_div_two_iff {\u03b8 : Angle} :\n    |\u03b8.toReal| = \u03c0 / 2 \u2194 \u03b8 = (\u03c0 / 2 : \u211d) \u2228 \u03b8 = (-\u03c0 / 2 : \u211d)", "start": [654, 1], "end": [657, 34], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.nsmul_toReal_eq_mul", "code": "theorem nsmul_toReal_eq_mul {n : \u2115} (h : n \u2260 0) {\u03b8 : Angle} :\n    (n \u2022 \u03b8).toReal = n * \u03b8.toReal \u2194 \u03b8.toReal \u2208 Set.Ioc (-\u03c0 / n) (\u03c0 / n)", "start": [660, 1], "end": [665, 20], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_nsmul_toReal_eq_two_mul", "code": "theorem two_nsmul_toReal_eq_two_mul {\u03b8 : Angle} :\n    ((2 : \u2115) \u2022 \u03b8).toReal = 2 * \u03b8.toReal \u2194 \u03b8.toReal \u2208 Set.Ioc (-\u03c0 / 2) (\u03c0 / 2)", "start": [668, 1], "end": [670, 49], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_zsmul_toReal_eq_two_mul", "code": "theorem two_zsmul_toReal_eq_two_mul {\u03b8 : Angle} :\n    ((2 : \u2124) \u2022 \u03b8).toReal = 2 * \u03b8.toReal \u2194 \u03b8.toReal \u2208 Set.Ioc (-\u03c0 / 2) (\u03c0 / 2)", "start": [673, 1], "end": [675, 59], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_coe_eq_self_sub_two_mul_int_mul_pi_iff", "code": "theorem toReal_coe_eq_self_sub_two_mul_int_mul_pi_iff {\u03b8 : \u211d} {k : \u2124} :\n    (\u03b8 : Angle).toReal = \u03b8 - 2 * k * \u03c0 \u2194 \u03b8 \u2208 Set.Ioc ((2 * k - 1 : \u211d) * \u03c0) ((2 * k + 1) * \u03c0)", "start": [678, 1], "end": [682, 83], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_coe_eq_self_sub_two_pi_iff", "code": "theorem toReal_coe_eq_self_sub_two_pi_iff {\u03b8 : \u211d} :\n    (\u03b8 : Angle).toReal = \u03b8 - 2 * \u03c0 \u2194 \u03b8 \u2208 Set.Ioc \u03c0 (3 * \u03c0)", "start": [685, 1], "end": [687, 74], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_coe_eq_self_add_two_pi_iff", "code": "theorem toReal_coe_eq_self_add_two_pi_iff {\u03b8 : \u211d} :\n    (\u03b8 : Angle).toReal = \u03b8 + 2 * \u03c0 \u2194 \u03b8 \u2208 Set.Ioc (-3 * \u03c0) (-\u03c0)", "start": [690, 1], "end": [692, 85], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_nsmul_toReal_eq_two_mul_sub_two_pi", "code": "theorem two_nsmul_toReal_eq_two_mul_sub_two_pi {\u03b8 : Angle} :\n    ((2 : \u2115) \u2022 \u03b8).toReal = 2 * \u03b8.toReal - 2 * \u03c0 \u2194 \u03c0 / 2 < \u03b8.toReal", "start": [695, 1], "end": [701, 82], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_zsmul_toReal_eq_two_mul_sub_two_pi", "code": "theorem two_zsmul_toReal_eq_two_mul_sub_two_pi {\u03b8 : Angle} :\n    ((2 : \u2124) \u2022 \u03b8).toReal = 2 * \u03b8.toReal - 2 * \u03c0 \u2194 \u03c0 / 2 < \u03b8.toReal", "start": [704, 1], "end": [706, 70], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_nsmul_toReal_eq_two_mul_add_two_pi", "code": "theorem two_nsmul_toReal_eq_two_mul_add_two_pi {\u03b8 : Angle} :\n    ((2 : \u2115) \u2022 \u03b8).toReal = 2 * \u03b8.toReal + 2 * \u03c0 \u2194 \u03b8.toReal \u2264 -\u03c0 / 2", "start": [709, 1], "end": [715, 86], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.two_zsmul_toReal_eq_two_mul_add_two_pi", "code": "theorem two_zsmul_toReal_eq_two_mul_add_two_pi {\u03b8 : Angle} :\n    ((2 : \u2124) \u2022 \u03b8).toReal = 2 * \u03b8.toReal + 2 * \u03c0 \u2194 \u03b8.toReal \u2264 -\u03c0 / 2", "start": [718, 1], "end": [720, 70], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sin_toReal", "code": "@[simp]\ntheorem sin_toReal (\u03b8 : Angle) : Real.sin \u03b8.toReal = sin \u03b8", "start": [723, 1], "end": [725, 43], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_toReal", "code": "@[simp]\ntheorem cos_toReal (\u03b8 : Angle) : Real.cos \u03b8.toReal = cos \u03b8", "start": [728, 1], "end": [730, 43], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_nonneg_iff_abs_toReal_le_pi_div_two", "code": "theorem cos_nonneg_iff_abs_toReal_le_pi_div_two {\u03b8 : Angle} : 0 \u2264 cos \u03b8 \u2194 |\u03b8.toReal| \u2264 \u03c0 / 2", "start": [733, 1], "end": [745, 30], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_pos_iff_abs_toReal_lt_pi_div_two", "code": "theorem cos_pos_iff_abs_toReal_lt_pi_div_two {\u03b8 : Angle} : 0 < cos \u03b8 \u2194 |\u03b8.toReal| < \u03c0 / 2", "start": [748, 1], "end": [752, 96], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.cos_neg_iff_pi_div_two_lt_abs_toReal", "code": "theorem cos_neg_iff_pi_div_two_lt_abs_toReal {\u03b8 : Angle} : cos \u03b8 < 0 \u2194 \u03c0 / 2 < |\u03b8.toReal|", "start": [755, 1], "end": [756, 80], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.abs_cos_eq_abs_sin_of_two_nsmul_add_two_nsmul_eq_pi", "code": "theorem abs_cos_eq_abs_sin_of_two_nsmul_add_two_nsmul_eq_pi {\u03b8 \u03c8 : Angle}\n    (h : (2 : \u2115) \u2022 \u03b8 + (2 : \u2115) \u2022 \u03c8 = \u03c0) : |cos \u03b8| = |sin \u03c8|", "start": [759, 1], "end": [762, 58], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.abs_cos_eq_abs_sin_of_two_zsmul_add_two_zsmul_eq_pi", "code": "theorem abs_cos_eq_abs_sin_of_two_zsmul_add_two_zsmul_eq_pi {\u03b8 \u03c8 : Angle}\n    (h : (2 : \u2124) \u2022 \u03b8 + (2 : \u2124) \u2022 \u03c8 = \u03c0) : |cos \u03b8| = |sin \u03c8|", "start": [765, 1], "end": [768, 62], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.tan", "code": "def tan (\u03b8 : Angle) : \u211d :=\n  sin \u03b8 / cos \u03b8", "start": [771, 1], "end": [773, 16], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.tan_eq_sin_div_cos", "code": "theorem tan_eq_sin_div_cos (\u03b8 : Angle) : tan \u03b8 = sin \u03b8 / cos \u03b8", "start": [776, 1], "end": [777, 6], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.tan_coe", "code": "@[simp]\ntheorem tan_coe (x : \u211d) : tan (x : Angle) = Real.tan x", "start": [780, 1], "end": [782, 54], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.tan_zero", "code": "@[simp]\ntheorem tan_zero : tan (0 : Angle) = 0", "start": [785, 1], "end": [786, 85], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.tan_coe_pi", "code": "theorem tan_coe_pi : tan (\u03c0 : Angle) = 0", "start": [790, 1], "end": [790, 73], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.tan_periodic", "code": "theorem tan_periodic : Function.Periodic tan (\u03c0 : Angle)", "start": [793, 1], "end": [797, 28], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.tan_add_pi", "code": "@[simp]\ntheorem tan_add_pi (\u03b8 : Angle) : tan (\u03b8 + \u03c0) = tan \u03b8", "start": [800, 1], "end": [802, 17], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.tan_sub_pi", "code": "@[simp]\ntheorem tan_sub_pi (\u03b8 : Angle) : tan (\u03b8 - \u03c0) = tan \u03b8", "start": [805, 1], "end": [807, 24], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.tan_toReal", "code": "@[simp]\ntheorem tan_toReal (\u03b8 : Angle) : Real.tan \u03b8.toReal = tan \u03b8", "start": [810, 1], "end": [812, 43], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.tan_eq_of_two_nsmul_eq", "code": "theorem tan_eq_of_two_nsmul_eq {\u03b8 \u03c8 : Angle} (h : (2 : \u2115) \u2022 \u03b8 = (2 : \u2115) \u2022 \u03c8) : tan \u03b8 = tan \u03c8", "start": [815, 1], "end": [819, 23], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.tan_eq_of_two_zsmul_eq", "code": "theorem tan_eq_of_two_zsmul_eq {\u03b8 \u03c8 : Angle} (h : (2 : \u2124) \u2022 \u03b8 = (2 : \u2124) \u2022 \u03c8) : tan \u03b8 = tan \u03c8", "start": [822, 1], "end": [824, 33], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.tan_eq_inv_of_two_nsmul_add_two_nsmul_eq_pi", "code": "theorem tan_eq_inv_of_two_nsmul_add_two_nsmul_eq_pi {\u03b8 \u03c8 : Angle}\n    (h : (2 : \u2115) \u2022 \u03b8 + (2 : \u2115) \u2022 \u03c8 = \u03c0) : tan \u03c8 = (tan \u03b8)\u207b\u00b9", "start": [827, 1], "end": [837, 38], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.tan_eq_inv_of_two_zsmul_add_two_zsmul_eq_pi", "code": "theorem tan_eq_inv_of_two_zsmul_add_two_zsmul_eq_pi {\u03b8 \u03c8 : Angle}\n    (h : (2 : \u2124) \u2022 \u03b8 + (2 : \u2124) \u2022 \u03c8 = \u03c0) : tan \u03c8 = (tan \u03b8)\u207b\u00b9", "start": [840, 1], "end": [843, 54], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign", "code": "def sign (\u03b8 : Angle) : SignType :=\n  SignType.sign (sin \u03b8)", "start": [846, 1], "end": [850, 24], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_zero", "code": "@[simp]\ntheorem sign_zero : (0 : Angle).sign = 0", "start": [853, 1], "end": [855, 40], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_coe_pi", "code": "@[simp]\ntheorem sign_coe_pi : (\u03c0 : Angle).sign = 0", "start": [858, 1], "end": [859, 89], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_neg", "code": "@[simp]\ntheorem sign_neg (\u03b8 : Angle) : (-\u03b8).sign = -\u03b8.sign", "start": [862, 1], "end": [864, 41], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_antiperiodic", "code": "theorem sign_antiperiodic : Function.Antiperiodic sign (\u03c0 : Angle)", "start": [867, 1], "end": [868, 45], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_add_pi", "code": "@[simp]\ntheorem sign_add_pi (\u03b8 : Angle) : (\u03b8 + \u03c0).sign = -\u03b8.sign", "start": [871, 1], "end": [873, 22], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_pi_add", "code": "@[simp]\ntheorem sign_pi_add (\u03b8 : Angle) : ((\u03c0 : Angle) + \u03b8).sign = -\u03b8.sign", "start": [876, 1], "end": [877, 100], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_sub_pi", "code": "@[simp]\ntheorem sign_sub_pi (\u03b8 : Angle) : (\u03b8 - \u03c0).sign = -\u03b8.sign", "start": [880, 1], "end": [882, 29], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_pi_sub", "code": "@[simp]\ntheorem sign_pi_sub (\u03b8 : Angle) : ((\u03c0 : Angle) - \u03b8).sign = \u03b8.sign", "start": [885, 1], "end": [887, 35], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_eq_zero_iff", "code": "theorem sign_eq_zero_iff {\u03b8 : Angle} : \u03b8.sign = 0 \u2194 \u03b8 = 0 \u2228 \u03b8 = \u03c0", "start": [890, 1], "end": [891, 54], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_ne_zero_iff", "code": "theorem sign_ne_zero_iff {\u03b8 : Angle} : \u03b8.sign \u2260 0 \u2194 \u03b8 \u2260 0 \u2227 \u03b8 \u2260 \u03c0", "start": [894, 1], "end": [895, 36], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_neg_iff_sign_neg", "code": "theorem toReal_neg_iff_sign_neg {\u03b8 : Angle} : \u03b8.toReal < 0 \u2194 \u03b8.sign = -1", "start": [898, 1], "end": [905, 86], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.toReal_nonneg_iff_sign_nonneg", "code": "theorem toReal_nonneg_iff_sign_nonneg {\u03b8 : Angle} : 0 \u2264 \u03b8.toReal \u2194 0 \u2264 \u03b8.sign", "start": [908, 1], "end": [916, 62], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_toReal", "code": "@[simp]\ntheorem sign_toReal {\u03b8 : Angle} (h : \u03b8 \u2260 \u03c0) : SignType.sign \u03b8.toReal = \u03b8.sign", "start": [919, 1], "end": [926, 93], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.coe_abs_toReal_of_sign_nonneg", "code": "theorem coe_abs_toReal_of_sign_nonneg {\u03b8 : Angle} (h : 0 \u2264 \u03b8.sign) : \u2191|\u03b8.toReal| = \u03b8", "start": [929, 1], "end": [930, 69], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.neg_coe_abs_toReal_of_sign_nonpos", "code": "theorem neg_coe_abs_toReal_of_sign_nonpos {\u03b8 : Angle} (h : \u03b8.sign \u2264 0) : -\u2191|\u03b8.toReal| = \u03b8", "start": [933, 1], "end": [938, 64], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.eq_iff_sign_eq_and_abs_toReal_eq", "code": "theorem eq_iff_sign_eq_and_abs_toReal_eq {\u03b8 \u03c8 : Angle} :\n    \u03b8 = \u03c8 \u2194 \u03b8.sign = \u03c8.sign \u2227 |\u03b8.toReal| = |\u03c8.toReal|", "start": [941, 1], "end": [959, 20], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.eq_iff_abs_toReal_eq_of_sign_eq", "code": "theorem eq_iff_abs_toReal_eq_of_sign_eq {\u03b8 \u03c8 : Angle} (h : \u03b8.sign = \u03c8.sign) :\n    \u03b8 = \u03c8 \u2194 |\u03b8.toReal| = |\u03c8.toReal|", "start": [962, 1], "end": [963, 96], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_coe_pi_div_two", "code": "@[simp]\ntheorem sign_coe_pi_div_two : (\u2191(\u03c0 / 2) : Angle).sign = 1", "start": [966, 1], "end": [968, 47], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_coe_neg_pi_div_two", "code": "@[simp]\ntheorem sign_coe_neg_pi_div_two : (\u2191(-\u03c0 / 2) : Angle).sign = -1", "start": [971, 1], "end": [973, 85], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_coe_nonneg_of_nonneg_of_le_pi", "code": "theorem sign_coe_nonneg_of_nonneg_of_le_pi {\u03b8 : \u211d} (h0 : 0 \u2264 \u03b8) (hpi : \u03b8 \u2264 \u03c0) :\n    0 \u2264 (\u03b8 : Angle).sign", "start": [976, 1], "end": [979, 45], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_neg_coe_nonpos_of_nonneg_of_le_pi", "code": "theorem sign_neg_coe_nonpos_of_nonneg_of_le_pi {\u03b8 : \u211d} (h0 : 0 \u2264 \u03b8) (hpi : \u03b8 \u2264 \u03c0) :\n    (-\u03b8 : Angle).sign \u2264 0", "start": [982, 1], "end": [985, 45], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_two_nsmul_eq_sign_iff", "code": "theorem sign_two_nsmul_eq_sign_iff {\u03b8 : Angle} :\n    ((2 : \u2115) \u2022 \u03b8).sign = \u03b8.sign \u2194 \u03b8 = \u03c0 \u2228 |\u03b8.toReal| < \u03c0 / 2", "start": [988, 1], "end": [1027, 52], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_two_zsmul_eq_sign_iff", "code": "theorem sign_two_zsmul_eq_sign_iff {\u03b8 : Angle} :\n    ((2 : \u2124) \u2022 \u03b8).sign = \u03b8.sign \u2194 \u03b8 = \u03c0 \u2228 |\u03b8.toReal| < \u03c0 / 2", "start": [1030, 1], "end": [1032, 58], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.continuousAt_sign", "code": "theorem continuousAt_sign {\u03b8 : Angle} (h0 : \u03b8 \u2260 0) (hpi : \u03b8 \u2260 \u03c0) : ContinuousAt sign \u03b8", "start": [1035, 1], "end": [1036, 96], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.angle_sign_comp", "code": "theorem _root_.ContinuousOn.angle_sign_comp {\u03b1 : Type*} [TopologicalSpace \u03b1] {f : \u03b1 \u2192 Angle}\n    {s : Set \u03b1} (hf : ContinuousOn f s) (hs : \u2200 z \u2208 s, f z \u2260 0 \u2227 f z \u2260 \u03c0) :\n    ContinuousOn (sign \u2218 f) s", "start": [1039, 1], "end": [1044, 50], "kind": "commanddeclaration"}, {"full_name": "Real.Angle.sign_eq_of_continuousOn", "code": "theorem sign_eq_of_continuousOn {\u03b1 : Type*} [TopologicalSpace \u03b1] {f : \u03b1 \u2192 Angle} {s : Set \u03b1}\n    {x y : \u03b1} (hc : IsConnected s) (hf : ContinuousOn f s) (hs : \u2200 z \u2208 s, f z \u2260 0 \u2227 f z \u2260 \u03c0)\n    (hx : x \u2208 s) (hy : y \u2208 s) : (f y).sign = (f x).sign", "start": [1047, 1], "end": [1053, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "Mathlib/Topology/Algebra/Order/ProjIcc.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.arcsin", "code": "noncomputable def arcsin : \u211d \u2192 \u211d :=\n  Subtype.val \u2218 IccExtend (neg_le_self zero_le_one) sinOrderIso.symm", "start": [31, 1], "end": [35, 69], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_mem_Icc", "code": "theorem arcsin_mem_Icc (x : \u211d) : arcsin x \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)", "start": [38, 1], "end": [39, 21], "kind": "commanddeclaration"}, {"full_name": "Real.range_arcsin", "code": "@[simp]\ntheorem range_arcsin : range arcsin = Icc (-(\u03c0 / 2)) (\u03c0 / 2)", "start": [42, 1], "end": [45, 13], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_le_pi_div_two", "code": "theorem arcsin_le_pi_div_two (x : \u211d) : arcsin x \u2264 \u03c0 / 2", "start": [48, 1], "end": [49, 23], "kind": "commanddeclaration"}, {"full_name": "Real.neg_pi_div_two_le_arcsin", "code": "theorem neg_pi_div_two_le_arcsin (x : \u211d) : -(\u03c0 / 2) \u2264 arcsin x", "start": [52, 1], "end": [53, 23], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_projIcc", "code": "theorem arcsin_projIcc (x : \u211d) : arcsin (projIcc (-1) 1 (neg_le_self zero_le_one) x) = arcsin x", "start": [56, 1], "end": [58, 29], "kind": "commanddeclaration"}, {"full_name": "Real.sin_arcsin'", "code": "theorem sin_arcsin' {x : \u211d} (hx : x \u2208 Icc (-1 : \u211d) 1) : sin (arcsin x) = x", "start": [61, 1], "end": [63, 61], "kind": "commanddeclaration"}, {"full_name": "Real.sin_arcsin", "code": "theorem sin_arcsin {x : \u211d} (hx\u2081 : -1 \u2264 x) (hx\u2082 : x \u2264 1) : sin (arcsin x) = x", "start": [66, 1], "end": [67, 25], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_sin'", "code": "theorem arcsin_sin' {x : \u211d} (hx : x \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)) : arcsin (sin x) = x", "start": [70, 1], "end": [71, 90], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_sin", "code": "theorem arcsin_sin {x : \u211d} (hx\u2081 : -(\u03c0 / 2) \u2264 x) (hx\u2082 : x \u2264 \u03c0 / 2) : arcsin (sin x) = x", "start": [74, 1], "end": [75, 25], "kind": "commanddeclaration"}, {"full_name": "Real.strictMonoOn_arcsin", "code": "theorem strictMonoOn_arcsin : StrictMonoOn arcsin (Icc (-1) 1)", "start": [78, 1], "end": [80, 57], "kind": "commanddeclaration"}, {"full_name": "Real.monotone_arcsin", "code": "theorem monotone_arcsin : Monotone arcsin", "start": [83, 1], "end": [84, 69], "kind": "commanddeclaration"}, {"full_name": "Real.injOn_arcsin", "code": "theorem injOn_arcsin : InjOn arcsin (Icc (-1) 1)", "start": [87, 1], "end": [88, 28], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_inj", "code": "theorem arcsin_inj {x y : \u211d} (hx\u2081 : -1 \u2264 x) (hx\u2082 : x \u2264 1) (hy\u2081 : -1 \u2264 y) (hy\u2082 : y \u2264 1) :\n    arcsin x = arcsin y \u2194 x = y", "start": [91, 1], "end": [93, 44], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_arcsin", "code": "@[continuity]\ntheorem continuous_arcsin : Continuous arcsin", "start": [96, 1], "end": [98, 70], "kind": "commanddeclaration"}, {"full_name": "Real.continuousAt_arcsin", "code": "theorem continuousAt_arcsin {x : \u211d} : ContinuousAt arcsin x", "start": [101, 1], "end": [102, 33], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_eq_of_sin_eq", "code": "theorem arcsin_eq_of_sin_eq {x y : \u211d} (h\u2081 : sin x = y) (h\u2082 : x \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)) :\n    arcsin y = x", "start": [105, 1], "end": [108, 70], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_zero", "code": "@[simp]\ntheorem arcsin_zero : arcsin 0 = 0", "start": [111, 1], "end": [113, 83], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_one", "code": "@[simp]\ntheorem arcsin_one : arcsin 1 = \u03c0 / 2", "start": [116, 1], "end": [118, 88], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_of_one_le", "code": "theorem arcsin_of_one_le {x : \u211d} (hx : 1 \u2264 x) : arcsin x = \u03c0 / 2", "start": [121, 1], "end": [122, 78], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_neg_one", "code": "theorem arcsin_neg_one : arcsin (-1) = -(\u03c0 / 2)", "start": [125, 1], "end": [127, 51], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_of_le_neg_one", "code": "theorem arcsin_of_le_neg_one {x : \u211d} (hx : x \u2264 -1) : arcsin x = -(\u03c0 / 2)", "start": [130, 1], "end": [131, 81], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_neg", "code": "@[simp]\ntheorem arcsin_neg (x : \u211d) : arcsin (-x) = -arcsin x", "start": [134, 1], "end": [142, 87], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_le_iff_le_sin", "code": "theorem arcsin_le_iff_le_sin {x y : \u211d} (hx : x \u2208 Icc (-1 : \u211d) 1) (hy : y \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)) :\n    arcsin x \u2264 y \u2194 x \u2264 sin y", "start": [145, 1], "end": [147, 90], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_le_iff_le_sin'", "code": "theorem arcsin_le_iff_le_sin' {x y : \u211d} (hy : y \u2208 Ico (-(\u03c0 / 2)) (\u03c0 / 2)) :\n    arcsin x \u2264 y \u2194 x \u2264 sin y", "start": [150, 1], "end": [156, 60], "kind": "commanddeclaration"}, {"full_name": "Real.le_arcsin_iff_sin_le", "code": "theorem le_arcsin_iff_sin_le {x y : \u211d} (hx : x \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)) (hy : y \u2208 Icc (-1 : \u211d) 1) :\n    x \u2264 arcsin y \u2194 sin x \u2264 y", "start": [159, 1], "end": [163, 20], "kind": "commanddeclaration"}, {"full_name": "Real.le_arcsin_iff_sin_le'", "code": "theorem le_arcsin_iff_sin_le' {x y : \u211d} (hx : x \u2208 Ioc (-(\u03c0 / 2)) (\u03c0 / 2)) :\n    x \u2264 arcsin y \u2194 sin x \u2264 y", "start": [166, 1], "end": [169, 29], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_lt_iff_lt_sin", "code": "theorem arcsin_lt_iff_lt_sin {x y : \u211d} (hx : x \u2208 Icc (-1 : \u211d) 1) (hy : y \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)) :\n    arcsin x < y \u2194 x < sin y", "start": [172, 1], "end": [174, 78], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_lt_iff_lt_sin'", "code": "theorem arcsin_lt_iff_lt_sin' {x y : \u211d} (hy : y \u2208 Ioc (-(\u03c0 / 2)) (\u03c0 / 2)) :\n    arcsin x < y \u2194 x < sin y", "start": [177, 1], "end": [179, 76], "kind": "commanddeclaration"}, {"full_name": "Real.lt_arcsin_iff_sin_lt", "code": "theorem lt_arcsin_iff_sin_lt {x y : \u211d} (hx : x \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)) (hy : y \u2208 Icc (-1 : \u211d) 1) :\n    x < arcsin y \u2194 sin x < y", "start": [182, 1], "end": [184, 78], "kind": "commanddeclaration"}, {"full_name": "Real.lt_arcsin_iff_sin_lt'", "code": "theorem lt_arcsin_iff_sin_lt' {x y : \u211d} (hx : x \u2208 Ico (-(\u03c0 / 2)) (\u03c0 / 2)) :\n    x < arcsin y \u2194 sin x < y", "start": [187, 1], "end": [189, 76], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_eq_iff_eq_sin", "code": "theorem arcsin_eq_iff_eq_sin {x y : \u211d} (hy : y \u2208 Ioo (-(\u03c0 / 2)) (\u03c0 / 2)) :\n    arcsin x = y \u2194 x = sin y", "start": [192, 1], "end": [195, 47], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_nonneg", "code": "@[simp]\ntheorem arcsin_nonneg {x : \u211d} : 0 \u2264 arcsin x \u2194 0 \u2264 x", "start": [198, 1], "end": [201, 18], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_nonpos", "code": "@[simp]\ntheorem arcsin_nonpos {x : \u211d} : arcsin x \u2264 0 \u2194 x \u2264 0", "start": [204, 1], "end": [206, 73], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_eq_zero_iff", "code": "@[simp]\ntheorem arcsin_eq_zero_iff {x : \u211d} : arcsin x = 0 \u2194 x = 0", "start": [209, 1], "end": [210, 87], "kind": "commanddeclaration"}, {"full_name": "Real.zero_eq_arcsin_iff", "code": "@[simp]\ntheorem zero_eq_arcsin_iff {x} : 0 = arcsin x \u2194 x = 0", "start": [213, 1], "end": [215, 35], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_pos", "code": "@[simp]\ntheorem arcsin_pos {x : \u211d} : 0 < arcsin x \u2194 0 < x", "start": [218, 1], "end": [220, 39], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_lt_zero", "code": "@[simp]\ntheorem arcsin_lt_zero {x : \u211d} : arcsin x < 0 \u2194 x < 0", "start": [223, 1], "end": [225, 39], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_lt_pi_div_two", "code": "@[simp]\ntheorem arcsin_lt_pi_div_two {x : \u211d} : arcsin x < \u03c0 / 2 \u2194 x < 1", "start": [228, 1], "end": [231, 24], "kind": "commanddeclaration"}, {"full_name": "Real.neg_pi_div_two_lt_arcsin", "code": "@[simp]\ntheorem neg_pi_div_two_lt_arcsin {x : \u211d} : -(\u03c0 / 2) < arcsin x \u2194 -1 < x", "start": [234, 1], "end": [237, 33], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_eq_pi_div_two", "code": "@[simp]\ntheorem arcsin_eq_pi_div_two {x : \u211d} : arcsin x = \u03c0 / 2 \u2194 1 \u2264 x", "start": [240, 1], "end": [242, 83], "kind": "commanddeclaration"}, {"full_name": "Real.pi_div_two_eq_arcsin", "code": "@[simp]\ntheorem pi_div_two_eq_arcsin {x} : \u03c0 / 2 = arcsin x \u2194 1 \u2264 x", "start": [245, 1], "end": [247, 37], "kind": "commanddeclaration"}, {"full_name": "Real.pi_div_two_le_arcsin", "code": "@[simp]\ntheorem pi_div_two_le_arcsin {x} : \u03c0 / 2 \u2264 arcsin x \u2194 1 \u2264 x", "start": [250, 1], "end": [252, 64], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_eq_neg_pi_div_two", "code": "@[simp]\ntheorem arcsin_eq_neg_pi_div_two {x : \u211d} : arcsin x = -(\u03c0 / 2) \u2194 x \u2264 -1", "start": [255, 1], "end": [257, 92], "kind": "commanddeclaration"}, {"full_name": "Real.neg_pi_div_two_eq_arcsin", "code": "@[simp]\ntheorem neg_pi_div_two_eq_arcsin {x} : -(\u03c0 / 2) = arcsin x \u2194 x \u2264 -1", "start": [260, 1], "end": [262, 41], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_le_neg_pi_div_two", "code": "@[simp]\ntheorem arcsin_le_neg_pi_div_two {x} : arcsin x \u2264 -(\u03c0 / 2) \u2194 x \u2264 -1", "start": [265, 1], "end": [267, 72], "kind": "commanddeclaration"}, {"full_name": "Real.pi_div_four_le_arcsin", "code": "@[simp]\ntheorem pi_div_four_le_arcsin {x} : \u03c0 / 4 \u2264 arcsin x \u2194 sqrt 2 / 2 \u2264 x", "start": [270, 1], "end": [274, 27], "kind": "commanddeclaration"}, {"full_name": "Real.mapsTo_sin_Ioo", "code": "theorem mapsTo_sin_Ioo : MapsTo sin (Ioo (-(\u03c0 / 2)) (\u03c0 / 2)) (Ioo (-1) 1)", "start": [277, 1], "end": [278, 94], "kind": "commanddeclaration"}, {"full_name": "Real.sinLocalHomeomorph", "code": "@[simp]\ndef sinLocalHomeomorph : LocalHomeomorph \u211d \u211d where\n  toFun := sin\n  invFun := arcsin\n  source := Ioo (-(\u03c0 / 2)) (\u03c0 / 2)\n  target := Ioo (-1) 1\n  map_source' := mapsTo_sin_Ioo\n  map_target' _ hy := \u27e8neg_pi_div_two_lt_arcsin.2 hy.1, arcsin_lt_pi_div_two.2 hy.2\u27e9\n  left_inv' _ hx := arcsin_sin hx.1.le hx.2.le\n  right_inv' _ hy := sin_arcsin hy.1.le hy.2.le\n  open_source := isOpen_Ioo\n  open_target := isOpen_Ioo\n  continuous_toFun := continuous_sin.continuousOn\n  continuous_invFun := continuous_arcsin.continuousOn", "start": [281, 1], "end": [295, 54], "kind": "commanddeclaration"}, {"full_name": "Real.cos_arcsin_nonneg", "code": "theorem cos_arcsin_nonneg (x : \u211d) : 0 \u2264 cos (arcsin x)", "start": [298, 1], "end": [299, 77], "kind": "commanddeclaration"}, {"full_name": "Real.cos_arcsin", "code": "theorem cos_arcsin (x : \u211d) : cos (arcsin x) = sqrt (1 - x ^ 2)", "start": [303, 1], "end": [315, 32], "kind": "commanddeclaration"}, {"full_name": "Real.tan_arcsin", "code": "theorem tan_arcsin (x : \u211d) : tan (arcsin x) = x / sqrt (1 - x ^ 2)", "start": [319, 1], "end": [329, 26], "kind": "commanddeclaration"}, {"full_name": "Real.arccos", "code": "noncomputable def arccos (x : \u211d) : \u211d :=\n  \u03c0 / 2 - arcsin x", "start": [332, 1], "end": [336, 19], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_eq_pi_div_two_sub_arcsin", "code": "theorem arccos_eq_pi_div_two_sub_arcsin (x : \u211d) : arccos x = \u03c0 / 2 - arcsin x", "start": [339, 1], "end": [340, 6], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_eq_pi_div_two_sub_arccos", "code": "theorem arcsin_eq_pi_div_two_sub_arccos (x : \u211d) : arcsin x = \u03c0 / 2 - arccos x", "start": [343, 1], "end": [343, 98], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_le_pi", "code": "theorem arccos_le_pi (x : \u211d) : arccos x \u2264 \u03c0", "start": [346, 1], "end": [347, 55], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_nonneg", "code": "theorem arccos_nonneg (x : \u211d) : 0 \u2264 arccos x", "start": [350, 1], "end": [351, 51], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_pos", "code": "@[simp]\ntheorem arccos_pos {x : \u211d} : 0 < arccos x \u2194 x < 1", "start": [354, 1], "end": [355, 70], "kind": "commanddeclaration"}, {"full_name": "Real.cos_arccos", "code": "theorem cos_arccos {x : \u211d} (hx\u2081 : -1 \u2264 x) (hx\u2082 : x \u2264 1) : cos (arccos x) = x", "start": [358, 1], "end": [359, 54], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_cos", "code": "theorem arccos_cos {x : \u211d} (hx\u2081 : 0 \u2264 x) (hx\u2082 : x \u2264 \u03c0) : arccos (cos x) = x", "start": [362, 1], "end": [363, 87], "kind": "commanddeclaration"}, {"full_name": "Real.strictAntiOn_arccos", "code": "theorem strictAntiOn_arccos : StrictAntiOn arccos (Icc (-1) 1)", "start": [366, 1], "end": [367, 50], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_injOn", "code": "theorem arccos_injOn : InjOn arccos (Icc (-1) 1)", "start": [370, 1], "end": [371, 28], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_inj", "code": "theorem arccos_inj {x y : \u211d} (hx\u2081 : -1 \u2264 x) (hx\u2082 : x \u2264 1) (hy\u2081 : -1 \u2264 y) (hy\u2082 : y \u2264 1) :\n    arccos x = arccos y \u2194 x = y", "start": [374, 1], "end": [376, 44], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_zero", "code": "@[simp]\ntheorem arccos_zero : arccos 0 = \u03c0 / 2", "start": [379, 1], "end": [380, 59], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_one", "code": "@[simp]\ntheorem arccos_one : arccos 1 = 0", "start": [383, 1], "end": [384, 54], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_neg_one", "code": "@[simp]\ntheorem arccos_neg_one : arccos (-1) = \u03c0", "start": [387, 1], "end": [388, 73], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_eq_zero", "code": "@[simp]\ntheorem arccos_eq_zero {x} : arccos x = 0 \u2194 1 \u2264 x", "start": [391, 1], "end": [392, 83], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_eq_pi_div_two", "code": "@[simp]\ntheorem arccos_eq_pi_div_two {x} : arccos x = \u03c0 / 2 \u2194 x = 0", "start": [395, 1], "end": [396, 80], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_eq_pi", "code": "@[simp]\ntheorem arccos_eq_pi {x} : arccos x = \u03c0 \u2194 x \u2264 -1", "start": [399, 1], "end": [401, 99], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_neg", "code": "theorem arccos_neg (x : \u211d) : arccos (-x) = \u03c0 - arccos x", "start": [404, 1], "end": [405, 95], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_of_one_le", "code": "theorem arccos_of_one_le {x : \u211d} (hx : 1 \u2264 x) : arccos x = 0", "start": [408, 1], "end": [409, 45], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_of_le_neg_one", "code": "theorem arccos_of_le_neg_one {x : \u211d} (hx : x \u2264 -1) : arccos x = \u03c0", "start": [412, 1], "end": [413, 68], "kind": "commanddeclaration"}, {"full_name": "Real.sin_arccos", "code": "theorem sin_arccos (x : \u211d) : sin (arccos x) = sqrt (1 - x ^ 2)", "start": [417, 1], "end": [426, 71], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_le_pi_div_two", "code": "@[simp]\ntheorem arccos_le_pi_div_two {x} : arccos x \u2264 \u03c0 / 2 \u2194 0 \u2264 x", "start": [429, 1], "end": [430, 80], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_lt_pi_div_two", "code": "@[simp]\ntheorem arccos_lt_pi_div_two {x : \u211d} : arccos x < \u03c0 / 2 \u2194 0 < x", "start": [433, 1], "end": [434, 84], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_le_pi_div_four", "code": "@[simp]\ntheorem arccos_le_pi_div_four {x} : arccos x \u2264 \u03c0 / 4 \u2194 sqrt 2 / 2 \u2264 x", "start": [437, 1], "end": [442, 15], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_arccos", "code": "@[continuity]\ntheorem continuous_arccos : Continuous arccos", "start": [445, 1], "end": [447, 41], "kind": "commanddeclaration"}, {"full_name": "Real.tan_arccos", "code": "theorem tan_arccos (x : \u211d) : tan (arccos x) = sqrt (1 - x ^ 2) / x", "start": [451, 1], "end": [452, 55], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_eq_arcsin", "code": "theorem arccos_eq_arcsin {x : \u211d} (h : 0 \u2264 x) : arccos x = arcsin (sqrt (1 - x ^ 2))", "start": [456, 1], "end": [459, 40], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_eq_arccos", "code": "theorem arcsin_eq_arccos {x : \u211d} (h : 0 \u2264 x) : arcsin x = arccos (sqrt (1 - x ^ 2))", "start": [463, 1], "end": [467, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Polynomial/Quotient.lean", "imports": ["Mathlib/Data/Polynomial/Div.lean", "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "Mathlib/RingTheory/Polynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.quotientSpanXSubCAlgEquivAux2", "code": "noncomputable def quotientSpanXSubCAlgEquivAux2 (x : R) :\n    (R[X] \u29f8 (RingHom.ker (aeval x).toRingHom : Ideal R[X])) \u2243\u2090[R] R :=\n  let e := RingHom.quotientKerEquivOfRightInverse (fun x => by\n    exact eval_C : Function.RightInverse (fun a : R => (C a : R[X])) (@aeval R R _ _ _ x))\n  { e with commutes' := fun r => e.apply_symm_apply r }", "start": [25, 1], "end": [29, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.quotientSpanXSubCAlgEquivAux1", "code": "noncomputable def quotientSpanXSubCAlgEquivAux1 (x : R) :\n    (R[X] \u29f8 Ideal.span {X - C x}) \u2243\u2090[R] (R[X] \u29f8 (RingHom.ker (aeval x).toRingHom : Ideal R[X])) :=\n  @Ideal.quotientEquivAlgOfEq R R[X] _ _ _ _ _ (ker_evalRingHom x).symm", "start": [31, 1], "end": [33, 72], "kind": "commanddeclaration"}, {"full_name": "Polynomial.quotientSpanXSubCAlgEquiv", "code": "noncomputable def quotientSpanXSubCAlgEquiv (x : R) :\n    (R[X] \u29f8 Ideal.span ({X - C x} : Set R[X])) \u2243\u2090[R] R :=\n  (quotientSpanXSubCAlgEquivAux1 x).trans (quotientSpanXSubCAlgEquivAux2 x)", "start": [36, 1], "end": [40, 76], "kind": "commanddeclaration"}, {"full_name": "Polynomial.quotientSpanXSubCAlgEquiv_mk", "code": "@[simp]\ntheorem quotientSpanXSubCAlgEquiv_mk (x : R) (p : R[X]) :\n    quotientSpanXSubCAlgEquiv x (Ideal.Quotient.mk _ p) = p.eval x", "start": [43, 1], "end": [46, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.quotientSpanXSubCAlgEquiv_symm_apply", "code": "@[simp]\ntheorem quotientSpanXSubCAlgEquiv_symm_apply (x : R) (y : R) :\n    (quotientSpanXSubCAlgEquiv x).symm y = algebraMap R _ y", "start": [49, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.quotientSpanCXSubCAlgEquiv", "code": "noncomputable def quotientSpanCXSubCAlgEquiv (x y : R) :\n    (R[X] \u29f8 (Ideal.span {C x, X - C y} : Ideal R[X])) \u2243\u2090[R] R \u29f8 (Ideal.span {x} : Ideal R) :=\n  (Ideal.quotientEquivAlgOfEq R <| by rw [Ideal.span_insert, sup_comm]).trans <|\n    (DoubleQuot.quotQuotEquivQuotSup\u2090 R _ _).symm.trans <|\n      (Ideal.quotientEquivAlg _ _ (quotientSpanXSubCAlgEquiv y) rfl).trans <|\n        Ideal.quotientEquivAlgOfEq R <| by\n          simp only [Ideal.map_span, Set.image_singleton]; congr 2; exact eval_C", "start": [55, 1], "end": [63, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.quotientSpanCXSubCXSubCAlgEquiv", "code": "noncomputable def quotientSpanCXSubCXSubCAlgEquiv {x : R} {y : R[X]} :\n    @AlgEquiv R (R[X][X] \u29f8 (Ideal.span {C (X - C x), X - C y} : Ideal <| R[X][X])) R _ _ _\n      (Ideal.Quotient.algebra R) _ :=\n((quotientSpanCXSubCAlgEquiv (X - C x) y).restrictScalars R).trans <| quotientSpanXSubCAlgEquiv x", "start": [66, 1], "end": [71, 98], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotient_map_C_eq_zero", "code": "theorem quotient_map_C_eq_zero {I : Ideal R} :\n    \u2200 a \u2208 I, ((Quotient.mk (map (C : R \u2192+* R[X]) I : Ideal R[X])).comp C) a = 0", "start": [83, 1], "end": [87, 28], "kind": "commanddeclaration"}, {"full_name": "Ideal.eval\u2082_C_mk_eq_zero", "code": "theorem eval\u2082_C_mk_eq_zero {I : Ideal R} :\n    \u2200 f \u2208 (map (C : R \u2192+* R[X]) I : Ideal R[X]), eval\u2082RingHom (C.comp (Quotient.mk I)) X f = 0", "start": [90, 1], "end": [103, 13], "kind": "commanddeclaration"}, {"full_name": "Ideal.polynomialQuotientEquivQuotientPolynomial", "code": "def polynomialQuotientEquivQuotientPolynomial (I : Ideal R) :\n    (R \u29f8 I)[X] \u2243+* R[X] \u29f8 (map C I : Ideal R[X]) where\n  toFun :=\n    eval\u2082RingHom\n      (Quotient.lift I ((Quotient.mk (map C I : Ideal R[X])).comp C) quotient_map_C_eq_zero)\n      (Quotient.mk (map C I : Ideal R[X]) X)\n  invFun :=\n    Quotient.lift (map C I : Ideal R[X]) (eval\u2082RingHom (C.comp (Quotient.mk I)) X)\n      eval\u2082_C_mk_eq_zero\n  map_mul' f g := by simp only [coe_eval\u2082RingHom, eval\u2082_mul]\n  map_add' f g := by simp only [eval\u2082_add, coe_eval\u2082RingHom]\n  left_inv := by\n    intro f\n    refine Polynomial.induction_on' f ?_ ?_\n    \u00b7 intro p q hp hq\n      simp only [coe_eval\u2082RingHom] at hp hq\n      simp only [coe_eval\u2082RingHom, hp, hq, RingHom.map_add]\n    \u00b7 rintro n \u27e8x\u27e9\n      simp only [\u2190 smul_X_eq_monomial, C_mul', Quotient.lift_mk, Submodule.Quotient.quot_mk_eq_mk,\n        Quotient.mk_eq_mk, eval\u2082_X_pow, eval\u2082_smul, coe_eval\u2082RingHom, RingHom.map_pow, eval\u2082_C,\n        RingHom.coe_comp, RingHom.map_mul, eval\u2082_X, Function.comp_apply]\n  right_inv := by\n    rintro \u27e8f\u27e9\n    refine Polynomial.induction_on' f ?_ ?_\n    \u00b7 intros p q hp hq\n      simp only [Submodule.Quotient.quot_mk_eq_mk, Quotient.mk_eq_mk, map_add, Quotient.lift_mk,\n        coe_eval\u2082RingHom] at hp hq \u22a2\n      rw [hp, hq]\n    \u00b7 intro n a\n      simp only [\u2190 smul_X_eq_monomial, \u2190 C_mul' a (X ^ n), Quotient.lift_mk,\n        Submodule.Quotient.quot_mk_eq_mk, Quotient.mk_eq_mk, eval\u2082_X_pow, eval\u2082_smul,\n        coe_eval\u2082RingHom, RingHom.map_pow, eval\u2082_C, RingHom.coe_comp, RingHom.map_mul, eval\u2082_X,\n        Function.comp_apply]", "start": [106, 1], "end": [142, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.polynomialQuotientEquivQuotientPolynomial_symm_mk", "code": "@[simp]\ntheorem polynomialQuotientEquivQuotientPolynomial_symm_mk (I : Ideal R) (f : R[X]) :\n    I.polynomialQuotientEquivQuotientPolynomial.symm (Quotient.mk _ f) = f.map (Quotient.mk I)", "start": [145, 1], "end": [150, 47], "kind": "commanddeclaration"}, {"full_name": "Ideal.polynomialQuotientEquivQuotientPolynomial_map_mk", "code": "@[simp]\ntheorem polynomialQuotientEquivQuotientPolynomial_map_mk (I : Ideal R) (f : R[X]) :\n    I.polynomialQuotientEquivQuotientPolynomial (f.map <| Quotient.mk I) =\n    Quotient.mk (map C I : Ideal R[X]) f", "start": [153, 1], "end": [158, 85], "kind": "commanddeclaration"}, {"full_name": "Ideal.isDomain_map_C_quotient", "code": "theorem isDomain_map_C_quotient {P : Ideal R} (_ : IsPrime P) :\n    IsDomain (R[X] \u29f8 (map (C : R \u2192+* R[X]) P : Ideal R[X]))", "start": [161, 1], "end": [164, 92], "kind": "commanddeclaration"}, {"full_name": "Ideal.eq_zero_of_polynomial_mem_map_range", "code": "theorem eq_zero_of_polynomial_mem_map_range (I : Ideal R[X]) (x : ((Quotient.mk I).comp C).range)\n    (hx : C x \u2208 I.map (Polynomial.mapRingHom ((Quotient.mk I).comp C).rangeRestrict)) : x = 0", "start": [167, 1], "end": [190, 11], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.quotient_map_C_eq_zero", "code": "theorem quotient_map_C_eq_zero {I : Ideal R} {i : R} (hi : i \u2208 I) :\n    (Ideal.Quotient.mk (Ideal.map (C : R \u2192+* MvPolynomial \u03c3 R) I :\n      Ideal (MvPolynomial \u03c3 R))).comp C i = 0", "start": [201, 1], "end": [205, 34], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_C_mk_eq_zero", "code": "theorem eval\u2082_C_mk_eq_zero {I : Ideal R} {a : MvPolynomial \u03c3 R}\n    (ha : a \u2208 (Ideal.map (C : R \u2192+* MvPolynomial \u03c3 R) I : Ideal (MvPolynomial \u03c3 R))) :\n    eval\u2082Hom (C.comp (Ideal.Quotient.mk I)) X a = 0", "start": [208, 1], "end": [219, 29], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.quotientEquivQuotientMvPolynomial_rightInverse", "code": "lemma quotientEquivQuotientMvPolynomial_rightInverse (I : Ideal R) :\n    Function.RightInverse\n      (eval\u2082 (Ideal.Quotient.lift I\n        ((Ideal.Quotient.mk (Ideal.map C I : Ideal (MvPolynomial \u03c3 R))).comp C)\n          fun i hi => quotient_map_C_eq_zero hi)\n          fun i => Ideal.Quotient.mk (Ideal.map C I : Ideal (MvPolynomial \u03c3 R)) (X i))\n      (Ideal.Quotient.lift (Ideal.map C I : Ideal (MvPolynomial \u03c3 R))\n        (eval\u2082Hom (C.comp (Ideal.Quotient.mk I)) X) fun a ha => eval\u2082_C_mk_eq_zero ha) := by\n  intro f\n  apply induction_on f\n  \u00b7 intro r\n    obtain \u27e8r, rfl\u27e9 := Ideal.Quotient.mk_surjective r\n    rw [eval\u2082_C, Ideal.Quotient.lift_mk, RingHom.comp_apply, Ideal.Quotient.lift_mk, eval\u2082Hom_C,\n      RingHom.comp_apply]\n  \u00b7 intros p q hp hq\n    simp only [RingHom.map_add, MvPolynomial.coe_eval\u2082Hom, coe_eval\u2082Hom, MvPolynomial.eval\u2082_add]\n      at hp hq \u22a2\n    rw [hp, hq]\n  \u00b7 intros p i hp\n    simp only [coe_eval\u2082Hom] at hp\n    simp only [hp, coe_eval\u2082Hom, Ideal.Quotient.lift_mk, eval\u2082_mul, RingHom.map_mul, eval\u2082_X]", "start": [222, 1], "end": [242, 94], "kind": "mathlibtacticlemma"}, {"full_name": "MvPolynomial.quotientEquivQuotientMvPolynomial_leftInverse", "code": "lemma quotientEquivQuotientMvPolynomial_leftInverse (I : Ideal R) :\n    Function.LeftInverse\n      (eval\u2082 (Ideal.Quotient.lift I\n        ((Ideal.Quotient.mk (Ideal.map C I : Ideal (MvPolynomial \u03c3 R))).comp C)\n          fun i hi => quotient_map_C_eq_zero hi)\n          fun i => Ideal.Quotient.mk (Ideal.map C I : Ideal (MvPolynomial \u03c3 R)) (X i))\n      (Ideal.Quotient.lift (Ideal.map C I : Ideal (MvPolynomial \u03c3 R))\n        (eval\u2082Hom (C.comp (Ideal.Quotient.mk I)) X) fun a ha => eval\u2082_C_mk_eq_zero ha) := by\n  intro f\n  obtain \u27e8f, rfl\u27e9 := Ideal.Quotient.mk_surjective f\n  apply induction_on f\n  \u00b7 intro r\n    rw [Ideal.Quotient.lift_mk, eval\u2082Hom_C, RingHom.comp_apply, eval\u2082_C, Ideal.Quotient.lift_mk,\n      RingHom.comp_apply]\n  \u00b7 intros p q hp hq\n    erw [Ideal.Quotient.lift_mk] at hp hq \u22a2\n    simp only [Submodule.Quotient.quot_mk_eq_mk, eval\u2082_add, RingHom.map_add, coe_eval\u2082Hom,\n      Ideal.Quotient.lift_mk, Ideal.Quotient.mk_eq_mk] at hp hq \u22a2\n    rw [hp, hq]\n  \u00b7 intros p i hp\n    simp only [Submodule.Quotient.quot_mk_eq_mk, coe_eval\u2082Hom, Ideal.Quotient.lift_mk,\n      Ideal.Quotient.mk_eq_mk, eval\u2082_mul, RingHom.map_mul, eval\u2082_X] at hp \u22a2\n    simp only [hp]", "start": [244, 1], "end": [266, 19], "kind": "mathlibtacticlemma"}, {"full_name": "MvPolynomial.quotientEquivQuotientMvPolynomial", "code": "noncomputable def quotientEquivQuotientMvPolynomial (I : Ideal R) :\n    MvPolynomial \u03c3 (R \u29f8 I) \u2243\u2090[R] MvPolynomial \u03c3 R \u29f8 (Ideal.map C I : Ideal (MvPolynomial \u03c3 R)) :=\n  let e : MvPolynomial \u03c3 (R \u29f8 I) \u2192\u2090[R]\n      MvPolynomial \u03c3 R \u29f8 (Ideal.map C I : Ideal (MvPolynomial \u03c3 R)) :=\n    { eval\u2082Hom\n      (Ideal.Quotient.lift I ((Ideal.Quotient.mk (Ideal.map C I : Ideal (MvPolynomial \u03c3 R))).comp C)\n        fun _ hi => quotient_map_C_eq_zero hi)\n      fun i => Ideal.Quotient.mk (Ideal.map C I : Ideal (MvPolynomial \u03c3 R)) (X i) with\n      commutes' := fun r => eval\u2082Hom_C _ _ (Ideal.Quotient.mk I r) }\n  { e with\n    invFun := Ideal.Quotient.lift (Ideal.map C I : Ideal (MvPolynomial \u03c3 R))\n      (eval\u2082Hom (C.comp (Ideal.Quotient.mk I)) X) fun _ ha => eval\u2082_C_mk_eq_zero ha\n    left_inv := quotientEquivQuotientMvPolynomial_rightInverse I\n    right_inv := quotientEquivQuotientMvPolynomial_leftInverse I }", "start": [269, 1], "end": [284, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/TensorProduct.lean", "imports": ["Mathlib/LinearAlgebra/TensorProduct/Tower.lean", "Mathlib/LinearAlgebra/FiniteDimensional.lean", "Mathlib/RingTheory/Adjoin/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/DirectSum/Finsupp.lean"], "premises": [{"full_name": "LinearMap.baseChange", "code": "def baseChange (f : M \u2192\u2097[R] N) : A \u2297[R] M \u2192\u2097[A] A \u2297[R] N :=\n  AlgebraTensorModule.map (LinearMap.id : A \u2192\u2097[A] A) f", "start": [67, 1], "end": [69, 55], "kind": "commanddeclaration"}, {"full_name": "LinearMap.baseChange_tmul", "code": "@[simp]\ntheorem baseChange_tmul (a : A) (x : M) : f.baseChange A (a \u2297\u209c x) = a \u2297\u209c f x", "start": [74, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.baseChange_eq_ltensor", "code": "theorem baseChange_eq_ltensor : (f.baseChange A : A \u2297 M \u2192 A \u2297 N) = f.lTensor A", "start": [79, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.baseChange_add", "code": "@[simp]\ntheorem baseChange_add : (f + g).baseChange A = f.baseChange A + g.baseChange A", "start": [83, 1], "end": [87, 49], "kind": "commanddeclaration"}, {"full_name": "LinearMap.baseChange_zero", "code": "@[simp]\ntheorem baseChange_zero : baseChange A (0 : M \u2192\u2097[R] N) = 0", "start": [90, 1], "end": [93, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.baseChange_smul", "code": "@[simp]\ntheorem baseChange_smul : (r \u2022 f).baseChange A = r \u2022 f.baseChange A", "start": [96, 1], "end": [99, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.baseChangeHom", "code": "@[simps]\ndef baseChangeHom : (M \u2192\u2097[R] N) \u2192\u2097[R] A \u2297[R] M \u2192\u2097[A] A \u2297[R] N where\n  toFun := baseChange A\n  map_add' := baseChange_add\n  map_smul' := baseChange_smul", "start": [104, 1], "end": [109, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.baseChange_sub", "code": "@[simp]\ntheorem baseChange_sub : (f - g).baseChange A = f.baseChange A - g.baseChange A", "start": [124, 1], "end": [128, 41], "kind": "commanddeclaration"}, {"full_name": "LinearMap.baseChange_neg", "code": "@[simp]\ntheorem baseChange_neg : (-f).baseChange A = -f.baseChange A", "start": [132, 1], "end": [136, 41], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.one_def", "code": "theorem one_def : (1 : A \u2297[R] B) = (1 : A) \u2297\u209c (1 : B)", "start": [163, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.instAddCommMonoidWithOne", "code": "instance instAddCommMonoidWithOne : AddCommMonoidWithOne (A \u2297[R] B) where\n  natCast n := n \u2297\u209c 1\n  natCast_zero := by simp\n  natCast_succ n := by simp [add_tmul, one_def]\n  add_comm := add_comm", "start": [167, 1], "end": [171, 23], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.natCast_def", "code": "theorem natCast_def (n : \u2115) : (n : A \u2297[R] B) = (n : A) \u2297\u209c (1 : B)", "start": [173, 1], "end": [173, 73], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.natCast_def'", "code": "theorem natCast_def' (n : \u2115) : (n : A \u2297[R] B) = (1 : A) \u2297\u209c (n : B)", "start": [175, 1], "end": [176, 53], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.mulAux", "code": "def mulAux (a\u2081 : A) (b\u2081 : B) : A \u2297[R] B \u2192\u2097[R] A \u2297[R] B :=\n  TensorProduct.map (LinearMap.mulLeft R a\u2081) (LinearMap.mulLeft R b\u2081)", "start": [186, 1], "end": [192, 70], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.mulAux_apply", "code": "@[simp]\ntheorem mulAux_apply (a\u2081 a\u2082 : A) (b\u2081 b\u2082 : B) :\n    (mulAux a\u2081 b\u2081) (a\u2082 \u2297\u209c[R] b\u2082) = (a\u2081 * a\u2082) \u2297\u209c[R] (b\u2081 * b\u2082)", "start": [195, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.mul", "code": "def mul : A \u2297[R] B \u2192\u2097[R] A \u2297[R] B \u2192\u2097[R] A \u2297[R] B :=\n  TensorProduct.lift <|\n    LinearMap.mk\u2082 R mulAux\n      (fun x\u2081 x\u2082 y =>\n        TensorProduct.ext' fun x' y' => by\n          simp only [mulAux_apply, LinearMap.add_apply, add_mul, add_tmul])\n      (fun c x y =>\n        TensorProduct.ext' fun x' y' => by\n          simp only [mulAux_apply, LinearMap.smul_apply, smul_tmul', smul_mul_assoc])\n      (fun x y\u2081 y\u2082 =>\n        TensorProduct.ext' fun x' y' => by\n          simp only [mulAux_apply, LinearMap.add_apply, add_mul, tmul_add])\n      fun c x y =>\n      TensorProduct.ext' fun x' y' => by\n        simp only [mulAux_apply, LinearMap.smul_apply, smul_tmul, smul_tmul', smul_mul_assoc]", "start": [201, 1], "end": [219, 94], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.mul_apply", "code": "@[simp]\ntheorem mul_apply (a\u2081 a\u2082 : A) (b\u2081 b\u2082 : B) :\n    mul (a\u2081 \u2297\u209c[R] b\u2081) (a\u2082 \u2297\u209c[R] b\u2082) = (a\u2081 * a\u2082) \u2297\u209c[R] (b\u2081 * b\u2082)", "start": [222, 1], "end": [225, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.instMul", "code": "instance instMul : Mul (A \u2297[R] B) where\n  mul a b := mul a b", "start": [229, 1], "end": [230, 21], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.tmul_mul_tmul", "code": "@[simp]\ntheorem tmul_mul_tmul (a\u2081 a\u2082 : A) (b\u2081 b\u2082 : B) :\n    a\u2081 \u2297\u209c[R] b\u2081 * a\u2082 \u2297\u209c[R] b\u2082 = (a\u2081 * a\u2082) \u2297\u209c[R] (b\u2081 * b\u2082)", "start": [232, 1], "end": [235, 6], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.tmul", "code": "theorem _root_.SemiconjBy.tmul {a\u2081 a\u2082 a\u2083 : A} {b\u2081 b\u2082 b\u2083 : B}\n    (ha : SemiconjBy a\u2081 a\u2082 a\u2083) (hb : SemiconjBy b\u2081 b\u2082 b\u2083) :\n    SemiconjBy (a\u2081 \u2297\u209c[R] b\u2081) (a\u2082 \u2297\u209c[R] b\u2082) (a\u2083 \u2297\u209c[R] b\u2083)", "start": [238, 1], "end": [241, 37], "kind": "commanddeclaration"}, {"full_name": "Commute.tmul", "code": "nonrec theorem _root_.Commute.tmul {a\u2081 a\u2082 : A} {b\u2081 b\u2082 : B}\n    (ha : Commute a\u2081 a\u2082) (hb : Commute b\u2081 b\u2082) :\n    Commute (a\u2081 \u2297\u209c[R] b\u2081) (a\u2082 \u2297\u209c[R] b\u2082)", "start": [243, 1], "end": [246, 13], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.instNonUnitalNonAssocSemiring", "code": "instance instNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring (A \u2297[R] B) where\n  left_distrib a b c := by simp [HMul.hMul, Mul.mul]\n  right_distrib a b c := by simp [HMul.hMul, Mul.mul]\n  zero_mul a := by simp [HMul.hMul, Mul.mul]\n  mul_zero a := by simp [HMul.hMul, Mul.mul]", "start": [248, 1], "end": [252, 45], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.isScalarTower_right", "code": "instance (priority := 100) isScalarTower_right [Monoid S] [DistribMulAction S A]\n    [IsScalarTower S A A] [SMulCommClass R S A] : IsScalarTower S (A \u2297[R] B) (A \u2297[R] B) where\n  smul_assoc r x y := by\n    change r \u2022 x * y = r \u2022 (x * y)\n    induction y using TensorProduct.induction_on with\n    | zero => simp [smul_zero]\n    | tmul a b => induction x using TensorProduct.induction_on with\n      | zero => simp [smul_zero]\n      | tmul a' b' =>\n        dsimp\n        rw [TensorProduct.smul_tmul', TensorProduct.smul_tmul', tmul_mul_tmul, smul_mul_assoc]\n      | add x y hx hy => simp [smul_add, add_mul _, *]\n    | add x y hx hy => simp [smul_add, mul_add _, *]", "start": [255, 1], "end": [267, 53], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.sMulCommClass_right", "code": "instance (priority := 100) sMulCommClass_right [Monoid S] [DistribMulAction S A]\n    [SMulCommClass S A A] [SMulCommClass R S A] : SMulCommClass S (A \u2297[R] B) (A \u2297[R] B) where\n  smul_comm r x y := by\n    change r \u2022 (x * y) = x * r \u2022 y\n    induction y using TensorProduct.induction_on with\n    | zero => simp [smul_zero]\n    | tmul a b => induction x using TensorProduct.induction_on with\n      | zero => simp [smul_zero]\n      | tmul a' b' =>\n        dsimp\n        rw [TensorProduct.smul_tmul', TensorProduct.smul_tmul', tmul_mul_tmul, mul_smul_comm]\n      | add x y hx hy => simp [smul_add, add_mul _, *]\n    | add x y hx hy => simp [smul_add, mul_add _, *]", "start": [271, 1], "end": [283, 53], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.one_mul", "code": "protected theorem one_mul (x : A \u2297[R] B) : mul (1 \u2297\u209c 1) x = x", "start": [294, 1], "end": [295, 91], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.mul_one", "code": "protected theorem mul_one (x : A \u2297[R] B) : mul x (1 \u2297\u209c 1) = x", "start": [298, 1], "end": [299, 91], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.instNonAssocSemiring", "code": "instance instNonAssocSemiring : NonAssocSemiring (A \u2297[R] B) where\n  one_mul := Algebra.TensorProduct.one_mul\n  mul_one := Algebra.TensorProduct.mul_one\n  toNonUnitalNonAssocSemiring := instNonUnitalNonAssocSemiring\n  __ := instAddCommMonoidWithOne", "start": [302, 1], "end": [306, 33], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.mul_assoc", "code": "protected theorem mul_assoc (x y z : A \u2297[R] B) : mul (mul x y) z = mul x (mul y z)", "start": [315, 1], "end": [321, 70], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.instNonUnitalSemiring", "code": "instance instNonUnitalSemiring : NonUnitalSemiring (A \u2297[R] B) where\n  mul_assoc := Algebra.TensorProduct.mul_assoc", "start": [324, 1], "end": [325, 47], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.instSemiring", "code": "instance instSemiring : Semiring (A \u2297[R] B) where\n  left_distrib a b c := by simp [HMul.hMul, Mul.mul]\n  right_distrib a b c := by simp [HMul.hMul, Mul.mul]\n  zero_mul a := by simp [HMul.hMul, Mul.mul]\n  mul_zero a := by simp [HMul.hMul, Mul.mul]\n  mul_assoc := Algebra.TensorProduct.mul_assoc\n  one_mul := Algebra.TensorProduct.one_mul\n  mul_one := Algebra.TensorProduct.mul_one\n  natCast_zero := AddMonoidWithOne.natCast_zero\n  natCast_succ := AddMonoidWithOne.natCast_succ", "start": [335, 1], "end": [344, 48], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.tmul_pow", "code": "@[simp]\ntheorem tmul_pow (a : A) (b : B) (k : \u2115) : a \u2297\u209c[R] b ^ k = (a ^ k) \u2297\u209c[R] (b ^ k)", "start": [346, 1], "end": [350, 24], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.includeLeftRingHom", "code": "@[simps]\ndef includeLeftRingHom : A \u2192+* A \u2297[R] B where\n  toFun a := a \u2297\u209c 1\n  map_zero' := by simp\n  map_add' := by simp [add_tmul]\n  map_one' := rfl\n  map_mul' := by simp", "start": [353, 1], "end": [360, 22], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.leftAlgebra", "code": "instance leftAlgebra [SMulCommClass R S A] : Algebra S (A \u2297[R] B) :=\n  { commutes' := fun r x => by\n      dsimp only [RingHom.toFun_eq_coe, RingHom.comp_apply, includeLeftRingHom_apply]\n      rw [algebraMap_eq_smul_one, \u2190 smul_tmul', \u2190 one_def, mul_smul_comm, smul_mul_assoc, mul_one,\n        one_mul]\n    smul_def' := fun r x => by\n      dsimp only [RingHom.toFun_eq_coe, RingHom.comp_apply, includeLeftRingHom_apply]\n      rw [algebraMap_eq_smul_one, \u2190 smul_tmul', smul_mul_assoc, \u2190 one_def, one_mul]\n    toRingHom := TensorProduct.includeLeftRingHom.comp (algebraMap S A) }", "start": [365, 1], "end": [373, 74], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.instAlgebra", "code": "instance instAlgebra : Algebra R (A \u2297[R] B) :=\n  inferInstance", "start": [379, 1], "end": [381, 16], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.algebraMap_apply", "code": "@[simp]\ntheorem algebraMap_apply [SMulCommClass R S A] (r : S) :\n    algebraMap S (A \u2297[R] B) r = (algebraMap S A) r \u2297\u209c 1", "start": [383, 1], "end": [386, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.algebraMap_apply'", "code": "theorem algebraMap_apply' (r : R) :\n    algebraMap R (A \u2297[R] B) r = 1 \u2297\u209c algebraMap R B r", "start": [389, 1], "end": [391, 99], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.includeLeft", "code": "def includeLeft [SMulCommClass R S A] : A \u2192\u2090[S] A \u2297[R] B :=\n  { includeLeftRingHom with commutes' := by simp }", "start": [393, 1], "end": [395, 51], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.includeLeft_apply", "code": "@[simp]\ntheorem includeLeft_apply [SMulCommClass R S A] (a : A) :\n    (includeLeft : A \u2192\u2090[S] A \u2297[R] B) a = a \u2297\u209c 1", "start": [398, 1], "end": [401, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.includeRight", "code": "def includeRight : B \u2192\u2090[R] A \u2297[R] B where\n  toFun b := 1 \u2297\u209c b\n  map_zero' := by simp\n  map_add' := by simp [tmul_add]\n  map_one' := rfl\n  map_mul' := by simp\n  commutes' r := by simp only [algebraMap_apply']", "start": [404, 1], "end": [411, 50], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.includeRight_apply", "code": "@[simp]\ntheorem includeRight_apply (b : B) : (includeRight : B \u2192\u2090[R] A \u2297[R] B) b = 1 \u2297\u209c b", "start": [414, 1], "end": [416, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.includeLeftRingHom_comp_algebraMap", "code": "theorem includeLeftRingHom_comp_algebraMap :\n    (includeLeftRingHom.comp (algebraMap R A) : R \u2192+* A \u2297[R] B) =\n      includeRight.toRingHom.comp (algebraMap R B)", "start": [419, 1], "end": [423, 7], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.ext", "code": "@[ext high]\ntheorem ext \u2983f g : (A \u2297[R] B) \u2192\u2090[S] C\u2984\n    (ha : f.comp includeLeft = g.comp includeLeft)\n    (hb : (f.restrictScalars R).comp includeRight = (g.restrictScalars R).comp includeRight) :\n    f = g", "start": [429, 1], "end": [445, 86], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.ext'", "code": "theorem ext' {g h : A \u2297[R] B \u2192\u2090[S] C} (H : \u2200 a b, g (a \u2297\u209c b) = h (a \u2297\u209c b)) : g = h", "start": [447, 1], "end": [448, 68], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.instAddCommGroupWithOne", "code": "instance instAddCommGroupWithOne : AddCommGroupWithOne (A \u2297[R] B) where\n  toAddCommGroup := TensorProduct.addCommGroup\n  __ := instAddCommMonoidWithOne\n  intCast z := z \u2297\u209c (1 : B)\n  intCast_ofNat n := by simp [natCast_def]\n  intCast_negSucc n := by simp [natCast_def, add_tmul, neg_tmul, one_def]", "start": [460, 1], "end": [465, 74], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.intCast_def", "code": "theorem intCast_def (z : \u2124) : (z : A \u2297[R] B) = (z : A) \u2297\u209c (1 : B)", "start": [467, 1], "end": [467, 73], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.instNonUnitalNonAssocRing", "code": "instance instNonUnitalNonAssocRing : NonUnitalNonAssocRing (A \u2297[R] B) where\n  toAddCommGroup := TensorProduct.addCommGroup\n  __ := instNonUnitalNonAssocSemiring", "start": [476, 1], "end": [478, 38], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.instNonAssocRing", "code": "instance instNonAssocRing : NonAssocRing (A \u2297[R] B) where\n  toAddCommGroup := TensorProduct.addCommGroup\n  __ := instNonAssocSemiring\n  __ := instAddCommGroupWithOne", "start": [487, 1], "end": [490, 32], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.instNonUnitalRing", "code": "instance instNonUnitalRing : NonUnitalRing (A \u2297[R] B) where\n  toAddCommGroup := TensorProduct.addCommGroup\n  __ := instNonUnitalSemiring", "start": [499, 1], "end": [501, 30], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.instRing", "code": "instance instRing : Ring (A \u2297[R] B) where\n  toSemiring := instSemiring\n  __ := TensorProduct.addCommGroup\n  __ := instNonAssocRing", "start": [510, 1], "end": [513, 25], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.intCast_def'", "code": "theorem intCast_def' (z : \u2124) : (z : A \u2297[R] B) = (1 : A) \u2297\u209c (z : B)", "start": [515, 1], "end": [516, 53], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.instCommRing", "code": "instance instCommRing : CommRing (A \u2297[R] B) :=\n  { toRing := inferInstance\n    mul_comm := fun x y => by\n      refine TensorProduct.induction_on x ?_ ?_ ?_\n      \u00b7 simp\n      \u00b7 intro a\u2081 b\u2081\n        refine TensorProduct.induction_on y ?_ ?_ ?_\n        \u00b7 simp\n        \u00b7 intro a\u2082 b\u2082\n          simp [mul_comm]\n        \u00b7 intro a\u2082 b\u2082 ha hb\n          rw [mul_add, add_mul, ha, hb]\n      \u00b7 intro x\u2081 x\u2082 h\u2081 h\u2082\n        rw [mul_add, add_mul, h\u2081, h\u2082] }", "start": [529, 1], "end": [544, 40], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.rightAlgebra", "code": "@[reducible]\ndef rightAlgebra : Algebra B (A \u2297[R] B) :=\n  (Algebra.TensorProduct.includeRight.toRingHom : B \u2192+* A \u2297[R] B).toAlgebra", "start": [548, 1], "end": [552, 76], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.right_isScalarTower", "code": "instance right_isScalarTower : IsScalarTower R B (A \u2297[R] B) :=\n  IsScalarTower.of_algebraMap_eq fun r => (Algebra.TensorProduct.includeRight.commutes r).symm", "start": [557, 1], "end": [558, 95], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.algHomOfLinearMapTensorProduct", "code": "def algHomOfLinearMapTensorProduct (f : A \u2297[R] B \u2192\u2097[S] C)\n    (h_mul : \u2200 (a\u2081 a\u2082 : A) (b\u2081 b\u2082 : B), f ((a\u2081 * a\u2082) \u2297\u209c (b\u2081 * b\u2082)) = f (a\u2081 \u2297\u209c b\u2081) * f (a\u2082 \u2297\u209c b\u2082))\n    (h_one : f (1 \u2297\u209c[R] 1) = 1) : A \u2297[R] B \u2192\u2090[S] C :=\n  AlgHom.ofLinearMap f h_one <| f.map_mul_iff.2 <| by\n    letI : Algebra R C := RestrictScalars.algebra R S C\n    letI : IsScalarTower R S C := RestrictScalars.isScalarTower R S C\n    ext\n    exact h_mul _ _ _ _", "start": [589, 1], "end": [603, 24], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.algHomOfLinearMapTensorProduct_apply", "code": "@[simp]\ntheorem algHomOfLinearMapTensorProduct_apply (f h_mul h_one x) :\n    (algHomOfLinearMapTensorProduct f h_mul h_one : A \u2297[R] B \u2192\u2090[S] C) x = f x", "start": [606, 1], "end": [609, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.algEquivOfLinearEquivTensorProduct", "code": "def algEquivOfLinearEquivTensorProduct (f : A \u2297[R] B \u2243\u2097[S] C)\n    (h_mul : \u2200 (a\u2081 a\u2082 : A) (b\u2081 b\u2082 : B), f ((a\u2081 * a\u2082) \u2297\u209c (b\u2081 * b\u2082)) = f (a\u2081 \u2297\u209c b\u2081) * f (a\u2082 \u2297\u209c b\u2082))\n    (h_one : f (1 \u2297\u209c[R] 1) = 1) : A \u2297[R] B \u2243\u2090[S] C :=\n  { algHomOfLinearMapTensorProduct (f : A \u2297[R] B \u2192\u2097[S] C) h_mul h_one, f with }", "start": [612, 1], "end": [621, 80], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.algEquivOfLinearEquivTensorProduct_apply", "code": "@[simp]\ntheorem algEquivOfLinearEquivTensorProduct_apply (f h_mul h_one x) :\n    (algEquivOfLinearEquivTensorProduct f h_mul h_one : A \u2297[R] B \u2243\u2090[S] C) x = f x", "start": [624, 1], "end": [627, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.algEquivOfLinearEquivTripleTensorProduct", "code": "def algEquivOfLinearEquivTripleTensorProduct (f : (A \u2297[R] B) \u2297[R] C \u2243\u2097[R] D)\n    (h_mul :\n      \u2200 (a\u2081 a\u2082 : A) (b\u2081 b\u2082 : B) (c\u2081 c\u2082 : C),\n        f ((a\u2081 * a\u2082) \u2297\u209c (b\u2081 * b\u2082) \u2297\u209c (c\u2081 * c\u2082)) = f (a\u2081 \u2297\u209c b\u2081 \u2297\u209c c\u2081) * f (a\u2082 \u2297\u209c b\u2082 \u2297\u209c c\u2082))\n    (h_one : f (((1 : A) \u2297\u209c[R] (1 : B)) \u2297\u209c[R] (1 : C)) = 1) :\n    (A \u2297[R] B) \u2297[R] C \u2243\u2090[R] D :=\n  AlgEquiv.ofLinearEquiv f h_one <| f.map_mul_iff.2 <| by\n    ext\n    exact h_mul _ _ _ _ _ _", "start": [630, 1], "end": [641, 28], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.algEquivOfLinearEquivTripleTensorProduct_apply", "code": "@[simp]\ntheorem algEquivOfLinearEquivTripleTensorProduct_apply (f h_mul h_one x) :\n    (algEquivOfLinearEquivTripleTensorProduct f h_mul h_one : (A \u2297[R] B) \u2297[R] C \u2243\u2090[R] D) x = f x", "start": [644, 1], "end": [647, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.lift", "code": "def lift (f : A \u2192\u2090[S] C) (g : B \u2192\u2090[R] C) (hfg : \u2200 x y, Commute (f x) (g y)) : (A \u2297[R] B) \u2192\u2090[S] C :=\n  algHomOfLinearMapTensorProduct\n    (AlgebraTensorModule.lift <|\n      letI restr : (C \u2192\u2097[S] C) \u2192\u2097[S] _ :=\n        { toFun := (\u00b7.restrictScalars R)\n          map_add' := fun f g => LinearMap.ext fun x => rfl\n          map_smul' := fun c g => LinearMap.ext fun x => rfl }\n      LinearMap.flip <| (restr \u2218\u2097 LinearMap.mul S C \u2218\u2097 f.toLinearMap).flip \u2218\u2097 g)\n    (fun a\u2081 a\u2082 b\u2081 b\u2082 => show f (a\u2081 * a\u2082) * g (b\u2081 * b\u2082) = f a\u2081 * g b\u2081 * (f a\u2082 * g b\u2082) by\n      rw [f.map_mul, g.map_mul, (hfg a\u2082 b\u2081).mul_mul_mul_comm])\n    (show f 1 * g 1 = 1 by rw [f.map_one, g.map_one, one_mul])", "start": [653, 1], "end": [668, 63], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.lift_tmul", "code": "@[simp]\ntheorem lift_tmul (f : A \u2192\u2090[S] C) (g : B \u2192\u2090[R] C) (hfg : \u2200 x y, Commute (f x) (g y))\n    (a : A) (b : B) :\n    lift f g hfg (a \u2297\u209c b) = f a * g b", "start": [670, 1], "end": [674, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.lift_includeLeft_includeRight", "code": "@[simp]\ntheorem lift_includeLeft_includeRight :\n    lift includeLeft includeRight (fun a b => (Commute.one_right _).tmul (Commute.one_left _)) =\n      .id S (A \u2297[R] B)", "start": [676, 1], "end": [680, 15], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.lift_comp_includeLeft", "code": "@[simp]\ntheorem lift_comp_includeLeft (f : A \u2192\u2090[S] C) (g : B \u2192\u2090[R] C) (hfg : \u2200 x y, Commute (f x) (g y)) :\n    (lift f g hfg).comp includeLeft = f", "start": [682, 1], "end": [685, 24], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.lift_comp_includeRight", "code": "@[simp]\ntheorem lift_comp_includeRight (f : A \u2192\u2090[S] C) (g : B \u2192\u2090[R] C) (hfg : \u2200 x y, Commute (f x) (g y)) :\n    ((lift f g hfg).restrictScalars R).comp includeRight = g", "start": [687, 1], "end": [690, 24], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.liftEquiv", "code": "@[simps]\ndef liftEquiv [IsScalarTower R S A] [IsScalarTower R S C] :\n    {fg : (A \u2192\u2090[S] C) \u00d7 (B \u2192\u2090[R] C) // \u2200 x y, Commute (fg.1 x) (fg.2 y)}\n      \u2243 ((A \u2297[R] B) \u2192\u2090[S] C) where\n  toFun fg := lift fg.val.1 fg.val.2 fg.prop\n  invFun f' := \u27e8(f'.comp includeLeft, (f'.restrictScalars R).comp includeRight), fun x y =>\n    ((Commute.one_right _).tmul (Commute.one_left _)).map f'\u27e9\n  left_inv fg := by ext <;> simp\n  right_inv f' := by ext <;> simp", "start": [692, 1], "end": [705, 34], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.lid", "code": "protected nonrec def lid : R \u2297[R] A \u2243\u2090[R] A :=\n  algEquivOfLinearEquivTensorProduct (TensorProduct.lid R A) (by\n    simp only [mul_smul, lid_tmul, Algebra.smul_mul_assoc, Algebra.mul_smul_comm]\n    simp_rw [\u2190 mul_smul, mul_comm]\n    simp)\n    (by simp [Algebra.smul_def])", "start": [723, 1], "end": [730, 33], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.lid_toLinearEquiv", "code": "@[simp] theorem lid_toLinearEquiv :\n    (TensorProduct.lid R A).toLinearEquiv = _root_.TensorProduct.lid R A", "start": [733, 1], "end": [734, 80], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.lid_tmul", "code": "@[simp]\ntheorem lid_tmul (r : R) (a : A) : (TensorProduct.lid R A : R \u2297 A \u2192 A) (r \u2297\u209c a) = r \u2022 a", "start": [736, 1], "end": [737, 95], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.rid", "code": "protected nonrec def rid : A \u2297[R] R \u2243\u2090[S] A :=\n  algEquivOfLinearEquivTensorProduct (AlgebraTensorModule.rid R S A)\n    (fun _a\u2081 _a\u2082 _r\u2081 _r\u2082 => smul_mul_smul _ _ _ _ |>.symm)\n    (one_smul _ _)", "start": [742, 1], "end": [749, 19], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.rid_toLinearEquiv", "code": "@[simp] theorem rid_toLinearEquiv :\n    (TensorProduct.rid R S A).toLinearEquiv = AlgebraTensorModule.rid R S A", "start": [752, 1], "end": [753, 83], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.rid_tmul", "code": "@[simp]\ntheorem rid_tmul (r : R) (a : A) : TensorProduct.rid R S A (a \u2297\u209c r) = r \u2022 a", "start": [756, 1], "end": [757, 83], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.comm", "code": "protected def comm : A \u2297[R] B \u2243\u2090[R] B \u2297[R] A :=\n  algEquivOfLinearEquivTensorProduct (_root_.TensorProduct.comm R A B) (fun _ _ _ _ => rfl) rfl", "start": [765, 1], "end": [768, 96], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.comm_toLinearEquiv", "code": "@[simp] theorem comm_toLinearEquiv :\n    (Algebra.TensorProduct.comm R A B).toLinearEquiv = _root_.TensorProduct.comm R A B", "start": [771, 1], "end": [772, 94], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.comm_tmul", "code": "@[simp]\ntheorem comm_tmul (a : A) (b : B) :\n    (TensorProduct.comm R A B : A \u2297[R] B \u2192 B \u2297[R] A) (a \u2297\u209c b) = b \u2297\u209c a", "start": [774, 1], "end": [777, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.adjoin_tmul_eq_top", "code": "theorem adjoin_tmul_eq_top : adjoin R { t : A \u2297[R] B | \u2203 a b, a \u2297\u209c[R] b = t } = \u22a4", "start": [780, 1], "end": [781, 89], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.assoc_aux_1", "code": "theorem assoc_aux_1 (a\u2081 a\u2082 : A) (b\u2081 b\u2082 : B) (c\u2081 c\u2082 : C) :\n    (TensorProduct.assoc R A B C) (((a\u2081 * a\u2082) \u2297\u209c[R] (b\u2081 * b\u2082)) \u2297\u209c[R] (c\u2081 * c\u2082)) =\n      (TensorProduct.assoc R A B C) ((a\u2081 \u2297\u209c[R] b\u2081) \u2297\u209c[R] c\u2081) *\n        (TensorProduct.assoc R A B C) ((a\u2082 \u2297\u209c[R] b\u2082) \u2297\u209c[R] c\u2082)", "start": [790, 1], "end": [794, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.assoc_aux_2", "code": "theorem assoc_aux_2 : (TensorProduct.assoc R A B C) ((1 \u2297\u209c[R] 1) \u2297\u209c[R] 1) = 1", "start": [797, 1], "end": [798, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.assoc", "code": "protected def assoc : (A \u2297[R] B) \u2297[R] C \u2243\u2090[R] A \u2297[R] B \u2297[R] C :=\n  algEquivOfLinearEquivTripleTensorProduct\n    (_root_.TensorProduct.assoc R A B C)\n    Algebra.TensorProduct.assoc_aux_1\n    Algebra.TensorProduct.assoc_aux_2", "start": [804, 1], "end": [809, 38], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.assoc_toLinearEquiv", "code": "@[simp] theorem assoc_toLinearEquiv :\n  (Algebra.TensorProduct.assoc R A B C).toLinearEquiv = _root_.TensorProduct.assoc R A B C", "start": [812, 1], "end": [813, 98], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.assoc_tmul", "code": "@[simp]\ntheorem assoc_tmul (a : A) (b : B) (c : C) :\n    Algebra.TensorProduct.assoc R A B C (a \u2297\u209c b \u2297\u209c c) = a \u2297\u209c (b \u2297\u209c c)", "start": [817, 1], "end": [820, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.map", "code": "def map (f : A \u2192\u2090[S] B) (g : C \u2192\u2090[R] D) : A \u2297[R] C \u2192\u2090[S] B \u2297[R] D :=\n  algHomOfLinearMapTensorProduct (AlgebraTensorModule.map f.toLinearMap g.toLinearMap) (by simp)\n    (by simp [one_def])", "start": [827, 1], "end": [830, 24], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.map_tmul", "code": "@[simp]\ntheorem map_tmul (f : A \u2192\u2090[S] B) (g : C \u2192\u2090[R] D) (a : A) (c : C) : map f g (a \u2297\u209c c) = f a \u2297\u209c g c", "start": [833, 1], "end": [835, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.map_id", "code": "@[simp]\ntheorem map_id : map (.id S A) (.id R C) = .id S _", "start": [838, 1], "end": [840, 58], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.map_comp", "code": "theorem map_comp (f\u2082 : B \u2192\u2090[S] C) (f\u2081 : A \u2192\u2090[S] B) (g\u2082 : E \u2192\u2090[R] F) (g\u2081 : D \u2192\u2090[R] E) :\n    map (f\u2082.comp f\u2081) (g\u2082.comp g\u2081) = (map f\u2082 g\u2082).comp (map f\u2081 g\u2081)", "start": [842, 1], "end": [844, 58], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.map_comp_includeLeft", "code": "@[simp]\ntheorem map_comp_includeLeft (f : A \u2192\u2090[S] B) (g : C \u2192\u2090[R] D) :\n    (map f g).comp includeLeft = includeLeft.comp f", "start": [846, 1], "end": [849, 24], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.map_restrictScalars_comp_includeRight", "code": "@[simp]\ntheorem map_restrictScalars_comp_includeRight (f : A \u2192\u2090[S] B) (g : C \u2192\u2090[R] D) :\n    ((map f g).restrictScalars R).comp includeRight = includeRight.comp g", "start": [852, 1], "end": [855, 24], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.map_comp_includeRight", "code": "@[simp]\ntheorem map_comp_includeRight (f : A \u2192\u2090[R] B) (g : C \u2192\u2090[R] D) :\n    (map f g).comp includeRight = includeRight.comp g", "start": [857, 1], "end": [860, 44], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.map_range", "code": "theorem map_range (f : A \u2192\u2090[R] B) (g : C \u2192\u2090[R] D) :\n    (map f g).range = (includeLeft.comp f).range \u2294 (includeRight.comp g).range", "start": [864, 1], "end": [872, 83], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.congr", "code": "def congr (f : A \u2243\u2090[S] B) (g : C \u2243\u2090[R] D) : A \u2297[R] C \u2243\u2090[S] B \u2297[R] D :=\n  AlgEquiv.ofAlgHom (map f g) (map f.symm g.symm)\n    (ext' fun b d => by simp) (ext' fun a c => by simp)", "start": [875, 1], "end": [880, 56], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.congr_toLinearEquiv", "code": "@[simp] theorem congr_toLinearEquiv (f : A \u2243\u2090[S] B) (g : C \u2243\u2090[R] D) :\n    (Algebra.TensorProduct.congr f g).toLinearEquiv =\n      TensorProduct.AlgebraTensorModule.congr f.toLinearEquiv g.toLinearEquiv", "start": [883, 1], "end": [885, 85], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.congr_apply", "code": "@[simp]\ntheorem congr_apply (f : A \u2243\u2090[S] B) (g : C \u2243\u2090[R] D) (x) :\n    congr f g x = (map (f : A \u2192\u2090[S] B) (g : C \u2192\u2090[R] D)) x", "start": [887, 1], "end": [890, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.congr_symm_apply", "code": "@[simp]\ntheorem congr_symm_apply (f : A \u2243\u2090[S] B) (g : C \u2243\u2090[R] D) (x) :\n    (congr f g).symm x = (map (f.symm : B \u2192\u2090[S] A) (g.symm : D \u2192\u2090[R] C)) x", "start": [893, 1], "end": [896, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.congr_refl", "code": "@[simp]\ntheorem congr_refl : congr (.refl : A \u2243\u2090[S] A) (.refl : C \u2243\u2090[R] C) = .refl", "start": [899, 1], "end": [901, 42], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.congr_trans", "code": "theorem congr_trans (f\u2081 : A \u2243\u2090[S] B) (f\u2082 : B \u2243\u2090[S] C) (g\u2081 : D \u2243\u2090[R] E) (g\u2082 : E \u2243\u2090[R] F) :\n    congr (f\u2081.trans f\u2082) (g\u2081.trans g\u2082) = (congr f\u2081 g\u2081).trans (congr f\u2082 g\u2082)", "start": [903, 1], "end": [905, 92], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.congr_symm", "code": "theorem congr_symm (f : A \u2243\u2090[S] B) (g : C \u2243\u2090[R] D) : congr f.symm g.symm = (congr f g).symm", "start": [907, 1], "end": [907, 99], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.productLeftAlgHom", "code": "abbrev productLeftAlgHom (f : A \u2192\u2090[S] C) (g : B \u2192\u2090[R] C) : A \u2297[R] B \u2192\u2090[S] C :=\n  lift f g (fun _ _ => Commute.all _ _)", "start": [920, 1], "end": [926, 40], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.lmul'", "code": "def lmul' : S \u2297[R] S \u2192\u2090[R] S :=\n  algHomOfLinearMapTensorProduct (LinearMap.mul' R S)\n    (fun a\u2081 a\u2082 b\u2081 b\u2082 => by simp only [LinearMap.mul'_apply, mul_mul_mul_comm]) <| by\n    simp only [LinearMap.mul'_apply, _root_.mul_one]", "start": [941, 1], "end": [945, 53], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.lmul'_toLinearMap", "code": "theorem lmul'_toLinearMap : (lmul' R : _ \u2192\u2090[R] S).toLinearMap = LinearMap.mul' R S", "start": [950, 1], "end": [951, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.lmul'_apply_tmul", "code": "@[simp]\ntheorem lmul'_apply_tmul (a b : S) : lmul' (S := S) R (a \u2297\u209c[R] b) = a * b", "start": [954, 1], "end": [956, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.lmul'_comp_includeLeft", "code": "@[simp]\ntheorem lmul'_comp_includeLeft : (lmul' R : _ \u2192\u2090[R] S).comp includeLeft = AlgHom.id R S", "start": [959, 1], "end": [961, 31], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.lmul'_comp_includeRight", "code": "@[simp]\ntheorem lmul'_comp_includeRight : (lmul' R : _ \u2192\u2090[R] S).comp includeRight = AlgHom.id R S", "start": [964, 1], "end": [966, 31], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.productMap", "code": "def productMap : A \u2297[R] B \u2192\u2090[R] S := productLeftAlgHom f g", "start": [969, 1], "end": [975, 59], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.productMap_eq_comp_map", "code": "theorem productMap_eq_comp_map : productMap f g = (lmul' R).comp (TensorProduct.map f g)", "start": [978, 1], "end": [979, 14], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.productMap_apply_tmul", "code": "@[simp]\ntheorem productMap_apply_tmul (a : A) (b : B) : productMap f g (a \u2297\u209c b) = f a * g b", "start": [981, 1], "end": [982, 91], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.productMap_left_apply", "code": "theorem productMap_left_apply (a : A) : productMap f g (a \u2297\u209c 1) = f a", "start": [986, 1], "end": [987, 7], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.productMap_left", "code": "@[simp]\ntheorem productMap_left : (productMap f g).comp includeLeft = f", "start": [990, 1], "end": [992, 57], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.productMap_right_apply", "code": "theorem productMap_right_apply (b : B) :\n    productMap f g (1 \u2297\u209c b) = g b", "start": [995, 1], "end": [996, 45], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.productMap_right", "code": "@[simp]\ntheorem productMap_right : (productMap f g).comp includeRight = g", "start": [999, 1], "end": [1001, 58], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.productMap_range", "code": "theorem productMap_range : (productMap f g).range = f.range \u2294 g.range", "start": [1004, 1], "end": [1008, 36], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.basisAux", "code": "noncomputable def basisAux : A \u2297[R] M \u2243\u2097[R] \u03b9 \u2192\u2080 A :=\n  _root_.TensorProduct.congr (Finsupp.LinearEquiv.finsuppUnique R A PUnit.{u\u03b9+1}).symm b.repr \u226a\u226b\u2097\n    (finsuppTensorFinsupp R A R PUnit \u03b9).trans\n      (Finsupp.lcongr (Equiv.uniqueProd \u03b9 PUnit) (_root_.TensorProduct.rid R A))", "start": [1021, 1], "end": [1026, 81], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.basisAux_tmul", "code": "theorem basisAux_tmul (a : A) (m : M) :\n    basisAux A b (a \u2297\u209c m) = a \u2022 Finsupp.mapRange (algebraMap R A) (map_zero _) (b.repr m)", "start": [1031, 1], "end": [1034, 56], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.basisAux_map_smul", "code": "theorem basisAux_map_smul (a : A) (x : A \u2297[R] M) : basisAux A b (a \u2022 x) = a \u2022 basisAux A b x", "start": [1037, 1], "end": [1040, 38], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.basis", "code": "noncomputable def basis : Basis \u03b9 A (A \u2297[R] M) where\n  repr := { basisAux A b with map_smul' := basisAux_map_smul b }", "start": [1045, 1], "end": [1047, 65], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.basis_repr_tmul", "code": "@[simp]\ntheorem basis_repr_tmul (a : A) (m : M) :\n    (basis A b).repr (a \u2297\u209c m) = a \u2022 Finsupp.mapRange (algebraMap R A) (map_zero _) (b.repr m)", "start": [1052, 1], "end": [1055, 22], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.basis_repr_symm_apply", "code": "theorem basis_repr_symm_apply (a : A) (i : \u03b9) :\n    (basis A b).repr.symm (Finsupp.single i a) = a \u2297\u209c b.repr.symm (Finsupp.single i 1)", "start": [1058, 1], "end": [1061, 47], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.basis_repr_symm_apply'", "code": "@[simp]\ntheorem basis_repr_symm_apply' (a : A) (i : \u03b9) :\n    a \u2022 Algebra.TensorProduct.basis A b i = a \u2297\u209c b i", "start": [1064, 1], "end": [1067, 42], "kind": "commanddeclaration"}, {"full_name": "Module.endTensorEndAlgHom", "code": "def endTensorEndAlgHom : End A M \u2297[R] End R N \u2192\u2090[S] End A (M \u2297[R] N) :=\n  Algebra.TensorProduct.algHomOfLinearMapTensorProduct\n    (AlgebraTensorModule.homTensorHomMap R A S M N M N)\n    (fun _f\u2081 _f\u2082 _g\u2081 _g\u2082 => AlgebraTensorModule.ext fun _m _n => rfl)\n    (AlgebraTensorModule.ext fun _m _n => rfl)", "start": [1085, 1], "end": [1094, 47], "kind": "commanddeclaration"}, {"full_name": "Module.endTensorEndAlgHom_apply", "code": "theorem endTensorEndAlgHom_apply (f : End A M) (g : End R N) :\n    endTensorEndAlgHom (R := R) (S := S) (A := A) (M := M) (N := N) (f \u2297\u209c[R] g)\n      = AlgebraTensorModule.map f g", "start": [1097, 1], "end": [1100, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.finiteDimensional_sup", "code": "theorem Subalgebra.finiteDimensional_sup {K L : Type*} [Field K] [CommRing L] [Algebra K L]\n    (E1 E2 : Subalgebra K L) [FiniteDimensional K E1] [FiniteDimensional K E2] :\n    FiniteDimensional K (E1 \u2294 E2 : Subalgebra K L)", "start": [1105, 1], "end": [1109, 93], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.Algebra.moduleAux", "code": "def moduleAux : A \u2297[R] B \u2192\u2097[R] M \u2192\u2097[R] M :=\n  TensorProduct.lift\n    { toFun := fun a => a \u2022 (Algebra.lsmul R R M : B \u2192\u2090[R] Module.End R M).toLinearMap\n      map_add' := fun r t => by\n        ext\n        simp only [add_smul, LinearMap.add_apply]\n      map_smul' := fun n r => by\n        ext\n        simp only [RingHom.id_apply, LinearMap.smul_apply, smul_assoc] }", "start": [1124, 1], "end": [1134, 73], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.Algebra.moduleAux_apply", "code": "theorem moduleAux_apply (a : A) (b : B) (m : M) : moduleAux (a \u2297\u209c[R] b) m = a \u2022 b \u2022 m", "start": [1137, 1], "end": [1138, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.Algebra.module", "code": "protected def module : Module (A \u2297[R] B) M where\n  smul x m := moduleAux x m\n  zero_smul m := by simp only [(\u00b7 \u2022 \u00b7), map_zero, LinearMap.zero_apply]\n  smul_zero x := by simp only [(\u00b7 \u2022 \u00b7), map_zero]\n  smul_add x m\u2081 m\u2082 := by simp only [(\u00b7 \u2022 \u00b7), map_add]\n  add_smul x y m := by simp only [(\u00b7 \u2022 \u00b7), map_add, LinearMap.add_apply]\n  one_smul m := by\n    simp only [(\u00b7 \u2022 \u00b7), Algebra.TensorProduct.one_def]\n    simp only [moduleAux_apply, one_smul]\n  mul_smul x y m := by\n    refine TensorProduct.induction_on x ?_ ?_ ?_ <;> refine TensorProduct.induction_on y ?_ ?_ ?_\n    \u00b7 simp only [(\u00b7 \u2022 \u00b7), mul_zero, map_zero, LinearMap.zero_apply]\n    \u00b7 intro a b\n      simp only [(\u00b7 \u2022 \u00b7), zero_mul, map_zero, LinearMap.zero_apply]\n    \u00b7 intro z w _ _\n      simp only [(\u00b7 \u2022 \u00b7), zero_mul, map_zero, LinearMap.zero_apply]\n    \u00b7 intro a b\n      simp only [(\u00b7 \u2022 \u00b7), mul_zero, map_zero, LinearMap.zero_apply]\n    \u00b7 intro a\u2081 b\u2081 a\u2082 b\u2082\n      simp only [(\u00b7 \u2022 \u00b7), Algebra.TensorProduct.tmul_mul_tmul]\n      simp only [moduleAux_apply, mul_smul]\n      rw [smul_comm a\u2081 b\u2082]\n    \u00b7 intro z w hz hw a b\n      simp only [(\u00b7 \u2022 \u00b7)] at hz hw \u22a2\n      simp only [moduleAux_apply]\n      rw [mul_add]  simp only [LinearMap.map_add, LinearMap.add_apply, moduleAux_apply, hz, hw, smul_add]\n    \u00b7 intro z w _ _\n      simp only [(\u00b7 \u2022 \u00b7), mul_zero, map_zero, LinearMap.zero_apply]\n    \u00b7 intro a b z w hz hw\n      simp only [(\u00b7 \u2022 \u00b7)] at hz hw\n      simp only [(\u00b7 \u2022 \u00b7), LinearMap.map_add, add_mul, LinearMap.add_apply, hz, hw]\n    \u00b7 intro u v _ _ z w hz hw\n      simp only [(\u00b7 \u2022 \u00b7)] at hz hw\n      simp only [(\u00b7 \u2022 \u00b7)]\n      rw [add_mul, LinearMap.map_add, LinearMap.add_apply, hz, hw]\n      simp only [LinearMap.map_add, LinearMap.add_apply]\n      rw [add_add_add_comm]", "start": [1143, 1], "end": [1198, 28], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.Algebra.smul_def", "code": "theorem smul_def (a : A) (b : B) (m : M) : a \u2297\u209c[R] b \u2022 m = a \u2022 b \u2022 m", "start": [1203, 1], "end": [1204, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/StructuredArrow.lean", "imports": ["Mathlib/CategoryTheory/EssentiallySmall.lean", "Mathlib/CategoryTheory/Comma.lean", "Mathlib/CategoryTheory/PUnit.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean"], "premises": [{"full_name": "CategoryTheory.StructuredArrow", "code": "def StructuredArrow (S : D) (T : C \u2964 D) :=\n  Comma (Functor.fromPUnit.{0} S) T", "start": [32, 1], "end": [40, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.proj", "code": "@[simps!]\ndef proj (S : D) (T : C \u2964 D) : StructuredArrow S T \u2964 C :=\n  Comma.snd _ _", "start": [48, 1], "end": [51, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.hom_ext", "code": "@[ext]\nlemma hom_ext {X Y : StructuredArrow S T} (f g : X \u27f6 Y) (h : f.right = g.right) : f = g :=\n  CommaMorphism.ext _ _ (Subsingleton.elim _ _) h", "start": [59, 1], "end": [61, 50], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.StructuredArrow.hom_eq_iff", "code": "@[simp]\ntheorem hom_eq_iff {X Y : StructuredArrow S T} (f g : X \u27f6 Y) : f = g \u2194 f.right = g.right", "start": [63, 1], "end": [65, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.mk", "code": "def mk (f : S \u27f6 T.obj Y) : StructuredArrow S T :=\n  \u27e8\u27e8\u27e8\u27e9\u27e9, Y, f\u27e9", "start": [67, 1], "end": [69, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.mk_left", "code": "@[simp]\ntheorem mk_left (f : S \u27f6 T.obj Y) : (mk f).left = \u27e8\u27e8\u27e9\u27e9", "start": [72, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.mk_right", "code": "@[simp]\ntheorem mk_right (f : S \u27f6 T.obj Y) : (mk f).right = Y", "start": [77, 1], "end": [79, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.mk_hom_eq_self", "code": "@[simp]\ntheorem mk_hom_eq_self (f : S \u27f6 T.obj Y) : (mk f).hom = f", "start": [82, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.w", "code": "@[reassoc (attr := simp)]\ntheorem w {A B : StructuredArrow S T} (f : A \u27f6 B) : A.hom \u226b T.map f.right = B.hom", "start": [87, 1], "end": [89, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.comp_right", "code": "@[simp]\ntheorem comp_right {X Y Z : StructuredArrow S T} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    (f \u226b g).right = f.right \u226b g.right", "start": [92, 1], "end": [94, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.id_right", "code": "@[simp]\ntheorem id_right (X : StructuredArrow S T) : (\ud835\udfd9 X : X \u27f6 X).right = \ud835\udfd9 X.right", "start": [96, 1], "end": [97, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.eqToHom_right", "code": "theorem eqToHom_right {X Y : StructuredArrow S T} (h : X = Y) :\n    (eqToHom h).right = eqToHom (by rw [h])", "start": [99, 1], "end": [102, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.left_eq_id", "code": "@[simp]\ntheorem left_eq_id {X Y : StructuredArrow S T} (f : X \u27f6 Y) : f.left = \ud835\udfd9 _", "start": [104, 1], "end": [105, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.homMk", "code": "@[simps]\ndef homMk {f f' : StructuredArrow S T} (g : f.right \u27f6 f'.right)\n    (w : f.hom \u226b T.map g = f'.hom := by aesop_cat) : f \u27f6 f' where\n  left := eqToHom (by ext)\n  right := g\n  w := by\n    dsimp\n    simpa using w.symm", "start": [107, 1], "end": [118, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.homMk'", "code": "@[simps]\ndef homMk' (f : StructuredArrow S T) (g : f.right \u27f6 Y') : f \u27f6 mk (f.hom \u226b T.map g) where\n  left := eqToHom (by ext)\n  right := g", "start": [125, 1], "end": [130, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.homMk'_id", "code": "lemma homMk'_id (f : StructuredArrow S T) : homMk' f (\ud835\udfd9 f.right) = eqToHom (by aesop_cat) := by\n  ext\n  simp [eqToHom_right]", "start": [133, 1], "end": [135, 23], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.StructuredArrow.homMk'_mk_id", "code": "lemma homMk'_mk_id (f : S \u27f6 T.obj Y) : homMk' (mk f) (\ud835\udfd9 Y) = eqToHom (by aesop_cat) :=\n  homMk'_id _", "start": [137, 1], "end": [138, 14], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.StructuredArrow.homMk'_comp", "code": "lemma homMk'_comp (f : StructuredArrow S T) (g : f.right \u27f6 Y') (g' : Y' \u27f6 Y'') :\n    homMk' f (g \u226b g') = homMk' f g \u226b homMk' (mk (f.hom \u226b T.map g)) g' \u226b eqToHom (by simp) := by\n  ext\n  simp [eqToHom_right]", "start": [140, 1], "end": [143, 23], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.StructuredArrow.homMk'_mk_comp", "code": "lemma homMk'_mk_comp (f : S \u27f6 T.obj Y) (g : Y \u27f6 Y') (g' : Y' \u27f6 Y'') :\n    homMk' (mk f) (g \u226b g') = homMk' (mk f) g \u226b homMk' (mk (f \u226b T.map g)) g' \u226b eqToHom (by simp) :=\n  homMk'_comp _ _ _", "start": [145, 1], "end": [147, 20], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.StructuredArrow.isoMk", "code": "@[simps!]\ndef isoMk {f f' : StructuredArrow S T} (g : f.right \u2245 f'.right)\n    (w : f.hom \u226b T.map g.hom = f'.hom := by aesop_cat) :\n    f \u2245 f' :=\n  Comma.isoMk (eqToIso (by ext)) g (by simpa [eqToHom_map] using w.symm)", "start": [149, 1], "end": [157, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.ext", "code": "theorem ext {A B : StructuredArrow S T} (f g : A \u27f6 B) : f.right = g.right \u2192 f = g", "start": [164, 1], "end": [165, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.ext_iff", "code": "theorem ext_iff {A B : StructuredArrow S T} (f g : A \u27f6 B) : f = g \u2194 f.right = g.right", "start": [168, 1], "end": [169, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.proj_faithful", "code": "instance proj_faithful : Faithful (proj S T) where\n  map_injective {_ _} := ext", "start": [172, 1], "end": [173, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.mono_of_mono_right", "code": "theorem mono_of_mono_right {A B : StructuredArrow S T} (f : A \u27f6 B) [h : Mono f.right] : Mono f", "start": [176, 1], "end": [178, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.epi_of_epi_right", "code": "theorem epi_of_epi_right {A B : StructuredArrow S T} (f : A \u27f6 B) [h : Epi f.right] : Epi f", "start": [181, 1], "end": [182, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.mono_homMk", "code": "instance mono_homMk {A B : StructuredArrow S T} (f : A.right \u27f6 B.right) (w) [h : Mono f] :\n    Mono (homMk f w) :=\n  (proj S T).mono_of_mono_map h", "start": [185, 1], "end": [187, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.epi_homMk", "code": "instance epi_homMk {A B : StructuredArrow S T} (f : A.right \u27f6 B.right) (w) [h : Epi f] :\n    Epi (homMk f w) :=\n  (proj S T).epi_of_epi_map h", "start": [190, 1], "end": [192, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.eq_mk", "code": "theorem eq_mk (f : StructuredArrow S T) : f = mk f.hom", "start": [195, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.eta", "code": "@[simps!]\ndef eta (f : StructuredArrow S T) : f \u2245 mk f.hom :=\n  isoMk (Iso.refl _)", "start": [201, 1], "end": [204, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.map", "code": "@[simps!]\ndef map (f : S \u27f6 S') : StructuredArrow S' T \u2964 StructuredArrow S T :=\n  Comma.mapLeft _ ((Functor.const _).map f)", "start": [211, 1], "end": [221, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.map_mk", "code": "@[simp]\ntheorem map_mk {f : S' \u27f6 T.obj Y} (g : S \u27f6 S') : (map g).obj (mk f) = mk (g \u226b f)", "start": [224, 1], "end": [226, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.map_id", "code": "@[simp]\ntheorem map_id {f : StructuredArrow S T} : (map (\ud835\udfd9 S)).obj f = f", "start": [229, 1], "end": [232, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.map_comp", "code": "@[simp]\ntheorem map_comp {f : S \u27f6 S'} {f' : S' \u27f6 S''} {h : StructuredArrow S'' T} :\n    (map (f \u226b f')).obj h = (map f).obj ((map f').obj h)", "start": [235, 1], "end": [239, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.mapIso", "code": "@[simp]\ndef mapIso (i : S \u2245 S') : StructuredArrow S T \u224c StructuredArrow S' T :=\n  Comma.mapLeftIso _ ((Functor.const _).mapIso i)", "start": [242, 1], "end": [245, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.mapNatIso", "code": "@[simp]\ndef mapNatIso (i : T \u2245 T') : StructuredArrow S T \u224c StructuredArrow S T' :=\n  Comma.mapRightIso _ i", "start": [247, 1], "end": [251, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.proj_reflectsIsomorphisms", "code": "instance proj_reflectsIsomorphisms : ReflectsIsomorphisms (proj S T) where\n  reflects {Y Z} f t :=\n    \u27e8\u27e8StructuredArrow.homMk\n        (inv ((proj S T).map f))\n        (by rw [Functor.map_inv, IsIso.comp_inv_eq]; simp),\n      by constructor <;> apply CommaMorphism.ext <;> dsimp at t \u22a2 <;> simp\u27e9\u27e9", "start": [253, 1], "end": [258, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.mkIdInitial", "code": "def mkIdInitial [Full T] [Faithful T] : IsInitial (mk (\ud835\udfd9 (T.obj Y))) where\n  desc c := homMk (T.preimage c.pt.hom)\n  uniq c m _ := by\n    apply CommaMorphism.ext\n    \u00b7 aesop_cat\n    \u00b7 apply T.map_injective\n      simpa only [homMk_right, T.image_preimage, \u2190 w m] using (Category.id_comp _).symm", "start": [263, 1], "end": [270, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.pre", "code": "@[simps!]\ndef pre (S : D) (F : B \u2964 C) (G : C \u2964 D) : StructuredArrow S (F \u22d9 G) \u2964 StructuredArrow S G :=\n  Comma.preRight _ F G", "start": [275, 1], "end": [278, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.isEquivalencePre", "code": "noncomputable def isEquivalencePre (S : D) (F : B \u2964 C) (G : C \u2964 D) [IsEquivalence F] :\n    IsEquivalence (pre S F G) :=\n  Comma.isEquivalencePreRight _ _ _", "start": [290, 1], "end": [293, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.post", "code": "@[simps]\ndef post (S : C) (F : B \u2964 C) (G : C \u2964 D) : StructuredArrow S F \u2964 StructuredArrow (G.obj S) (F \u22d9 G)\n    where\n  obj X := StructuredArrow.mk (G.map X.hom)\n  map f := StructuredArrow.homMk f.right (by simp [Functor.comp_map, \u2190G.map_comp, \u2190 f.w])", "start": [295, 1], "end": [300, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.isEquivalencePost", "code": "noncomputable def isEquivalencePost (S : C) (F : B \u2964 C) (G : C \u2964 D) [Full G] [Faithful G] :\n    IsEquivalence (post S F G) :=\n  Equivalence.ofFullyFaithfullyEssSurj _", "start": [312, 1], "end": [315, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.small_proj_preimage_of_locallySmall", "code": "instance small_proj_preimage_of_locallySmall {\ud835\udca2 : Set C} [Small.{v\u2081} \ud835\udca2] [LocallySmall.{v\u2081} D] :\n    Small.{v\u2081} ((proj S T).obj \u207b\u00b9' \ud835\udca2) := by\n  suffices (proj S T).obj \u207b\u00b9' \ud835\udca2 = Set.range fun f : \u03a3G : \ud835\udca2, S \u27f6 T.obj G => mk f.2 by\n    rw [this]\n    infer_instance\n  exact Set.ext fun X => \u27e8fun h => \u27e8\u27e8\u27e8_, h\u27e9, X.hom\u27e9, (eq_mk _).symm\u27e9, by aesop_cat\u27e9", "start": [317, 1], "end": [322, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.IsUniversal", "code": "abbrev IsUniversal (f : StructuredArrow S T) := IsInitial f", "start": [325, 1], "end": [326, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.IsUniversal.uniq", "code": "theorem uniq (h : IsUniversal f) (\u03b7 : f \u27f6 g) : \u03b7 = h.to g", "start": [332, 1], "end": [333, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.IsUniversal.desc", "code": "def desc (h : IsUniversal f) (g : StructuredArrow S T) : f.right \u27f6 g.right :=\n  (h.to g).right", "start": [335, 1], "end": [337, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.IsUniversal.fac", "code": "@[reassoc (attr := simp)]\ntheorem fac (h : IsUniversal f) (g : StructuredArrow S T) :\n    f.hom \u226b T.map (h.desc g) = g.hom", "start": [339, 1], "end": [343, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.IsUniversal.hom_desc", "code": "theorem hom_desc (h : IsUniversal f) {c : C} (\u03b7 : f.right \u27f6 c) :\n    \u03b7 = h.desc (mk <| f.hom \u226b T.map \u03b7)", "start": [345, 1], "end": [348, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.IsUniversal.hom_ext", "code": "theorem hom_ext (h : IsUniversal f) {c : C} {\u03b7 \u03b7' : f.right \u27f6 c}\n    (w : f.hom \u226b T.map \u03b7 = f.hom \u226b T.map \u03b7') : \u03b7 = \u03b7'", "start": [350, 1], "end": [354, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.IsUniversal.existsUnique", "code": "theorem existsUnique (h : IsUniversal f) (g : StructuredArrow S T) :\n    \u2203! \u03b7 : f.right \u27f6 g.right, f.hom \u226b T.map \u03b7 = g.hom", "start": [356, 1], "end": [358, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow", "code": "def CostructuredArrow (S : C \u2964 D) (T : D) :=\n  Comma S (Functor.fromPUnit.{0} T)", "start": [364, 1], "end": [372, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.proj", "code": "@[simps!]\ndef proj (S : C \u2964 D) (T : D) : CostructuredArrow S T \u2964 C :=\n  Comma.fst _ _", "start": [379, 1], "end": [382, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.hom_ext", "code": "@[ext]\nlemma hom_ext {X Y : CostructuredArrow S T} (f g : X \u27f6 Y) (h : f.left = g.left) : f = g :=\n  CommaMorphism.ext _ _ h (Subsingleton.elim _ _)", "start": [390, 1], "end": [392, 50], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.CostructuredArrow.hom_eq_iff", "code": "@[simp]\ntheorem hom_eq_iff {X Y : CostructuredArrow S T} (f g : X \u27f6 Y) : f = g \u2194 f.left = g.left", "start": [394, 1], "end": [396, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.mk", "code": "def mk (f : S.obj Y \u27f6 T) : CostructuredArrow S T :=\n  \u27e8Y, \u27e8\u27e8\u27e9\u27e9, f\u27e9", "start": [398, 1], "end": [400, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.mk_left", "code": "@[simp]\ntheorem mk_left (f : S.obj Y \u27f6 T) : (mk f).left = Y", "start": [403, 1], "end": [405, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.mk_right", "code": "@[simp]\ntheorem mk_right (f : S.obj Y \u27f6 T) : (mk f).right = \u27e8\u27e8\u27e9\u27e9", "start": [408, 1], "end": [410, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.mk_hom_eq_self", "code": "@[simp]\ntheorem mk_hom_eq_self (f : S.obj Y \u27f6 T) : (mk f).hom = f", "start": [413, 1], "end": [415, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.w", "code": "@[reassoc]\ntheorem w {A B : CostructuredArrow S T} (f : A \u27f6 B) : S.map f.left \u226b B.hom = A.hom", "start": [419, 1], "end": [420, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.comp_left", "code": "@[simp]\ntheorem comp_left {X Y Z : CostructuredArrow S T} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    (f \u226b g).left = f.left \u226b g.left", "start": [423, 1], "end": [425, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.id_left", "code": "@[simp]\ntheorem id_left (X : CostructuredArrow S T) : (\ud835\udfd9 X : X \u27f6 X).left = \ud835\udfd9 X.left", "start": [427, 1], "end": [428, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.eqToHom_left", "code": "theorem eqToHom_left {X Y : CostructuredArrow S T} (h : X = Y) :\n    (eqToHom h).left = eqToHom (by rw [h])", "start": [430, 1], "end": [433, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.right_eq_id", "code": "@[simp]\ntheorem right_eq_id {X Y : CostructuredArrow S T} (f : X \u27f6 Y) : f.right = \ud835\udfd9 _", "start": [435, 1], "end": [436, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.homMk", "code": "@[simps!]\ndef homMk {f f' : CostructuredArrow S T} (g : f.left \u27f6 f'.left)\n    (w : S.map g \u226b f'.hom = f.hom := by aesop_cat) : f \u27f6 f' where\n  left := g\n  right := eqToHom (by ext)\n  w := by simpa [eqToHom_map] using w", "start": [438, 1], "end": [447, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.homMk'", "code": "@[simps]\ndef homMk' (f : CostructuredArrow S T) (g : Y' \u27f6 f.left) : mk (S.map g \u226b f.hom) \u27f6 f where\n  left := g\n  right := eqToHom (by ext)", "start": [454, 1], "end": [459, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.homMk'_id", "code": "lemma homMk'_id (f : CostructuredArrow S T) : homMk' f (\ud835\udfd9 f.left) = eqToHom (by aesop_cat) := by\n  ext\n  simp [eqToHom_left]", "start": [461, 1], "end": [463, 22], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.CostructuredArrow.homMk'_mk_id", "code": "lemma homMk'_mk_id (f : S.obj Y \u27f6 T) : homMk' (mk f) (\ud835\udfd9 Y) = eqToHom (by aesop_cat) :=\n  homMk'_id _", "start": [465, 1], "end": [466, 14], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.CostructuredArrow.homMk'_comp", "code": "lemma homMk'_comp (f : CostructuredArrow S T) (g : Y' \u27f6 f.left) (g' : Y'' \u27f6 Y') :\n    homMk' f (g' \u226b g) = eqToHom (by simp) \u226b homMk' (mk (S.map g \u226b f.hom)) g' \u226b homMk' f g := by\n  ext\n  simp [eqToHom_left]", "start": [468, 1], "end": [471, 22], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.CostructuredArrow.homMk'_mk_comp", "code": "lemma homMk'_mk_comp (f : S.obj Y \u27f6 T) (g : Y' \u27f6 Y) (g' : Y'' \u27f6 Y') :\n    homMk' (mk f) (g' \u226b g) = eqToHom (by simp) \u226b homMk' (mk (S.map g \u226b f)) g' \u226b homMk' (mk f) g :=\n  homMk'_comp _ _ _", "start": [473, 1], "end": [475, 20], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.CostructuredArrow.isoMk", "code": "@[simps!]\ndef isoMk {f f' : CostructuredArrow S T} (g : f.left \u2245 f'.left)\n    (w : S.map g.hom \u226b f'.hom = f.hom := by aesop_cat) : f \u2245 f' :=\n  Comma.isoMk g (eqToIso (by ext)) (by simpa [eqToHom_map] using w)", "start": [477, 1], "end": [484, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.ext", "code": "theorem ext {A B : CostructuredArrow S T} (f g : A \u27f6 B) (h : f.left = g.left) : f = g", "start": [491, 1], "end": [492, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.ext_iff", "code": "theorem ext_iff {A B : CostructuredArrow S T} (f g : A \u27f6 B) : f = g \u2194 f.left = g.left", "start": [495, 1], "end": [496, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.proj_faithful", "code": "instance proj_faithful : Faithful (proj S T) where map_injective {_ _} := ext", "start": [499, 1], "end": [499, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.mono_of_mono_left", "code": "theorem mono_of_mono_left {A B : CostructuredArrow S T} (f : A \u27f6 B) [h : Mono f.left] : Mono f", "start": [502, 1], "end": [503, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.epi_of_epi_left", "code": "theorem epi_of_epi_left {A B : CostructuredArrow S T} (f : A \u27f6 B) [h : Epi f.left] : Epi f", "start": [506, 1], "end": [508, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.mono_homMk", "code": "instance mono_homMk {A B : CostructuredArrow S T} (f : A.left \u27f6 B.left) (w) [h : Mono f] :\n    Mono (homMk f w) :=\n  (proj S T).mono_of_mono_map h", "start": [511, 1], "end": [513, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.epi_homMk", "code": "instance epi_homMk {A B : CostructuredArrow S T} (f : A.left \u27f6 B.left) (w) [h : Epi f] :\n    Epi (homMk f w) :=\n  (proj S T).epi_of_epi_map h", "start": [516, 1], "end": [518, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.eq_mk", "code": "theorem eq_mk (f : CostructuredArrow S T) : f = mk f.hom", "start": [521, 1], "end": [524, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.eta", "code": "@[simps!]\ndef eta (f : CostructuredArrow S T) : f \u2245 mk f.hom :=\n  isoMk (Iso.refl _)", "start": [527, 1], "end": [530, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.map", "code": "@[simps!]\ndef map (f : T \u27f6 T') : CostructuredArrow S T \u2964 CostructuredArrow S T' :=\n  Comma.mapRight _ ((Functor.const _).map f)", "start": [537, 1], "end": [547, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.map_mk", "code": "@[simp]\ntheorem map_mk {f : S.obj Y \u27f6 T} (g : T \u27f6 T') : (map g).obj (mk f) = mk (f \u226b g)", "start": [550, 1], "end": [552, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.map_id", "code": "@[simp]\ntheorem map_id {f : CostructuredArrow S T} : (map (\ud835\udfd9 T)).obj f = f", "start": [555, 1], "end": [558, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.map_comp", "code": "@[simp]\ntheorem map_comp {f : T \u27f6 T'} {f' : T' \u27f6 T''} {h : CostructuredArrow S T} :\n    (map (f \u226b f')).obj h = (map f').obj ((map f).obj h)", "start": [561, 1], "end": [565, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.mapIso", "code": "@[simp]\ndef mapIso (i : T \u2245 T') : CostructuredArrow S T \u224c CostructuredArrow S T' :=\n  Comma.mapRightIso _ ((Functor.const _).mapIso i)", "start": [568, 1], "end": [572, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.mapNatIso", "code": "@[simp]\ndef mapNatIso (i : S \u2245 S') : CostructuredArrow S T \u224c CostructuredArrow S' T :=\n  Comma.mapLeftIso _ i", "start": [574, 1], "end": [578, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.proj_reflectsIsomorphisms", "code": "instance proj_reflectsIsomorphisms : ReflectsIsomorphisms (proj S T) where\n  reflects {Y Z} f t :=\n    \u27e8\u27e8CostructuredArrow.homMk\n        (inv ((proj S T).map f))\n        (by rw [Functor.map_inv, IsIso.inv_comp_eq]; simp),\n      by constructor <;> ext <;> dsimp at t \u22a2 <;> simp\u27e9\u27e9", "start": [580, 1], "end": [585, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.mkIdTerminal", "code": "def mkIdTerminal [Full S] [Faithful S] : IsTerminal (mk (\ud835\udfd9 (S.obj Y))) where\n  lift c := homMk (S.preimage c.pt.hom)\n  uniq := by\n    rintro c m -\n    ext\n    apply S.map_injective\n    simpa only [homMk_left, S.image_preimage, \u2190 w m] using (Category.comp_id _).symm", "start": [590, 1], "end": [597, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.pre", "code": "@[simps!]\ndef pre (F : B \u2964 C) (G : C \u2964 D) (S : D) : CostructuredArrow (F \u22d9 G) S \u2964 CostructuredArrow G S :=\n  Comma.preLeft F G _", "start": [602, 1], "end": [605, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.isEquivalencePre", "code": "noncomputable def isEquivalencePre (F : B \u2964 C) (G : C \u2964 D) (S : D) [IsEquivalence F] :\n    IsEquivalence (pre F G S) :=\n  Comma.isEquivalencePreLeft _ _ _", "start": [617, 1], "end": [620, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.post", "code": "@[simps]\ndef post (F : B \u2964 C) (G : C \u2964 D) (S : C) :\n    CostructuredArrow F S \u2964 CostructuredArrow (F \u22d9 G) (G.obj S) where\n  obj X := CostructuredArrow.mk (G.map X.hom)\n  map f := CostructuredArrow.homMk f.left (by simp [Functor.comp_map, \u2190G.map_comp, \u2190 f.w])", "start": [622, 1], "end": [627, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.isEquivalencePost", "code": "noncomputable def isEquivalencePost (S : C) (F : B \u2964 C) (G : C \u2964 D) [Full G] [Faithful G] :\n    IsEquivalence (post F G S) :=\n  Equivalence.ofFullyFaithfullyEssSurj _", "start": [639, 1], "end": [642, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.small_proj_preimage_of_locallySmall", "code": "instance small_proj_preimage_of_locallySmall {\ud835\udca2 : Set C} [Small.{v\u2081} \ud835\udca2] [LocallySmall.{v\u2081} D] :\n    Small.{v\u2081} ((proj S T).obj \u207b\u00b9' \ud835\udca2) := by\n  suffices (proj S T).obj \u207b\u00b9' \ud835\udca2 = Set.range fun f : \u03a3G : \ud835\udca2, S.obj G \u27f6 T => mk f.2 by\n    rw [this]\n    infer_instance\n  exact Set.ext fun X => \u27e8fun h => \u27e8\u27e8\u27e8_, h\u27e9, X.hom\u27e9, (eq_mk _).symm\u27e9, by aesop_cat\u27e9", "start": [644, 1], "end": [649, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.IsUniversal", "code": "abbrev IsUniversal (f : CostructuredArrow S T) := IsTerminal f", "start": [652, 1], "end": [653, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.IsUniversal.uniq", "code": "theorem uniq (h : IsUniversal f) (\u03b7 : g \u27f6 f) : \u03b7 = h.from g", "start": [659, 1], "end": [660, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.IsUniversal.lift", "code": "def lift (h : IsUniversal f) (g : CostructuredArrow S T) : g.left \u27f6 f.left :=\n  (h.from g).left", "start": [662, 1], "end": [664, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.IsUniversal.fac", "code": "@[reassoc (attr := simp)]\ntheorem fac (h : IsUniversal f) (g : CostructuredArrow S T) :\n    S.map (h.lift g) \u226b f.hom = g.hom", "start": [666, 1], "end": [670, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.IsUniversal.hom_desc", "code": "theorem hom_desc (h : IsUniversal f) {c : C} (\u03b7 : c \u27f6 f.left) :\n    \u03b7 = h.lift (mk <| S.map \u03b7 \u226b f.hom)", "start": [672, 1], "end": [675, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.IsUniversal.hom_ext", "code": "theorem hom_ext (h : IsUniversal f) {c : C} {\u03b7 \u03b7' : c \u27f6 f.left}\n    (w : S.map \u03b7 \u226b f.hom = S.map \u03b7' \u226b f.hom) : \u03b7 = \u03b7'", "start": [677, 1], "end": [681, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.IsUniversal.existsUnique", "code": "theorem existsUnique (h : IsUniversal f) (g : CostructuredArrow S T) :\n    \u2203! \u03b7 : g.left \u27f6 f.left, S.map \u03b7 \u226b f.hom = g.hom", "start": [683, 1], "end": [685, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toStructuredArrow", "code": "@[simps]\ndef toStructuredArrow (G : E \u2964 C) (X : D) (F : C \u2964 D) (f : (Y : E) \u2192 X \u27f6 F.obj (G.obj Y))\n    (h : \u2200 {Y Z : E} (g : Y \u27f6 Z), f Y \u226b F.map (G.map g) = f Z) : E \u2964 StructuredArrow X F where\n  obj Y := StructuredArrow.mk (f Y)\n  map g := StructuredArrow.homMk (G.map g) (h g)", "start": [695, 1], "end": [705, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toStructuredArrowCompProj", "code": "def toStructuredArrowCompProj (G : E \u2964 C) (X : D) (F : C \u2964 D) (f : (Y : E) \u2192 X \u27f6 F.obj (G.obj Y))\n    (h : \u2200 {Y Z : E} (g : Y \u27f6 Z), f Y \u226b F.map (G.map g) = f Z) :\n    G.toStructuredArrow X F f h \u22d9 StructuredArrow.proj _ _ \u2245 G :=\n  Iso.refl _", "start": [707, 1], "end": [712, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toStructuredArrow_comp_proj", "code": "@[simp]\nlemma toStructuredArrow_comp_proj (G : E \u2964 C) (X : D) (F : C \u2964 D)\n    (f : (Y : E) \u2192 X \u27f6 F.obj (G.obj Y)) (h : \u2200 {Y Z : E} (g : Y \u27f6 Z), f Y \u226b F.map (G.map g) = f Z) :\n    G.toStructuredArrow X F f h \u22d9 StructuredArrow.proj _ _ = G :=\n  rfl", "start": [714, 1], "end": [718, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.toCostructuredArrow", "code": "@[simps]\ndef toCostructuredArrow (G : E \u2964 C) (F : C \u2964 D) (X : D) (f : (Y : E) \u2192 F.obj (G.obj Y) \u27f6 X)\n    (h : \u2200 {Y Z : E} (g : Y \u27f6 Z), F.map (G.map g) \u226b f Z = f Y) : E \u2964 CostructuredArrow F X where\n  obj Y := CostructuredArrow.mk (f Y)\n  map g := CostructuredArrow.homMk (G.map g) (h g)", "start": [720, 1], "end": [730, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toCostructuredArrowCompProj", "code": "def toCostructuredArrowCompProj (G : E \u2964 C) (F : C \u2964 D) (X : D)\n    (f : (Y : E) \u2192 F.obj (G.obj Y) \u27f6 X) (h : \u2200 {Y Z : E} (g : Y \u27f6 Z), F.map (G.map g) \u226b f Z = f Y) :\n    G.toCostructuredArrow F X f h \u22d9 CostructuredArrow.proj _ _ \u2245 G :=\n  Iso.refl _", "start": [732, 1], "end": [737, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toCostructuredArrow_comp_proj", "code": "@[simp]\nlemma toCostructuredArrow_comp_proj (G : E \u2964 C) (F : C \u2964 D) (X : D)\n    (f : (Y : E) \u2192 F.obj (G.obj Y) \u27f6 X) (h : \u2200 {Y Z : E} (g : Y \u27f6 Z), F.map (G.map g) \u226b f Z = f Y) :\n    G.toCostructuredArrow F X f h \u22d9 CostructuredArrow.proj _ _ = G :=\nrfl", "start": [739, 1], "end": [743, 4], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.StructuredArrow.toCostructuredArrow", "code": "@[simps]\ndef toCostructuredArrow (F : C \u2964 D) (d : D) :\n    (StructuredArrow d F)\u1d52\u1d56 \u2964 CostructuredArrow F.op (op d) where\n  obj X := @CostructuredArrow.mk _ _ _ _ _ (op X.unop.right) F.op X.unop.hom.op\n  map f :=\n    CostructuredArrow.homMk f.unop.right.op\n      (by\n        dsimp\n        rw [\u2190 op_comp, \u2190 f.unop.w, Functor.const_obj_map]\n        erw [Category.id_comp])", "start": [751, 1], "end": [764, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.toCostructuredArrow'", "code": "@[simps]\ndef toCostructuredArrow' (F : C \u2964 D) (d : D) :\n    (StructuredArrow (op d) F.op)\u1d52\u1d56 \u2964 CostructuredArrow F d\n    where\n  obj X := @CostructuredArrow.mk _ _ _ _ _ (unop X.unop.right) F X.unop.hom.unop\n  map f :=\n    CostructuredArrow.homMk f.unop.right.unop\n      (by\n        dsimp\n        rw [\u2190 Quiver.Hom.unop_op (F.map (Quiver.Hom.unop f.unop.right)), \u2190 unop_comp, \u2190 F.op_map, \u2190\n          f.unop.w, Functor.const_obj_map]\n        erw [Category.id_comp])", "start": [767, 1], "end": [782, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.toStructuredArrow", "code": "@[simps]\ndef toStructuredArrow (F : C \u2964 D) (d : D) : (CostructuredArrow F d)\u1d52\u1d56 \u2964 StructuredArrow (op d) F.op\n    where\n  obj X := @StructuredArrow.mk _ _ _ _ _ (op X.unop.left) F.op X.unop.hom.op\n  map f :=\n    StructuredArrow.homMk f.unop.left.op\n      (by\n        dsimp\n        rw [\u2190 op_comp, f.unop.w, Functor.const_obj_map]\n        erw [Category.comp_id])", "start": [789, 1], "end": [802, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.toStructuredArrow'", "code": "@[simps]\ndef toStructuredArrow' (F : C \u2964 D) (d : D) : (CostructuredArrow F.op (op d))\u1d52\u1d56 \u2964 StructuredArrow d F\n    where\n  obj X := @StructuredArrow.mk _ _ _ _ _ (unop X.unop.left) F X.unop.hom.unop\n  map f :=\n    StructuredArrow.homMk f.unop.left.unop\n      (by\n        dsimp\n        rw [\u2190 Quiver.Hom.unop_op (F.map f.unop.left.unop), \u2190 unop_comp, \u2190 F.op_map, f.unop.w,\n          Functor.const_obj_map]\n        erw [Category.comp_id])", "start": [805, 1], "end": [819, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.structuredArrowOpEquivalence", "code": "def structuredArrowOpEquivalence (F : C \u2964 D) (d : D) :\n    (StructuredArrow d F)\u1d52\u1d56 \u224c CostructuredArrow F.op (op d) :=\n  Equivalence.mk (StructuredArrow.toCostructuredArrow F d)\n    (CostructuredArrow.toStructuredArrow' F d).rightOp\n    (NatIso.ofComponents\n      (fun X => (StructuredArrow.isoMk (Iso.refl _)).op)\n      fun {X Y} f => Quiver.Hom.unop_inj <| by\n        apply CommaMorphism.ext <;>\n          dsimp [StructuredArrow.isoMk, Comma.isoMk,StructuredArrow.homMk]; simp)\n    (NatIso.ofComponents\n      (fun X => CostructuredArrow.isoMk (Iso.refl _))\n      fun {X Y} f => by\n        apply CommaMorphism.ext <;>\n          dsimp [CostructuredArrow.isoMk, Comma.isoMk, CostructuredArrow.homMk]; simp)", "start": [824, 1], "end": [840, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.costructuredArrowOpEquivalence", "code": "def costructuredArrowOpEquivalence (F : C \u2964 D) (d : D) :\n    (CostructuredArrow F d)\u1d52\u1d56 \u224c StructuredArrow (op d) F.op :=\n  Equivalence.mk (CostructuredArrow.toStructuredArrow F d)\n    (StructuredArrow.toCostructuredArrow' F d).rightOp\n    (NatIso.ofComponents\n      (fun X => (CostructuredArrow.isoMk (Iso.refl _)).op)\n      fun {X Y} f => Quiver.Hom.unop_inj <| by\n        apply CommaMorphism.ext <;>\n          dsimp [CostructuredArrow.isoMk, CostructuredArrow.homMk, Comma.isoMk]; simp)\n    (NatIso.ofComponents\n      (fun X => StructuredArrow.isoMk (Iso.refl _))\n      fun {X Y} f => by\n        apply CommaMorphism.ext <;>\n          dsimp [StructuredArrow.isoMk, StructuredArrow.homMk, Comma.isoMk]; simp)", "start": [843, 1], "end": [860, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/JordanHolder.lean", "imports": ["Mathlib/Order/Lattice.lean", "Mathlib/Logic/Equiv/Fin.lean", "Mathlib/Logic/Equiv/Functor.lean", "Mathlib/Data/Fintype/Card.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/List/Sort.lean"], "premises": [{"full_name": "JordanHolderLattice", "code": "class JordanHolderLattice (X : Type u) [Lattice X] where\n  IsMaximal : X \u2192 X \u2192 Prop\n  lt_of_isMaximal : \u2200 {x y}, IsMaximal x y \u2192 x < y\n  sup_eq_of_isMaximal : \u2200 {x y z}, IsMaximal x z \u2192 IsMaximal y z \u2192 x \u2260 y \u2192 x \u2294 y = z\n  isMaximal_inf_left_of_isMaximal_sup :\n    \u2200 {x y}, IsMaximal x (x \u2294 y) \u2192 IsMaximal y (x \u2294 y) \u2192 IsMaximal (x \u2293 y) x\n  Iso : X \u00d7 X \u2192 X \u00d7 X \u2192 Prop\n  iso_symm : \u2200 {x y}, Iso x y \u2192 Iso y x\n  iso_trans : \u2200 {x y z}, Iso x y \u2192 Iso y z \u2192 Iso x z\n  second_iso : \u2200 {x y}, IsMaximal x (x \u2294 y) \u2192 Iso (x, x \u2294 y) (x \u2293 y, y)", "start": [73, 1], "end": [90, 72], "kind": "commanddeclaration"}, {"full_name": "JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup", "code": "theorem isMaximal_inf_right_of_isMaximal_sup {x y : X} (hxz : IsMaximal x (x \u2294 y))\n    (hyz : IsMaximal y (x \u2294 y)) : IsMaximal (x \u2293 y) y", "start": [97, 1], "end": [101, 52], "kind": "commanddeclaration"}, {"full_name": "JordanHolderLattice.isMaximal_of_eq_inf", "code": "theorem isMaximal_of_eq_inf (x b : X) {a y : X} (ha : x \u2293 y = a) (hxy : x \u2260 y) (hxb : IsMaximal x b)\n    (hyb : IsMaximal y b) : IsMaximal a y", "start": [104, 1], "end": [108, 53], "kind": "commanddeclaration"}, {"full_name": "JordanHolderLattice.second_iso_of_eq", "code": "theorem second_iso_of_eq {x y a b : X} (hm : IsMaximal x a) (ha : x \u2294 y = a) (hb : x \u2293 y = b) :\n    Iso (x, a) (b, y)", "start": [111, 1], "end": [112, 60], "kind": "commanddeclaration"}, {"full_name": "JordanHolderLattice.IsMaximal.iso_refl", "code": "theorem IsMaximal.iso_refl {x y : X} (h : IsMaximal x y) : Iso (x, y) (x, y)", "start": [115, 1], "end": [117, 51], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries", "code": "structure CompositionSeries (X : Type u) [Lattice X] [JordanHolderLattice X] : Type u where\n  length : \u2115\n  series : Fin (length + 1) \u2192 X\n  step' : \u2200 i : Fin length, IsMaximal (series (Fin.castSucc i)) (series (Fin.succ i))", "start": [128, 1], "end": [138, 86], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.coeFun", "code": "instance coeFun : CoeFun (CompositionSeries X) fun x => Fin (x.length + 1) \u2192 X where\n  coe := CompositionSeries.series", "start": [145, 1], "end": [146, 34], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.inhabited", "code": "instance inhabited [Inhabited X] : Inhabited (CompositionSeries X) :=\n  \u27e8{  length := 0\n      series := default\n      step' := fun x => x.elim0 }\u27e9", "start": [149, 1], "end": [152, 35], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.step", "code": "theorem step (s : CompositionSeries X) :\n    \u2200 i : Fin s.length, IsMaximal (s (Fin.castSucc i)) (s (Fin.succ i))", "start": [155, 1], "end": [157, 10], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.coeFn_mk", "code": "theorem coeFn_mk (length : \u2115) (series step) :\n    (@CompositionSeries.mk X _ _ length series step : Fin length.succ \u2192 X) = series", "start": [161, 1], "end": [163, 6], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.lt_succ", "code": "theorem lt_succ (s : CompositionSeries X) (i : Fin s.length) :\n    s (Fin.castSucc i) < s (Fin.succ i)", "start": [166, 1], "end": [168, 29], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.strictMono", "code": "protected theorem strictMono (s : CompositionSeries X) : StrictMono s", "start": [171, 1], "end": [172, 41], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.injective", "code": "protected theorem injective (s : CompositionSeries X) : Function.Injective s", "start": [175, 1], "end": [176, 25], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.inj", "code": "@[simp]\nprotected theorem inj (s : CompositionSeries X) {i j : Fin s.length.succ} : s i = s j \u2194 i = j", "start": [179, 1], "end": [181, 21], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.membership", "code": "instance membership : Membership X (CompositionSeries X) :=\n  \u27e8fun x s => x \u2208 Set.range s\u27e9", "start": [184, 1], "end": [185, 31], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.mem_def", "code": "theorem mem_def {x : X} {s : CompositionSeries X} : x \u2208 s \u2194 x \u2208 Set.range s", "start": [188, 1], "end": [189, 10], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.total", "code": "theorem total {s : CompositionSeries X} {x y : X} (hx : x \u2208 s) (hy : y \u2208 s) : x \u2264 y \u2228 y \u2264 x", "start": [192, 1], "end": [196, 21], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.toList", "code": "def toList (s : CompositionSeries X) : List X :=\n  List.ofFn s", "start": [199, 1], "end": [201, 14], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.ext_fun", "code": "theorem ext_fun {s\u2081 s\u2082 : CompositionSeries X} (hl : s\u2081.length = s\u2082.length)\n    (h : \u2200 i, s\u2081 i = s\u2082 (Fin.cast (congr_arg Nat.succ hl) i)) : s\u2081 = s\u2082", "start": [204, 1], "end": [212, 38], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.length_toList", "code": "@[simp]\ntheorem length_toList (s : CompositionSeries X) : s.toList.length = s.length + 1", "start": [215, 1], "end": [217, 32], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.toList_ne_nil", "code": "theorem toList_ne_nil (s : CompositionSeries X) : s.toList \u2260 []", "start": [220, 1], "end": [221, 73], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.toList_injective", "code": "theorem toList_injective : Function.Injective (@CompositionSeries.toList X _ _)", "start": [224, 1], "end": [242, 18], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.chain'_toList", "code": "theorem chain'_toList (s : CompositionSeries X) : List.Chain' IsMaximal s.toList", "start": [245, 1], "end": [251, 28], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.toList_sorted", "code": "theorem toList_sorted (s : CompositionSeries X) : s.toList.Sorted (\u00b7 < \u00b7)", "start": [254, 1], "end": [258, 25], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.toList_nodup", "code": "theorem toList_nodup (s : CompositionSeries X) : s.toList.Nodup", "start": [261, 1], "end": [262, 24], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.mem_toList", "code": "@[simp]\ntheorem mem_toList {s : CompositionSeries X} {x : X} : x \u2208 s.toList \u2194 x \u2208 s", "start": [265, 1], "end": [267, 38], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.ofList", "code": "def ofList (l : List X) (hl : l \u2260 []) (hc : List.Chain' IsMaximal l) : CompositionSeries X\n    where\n  length := l.length - 1\n  series i :=\n    l.nthLe i\n      (by\n        conv_rhs => rw [\u2190 tsub_add_cancel_of_le (Nat.succ_le_of_lt (List.length_pos_of_ne_nil hl))]\n        exact i.2)\n  step' := fun \u27e8i, hi\u27e9 => List.chain'_iff_get.1 hc i hi", "start": [270, 1], "end": [279, 56], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.length_ofList", "code": "theorem length_ofList (l : List X) (hl : l \u2260 []) (hc : List.Chain' IsMaximal l) :\n    (ofList l hl hc).length = l.length - 1", "start": [282, 1], "end": [284, 6], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.ofList_toList", "code": "theorem ofList_toList (s : CompositionSeries X) :\n    ofList s.toList s.toList_ne_nil s.chain'_toList = s", "start": [287, 1], "end": [293, 43], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.ofList_toList'", "code": "@[simp]\ntheorem ofList_toList' (s : CompositionSeries X) :\n    ofList s.toList s.toList_ne_nil s.chain'_toList = s", "start": [296, 1], "end": [299, 18], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.toList_ofList", "code": "@[simp]\ntheorem toList_ofList (l : List X) (hl : l \u2260 []) (hc : List.Chain' IsMaximal l) :\n    toList (ofList l hl hc) = l", "start": [302, 1], "end": [311, 8], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.ext", "code": "@[ext]\ntheorem ext {s\u2081 s\u2082 : CompositionSeries X} (h : \u2200 x, x \u2208 s\u2081 \u2194 x \u2208 s\u2082) : s\u2081 = s\u2082", "start": [314, 1], "end": [323, 40], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.top", "code": "def top (s : CompositionSeries X) : X :=\n  s (Fin.last _)", "start": [326, 1], "end": [328, 17], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.top_mem", "code": "theorem top_mem (s : CompositionSeries X) : s.top \u2208 s", "start": [331, 1], "end": [332, 48], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.le_top", "code": "@[simp]\ntheorem le_top {s : CompositionSeries X} (i : Fin (s.length + 1)) : s i \u2264 s.top", "start": [335, 1], "end": [337, 40], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.le_top_of_mem", "code": "theorem le_top_of_mem {s : CompositionSeries X} {x : X} (hx : x \u2208 s) : x \u2264 s.top", "start": [340, 1], "end": [342, 16], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.bot", "code": "def bot (s : CompositionSeries X) : X :=\n  s 0", "start": [345, 1], "end": [347, 6], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.bot_mem", "code": "theorem bot_mem (s : CompositionSeries X) : s.bot \u2208 s", "start": [350, 1], "end": [351, 39], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.bot_le", "code": "@[simp]\ntheorem bot_le {s : CompositionSeries X} (i : Fin (s.length + 1)) : s.bot \u2264 s i", "start": [354, 1], "end": [356, 40], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.bot_le_of_mem", "code": "theorem bot_le_of_mem {s : CompositionSeries X} {x : X} (hx : x \u2208 s) : s.bot \u2264 x", "start": [359, 1], "end": [361, 16], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.length_pos_of_mem_ne", "code": "theorem length_pos_of_mem_ne {s : CompositionSeries X} {x y : X} (hx : x \u2208 s) (hy : y \u2208 s)\n    (hxy : x \u2260 y) : 0 < s.length", "start": [364, 1], "end": [371, 95], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.forall_mem_eq_of_length_eq_zero", "code": "theorem forall_mem_eq_of_length_eq_zero {s : CompositionSeries X} (hs : s.length = 0) {x y}\n    (hx : x \u2208 s) (hy : y \u2208 s) : x = y", "start": [374, 1], "end": [376, 84], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.eraseTop", "code": "@[simps]\ndef eraseTop (s : CompositionSeries X) : CompositionSeries X where\n  length := s.length - 1\n  series i := s \u27e8i, lt_of_lt_of_le i.2 (Nat.succ_le_succ tsub_le_self)\u27e9\n  step' i := by\n    have := s.step \u27e8i, lt_of_lt_of_le i.2 tsub_le_self\u27e9\n    cases i\n    exact this", "start": [379, 1], "end": [388, 15], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.top_eraseTop", "code": "theorem top_eraseTop (s : CompositionSeries X) :\n    s.eraseTop.top = s \u27e8s.length - 1, lt_of_le_of_lt tsub_le_self (Nat.lt_succ_self _)\u27e9", "start": [391, 1], "end": [398, 23], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.eraseTop_top_le", "code": "theorem eraseTop_top_le (s : CompositionSeries X) : s.eraseTop.top \u2264 s.top", "start": [401, 1], "end": [402, 84], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.bot_eraseTop", "code": "@[simp]\ntheorem bot_eraseTop (s : CompositionSeries X) : s.eraseTop.bot = s.bot", "start": [405, 1], "end": [407, 6], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.mem_eraseTop_of_ne_of_mem", "code": "theorem mem_eraseTop_of_ne_of_mem {s : CompositionSeries X} {x : X} (hx : x \u2260 s.top) (hxs : x \u2208 s) :\n    x \u2208 s.eraseTop", "start": [410, 1], "end": [417, 42], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.mem_eraseTop", "code": "theorem mem_eraseTop {s : CompositionSeries X} {x : X} (h : 0 < s.length) :\n    x \u2208 s.eraseTop \u2194 x \u2260 s.top \u2227 x \u2208 s", "start": [420, 1], "end": [432, 44], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.lt_top_of_mem_eraseTop", "code": "theorem lt_top_of_mem_eraseTop {s : CompositionSeries X} {x : X} (h : 0 < s.length)\n    (hx : x \u2208 s.eraseTop) : x < s.top", "start": [435, 1], "end": [437, 85], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.isMaximal_eraseTop_top", "code": "theorem isMaximal_eraseTop_top {s : CompositionSeries X} (h : 0 < s.length) :\n    IsMaximal s.eraseTop.top s.top", "start": [440, 1], "end": [445, 76], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.append_castAdd_aux", "code": "theorem append_castAdd_aux (i : Fin m) :\n    Matrix.vecAppend (Nat.add_succ _ _).symm (a \u2218 Fin.castSucc) b\n      (Fin.castSucc <| Fin.castAdd n i) =\n      a (Fin.castSucc i)", "start": [453, 1], "end": [458, 36], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.append_succ_castAdd_aux", "code": "theorem append_succ_castAdd_aux (i : Fin m) (h : a (Fin.last _) = b 0) :\n    Matrix.vecAppend (Nat.add_succ _ _).symm (a \u2218 Fin.castSucc) b (Fin.castAdd n i).succ =\n      a i.succ", "start": [461, 1], "end": [473, 57], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.append_natAdd_aux", "code": "theorem append_natAdd_aux (i : Fin n) :\n    Matrix.vecAppend (Nat.add_succ _ _).symm (a \u2218 Fin.castSucc) b\n      (Fin.castSucc <| Fin.natAdd m i) =\n      b (Fin.castSucc i)", "start": [476, 1], "end": [482, 79], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.append_succ_natAdd_aux", "code": "theorem append_succ_natAdd_aux (i : Fin n) :\n    Matrix.vecAppend (Nat.add_succ _ _).symm (a \u2218 Fin.castSucc) b (Fin.natAdd m i).succ =\n      b i.succ", "start": [485, 1], "end": [490, 96], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.append", "code": "@[simps length]\ndef append (s\u2081 s\u2082 : CompositionSeries X) (h : s\u2081.top = s\u2082.bot) : CompositionSeries X where\n  length := s\u2081.length + s\u2082.length\n  series := Matrix.vecAppend (Nat.add_succ s\u2081.length s\u2082.length).symm (s\u2081 \u2218 Fin.castSucc) s\u2082\n  step' i := by\n    refine' Fin.addCases _ _ i\n    \u00b7 intro i\n      rw [append_succ_castAdd_aux _ _ _ h, append_castAdd_aux]\n      exact s\u2081.step i\n    \u00b7 intro i\n      rw [append_natAdd_aux, append_succ_natAdd_aux]\n      exact s\u2082.step i", "start": [495, 1], "end": [508, 22], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.coe_append", "code": "theorem coe_append (s\u2081 s\u2082 : CompositionSeries X) (h) :\n    \u21d1(s\u2081.append s\u2082 h) = Matrix.vecAppend (Nat.add_succ _ _).symm (s\u2081 \u2218 Fin.castSucc) s\u2082", "start": [511, 1], "end": [513, 6], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.append_castAdd", "code": "@[simp]\ntheorem append_castAdd {s\u2081 s\u2082 : CompositionSeries X} (h : s\u2081.top = s\u2082.bot) (i : Fin s\u2081.length) :\n    append s\u2081 s\u2082 h (Fin.castSucc <| Fin.castAdd s\u2082.length i) = s\u2081 (Fin.castSucc i)", "start": [516, 1], "end": [519, 44], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.append_succ_castAdd", "code": "@[simp]\ntheorem append_succ_castAdd {s\u2081 s\u2082 : CompositionSeries X} (h : s\u2081.top = s\u2082.bot)\n    (i : Fin s\u2081.length) : append s\u2081 s\u2082 h (Fin.castAdd s\u2082.length i).succ = s\u2081 i.succ", "start": [522, 1], "end": [525, 51], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.append_natAdd", "code": "@[simp]\ntheorem append_natAdd {s\u2081 s\u2082 : CompositionSeries X} (h : s\u2081.top = s\u2082.bot) (i : Fin s\u2082.length) :\n    append s\u2081 s\u2082 h (Fin.castSucc <| Fin.natAdd s\u2081.length i) = s\u2082 (Fin.castSucc i)", "start": [528, 1], "end": [531, 43], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.append_succ_natAdd", "code": "@[simp]\ntheorem append_succ_natAdd {s\u2081 s\u2082 : CompositionSeries X} (h : s\u2081.top = s\u2082.bot) (i : Fin s\u2082.length) :\n    append s\u2081 s\u2082 h (Fin.natAdd s\u2081.length i).succ = s\u2082 i.succ", "start": [534, 1], "end": [537, 48], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.snoc", "code": "@[simps length]\ndef snoc (s : CompositionSeries X) (x : X) (hsat : IsMaximal s.top x) : CompositionSeries X where\n  length := s.length + 1\n  series := Fin.snoc s x\n  step' i := by\n    refine' Fin.lastCases _ _ i\n    \u00b7 rwa [Fin.snoc_castSucc, Fin.succ_last, Fin.snoc_last, \u2190 top]\n    \u00b7 intro i\n      rw [Fin.snoc_castSucc, \u2190 Fin.castSucc_fin_succ, Fin.snoc_castSucc]\n      exact s.step _", "start": [540, 1], "end": [550, 21], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.top_snoc", "code": "@[simp]\ntheorem top_snoc (s : CompositionSeries X) (x : X) (hsat : IsMaximal s.top x) :\n    (snoc s x hsat).top = x", "start": [553, 1], "end": [556, 38], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.snoc_last", "code": "@[simp]\ntheorem snoc_last (s : CompositionSeries X) (x : X) (hsat : IsMaximal s.top x) :\n    snoc s x hsat (Fin.last (s.length + 1)) = x", "start": [559, 1], "end": [562, 38], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.snoc_castSucc", "code": "@[simp]\ntheorem snoc_castSucc (s : CompositionSeries X) (x : X) (hsat : IsMaximal s.top x)\n    (i : Fin (s.length + 1)) : snoc s x hsat (Fin.castSucc i) = s i", "start": [565, 1], "end": [568, 44], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.bot_snoc", "code": "@[simp]\ntheorem bot_snoc (s : CompositionSeries X) (x : X) (hsat : IsMaximal s.top x) :\n    (snoc s x hsat).bot = s.bot", "start": [571, 1], "end": [574, 84], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.mem_snoc", "code": "theorem mem_snoc {s : CompositionSeries X} {x y : X} {hsat : IsMaximal s.top x} :\n    y \u2208 snoc s x hsat \u2194 y \u2208 s \u2228 y = x", "start": [577, 1], "end": [592, 11], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.eq_snoc_eraseTop", "code": "theorem eq_snoc_eraseTop {s : CompositionSeries X} (h : 0 < s.length) :\n    s = snoc (eraseTop s) s.top (isMaximal_eraseTop_top h)", "start": [595, 1], "end": [599, 49], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.snoc_eraseTop_top", "code": "@[simp]\ntheorem snoc_eraseTop_top {s : CompositionSeries X} (h : IsMaximal s.eraseTop.top s.top) :\n    s.eraseTop.snoc s.top h = s", "start": [602, 1], "end": [611, 28], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.Equivalent", "code": "def Equivalent (s\u2081 s\u2082 : CompositionSeries X) : Prop :=\n  \u2203 f : Fin s\u2081.length \u2243 Fin s\u2082.length,\n    \u2200 i : Fin s\u2081.length, Iso (s\u2081 (Fin.castSucc i), s\u2081 i.succ)\n      (s\u2082 (Fin.castSucc (f i)), s\u2082 (Fin.succ (f i)))", "start": [614, 1], "end": [620, 53], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.Equivalent.refl", "code": "@[refl]\ntheorem refl (s : CompositionSeries X) : Equivalent s s", "start": [625, 1], "end": [627, 47], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.Equivalent.symm", "code": "@[symm]\ntheorem symm {s\u2081 s\u2082 : CompositionSeries X} (h : Equivalent s\u2081 s\u2082) : Equivalent s\u2082 s\u2081", "start": [630, 1], "end": [632, 86], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.Equivalent.trans", "code": "@[trans]\ntheorem trans {s\u2081 s\u2082 s\u2083 : CompositionSeries X} (h\u2081 : Equivalent s\u2081 s\u2082) (h\u2082 : Equivalent s\u2082 s\u2083) :\n    Equivalent s\u2081 s\u2083", "start": [635, 1], "end": [639, 74], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.Equivalent.append", "code": "theorem append {s\u2081 s\u2082 t\u2081 t\u2082 : CompositionSeries X} (hs : s\u2081.top = s\u2082.bot) (ht : t\u2081.top = t\u2082.bot)\n    (h\u2081 : Equivalent s\u2081 t\u2081) (h\u2082 : Equivalent s\u2082 t\u2082) :\n    Equivalent (append s\u2081 s\u2082 hs) (append t\u2081 t\u2082 ht)", "start": [642, 1], "end": [657, 47], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.Equivalent.snoc", "code": "protected theorem snoc {s\u2081 s\u2082 : CompositionSeries X} {x\u2081 x\u2082 : X} {hsat\u2081 : IsMaximal s\u2081.top x\u2081}\n    {hsat\u2082 : IsMaximal s\u2082.top x\u2082} (hequiv : Equivalent s\u2081 s\u2082)\n    (htop : Iso (s\u2081.top, x\u2081) (s\u2082.top, x\u2082)) : Equivalent (s\u2081.snoc x\u2081 hsat\u2081) (s\u2082.snoc x\u2082 hsat\u2082)", "start": [660, 1], "end": [673, 60], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.Equivalent.length_eq", "code": "theorem length_eq {s\u2081 s\u2082 : CompositionSeries X} (h : Equivalent s\u2081 s\u2082) : s\u2081.length = s\u2082.length", "start": [676, 1], "end": [677, 42], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.Equivalent.snoc_snoc_swap", "code": "theorem snoc_snoc_swap {s : CompositionSeries X} {x\u2081 x\u2082 y\u2081 y\u2082 : X} {hsat\u2081 : IsMaximal s.top x\u2081}\n    {hsat\u2082 : IsMaximal s.top x\u2082} {hsaty\u2081 : IsMaximal (snoc s x\u2081 hsat\u2081).top y\u2081}\n    {hsaty\u2082 : IsMaximal (snoc s x\u2082 hsat\u2082).top y\u2082} (hr\u2081 : Iso (s.top, x\u2081) (x\u2082, y\u2082))\n    (hr\u2082 : Iso (x\u2081, y\u2081) (s.top, x\u2082)) :\n    Equivalent (snoc (snoc s x\u2081 hsat\u2081) y\u2081 hsaty\u2081) (snoc (snoc s x\u2082 hsat\u2082) y\u2082 hsaty\u2082)", "start": [680, 1], "end": [709, 35], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.length_eq_zero_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero", "code": "theorem length_eq_zero_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero {s\u2081 s\u2082 : CompositionSeries X}\n    (hb : s\u2081.bot = s\u2082.bot) (ht : s\u2081.top = s\u2082.top) (hs\u2081 : s\u2081.length = 0) : s\u2082.length = 0", "start": [714, 1], "end": [721, 8], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.length_pos_of_bot_eq_bot_of_top_eq_top_of_length_pos", "code": "theorem length_pos_of_bot_eq_bot_of_top_eq_top_of_length_pos {s\u2081 s\u2082 : CompositionSeries X}\n    (hb : s\u2081.bot = s\u2082.bot) (ht : s\u2081.top = s\u2082.top) : 0 < s\u2081.length \u2192 0 < s\u2082.length", "start": [724, 1], "end": [729, 90], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.eq_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero", "code": "theorem eq_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero {s\u2081 s\u2082 : CompositionSeries X}\n    (hb : s\u2081.bot = s\u2082.bot) (ht : s\u2081.top = s\u2082.top) (hs\u20810 : s\u2081.length = 0) : s\u2081 = s\u2082", "start": [732, 1], "end": [742, 11], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.exists_top_eq_snoc_equivalant", "code": "theorem exists_top_eq_snoc_equivalant (s : CompositionSeries X) (x : X) (hm : IsMaximal x s.top)\n    (hb : s.bot \u2264 x) :\n    \u2203 t : CompositionSeries X,\n      t.bot = s.bot \u2227 t.length + 1 = s.length \u2227\n      \u2203 htx : t.top = x, Equivalent s (snoc t s.top (htx.symm \u25b8 hm))", "start": [745, 1], "end": [785, 95], "kind": "commanddeclaration"}, {"full_name": "CompositionSeries.jordan_holder", "code": "theorem jordan_holder (s\u2081 s\u2082 : CompositionSeries X) (hb : s\u2081.bot = s\u2082.bot) (ht : s\u2081.top = s\u2082.top) :\n    Equivalent s\u2081 s\u2082", "start": [788, 1], "end": [804, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "Mathlib/Data/Matrix/Invertible.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.invertibleOfDetInvertible", "code": "def invertibleOfDetInvertible [Invertible A.det] : Invertible A where\n  invOf := \u215f A.det \u2022 A.adjugate\n  mul_invOf_self := by\n    rw [mul_smul_comm, mul_adjugate, smul_smul, invOf_mul_self, one_smul]\n  invOf_mul_self := by\n    rw [smul_mul_assoc, adjugate_mul, smul_smul, invOf_mul_self, one_smul]", "start": [70, 1], "end": [76, 75], "kind": "commanddeclaration"}, {"full_name": "Matrix.invOf_eq", "code": "theorem invOf_eq [Invertible A.det] [Invertible A] : \u215f A = \u215f A.det \u2022 A.adjugate", "start": [79, 1], "end": [81, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.detInvertibleOfLeftInverse", "code": "def detInvertibleOfLeftInverse (h : B * A = 1) : Invertible A.det where\n  invOf := B.det\n  mul_invOf_self := by rw [mul_comm, \u2190 det_mul, h, det_one]\n  invOf_mul_self := by rw [\u2190 det_mul, h, det_one]", "start": [84, 1], "end": [88, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.detInvertibleOfRightInverse", "code": "def detInvertibleOfRightInverse (h : A * B = 1) : Invertible A.det where\n  invOf := B.det\n  mul_invOf_self := by rw [\u2190 det_mul, h, det_one]\n  invOf_mul_self := by rw [mul_comm, \u2190 det_mul, h, det_one]", "start": [91, 1], "end": [95, 60], "kind": "commanddeclaration"}, {"full_name": "Matrix.detInvertibleOfInvertible", "code": "def detInvertibleOfInvertible [Invertible A] : Invertible A.det :=\n  detInvertibleOfLeftInverse A (\u215f A) (invOf_mul_self _)", "start": [98, 1], "end": [100, 56], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_invOf", "code": "theorem det_invOf [Invertible A] [Invertible A.det] : (\u215f A).det = \u215f A.det", "start": [103, 1], "end": [105, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.invertibleEquivDetInvertible", "code": "@[simps]\ndef invertibleEquivDetInvertible : Invertible A \u2243 Invertible A.det where\n  toFun := @detInvertibleOfInvertible _ _ _ _ _ A\n  invFun := @invertibleOfDetInvertible _ _ _ _ _ A\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _", "start": [108, 1], "end": [115, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_eq_one_comm", "code": "theorem mul_eq_one_comm : A * B = 1 \u2194 B * A = 1", "start": [120, 1], "end": [129, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.invertibleOfLeftInverse", "code": "def invertibleOfLeftInverse (h : B * A = 1) : Invertible A :=\n  \u27e8B, h, mul_eq_one_comm.mp h\u27e9", "start": [135, 1], "end": [137, 31], "kind": "commanddeclaration"}, {"full_name": "Matrix.invertibleOfRightInverse", "code": "def invertibleOfRightInverse (h : A * B = 1) : Invertible A :=\n  \u27e8B, mul_eq_one_comm.mp h, h\u27e9", "start": [140, 1], "end": [142, 31], "kind": "commanddeclaration"}, {"full_name": "Matrix.unitOfDetInvertible", "code": "def unitOfDetInvertible [Invertible A.det] : (Matrix n n \u03b1)\u02e3 :=\n  @unitOfInvertible _ _ A (invertibleOfDetInvertible A)", "start": [145, 1], "end": [147, 56], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_iff_isUnit_det", "code": "theorem isUnit_iff_isUnit_det : IsUnit A \u2194 IsUnit A.det", "start": [150, 1], "end": [152, 96], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_det_of_invertible", "code": "theorem isUnit_det_of_invertible [Invertible A] : IsUnit A.det", "start": [158, 1], "end": [159, 60], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_of_left_inverse", "code": "theorem isUnit_of_left_inverse (h : B * A = 1) : IsUnit A", "start": [164, 1], "end": [165, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_of_right_inverse", "code": "theorem isUnit_of_right_inverse (h : A * B = 1) : IsUnit A", "start": [168, 1], "end": [169, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_det_of_left_inverse", "code": "theorem isUnit_det_of_left_inverse (h : B * A = 1) : IsUnit A.det", "start": [172, 1], "end": [173, 65], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_det_of_right_inverse", "code": "theorem isUnit_det_of_right_inverse (h : A * B = 1) : IsUnit A.det", "start": [176, 1], "end": [177, 66], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_ne_zero_of_left_inverse", "code": "theorem det_ne_zero_of_left_inverse [Nontrivial \u03b1] (h : B * A = 1) : A.det \u2260 0", "start": [180, 1], "end": [181, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_ne_zero_of_right_inverse", "code": "theorem det_ne_zero_of_right_inverse [Nontrivial \u03b1] (h : A * B = 1) : A.det \u2260 0", "start": [184, 1], "end": [185, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_det_transpose", "code": "theorem isUnit_det_transpose (h : IsUnit A.det) : IsUnit A\u1d40.det", "start": [194, 1], "end": [196, 10], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv", "code": "noncomputable instance inv : Inv (Matrix n n \u03b1) :=\n  \u27e8fun A => Ring.inverse A.det \u2022 A.adjugate\u27e9", "start": [202, 1], "end": [204, 45], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_def", "code": "theorem inv_def (A : Matrix n n \u03b1) : A\u207b\u00b9 = Ring.inverse A.det \u2022 A.adjugate", "start": [206, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.nonsing_inv_apply_not_isUnit", "code": "theorem nonsing_inv_apply_not_isUnit (h : \u00acIsUnit A.det) : A\u207b\u00b9 = 0", "start": [210, 1], "end": [211, 53], "kind": "commanddeclaration"}, {"full_name": "Matrix.nonsing_inv_apply", "code": "theorem nonsing_inv_apply (h : IsUnit A.det) : A\u207b\u00b9 = (\u2191h.unit\u207b\u00b9 : \u03b1) \u2022 A.adjugate", "start": [214, 1], "end": [215, 61], "kind": "commanddeclaration"}, {"full_name": "Matrix.invOf_eq_nonsing_inv", "code": "@[simp]\ntheorem invOf_eq_nonsing_inv [Invertible A] : \u215f A = A\u207b\u00b9", "start": [218, 1], "end": [222, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.coe_units_inv", "code": "@[simp, norm_cast]\ntheorem coe_units_inv (A : (Matrix n n \u03b1)\u02e3) : \u2191A\u207b\u00b9 = (A\u207b\u00b9 : Matrix n n \u03b1)", "start": [225, 1], "end": [230, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.nonsing_inv_eq_ring_inverse", "code": "theorem nonsing_inv_eq_ring_inverse : A\u207b\u00b9 = Ring.inverse A", "start": [233, 1], "end": [239, 73], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_nonsing_inv", "code": "theorem transpose_nonsing_inv : A\u207b\u00b9\u1d40 = A\u1d40\u207b\u00b9", "start": [242, 1], "end": [243, 75], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_nonsing_inv", "code": "theorem conjTranspose_nonsing_inv [StarRing \u03b1] : A\u207b\u00b9\u1d34 = A\u1d34\u207b\u00b9", "start": [246, 1], "end": [248, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_nonsing_inv", "code": "@[simp]\ntheorem mul_nonsing_inv (h : IsUnit A.det) : A * A\u207b\u00b9 = 1", "start": [251, 1], "end": [255, 46], "kind": "commanddeclaration"}, {"full_name": "Matrix.nonsing_inv_mul", "code": "@[simp]\ntheorem nonsing_inv_mul (h : IsUnit A.det) : A\u207b\u00b9 * A = 1", "start": [258, 1], "end": [262, 46], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_inv_of_invertible", "code": "@[simp]\ntheorem inv_inv_of_invertible [Invertible A] : A\u207b\u00b9\u207b\u00b9 = A", "start": [269, 1], "end": [271, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_nonsing_inv_cancel_right", "code": "@[simp]\ntheorem mul_nonsing_inv_cancel_right (B : Matrix m n \u03b1) (h : IsUnit A.det) : B * A * A\u207b\u00b9 = B", "start": [274, 1], "end": [276, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_nonsing_inv_cancel_left", "code": "@[simp]\ntheorem mul_nonsing_inv_cancel_left (B : Matrix n m \u03b1) (h : IsUnit A.det) : A * (A\u207b\u00b9 * B) = B", "start": [279, 1], "end": [281, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.nonsing_inv_mul_cancel_right", "code": "@[simp]\ntheorem nonsing_inv_mul_cancel_right (B : Matrix m n \u03b1) (h : IsUnit A.det) : B * A\u207b\u00b9 * A = B", "start": [284, 1], "end": [286, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.nonsing_inv_mul_cancel_left", "code": "@[simp]\ntheorem nonsing_inv_mul_cancel_left (B : Matrix n m \u03b1) (h : IsUnit A.det) : A\u207b\u00b9 * (A * B) = B", "start": [289, 1], "end": [291, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_inv_of_invertible", "code": "@[simp]\ntheorem mul_inv_of_invertible [Invertible A] : A * A\u207b\u00b9 = 1", "start": [294, 1], "end": [296, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_mul_of_invertible", "code": "@[simp]\ntheorem inv_mul_of_invertible [Invertible A] : A\u207b\u00b9 * A = 1", "start": [299, 1], "end": [301, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_inv_cancel_right_of_invertible", "code": "@[simp]\ntheorem mul_inv_cancel_right_of_invertible (B : Matrix m n \u03b1) [Invertible A] : B * A * A\u207b\u00b9 = B", "start": [304, 1], "end": [306, 64], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_inv_cancel_left_of_invertible", "code": "@[simp]\ntheorem mul_inv_cancel_left_of_invertible (B : Matrix n m \u03b1) [Invertible A] : A * (A\u207b\u00b9 * B) = B", "start": [309, 1], "end": [311, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_mul_cancel_right_of_invertible", "code": "@[simp]\ntheorem inv_mul_cancel_right_of_invertible (B : Matrix m n \u03b1) [Invertible A] : B * A\u207b\u00b9 * A = B", "start": [314, 1], "end": [316, 64], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_mul_cancel_left_of_invertible", "code": "@[simp]\ntheorem inv_mul_cancel_left_of_invertible (B : Matrix n m \u03b1) [Invertible A] : A\u207b\u00b9 * (A * B) = B", "start": [319, 1], "end": [321, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_mul_eq_iff_eq_mul_of_invertible", "code": "theorem inv_mul_eq_iff_eq_mul_of_invertible (A B C : Matrix n n \u03b1) [Invertible A] :\n    A\u207b\u00b9 * B = C \u2194 B = A * C", "start": [324, 1], "end": [327, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_inv_eq_iff_eq_mul_of_invertible", "code": "theorem mul_inv_eq_iff_eq_mul_of_invertible (A B C : Matrix n n \u03b1) [Invertible A] :\n    B * A\u207b\u00b9 = C \u2194 B = C * A", "start": [330, 1], "end": [333, 59], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_right_injective_of_invertible", "code": "lemma mul_right_injective_of_invertible [Invertible A] :\n    Function.Injective (fun (x : Matrix n m \u03b1) => A * x) :=\n  fun _ _ h => by simpa only [inv_mul_cancel_left_of_invertible] using congr_arg (A\u207b\u00b9 * \u00b7) h", "start": [336, 1], "end": [338, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.mul_left_injective_of_invertible", "code": "lemma mul_left_injective_of_invertible [Invertible A] :\n    Function.Injective (fun (x : Matrix m n \u03b1) => x * A) :=\n  fun a x hax => by simpa only [mul_inv_cancel_right_of_invertible] using congr_arg (\u00b7 * A\u207b\u00b9) hax", "start": [340, 1], "end": [342, 98], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.mul_right_inj_of_invertible", "code": "lemma mul_right_inj_of_invertible [Invertible A] {x y : Matrix n m \u03b1} : A * x = A * y \u2194 x = y :=\n  (mul_right_injective_of_invertible A).eq_iff", "start": [344, 1], "end": [345, 47], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.mul_left_inj_of_invertible", "code": "lemma mul_left_inj_of_invertible [Invertible A] {x y : Matrix m n \u03b1} : x * A = y * A \u2194 x = y :=\n  (mul_left_injective_of_invertible A).eq_iff", "start": [347, 1], "end": [348, 46], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.mul_left_injective_of_inv", "code": "lemma mul_left_injective_of_inv (A : Matrix m n \u03b1) (B : Matrix n m \u03b1) (h : A * B = 1) :\n    Function.Injective (fun x : Matrix l m \u03b1 => x * A) :=\n  fun _ _ g => by simpa only [Matrix.mul_assoc, Matrix.mul_one, h] using congr_arg (\u00b7 * B) g", "start": [354, 1], "end": [356, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.mul_right_injective_of_inv", "code": "lemma mul_right_injective_of_inv (A : Matrix m n \u03b1) (B : Matrix n m \u03b1) (h : A * B = 1) :\n    Function.Injective (fun x : Matrix m l \u03b1 => B * x) :=\n  fun _ _ g => by simpa only [\u2190 Matrix.mul_assoc, Matrix.one_mul, h] using congr_arg (A * \u00b7) g", "start": [358, 1], "end": [360, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.nonsing_inv_cancel_or_zero", "code": "theorem nonsing_inv_cancel_or_zero : A\u207b\u00b9 * A = 1 \u2227 A * A\u207b\u00b9 = 1 \u2228 A\u207b\u00b9 = 0", "start": [364, 1], "end": [367, 52], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_nonsing_inv_mul_det", "code": "theorem det_nonsing_inv_mul_det (h : IsUnit A.det) : A\u207b\u00b9.det * A.det = 1", "start": [370, 1], "end": [371, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_nonsing_inv", "code": "@[simp]\ntheorem det_nonsing_inv : A\u207b\u00b9.det = Ring.inverse A.det", "start": [374, 1], "end": [382, 83], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_nonsing_inv_det", "code": "theorem isUnit_nonsing_inv_det (h : IsUnit A.det) : IsUnit A\u207b\u00b9.det", "start": [385, 1], "end": [386, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.nonsing_inv_nonsing_inv", "code": "@[simp]\ntheorem nonsing_inv_nonsing_inv (h : IsUnit A.det) : A\u207b\u00b9\u207b\u00b9 = A", "start": [389, 1], "end": [395, 94], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_nonsing_inv_det_iff", "code": "theorem isUnit_nonsing_inv_det_iff {A : Matrix n n \u03b1} : IsUnit A\u207b\u00b9.det \u2194 IsUnit A.det", "start": [399, 1], "end": [400, 51], "kind": "commanddeclaration"}, {"full_name": "Matrix.invertibleOfIsUnitDet", "code": "noncomputable def invertibleOfIsUnitDet (h : IsUnit A.det) : Invertible A :=\n  \u27e8A\u207b\u00b9, nonsing_inv_mul A h, mul_nonsing_inv A h\u27e9", "start": [404, 1], "end": [407, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.nonsingInvUnit", "code": "noncomputable def nonsingInvUnit (h : IsUnit A.det) : (Matrix n n \u03b1)\u02e3 :=\n  @unitOfInvertible _ _ _ (invertibleOfIsUnitDet A h)", "start": [410, 1], "end": [413, 54], "kind": "commanddeclaration"}, {"full_name": "Matrix.unitOfDetInvertible_eq_nonsingInvUnit", "code": "theorem unitOfDetInvertible_eq_nonsingInvUnit [Invertible A.det] :\n    unitOfDetInvertible A = nonsingInvUnit A (isUnit_of_invertible _)", "start": [416, 1], "end": [419, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_eq_left_inv", "code": "theorem inv_eq_left_inv (h : B * A = 1) : A\u207b\u00b9 = B", "start": [424, 1], "end": [427, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_eq_right_inv", "code": "theorem inv_eq_right_inv (h : A * B = 1) : A\u207b\u00b9 = B", "start": [430, 1], "end": [432, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.left_inv_eq_left_inv", "code": "theorem left_inv_eq_left_inv (h : B * A = 1) (g : C * A = 1) : B = C", "start": [439, 1], "end": [441, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.right_inv_eq_right_inv", "code": "theorem right_inv_eq_right_inv (h : A * B = 1) (g : A * C = 1) : B = C", "start": [444, 1], "end": [446, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.right_inv_eq_left_inv", "code": "theorem right_inv_eq_left_inv (h : A * B = 1) (g : C * A = 1) : B = C", "start": [449, 1], "end": [451, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_inj", "code": "theorem inv_inj (h : A\u207b\u00b9 = B\u207b\u00b9) (h' : IsUnit A.det) : A = B", "start": [454, 1], "end": [458, 70], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_zero", "code": "@[simp]\ntheorem inv_zero : (0 : Matrix n n \u03b1)\u207b\u00b9 = 0", "start": [465, 1], "end": [476, 14], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_smul", "code": "theorem inv_smul (k : \u03b1) [Invertible k] (h : IsUnit A.det) : (k \u2022 A)\u207b\u00b9 = \u215f k \u2022 A\u207b\u00b9", "start": [482, 1], "end": [483, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_smul'", "code": "theorem inv_smul' (k : \u03b1\u02e3) (h : IsUnit A.det) : (k \u2022 A)\u207b\u00b9 = k\u207b\u00b9 \u2022 A\u207b\u00b9", "start": [486, 1], "end": [487, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_adjugate", "code": "theorem inv_adjugate (A : Matrix n n \u03b1) (h : IsUnit A.det) : (adjugate A)\u207b\u00b9 = h.unit\u207b\u00b9 \u2022 A", "start": [490, 1], "end": [492, 82], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonalInvertible", "code": "def diagonalInvertible {\u03b1} [NonAssocSemiring \u03b1] (v : n \u2192 \u03b1) [Invertible v] :\n    Invertible (diagonal v) :=\n  Invertible.map (diagonalRingHom n \u03b1) v", "start": [497, 1], "end": [500, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.invOf_diagonal_eq", "code": "theorem invOf_diagonal_eq {\u03b1} [Semiring \u03b1] (v : n \u2192 \u03b1) [Invertible v] [Invertible (diagonal v)] :\n    \u215f (diagonal v) = diagonal (\u215f v)", "start": [503, 1], "end": [507, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.invertibleOfDiagonalInvertible", "code": "def invertibleOfDiagonalInvertible (v : n \u2192 \u03b1) [Invertible (diagonal v)] : Invertible v where\n  invOf := diag (\u215f (diagonal v))\n  invOf_mul_self :=\n    funext fun i => by\n      letI : Invertible (diagonal v).det := detInvertibleOfInvertible _\n      rw [invOf_eq, diag_smul, adjugate_diagonal, diag_diagonal]\n      dsimp\n      rw [mul_assoc, prod_erase_mul _ _ (Finset.mem_univ _), \u2190 det_diagonal]\n      exact mul_invOf_self _\n  mul_invOf_self :=\n    funext fun i => by\n      letI : Invertible (diagonal v).det := detInvertibleOfInvertible _\n      rw [invOf_eq, diag_smul, adjugate_diagonal, diag_diagonal]\n      dsimp\n      rw [mul_left_comm, mul_prod_erase _ _ (Finset.mem_univ _), \u2190 det_diagonal]\n      exact mul_invOf_self _", "start": [510, 1], "end": [526, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonalInvertibleEquivInvertible", "code": "@[simps]\ndef diagonalInvertibleEquivInvertible (v : n \u2192 \u03b1) : Invertible (diagonal v) \u2243 Invertible v where\n  toFun := @invertibleOfDiagonalInvertible _ _ _ _ _ _\n  invFun := @diagonalInvertible _ _ _ _ _ _\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _", "start": [529, 1], "end": [536, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_diagonal", "code": "@[simp]\ntheorem isUnit_diagonal {v : n \u2192 \u03b1} : IsUnit (diagonal v) \u2194 IsUnit v", "start": [539, 1], "end": [543, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_diagonal", "code": "theorem inv_diagonal (v : n \u2192 \u03b1) : (diagonal v)\u207b\u00b9 = diagonal (Ring.inverse v)", "start": [546, 1], "end": [554, 93], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_inv_inv", "code": "@[simp]\ntheorem inv_inv_inv (A : Matrix n n \u03b1) : A\u207b\u00b9\u207b\u00b9\u207b\u00b9 = A\u207b\u00b9", "start": [559, 1], "end": [563, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_inv_rev", "code": "theorem mul_inv_rev (A B : Matrix n n \u03b1) : (A * B)\u207b\u00b9 = B\u207b\u00b9 * A\u207b\u00b9", "start": [566, 1], "end": [569, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.list_prod_inv_reverse", "code": "theorem list_prod_inv_reverse : \u2200 l : List (Matrix n n \u03b1), l.prod\u207b\u00b9 = (l.reverse.map Inv.inv).prod", "start": [572, 1], "end": [577, 45], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_smul_inv_mulVec_eq_cramer", "code": "@[simp]\ntheorem det_smul_inv_mulVec_eq_cramer (A : Matrix n n \u03b1) (b : n \u2192 \u03b1) (h : IsUnit A.det) :\n    A.det \u2022 A\u207b\u00b9.mulVec b = cramer A b", "start": [580, 1], "end": [585, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_smul_inv_vecMul_eq_cramer_transpose", "code": "@[simp]\ntheorem det_smul_inv_vecMul_eq_cramer_transpose (A : Matrix n n \u03b1) (b : n \u2192 \u03b1) (h : IsUnit A.det) :\n    A.det \u2022 A\u207b\u00b9.vecMul b = cramer A\u1d40 b", "start": [588, 1], "end": [593, 67], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrixEquivInvertible", "code": "def submatrixEquivInvertible (A : Matrix m m \u03b1) (e\u2081 e\u2082 : n \u2243 m) [Invertible A] :\n    Invertible (A.submatrix e\u2081 e\u2082) :=\n  invertibleOfRightInverse _ ((\u215f A).submatrix e\u2082 e\u2081) <| by\n    rw [Matrix.submatrix_mul_equiv, mul_invOf_self, submatrix_one_equiv]", "start": [609, 1], "end": [613, 73], "kind": "commanddeclaration"}, {"full_name": "Matrix.invertibleOfSubmatrixEquivInvertible", "code": "def invertibleOfSubmatrixEquivInvertible (A : Matrix m m \u03b1) (e\u2081 e\u2082 : n \u2243 m)\n    [Invertible (A.submatrix e\u2081 e\u2082)] : Invertible A :=\n  invertibleOfRightInverse _ ((\u215f (A.submatrix e\u2081 e\u2082)).submatrix e\u2082.symm e\u2081.symm) <| by\n    have : A = (A.submatrix e\u2081 e\u2082).submatrix e\u2081.symm e\u2082.symm := by simp\n    rw [congr_arg\u2082 (\u00b7 * \u00b7) this rfl]\n    rw [Matrix.submatrix_mul_equiv, mul_invOf_self, submatrix_one_equiv]", "start": [616, 1], "end": [626, 73], "kind": "commanddeclaration"}, {"full_name": "Matrix.invOf_submatrix_equiv_eq", "code": "theorem invOf_submatrix_equiv_eq (A : Matrix m m \u03b1) (e\u2081 e\u2082 : n \u2243 m) [Invertible A]\n    [Invertible (A.submatrix e\u2081 e\u2082)] : \u215f (A.submatrix e\u2081 e\u2082) = (\u215f A).submatrix e\u2082 e\u2081", "start": [629, 1], "end": [633, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrixEquivInvertibleEquivInvertible", "code": "@[simps]\ndef submatrixEquivInvertibleEquivInvertible (A : Matrix m m \u03b1) (e\u2081 e\u2082 : n \u2243 m) :\n    Invertible (A.submatrix e\u2081 e\u2082) \u2243 Invertible A where\n  toFun _ := invertibleOfSubmatrixEquivInvertible A e\u2081 e\u2082\n  invFun _ := submatrixEquivInvertible A e\u2081 e\u2082\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _", "start": [636, 1], "end": [645, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_submatrix_equiv", "code": "@[simp]\ntheorem isUnit_submatrix_equiv {A : Matrix m m \u03b1} (e\u2081 e\u2082 : n \u2243 m) :\n    IsUnit (A.submatrix e\u2081 e\u2082) \u2194 IsUnit A", "start": [648, 1], "end": [653, 68], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_submatrix_equiv", "code": "@[simp]\ntheorem inv_submatrix_equiv (A : Matrix m m \u03b1) (e\u2081 e\u2082 : n \u2243 m) :\n    (A.submatrix e\u2081 e\u2082)\u207b\u00b9 = A\u207b\u00b9.submatrix e\u2082 e\u2081", "start": [656, 1], "end": [665, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_reindex", "code": "theorem inv_reindex (e\u2081 e\u2082 : n \u2243 m) (A : Matrix n n \u03b1) : (reindex e\u2081 e\u2082 A)\u207b\u00b9 = reindex e\u2082 e\u2081 A\u207b\u00b9", "start": [668, 1], "end": [669, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_conj", "code": "theorem det_conj {M : Matrix m m \u03b1} (h : IsUnit M) (N : Matrix m m \u03b1) : det (M * N * M\u207b\u00b9) = det N", "start": [681, 1], "end": [683, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_conj'", "code": "theorem det_conj' {M : Matrix m m \u03b1} (h : IsUnit M) (N : Matrix m m \u03b1) :\n    det (M\u207b\u00b9 * N * M) = det N", "start": [686, 1], "end": [688, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Basis.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/ToLin.lean", "Mathlib/LinearAlgebra/Matrix/Reindex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Basis.toMatrix", "code": "def Basis.toMatrix (e : Basis \u03b9 R M) (v : \u03b9' \u2192 M) : Matrix \u03b9 \u03b9' R := fun i j => e.repr (v j) i", "start": [53, 1], "end": [55, 95], "kind": "commanddeclaration"}, {"full_name": "Basis.toMatrix_apply", "code": "theorem toMatrix_apply : e.toMatrix v i j = e.repr (v j) i", "start": [62, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.toMatrix_transpose_apply", "code": "theorem toMatrix_transpose_apply : (e.toMatrix v)\u1d40 j = e.repr (v j)", "start": [66, 1], "end": [67, 22], "kind": "commanddeclaration"}, {"full_name": "Basis.toMatrix_eq_toMatrix_constr", "code": "theorem toMatrix_eq_toMatrix_constr [Fintype \u03b9] [DecidableEq \u03b9] (v : \u03b9 \u2192 M) :\n    e.toMatrix v = LinearMap.toMatrix e e (e.constr \u2115 v)", "start": [70, 1], "end": [73, 74], "kind": "commanddeclaration"}, {"full_name": "Basis.coePiBasisFun.toMatrix_eq_transpose", "code": "theorem coePiBasisFun.toMatrix_eq_transpose [Fintype \u03b9] :\n    ((Pi.basisFun R \u03b9).toMatrix : Matrix \u03b9 \u03b9 R \u2192 Matrix \u03b9 \u03b9 R) = Matrix.transpose", "start": [77, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.toMatrix_self", "code": "@[simp]\ntheorem toMatrix_self [DecidableEq \u03b9] : e.toMatrix e = 1", "start": [83, 1], "end": [87, 73], "kind": "commanddeclaration"}, {"full_name": "Basis.toMatrix_update", "code": "theorem toMatrix_update [DecidableEq \u03b9'] (x : M) :\n    e.toMatrix (Function.update v j x) = Matrix.updateColumn (e.toMatrix v) j (e.repr x)", "start": [90, 1], "end": [96, 24], "kind": "commanddeclaration"}, {"full_name": "Basis.toMatrix_unitsSMul", "code": "@[simp]\ntheorem toMatrix_unitsSMul [DecidableEq \u03b9] (e : Basis \u03b9 R\u2082 M\u2082) (w : \u03b9 \u2192 R\u2082\u02e3) :\n    e.toMatrix (e.unitsSMul w) = diagonal ((\u2191) \u2218 w)", "start": [99, 1], "end": [106, 73], "kind": "commanddeclaration"}, {"full_name": "Basis.toMatrix_isUnitSMul", "code": "@[simp]\ntheorem toMatrix_isUnitSMul [DecidableEq \u03b9] (e : Basis \u03b9 R\u2082 M\u2082) {w : \u03b9 \u2192 R\u2082}\n    (hw : \u2200 i, IsUnit (w i)) : e.toMatrix (e.isUnitSMul hw) = diagonal w", "start": [109, 1], "end": [113, 25], "kind": "commanddeclaration"}, {"full_name": "Basis.sum_toMatrix_smul_self", "code": "@[simp]\ntheorem sum_toMatrix_smul_self [Fintype \u03b9] : \u2211 i : \u03b9, e.toMatrix v i j \u2022 e i = v j", "start": [116, 1], "end": [118, 41], "kind": "commanddeclaration"}, {"full_name": "Basis.toMatrix_map_vecMul", "code": "theorem toMatrix_map_vecMul {S : Type*} [Ring S] [Algebra R S] [Fintype \u03b9] (b : Basis \u03b9 R S)\n    (v : \u03b9' \u2192 S) : ((b.toMatrix v).map <| algebraMap R S).vecMul b = v", "start": [121, 1], "end": [125, 28], "kind": "commanddeclaration"}, {"full_name": "Basis.toLin_toMatrix", "code": "@[simp]\ntheorem toLin_toMatrix [Fintype \u03b9] [Fintype \u03b9'] [DecidableEq \u03b9'] (v : Basis \u03b9' R M) :\n    Matrix.toLin v e (e.toMatrix v) = LinearMap.id", "start": [128, 1], "end": [131, 72], "kind": "commanddeclaration"}, {"full_name": "Basis.toMatrixEquiv", "code": "def toMatrixEquiv [Fintype \u03b9] (e : Basis \u03b9 R M) : (\u03b9 \u2192 M) \u2243\u2097[R] Matrix \u03b9 \u03b9 R where\n  toFun := e.toMatrix\n  map_add' v w := by\n    ext i j\n    change _ = _ + _\n    rw [e.toMatrix_apply, Pi.add_apply, LinearEquiv.map_add]\n    rfl\n  map_smul' := by\n    intro c v\n    ext i j\n    dsimp only []\n    rw [e.toMatrix_apply, Pi.smul_apply, LinearEquiv.map_smul]\n    rfl\n  invFun m j := \u2211 i, m i j \u2022 e i\n  left_inv := by\n    intro v\n    ext j\n    exact e.sum_toMatrix_smul_self v j\n  right_inv := by\n    intro m\n    ext k l\n    simp only [e.toMatrix_apply, \u2190 e.equivFun_apply, \u2190 e.equivFun_symm_apply,\n      LinearEquiv.apply_symm_apply]", "start": [134, 1], "end": [158, 36], "kind": "commanddeclaration"}, {"full_name": "basis_toMatrix_mul_linearMap_toMatrix", "code": "@[simp]\ntheorem basis_toMatrix_mul_linearMap_toMatrix [DecidableEq \u03b9'] :\n    c.toMatrix c' * LinearMap.toMatrix b' c' f = LinearMap.toMatrix b' c f", "start": [177, 1], "end": [183, 89], "kind": "commanddeclaration"}, {"full_name": "linearMap_toMatrix_mul_basis_toMatrix", "code": "@[simp]\ntheorem linearMap_toMatrix_mul_basis_toMatrix [DecidableEq \u03b9] [DecidableEq \u03b9'] :\n    LinearMap.toMatrix b' c' f * b'.toMatrix b = LinearMap.toMatrix b c' f", "start": [188, 1], "end": [192, 92], "kind": "commanddeclaration"}, {"full_name": "basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix", "code": "theorem basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix [DecidableEq \u03b9] [DecidableEq \u03b9'] :\n    c.toMatrix c' * LinearMap.toMatrix b' c' f * b'.toMatrix b = LinearMap.toMatrix b c f", "start": [195, 1], "end": [197, 84], "kind": "commanddeclaration"}, {"full_name": "basis_toMatrix_mul", "code": "theorem basis_toMatrix_mul [DecidableEq \u03ba] (b\u2081 : Basis \u03b9 R M) (b\u2082 : Basis \u03b9' R M) (b\u2083 : Basis \u03ba R N)\n    (A : Matrix \u03b9' \u03ba R) : b\u2081.toMatrix b\u2082 * A = LinearMap.toMatrix b\u2083 b\u2081 (toLin b\u2083 b\u2082 A)", "start": [200, 1], "end": [203, 41], "kind": "commanddeclaration"}, {"full_name": "mul_basis_toMatrix", "code": "theorem mul_basis_toMatrix [DecidableEq \u03b9] [DecidableEq \u03b9'] (b\u2081 : Basis \u03b9 R M) (b\u2082 : Basis \u03b9' R M)\n    (b\u2083 : Basis \u03ba R N) (A : Matrix \u03ba \u03b9 R) :\n    A * b\u2081.toMatrix b\u2082 = LinearMap.toMatrix b\u2082 b\u2083 (toLin b\u2081 b\u2083 A)", "start": [206, 1], "end": [210, 41], "kind": "commanddeclaration"}, {"full_name": "basis_toMatrix_basisFun_mul", "code": "theorem basis_toMatrix_basisFun_mul (b : Basis \u03b9 R (\u03b9 \u2192 R)) (A : Matrix \u03b9 \u03b9 R) :\n    b.toMatrix (Pi.basisFun R \u03b9) * A = of fun i j => b.repr (A\u1d40 j) i", "start": [213, 1], "end": [219, 53], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_id_eq_basis_toMatrix", "code": "@[simp]\ntheorem LinearMap.toMatrix_id_eq_basis_toMatrix [DecidableEq \u03b9] :\n    LinearMap.toMatrix b b' id = b'.toMatrix b", "start": [222, 1], "end": [227, 83], "kind": "commanddeclaration"}, {"full_name": "Basis.toMatrix_reindex'", "code": "theorem Basis.toMatrix_reindex' [DecidableEq \u03b9] [DecidableEq \u03b9'] (b : Basis \u03b9 R M) (v : \u03b9' \u2192 M)\n    (e : \u03b9 \u2243 \u03b9') : (b.reindex e).toMatrix v = Matrix.reindexAlgEquiv _ e (b.toMatrix (v \u2218 e))", "start": [230, 1], "end": [236, 35], "kind": "commanddeclaration"}, {"full_name": "Basis.toMatrix_mul_toMatrix", "code": "@[simp]\ntheorem Basis.toMatrix_mul_toMatrix {\u03b9'' : Type*} [Fintype \u03b9'] (b'' : \u03b9'' \u2192 M) :\n    b.toMatrix b' * b'.toMatrix b'' = b.toMatrix b''", "start": [241, 1], "end": [249, 78], "kind": "commanddeclaration"}, {"full_name": "Basis.toMatrix_mul_toMatrix_flip", "code": "theorem Basis.toMatrix_mul_toMatrix_flip [DecidableEq \u03b9] [Fintype \u03b9'] :\n    b.toMatrix b' * b'.toMatrix b = 1", "start": [252, 1], "end": [254, 98], "kind": "commanddeclaration"}, {"full_name": "Basis.invertibleToMatrix", "code": "def Basis.invertibleToMatrix [DecidableEq \u03b9] [Fintype \u03b9] (b b' : Basis \u03b9 R\u2082 M\u2082) :\n    Invertible (b.toMatrix b') :=\n  \u27e8b'.toMatrix b, Basis.toMatrix_mul_toMatrix_flip _ _, Basis.toMatrix_mul_toMatrix_flip _ _\u27e9", "start": [257, 1], "end": [260, 94], "kind": "commanddeclaration"}, {"full_name": "Basis.toMatrix_reindex", "code": "@[simp]\ntheorem Basis.toMatrix_reindex (b : Basis \u03b9 R M) (v : \u03b9' \u2192 M) (e : \u03b9 \u2243 \u03b9') :\n    (b.reindex e).toMatrix v = (b.toMatrix v).submatrix e.symm _root_.id", "start": [263, 1], "end": [268, 35], "kind": "commanddeclaration"}, {"full_name": "Basis.toMatrix_map", "code": "@[simp]\ntheorem Basis.toMatrix_map (b : Basis \u03b9 R M) (f : M \u2243\u2097[R] N) (v : \u03b9 \u2192 N) :\n    (b.map f).toMatrix v = b.toMatrix (f.symm \u2218 v)", "start": [271, 1], "end": [275, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Order/Lattice.lean", "imports": ["Mathlib/Topology/Order/Basic.lean", "Mathlib/Topology/Constructions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousInf", "code": "class ContinuousInf (L : Type*) [TopologicalSpace L] [Inf L] : Prop where\n  \n  continuous_inf : Continuous fun p : L \u00d7 L => p.1 \u2293 p.2", "start": [34, 1], "end": [40, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousSup", "code": "class ContinuousSup (L : Type*) [TopologicalSpace L] [Sup L] : Prop where\n  \n  continuous_sup : Continuous fun p : L \u00d7 L => p.1 \u2294 p.2", "start": [43, 1], "end": [49, 57], "kind": "commanddeclaration"}, {"full_name": "OrderDual.continuousSup", "code": "instance (priority := 100) OrderDual.continuousSup (L : Type*) [TopologicalSpace L] [Inf L]\n    [ContinuousInf L] : ContinuousSup L\u1d52\u1d48 where\n  continuous_sup := @ContinuousInf.continuous_inf L _ _ _", "start": [53, 1], "end": [55, 58], "kind": "commanddeclaration"}, {"full_name": "OrderDual.continuousInf", "code": "instance (priority := 100) OrderDual.continuousInf (L : Type*) [TopologicalSpace L] [Sup L]\n    [ContinuousSup L] : ContinuousInf L\u1d52\u1d48 where\n  continuous_inf := @ContinuousSup.continuous_sup L _ _ _", "start": [59, 1], "end": [61, 58], "kind": "commanddeclaration"}, {"full_name": "TopologicalLattice", "code": "class TopologicalLattice (L : Type*) [TopologicalSpace L] [Lattice L]\n  extends ContinuousInf L, ContinuousSup L : Prop", "start": [64, 1], "end": [68, 50], "kind": "commanddeclaration"}, {"full_name": "OrderDual.topologicalLattice", "code": "instance (priority := 100) OrderDual.topologicalLattice (L : Type*) [TopologicalSpace L]\n    [Lattice L] [TopologicalLattice L] : TopologicalLattice L\u1d52\u1d48 where", "start": [72, 1], "end": [73, 70], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.topologicalLattice", "code": "instance (priority := 100) LinearOrder.topologicalLattice {L : Type*} [TopologicalSpace L]\n    [LinearOrder L] [OrderClosedTopology L] : TopologicalLattice L\n    where\n  continuous_inf := continuous_min\n  continuous_sup := continuous_max", "start": [77, 1], "end": [81, 35], "kind": "commanddeclaration"}, {"full_name": "continuous_inf", "code": "@[continuity]\ntheorem continuous_inf [Inf L] [ContinuousInf L] : Continuous fun p : L \u00d7 L => p.1 \u2293 p.2", "start": [86, 1], "end": [88, 31], "kind": "commanddeclaration"}, {"full_name": "Continuous.inf", "code": "@[continuity]\ntheorem Continuous.inf [Inf L] [ContinuousInf L] {f g : X \u2192 L} (hf : Continuous f)\n    (hg : Continuous g) : Continuous fun x => f x \u2293 g x", "start": [91, 1], "end": [94, 42], "kind": "commanddeclaration"}, {"full_name": "continuous_sup", "code": "@[continuity]\ntheorem continuous_sup [Sup L] [ContinuousSup L] : Continuous fun p : L \u00d7 L => p.1 \u2294 p.2", "start": [97, 1], "end": [99, 31], "kind": "commanddeclaration"}, {"full_name": "Continuous.sup", "code": "@[continuity]\ntheorem Continuous.sup [Sup L] [ContinuousSup L] {f g : X \u2192 L} (hf : Continuous f)\n    (hg : Continuous g) : Continuous fun x => f x \u2294 g x", "start": [102, 1], "end": [105, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.sup_right_nhds'", "code": "theorem Filter.Tendsto.sup_right_nhds' {\u03b9 \u03b2} [TopologicalSpace \u03b2] [Sup \u03b2] [ContinuousSup \u03b2]\n    {l : Filter \u03b9} {f g : \u03b9 \u2192 \u03b2} {x y : \u03b2} (hf : Tendsto f l (\ud835\udcdd x)) (hg : Tendsto g l (\ud835\udcdd y)) :\n    Tendsto (f \u2294 g) l (\ud835\udcdd (x \u2294 y))", "start": [108, 1], "end": [111, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.sup_right_nhds", "code": "theorem Filter.Tendsto.sup_right_nhds {\u03b9 \u03b2} [TopologicalSpace \u03b2] [Sup \u03b2] [ContinuousSup \u03b2]\n    {l : Filter \u03b9} {f g : \u03b9 \u2192 \u03b2} {x y : \u03b2} (hf : Tendsto f l (\ud835\udcdd x)) (hg : Tendsto g l (\ud835\udcdd y)) :\n    Tendsto (fun i => f i \u2294 g i) l (\ud835\udcdd (x \u2294 y))", "start": [114, 1], "end": [117, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.inf_right_nhds'", "code": "theorem Filter.Tendsto.inf_right_nhds' {\u03b9 \u03b2} [TopologicalSpace \u03b2] [Inf \u03b2] [ContinuousInf \u03b2]\n    {l : Filter \u03b9} {f g : \u03b9 \u2192 \u03b2} {x y : \u03b2} (hf : Tendsto f l (\ud835\udcdd x)) (hg : Tendsto g l (\ud835\udcdd y)) :\n    Tendsto (f \u2293 g) l (\ud835\udcdd (x \u2293 y))", "start": [120, 1], "end": [123, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.inf_right_nhds", "code": "theorem Filter.Tendsto.inf_right_nhds {\u03b9 \u03b2} [TopologicalSpace \u03b2] [Inf \u03b2] [ContinuousInf \u03b2]\n    {l : Filter \u03b9} {f g : \u03b9 \u2192 \u03b2} {x y : \u03b2} (hf : Tendsto f l (\ud835\udcdd x)) (hg : Tendsto g l (\ud835\udcdd y)) :\n    Tendsto (fun i => f i \u2293 g i) l (\ud835\udcdd (x \u2293 y))", "start": [126, 1], "end": [129, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Lattice.lean", "imports": ["Mathlib/MeasureTheory/Measure/AEMeasurable.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasurableSup", "code": "class MeasurableSup (M : Type*) [MeasurableSpace M] [Sup M] : Prop where\n  measurable_const_sup : \u2200 c : M, Measurable (c \u2294 \u00b7)\n  measurable_sup_const : \u2200 c : M, Measurable (\u00b7 \u2294 c)", "start": [35, 1], "end": [39, 53], "kind": "commanddeclaration"}, {"full_name": "MeasurableSup\u2082", "code": "class MeasurableSup\u2082 (M : Type*) [MeasurableSpace M] [Sup M] : Prop where\n  measurable_sup : Measurable fun p : M \u00d7 M => p.1 \u2294 p.2", "start": [44, 1], "end": [47, 57], "kind": "commanddeclaration"}, {"full_name": "MeasurableInf", "code": "class MeasurableInf (M : Type*) [MeasurableSpace M] [Inf M] : Prop where\n  measurable_const_inf : \u2200 c : M, Measurable (c \u2293 \u00b7)\n  measurable_inf_const : \u2200 c : M, Measurable (\u00b7 \u2293 c)", "start": [55, 1], "end": [59, 53], "kind": "commanddeclaration"}, {"full_name": "MeasurableInf\u2082", "code": "class MeasurableInf\u2082 (M : Type*) [MeasurableSpace M] [Inf M] : Prop where\n  measurable_inf : Measurable fun p : M \u00d7 M => p.1 \u2293 p.2", "start": [64, 1], "end": [67, 57], "kind": "commanddeclaration"}, {"full_name": "OrderDual.instMeasurableSup", "code": "instance (priority := 100) OrderDual.instMeasurableSup [Inf M] [MeasurableInf M] :\n    MeasurableSup M\u1d52\u1d48 :=\n  \u27e8@measurable_const_inf M _ _ _, @measurable_inf_const M _ _ _\u27e9", "start": [79, 1], "end": [81, 65], "kind": "commanddeclaration"}, {"full_name": "OrderDual.instMeasurableInf", "code": "instance (priority := 100) OrderDual.instMeasurableInf [Sup M] [MeasurableSup M] :\n    MeasurableInf M\u1d52\u1d48 :=\n  \u27e8@measurable_const_sup M _ _ _, @measurable_sup_const M _ _ _\u27e9", "start": [84, 1], "end": [86, 65], "kind": "commanddeclaration"}, {"full_name": "OrderDual.instMeasurableSup\u2082", "code": "instance (priority := 100) OrderDual.instMeasurableSup\u2082 [Inf M] [MeasurableInf\u2082 M] :\n    MeasurableSup\u2082 M\u1d52\u1d48 :=\n  \u27e8@measurable_inf M _ _ _\u27e9", "start": [89, 1], "end": [91, 28], "kind": "commanddeclaration"}, {"full_name": "OrderDual.instMeasurableInf\u2082", "code": "instance (priority := 100) OrderDual.instMeasurableInf\u2082 [Sup M] [MeasurableSup\u2082 M] :\n    MeasurableInf\u2082 M\u1d52\u1d48 :=\n  \u27e8@measurable_sup M _ _ _\u27e9", "start": [94, 1], "end": [96, 28], "kind": "commanddeclaration"}, {"full_name": "Measurable.const_sup", "code": "@[measurability]\ntheorem Measurable.const_sup (hf : Measurable f) (c : M) : Measurable fun x => c \u2294 f x", "start": [111, 1], "end": [113, 35], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.const_sup", "code": "@[measurability]\ntheorem AEMeasurable.const_sup (hf : AEMeasurable f \u03bc) (c : M) :\n    AEMeasurable (fun x => c \u2294 f x) \u03bc", "start": [116, 1], "end": [119, 62], "kind": "commanddeclaration"}, {"full_name": "Measurable.sup_const", "code": "@[measurability]\ntheorem Measurable.sup_const (hf : Measurable f) (c : M) : Measurable fun x => f x \u2294 c", "start": [122, 1], "end": [124, 35], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.sup_const", "code": "@[measurability]\ntheorem AEMeasurable.sup_const (hf : AEMeasurable f \u03bc) (c : M) :\n    AEMeasurable (fun x => f x \u2294 c) \u03bc", "start": [127, 1], "end": [130, 48], "kind": "commanddeclaration"}, {"full_name": "Measurable.sup'", "code": "@[measurability]\ntheorem Measurable.sup' (hf : Measurable f) (hg : Measurable g) : Measurable (f \u2294 g)", "start": [139, 1], "end": [141, 38], "kind": "commanddeclaration"}, {"full_name": "Measurable.sup", "code": "@[measurability]\ntheorem Measurable.sup (hf : Measurable f) (hg : Measurable g) : Measurable fun a => f a \u2294 g a", "start": [144, 1], "end": [146, 38], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.sup'", "code": "@[measurability]\ntheorem AEMeasurable.sup' (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    AEMeasurable (f \u2294 g) \u03bc", "start": [149, 1], "end": [152, 51], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.sup", "code": "@[measurability]\ntheorem AEMeasurable.sup (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    AEMeasurable (fun a => f a \u2294 g a) \u03bc", "start": [155, 1], "end": [158, 51], "kind": "commanddeclaration"}, {"full_name": "MeasurableSup\u2082.toMeasurableSup", "code": "instance (priority := 100) MeasurableSup\u2082.toMeasurableSup : MeasurableSup M :=\n  \u27e8fun _ => measurable_const.sup measurable_id, fun _ => measurable_id.sup measurable_const\u27e9", "start": [161, 1], "end": [162, 93], "kind": "commanddeclaration"}, {"full_name": "Measurable.const_inf", "code": "@[measurability]\ntheorem Measurable.const_inf (hf : Measurable f) (c : M) : Measurable fun x => c \u2293 f x", "start": [177, 1], "end": [179, 35], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.const_inf", "code": "@[measurability]\ntheorem AEMeasurable.const_inf (hf : AEMeasurable f \u03bc) (c : M) :\n    AEMeasurable (fun x => c \u2293 f x) \u03bc", "start": [182, 1], "end": [185, 62], "kind": "commanddeclaration"}, {"full_name": "Measurable.inf_const", "code": "@[measurability]\ntheorem Measurable.inf_const (hf : Measurable f) (c : M) : Measurable fun x => f x \u2293 c", "start": [188, 1], "end": [190, 35], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.inf_const", "code": "@[measurability]\ntheorem AEMeasurable.inf_const (hf : AEMeasurable f \u03bc) (c : M) :\n    AEMeasurable (fun x => f x \u2293 c) \u03bc", "start": [193, 1], "end": [196, 48], "kind": "commanddeclaration"}, {"full_name": "Measurable.inf'", "code": "@[measurability]\ntheorem Measurable.inf' (hf : Measurable f) (hg : Measurable g) : Measurable (f \u2293 g)", "start": [205, 1], "end": [207, 38], "kind": "commanddeclaration"}, {"full_name": "Measurable.inf", "code": "@[measurability]\ntheorem Measurable.inf (hf : Measurable f) (hg : Measurable g) : Measurable fun a => f a \u2293 g a", "start": [210, 1], "end": [212, 38], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.inf'", "code": "@[measurability]\ntheorem AEMeasurable.inf' (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    AEMeasurable (f \u2293 g) \u03bc", "start": [215, 1], "end": [218, 51], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.inf", "code": "@[measurability]\ntheorem AEMeasurable.inf (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    AEMeasurable (fun a => f a \u2293 g a) \u03bc", "start": [221, 1], "end": [224, 51], "kind": "commanddeclaration"}, {"full_name": "MeasurableInf\u2082.to_hasMeasurableInf", "code": "instance (priority := 100) MeasurableInf\u2082.to_hasMeasurableInf : MeasurableInf M :=\n  \u27e8fun _ => measurable_const.inf measurable_id, fun _ => measurable_id.inf measurable_const\u27e9", "start": [227, 1], "end": [228, 93], "kind": "commanddeclaration"}, {"full_name": "Finset.measurable_sup'", "code": "@[measurability]\ntheorem Finset.measurable_sup' {\u03b9 : Type*} {s : Finset \u03b9} (hs : s.Nonempty) {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1}\n    (hf : \u2200 n \u2208 s, Measurable (f n)) : Measurable (s.sup' hs f)", "start": [241, 1], "end": [244, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.measurable_range_sup'", "code": "@[measurability]\ntheorem Finset.measurable_range_sup' {f : \u2115 \u2192 \u03b4 \u2192 \u03b1} {n : \u2115} (hf : \u2200 k \u2264 n, Measurable (f k)) :\n    Measurable ((range (n + 1)).sup' nonempty_range_succ f)", "start": [247, 1], "end": [252, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.measurable_range_sup''", "code": "@[measurability]\ntheorem Finset.measurable_range_sup'' {f : \u2115 \u2192 \u03b4 \u2192 \u03b1} {n : \u2115} (hf : \u2200 k \u2264 n, Measurable (f k)) :\n    Measurable fun x => (range (n + 1)).sup' nonempty_range_succ fun k => f k x", "start": [255, 1], "end": [260, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/AEMeasurableSequence.lean", "imports": ["Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "aeSeqSet", "code": "def aeSeqSet (hf : \u2200 i, AEMeasurable (f i) \u03bc) (p : \u03b1 \u2192 (\u03b9 \u2192 \u03b2) \u2192 Prop) : Set \u03b1 :=\n  (toMeasurable \u03bc { x | (\u2200 i, f i x = (hf i).mk (f i) x) \u2227 p x fun n => f n x }\u1d9c)\u1d9c", "start": [33, 1], "end": [37, 83], "kind": "commanddeclaration"}, {"full_name": "aeSeq", "code": "noncomputable def aeSeq (hf : \u2200 i, AEMeasurable (f i) \u03bc) (p : \u03b1 \u2192 (\u03b9 \u2192 \u03b2) \u2192 Prop) : \u03b9 \u2192 \u03b1 \u2192 \u03b2 :=\n  fun i x => ite (x \u2208 aeSeqSet hf p) ((hf i).mk (f i) x) (\u27e8f i x\u27e9 : Nonempty \u03b2).some", "start": [40, 1], "end": [43, 85], "kind": "commanddeclaration"}, {"full_name": "aeSeq.mk_eq_fun_of_mem_aeSeqSet", "code": "theorem mk_eq_fun_of_mem_aeSeqSet (hf : \u2200 i, AEMeasurable (f i) \u03bc) {x : \u03b1} (hx : x \u2208 aeSeqSet hf p)\n    (i : \u03b9) : (hf i).mk (f i) x = f i x", "start": [50, 1], "end": [56, 19], "kind": "commanddeclaration"}, {"full_name": "aeSeq.aeSeq_eq_mk_of_mem_aeSeqSet", "code": "theorem aeSeq_eq_mk_of_mem_aeSeqSet (hf : \u2200 i, AEMeasurable (f i) \u03bc) {x : \u03b1}\n    (hx : x \u2208 aeSeqSet hf p) (i : \u03b9) : aeSeq hf p i x = (hf i).mk (f i) x", "start": [59, 1], "end": [61, 33], "kind": "commanddeclaration"}, {"full_name": "aeSeq.aeSeq_eq_fun_of_mem_aeSeqSet", "code": "theorem aeSeq_eq_fun_of_mem_aeSeqSet (hf : \u2200 i, AEMeasurable (f i) \u03bc) {x : \u03b1}\n    (hx : x \u2208 aeSeqSet hf p) (i : \u03b9) : aeSeq hf p i x = f i x", "start": [64, 1], "end": [66, 85], "kind": "commanddeclaration"}, {"full_name": "aeSeq.prop_of_mem_aeSeqSet", "code": "theorem prop_of_mem_aeSeqSet (hf : \u2200 i, AEMeasurable (f i) \u03bc) {x : \u03b1} (hx : x \u2208 aeSeqSet hf p) :\n    p x fun n => aeSeq hf p n x", "start": [69, 1], "end": [78, 12], "kind": "commanddeclaration"}, {"full_name": "aeSeq.fun_prop_of_mem_aeSeqSet", "code": "theorem fun_prop_of_mem_aeSeqSet (hf : \u2200 i, AEMeasurable (f i) \u03bc) {x : \u03b1} (hx : x \u2208 aeSeqSet hf p) :\n    p x fun n => f n x", "start": [81, 1], "end": [86, 35], "kind": "commanddeclaration"}, {"full_name": "aeSeq.aeSeqSet_measurableSet", "code": "theorem aeSeqSet_measurableSet {hf : \u2200 i, AEMeasurable (f i) \u03bc} : MeasurableSet (aeSeqSet hf p)", "start": [91, 1], "end": [92, 41], "kind": "commanddeclaration"}, {"full_name": "aeSeq.measurable", "code": "theorem measurable (hf : \u2200 i, AEMeasurable (f i) \u03bc) (p : \u03b1 \u2192 (\u03b9 \u2192 \u03b2) \u2192 Prop) (i : \u03b9) :\n    Measurable (aeSeq hf p i)", "start": [95, 1], "end": [97, 97], "kind": "commanddeclaration"}, {"full_name": "aeSeq.measure_compl_aeSeqSet_eq_zero", "code": "theorem measure_compl_aeSeqSet_eq_zero [Countable \u03b9] (hf : \u2200 i, AEMeasurable (f i) \u03bc)\n    (hp : \u2200\u1d50 x \u2202\u03bc, p x fun n => f n x) : \u03bc (aeSeqSet hf p)\u1d9c = 0", "start": [100, 1], "end": [105, 39], "kind": "commanddeclaration"}, {"full_name": "aeSeq.aeSeq_eq_mk_ae", "code": "theorem aeSeq_eq_mk_ae [Countable \u03b9] (hf : \u2200 i, AEMeasurable (f i) \u03bc)\n    (hp : \u2200\u1d50 x \u2202\u03bc, p x fun n => f n x) : \u2200\u1d50 a : \u03b1 \u2202\u03bc, \u2200 i : \u03b9, aeSeq hf p i a = (hf i).mk (f i) a", "start": [108, 1], "end": [115, 16], "kind": "commanddeclaration"}, {"full_name": "aeSeq.aeSeq_eq_fun_ae", "code": "theorem aeSeq_eq_fun_ae [Countable \u03b9] (hf : \u2200 i, AEMeasurable (f i) \u03bc)\n    (hp : \u2200\u1d50 x \u2202\u03bc, p x fun n => f n x) : \u2200\u1d50 a : \u03b1 \u2202\u03bc, \u2200 i : \u03b9, aeSeq hf p i a = f i a", "start": [118, 1], "end": [122, 64], "kind": "commanddeclaration"}, {"full_name": "aeSeq.aeSeq_n_eq_fun_n_ae", "code": "theorem aeSeq_n_eq_fun_n_ae [Countable \u03b9] (hf : \u2200 i, AEMeasurable (f i) \u03bc)\n    (hp : \u2200\u1d50 x \u2202\u03bc, p x fun n => f n x) (n : \u03b9) : aeSeq hf p n =\u1d50[\u03bc] f n", "start": [125, 1], "end": [127, 42], "kind": "commanddeclaration"}, {"full_name": "aeSeq.iSup", "code": "theorem iSup [CompleteLattice \u03b2] [Countable \u03b9] (hf : \u2200 i, AEMeasurable (f i) \u03bc)\n    (hp : \u2200\u1d50 x \u2202\u03bc, p x fun n => f n x) : \u2a06 n, aeSeq hf p n =\u1d50[\u03bc] \u2a06 n, f n", "start": [130, 1], "end": [137, 99], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/GDelta.lean", "imports": ["Mathlib/Order/Filter/CountableInter.lean", "Mathlib/Topology/Separation.lean", "Mathlib/Topology/UniformSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsG\u03b4", "code": "def IsG\u03b4 (s : Set X) : Prop :=\n  \u2203 T : Set (Set X), (\u2200 t \u2208 T, IsOpen t) \u2227 T.Countable \u2227 s = \u22c2\u2080 T", "start": [57, 1], "end": [59, 66], "kind": "commanddeclaration"}, {"full_name": "IsOpen.isG\u03b4", "code": "theorem IsOpen.isG\u03b4 {s : Set X} (h : IsOpen s) : IsG\u03b4 s", "start": [62, 1], "end": [64, 75], "kind": "commanddeclaration"}, {"full_name": "isG\u03b4_empty", "code": "@[simp]\ntheorem isG\u03b4_empty : IsG\u03b4 (\u2205 : Set X)", "start": [67, 1], "end": [69, 20], "kind": "commanddeclaration"}, {"full_name": "isG\u03b4_univ", "code": "@[simp]\ntheorem isG\u03b4_univ : IsG\u03b4 (univ : Set X)", "start": [72, 1], "end": [74, 19], "kind": "commanddeclaration"}, {"full_name": "isG\u03b4_biInter_of_open", "code": "theorem isG\u03b4_biInter_of_open {I : Set \u03b9} (hI : I.Countable) {f : \u03b9 \u2192 Set X}\n    (hf : \u2200 i \u2208 I, IsOpen (f i)) : IsG\u03b4 (\u22c2 i \u2208 I, f i)", "start": [77, 1], "end": [79, 70], "kind": "commanddeclaration"}, {"full_name": "isG\u03b4_iInter_of_open", "code": "theorem isG\u03b4_iInter_of_open [Encodable \u03b9] {f : \u03b9 \u2192 Set X} (hf : \u2200 i, IsOpen (f i)) :\n    IsG\u03b4 (\u22c2 i, f i)", "start": [83, 1], "end": [85, 80], "kind": "commanddeclaration"}, {"full_name": "isG\u03b4_iInter", "code": "theorem isG\u03b4_iInter [Encodable \u03b9] {s : \u03b9 \u2192 Set X} (hs : \u2200 i, IsG\u03b4 (s i)) : IsG\u03b4 (\u22c2 i, s i)", "start": [89, 1], "end": [94, 35], "kind": "commanddeclaration"}, {"full_name": "isG\u03b4_biInter", "code": "theorem isG\u03b4_biInter {s : Set \u03b9} (hs : s.Countable) {t : \u2200 i \u2208 s, Set X}\n    (ht : \u2200 (i) (hi : i \u2208 s), IsG\u03b4 (t i hi)) : IsG\u03b4 (\u22c2 i \u2208 s, t i \u2039_\u203a)", "start": [97, 1], "end": [101, 38], "kind": "commanddeclaration"}, {"full_name": "isG\u03b4_sInter", "code": "theorem isG\u03b4_sInter {S : Set (Set X)} (h : \u2200 s \u2208 S, IsG\u03b4 s) (hS : S.Countable) : IsG\u03b4 (\u22c2\u2080 S)", "start": [104, 1], "end": [106, 57], "kind": "commanddeclaration"}, {"full_name": "IsG\u03b4.inter", "code": "theorem IsG\u03b4.inter {s t : Set X} (hs : IsG\u03b4 s) (ht : IsG\u03b4 t) : IsG\u03b4 (s \u2229 t)", "start": [109, 1], "end": [111, 50], "kind": "commanddeclaration"}, {"full_name": "IsG\u03b4.union", "code": "theorem IsG\u03b4.union {s t : Set X} (hs : IsG\u03b4 s) (ht : IsG\u03b4 t) : IsG\u03b4 (s \u222a t)", "start": [114, 1], "end": [121, 40], "kind": "commanddeclaration"}, {"full_name": "isG\u03b4_biUnion", "code": "theorem isG\u03b4_biUnion {s : Set \u03b9} (hs : s.Finite) {f : \u03b9 \u2192 Set X} (h : \u2200 i \u2208 s, IsG\u03b4 (f i)) :\n    IsG\u03b4 (\u22c3 i \u2208 s, f i)", "start": [125, 1], "end": [130, 45], "kind": "commanddeclaration"}, {"full_name": "IsClosed.isG\u03b4", "code": "theorem IsClosed.isG\u03b4 {X} [UniformSpace X] [IsCountablyGenerated (uniformity X)] {s : Set X}\n    (hs : IsClosed s) : IsG\u03b4 s", "start": [134, 1], "end": [139, 71], "kind": "commanddeclaration"}, {"full_name": "isG\u03b4_compl_singleton", "code": "theorem isG\u03b4_compl_singleton (x : X) : IsG\u03b4 ({x}\u1d9c : Set X)", "start": [146, 1], "end": [147, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.isG\u03b4_compl", "code": "theorem Set.Countable.isG\u03b4_compl {s : Set X} (hs : s.Countable) : IsG\u03b4 s\u1d9c", "start": [150, 1], "end": [152, 58], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isG\u03b4_compl", "code": "theorem Set.Finite.isG\u03b4_compl {s : Set X} (hs : s.Finite) : IsG\u03b4 s\u1d9c", "start": [155, 1], "end": [156, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.isG\u03b4_compl", "code": "theorem Set.Subsingleton.isG\u03b4_compl {s : Set X} (hs : s.Subsingleton) : IsG\u03b4 s\u1d9c", "start": [159, 1], "end": [160, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.isG\u03b4_compl", "code": "theorem Finset.isG\u03b4_compl (s : Finset X) : IsG\u03b4 (s\u1d9c : Set X)", "start": [163, 1], "end": [164, 28], "kind": "commanddeclaration"}, {"full_name": "isG\u03b4_singleton", "code": "theorem isG\u03b4_singleton (x : X) : IsG\u03b4 ({x} : Set X)", "start": [169, 1], "end": [172, 63], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isG\u03b4", "code": "theorem Set.Finite.isG\u03b4 {s : Set X} (hs : s.Finite) : IsG\u03b4 s", "start": [175, 1], "end": [176, 78], "kind": "commanddeclaration"}, {"full_name": "isG\u03b4_setOf_continuousAt", "code": "theorem isG\u03b4_setOf_continuousAt [UniformSpace Y] [IsCountablyGenerated (uniformity Y)] (f : X \u2192 Y) :\n    IsG\u03b4 { x | ContinuousAt f x }", "start": [187, 1], "end": [196, 79], "kind": "commanddeclaration"}, {"full_name": "residual", "code": "def residual (X : Type*) [TopologicalSpace X] : Filter X :=\n  Filter.countableGenerate { t | IsOpen t \u2227 Dense t }", "start": [205, 1], "end": [207, 54], "kind": "commanddeclaration"}, {"full_name": "countableInterFilter_residual", "code": "instance countableInterFilter_residual : CountableInterFilter (residual X) := by\n  rw [residual]; infer_instance", "start": [210, 1], "end": [211, 32], "kind": "commanddeclaration"}, {"full_name": "residual_of_dense_open", "code": "theorem residual_of_dense_open {s : Set X} (ho : IsOpen s) (hd : Dense s) : s \u2208 residual X", "start": [214, 1], "end": [216, 39], "kind": "commanddeclaration"}, {"full_name": "residual_of_dense_G\u03b4", "code": "theorem residual_of_dense_G\u03b4 {s : Set X} (ho : IsG\u03b4 s) (hd : Dense s) : s \u2208 residual X", "start": [219, 1], "end": [224, 75], "kind": "commanddeclaration"}, {"full_name": "mem_residual_iff", "code": "theorem mem_residual_iff {s : Set X} :\n    s \u2208 residual X \u2194\n      \u2203 S : Set (Set X), (\u2200 t \u2208 S, IsOpen t) \u2227 (\u2200 t \u2208 S, Dense t) \u2227 S.Countable \u2227 \u22c2\u2080 S \u2286 s", "start": [227, 1], "end": [231, 95], "kind": "commanddeclaration"}, {"full_name": "IsNowhereDense", "code": "def IsNowhereDense (s : Set X) := interior (closure s) = \u2205", "start": [240, 1], "end": [241, 59], "kind": "commanddeclaration"}, {"full_name": "isNowhereDense_of_empty", "code": "@[simp]\nlemma isNowhereDense_of_empty : IsNowhereDense (\u2205 : Set X) := by\n  rw [IsNowhereDense, closure_empty, interior_empty]", "start": [243, 1], "end": [246, 53], "kind": "mathlibtacticlemma"}, {"full_name": "IsClosed.isNowhereDense_iff", "code": "lemma IsClosed.isNowhereDense_iff {s : Set X} (hs : IsClosed s) :\n    IsNowhereDense s \u2194 interior s = \u2205 := by\n  rw [IsNowhereDense, IsClosed.closure_eq hs]", "start": [248, 1], "end": [251, 46], "kind": "mathlibtacticlemma"}, {"full_name": "IsNowhereDense.closure", "code": "protected lemma IsNowhereDense.closure {s : Set X} (hs : IsNowhereDense s) :\n    IsNowhereDense (closure s) := by\n  rwa [IsNowhereDense, closure_closure]", "start": [253, 1], "end": [256, 40], "kind": "mathlibtacticlemma"}, {"full_name": "IsNowhereDense.subset_of_closed_nowhereDense", "code": "lemma IsNowhereDense.subset_of_closed_nowhereDense {s : Set X} (hs : IsNowhereDense s) :\n    \u2203 t : Set X, s \u2286 t \u2227 IsNowhereDense t \u2227 IsClosed t :=\n  \u27e8closure s, subset_closure, \u27e8hs.closure, isClosed_closure\u27e9\u27e9", "start": [258, 1], "end": [261, 62], "kind": "mathlibtacticlemma"}, {"full_name": "closed_isNowhereDense_iff_compl", "code": "lemma closed_isNowhereDense_iff_compl {s : Set X} :\n    IsClosed s \u2227 IsNowhereDense s \u2194 IsOpen s\u1d9c \u2227 Dense s\u1d9c := by\n  rw [and_congr_right IsClosed.isNowhereDense_iff,\n    isOpen_compl_iff, interior_eq_empty_iff_dense_compl]", "start": [263, 1], "end": [267, 57], "kind": "mathlibtacticlemma"}, {"full_name": "IsMeagre", "code": "def IsMeagre (s : Set X) := s\u1d9c \u2208 residual X", "start": [269, 1], "end": [270, 44], "kind": "commanddeclaration"}, {"full_name": "meagre_empty", "code": "lemma meagre_empty : IsMeagre (\u2205 : Set X) := by\n  rw [IsMeagre, compl_empty]\n  exact Filter.univ_mem", "start": [272, 1], "end": [275, 24], "kind": "mathlibtacticlemma"}, {"full_name": "IsMeagre.mono", "code": "lemma IsMeagre.mono {s t : Set X} (hs : IsMeagre s) (hts: t \u2286 s) : IsMeagre t :=\n  Filter.mem_of_superset hs (compl_subset_compl.mpr hts)", "start": [277, 1], "end": [279, 57], "kind": "mathlibtacticlemma"}, {"full_name": "IsMeagre.inter", "code": "lemma IsMeagre.inter {s t : Set X} (hs : IsMeagre s) : IsMeagre (s \u2229 t) :=\n  hs.mono (inter_subset_left s t)", "start": [281, 1], "end": [283, 34], "kind": "mathlibtacticlemma"}, {"full_name": "meagre_iUnion", "code": "lemma meagre_iUnion {s : \u2115 \u2192 Set X} (hs : \u2200 n, IsMeagre (s n)) : IsMeagre (\u22c3 n, s n) := by\n  rw [IsMeagre, compl_iUnion]\n  exact countable_iInter_mem.mpr hs", "start": [285, 1], "end": [288, 36], "kind": "mathlibtacticlemma"}, {"full_name": "meagre_iff_countable_union_nowhereDense", "code": "lemma meagre_iff_countable_union_nowhereDense {s : Set X} : IsMeagre s \u2194\n    \u2203 S : Set (Set X), (\u2200 t \u2208 S, IsNowhereDense t) \u2227 S.Countable \u2227 s \u2286 \u22c3\u2080 S := by\n  rw [IsMeagre, mem_residual_iff, compl_bijective.surjective.image_surjective.exists]\n  simp_rw [\u2190 and_assoc, \u2190 forall_and, ball_image_iff, \u2190 closed_isNowhereDense_iff_compl,\n    sInter_image, \u2190 compl_iUnion\u2082, compl_subset_compl, \u2190 sUnion_eq_biUnion, and_assoc]\n  refine \u27e8fun \u27e8S, hS, hc, hsub\u27e9 \u21a6 \u27e8S, fun s hs \u21a6 (hS s hs).2, ?_, hsub\u27e9, fun \u27e8S, hS, hc, hsub\u27e9 \u21a6 ?_\u27e9\n  \u00b7 rw [\u2190 compl_compl_image S]; exact hc.image _\n  use closure '' S\n  rw [ball_image_iff]\n  exact \u27e8fun s hs \u21a6 \u27e8isClosed_closure, (hS s hs).closure\u27e9,\n    (hc.image _).image _, hsub.trans (sUnion_mono_subsets fun s \u21a6 subset_closure)\u27e9", "start": [290, 1], "end": [301, 83], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/MeasureTheory/Group/Arithmetic.lean", "imports": ["Mathlib/MeasureTheory/Measure/AEMeasurable.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasurableAdd", "code": "class MeasurableAdd (M : Type*) [MeasurableSpace M] [Add M] : Prop where\n  measurable_const_add : \u2200 c : M, Measurable (c + \u00b7)\n  measurable_add_const : \u2200 c : M, Measurable (\u00b7 + c)", "start": [59, 1], "end": [63, 53], "kind": "commanddeclaration"}, {"full_name": "MeasurableAdd\u2082", "code": "class MeasurableAdd\u2082 (M : Type*) [MeasurableSpace M] [Add M] : Prop where\n  measurable_add : Measurable fun p : M \u00d7 M => p.1 + p.2", "start": [70, 1], "end": [73, 57], "kind": "commanddeclaration"}, {"full_name": "MeasurableMul", "code": "@[to_additive]\nclass MeasurableMul (M : Type*) [MeasurableSpace M] [Mul M] : Prop where\n  measurable_const_mul : \u2200 c : M, Measurable (c * \u00b7)\n  measurable_mul_const : \u2200 c : M, Measurable (\u00b7 * c)", "start": [78, 1], "end": [83, 53], "kind": "commanddeclaration"}, {"full_name": "MeasurableMul\u2082", "code": "@[to_additive MeasurableAdd\u2082]\nclass MeasurableMul\u2082 (M : Type*) [MeasurableSpace M] [Mul M] : Prop where\n  measurable_mul : Measurable fun p : M \u00d7 M => p.1 * p.2", "start": [90, 1], "end": [94, 57], "kind": "commanddeclaration"}, {"full_name": "Measurable.const_mul", "code": "@[to_additive (attr := measurability)]\ntheorem Measurable.const_mul [MeasurableMul M] (hf : Measurable f) (c : M) :\n    Measurable fun x => c * f x", "start": [105, 1], "end": [108, 35], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.const_mul", "code": "@[to_additive (attr := measurability)]\ntheorem AEMeasurable.const_mul [MeasurableMul M] (hf : AEMeasurable f \u03bc) (c : M) :\n    AEMeasurable (fun x => c * f x) \u03bc", "start": [112, 1], "end": [115, 62], "kind": "commanddeclaration"}, {"full_name": "Measurable.mul_const", "code": "@[to_additive (attr := measurability)]\ntheorem Measurable.mul_const [MeasurableMul M] (hf : Measurable f) (c : M) :\n    Measurable fun x => f x * c", "start": [119, 1], "end": [122, 35], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.mul_const", "code": "@[to_additive (attr := measurability)]\ntheorem AEMeasurable.mul_const [MeasurableMul M] (hf : AEMeasurable f \u03bc) (c : M) :\n    AEMeasurable (fun x => f x * c) \u03bc", "start": [126, 1], "end": [129, 48], "kind": "commanddeclaration"}, {"full_name": "Measurable.mul'", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\ntheorem Measurable.mul' [MeasurableMul\u2082 M] (hf : Measurable f) (hg : Measurable g) :\n    Measurable (f * g)", "start": [133, 1], "end": [136, 38], "kind": "commanddeclaration"}, {"full_name": "Measurable.mul", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\ntheorem Measurable.mul [MeasurableMul\u2082 M] (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => f a * g a", "start": [140, 1], "end": [143, 38], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.mul'", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\ntheorem AEMeasurable.mul' [MeasurableMul\u2082 M] (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    AEMeasurable (f * g) \u03bc", "start": [147, 1], "end": [150, 51], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.mul", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\ntheorem AEMeasurable.mul [MeasurableMul\u2082 M] (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    AEMeasurable (fun a => f a * g a) \u03bc", "start": [154, 1], "end": [157, 51], "kind": "commanddeclaration"}, {"full_name": "MeasurableMul\u2082.toMeasurableMul", "code": "@[to_additive]\ninstance (priority := 100) MeasurableMul\u2082.toMeasurableMul [MeasurableMul\u2082 M] :\n    MeasurableMul M :=\n  \u27e8fun _ => measurable_const.mul measurable_id, fun _ => measurable_id.mul measurable_const\u27e9", "start": [161, 1], "end": [164, 93], "kind": "commanddeclaration"}, {"full_name": "Pi.measurableMul", "code": "@[to_additive]\ninstance Pi.measurableMul {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, Mul (\u03b1 i)]\n    [\u2200 i, MeasurableSpace (\u03b1 i)] [\u2200 i, MeasurableMul (\u03b1 i)] : MeasurableMul (\u2200 i, \u03b1 i) :=\n  \u27e8fun _ => measurable_pi_iff.mpr fun i => (measurable_pi_apply i).const_mul _, fun _ =>\n    measurable_pi_iff.mpr fun i => (measurable_pi_apply i).mul_const _\u27e9", "start": [168, 1], "end": [172, 72], "kind": "commanddeclaration"}, {"full_name": "Pi.measurableMul\u2082", "code": "@[to_additive Pi.measurableAdd\u2082]\ninstance Pi.measurableMul\u2082 {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, Mul (\u03b1 i)]\n    [\u2200 i, MeasurableSpace (\u03b1 i)] [\u2200 i, MeasurableMul\u2082 (\u03b1 i)] : MeasurableMul\u2082 (\u2200 i, \u03b1 i) :=\n  \u27e8measurable_pi_iff.mpr fun _ => measurable_fst.eval.mul measurable_snd.eval\u27e9", "start": [176, 1], "end": [179, 79], "kind": "commanddeclaration"}, {"full_name": "measurable_div_const'", "code": "@[to_additive \" A version of `measurable_sub_const` that assumes `MeasurableAdd` instead of\n  `MeasurableSub`. This can be nice to avoid unnecessary type-class assumptions. \"]\ntheorem measurable_div_const' {G : Type*} [DivInvMonoid G] [MeasurableSpace G] [MeasurableMul G]\n    (g : G) : Measurable fun h => h / g", "start": [185, 1], "end": [190, 93], "kind": "commanddeclaration"}, {"full_name": "MeasurablePow", "code": "class MeasurablePow (\u03b2 \u03b3 : Type*) [MeasurableSpace \u03b2] [MeasurableSpace \u03b3] [Pow \u03b2 \u03b3] : Prop where\n  measurable_pow : Measurable fun p : \u03b2 \u00d7 \u03b3 => p.1 ^ p.2", "start": [194, 1], "end": [196, 57], "kind": "commanddeclaration"}, {"full_name": "Monoid.measurablePow", "code": "instance Monoid.measurablePow (M : Type*) [Monoid M] [MeasurableSpace M] [MeasurableMul\u2082 M] :\n    MeasurablePow M \u2115 :=\n  \u27e8measurable_from_prod_countable fun n => by\n      induction' n with n ih\n      \u00b7 simp only [Nat.zero_eq, pow_zero, \u2190 Pi.one_def, measurable_one]\n      \u00b7 simp only [pow_succ]\n        exact measurable_id.mul ih\u27e9", "start": [201, 1], "end": [208, 36], "kind": "commanddeclaration"}, {"full_name": "Measurable.pow", "code": "@[aesop safe 20 apply (rule_sets [Measurable])]\ntheorem Measurable.pow (hf : Measurable f) (hg : Measurable g) : Measurable fun x => f x ^ g x", "start": [216, 1], "end": [218, 38], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.pow", "code": "@[aesop safe 20 apply (rule_sets [Measurable])]\ntheorem AEMeasurable.pow (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    AEMeasurable (fun x => f x ^ g x) \u03bc", "start": [221, 1], "end": [224, 51], "kind": "commanddeclaration"}, {"full_name": "Measurable.pow_const", "code": "@[measurability]\ntheorem Measurable.pow_const (hf : Measurable f) (c : \u03b3) : Measurable fun x => f x ^ c", "start": [227, 1], "end": [229, 26], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.pow_const", "code": "@[measurability]\ntheorem AEMeasurable.pow_const (hf : AEMeasurable f \u03bc) (c : \u03b3) :\n    AEMeasurable (fun x => f x ^ c) \u03bc", "start": [232, 1], "end": [235, 28], "kind": "commanddeclaration"}, {"full_name": "Measurable.const_pow", "code": "@[measurability]\ntheorem Measurable.const_pow (hg : Measurable g) (c : \u03b2) : Measurable fun x => c ^ g x", "start": [238, 1], "end": [240, 26], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.const_pow", "code": "@[measurability]\ntheorem AEMeasurable.const_pow (hg : AEMeasurable g \u03bc) (c : \u03b2) :\n    AEMeasurable (fun x => c ^ g x) \u03bc", "start": [243, 1], "end": [246, 28], "kind": "commanddeclaration"}, {"full_name": "MeasurableSub", "code": "class MeasurableSub (G : Type*) [MeasurableSpace G] [Sub G] : Prop where\n  measurable_const_sub : \u2200 c : G, Measurable (c - \u00b7)\n  measurable_sub_const : \u2200 c : G, Measurable (\u00b7 - c)", "start": [251, 1], "end": [255, 53], "kind": "commanddeclaration"}, {"full_name": "MeasurableSub\u2082", "code": "class MeasurableSub\u2082 (G : Type*) [MeasurableSpace G] [Sub G] : Prop where\n  measurable_sub : Measurable fun p : G \u00d7 G => p.1 - p.2", "start": [262, 1], "end": [265, 57], "kind": "commanddeclaration"}, {"full_name": "MeasurableDiv", "code": "@[to_additive]\nclass MeasurableDiv (G\u2080 : Type*) [MeasurableSpace G\u2080] [Div G\u2080] : Prop where\n  measurable_const_div : \u2200 c : G\u2080, Measurable (c / \u00b7)\n  measurable_div_const : \u2200 c : G\u2080, Measurable (\u00b7 / c)", "start": [271, 1], "end": [276, 54], "kind": "commanddeclaration"}, {"full_name": "MeasurableDiv\u2082", "code": "@[to_additive MeasurableSub\u2082]\nclass MeasurableDiv\u2082 (G\u2080 : Type*) [MeasurableSpace G\u2080] [Div G\u2080] : Prop where\n  measurable_div : Measurable fun p : G\u2080 \u00d7 G\u2080 => p.1 / p.2", "start": [283, 1], "end": [287, 59], "kind": "commanddeclaration"}, {"full_name": "Measurable.const_div", "code": "@[to_additive (attr := measurability)]\ntheorem Measurable.const_div [MeasurableDiv G] (hf : Measurable f) (c : G) :\n    Measurable fun x => c / f x", "start": [298, 1], "end": [301, 49], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.const_div", "code": "@[to_additive (attr := measurability)]\ntheorem AEMeasurable.const_div [MeasurableDiv G] (hf : AEMeasurable f \u03bc) (c : G) :\n    AEMeasurable (fun x => c / f x) \u03bc", "start": [305, 1], "end": [308, 62], "kind": "commanddeclaration"}, {"full_name": "Measurable.div_const", "code": "@[to_additive (attr := measurability)]\ntheorem Measurable.div_const [MeasurableDiv G] (hf : Measurable f) (c : G) :\n    Measurable fun x => f x / c", "start": [312, 1], "end": [315, 49], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.div_const", "code": "@[to_additive (attr := measurability)]\ntheorem AEMeasurable.div_const [MeasurableDiv G] (hf : AEMeasurable f \u03bc) (c : G) :\n    AEMeasurable (fun x => f x / c) \u03bc", "start": [319, 1], "end": [322, 62], "kind": "commanddeclaration"}, {"full_name": "Measurable.div'", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\ntheorem Measurable.div' [MeasurableDiv\u2082 G] (hf : Measurable f) (hg : Measurable g) :\n    Measurable (f / g)", "start": [326, 1], "end": [329, 38], "kind": "commanddeclaration"}, {"full_name": "Measurable.div", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\ntheorem Measurable.div [MeasurableDiv\u2082 G] (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => f a / g a", "start": [333, 1], "end": [336, 38], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.div'", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\ntheorem AEMeasurable.div' [MeasurableDiv\u2082 G] (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    AEMeasurable (f / g) \u03bc", "start": [340, 1], "end": [343, 51], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.div", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\ntheorem AEMeasurable.div [MeasurableDiv\u2082 G] (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    AEMeasurable (fun a => f a / g a) \u03bc", "start": [347, 1], "end": [350, 51], "kind": "commanddeclaration"}, {"full_name": "MeasurableDiv\u2082.toMeasurableDiv", "code": "@[to_additive]\ninstance (priority := 100) MeasurableDiv\u2082.toMeasurableDiv [MeasurableDiv\u2082 G] :\n    MeasurableDiv G :=\n  \u27e8fun _ => measurable_const.div measurable_id, fun _ => measurable_id.div measurable_const\u27e9", "start": [354, 1], "end": [357, 93], "kind": "commanddeclaration"}, {"full_name": "Pi.measurableDiv", "code": "@[to_additive]\ninstance Pi.measurableDiv {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, Div (\u03b1 i)]\n    [\u2200 i, MeasurableSpace (\u03b1 i)] [\u2200 i, MeasurableDiv (\u03b1 i)] : MeasurableDiv (\u2200 i, \u03b1 i) :=\n  \u27e8fun _ => measurable_pi_iff.mpr fun i => (measurable_pi_apply i).const_div _, fun _ =>\n    measurable_pi_iff.mpr fun i => (measurable_pi_apply i).div_const _\u27e9", "start": [361, 1], "end": [365, 72], "kind": "commanddeclaration"}, {"full_name": "Pi.measurableDiv\u2082", "code": "@[to_additive Pi.measurableSub\u2082]\ninstance Pi.measurableDiv\u2082 {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, Div (\u03b1 i)]\n    [\u2200 i, MeasurableSpace (\u03b1 i)] [\u2200 i, MeasurableDiv\u2082 (\u03b1 i)] : MeasurableDiv\u2082 (\u2200 i, \u03b1 i) :=\n  \u27e8measurable_pi_iff.mpr fun _ => measurable_fst.eval.div measurable_snd.eval\u27e9", "start": [369, 1], "end": [372, 79], "kind": "commanddeclaration"}, {"full_name": "measurableSet_eq_fun", "code": "@[measurability]\ntheorem measurableSet_eq_fun {m : MeasurableSpace \u03b1} {E} [MeasurableSpace E] [AddGroup E]\n    [MeasurableSingletonClass E] [MeasurableSub\u2082 E] {f g : \u03b1 \u2192 E} (hf : Measurable f)\n    (hg : Measurable g) : MeasurableSet { x | f x = g x }", "start": [376, 1], "end": [384, 56], "kind": "commanddeclaration"}, {"full_name": "nullMeasurableSet_eq_fun", "code": "theorem nullMeasurableSet_eq_fun {E} [MeasurableSpace E] [AddGroup E] [MeasurableSingletonClass E]\n    [MeasurableSub\u2082 E] {f g : \u03b1 \u2192 E} (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    NullMeasurableSet { x | f x = g x } \u03bc", "start": [387, 1], "end": [393, 23], "kind": "commanddeclaration"}, {"full_name": "measurableSet_eq_fun_of_countable", "code": "theorem measurableSet_eq_fun_of_countable {m : MeasurableSpace \u03b1} {E} [MeasurableSpace E]\n    [MeasurableSingletonClass E] [Countable E] {f g : \u03b1 \u2192 E} (hf : Measurable f)\n    (hg : Measurable g) : MeasurableSet { x | f x = g x }", "start": [396, 1], "end": [405, 41], "kind": "commanddeclaration"}, {"full_name": "ae_eq_trim_of_measurable", "code": "theorem ae_eq_trim_of_measurable {\u03b1 E} {m m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    [MeasurableSpace E] [AddGroup E] [MeasurableSingletonClass E] [MeasurableSub\u2082 E]\n    (hm : m \u2264 m0) {f g : \u03b1 \u2192 E} (hf : Measurable[m] f) (hg : Measurable[m] g) (hfg : f =\u1d50[\u03bc] g) :\n    f =\u1da0[@Measure.ae \u03b1 m (\u03bc.trim hm)] g", "start": [408, 1], "end": [413, 83], "kind": "commanddeclaration"}, {"full_name": "MeasurableNeg", "code": "class MeasurableNeg (G : Type*) [Neg G] [MeasurableSpace G] : Prop where\n  measurable_neg : Measurable (Neg.neg : G \u2192 G)", "start": [418, 1], "end": [420, 48], "kind": "commanddeclaration"}, {"full_name": "MeasurableInv", "code": "@[to_additive]\nclass MeasurableInv (G : Type*) [Inv G] [MeasurableSpace G] : Prop where\n  measurable_inv : Measurable (Inv.inv : G \u2192 G)", "start": [424, 1], "end": [427, 48], "kind": "commanddeclaration"}, {"full_name": "measurableDiv_of_mul_inv", "code": "@[to_additive]\ninstance (priority := 100) measurableDiv_of_mul_inv (G : Type*) [MeasurableSpace G]\n    [DivInvMonoid G] [MeasurableMul G] [MeasurableInv G] : MeasurableDiv G where\n  measurable_const_div c := by\n    convert measurable_inv.const_mul c using 1\n    ext1\n    apply div_eq_mul_inv\n  measurable_div_const c := by\n    convert measurable_id.mul_const c\u207b\u00b9 using 1\n    ext1\n    apply div_eq_mul_inv", "start": [435, 1], "end": [445, 25], "kind": "commanddeclaration"}, {"full_name": "Measurable.inv", "code": "@[to_additive (attr := measurability)]\ntheorem Measurable.inv (hf : Measurable f) : Measurable fun x => (f x)\u207b\u00b9", "start": [454, 1], "end": [456, 25], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.inv", "code": "@[to_additive (attr := measurability)]\ntheorem AEMeasurable.inv (hf : AEMeasurable f \u03bc) : AEMeasurable (fun x => (f x)\u207b\u00b9) \u03bc", "start": [460, 1], "end": [462, 38], "kind": "commanddeclaration"}, {"full_name": "measurable_inv_iff", "code": "@[to_additive (attr := simp)]\ntheorem measurable_inv_iff {G : Type*} [Group G] [MeasurableSpace G] [MeasurableInv G]\n    {f : \u03b1 \u2192 G} : (Measurable fun x => (f x)\u207b\u00b9) \u2194 Measurable f", "start": [466, 1], "end": [469, 65], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_inv_iff", "code": "@[to_additive (attr := simp)]\ntheorem aemeasurable_inv_iff {G : Type*} [Group G] [MeasurableSpace G] [MeasurableInv G]\n    {f : \u03b1 \u2192 G} : AEMeasurable (fun x => (f x)\u207b\u00b9) \u03bc \u2194 AEMeasurable f \u03bc", "start": [473, 1], "end": [476, 65], "kind": "commanddeclaration"}, {"full_name": "measurable_inv_iff\u2080", "code": "@[simp]\ntheorem measurable_inv_iff\u2080 {G\u2080 : Type*} [GroupWithZero G\u2080] [MeasurableSpace G\u2080]\n    [MeasurableInv G\u2080] {f : \u03b1 \u2192 G\u2080} : (Measurable fun x => (f x)\u207b\u00b9) \u2194 Measurable f", "start": [480, 1], "end": [483, 65], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_inv_iff\u2080", "code": "@[simp]\ntheorem aemeasurable_inv_iff\u2080 {G\u2080 : Type*} [GroupWithZero G\u2080] [MeasurableSpace G\u2080]\n    [MeasurableInv G\u2080] {f : \u03b1 \u2192 G\u2080} : AEMeasurable (fun x => (f x)\u207b\u00b9) \u03bc \u2194 AEMeasurable f \u03bc", "start": [486, 1], "end": [489, 65], "kind": "commanddeclaration"}, {"full_name": "Pi.measurableInv", "code": "@[to_additive]\ninstance Pi.measurableInv {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, Inv (\u03b1 i)]\n    [\u2200 i, MeasurableSpace (\u03b1 i)] [\u2200 i, MeasurableInv (\u03b1 i)] : MeasurableInv (\u2200 i, \u03b1 i) :=\n  \u27e8measurable_pi_iff.mpr fun i => (measurable_pi_apply i).inv\u27e9", "start": [492, 1], "end": [495, 63], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.inv", "code": "@[to_additive]\ntheorem MeasurableSet.inv {s : Set G} (hs : MeasurableSet s) : MeasurableSet s\u207b\u00b9", "start": [499, 1], "end": [501, 20], "kind": "commanddeclaration"}, {"full_name": "DivInvMonoid.measurableZpow", "code": "instance DivInvMonoid.measurableZpow (G : Type u) [DivInvMonoid G] [MeasurableSpace G]\n    [MeasurableMul\u2082 G] [MeasurableInv G] : MeasurablePow G \u2124 :=\n  \u27e8measurable_from_prod_countable fun n => by\n      cases' n with n n\n      \u00b7 simp_rw [Int.ofNat_eq_coe, zpow_ofNat]\n        exact measurable_id.pow_const _\n      \u00b7 simp_rw [zpow_negSucc]\n        exact (measurable_id.pow_const (n + 1)).inv\u27e9", "start": [507, 1], "end": [515, 53], "kind": "commanddeclaration"}, {"full_name": "measurableDiv\u2082_of_mul_inv", "code": "@[to_additive]\ninstance (priority := 100) measurableDiv\u2082_of_mul_inv (G : Type*) [MeasurableSpace G]\n    [DivInvMonoid G] [MeasurableMul\u2082 G] [MeasurableInv G] : MeasurableDiv\u2082 G :=\n  \u27e8by\n    simp only [div_eq_mul_inv]\n    exact measurable_fst.mul measurable_snd.inv\u27e9", "start": [518, 1], "end": [523, 49], "kind": "commanddeclaration"}, {"full_name": "MeasurableVAdd", "code": "class MeasurableVAdd (M \u03b1 : Type*) [VAdd M \u03b1] [MeasurableSpace M] [MeasurableSpace \u03b1] :\n    Prop where\n  measurable_const_vadd : \u2200 c : M, Measurable ((\u00b7 +\u1d65 \u00b7) c : \u03b1 \u2192 \u03b1)\n  measurable_vadd_const : \u2200 x : \u03b1, Measurable fun c : M => c +\u1d65 x", "start": [527, 1], "end": [532, 66], "kind": "commanddeclaration"}, {"full_name": "MeasurableSMul", "code": "@[to_additive]\nclass MeasurableSMul (M \u03b1 : Type*) [SMul M \u03b1] [MeasurableSpace M] [MeasurableSpace \u03b1] :\n    Prop where\n  measurable_const_smul : \u2200 c : M, Measurable ((\u00b7 \u2022 \u00b7) c : \u03b1 \u2192 \u03b1)\n  measurable_smul_const : \u2200 x : \u03b1, Measurable fun c : M => c \u2022 x", "start": [537, 1], "end": [543, 65], "kind": "commanddeclaration"}, {"full_name": "MeasurableVAdd\u2082", "code": "class MeasurableVAdd\u2082 (M \u03b1 : Type*) [VAdd M \u03b1] [MeasurableSpace M] [MeasurableSpace \u03b1] :\n    Prop where\n  measurable_vadd : Measurable (Function.uncurry (\u00b7 +\u1d65 \u00b7) : M \u00d7 \u03b1 \u2192 \u03b1)", "start": [548, 1], "end": [552, 71], "kind": "commanddeclaration"}, {"full_name": "MeasurableSMul\u2082", "code": "@[to_additive MeasurableVAdd\u2082]\nclass MeasurableSMul\u2082 (M \u03b1 : Type*) [SMul M \u03b1] [MeasurableSpace M] [MeasurableSpace \u03b1] :\n    Prop where\n  measurable_smul : Measurable (Function.uncurry (\u00b7 \u2022 \u00b7) : M \u00d7 \u03b1 \u2192 \u03b1)", "start": [556, 1], "end": [561, 70], "kind": "commanddeclaration"}, {"full_name": "measurableSMul_of_mul", "code": "@[to_additive]\ninstance measurableSMul_of_mul (M : Type*) [Mul M] [MeasurableSpace M] [MeasurableMul M] :\n    MeasurableSMul M M :=\n  \u27e8measurable_id.const_mul, measurable_id.mul_const\u27e9", "start": [573, 1], "end": [576, 53], "kind": "commanddeclaration"}, {"full_name": "measurableSMul\u2082_of_mul", "code": "@[to_additive]\ninstance measurableSMul\u2082_of_mul (M : Type*) [Mul M] [MeasurableSpace M] [MeasurableMul\u2082 M] :\n    MeasurableSMul\u2082 M M :=\n  \u27e8measurable_mul\u27e9", "start": [580, 1], "end": [583, 19], "kind": "commanddeclaration"}, {"full_name": "Submonoid.measurableSMul", "code": "@[to_additive]\ninstance Submonoid.measurableSMul {M \u03b1} [MeasurableSpace M] [MeasurableSpace \u03b1] [Monoid M]\n    [MulAction M \u03b1] [MeasurableSMul M \u03b1] (s : Submonoid M) : MeasurableSMul s \u03b1 :=\n  \u27e8fun c => by simpa only using measurable_const_smul (c : M), fun x =>\n    (measurable_smul_const x : Measurable fun c : M => c \u2022 x).comp measurable_subtype_coe\u27e9", "start": [587, 1], "end": [591, 91], "kind": "commanddeclaration"}, {"full_name": "Subgroup.measurableSMul", "code": "@[to_additive]\ninstance Subgroup.measurableSMul {G \u03b1} [MeasurableSpace G] [MeasurableSpace \u03b1] [Group G]\n    [MulAction G \u03b1] [MeasurableSMul G \u03b1] (s : Subgroup G) : MeasurableSMul s \u03b1 :=\n  s.toSubmonoid.measurableSMul", "start": [595, 1], "end": [598, 31], "kind": "commanddeclaration"}, {"full_name": "Measurable.smul", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\ntheorem Measurable.smul [MeasurableSMul\u2082 M \u03b2] (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun x => f x \u2022 g x", "start": [607, 1], "end": [610, 39], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.smul", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\ntheorem AEMeasurable.smul [MeasurableSMul\u2082 M \u03b2] {\u03bc : Measure \u03b1} (hf : AEMeasurable f \u03bc)\n    (hg : AEMeasurable g \u03bc) : AEMeasurable (fun x => f x \u2022 g x) \u03bc", "start": [614, 1], "end": [617, 68], "kind": "commanddeclaration"}, {"full_name": "MeasurableSMul\u2082.toMeasurableSMul", "code": "@[to_additive]\ninstance (priority := 100) MeasurableSMul\u2082.toMeasurableSMul [MeasurableSMul\u2082 M \u03b2] :\n    MeasurableSMul M \u03b2 :=\n  \u27e8fun _ => measurable_const.smul measurable_id, fun _ => measurable_id.smul measurable_const\u27e9", "start": [621, 1], "end": [624, 95], "kind": "commanddeclaration"}, {"full_name": "Measurable.smul_const", "code": "@[to_additive (attr := measurability)]\ntheorem Measurable.smul_const (hf : Measurable f) (y : \u03b2) : Measurable fun x => f x \u2022 y", "start": [630, 1], "end": [632, 51], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.smul_const", "code": "@[to_additive (attr := measurability)]\ntheorem AEMeasurable.smul_const (hf : AEMeasurable f \u03bc) (y : \u03b2) :\n    AEMeasurable (fun x => f x \u2022 y) \u03bc", "start": [636, 1], "end": [639, 64], "kind": "commanddeclaration"}, {"full_name": "Measurable.const_smul'", "code": "@[to_additive (attr := measurability)]\ntheorem Measurable.const_smul' (hg : Measurable g) (c : M) : Measurable fun x => c \u2022 g x", "start": [643, 1], "end": [645, 51], "kind": "commanddeclaration"}, {"full_name": "Measurable.const_smul", "code": "@[to_additive (attr := measurability)]\ntheorem Measurable.const_smul (hg : Measurable g) (c : M) : Measurable (c \u2022 g)", "start": [649, 1], "end": [651, 19], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.const_smul'", "code": "@[to_additive (attr := measurability)]\ntheorem AEMeasurable.const_smul' (hg : AEMeasurable g \u03bc) (c : M) :\n    AEMeasurable (fun x => c \u2022 g x) \u03bc", "start": [655, 1], "end": [658, 64], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.const_smul", "code": "@[to_additive (attr := measurability)]\ntheorem AEMeasurable.const_smul (hf : AEMeasurable g \u03bc) (c : M) : AEMeasurable (c \u2022 g) \u03bc", "start": [662, 1], "end": [664, 19], "kind": "commanddeclaration"}, {"full_name": "Pi.measurableSMul", "code": "@[to_additive]\ninstance Pi.measurableSMul {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, SMul M (\u03b1 i)]\n    [\u2200 i, MeasurableSpace (\u03b1 i)] [\u2200 i, MeasurableSMul M (\u03b1 i)] :\n    MeasurableSMul M (\u2200 i, \u03b1 i) :=\n  \u27e8fun _ => measurable_pi_iff.mpr fun i => (measurable_pi_apply i).const_smul _, fun _ =>\n    measurable_pi_iff.mpr fun _ => measurable_smul_const _\u27e9", "start": [668, 1], "end": [673, 60], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.measurableSMul_nat\u2082", "code": "instance AddMonoid.measurableSMul_nat\u2082 (M : Type*) [AddMonoid M] [MeasurableSpace M]\n    [MeasurableAdd\u2082 M] : MeasurableSMul\u2082 \u2115 M :=\n  \u27e8by\n    suffices Measurable fun p : M \u00d7 \u2115 => p.2 \u2022 p.1 by apply this.comp measurable_swap\n    refine' measurable_from_prod_countable fun n => _\n    induction' n with n ih\n    \u00b7 simp only [Nat.zero_eq, zero_smul, \u2190 Pi.zero_def, measurable_zero]\n    \u00b7 simp only [succ_nsmul]\n      exact measurable_id.add ih\u27e9", "start": [677, 1], "end": [686, 34], "kind": "commanddeclaration"}, {"full_name": "SubNegMonoid.measurableSMul_int\u2082", "code": "instance SubNegMonoid.measurableSMul_int\u2082 (M : Type*) [SubNegMonoid M] [MeasurableSpace M]\n    [MeasurableAdd\u2082 M] [MeasurableNeg M] : MeasurableSMul\u2082 \u2124 M :=\n  \u27e8by\n    suffices Measurable fun p : M \u00d7 \u2124 => p.2 \u2022 p.1 by apply this.comp measurable_swap\n    refine' measurable_from_prod_countable fun n => _\n    induction' n with n n ih\n    \u00b7 simp only [Int.ofNat_eq_coe, ofNat_zsmul]\n      exact measurable_const_smul _\n    \u00b7 simp only [negSucc_zsmul]\n      exact (measurable_const_smul _).neg\u27e9", "start": [689, 1], "end": [699, 43], "kind": "commanddeclaration"}, {"full_name": "measurable_const_smul_iff", "code": "@[to_additive]\ntheorem measurable_const_smul_iff (c : G) : (Measurable fun x => c \u2022 f x) \u2194 Measurable f", "start": [711, 1], "end": [713, 92], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_const_smul_iff", "code": "@[to_additive]\ntheorem aemeasurable_const_smul_iff (c : G) :\n    AEMeasurable (fun x => c \u2022 f x) \u03bc \u2194 AEMeasurable f \u03bc", "start": [717, 1], "end": [720, 92], "kind": "commanddeclaration"}, {"full_name": "Units.instMeasurableSpace", "code": "@[to_additive]\ninstance Units.instMeasurableSpace : MeasurableSpace M\u02e3 := MeasurableSpace.comap ((\u2191) : M\u02e3 \u2192 M) \u2039_\u203a", "start": [724, 1], "end": [725, 100], "kind": "commanddeclaration"}, {"full_name": "Units.measurableSMul", "code": "@[to_additive]\ninstance Units.measurableSMul : MeasurableSMul M\u02e3 \u03b2 where\n  measurable_const_smul c := (measurable_const_smul (c : M) : _)\n  measurable_smul_const x :=\n    (measurable_smul_const x : Measurable fun c : M => c \u2022 x).comp MeasurableSpace.le_map_comap", "start": [729, 1], "end": [733, 96], "kind": "commanddeclaration"}, {"full_name": "IsUnit.measurable_const_smul_iff", "code": "@[to_additive]\nnonrec theorem IsUnit.measurable_const_smul_iff {c : M} (hc : IsUnit c) :\n    (Measurable fun x => c \u2022 f x) \u2194 Measurable f", "start": [737, 1], "end": [741, 35], "kind": "commanddeclaration"}, {"full_name": "IsUnit.aemeasurable_const_smul_iff", "code": "@[to_additive]\nnonrec theorem IsUnit.aemeasurable_const_smul_iff {c : M} (hc : IsUnit c) :\n    AEMeasurable (fun x => c \u2022 f x) \u03bc \u2194 AEMeasurable f \u03bc", "start": [745, 1], "end": [749, 37], "kind": "commanddeclaration"}, {"full_name": "measurable_const_smul_iff\u2080", "code": "theorem measurable_const_smul_iff\u2080 {c : G\u2080} (hc : c \u2260 0) :\n    (Measurable fun x => c \u2022 f x) \u2194 Measurable f", "start": [756, 1], "end": [758, 46], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_const_smul_iff\u2080", "code": "theorem aemeasurable_const_smul_iff\u2080 {c : G\u2080} (hc : c \u2260 0) :\n    AEMeasurable (fun x => c \u2022 f x) \u03bc \u2194 AEMeasurable f \u03bc", "start": [761, 1], "end": [763, 48], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.instMeasurableSpace", "code": "@[to_additive]\ninstance MulOpposite.instMeasurableSpace {\u03b1 : Type*} [h : MeasurableSpace \u03b1] :\n    MeasurableSpace \u03b1\u1d50\u1d52\u1d56 :=\n  MeasurableSpace.map op h", "start": [777, 1], "end": [780, 27], "kind": "commanddeclaration"}, {"full_name": "measurable_mul_op", "code": "@[to_additive]\ntheorem measurable_mul_op {\u03b1 : Type*} [MeasurableSpace \u03b1] : Measurable (op : \u03b1 \u2192 \u03b1\u1d50\u1d52\u1d56)", "start": [784, 1], "end": [786, 5], "kind": "commanddeclaration"}, {"full_name": "measurable_mul_unop", "code": "@[to_additive]\ntheorem measurable_mul_unop {\u03b1 : Type*} [MeasurableSpace \u03b1] : Measurable (unop : \u03b1\u1d50\u1d52\u1d56 \u2192 \u03b1)", "start": [790, 1], "end": [792, 14], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.instMeasurableMul", "code": "@[to_additive]\ninstance MulOpposite.instMeasurableMul {M : Type*} [Mul M] [MeasurableSpace M]\n    [MeasurableMul M] : MeasurableMul M\u1d50\u1d52\u1d56 :=\n  \u27e8fun _ => measurable_mul_op.comp (measurable_mul_unop.mul_const _), fun _ =>\n    measurable_mul_op.comp (measurable_mul_unop.const_mul _)\u27e9", "start": [796, 1], "end": [800, 62], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.instMeasurableMul\u2082", "code": "@[to_additive]\ninstance MulOpposite.instMeasurableMul\u2082 {M : Type*} [Mul M] [MeasurableSpace M]\n    [MeasurableMul\u2082 M] : MeasurableMul\u2082 M\u1d50\u1d52\u1d56 :=\n  \u27e8measurable_mul_op.comp\n      ((measurable_mul_unop.comp measurable_snd).mul (measurable_mul_unop.comp measurable_fst))\u27e9", "start": [804, 1], "end": [808, 97], "kind": "commanddeclaration"}, {"full_name": "MeasurableSMul.op", "code": "nonrec instance MeasurableSMul.op {M \u03b1} [MeasurableSpace M] [MeasurableSpace \u03b1] [SMul M \u03b1]\n    [SMul M\u1d50\u1d52\u1d56 \u03b1] [IsCentralScalar M \u03b1] [MeasurableSMul M \u03b1] : MeasurableSMul M\u1d50\u1d52\u1d56 \u03b1 :=\n  \u27e8MulOpposite.rec' fun c =>\n      show Measurable fun x => op c \u2022 x by\n        simpa only [op_smul_eq_smul] using measurable_const_smul c,\n    fun x =>\n    show Measurable fun c => op (unop c) \u2022 x by\n      simpa only [op_smul_eq_smul] using (measurable_smul_const x).comp measurable_mul_unop\u27e9", "start": [812, 1], "end": [820, 93], "kind": "commanddeclaration"}, {"full_name": "MeasurableSMul\u2082.op", "code": "nonrec instance MeasurableSMul\u2082.op {M \u03b1} [MeasurableSpace M] [MeasurableSpace \u03b1] [SMul M \u03b1]\n    [SMul M\u1d50\u1d52\u1d56 \u03b1] [IsCentralScalar M \u03b1] [MeasurableSMul\u2082 M \u03b1] : MeasurableSMul\u2082 M\u1d50\u1d52\u1d56 \u03b1 :=\n  \u27e8show Measurable fun x : M\u1d50\u1d52\u1d56 \u00d7 \u03b1 => op (unop x.1) \u2022 x.2 by\n      simp_rw [op_smul_eq_smul]\n      refine' (measurable_mul_unop.comp measurable_fst).smul measurable_snd\u27e9", "start": [823, 1], "end": [828, 77], "kind": "commanddeclaration"}, {"full_name": "measurableSMul_opposite_of_mul", "code": "@[to_additive]\ninstance measurableSMul_opposite_of_mul {M : Type*} [Mul M] [MeasurableSpace M]\n    [MeasurableMul M] : MeasurableSMul M\u1d50\u1d52\u1d56 M :=\n  \u27e8fun c => measurable_mul_const (unop c), fun x => measurable_mul_unop.const_mul x\u27e9", "start": [831, 1], "end": [834, 85], "kind": "commanddeclaration"}, {"full_name": "measurableSMul\u2082_opposite_of_mul", "code": "@[to_additive]\ninstance measurableSMul\u2082_opposite_of_mul {M : Type*} [Mul M] [MeasurableSpace M]\n    [MeasurableMul\u2082 M] : MeasurableSMul\u2082 M\u1d50\u1d52\u1d56 M :=\n  \u27e8measurable_snd.mul (measurable_mul_unop.comp measurable_fst)\u27e9", "start": [838, 1], "end": [841, 65], "kind": "commanddeclaration"}, {"full_name": "List.measurable_prod'", "code": "@[to_additive (attr := measurability)]\ntheorem List.measurable_prod' (l : List (\u03b1 \u2192 M)) (hl : \u2200 f \u2208 l, Measurable f) :\n    Measurable l.prod", "start": [857, 1], "end": [863, 28], "kind": "commanddeclaration"}, {"full_name": "List.aemeasurable_prod'", "code": "@[to_additive (attr := measurability)]\ntheorem List.aemeasurable_prod' (l : List (\u03b1 \u2192 M)) (hl : \u2200 f \u2208 l, AEMeasurable f \u03bc) :\n    AEMeasurable l.prod \u03bc", "start": [867, 1], "end": [873, 28], "kind": "commanddeclaration"}, {"full_name": "List.measurable_prod", "code": "@[to_additive (attr := measurability)]\ntheorem List.measurable_prod (l : List (\u03b1 \u2192 M)) (hl : \u2200 f \u2208 l, Measurable f) :\n    Measurable fun x => (l.map fun f : \u03b1 \u2192 M => f x).prod", "start": [877, 1], "end": [880, 64], "kind": "commanddeclaration"}, {"full_name": "List.aemeasurable_prod", "code": "@[to_additive (attr := measurability)]\ntheorem List.aemeasurable_prod (l : List (\u03b1 \u2192 M)) (hl : \u2200 f \u2208 l, AEMeasurable f \u03bc) :\n    AEMeasurable (fun x => (l.map fun f : \u03b1 \u2192 M => f x).prod) \u03bc", "start": [884, 1], "end": [887, 66], "kind": "commanddeclaration"}, {"full_name": "Multiset.measurable_prod'", "code": "@[to_additive (attr := measurability)]\ntheorem Multiset.measurable_prod' (l : Multiset (\u03b1 \u2192 M)) (hl : \u2200 f \u2208 l, Measurable f) :\n    Measurable l.prod", "start": [898, 1], "end": [902, 53], "kind": "commanddeclaration"}, {"full_name": "Multiset.aemeasurable_prod'", "code": "@[to_additive (attr := measurability)]\ntheorem Multiset.aemeasurable_prod' (l : Multiset (\u03b1 \u2192 M)) (hl : \u2200 f \u2208 l, AEMeasurable f \u03bc) :\n    AEMeasurable l.prod \u03bc", "start": [906, 1], "end": [910, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.measurable_prod", "code": "@[to_additive (attr := measurability)]\ntheorem Multiset.measurable_prod (s : Multiset (\u03b1 \u2192 M)) (hs : \u2200 f \u2208 s, Measurable f) :\n    Measurable fun x => (s.map fun f : \u03b1 \u2192 M => f x).prod", "start": [914, 1], "end": [917, 68], "kind": "commanddeclaration"}, {"full_name": "Multiset.aemeasurable_prod", "code": "@[to_additive (attr := measurability)]\ntheorem Multiset.aemeasurable_prod (s : Multiset (\u03b1 \u2192 M)) (hs : \u2200 f \u2208 s, AEMeasurable f \u03bc) :\n    AEMeasurable (fun x => (s.map fun f : \u03b1 \u2192 M => f x).prod) \u03bc", "start": [921, 1], "end": [924, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.measurable_prod'", "code": "@[to_additive (attr := measurability)]\ntheorem Finset.measurable_prod' (s : Finset \u03b9) (hf : \u2200 i \u2208 s, Measurable (f i)) :\n    Measurable (\u220f i in s, f i)", "start": [928, 1], "end": [931, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.measurable_prod", "code": "@[to_additive (attr := measurability)]\ntheorem Finset.measurable_prod (s : Finset \u03b9) (hf : \u2200 i \u2208 s, Measurable (f i)) :\n    Measurable fun a => \u220f i in s, f i a", "start": [935, 1], "end": [938, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.aemeasurable_prod'", "code": "@[to_additive (attr := measurability)]\ntheorem Finset.aemeasurable_prod' (s : Finset \u03b9) (hf : \u2200 i \u2208 s, AEMeasurable (f i) \u03bc) :\n    AEMeasurable (\u220f i in s, f i) \u03bc", "start": [942, 1], "end": [947, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.aemeasurable_prod", "code": "@[to_additive (attr := measurability)]\ntheorem Finset.aemeasurable_prod (s : Finset \u03b9) (hf : \u2200 i \u2208 s, AEMeasurable (f i) \u03bc) :\n    AEMeasurable (fun a => \u220f i in s, f i a) \u03bc", "start": [951, 1], "end": [954, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Instances/EReal.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Rat/Encodable.lean", "Mathlib/Data/Real/EReal.lean", "Mathlib/Topology/Instances/ENNReal.lean", "Mathlib/Topology/Algebra/Order/MonotoneContinuity.lean"], "premises": [{"full_name": "EReal.denseRange_ratCast", "code": "lemma denseRange_ratCast : DenseRange (fun r : \u211a \u21a6 ((r : \u211d) : EReal)) :=\n  dense_of_exists_between fun _ _ h => exists_range_iff.2 <| exists_rat_btwn_of_lt h", "start": [45, 1], "end": [46, 85], "kind": "mathlibtacticlemma"}, {"full_name": "EReal.embedding_coe", "code": "theorem embedding_coe : Embedding ((\u2191) : \u211d \u2192 EReal)", "start": [54, 1], "end": [55, 95], "kind": "commanddeclaration"}, {"full_name": "EReal.openEmbedding_coe", "code": "theorem openEmbedding_coe : OpenEmbedding ((\u2191) : \u211d \u2192 EReal)", "start": [58, 1], "end": [59, 63], "kind": "commanddeclaration"}, {"full_name": "EReal.tendsto_coe", "code": "@[norm_cast]\ntheorem tendsto_coe {\u03b1 : Type*} {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d} {a : \u211d} :\n    Tendsto (fun a => (m a : EReal)) f (\ud835\udcdd \u2191a) \u2194 Tendsto m f (\ud835\udcdd a)", "start": [62, 1], "end": [65, 38], "kind": "commanddeclaration"}, {"full_name": "continuous_coe_real_ereal", "code": "theorem _root_.continuous_coe_real_ereal : Continuous ((\u2191) : \u211d \u2192 EReal)", "start": [68, 1], "end": [69, 27], "kind": "commanddeclaration"}, {"full_name": "EReal.continuous_coe_iff", "code": "theorem continuous_coe_iff {f : \u03b1 \u2192 \u211d} : (Continuous fun a => (f a : EReal)) \u2194 Continuous f", "start": [72, 1], "end": [73, 36], "kind": "commanddeclaration"}, {"full_name": "EReal.nhds_coe", "code": "theorem nhds_coe {r : \u211d} : \ud835\udcdd (r : EReal) = (\ud835\udcdd r).map (\u2191)", "start": [76, 1], "end": [77, 41], "kind": "commanddeclaration"}, {"full_name": "EReal.nhds_coe_coe", "code": "theorem nhds_coe_coe {r p : \u211d} :\n    \ud835\udcdd ((r : EReal), (p : EReal)) = (\ud835\udcdd (r, p)).map fun p : \u211d \u00d7 \u211d => (\u2191p.1, \u2191p.2)", "start": [80, 1], "end": [82, 71], "kind": "commanddeclaration"}, {"full_name": "EReal.tendsto_toReal", "code": "theorem tendsto_toReal {a : EReal} (ha : a \u2260 \u22a4) (h'a : a \u2260 \u22a5) :\n    Tendsto EReal.toReal (\ud835\udcdd a) (\ud835\udcdd a.toReal)", "start": [85, 1], "end": [89, 19], "kind": "commanddeclaration"}, {"full_name": "EReal.continuousOn_toReal", "code": "theorem continuousOn_toReal : ContinuousOn EReal.toReal ({\u22a5, \u22a4}\u1d9c : Set EReal)", "start": [92, 1], "end": [93, 81], "kind": "commanddeclaration"}, {"full_name": "EReal.neBotTopHomeomorphReal", "code": "def neBotTopHomeomorphReal : ({\u22a5, \u22a4}\u1d9c : Set EReal) \u2243\u209c \u211d where\n  toEquiv := neTopBotEquivReal\n  continuous_toFun := continuousOn_iff_continuous_restrict.1 continuousOn_toReal\n  continuous_invFun := continuous_coe_real_ereal.subtype_mk _", "start": [96, 1], "end": [100, 62], "kind": "commanddeclaration"}, {"full_name": "EReal.embedding_coe_ennreal", "code": "theorem embedding_coe_ennreal : Embedding ((\u2191) : \u211d\u22650\u221e \u2192 EReal)", "start": [105, 1], "end": [107, 51], "kind": "commanddeclaration"}, {"full_name": "EReal.closedEmbedding_coe_ennreal", "code": "theorem closedEmbedding_coe_ennreal : ClosedEmbedding ((\u2191) : \u211d\u22650\u221e \u2192 EReal)", "start": [110, 1], "end": [111, 73], "kind": "commanddeclaration"}, {"full_name": "EReal.tendsto_coe_ennreal", "code": "@[norm_cast]\ntheorem tendsto_coe_ennreal {\u03b1 : Type*} {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e} :\n    Tendsto (fun a => (m a : EReal)) f (\ud835\udcdd \u2191a) \u2194 Tendsto m f (\ud835\udcdd a)", "start": [113, 1], "end": [116, 46], "kind": "commanddeclaration"}, {"full_name": "continuous_coe_ennreal_ereal", "code": "theorem _root_.continuous_coe_ennreal_ereal : Continuous ((\u2191) : \u211d\u22650\u221e \u2192 EReal)", "start": [119, 1], "end": [120, 35], "kind": "commanddeclaration"}, {"full_name": "EReal.continuous_coe_ennreal_iff", "code": "theorem continuous_coe_ennreal_iff {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    (Continuous fun a => (f a : EReal)) \u2194 Continuous f", "start": [123, 1], "end": [125, 44], "kind": "commanddeclaration"}, {"full_name": "EReal.nhds_top", "code": "theorem nhds_top : \ud835\udcdd (\u22a4 : EReal) = \u2a05 (a) (_ : a \u2260 \u22a4), \ud835\udcdf (Ioi a)", "start": [130, 1], "end": [131, 59], "kind": "commanddeclaration"}, {"full_name": "EReal.nhds_top_basis", "code": "nonrec theorem nhds_top_basis : (\ud835\udcdd (\u22a4 : EReal)).HasBasis (fun _ : \u211d \u21a6 True) (Ioi \u00b7)", "start": [134, 1], "end": [137, 44], "kind": "commanddeclaration"}, {"full_name": "EReal.nhds_top'", "code": "theorem nhds_top' : \ud835\udcdd (\u22a4 : EReal) = \u2a05 a : \u211d, \ud835\udcdf (Ioi \u2191a)", "start": [139, 1], "end": [139, 82], "kind": "commanddeclaration"}, {"full_name": "EReal.mem_nhds_top_iff", "code": "theorem mem_nhds_top_iff {s : Set EReal} : s \u2208 \ud835\udcdd (\u22a4 : EReal) \u2194 \u2203 y : \u211d, Ioi (y : EReal) \u2286 s", "start": [142, 1], "end": [143, 58], "kind": "commanddeclaration"}, {"full_name": "EReal.tendsto_nhds_top_iff_real", "code": "theorem tendsto_nhds_top_iff_real {\u03b1 : Type*} {m : \u03b1 \u2192 EReal} {f : Filter \u03b1} :\n    Tendsto m f (\ud835\udcdd \u22a4) \u2194 \u2200 x : \u211d, \u2200\u1da0 a in f, \u2191x < m a", "start": [146, 1], "end": [148, 81], "kind": "commanddeclaration"}, {"full_name": "EReal.nhds_bot", "code": "theorem nhds_bot : \ud835\udcdd (\u22a5 : EReal) = \u2a05 (a) (_ : a \u2260 \u22a5), \ud835\udcdf (Iio a)", "start": [151, 1], "end": [152, 59], "kind": "commanddeclaration"}, {"full_name": "EReal.nhds_bot_basis", "code": "theorem nhds_bot_basis : (\ud835\udcdd (\u22a5 : EReal)).HasBasis (fun _ : \u211d \u21a6 True) (Iio \u00b7)", "start": [155, 1], "end": [158, 44], "kind": "commanddeclaration"}, {"full_name": "EReal.nhds_bot'", "code": "theorem nhds_bot' : \ud835\udcdd (\u22a5 : EReal) = \u2a05 a : \u211d, \ud835\udcdf (Iio \u2191a)", "start": [160, 1], "end": [161, 25], "kind": "commanddeclaration"}, {"full_name": "EReal.mem_nhds_bot_iff", "code": "theorem mem_nhds_bot_iff {s : Set EReal} : s \u2208 \ud835\udcdd (\u22a5 : EReal) \u2194 \u2203 y : \u211d, Iio (y : EReal) \u2286 s", "start": [164, 1], "end": [165, 58], "kind": "commanddeclaration"}, {"full_name": "EReal.tendsto_nhds_bot_iff_real", "code": "theorem tendsto_nhds_bot_iff_real {\u03b1 : Type*} {m : \u03b1 \u2192 EReal} {f : Filter \u03b1} :\n    Tendsto m f (\ud835\udcdd \u22a5) \u2194 \u2200 x : \u211d, \u2200\u1da0 a in f, m a < x", "start": [168, 1], "end": [170, 81], "kind": "commanddeclaration"}, {"full_name": "EReal.continuousAt_add_coe_coe", "code": "theorem continuousAt_add_coe_coe (a b : \u211d) :\n    ContinuousAt (fun p : EReal \u00d7 EReal => p.1 + p.2) (a, b)", "start": [175, 1], "end": [178, 17], "kind": "commanddeclaration"}, {"full_name": "EReal.continuousAt_add_top_coe", "code": "theorem continuousAt_add_top_coe (a : \u211d) :\n    ContinuousAt (fun p : EReal \u00d7 EReal => p.1 + p.2) (\u22a4, a)", "start": [181, 1], "end": [186, 66], "kind": "commanddeclaration"}, {"full_name": "EReal.continuousAt_add_coe_top", "code": "theorem continuousAt_add_coe_top (a : \u211d) :\n    ContinuousAt (fun p : EReal \u00d7 EReal => p.1 + p.2) (a, \u22a4)", "start": [189, 1], "end": [192, 95], "kind": "commanddeclaration"}, {"full_name": "EReal.continuousAt_add_top_top", "code": "theorem continuousAt_add_top_top : ContinuousAt (fun p : EReal \u00d7 EReal => p.1 + p.2) (\u22a4, \u22a4)", "start": [195, 1], "end": [199, 59], "kind": "commanddeclaration"}, {"full_name": "EReal.continuousAt_add_bot_coe", "code": "theorem continuousAt_add_bot_coe (a : \u211d) :\n    ContinuousAt (fun p : EReal \u00d7 EReal => p.1 + p.2) (\u22a5, a)", "start": [202, 1], "end": [207, 66], "kind": "commanddeclaration"}, {"full_name": "EReal.continuousAt_add_coe_bot", "code": "theorem continuousAt_add_coe_bot (a : \u211d) :\n    ContinuousAt (fun p : EReal \u00d7 EReal => p.1 + p.2) (a, \u22a5)", "start": [210, 1], "end": [213, 95], "kind": "commanddeclaration"}, {"full_name": "EReal.continuousAt_add_bot_bot", "code": "theorem continuousAt_add_bot_bot : ContinuousAt (fun p : EReal \u00d7 EReal => p.1 + p.2) (\u22a5, \u22a5)", "start": [216, 1], "end": [220, 59], "kind": "commanddeclaration"}, {"full_name": "EReal.continuousAt_add", "code": "theorem continuousAt_add {p : EReal \u00d7 EReal} (h : p.1 \u2260 \u22a4 \u2228 p.2 \u2260 \u22a5) (h' : p.1 \u2260 \u22a5 \u2228 p.2 \u2260 \u22a4) :\n    ContinuousAt (fun p : EReal \u00d7 EReal => p.1 + p.2) p", "start": [223, 1], "end": [237, 35], "kind": "commanddeclaration"}, {"full_name": "EReal.negHomeo", "code": "@[deprecated Homeomorph.neg]\ndef negHomeo : EReal \u2243\u209c EReal :=\n  negOrderIso.toHomeomorph", "start": [244, 1], "end": [247, 27], "kind": "commanddeclaration"}, {"full_name": "EReal.continuous_neg", "code": "@[deprecated continuous_neg]\nprotected theorem continuous_neg : Continuous fun x : EReal => -x", "start": [250, 1], "end": [252, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Semicontinuous.lean", "imports": ["Mathlib/Topology/Instances/ENNReal.lean", "Mathlib/Algebra/IndicatorFunction.lean", "Mathlib/Topology/ContinuousOn.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LowerSemicontinuousWithinAt", "code": "def LowerSemicontinuousWithinAt (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (x : \u03b1) :=\n  \u2200 y < f x, \u2200\u1da0 x' in \ud835\udcdd[s] x, y < f x'", "start": [67, 1], "end": [71, 39], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuousOn", "code": "def LowerSemicontinuousOn (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :=\n  \u2200 x \u2208 s, LowerSemicontinuousWithinAt f s x", "start": [74, 1], "end": [78, 45], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuousAt", "code": "def LowerSemicontinuousAt (f : \u03b1 \u2192 \u03b2) (x : \u03b1) :=\n  \u2200 y < f x, \u2200\u1da0 x' in \ud835\udcdd x, y < f x'", "start": [81, 1], "end": [85, 36], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuous", "code": "def LowerSemicontinuous (f : \u03b1 \u2192 \u03b2) :=\n  \u2200 x, LowerSemicontinuousAt f x", "start": [88, 1], "end": [92, 33], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuousWithinAt", "code": "def UpperSemicontinuousWithinAt (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (x : \u03b1) :=\n  \u2200 y, f x < y \u2192 \u2200\u1da0 x' in \ud835\udcdd[s] x, f x' < y", "start": [95, 1], "end": [99, 43], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuousOn", "code": "def UpperSemicontinuousOn (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :=\n  \u2200 x \u2208 s, UpperSemicontinuousWithinAt f s x", "start": [102, 1], "end": [106, 45], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuousAt", "code": "def UpperSemicontinuousAt (f : \u03b1 \u2192 \u03b2) (x : \u03b1) :=\n  \u2200 y, f x < y \u2192 \u2200\u1da0 x' in \ud835\udcdd x, f x' < y", "start": [109, 1], "end": [113, 40], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuous", "code": "def UpperSemicontinuous (f : \u03b1 \u2192 \u03b2) :=\n  \u2200 x, UpperSemicontinuousAt f x", "start": [116, 1], "end": [120, 33], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuousWithinAt.mono", "code": "theorem LowerSemicontinuousWithinAt.mono (h : LowerSemicontinuousWithinAt f s x) (hst : t \u2286 s) :\n    LowerSemicontinuousWithinAt f t x", "start": [131, 1], "end": [133, 65], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousWithinAt_univ_iff", "code": "theorem lowerSemicontinuousWithinAt_univ_iff :\n    LowerSemicontinuousWithinAt f univ x \u2194 LowerSemicontinuousAt f x", "start": [136, 1], "end": [138, 77], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuousAt.lowerSemicontinuousWithinAt", "code": "theorem LowerSemicontinuousAt.lowerSemicontinuousWithinAt (s : Set \u03b1)\n    (h : LowerSemicontinuousAt f x) : LowerSemicontinuousWithinAt f s x", "start": [141, 1], "end": [143, 60], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuousOn.lowerSemicontinuousWithinAt", "code": "theorem LowerSemicontinuousOn.lowerSemicontinuousWithinAt (h : LowerSemicontinuousOn f s)\n    (hx : x \u2208 s) : LowerSemicontinuousWithinAt f s x", "start": [146, 1], "end": [148, 9], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuousOn.mono", "code": "theorem LowerSemicontinuousOn.mono (h : LowerSemicontinuousOn f s) (hst : t \u2286 s) :\n    LowerSemicontinuousOn f t", "start": [151, 1], "end": [152, 69], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousOn_univ_iff", "code": "theorem lowerSemicontinuousOn_univ_iff : LowerSemicontinuousOn f univ \u2194 LowerSemicontinuous f", "start": [155, 1], "end": [156, 90], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuous.lowerSemicontinuousAt", "code": "theorem LowerSemicontinuous.lowerSemicontinuousAt (h : LowerSemicontinuous f) (x : \u03b1) :\n    LowerSemicontinuousAt f x", "start": [159, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuous.lowerSemicontinuousWithinAt", "code": "theorem LowerSemicontinuous.lowerSemicontinuousWithinAt (h : LowerSemicontinuous f) (s : Set \u03b1)\n    (x : \u03b1) : LowerSemicontinuousWithinAt f s x", "start": [164, 1], "end": [166, 38], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuous.lowerSemicontinuousOn", "code": "theorem LowerSemicontinuous.lowerSemicontinuousOn (h : LowerSemicontinuous f) (s : Set \u03b1) :\n    LowerSemicontinuousOn f s", "start": [169, 1], "end": [170, 80], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousWithinAt_const", "code": "theorem lowerSemicontinuousWithinAt_const : LowerSemicontinuousWithinAt (fun _x => z) s x", "start": [176, 1], "end": [177, 56], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousAt_const", "code": "theorem lowerSemicontinuousAt_const : LowerSemicontinuousAt (fun _x => z) x", "start": [180, 1], "end": [181, 43], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousOn_const", "code": "theorem lowerSemicontinuousOn_const : LowerSemicontinuousOn (fun _x => z) s", "start": [184, 1], "end": [185, 36], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuous_const", "code": "theorem lowerSemicontinuous_const : LowerSemicontinuous fun _x : \u03b1 => z", "start": [188, 1], "end": [189, 30], "kind": "commanddeclaration"}, {"full_name": "IsOpen.lowerSemicontinuous_indicator", "code": "theorem IsOpen.lowerSemicontinuous_indicator (hs : IsOpen s) (hy : 0 \u2264 y) :\n    LowerSemicontinuous (indicator s fun _x => y)", "start": [199, 1], "end": [206, 59], "kind": "commanddeclaration"}, {"full_name": "IsOpen.lowerSemicontinuousOn_indicator", "code": "theorem IsOpen.lowerSemicontinuousOn_indicator (hs : IsOpen s) (hy : 0 \u2264 y) :\n    LowerSemicontinuousOn (indicator s fun _x => y) t", "start": [209, 1], "end": [211, 64], "kind": "commanddeclaration"}, {"full_name": "IsOpen.lowerSemicontinuousAt_indicator", "code": "theorem IsOpen.lowerSemicontinuousAt_indicator (hs : IsOpen s) (hy : 0 \u2264 y) :\n    LowerSemicontinuousAt (indicator s fun _x => y) x", "start": [214, 1], "end": [216, 64], "kind": "commanddeclaration"}, {"full_name": "IsOpen.lowerSemicontinuousWithinAt_indicator", "code": "theorem IsOpen.lowerSemicontinuousWithinAt_indicator (hs : IsOpen s) (hy : 0 \u2264 y) :\n    LowerSemicontinuousWithinAt (indicator s fun _x => y) t x", "start": [219, 1], "end": [221, 72], "kind": "commanddeclaration"}, {"full_name": "IsClosed.lowerSemicontinuous_indicator", "code": "theorem IsClosed.lowerSemicontinuous_indicator (hs : IsClosed s) (hy : y \u2264 0) :\n    LowerSemicontinuous (indicator s fun _x => y)", "start": [224, 1], "end": [231, 49], "kind": "commanddeclaration"}, {"full_name": "IsClosed.lowerSemicontinuousOn_indicator", "code": "theorem IsClosed.lowerSemicontinuousOn_indicator (hs : IsClosed s) (hy : y \u2264 0) :\n    LowerSemicontinuousOn (indicator s fun _x => y) t", "start": [234, 1], "end": [236, 64], "kind": "commanddeclaration"}, {"full_name": "IsClosed.lowerSemicontinuousAt_indicator", "code": "theorem IsClosed.lowerSemicontinuousAt_indicator (hs : IsClosed s) (hy : y \u2264 0) :\n    LowerSemicontinuousAt (indicator s fun _x => y) x", "start": [239, 1], "end": [241, 64], "kind": "commanddeclaration"}, {"full_name": "IsClosed.lowerSemicontinuousWithinAt_indicator", "code": "theorem IsClosed.lowerSemicontinuousWithinAt_indicator (hs : IsClosed s) (hy : y \u2264 0) :\n    LowerSemicontinuousWithinAt (indicator s fun _x => y) t x", "start": [244, 1], "end": [246, 72], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuous_iff_isOpen_preimage", "code": "theorem lowerSemicontinuous_iff_isOpen_preimage :\n    LowerSemicontinuous f \u2194 \u2200 y, IsOpen (f \u207b\u00b9' Ioi y)", "start": [254, 1], "end": [257, 32], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuous.isOpen_preimage", "code": "theorem LowerSemicontinuous.isOpen_preimage (hf : LowerSemicontinuous f) (y : \u03b2) :\n    IsOpen (f \u207b\u00b9' Ioi y)", "start": [260, 1], "end": [262, 49], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuous_iff_isClosed_preimage", "code": "theorem lowerSemicontinuous_iff_isClosed_preimage {f : \u03b1 \u2192 \u03b3} :\n    LowerSemicontinuous f \u2194 \u2200 y, IsClosed (f \u207b\u00b9' Iic y)", "start": [269, 1], "end": [272, 62], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuous.isClosed_preimage", "code": "theorem LowerSemicontinuous.isClosed_preimage {f : \u03b1 \u2192 \u03b3} (hf : LowerSemicontinuous f) (y : \u03b3) :\n    IsClosed (f \u207b\u00b9' Iic y)", "start": [275, 1], "end": [277, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.lowerSemicontinuousWithinAt", "code": "theorem ContinuousWithinAt.lowerSemicontinuousWithinAt {f : \u03b1 \u2192 \u03b3} (h : ContinuousWithinAt f s x) :\n    LowerSemicontinuousWithinAt f s x", "start": [282, 1], "end": [283, 74], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.lowerSemicontinuousAt", "code": "theorem ContinuousAt.lowerSemicontinuousAt {f : \u03b1 \u2192 \u03b3} (h : ContinuousAt f x) :\n    LowerSemicontinuousAt f x", "start": [286, 1], "end": [287, 66], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.lowerSemicontinuousOn", "code": "theorem ContinuousOn.lowerSemicontinuousOn {f : \u03b1 \u2192 \u03b3} (h : ContinuousOn f s) :\n    LowerSemicontinuousOn f s", "start": [290, 1], "end": [291, 82], "kind": "commanddeclaration"}, {"full_name": "Continuous.lowerSemicontinuous", "code": "theorem Continuous.lowerSemicontinuous {f : \u03b1 \u2192 \u03b3} (h : Continuous f) : LowerSemicontinuous f", "start": [294, 1], "end": [295, 49], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.comp_lowerSemicontinuousWithinAt", "code": "theorem ContinuousAt.comp_lowerSemicontinuousWithinAt {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3}\n    (hg : ContinuousAt g (f x)) (hf : LowerSemicontinuousWithinAt f s x) (gmon : Monotone g) :\n    LowerSemicontinuousWithinAt (g \u2218 f) s x", "start": [309, 1], "end": [322, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.comp_lowerSemicontinuousAt", "code": "theorem ContinuousAt.comp_lowerSemicontinuousAt {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3} (hg : ContinuousAt g (f x))\n    (hf : LowerSemicontinuousAt f x) (gmon : Monotone g) : LowerSemicontinuousAt (g \u2218 f) x", "start": [325, 1], "end": [328, 52], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp_lowerSemicontinuousOn", "code": "theorem Continuous.comp_lowerSemicontinuousOn {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3} (hg : Continuous g)\n    (hf : LowerSemicontinuousOn f s) (gmon : Monotone g) : LowerSemicontinuousOn (g \u2218 f) s", "start": [331, 1], "end": [333, 78], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp_lowerSemicontinuous", "code": "theorem Continuous.comp_lowerSemicontinuous {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3} (hg : Continuous g)\n    (hf : LowerSemicontinuous f) (gmon : Monotone g) : LowerSemicontinuous (g \u2218 f)", "start": [336, 1], "end": [338, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.comp_lowerSemicontinuousWithinAt_antitone", "code": "theorem ContinuousAt.comp_lowerSemicontinuousWithinAt_antitone {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3}\n    (hg : ContinuousAt g (f x)) (hf : LowerSemicontinuousWithinAt f s x) (gmon : Antitone g) :\n    UpperSemicontinuousWithinAt (g \u2218 f) s x", "start": [341, 1], "end": [344, 90], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.comp_lowerSemicontinuousAt_antitone", "code": "theorem ContinuousAt.comp_lowerSemicontinuousAt_antitone {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3}\n    (hg : ContinuousAt g (f x)) (hf : LowerSemicontinuousAt f x) (gmon : Antitone g) :\n    UpperSemicontinuousAt (g \u2218 f) x", "start": [347, 1], "end": [350, 82], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp_lowerSemicontinuousOn_antitone", "code": "theorem Continuous.comp_lowerSemicontinuousOn_antitone {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3} (hg : Continuous g)\n    (hf : LowerSemicontinuousOn f s) (gmon : Antitone g) : UpperSemicontinuousOn (g \u2218 f) s", "start": [353, 1], "end": [355, 87], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp_lowerSemicontinuous_antitone", "code": "theorem Continuous.comp_lowerSemicontinuous_antitone {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3} (hg : Continuous g)\n    (hf : LowerSemicontinuous f) (gmon : Antitone g) : UpperSemicontinuous (g \u2218 f)", "start": [358, 1], "end": [360, 66], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuousWithinAt.add'", "code": "theorem LowerSemicontinuousWithinAt.add' {f g : \u03b1 \u2192 \u03b3} (hf : LowerSemicontinuousWithinAt f s x)\n    (hg : LowerSemicontinuousWithinAt g s x)\n    (hcont : ContinuousAt (fun p : \u03b3 \u00d7 \u03b3 => p.1 + p.2) (f x, g x)) :\n    LowerSemicontinuousWithinAt (fun z => f z + g z) s x", "start": [373, 1], "end": [443, 60], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuousAt.add'", "code": "theorem LowerSemicontinuousAt.add' {f g : \u03b1 \u2192 \u03b3} (hf : LowerSemicontinuousAt f x)\n    (hg : LowerSemicontinuousAt g x)\n    (hcont : ContinuousAt (fun p : \u03b3 \u00d7 \u03b3 => p.1 + p.2) (f x, g x)) :\n    LowerSemicontinuousAt (fun z => f z + g z) x", "start": [446, 1], "end": [454, 25], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuousOn.add'", "code": "theorem LowerSemicontinuousOn.add' {f g : \u03b1 \u2192 \u03b3} (hf : LowerSemicontinuousOn f s)\n    (hg : LowerSemicontinuousOn g s)\n    (hcont : \u2200 x \u2208 s, ContinuousAt (fun p : \u03b3 \u00d7 \u03b3 => p.1 + p.2) (f x, g x)) :\n    LowerSemicontinuousOn (fun z => f z + g z) s", "start": [457, 1], "end": [464, 40], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuous.add'", "code": "theorem LowerSemicontinuous.add' {f g : \u03b1 \u2192 \u03b3} (hf : LowerSemicontinuous f)\n    (hg : LowerSemicontinuous g)\n    (hcont : \u2200 x, ContinuousAt (fun p : \u03b3 \u00d7 \u03b3 => p.1 + p.2) (f x, g x)) :\n    LowerSemicontinuous fun z => f z + g z", "start": [467, 1], "end": [473, 84], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuousWithinAt.add", "code": "theorem LowerSemicontinuousWithinAt.add {f g : \u03b1 \u2192 \u03b3} (hf : LowerSemicontinuousWithinAt f s x)\n    (hg : LowerSemicontinuousWithinAt g s x) :\n    LowerSemicontinuousWithinAt (fun z => f z + g z) s x", "start": [478, 1], "end": [484, 41], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuousAt.add", "code": "theorem LowerSemicontinuousAt.add {f g : \u03b1 \u2192 \u03b3} (hf : LowerSemicontinuousAt f x)\n    (hg : LowerSemicontinuousAt g x) : LowerSemicontinuousAt (fun z => f z + g z) x", "start": [487, 1], "end": [492, 41], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuousOn.add", "code": "theorem LowerSemicontinuousOn.add {f g : \u03b1 \u2192 \u03b3} (hf : LowerSemicontinuousOn f s)\n    (hg : LowerSemicontinuousOn g s) : LowerSemicontinuousOn (fun z => f z + g z) s", "start": [495, 1], "end": [500, 55], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuous.add", "code": "theorem LowerSemicontinuous.add {f g : \u03b1 \u2192 \u03b3} (hf : LowerSemicontinuous f)\n    (hg : LowerSemicontinuous g) : LowerSemicontinuous fun z => f z + g z", "start": [503, 1], "end": [508, 51], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousWithinAt_sum", "code": "theorem lowerSemicontinuousWithinAt_sum {f : \u03b9 \u2192 \u03b1 \u2192 \u03b3} {a : Finset \u03b9}\n    (ha : \u2200 i \u2208 a, LowerSemicontinuousWithinAt (f i) s x) :\n    LowerSemicontinuousWithinAt (fun z => \u2211 i in a, f i z) s x", "start": [511, 1], "end": [520, 62], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousAt_sum", "code": "theorem lowerSemicontinuousAt_sum {f : \u03b9 \u2192 \u03b1 \u2192 \u03b3} {a : Finset \u03b9}\n    (ha : \u2200 i \u2208 a, LowerSemicontinuousAt (f i) x) :\n    LowerSemicontinuousAt (fun z => \u2211 i in a, f i z) x", "start": [523, 1], "end": [527, 43], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousOn_sum", "code": "theorem lowerSemicontinuousOn_sum {f : \u03b9 \u2192 \u03b1 \u2192 \u03b3} {a : Finset \u03b9}\n    (ha : \u2200 i \u2208 a, LowerSemicontinuousOn (f i) s) :\n    LowerSemicontinuousOn (fun z => \u2211 i in a, f i z) s", "start": [530, 1], "end": [533, 59], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuous_sum", "code": "theorem lowerSemicontinuous_sum {f : \u03b9 \u2192 \u03b1 \u2192 \u03b3} {a : Finset \u03b9}\n    (ha : \u2200 i \u2208 a, LowerSemicontinuous (f i)) : LowerSemicontinuous fun z => \u2211 i in a, f i z", "start": [536, 1], "end": [538, 59], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousWithinAt_ciSup", "code": "theorem lowerSemicontinuousWithinAt_ciSup {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4'}\n    (bdd : \u2200\u1da0 y in \ud835\udcdd[s] x, BddAbove (range fun i => f i y))\n    (h : \u2200 i, LowerSemicontinuousWithinAt (f i) s x) :\n    LowerSemicontinuousWithinAt (fun x' => \u2a06 i, f i x') s x", "start": [550, 1], "end": [558, 84], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousWithinAt_iSup", "code": "theorem lowerSemicontinuousWithinAt_iSup {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4}\n    (h : \u2200 i, LowerSemicontinuousWithinAt (f i) s x) :\n    LowerSemicontinuousWithinAt (fun x' => \u2a06 i, f i x') s x", "start": [561, 1], "end": [564, 48], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousWithinAt_biSup", "code": "theorem lowerSemicontinuousWithinAt_biSup {p : \u03b9 \u2192 Prop} {f : \u2200 (i) (_h : p i), \u03b1 \u2192 \u03b4}\n    (h : \u2200 i hi, LowerSemicontinuousWithinAt (f i hi) s x) :\n    LowerSemicontinuousWithinAt (fun x' => \u2a06 (i) (hi), f i hi x') s x", "start": [567, 1], "end": [570, 94], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousAt_ciSup", "code": "theorem lowerSemicontinuousAt_ciSup {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4'}\n    (bdd : \u2200\u1da0 y in \ud835\udcdd x, BddAbove (range fun i => f i y)) (h : \u2200 i, LowerSemicontinuousAt (f i) x) :\n    LowerSemicontinuousAt (fun x' => \u2a06 i, f i x') x", "start": [573, 1], "end": [578, 48], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousAt_iSup", "code": "theorem lowerSemicontinuousAt_iSup {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4} (h : \u2200 i, LowerSemicontinuousAt (f i) x) :\n    LowerSemicontinuousAt (fun x' => \u2a06 i, f i x') x", "start": [581, 1], "end": [583, 42], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousAt_biSup", "code": "theorem lowerSemicontinuousAt_biSup {p : \u03b9 \u2192 Prop} {f : \u2200 (i) (_h : p i), \u03b1 \u2192 \u03b4}\n    (h : \u2200 i hi, LowerSemicontinuousAt (f i hi) x) :\n    LowerSemicontinuousAt (fun x' => \u2a06 (i) (hi), f i hi x') x", "start": [586, 1], "end": [589, 82], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousOn_ciSup", "code": "theorem lowerSemicontinuousOn_ciSup {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4'}\n    (bdd : \u2200 x \u2208 s, BddAbove (range fun i => f i x)) (h : \u2200 i, LowerSemicontinuousOn (f i) s) :\n    LowerSemicontinuousOn (fun x' => \u2a06 i, f i x') s", "start": [592, 1], "end": [595, 92], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousOn_iSup", "code": "theorem lowerSemicontinuousOn_iSup {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4} (h : \u2200 i, LowerSemicontinuousOn (f i) s) :\n    LowerSemicontinuousOn (fun x' => \u2a06 i, f i x') s", "start": [598, 1], "end": [600, 42], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousOn_biSup", "code": "theorem lowerSemicontinuousOn_biSup {p : \u03b9 \u2192 Prop} {f : \u2200 (i) (_h : p i), \u03b1 \u2192 \u03b4}\n    (h : \u2200 i hi, LowerSemicontinuousOn (f i hi) s) :\n    LowerSemicontinuousOn (fun x' => \u2a06 (i) (hi), f i hi x') s", "start": [603, 1], "end": [606, 82], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuous_ciSup", "code": "theorem lowerSemicontinuous_ciSup {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4'} (bdd : \u2200 x, BddAbove (range fun i => f i x))\n    (h : \u2200 i, LowerSemicontinuous (f i)) : LowerSemicontinuous fun x' => \u2a06 i, f i x'", "start": [609, 1], "end": [611, 72], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuous_iSup", "code": "theorem lowerSemicontinuous_iSup {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4} (h : \u2200 i, LowerSemicontinuous (f i)) :\n    LowerSemicontinuous fun x' => \u2a06 i, f i x'", "start": [614, 1], "end": [616, 40], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuous_biSup", "code": "theorem lowerSemicontinuous_biSup {p : \u03b9 \u2192 Prop} {f : \u2200 (i) (_h : p i), \u03b1 \u2192 \u03b4}\n    (h : \u2200 i hi, LowerSemicontinuous (f i hi)) :\n    LowerSemicontinuous fun x' => \u2a06 (i) (hi), f i hi x'", "start": [619, 1], "end": [622, 78], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousWithinAt_tsum", "code": "theorem lowerSemicontinuousWithinAt_tsum {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e}\n    (h : \u2200 i, LowerSemicontinuousWithinAt (f i) s x) :\n    LowerSemicontinuousWithinAt (fun x' => \u2211' i, f i x') s x", "start": [634, 1], "end": [639, 57], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousAt_tsum", "code": "theorem lowerSemicontinuousAt_tsum {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200 i, LowerSemicontinuousAt (f i) x) :\n    LowerSemicontinuousAt (fun x' => \u2211' i, f i x') x", "start": [642, 1], "end": [645, 43], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuousOn_tsum", "code": "theorem lowerSemicontinuousOn_tsum {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200 i, LowerSemicontinuousOn (f i) s) :\n    LowerSemicontinuousOn (fun x' => \u2211' i, f i x') s", "start": [648, 1], "end": [650, 53], "kind": "commanddeclaration"}, {"full_name": "lowerSemicontinuous_tsum", "code": "theorem lowerSemicontinuous_tsum {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200 i, LowerSemicontinuous (f i)) :\n    LowerSemicontinuous fun x' => \u2211' i, f i x'", "start": [653, 1], "end": [654, 101], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuousWithinAt.mono", "code": "theorem UpperSemicontinuousWithinAt.mono (h : UpperSemicontinuousWithinAt f s x) (hst : t \u2286 s) :\n    UpperSemicontinuousWithinAt f t x", "start": [667, 1], "end": [669, 65], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousWithinAt_univ_iff", "code": "theorem upperSemicontinuousWithinAt_univ_iff :\n    UpperSemicontinuousWithinAt f univ x \u2194 UpperSemicontinuousAt f x", "start": [672, 1], "end": [674, 77], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuousAt.upperSemicontinuousWithinAt", "code": "theorem UpperSemicontinuousAt.upperSemicontinuousWithinAt (s : Set \u03b1)\n    (h : UpperSemicontinuousAt f x) : UpperSemicontinuousWithinAt f s x", "start": [677, 1], "end": [679, 60], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuousOn.upperSemicontinuousWithinAt", "code": "theorem UpperSemicontinuousOn.upperSemicontinuousWithinAt (h : UpperSemicontinuousOn f s)\n    (hx : x \u2208 s) : UpperSemicontinuousWithinAt f s x", "start": [682, 1], "end": [684, 9], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuousOn.mono", "code": "theorem UpperSemicontinuousOn.mono (h : UpperSemicontinuousOn f s) (hst : t \u2286 s) :\n    UpperSemicontinuousOn f t", "start": [687, 1], "end": [688, 69], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousOn_univ_iff", "code": "theorem upperSemicontinuousOn_univ_iff : UpperSemicontinuousOn f univ \u2194 UpperSemicontinuous f", "start": [691, 1], "end": [692, 90], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuous.upperSemicontinuousAt", "code": "theorem UpperSemicontinuous.upperSemicontinuousAt (h : UpperSemicontinuous f) (x : \u03b1) :\n    UpperSemicontinuousAt f x", "start": [695, 1], "end": [697, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuous.upperSemicontinuousWithinAt", "code": "theorem UpperSemicontinuous.upperSemicontinuousWithinAt (h : UpperSemicontinuous f) (s : Set \u03b1)\n    (x : \u03b1) : UpperSemicontinuousWithinAt f s x", "start": [700, 1], "end": [702, 38], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuous.upperSemicontinuousOn", "code": "theorem UpperSemicontinuous.upperSemicontinuousOn (h : UpperSemicontinuous f) (s : Set \u03b1) :\n    UpperSemicontinuousOn f s", "start": [705, 1], "end": [706, 80], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousWithinAt_const", "code": "theorem upperSemicontinuousWithinAt_const : UpperSemicontinuousWithinAt (fun _x => z) s x", "start": [712, 1], "end": [713, 56], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousAt_const", "code": "theorem upperSemicontinuousAt_const : UpperSemicontinuousAt (fun _x => z) x", "start": [716, 1], "end": [717, 43], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousOn_const", "code": "theorem upperSemicontinuousOn_const : UpperSemicontinuousOn (fun _x => z) s", "start": [720, 1], "end": [721, 36], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuous_const", "code": "theorem upperSemicontinuous_const : UpperSemicontinuous fun _x : \u03b1 => z", "start": [724, 1], "end": [725, 30], "kind": "commanddeclaration"}, {"full_name": "IsOpen.upperSemicontinuous_indicator", "code": "theorem IsOpen.upperSemicontinuous_indicator (hs : IsOpen s) (hy : y \u2264 0) :\n    UpperSemicontinuous (indicator s fun _x => y)", "start": [735, 1], "end": [737, 62], "kind": "commanddeclaration"}, {"full_name": "IsOpen.upperSemicontinuousOn_indicator", "code": "theorem IsOpen.upperSemicontinuousOn_indicator (hs : IsOpen s) (hy : y \u2264 0) :\n    UpperSemicontinuousOn (indicator s fun _x => y) t", "start": [740, 1], "end": [742, 64], "kind": "commanddeclaration"}, {"full_name": "IsOpen.upperSemicontinuousAt_indicator", "code": "theorem IsOpen.upperSemicontinuousAt_indicator (hs : IsOpen s) (hy : y \u2264 0) :\n    UpperSemicontinuousAt (indicator s fun _x => y) x", "start": [745, 1], "end": [747, 64], "kind": "commanddeclaration"}, {"full_name": "IsOpen.upperSemicontinuousWithinAt_indicator", "code": "theorem IsOpen.upperSemicontinuousWithinAt_indicator (hs : IsOpen s) (hy : y \u2264 0) :\n    UpperSemicontinuousWithinAt (indicator s fun _x => y) t x", "start": [750, 1], "end": [752, 72], "kind": "commanddeclaration"}, {"full_name": "IsClosed.upperSemicontinuous_indicator", "code": "theorem IsClosed.upperSemicontinuous_indicator (hs : IsClosed s) (hy : 0 \u2264 y) :\n    UpperSemicontinuous (indicator s fun _x => y)", "start": [755, 1], "end": [757, 64], "kind": "commanddeclaration"}, {"full_name": "IsClosed.upperSemicontinuousOn_indicator", "code": "theorem IsClosed.upperSemicontinuousOn_indicator (hs : IsClosed s) (hy : 0 \u2264 y) :\n    UpperSemicontinuousOn (indicator s fun _x => y) t", "start": [760, 1], "end": [762, 64], "kind": "commanddeclaration"}, {"full_name": "IsClosed.upperSemicontinuousAt_indicator", "code": "theorem IsClosed.upperSemicontinuousAt_indicator (hs : IsClosed s) (hy : 0 \u2264 y) :\n    UpperSemicontinuousAt (indicator s fun _x => y) x", "start": [765, 1], "end": [767, 64], "kind": "commanddeclaration"}, {"full_name": "IsClosed.upperSemicontinuousWithinAt_indicator", "code": "theorem IsClosed.upperSemicontinuousWithinAt_indicator (hs : IsClosed s) (hy : 0 \u2264 y) :\n    UpperSemicontinuousWithinAt (indicator s fun _x => y) t x", "start": [770, 1], "end": [772, 72], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuous_iff_isOpen_preimage", "code": "theorem upperSemicontinuous_iff_isOpen_preimage :\n    UpperSemicontinuous f \u2194 \u2200 y, IsOpen (f \u207b\u00b9' Iio y)", "start": [780, 1], "end": [783, 32], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuous.isOpen_preimage", "code": "theorem UpperSemicontinuous.isOpen_preimage (hf : UpperSemicontinuous f) (y : \u03b2) :\n    IsOpen (f \u207b\u00b9' Iio y)", "start": [786, 1], "end": [788, 49], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuous_iff_isClosed_preimage", "code": "theorem upperSemicontinuous_iff_isClosed_preimage {f : \u03b1 \u2192 \u03b3} :\n    UpperSemicontinuous f \u2194 \u2200 y, IsClosed (f \u207b\u00b9' Ici y)", "start": [795, 1], "end": [798, 62], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuous.isClosed_preimage", "code": "theorem UpperSemicontinuous.isClosed_preimage {f : \u03b1 \u2192 \u03b3} (hf : UpperSemicontinuous f) (y : \u03b3) :\n    IsClosed (f \u207b\u00b9' Ici y)", "start": [801, 1], "end": [803, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.upperSemicontinuousWithinAt", "code": "theorem ContinuousWithinAt.upperSemicontinuousWithinAt {f : \u03b1 \u2192 \u03b3} (h : ContinuousWithinAt f s x) :\n    UpperSemicontinuousWithinAt f s x", "start": [808, 1], "end": [809, 74], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.upperSemicontinuousAt", "code": "theorem ContinuousAt.upperSemicontinuousAt {f : \u03b1 \u2192 \u03b3} (h : ContinuousAt f x) :\n    UpperSemicontinuousAt f x", "start": [812, 1], "end": [813, 66], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.upperSemicontinuousOn", "code": "theorem ContinuousOn.upperSemicontinuousOn {f : \u03b1 \u2192 \u03b3} (h : ContinuousOn f s) :\n    UpperSemicontinuousOn f s", "start": [816, 1], "end": [817, 82], "kind": "commanddeclaration"}, {"full_name": "Continuous.upperSemicontinuous", "code": "theorem Continuous.upperSemicontinuous {f : \u03b1 \u2192 \u03b3} (h : Continuous f) : UpperSemicontinuous f", "start": [820, 1], "end": [821, 49], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.comp_upperSemicontinuousWithinAt", "code": "theorem ContinuousAt.comp_upperSemicontinuousWithinAt {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3}\n    (hg : ContinuousAt g (f x)) (hf : UpperSemicontinuousWithinAt f s x) (gmon : Monotone g) :\n    UpperSemicontinuousWithinAt (g \u2218 f) s x", "start": [835, 1], "end": [838, 97], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.comp_upperSemicontinuousAt", "code": "theorem ContinuousAt.comp_upperSemicontinuousAt {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3} (hg : ContinuousAt g (f x))\n    (hf : UpperSemicontinuousAt f x) (gmon : Monotone g) : UpperSemicontinuousAt (g \u2218 f) x", "start": [841, 1], "end": [843, 89], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp_upperSemicontinuousOn", "code": "theorem Continuous.comp_upperSemicontinuousOn {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3} (hg : Continuous g)\n    (hf : UpperSemicontinuousOn f s) (gmon : Monotone g) : UpperSemicontinuousOn (g \u2218 f) s", "start": [846, 1], "end": [848, 78], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp_upperSemicontinuous", "code": "theorem Continuous.comp_upperSemicontinuous {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3} (hg : Continuous g)\n    (hf : UpperSemicontinuous f) (gmon : Monotone g) : UpperSemicontinuous (g \u2218 f)", "start": [851, 1], "end": [853, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.comp_upperSemicontinuousWithinAt_antitone", "code": "theorem ContinuousAt.comp_upperSemicontinuousWithinAt_antitone {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3}\n    (hg : ContinuousAt g (f x)) (hf : UpperSemicontinuousWithinAt f s x) (gmon : Antitone g) :\n    LowerSemicontinuousWithinAt (g \u2218 f) s x", "start": [856, 1], "end": [859, 90], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.comp_upperSemicontinuousAt_antitone", "code": "theorem ContinuousAt.comp_upperSemicontinuousAt_antitone {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3}\n    (hg : ContinuousAt g (f x)) (hf : UpperSemicontinuousAt f x) (gmon : Antitone g) :\n    LowerSemicontinuousAt (g \u2218 f) x", "start": [862, 1], "end": [865, 82], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp_upperSemicontinuousOn_antitone", "code": "theorem Continuous.comp_upperSemicontinuousOn_antitone {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3} (hg : Continuous g)\n    (hf : UpperSemicontinuousOn f s) (gmon : Antitone g) : LowerSemicontinuousOn (g \u2218 f) s", "start": [868, 1], "end": [870, 87], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp_upperSemicontinuous_antitone", "code": "theorem Continuous.comp_upperSemicontinuous_antitone {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3} (hg : Continuous g)\n    (hf : UpperSemicontinuous f) (gmon : Antitone g) : LowerSemicontinuous (g \u2218 f)", "start": [873, 1], "end": [875, 66], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuousWithinAt.add'", "code": "theorem UpperSemicontinuousWithinAt.add' {f g : \u03b1 \u2192 \u03b3} (hf : UpperSemicontinuousWithinAt f s x)\n    (hg : UpperSemicontinuousWithinAt g s x)\n    (hcont : ContinuousAt (fun p : \u03b3 \u00d7 \u03b3 => p.1 + p.2) (f x, g x)) :\n    UpperSemicontinuousWithinAt (fun z => f z + g z) s x", "start": [888, 1], "end": [895, 70], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuousAt.add'", "code": "theorem UpperSemicontinuousAt.add' {f g : \u03b1 \u2192 \u03b3} (hf : UpperSemicontinuousAt f x)\n    (hg : UpperSemicontinuousAt g x)\n    (hcont : ContinuousAt (fun p : \u03b3 \u00d7 \u03b3 => p.1 + p.2) (f x, g x)) :\n    UpperSemicontinuousAt (fun z => f z + g z) x", "start": [898, 1], "end": [906, 25], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuousOn.add'", "code": "theorem UpperSemicontinuousOn.add' {f g : \u03b1 \u2192 \u03b3} (hf : UpperSemicontinuousOn f s)\n    (hg : UpperSemicontinuousOn g s)\n    (hcont : \u2200 x \u2208 s, ContinuousAt (fun p : \u03b3 \u00d7 \u03b3 => p.1 + p.2) (f x, g x)) :\n    UpperSemicontinuousOn (fun z => f z + g z) s", "start": [909, 1], "end": [916, 40], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuous.add'", "code": "theorem UpperSemicontinuous.add' {f g : \u03b1 \u2192 \u03b3} (hf : UpperSemicontinuous f)\n    (hg : UpperSemicontinuous g)\n    (hcont : \u2200 x, ContinuousAt (fun p : \u03b3 \u00d7 \u03b3 => p.1 + p.2) (f x, g x)) :\n    UpperSemicontinuous fun z => f z + g z", "start": [919, 1], "end": [925, 84], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuousWithinAt.add", "code": "theorem UpperSemicontinuousWithinAt.add {f g : \u03b1 \u2192 \u03b3} (hf : UpperSemicontinuousWithinAt f s x)\n    (hg : UpperSemicontinuousWithinAt g s x) :\n    UpperSemicontinuousWithinAt (fun z => f z + g z) s x", "start": [930, 1], "end": [936, 41], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuousAt.add", "code": "theorem UpperSemicontinuousAt.add {f g : \u03b1 \u2192 \u03b3} (hf : UpperSemicontinuousAt f x)\n    (hg : UpperSemicontinuousAt g x) : UpperSemicontinuousAt (fun z => f z + g z) x", "start": [939, 1], "end": [944, 41], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuousOn.add", "code": "theorem UpperSemicontinuousOn.add {f g : \u03b1 \u2192 \u03b3} (hf : UpperSemicontinuousOn f s)\n    (hg : UpperSemicontinuousOn g s) : UpperSemicontinuousOn (fun z => f z + g z) s", "start": [947, 1], "end": [952, 55], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuous.add", "code": "theorem UpperSemicontinuous.add {f g : \u03b1 \u2192 \u03b3} (hf : UpperSemicontinuous f)\n    (hg : UpperSemicontinuous g) : UpperSemicontinuous fun z => f z + g z", "start": [955, 1], "end": [960, 51], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousWithinAt_sum", "code": "theorem upperSemicontinuousWithinAt_sum {f : \u03b9 \u2192 \u03b1 \u2192 \u03b3} {a : Finset \u03b9}\n    (ha : \u2200 i \u2208 a, UpperSemicontinuousWithinAt (f i) s x) :\n    UpperSemicontinuousWithinAt (fun z => \u2211 i in a, f i z) s x", "start": [963, 1], "end": [966, 64], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousAt_sum", "code": "theorem upperSemicontinuousAt_sum {f : \u03b9 \u2192 \u03b1 \u2192 \u03b3} {a : Finset \u03b9}\n    (ha : \u2200 i \u2208 a, UpperSemicontinuousAt (f i) x) :\n    UpperSemicontinuousAt (fun z => \u2211 i in a, f i z) x", "start": [969, 1], "end": [973, 43], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousOn_sum", "code": "theorem upperSemicontinuousOn_sum {f : \u03b9 \u2192 \u03b1 \u2192 \u03b3} {a : Finset \u03b9}\n    (ha : \u2200 i \u2208 a, UpperSemicontinuousOn (f i) s) :\n    UpperSemicontinuousOn (fun z => \u2211 i in a, f i z) s", "start": [976, 1], "end": [979, 59], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuous_sum", "code": "theorem upperSemicontinuous_sum {f : \u03b9 \u2192 \u03b1 \u2192 \u03b3} {a : Finset \u03b9}\n    (ha : \u2200 i \u2208 a, UpperSemicontinuous (f i)) : UpperSemicontinuous fun z => \u2211 i in a, f i z", "start": [982, 1], "end": [984, 59], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousWithinAt_ciInf", "code": "theorem upperSemicontinuousWithinAt_ciInf {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4'}\n    (bdd : \u2200\u1da0 y in \ud835\udcdd[s] x, BddBelow (range fun i => f i y))\n    (h : \u2200 i, UpperSemicontinuousWithinAt (f i) s x) :\n    UpperSemicontinuousWithinAt (fun x' => \u2a05 i, f i x') s x", "start": [996, 1], "end": [1000, 62], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousWithinAt_iInf", "code": "theorem upperSemicontinuousWithinAt_iInf {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4}\n    (h : \u2200 i, UpperSemicontinuousWithinAt (f i) s x) :\n    UpperSemicontinuousWithinAt (fun x' => \u2a05 i, f i x') s x", "start": [1003, 1], "end": [1006, 56], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousWithinAt_biInf", "code": "theorem upperSemicontinuousWithinAt_biInf {p : \u03b9 \u2192 Prop} {f : \u2200 (i) (_h : p i), \u03b1 \u2192 \u03b4}\n    (h : \u2200 i hi, UpperSemicontinuousWithinAt (f i hi) s x) :\n    UpperSemicontinuousWithinAt (fun x' => \u2a05 (i) (hi), f i hi x') s x", "start": [1009, 1], "end": [1012, 94], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousAt_ciInf", "code": "theorem upperSemicontinuousAt_ciInf {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4'}\n    (bdd : \u2200\u1da0 y in \ud835\udcdd x, BddBelow (range fun i => f i y)) (h : \u2200 i, UpperSemicontinuousAt (f i) x) :\n    UpperSemicontinuousAt (fun x' => \u2a05 i, f i x') x", "start": [1015, 1], "end": [1018, 54], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousAt_iInf", "code": "theorem upperSemicontinuousAt_iInf {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4} (h : \u2200 i, UpperSemicontinuousAt (f i) x) :\n    UpperSemicontinuousAt (fun x' => \u2a05 i, f i x') x", "start": [1021, 1], "end": [1023, 48], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousAt_biInf", "code": "theorem upperSemicontinuousAt_biInf {p : \u03b9 \u2192 Prop} {f : \u2200 (i) (_h : p i), \u03b1 \u2192 \u03b4}\n    (h : \u2200 i hi, UpperSemicontinuousAt (f i hi) x) :\n    UpperSemicontinuousAt (fun x' => \u2a05 (i) (hi), f i hi x') x", "start": [1026, 1], "end": [1029, 82], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousOn_ciInf", "code": "theorem upperSemicontinuousOn_ciInf {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4'}\n    (bdd : \u2200 x \u2208 s, BddBelow (range fun i => f i x)) (h : \u2200 i, UpperSemicontinuousOn (f i) s) :\n    UpperSemicontinuousOn (fun x' => \u2a05 i, f i x') s", "start": [1032, 1], "end": [1035, 92], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousOn_iInf", "code": "theorem upperSemicontinuousOn_iInf {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4} (h : \u2200 i, UpperSemicontinuousOn (f i) s) :\n    UpperSemicontinuousOn (fun x' => \u2a05 i, f i x') s", "start": [1038, 1], "end": [1040, 53], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuousOn_biInf", "code": "theorem upperSemicontinuousOn_biInf {p : \u03b9 \u2192 Prop} {f : \u2200 (i) (_h : p i), \u03b1 \u2192 \u03b4}\n    (h : \u2200 i hi, UpperSemicontinuousOn (f i hi) s) :\n    UpperSemicontinuousOn (fun x' => \u2a05 (i) (hi), f i hi x') s", "start": [1043, 1], "end": [1046, 82], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuous_ciInf", "code": "theorem upperSemicontinuous_ciInf {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4'} (bdd : \u2200 x, BddBelow (range fun i => f i x))\n    (h : \u2200 i, UpperSemicontinuous (f i)) : UpperSemicontinuous fun x' => \u2a05 i, f i x'", "start": [1049, 1], "end": [1051, 72], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuous_iInf", "code": "theorem upperSemicontinuous_iInf {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4} (h : \u2200 i, UpperSemicontinuous (f i)) :\n    UpperSemicontinuous fun x' => \u2a05 i, f i x'", "start": [1054, 1], "end": [1055, 100], "kind": "commanddeclaration"}, {"full_name": "upperSemicontinuous_biInf", "code": "theorem upperSemicontinuous_biInf {p : \u03b9 \u2192 Prop} {f : \u2200 (i) (_h : p i), \u03b1 \u2192 \u03b4}\n    (h : \u2200 i hi, UpperSemicontinuous (f i hi)) :\n    UpperSemicontinuous fun x' => \u2a05 (i) (hi), f i hi x'", "start": [1058, 1], "end": [1061, 78], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_iff_lower_upperSemicontinuousWithinAt", "code": "theorem continuousWithinAt_iff_lower_upperSemicontinuousWithinAt {f : \u03b1 \u2192 \u03b3} :\n    ContinuousWithinAt f s x \u2194\n      LowerSemicontinuousWithinAt f s x \u2227 UpperSemicontinuousWithinAt f s x", "start": [1070, 1], "end": [1098, 31], "kind": "commanddeclaration"}, {"full_name": "continuousAt_iff_lower_upperSemicontinuousAt", "code": "theorem continuousAt_iff_lower_upperSemicontinuousAt {f : \u03b1 \u2192 \u03b3} :\n    ContinuousAt f x \u2194 LowerSemicontinuousAt f x \u2227 UpperSemicontinuousAt f x", "start": [1101, 1], "end": [1104, 100], "kind": "commanddeclaration"}, {"full_name": "continuousOn_iff_lower_upperSemicontinuousOn", "code": "theorem continuousOn_iff_lower_upperSemicontinuousOn {f : \u03b1 \u2192 \u03b3} :\n    ContinuousOn f s \u2194 LowerSemicontinuousOn f s \u2227 UpperSemicontinuousOn f s", "start": [1107, 1], "end": [1111, 100], "kind": "commanddeclaration"}, {"full_name": "continuous_iff_lower_upperSemicontinuous", "code": "theorem continuous_iff_lower_upperSemicontinuous {f : \u03b1 \u2192 \u03b3} :\n    Continuous f \u2194 LowerSemicontinuous f \u2227 UpperSemicontinuous f", "start": [1114, 1], "end": [1117, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/MutuallySingular.lean", "imports": ["Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.Measure.MutuallySingular", "code": "def MutuallySingular {_ : MeasurableSpace \u03b1} (\u03bc \u03bd : Measure \u03b1) : Prop :=\n  \u2203 s : Set \u03b1, MeasurableSet s \u2227 \u03bc s = 0 \u2227 \u03bd s\u1d9c = 0", "start": [37, 1], "end": [40, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.mk", "code": "theorem mk {s t : Set \u03b1} (hs : \u03bc s = 0) (ht : \u03bd t = 0) (hst : univ \u2286 s \u222a t) :\n    MutuallySingular \u03bc \u03bd", "start": [49, 1], "end": [53, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.zero_right", "code": "@[simp]\ntheorem zero_right : \u03bc \u27c2\u2098 0", "start": [56, 1], "end": [58, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.symm", "code": "@[symm]\ntheorem symm (h : \u03bd \u27c2\u2098 \u03bc) : \u03bc \u27c2\u2098 \u03bd", "start": [61, 1], "end": [64, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.comm", "code": "theorem comm : \u03bc \u27c2\u2098 \u03bd \u2194 \u03bd \u27c2\u2098 \u03bc", "start": [67, 1], "end": [68, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.zero_left", "code": "@[simp]\ntheorem zero_left : 0 \u27c2\u2098 \u03bc", "start": [71, 1], "end": [73, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.mono_ac", "code": "theorem mono_ac (h : \u03bc\u2081 \u27c2\u2098 \u03bd\u2081) (h\u03bc : \u03bc\u2082 \u226a \u03bc\u2081) (h\u03bd : \u03bd\u2082 \u226a \u03bd\u2081) : \u03bc\u2082 \u27c2\u2098 \u03bd\u2082", "start": [76, 1], "end": [78, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.mono", "code": "theorem mono (h : \u03bc\u2081 \u27c2\u2098 \u03bd\u2081) (h\u03bc : \u03bc\u2082 \u2264 \u03bc\u2081) (h\u03bd : \u03bd\u2082 \u2264 \u03bd\u2081) : \u03bc\u2082 \u27c2\u2098 \u03bd\u2082", "start": [81, 1], "end": [82, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.sum_left", "code": "@[simp]\ntheorem sum_left {\u03b9 : Type*} [Countable \u03b9] {\u03bc : \u03b9 \u2192 Measure \u03b1} : sum \u03bc \u27c2\u2098 \u03bd \u2194 \u2200 i, \u03bc i \u27c2\u2098 \u03bd", "start": [85, 1], "end": [92, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.sum_right", "code": "@[simp]\ntheorem sum_right {\u03b9 : Type*} [Countable \u03b9] {\u03bd : \u03b9 \u2192 Measure \u03b1} : \u03bc \u27c2\u2098 sum \u03bd \u2194 \u2200 i, \u03bc \u27c2\u2098 \u03bd i", "start": [95, 1], "end": [97, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.add_left_iff", "code": "@[simp]\ntheorem add_left_iff : \u03bc\u2081 + \u03bc\u2082 \u27c2\u2098 \u03bd \u2194 \u03bc\u2081 \u27c2\u2098 \u03bd \u2227 \u03bc\u2082 \u27c2\u2098 \u03bd", "start": [100, 1], "end": [102, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.add_right_iff", "code": "@[simp]\ntheorem add_right_iff : \u03bc \u27c2\u2098 \u03bd\u2081 + \u03bd\u2082 \u2194 \u03bc \u27c2\u2098 \u03bd\u2081 \u2227 \u03bc \u27c2\u2098 \u03bd\u2082", "start": [105, 1], "end": [107, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.add_left", "code": "theorem add_left (h\u2081 : \u03bd\u2081 \u27c2\u2098 \u03bc) (h\u2082 : \u03bd\u2082 \u27c2\u2098 \u03bc) : \u03bd\u2081 + \u03bd\u2082 \u27c2\u2098 \u03bc", "start": [110, 1], "end": [111, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.add_right", "code": "theorem add_right (h\u2081 : \u03bc \u27c2\u2098 \u03bd\u2081) (h\u2082 : \u03bc \u27c2\u2098 \u03bd\u2082) : \u03bc \u27c2\u2098 \u03bd\u2081 + \u03bd\u2082", "start": [114, 1], "end": [115, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.smul", "code": "theorem smul (r : \u211d\u22650\u221e) (h : \u03bd \u27c2\u2098 \u03bc) : r \u2022 \u03bd \u27c2\u2098 \u03bc", "start": [118, 1], "end": [119, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MutuallySingular.smul_nnreal", "code": "theorem smul_nnreal (r : \u211d\u22650) (h : \u03bd \u27c2\u2098 \u03bc) : r \u2022 \u03bd \u27c2\u2098 \u03bc", "start": [122, 1], "end": [123, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/AffineSpace/MidpointZero.lean", "imports": ["Mathlib/Algebra/CharP/Invertible.lean", "Mathlib/LinearAlgebra/AffineSpace/Midpoint.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "lineMap_inv_two", "code": "theorem lineMap_inv_two {R : Type*} {V P : Type*} [DivisionRing R] [CharZero R] [AddCommGroup V]\n    [Module R V] [AddTorsor V P] (a b : P) : lineMap a b (2\u207b\u00b9 : R) = midpoint R a b", "start": [24, 1], "end": [26, 6], "kind": "commanddeclaration"}, {"full_name": "lineMap_one_half", "code": "theorem lineMap_one_half {R : Type*} {V P : Type*} [DivisionRing R] [CharZero R] [AddCommGroup V]\n    [Module R V] [AddTorsor V P] (a b : P) : lineMap a b (1 / 2 : R) = midpoint R a b", "start": [29, 1], "end": [31, 32], "kind": "commanddeclaration"}, {"full_name": "homothety_invOf_two", "code": "theorem homothety_invOf_two {R : Type*} {V P : Type*} [CommRing R] [Invertible (2 : R)]\n    [AddCommGroup V] [Module R V] [AddTorsor V P] (a b : P) :\n    homothety a (\u215f 2 : R) b = midpoint R a b", "start": [34, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "homothety_inv_two", "code": "theorem homothety_inv_two {k : Type*} {V P : Type*} [Field k] [CharZero k] [AddCommGroup V]\n    [Module k V] [AddTorsor V P] (a b : P) : homothety a (2\u207b\u00b9 : k) b = midpoint k a b", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "homothety_one_half", "code": "theorem homothety_one_half {k : Type*} {V P : Type*} [Field k] [CharZero k] [AddCommGroup V]\n    [Module k V] [AddTorsor V P] (a b : P) : homothety a (1 / 2 : k) b = midpoint k a b", "start": [45, 1], "end": [47, 34], "kind": "commanddeclaration"}, {"full_name": "pi_midpoint_apply", "code": "@[simp]\ntheorem pi_midpoint_apply {k \u03b9 : Type*} {V : \u2200 _ : \u03b9, Type*} {P : \u2200 _ : \u03b9, Type*} [Field k]\n    [Invertible (2 : k)] [\u2200 i, AddCommGroup (V i)] [\u2200 i, Module k (V i)]\n    [\u2200 i, AddTorsor (V i) (P i)] (f g : \u2200 i, P i) (i : \u03b9) :\n    midpoint k f g i = midpoint k (f i) (g i)", "start": [50, 1], "end": [55, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/AffineSpace/Slope.lean", "imports": ["Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "Mathlib/Tactic/FieldSimp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "slope", "code": "def slope (f : k \u2192 PE) (a b : k) : E :=\n  (b - a)\u207b\u00b9 \u2022 (f b -\u1d65 f a)", "start": [28, 1], "end": [31, 27], "kind": "commanddeclaration"}, {"full_name": "slope_fun_def", "code": "theorem slope_fun_def (f : k \u2192 PE) : slope f = fun a b => (b - a)\u207b\u00b9 \u2022 (f b -\u1d65 f a)", "start": [34, 1], "end": [35, 6], "kind": "commanddeclaration"}, {"full_name": "slope_def_field", "code": "theorem slope_def_field (f : k \u2192 k) (a b : k) : slope f a b = (f b - f a) / (b - a)", "start": [38, 1], "end": [39, 28], "kind": "commanddeclaration"}, {"full_name": "slope_fun_def_field", "code": "theorem slope_fun_def_field (f : k \u2192 k) (a : k) : slope f a = fun b => (f b - f a) / (b - a)", "start": [42, 1], "end": [43, 28], "kind": "commanddeclaration"}, {"full_name": "slope_same", "code": "@[simp]\ntheorem slope_same (f : k \u2192 PE) (a : k) : (slope f a a : E) = 0", "start": [46, 1], "end": [48, 44], "kind": "commanddeclaration"}, {"full_name": "slope_def_module", "code": "theorem slope_def_module (f : k \u2192 E) (a b : k) : slope f a b = (b - a)\u207b\u00b9 \u2022 (f b - f a)", "start": [51, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "sub_smul_slope", "code": "@[simp]\ntheorem sub_smul_slope (f : k \u2192 PE) (a b : k) : (b - a) \u2022 slope f a b = f b -\u1d65 f a", "start": [55, 1], "end": [59, 56], "kind": "commanddeclaration"}, {"full_name": "sub_smul_slope_vadd", "code": "theorem sub_smul_slope_vadd (f : k \u2192 PE) (a b : k) : (b - a) \u2022 slope f a b +\u1d65 f a = f b", "start": [62, 1], "end": [63, 33], "kind": "commanddeclaration"}, {"full_name": "slope_vadd_const", "code": "@[simp]\ntheorem slope_vadd_const (f : k \u2192 E) (c : PE) : (slope fun x => f x +\u1d65 c) = slope f", "start": [66, 1], "end": [69, 62], "kind": "commanddeclaration"}, {"full_name": "slope_sub_smul", "code": "@[simp]\ntheorem slope_sub_smul (f : k \u2192 E) {a b : k} (h : a \u2260 b) :\n    slope (fun x => (x - a) \u2022 f x) a b = f b", "start": [72, 1], "end": [75, 54], "kind": "commanddeclaration"}, {"full_name": "eq_of_slope_eq_zero", "code": "theorem eq_of_slope_eq_zero {f : k \u2192 PE} {a b : k} (h : slope f a b = (0 : E)) : f a = f b", "start": [78, 1], "end": [79, 60], "kind": "commanddeclaration"}, {"full_name": "AffineMap.slope_comp", "code": "theorem AffineMap.slope_comp {F PF : Type*} [AddCommGroup F] [Module k F] [AddTorsor F PF]\n    (f : PE \u2192\u1d43[k] PF) (g : k \u2192 PE) (a b : k) : slope (f \u2218 g) a b = f.linear (slope g a b)", "start": [82, 1], "end": [84, 66], "kind": "commanddeclaration"}, {"full_name": "LinearMap.slope_comp", "code": "theorem LinearMap.slope_comp {F : Type*} [AddCommGroup F] [Module k F] (f : E \u2192\u2097[k] F) (g : k \u2192 E)\n    (a b : k) : slope (f \u2218 g) a b = f (slope g a b)", "start": [87, 1], "end": [89, 33], "kind": "commanddeclaration"}, {"full_name": "slope_comm", "code": "theorem slope_comm (f : k \u2192 PE) (a b : k) : slope f a b = slope f b a", "start": [92, 1], "end": [93, 84], "kind": "commanddeclaration"}, {"full_name": "sub_div_sub_smul_slope_add_sub_div_sub_smul_slope", "code": "theorem sub_div_sub_smul_slope_add_sub_div_sub_smul_slope (f : k \u2192 PE) (a b c : k) :\n    ((b - a) / (c - a)) \u2022 slope f a b + ((c - b) / (c - a)) \u2022 slope f b c = slope f a c", "start": [96, 1], "end": [113, 26], "kind": "commanddeclaration"}, {"full_name": "lineMap_slope_slope_sub_div_sub", "code": "theorem lineMap_slope_slope_sub_div_sub (f : k \u2192 PE) (a b c : k) (h : a \u2260 c) :\n    lineMap (slope f a b) (slope f b c) ((c - b) / (c - a)) = slope f a c", "start": [116, 1], "end": [121, 26], "kind": "commanddeclaration"}, {"full_name": "lineMap_slope_lineMap_slope_lineMap", "code": "theorem lineMap_slope_lineMap_slope_lineMap (f : k \u2192 PE) (a b r : k) :\n    lineMap (slope f (lineMap a b r) b) (slope f a (lineMap a b r)) r = slope f a b", "start": [124, 1], "end": [132, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/LatticeGroup.lean", "imports": ["Mathlib/Algebra/Module/Basic.lean", "Mathlib/Algebra/Order/Group/Abs.lean", "Mathlib/Order/Closure.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "mul_sup", "code": "@[to_additive]\ntheorem mul_sup [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b c : \u03b1) : c * (a \u2294 b) = c * a \u2294 c * b", "start": [76, 1], "end": [78, 35], "kind": "commanddeclaration"}, {"full_name": "sup_mul", "code": "@[to_additive]\ntheorem sup_mul [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (a b c : \u03b1) :\n    (a \u2294 b) * c = a * c \u2294 b * c", "start": [82, 1], "end": [85, 36], "kind": "commanddeclaration"}, {"full_name": "mul_inf", "code": "@[to_additive]\ntheorem mul_inf [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b c : \u03b1) : c * (a \u2293 b) = c * a \u2293 c * b", "start": [89, 1], "end": [91, 35], "kind": "commanddeclaration"}, {"full_name": "inf_mul", "code": "@[to_additive]\ntheorem inf_mul [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (a b c : \u03b1) :\n    (a \u2293 b) * c = a * c \u2293 b * c", "start": [95, 1], "end": [98, 36], "kind": "commanddeclaration"}, {"full_name": "inv_sup_eq_inv_inf_inv", "code": "@[to_additive]\ntheorem inv_sup_eq_inv_inf_inv\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (a b : \u03b1) :\n    (a \u2294 b)\u207b\u00b9 = a\u207b\u00b9 \u2293 b\u207b\u00b9", "start": [104, 1], "end": [108, 31], "kind": "commanddeclaration"}, {"full_name": "inv_inf_eq_sup_inv", "code": "@[to_additive]\ntheorem inv_inf_eq_sup_inv\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (a b : \u03b1) :\n    (a \u2293 b)\u207b\u00b9 = a\u207b\u00b9 \u2294 b\u207b\u00b9", "start": [113, 1], "end": [117, 31], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.hasOneLatticeHasPosPart", "code": "@[to_additive\n      \"Let `\u03b1` be a lattice ordered commutative group with identity `0`. For an element `a` of type\n      `\u03b1`,the element `a \u2294 0` is said to be the *positive component* of `a`, denoted `a\u207a`.\"]\ninstance (priority := 100) hasOneLatticeHasPosPart : PosPart \u03b1 :=\n  \u27e8fun a => a \u2294 1\u27e9", "start": [124, 1], "end": [132, 19], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.m_pos_part_def", "code": "@[to_additive pos_part_def]\ntheorem m_pos_part_def (a : \u03b1) : a\u207a = a \u2294 1", "start": [136, 1], "end": [138, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.hasOneLatticeHasNegPart", "code": "@[to_additive\n      \"Let `\u03b1` be a lattice ordered commutative group with identity `0`. For an element `a` of type\n      `\u03b1`, the element `(-a) \u2294 0` is said to be the *negative component* of `a`, denoted `a\u207b`.\"]\ninstance (priority := 100) hasOneLatticeHasNegPart : NegPart \u03b1 :=\n  \u27e8fun a => a\u207b\u00b9 \u2294 1\u27e9", "start": [143, 1], "end": [151, 21], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.m_neg_part_def", "code": "@[to_additive neg_part_def]\ntheorem m_neg_part_def (a : \u03b1) : a\u207b = a\u207b\u00b9 \u2294 1", "start": [155, 1], "end": [157, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.pos_one", "code": "@[to_additive (attr := simp)]\ntheorem pos_one : (1 : \u03b1)\u207a = 1", "start": [161, 1], "end": [163, 11], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.neg_one", "code": "@[to_additive (attr := simp)]\ntheorem neg_one : (1 : \u03b1)\u207b = 1", "start": [167, 1], "end": [168, 76], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.neg_eq_inv_inf_one", "code": "@[to_additive]\ntheorem neg_eq_inv_inf_one\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (a : \u03b1) :\n    a\u207b = (a \u2293 1)\u207b\u00b9", "start": [173, 1], "end": [177, 84], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.le_mabs", "code": "@[to_additive le_abs]\ntheorem le_mabs (a : \u03b1) : a \u2264 |a|", "start": [181, 1], "end": [183, 14], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.inv_le_abs", "code": "@[to_additive]\ntheorem inv_le_abs (a : \u03b1) : a\u207b\u00b9 \u2264 |a|", "start": [188, 1], "end": [190, 15], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.abs_inv", "code": "@[to_additive (attr := simp)]\ntheorem abs_inv (a : \u03b1) : |a\u207b\u00b9| = |a|", "start": [194, 1], "end": [197, 43], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.one_le_pos", "code": "@[to_additive pos_nonneg]\ntheorem one_le_pos (a : \u03b1) : 1 \u2264 a\u207a", "start": [200, 1], "end": [202, 15], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.one_le_neg", "code": "@[to_additive neg_nonneg]\ntheorem one_le_neg (a : \u03b1) : 1 \u2264 a\u207b", "start": [207, 1], "end": [209, 15], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.pos_le_one_iff", "code": "@[to_additive]\ntheorem pos_le_one_iff {a : \u03b1} : a\u207a \u2264 1 \u2194 a \u2264 1", "start": [214, 1], "end": [216, 55], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.neg_le_one_iff", "code": "@[to_additive]\ntheorem neg_le_one_iff {a : \u03b1} : a\u207b \u2264 1 \u2194 a\u207b\u00b9 \u2264 1", "start": [221, 1], "end": [223, 55], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.pos_eq_one_iff", "code": "@[to_additive]\ntheorem pos_eq_one_iff {a : \u03b1} : a\u207a = 1 \u2194 a \u2264 1", "start": [227, 1], "end": [229, 15], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.neg_eq_one_iff'", "code": "@[to_additive]\ntheorem neg_eq_one_iff' {a : \u03b1} : a\u207b = 1 \u2194 a\u207b\u00b9 \u2264 1", "start": [233, 1], "end": [235, 15], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.neg_eq_one_iff", "code": "@[to_additive]\ntheorem neg_eq_one_iff [CovariantClass \u03b1 \u03b1 Mul.mul LE.le] {a : \u03b1} : a\u207b = 1 \u2194 1 \u2264 a", "start": [239, 1], "end": [241, 81], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.m_le_pos", "code": "@[to_additive le_pos]\ntheorem m_le_pos (a : \u03b1) : a \u2264 a\u207a", "start": [245, 1], "end": [247, 14], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.inv_le_neg", "code": "@[to_additive]\ntheorem inv_le_neg (a : \u03b1) : a\u207b\u00b9 \u2264 a\u207b", "start": [252, 1], "end": [254, 14], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.neg_eq_pos_inv", "code": "@[to_additive]\ntheorem neg_eq_pos_inv (a : \u03b1) : a\u207b = a\u207b\u00b9\u207a", "start": [260, 1], "end": [262, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.pos_eq_neg_inv", "code": "@[to_additive]\ntheorem pos_eq_neg_inv (a : \u03b1) : a\u207a = a\u207b\u00b9\u207b", "start": [267, 1], "end": [268, 78], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.mul_inf_eq_mul_inf_mul", "code": "@[to_additive]\ntheorem mul_inf_eq_mul_inf_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b c : \u03b1) :\n    c * (a \u2293 b) = c * a \u2293 c * b", "start": [274, 1], "end": [282, 7], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.pos_div_neg", "code": "@[to_additive (attr := simp)]\ntheorem pos_div_neg [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a : \u03b1) : a\u207a / a\u207b = a", "start": [288, 1], "end": [293, 81], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.pos_of_one_le", "code": "@[to_additive \"If `a` is positive, then it is equal to its positive component `a\u207a`.\"]\ntheorem pos_of_one_le (a : \u03b1) (h : 1 \u2264 a) : a\u207a = a", "start": [298, 1], "end": [302, 25], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.pos_of_le_one", "code": "@[to_additive]\ntheorem pos_of_le_one (a : \u03b1) (h : a \u2264 1) : a\u207a = 1", "start": [308, 1], "end": [310, 23], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.neg_of_one_le_inv", "code": "@[to_additive neg_of_inv_nonneg]\ntheorem neg_of_one_le_inv (a : \u03b1) (h : 1 \u2264 a\u207b\u00b9) : a\u207b = a\u207b\u00b9", "start": [314, 1], "end": [317, 26], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.neg_of_inv_le_one", "code": "@[to_additive]\ntheorem neg_of_inv_le_one (a : \u03b1) (h : a\u207b\u00b9 \u2264 1) : a\u207b = 1", "start": [322, 1], "end": [324, 24], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.neg_of_le_one", "code": "@[to_additive]\ntheorem neg_of_le_one [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a : \u03b1) (h : a \u2264 1) : a\u207b = a\u207b\u00b9", "start": [329, 1], "end": [331, 35], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.pos_eq_self_of_one_lt_pos", "code": "@[to_additive]\ntheorem pos_eq_self_of_one_lt_pos {\u03b1} [LinearOrder \u03b1] [CommGroup \u03b1] {x : \u03b1} (hx : 1 < x\u207a) :\n    x\u207a = x", "start": [336, 1], "end": [341, 14], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.neg_of_one_le", "code": "@[to_additive]\ntheorem neg_of_one_le [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a : \u03b1) (h : 1 \u2264 a) : a\u207b = 1", "start": [346, 1], "end": [348, 23], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.mabs_of_one_le", "code": "@[to_additive abs_of_nonneg]\ntheorem mabs_of_one_le [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a : \u03b1) (h : 1 \u2264 a) : |a| = a", "start": [353, 1], "end": [355, 38], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.abs_div_comm", "code": "@[to_additive]\ntheorem abs_div_comm (a b : \u03b1) : |a / b| = |b / a|", "start": [360, 1], "end": [363, 57], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.pow_two_semiclosed", "code": "@[to_additive]\nlemma pow_two_semiclosed\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (a : \u03b1) :\n    (1 : \u03b1) \u2264 a^2 \u2192 1 \u2264 a := by\n  intro h\n  have e1 : (a \u2293 1) * (a \u2293 1) = a\u22931 := by\n    rw [mul_inf, inf_mul, \u2190 pow_two, mul_one, one_mul, inf_assoc, inf_left_idem, inf_comm,\n     inf_assoc, (inf_of_le_left h)]\n  rw [\u2190 inf_eq_right]\n  exact mul_right_eq_self.mp e1", "start": [369, 1], "end": [378, 32], "kind": "mathlibtacticlemma"}, {"full_name": "LatticeOrderedGroup.one_le_abs", "code": "@[to_additive abs_nonneg]\ntheorem one_le_abs\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (a : \u03b1) :\n    1 \u2264 |a|", "start": [380, 1], "end": [386, 21], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.pos_mul_neg", "code": "@[to_additive]\ntheorem pos_mul_neg\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (a : \u03b1) :\n    |a| = a\u207a * a\u207b", "start": [390, 1], "end": [396, 45], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.m_pos_abs", "code": "@[to_additive pos_abs]\ntheorem m_pos_abs [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)]\n    (a : \u03b1) : |a|\u207a = |a|", "start": [400, 1], "end": [405, 19], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.m_neg_abs", "code": "@[to_additive neg_abs]\ntheorem m_neg_abs [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)]\n    (a : \u03b1) : |a|\u207b = 1", "start": [409, 1], "end": [415, 19], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.sup_div_inf_eq_abs_div", "code": "@[to_additive]\ntheorem sup_div_inf_eq_abs_div\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (a b : \u03b1) :\n    (a \u2294 b) / (a \u2293 b) = |b / a|", "start": [420, 1], "end": [435, 52], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.mabs_mabs", "code": "@[to_additive (attr := simp) abs_abs\n  \"The unary operation of taking the absolute value is idempotent.\"]\ntheorem mabs_mabs [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)]\n    (a : \u03b1) : |(|a|)| = |a|", "start": [439, 1], "end": [444, 34], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedGroup.pos_inf_neg_eq_one", "code": "@[to_additive]\ntheorem pos_inf_neg_eq_one\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (a : \u03b1) :\n    a\u207a \u2293 a\u207b = 1", "start": [450, 1], "end": [455, 46], "kind": "commanddeclaration"}, {"full_name": "inf_mul_sup", "code": "@[to_additive]\ntheorem inf_mul_sup [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b : \u03b1) : (a \u2293 b) * (a \u2294 b) = a * b", "start": [468, 1], "end": [474, 56], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedCommGroup.sup_eq_mul_pos_div", "code": "@[to_additive]\ntheorem sup_eq_mul_pos_div [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b : \u03b1) : a \u2294 b = b * (a / b)\u207a", "start": [484, 1], "end": [489, 57], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedCommGroup.inf_eq_div_pos_div", "code": "@[to_additive]\ntheorem inf_eq_div_pos_div [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b : \u03b1) : a \u2293 b = a / (a / b)\u207a", "start": [495, 1], "end": [507, 78], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedCommGroup.m_le_iff_pos_le_neg_ge", "code": "@[to_additive le_iff_pos_le_neg_ge]\ntheorem m_le_iff_pos_le_neg_ge [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b : \u03b1) :\n    a \u2264 b \u2194 a\u207a \u2264 b\u207a \u2227 b\u207b \u2264 a\u207b", "start": [512, 1], "end": [521, 31], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedCommGroup.sup_sq_eq_mul_mul_abs_div", "code": "@[to_additive two_sup_eq_add_add_abs_sub]\ntheorem sup_sq_eq_mul_mul_abs_div [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b : \u03b1) :\n    (a \u2294 b) ^ 2 = a * b * |b / a|", "start": [526, 1], "end": [530, 36], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedCommGroup.inf_sq_eq_mul_div_abs_div", "code": "@[to_additive two_inf_eq_add_sub_abs_sub]\ntheorem inf_sq_eq_mul_div_abs_div [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b : \u03b1) :\n    (a \u2293 b) ^ 2 = a * b / |b / a|", "start": [535, 1], "end": [539, 62], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedCommGroup.latticeOrderedCommGroupToDistribLattice", "code": "@[to_additive \"Every lattice ordered commutative additive group is a distributive lattice\"]\ndef latticeOrderedCommGroupToDistribLattice (\u03b1 : Type u) [s : Lattice \u03b1] [CommGroup \u03b1]\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] : DistribLattice \u03b1 :=\n  { s with\n    le_sup_inf := by\n      intros x y z\n      rw [\u2190 mul_le_mul_iff_left (x \u2293 (y \u2293 z)), inf_mul_sup x (y \u2293 z), \u2190 inv_mul_le_iff_le_mul,\n        le_inf_iff]\n      constructor\n      \u00b7 rw [inv_mul_le_iff_le_mul, \u2190 inf_mul_sup x y]\n        apply mul_le_mul'\n        \u00b7 apply inf_le_inf_left\n          apply inf_le_left\n        \u00b7 apply inf_le_left\n      \u00b7 rw [inv_mul_le_iff_le_mul, \u2190 inf_mul_sup x z]\n        apply mul_le_mul'\n        \u00b7 apply inf_le_inf_left\n          apply inf_le_right\n        \u00b7 apply inf_le_right }", "start": [543, 1], "end": [564, 31], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedCommGroup.abs_div_sup_mul_abs_div_inf", "code": "@[to_additive]\ntheorem abs_div_sup_mul_abs_div_inf [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b c : \u03b1) :\n    |(a \u2294 c) / (b \u2294 c)| * |(a \u2293 c) / (b \u2293 c)| = |a / b|", "start": [571, 1], "end": [589, 50], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedCommGroup.mabs_sup_div_sup_le_mabs", "code": "@[to_additive abs_sup_sub_sup_le_abs]\ntheorem mabs_sup_div_sup_le_mabs [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b c : \u03b1) :\n    |(a \u2294 c) / (b \u2294 c)| \u2264 |a / b|", "start": [593, 1], "end": [598, 23], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedCommGroup.mabs_inf_div_inf_le_mabs", "code": "@[to_additive abs_inf_sub_inf_le_abs]\ntheorem mabs_inf_div_inf_le_mabs [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b c : \u03b1) :\n    |(a \u2293 c) / (b \u2293 c)| \u2264 |a / b|", "start": [602, 1], "end": [607, 23], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedCommGroup.m_Birkhoff_inequalities", "code": "@[to_additive Birkhoff_inequalities]\ntheorem m_Birkhoff_inequalities [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b c : \u03b1) :\n    |(a \u2294 c) / (b \u2294 c)| \u2294 |(a \u2293 c) / (b \u2293 c)| \u2264 |a / b|", "start": [614, 1], "end": [617, 75], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedCommGroup.mabs_mul_le", "code": "@[to_additive abs_add_le \"The absolute value satisfies the triangle inequality.\"]\ntheorem mabs_mul_le [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b : \u03b1) : |a * b| \u2264 |a| * |b|", "start": [624, 1], "end": [631, 52], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedCommGroup.abs_abs_div_abs_le", "code": "@[to_additive]\ntheorem abs_abs_div_abs_le [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b : \u03b1) :\n    |(|a| / |b|)| \u2264 |a / b|", "start": [636, 1], "end": [646, 27], "kind": "commanddeclaration"}, {"full_name": "inf_eq_half_smul_add_sub_abs_sub", "code": "lemma inf_eq_half_smul_add_sub_abs_sub (x y : \u03b2) :\n    x \u2293 y = (\u215f2 : \u03b1) \u2022 (x + y - |y - x|) := by\n  rw [\u2190LatticeOrderedCommGroup.two_inf_eq_add_sub_abs_sub x y, two_smul, \u2190two_smul \u03b1,\n    smul_smul, invOf_mul_self, one_smul]", "start": [658, 1], "end": [661, 41], "kind": "mathlibtacticlemma"}, {"full_name": "sup_eq_half_smul_add_add_abs_sub", "code": "lemma sup_eq_half_smul_add_add_abs_sub (x y : \u03b2) :\n    x \u2294 y = (\u215f2 : \u03b1) \u2022 (x + y + |y - x|) := by\n  rw [\u2190LatticeOrderedCommGroup.two_sup_eq_add_add_abs_sub x y, two_smul, \u2190two_smul \u03b1,\n    smul_smul, invOf_mul_self, one_smul]", "start": [663, 1], "end": [666, 41], "kind": "mathlibtacticlemma"}, {"full_name": "inf_eq_half_smul_add_sub_abs_sub'", "code": "lemma inf_eq_half_smul_add_sub_abs_sub' (x y : \u03b2) : x \u2293 y = (2\u207b\u00b9 : \u03b1) \u2022 (x + y - |y - x|) := by\n  letI := invertibleOfNonzero (two_ne_zero' \u03b1)\n  exact inf_eq_half_smul_add_sub_abs_sub \u03b1 x y", "start": [676, 1], "end": [678, 47], "kind": "mathlibtacticlemma"}, {"full_name": "sup_eq_half_smul_add_add_abs_sub'", "code": "lemma sup_eq_half_smul_add_add_abs_sub' (x y : \u03b2) : x \u2294 y = (2\u207b\u00b9 : \u03b1) \u2022 (x + y + |y - x|) := by\n  letI := invertibleOfNonzero (two_ne_zero' \u03b1)\n  exact sup_eq_half_smul_add_add_abs_sub \u03b1 x y", "start": [680, 1], "end": [682, 47], "kind": "mathlibtacticlemma"}, {"full_name": "LatticeOrderedAddCommGroup.IsSolid", "code": "def IsSolid (s : Set \u03b2) : Prop := \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, |y| \u2264 |x| \u2192 y \u2208 s", "start": [692, 1], "end": [694, 74], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedAddCommGroup.solidClosure", "code": "def solidClosure (s : Set \u03b2) : Set \u03b2 := { y | \u2203 x \u2208 s, |y| \u2264 |x| }", "start": [697, 1], "end": [698, 67], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedAddCommGroup.isSolid_solidClosure", "code": "theorem isSolid_solidClosure (s : Set \u03b2) : IsSolid (solidClosure s)", "start": [701, 1], "end": [702, 53], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedAddCommGroup.solidClosure_min", "code": "theorem solidClosure_min (s t : Set \u03b2) (h1 : s \u2286 t) (h2 : IsSolid t) : solidClosure s \u2286 t", "start": [705, 1], "end": [706, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/CompactConvergence.lean", "imports": ["Mathlib/Topology/CompactOpen.lean", "Mathlib/Topology/UniformSpace/UniformConvergence.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousMap.compactConvNhd", "code": "def compactConvNhd : Set C(\u03b1, \u03b2) :=\n  { g | \u2200 x \u2208 K, (f x, g x) \u2208 V }", "start": [94, 1], "end": [97, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.self_mem_compactConvNhd", "code": "theorem self_mem_compactConvNhd (hV : V \u2208 \ud835\udce4 \u03b2) : f \u2208 compactConvNhd K V f", "start": [102, 1], "end": [103, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactConvNhd_mono", "code": "@[mono]\ntheorem compactConvNhd_mono {V' : Set (\u03b2 \u00d7 \u03b2)} (hV' : V' \u2286 V) :\n    compactConvNhd K V' f \u2286 compactConvNhd K V f", "start": [106, 1], "end": [108, 84], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactConvNhd_mem_comp", "code": "theorem compactConvNhd_mem_comp {g\u2081 g\u2082 : C(\u03b1, \u03b2)} {V' : Set (\u03b2 \u00d7 \u03b2)}\n    (hg\u2081 : g\u2081 \u2208 compactConvNhd K V f) (hg\u2082 : g\u2082 \u2208 compactConvNhd K V' g\u2081) :\n    g\u2082 \u2208 compactConvNhd K (V \u25cb V') f", "start": [111, 1], "end": [113, 79], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactConvNhd_nhd_basis", "code": "theorem compactConvNhd_nhd_basis (hV : V \u2208 \ud835\udce4 \u03b2) :\n    \u2203 V' \u2208 \ud835\udce4 \u03b2,\n      V' \u2286 V \u2227 \u2200 g \u2208 compactConvNhd K V' f, compactConvNhd K V' g \u2286 compactConvNhd K V f", "start": [116, 1], "end": [124, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactConvNhd_subset_inter", "code": "theorem compactConvNhd_subset_inter (K\u2081 K\u2082 : Set \u03b1) (V\u2081 V\u2082 : Set (\u03b2 \u00d7 \u03b2)) :\n    compactConvNhd (K\u2081 \u222a K\u2082) (V\u2081 \u2229 V\u2082) f \u2286 compactConvNhd K\u2081 V\u2081 f \u2229 compactConvNhd K\u2082 V\u2082 f", "start": [127, 1], "end": [131, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactConvNhd_compact_entourage_nonempty", "code": "theorem compactConvNhd_compact_entourage_nonempty :\n    { KV : Set \u03b1 \u00d7 Set (\u03b2 \u00d7 \u03b2) | IsCompact KV.1 \u2227 KV.2 \u2208 \ud835\udce4 \u03b2 }.Nonempty", "start": [134, 1], "end": [136, 48], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactConvNhd_filter_isBasis", "code": "theorem compactConvNhd_filter_isBasis :\n    Filter.IsBasis (fun KV : Set \u03b1 \u00d7 Set (\u03b2 \u00d7 \u03b2) => IsCompact KV.1 \u2227 KV.2 \u2208 \ud835\udce4 \u03b2) fun KV =>\n      compactConvNhd KV.1 KV.2 f", "start": [139, 1], "end": [147, 55], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactConvergenceFilterBasis", "code": "def compactConvergenceFilterBasis (f : C(\u03b1, \u03b2)) : FilterBasis C(\u03b1, \u03b2) :=\n  (compactConvNhd_filter_isBasis f).filterBasis", "start": [150, 1], "end": [152, 48], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.mem_compactConvergence_nhd_filter", "code": "theorem mem_compactConvergence_nhd_filter (Y : Set C(\u03b1, \u03b2)) :\n    Y \u2208 (compactConvergenceFilterBasis f).filter \u2194\n    \u2203 (K : Set \u03b1) (V : Set (\u03b2 \u00d7 \u03b2)) (_hK : IsCompact K) (_hV : V \u2208 \ud835\udce4 \u03b2),\n      compactConvNhd K V f \u2286 Y", "start": [155, 1], "end": [163, 62], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactConvergenceTopology", "code": "def compactConvergenceTopology : TopologicalSpace C(\u03b1, \u03b2) :=\n  TopologicalSpace.mkOfNhds fun f => (compactConvergenceFilterBasis f).filter", "start": [166, 1], "end": [170, 78], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.nhds_compactConvergence", "code": "theorem nhds_compactConvergence :\n    @nhds _ compactConvergenceTopology f = (compactConvergenceFilterBasis f).filter", "start": [173, 1], "end": [180, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.hasBasis_nhds_compactConvergence", "code": "theorem hasBasis_nhds_compactConvergence :\n    HasBasis (@nhds _ compactConvergenceTopology f)\n      (fun p : Set \u03b1 \u00d7 Set (\u03b2 \u00d7 \u03b2) => IsCompact p.1 \u2227 p.2 \u2208 \ud835\udce4 \u03b2) fun p =>\n      compactConvNhd p.1 p.2 f", "start": [183, 1], "end": [187, 80], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn'", "code": "theorem tendsto_iff_forall_compact_tendstoUniformlyOn' {\u03b9 : Type u\u2083} {p : Filter \u03b9}\n    {F : \u03b9 \u2192 C(\u03b1, \u03b2)} :\n    Filter.Tendsto F p (@nhds _ compactConvergenceTopology f) \u2194\n      \u2200 K, IsCompact K \u2192 TendstoUniformlyOn (fun i a => F i a) f p K", "start": [190, 1], "end": [201, 47], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactConvNhd_subset_compactOpen", "code": "theorem compactConvNhd_subset_compactOpen (hK : IsCompact K) {U : Set \u03b2} (hU : IsOpen U)\n    (hf : f \u2208 CompactOpen.gen K U) :\n    \u2203 V \u2208 \ud835\udce4 \u03b2, IsOpen V \u2227 compactConvNhd K V f \u2286 CompactOpen.gen K U", "start": [204, 1], "end": [214, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.iInter_compactOpen_gen_subset_compactConvNhd", "code": "theorem iInter_compactOpen_gen_subset_compactConvNhd (hK : IsCompact K) (hV : V \u2208 \ud835\udce4 \u03b2) :\n    \u2203 (\u03b9 : Sort (u\u2081 + 1)) (_ : Fintype \u03b9) (C : \u03b9 \u2192 Set \u03b1) (_hC : \u2200 i, IsCompact (C i))\n      (U : \u03b9 \u2192 Set \u03b2) (_hU : \u2200 i, IsOpen (U i)),\n      (f \u2208 \u22c2 i, CompactOpen.gen (C i) (U i)) \u2227\n        \u22c2 i, CompactOpen.gen (C i) (U i) \u2286 compactConvNhd K V f", "start": [217, 1], "end": [264, 80], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactOpen_eq_compactConvergence", "code": "theorem compactOpen_eq_compactConvergence :\n    ContinuousMap.compactOpen = (compactConvergenceTopology : TopologicalSpace C(\u03b1, \u03b2))", "start": [267, 1], "end": [286, 95], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactConvergenceUniformity", "code": "def compactConvergenceUniformity : Filter (C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2)) :=\n  \u2a05 KV \u2208 { KV : Set \u03b1 \u00d7 Set (\u03b2 \u00d7 \u03b2) | IsCompact KV.1 \u2227 KV.2 \u2208 \ud835\udce4 \u03b2 },\n    \ud835\udcdf { fg : C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2) | \u2200 x : \u03b1, x \u2208 KV.1 \u2192 (fg.1 x, fg.2 x) \u2208 KV.2 }", "start": [289, 1], "end": [292, 79], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.hasBasis_compactConvergenceUniformity_aux", "code": "theorem hasBasis_compactConvergenceUniformity_aux :\n    HasBasis (@compactConvergenceUniformity \u03b1 \u03b2 _ _)\n      (fun p : Set \u03b1 \u00d7 Set (\u03b2 \u00d7 \u03b2) => IsCompact p.1 \u2227 p.2 \u2208 \ud835\udce4 \u03b2) fun p =>\n      { fg : C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2) | \u2200 x \u2208 p.1, (fg.1 x, fg.2 x) \u2208 p.2 }", "start": [295, 1], "end": [304, 48], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.mem_compactConvergenceUniformity", "code": "theorem mem_compactConvergenceUniformity (X : Set (C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2))) :\n    X \u2208 @compactConvergenceUniformity \u03b1 \u03b2 _ _ \u2194\n      \u2203 (K : Set \u03b1) (V : Set (\u03b2 \u00d7 \u03b2)) (_hK : IsCompact K) (_hV : V \u2208 \ud835\udce4 \u03b2),\n        { fg : C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2) | \u2200 x \u2208 K, (fg.1 x, fg.2 x) \u2208 V } \u2286 X", "start": [307, 1], "end": [314, 15], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactConvergenceUniformSpace", "code": "instance compactConvergenceUniformSpace : UniformSpace C(\u03b1, \u03b2)\n    where\n  uniformity := compactConvergenceUniformity\n  refl := by\n    simp only [compactConvergenceUniformity, and_imp, Filter.le_principal_iff, Prod.forall,\n      Filter.mem_principal, mem_setOf_eq, le_iInf_iff, idRel_subset]\n    exact fun K V _hK hV f x _hx => refl_mem_uniformity hV\n  symm := by\n    simp only [compactConvergenceUniformity, and_imp, Prod.forall, mem_setOf_eq, Prod.fst_swap,\n      Filter.tendsto_principal, Prod.snd_swap, Filter.tendsto_iInf]\n    intro K V hK hV\n    obtain \u27e8V', hV', hsymm, hsub\u27e9 := symm_of_uniformity hV\n    let X := { fg : C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2) | \u2200 x : \u03b1, x \u2208 K \u2192 (fg.1 x, fg.2 x) \u2208 V' }\n    have hX : X \u2208 compactConvergenceUniformity :=\n      (mem_compactConvergenceUniformity X).mpr \u27e8K, V', hK, hV', by simp\u27e9\n    exact Filter.eventually_of_mem hX fun fg hfg x hx => hsub (hsymm _ _ (hfg x hx))\n  comp X hX := by\n    obtain \u27e8K, V, hK, hV, hX\u27e9 := (mem_compactConvergenceUniformity X).mp hX\n    obtain \u27e8V', hV', hcomp\u27e9 := comp_mem_uniformity_sets hV\n    let h := fun s : Set (C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2)) => s \u25cb s\n    suffices h { fg : C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2) | \u2200 x \u2208 K, (fg.1 x, fg.2 x) \u2208 V' } \u2208\n        compactConvergenceUniformity.lift' h by\n      apply Filter.mem_of_superset this\n      rintro \u27e8f, g\u27e9 \u27e8z, hz\u2081, hz\u2082\u27e9\n      refine' hX fun x hx => hcomp _\n      exact \u27e8z x, hz\u2081 x hx, hz\u2082 x hx\u27e9\n    apply Filter.mem_lift'\n    exact (mem_compactConvergenceUniformity _).mpr \u27e8K, V', hK, hV', Subset.refl _\u27e9\n  isOpen_uniformity := by\n    rw [compactOpen_eq_compactConvergence]\n    refine' fun Y => forall\u2082_congr fun f hf => _\n    simp only [mem_compactConvergence_nhd_filter, mem_compactConvergenceUniformity, Prod.forall,\n      setOf_subset_setOf, compactConvNhd]\n    refine' exists\u2084_congr fun K V _hK _hV => \u27e8_, fun hY g hg => hY f g hg rfl\u27e9\n    rintro hY g\u2081 g\u2082 hg\u2081 rfl\n    exact hY hg\u2081", "start": [317, 1], "end": [353, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.mem_compactConvergence_entourage_iff", "code": "theorem mem_compactConvergence_entourage_iff (X : Set (C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2))) :\n    X \u2208 \ud835\udce4 C(\u03b1, \u03b2) \u2194\n      \u2203 (K : Set \u03b1) (V : Set (\u03b2 \u00d7 \u03b2)) (_hK : IsCompact K) (_hV : V \u2208 \ud835\udce4 \u03b2),\n        { fg : C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2) | \u2200 x \u2208 K, (fg.1 x, fg.2 x) \u2208 V } \u2286 X", "start": [356, 1], "end": [360, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.hasBasis_compactConvergenceUniformity", "code": "theorem hasBasis_compactConvergenceUniformity :\n    HasBasis (\ud835\udce4 C(\u03b1, \u03b2)) (fun p : Set \u03b1 \u00d7 Set (\u03b2 \u00d7 \u03b2) => IsCompact p.1 \u2227 p.2 \u2208 \ud835\udce4 \u03b2) fun p =>\n      { fg : C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2) | \u2200 x \u2208 p.1, (fg.1 x, fg.2 x) \u2208 p.2 }", "start": [363, 1], "end": [366, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.compactConvergenceUniformity", "code": "theorem _root_.Filter.HasBasis.compactConvergenceUniformity {\u03b9 : Type*} {pi : \u03b9 \u2192 Prop}\n    {s : \u03b9 \u2192 Set (\u03b2 \u00d7 \u03b2)} (h : (\ud835\udce4 \u03b2).HasBasis pi s) :\n    HasBasis (\ud835\udce4 C(\u03b1, \u03b2)) (fun p : Set \u03b1 \u00d7 \u03b9 => IsCompact p.1 \u2227 pi p.2) fun p =>\n      { fg : C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2) | \u2200 x \u2208 p.1, (fg.1 x, fg.2 x) \u2208 s p.2 }", "start": [369, 1], "end": [378, 56], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn", "code": "theorem tendsto_iff_forall_compact_tendstoUniformlyOn :\n    Tendsto F p (\ud835\udcdd f) \u2194 \u2200 K, IsCompact K \u2192 TendstoUniformlyOn (fun i a => F i a) f p K", "start": [383, 1], "end": [385, 89], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.tendsto_of_tendstoLocallyUniformly", "code": "theorem tendsto_of_tendstoLocallyUniformly (h : TendstoLocallyUniformly (fun i a => F i a) f p) :\n    Tendsto F p (\ud835\udcdd f)", "start": [388, 1], "end": [394, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.tendsto_iff_tendstoLocallyUniformly", "code": "theorem tendsto_iff_tendstoLocallyUniformly [WeaklyLocallyCompactSpace \u03b1] :\n    Tendsto F p (\ud835\udcdd f) \u2194 TendstoLocallyUniformly (fun i a => F i a) f p", "start": [397, 1], "end": [407, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.tendstoLocallyUniformly_of_tendsto", "code": "@[deprecated tendsto_iff_tendstoLocallyUniformly]\ntheorem tendstoLocallyUniformly_of_tendsto [WeaklyLocallyCompactSpace \u03b1] (h : Tendsto F p (\ud835\udcdd f)) :\n    TendstoLocallyUniformly (fun i a => F i a) f p", "start": [410, 1], "end": [413, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.hasBasis_compactConvergenceUniformity_of_compact", "code": "theorem hasBasis_compactConvergenceUniformity_of_compact :\n    HasBasis (\ud835\udce4 C(\u03b1, \u03b2)) (fun V : Set (\u03b2 \u00d7 \u03b2) => V \u2208 \ud835\udce4 \u03b2) fun V =>\n      { fg : C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2) | \u2200 x, (fg.1 x, fg.2 x) \u2208 V }", "start": [420, 1], "end": [425, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.tendsto_iff_tendstoUniformly", "code": "theorem tendsto_iff_tendstoUniformly :\n    Tendsto F p (\ud835\udcdd f) \u2194 TendstoUniformly (fun i a => F i a) f p", "start": [428, 1], "end": [433, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/ContinuousFunction/Ordered.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Basic.lean", "Mathlib/Topology/Algebra/Order/Group.lean", "Mathlib/Topology/Algebra/Order/ProjIcc.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousMap.abs", "code": "def abs (f : C(\u03b1, \u03b2)) : C(\u03b1, \u03b2) where toFun x := |f x|", "start": [28, 1], "end": [29, 55], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.abs_apply", "code": "@[simp]\ntheorem abs_apply (f : C(\u03b1, \u03b2)) (x : \u03b1) : |f| x = |f x|", "start": [36, 1], "end": [38, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.partialOrder", "code": "instance partialOrder [PartialOrder \u03b2] : PartialOrder C(\u03b1, \u03b2) :=\n  PartialOrder.lift (fun f => f.toFun) (fun f g _ => by cases f; cases g; congr)", "start": [51, 1], "end": [52, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.le_def", "code": "theorem le_def [PartialOrder \u03b2] {f g : C(\u03b1, \u03b2)} : f \u2264 g \u2194 \u2200 a, f a \u2264 g a", "start": [56, 1], "end": [57, 12], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.lt_def", "code": "theorem lt_def [PartialOrder \u03b2] {f g : C(\u03b1, \u03b2)} : f < g \u2194 (\u2200 a, f a \u2264 g a) \u2227 \u2203 a, f a < g a", "start": [60, 1], "end": [61, 12], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.sup", "code": "instance sup [LinearOrder \u03b2] [OrderClosedTopology \u03b2] : Sup C(\u03b1, \u03b2) where\n  sup f g := { toFun := fun a => max (f a) (g a) }", "start": [64, 1], "end": [65, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.sup_coe", "code": "@[simp, norm_cast]\ntheorem sup_coe [LinearOrder \u03b2] [OrderClosedTopology \u03b2] (f g : C(\u03b1, \u03b2)) :\n    ((f \u2294 g : C(\u03b1, \u03b2)) : \u03b1 \u2192 \u03b2) = (f \u2294 g : \u03b1 \u2192 \u03b2)", "start": [68, 1], "end": [71, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.sup_apply", "code": "@[simp]\ntheorem sup_apply [LinearOrder \u03b2] [OrderClosedTopology \u03b2] (f g : C(\u03b1, \u03b2)) (a : \u03b1) :\n    (f \u2294 g) a = max (f a) (g a)", "start": [74, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.semilatticeSup", "code": "instance semilatticeSup [LinearOrder \u03b2] [OrderClosedTopology \u03b2] : SemilatticeSup C(\u03b1, \u03b2) :=\n  { ContinuousMap.partialOrder,\n    ContinuousMap.sup with\n    le_sup_left := fun f g => le_def.mpr (by simp [le_refl])\n    le_sup_right := fun f g => le_def.mpr (by simp [le_refl])\n    sup_le := fun f\u2081 f\u2082 g w\u2081 w\u2082 => le_def.mpr fun a => by simp [le_def.mp w\u2081 a, le_def.mp w\u2082 a] }", "start": [80, 1], "end": [85, 98], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.inf", "code": "instance inf [LinearOrder \u03b2] [OrderClosedTopology \u03b2] : Inf C(\u03b1, \u03b2) where\n  inf f g := { toFun := fun a => min (f a) (g a) }", "start": [87, 1], "end": [88, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.inf_coe", "code": "@[simp, norm_cast]\ntheorem inf_coe [LinearOrder \u03b2] [OrderClosedTopology \u03b2] (f g : C(\u03b1, \u03b2)) :\n    ((f \u2293 g : C(\u03b1, \u03b2)) : \u03b1 \u2192 \u03b2) = (f \u2293 g : \u03b1 \u2192 \u03b2)", "start": [91, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.inf_apply", "code": "@[simp]\ntheorem inf_apply [LinearOrder \u03b2] [OrderClosedTopology \u03b2] (f g : C(\u03b1, \u03b2)) (a : \u03b1) :\n    (f \u2293 g) a = min (f a) (g a)", "start": [97, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.semilatticeInf", "code": "instance semilatticeInf [LinearOrder \u03b2] [OrderClosedTopology \u03b2] : SemilatticeInf C(\u03b1, \u03b2) :=\n  { ContinuousMap.partialOrder,\n    ContinuousMap.inf with\n    inf_le_left := fun f g => le_def.mpr (by simp [le_refl])\n    inf_le_right := fun f g => le_def.mpr (by simp [le_refl])\n    le_inf := fun f\u2081 f\u2082 g w\u2081 w\u2082 => le_def.mpr fun a => by simp [le_def.mp w\u2081 a, le_def.mp w\u2082 a] }", "start": [103, 1], "end": [108, 98], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.sup'_apply", "code": "theorem sup'_apply {\u03b9 : Type*} {s : Finset \u03b9} (H : s.Nonempty) (f : \u03b9 \u2192 C(\u03b2, \u03b3)) (b : \u03b2) :\n    s.sup' H f b = s.sup' H fun a => f a b", "start": [118, 1], "end": [120, 74], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.sup'_coe", "code": "@[simp, norm_cast]\ntheorem sup'_coe {\u03b9 : Type*} {s : Finset \u03b9} (H : s.Nonempty) (f : \u03b9 \u2192 C(\u03b2, \u03b3)) :\n    ((s.sup' H f : C(\u03b2, \u03b3)) : \u03b2 \u2192 \u03b3) = s.sup' H fun a => (f a : \u03b2 \u2192 \u03b3)", "start": [123, 1], "end": [127, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.inf'_apply", "code": "theorem inf'_apply {\u03b9 : Type*} {s : Finset \u03b9} (H : s.Nonempty) (f : \u03b9 \u2192 C(\u03b2, \u03b3)) (b : \u03b2) :\n    s.inf' H f b = s.inf' H fun a => f a b", "start": [136, 1], "end": [138, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.inf'_coe", "code": "@[simp, norm_cast]\ntheorem inf'_coe {\u03b9 : Type*} {s : Finset \u03b9} (H : s.Nonempty) (f : \u03b9 \u2192 C(\u03b2, \u03b3)) :\n    ((s.inf' H f : C(\u03b2, \u03b3)) : \u03b2 \u2192 \u03b3) = s.inf' H fun a => (f a : \u03b2 \u2192 \u03b3)", "start": [141, 1], "end": [144, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.IccExtend", "code": "def IccExtend (f : C(Set.Icc a b, \u03b2)) : C(\u03b1, \u03b2) where\n  toFun := Set.IccExtend h f", "start": [155, 1], "end": [157, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_IccExtend", "code": "@[simp]\ntheorem coe_IccExtend (f : C(Set.Icc a b, \u03b2)) :\n    ((IccExtend h f : C(\u03b1, \u03b2)) : \u03b1 \u2192 \u03b2) = Set.IccExtend h f", "start": [160, 1], "end": [163, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "imports": ["Mathlib/Topology/MetricSpace/Equicontinuity.lean", "Mathlib/Topology/Algebra/Module/LocallyConvex.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Seminorm.lean", "Mathlib/Topology/Algebra/Equicontinuity.lean", "Mathlib/Topology/Algebra/FilterBasis.lean"], "premises": [{"full_name": "SeminormFamily", "code": "abbrev SeminormFamily :=\n  \u03b9 \u2192 Seminorm \ud835\udd5c E", "start": [64, 1], "end": [66, 19], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.basisSets", "code": "def basisSets (p : SeminormFamily \ud835\udd5c E \u03b9) : Set (Set E) :=\n  \u22c3 (s : Finset \u03b9) (r) (_ : 0 < r), singleton (ball (s.sup p) (0 : E) r)", "start": [73, 1], "end": [75, 73], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.basisSets_iff", "code": "theorem basisSets_iff {U : Set E} :\n    U \u2208 p.basisSets \u2194 \u2203 (i : Finset \u03b9) (r : _) (_ : 0 < r), U = ball (i.sup p) 0 r", "start": [80, 1], "end": [82, 55], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.basisSets_mem", "code": "theorem basisSets_mem (i : Finset \u03b9) {r : \u211d} (hr : 0 < r) : (i.sup p).ball 0 r \u2208 p.basisSets", "start": [85, 1], "end": [86, 40], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.basisSets_singleton_mem", "code": "theorem basisSets_singleton_mem (i : \u03b9) {r : \u211d} (hr : 0 < r) : (p i).ball 0 r \u2208 p.basisSets", "start": [89, 1], "end": [90, 67], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.basisSets_nonempty", "code": "theorem basisSets_nonempty [Nonempty \u03b9] : p.basisSets.Nonempty", "start": [93, 1], "end": [96, 48], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.basisSets_intersect", "code": "theorem basisSets_intersect (U V : Set E) (hU : U \u2208 p.basisSets) (hV : V \u2208 p.basisSets) :\n    \u2203 z \u2208 p.basisSets, z \u2286 U \u2229 V", "start": [99, 1], "end": [113, 80], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.basisSets_zero", "code": "theorem basisSets_zero (U) (hU : U \u2208 p.basisSets) : (0 : E) \u2208 U", "start": [116, 1], "end": [119, 11], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.basisSets_add", "code": "theorem basisSets_add (U) (hU : U \u2208 p.basisSets) :\n    \u2203 V \u2208 p.basisSets, V + V \u2286 U", "start": [122, 1], "end": [128, 33], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.basisSets_neg", "code": "theorem basisSets_neg (U) (hU' : U \u2208 p.basisSets) :\n    \u2203 V \u2208 p.basisSets, V \u2286 (fun x : E => -x) \u207b\u00b9' U", "start": [131, 1], "end": [135, 31], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.addGroupFilterBasis", "code": "protected def addGroupFilterBasis [Nonempty \u03b9] : AddGroupFilterBasis E :=\n  addGroupFilterBasisOfComm p.basisSets p.basisSets_nonempty p.basisSets_intersect p.basisSets_zero\n    p.basisSets_add p.basisSets_neg", "start": [138, 1], "end": [141, 36], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.basisSets_smul_right", "code": "theorem basisSets_smul_right (v : E) (U : Set E) (hU : U \u2208 p.basisSets) :\n    \u2200\u1da0 x : \ud835\udd5c in \ud835\udcdd 0, x \u2022 v \u2208 U", "start": [144, 1], "end": [154, 49], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.basisSets_smul", "code": "theorem basisSets_smul (U) (hU : U \u2208 p.basisSets) :\n    \u2203 V \u2208 \ud835\udcdd (0 : \ud835\udd5c), \u2203 W \u2208 p.addGroupFilterBasis.sets, V \u2022 W \u2286 U", "start": [159, 1], "end": [165, 44], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.basisSets_smul_left", "code": "theorem basisSets_smul_left (x : \ud835\udd5c) (U : Set E) (hU : U \u2208 p.basisSets) :\n    \u2203 V \u2208 p.addGroupFilterBasis.sets, V \u2286 (fun y : E => x \u2022 y) \u207b\u00b9' U", "start": [168, 1], "end": [178, 38], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.moduleFilterBasis", "code": "protected def moduleFilterBasis : ModuleFilterBasis \ud835\udd5c E where\n  toAddGroupFilterBasis := p.addGroupFilterBasis\n  smul' := p.basisSets_smul _\n  smul_left' := p.basisSets_smul_left\n  smul_right' := p.basisSets_smul_right", "start": [181, 1], "end": [186, 40], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.filter_eq_iInf", "code": "theorem filter_eq_iInf (p : SeminormFamily \ud835\udd5c E \u03b9) :\n    p.moduleFilterBasis.toFilterBasis.filter = \u2a05 i, (\ud835\udcdd 0).comap (p i)", "start": [189, 1], "end": [206, 59], "kind": "commanddeclaration"}, {"full_name": "Seminorm.IsBounded", "code": "def IsBounded (p : \u03b9 \u2192 Seminorm \ud835\udd5c E) (q : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F) : Prop :=\n  \u2200 i, \u2203 s : Finset \u03b9, \u2203 C : \u211d\u22650, (q i).comp f \u2264 C \u2022 s.sup p", "start": [224, 1], "end": [226, 61], "kind": "commanddeclaration"}, {"full_name": "Seminorm.isBounded_const", "code": "theorem isBounded_const (\u03b9' : Type*) [Nonempty \u03b9'] {p : \u03b9 \u2192 Seminorm \ud835\udd5c E} {q : Seminorm \ud835\udd5c\u2082 F}\n    (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F) :\n    IsBounded p (fun _ : \u03b9' => q) f \u2194 \u2203 (s : Finset \u03b9) (C : \u211d\u22650), q.comp f \u2264 C \u2022 s.sup p", "start": [229, 1], "end": [232, 38], "kind": "commanddeclaration"}, {"full_name": "Seminorm.const_isBounded", "code": "theorem const_isBounded (\u03b9 : Type*) [Nonempty \u03b9] {p : Seminorm \ud835\udd5c E} {q : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F}\n    (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F) : IsBounded (fun _ : \u03b9 => p) q f \u2194 \u2200 i, \u2203 C : \u211d\u22650, (q i).comp f \u2264 C \u2022 p", "start": [235, 1], "end": [241, 38], "kind": "commanddeclaration"}, {"full_name": "Seminorm.isBounded_sup", "code": "theorem isBounded_sup {p : \u03b9 \u2192 Seminorm \ud835\udd5c E} {q : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F} {f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F}\n    (hf : IsBounded p q f) (s' : Finset \u03b9') :\n    \u2203 (C : \u211d\u22650) (s : Finset \u03b9), (s'.sup q).comp f \u2264 C \u2022 s.sup p", "start": [244, 1], "end": [259, 38], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms", "code": "structure WithSeminorms (p : SeminormFamily \ud835\udd5c E \u03b9) [topology : TopologicalSpace E] : Prop where\n  topology_eq_withSeminorms : topology = p.moduleFilterBasis.topology", "start": [270, 1], "end": [272, 70], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.withSeminorms_eq", "code": "theorem WithSeminorms.withSeminorms_eq {p : SeminormFamily \ud835\udd5c E \u03b9} [t : TopologicalSpace E]\n    (hp : WithSeminorms p) : t = p.moduleFilterBasis.topology", "start": [275, 1], "end": [277, 7], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.topologicalAddGroup", "code": "theorem WithSeminorms.topologicalAddGroup (hp : WithSeminorms p) : TopologicalAddGroup E", "start": [284, 1], "end": [286, 52], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.continuousSMul", "code": "theorem WithSeminorms.continuousSMul (hp : WithSeminorms p) : ContinuousSMul \ud835\udd5c E", "start": [289, 1], "end": [291, 43], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.hasBasis", "code": "theorem WithSeminorms.hasBasis (hp : WithSeminorms p) :\n    (\ud835\udcdd (0 : E)).HasBasis (fun s : Set E => s \u2208 p.basisSets) id", "start": [293, 1], "end": [296, 49], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.hasBasis_zero_ball", "code": "theorem WithSeminorms.hasBasis_zero_ball (hp : WithSeminorms p) :\n    (\ud835\udcdd (0 : E)).HasBasis\n    (fun sr : Finset \u03b9 \u00d7 \u211d => 0 < sr.2) fun sr => (sr.1.sup p).ball 0 sr.2", "start": [299, 1], "end": [308, 35], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.hasBasis_ball", "code": "theorem WithSeminorms.hasBasis_ball (hp : WithSeminorms p) {x : E} :\n    (\ud835\udcdd (x : E)).HasBasis\n    (fun sr : Finset \u03b9 \u00d7 \u211d => 0 < sr.2) fun sr => (sr.1.sup p).ball x sr.2", "start": [311, 1], "end": [321, 38], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.mem_nhds_iff", "code": "theorem WithSeminorms.mem_nhds_iff (hp : WithSeminorms p) (x : E) (U : Set E) :\n    U \u2208 nhds x \u2194 \u2203 s : Finset \u03b9, \u2203 r > 0, (s.sup p).ball x r \u2286 U", "start": [324, 1], "end": [328, 45], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.isOpen_iff_mem_balls", "code": "theorem WithSeminorms.isOpen_iff_mem_balls (hp : WithSeminorms p) (U : Set E) :\n    IsOpen U \u2194 \u2200 x \u2208 U, \u2203 s : Finset \u03b9, \u2203 r > 0, (s.sup p).ball x r \u2286 U", "start": [331, 1], "end": [335, 69], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.T1_of_separating", "code": "theorem WithSeminorms.T1_of_separating (hp : WithSeminorms p)\n    (h : \u2200 x, x \u2260 0 \u2192 \u2203 i, p i x \u2260 0) : T1Space E", "start": [341, 1], "end": [350, 72], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.separating_of_T1", "code": "theorem WithSeminorms.separating_of_T1 [T1Space E] (hp : WithSeminorms p) (x : E) (hx : x \u2260 0) :\n    \u2203 i, p i x \u2260 0", "start": [353, 1], "end": [361, 101], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.separating_iff_T1", "code": "theorem WithSeminorms.separating_iff_T1 (hp : WithSeminorms p) :\n    (\u2200 x, x \u2260 0 \u2192 \u2203 i, p i x \u2260 0) \u2194 T1Space E", "start": [364, 1], "end": [369, 42], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.tendsto_nhds'", "code": "theorem WithSeminorms.tendsto_nhds' (hp : WithSeminorms p) (u : F \u2192 E) {f : Filter F} (y\u2080 : E) :\n    Filter.Tendsto u f (\ud835\udcdd y\u2080) \u2194 \u2200 (s : Finset \u03b9) (\u03b5), 0 < \u03b5 \u2192 \u2200\u1da0 x in f, s.sup p (u x - y\u2080) < \u03b5", "start": [380, 1], "end": [385, 47], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.tendsto_nhds", "code": "theorem WithSeminorms.tendsto_nhds (hp : WithSeminorms p) (u : F \u2192 E) {f : Filter F} (y\u2080 : E) :\n    Filter.Tendsto u f (\ud835\udcdd y\u2080) \u2194 \u2200 i \u03b5, 0 < \u03b5 \u2192 \u2200\u1da0 x in f, p i (u x - y\u2080) < \u03b5", "start": [388, 1], "end": [394, 85], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.tendsto_nhds_atTop", "code": "theorem WithSeminorms.tendsto_nhds_atTop (hp : WithSeminorms p) (u : F \u2192 E) (y\u2080 : E) :\n    Filter.Tendsto u Filter.atTop (\ud835\udcdd y\u2080) \u2194\n    \u2200 i \u03b5, 0 < \u03b5 \u2192 \u2203 x\u2080, \u2200 x, x\u2080 \u2264 x \u2192 p i (u x - y\u2080) < \u03b5", "start": [399, 1], "end": [404, 59], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.withSeminorms_of_nhds", "code": "theorem SeminormFamily.withSeminorms_of_nhds [TopologicalAddGroup E] (p : SeminormFamily \ud835\udd5c E \u03b9)\n    (h : \ud835\udcdd (0 : E) = p.moduleFilterBasis.toFilterBasis.filter) : WithSeminorms p", "start": [419, 1], "end": [424, 10], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.withSeminorms_of_hasBasis", "code": "theorem SeminormFamily.withSeminorms_of_hasBasis [TopologicalAddGroup E] (p : SeminormFamily \ud835\udd5c E \u03b9)\n    (h : (\ud835\udcdd (0 : E)).HasBasis (fun s : Set E => s \u2208 p.basisSets) id) : WithSeminorms p", "start": [427, 1], "end": [430, 84], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.withSeminorms_iff_nhds_eq_iInf", "code": "theorem SeminormFamily.withSeminorms_iff_nhds_eq_iInf [TopologicalAddGroup E]\n    (p : SeminormFamily \ud835\udd5c E \u03b9) : WithSeminorms p \u2194 (\ud835\udcdd (0 : E)) = \u2a05 i, (\ud835\udcdd 0).comap (p i)", "start": [433, 1], "end": [438, 43], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.withSeminorms_iff_topologicalSpace_eq_iInf", "code": "theorem SeminormFamily.withSeminorms_iff_topologicalSpace_eq_iInf [TopologicalAddGroup E]\n    (p : SeminormFamily \ud835\udd5c E \u03b9) :\n    WithSeminorms p \u2194\n      t = \u2a05 i, (p i).toSeminormedAddCommGroup.toUniformSpace.toTopologicalSpace", "start": [441, 1], "end": [451, 59], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.continuous_seminorm", "code": "theorem WithSeminorms.continuous_seminorm {p : SeminormFamily \ud835\udd5c E \u03b9} (hp : WithSeminorms p)\n    (i : \u03b9) : Continuous (p i)", "start": [454, 1], "end": [458, 76], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf", "code": "theorem SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf [u : UniformSpace E]\n    [UniformAddGroup E] (p : SeminormFamily \ud835\udd5c E \u03b9) :\n    WithSeminorms p \u2194 u = \u2a05 i, (p i).toSeminormedAddCommGroup.toUniformSpace", "start": [463, 1], "end": [473, 78], "kind": "commanddeclaration"}, {"full_name": "norm_withSeminorms", "code": "theorem norm_withSeminorms (\ud835\udd5c E) [NormedField \ud835\udd5c] [SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E] :\n    WithSeminorms fun _ : Fin 1 => normSeminorm \ud835\udd5c E", "start": [480, 1], "end": [499, 26], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.isVonNBounded_iff_finset_seminorm_bounded", "code": "theorem WithSeminorms.isVonNBounded_iff_finset_seminorm_bounded {s : Set E} (hp : WithSeminorms p) :\n    Bornology.IsVonNBounded \ud835\udd5c s \u2194 \u2200 I : Finset \u03b9, \u2203 r > 0, \u2200 x \u2208 s, I.sup p x < r", "start": [512, 1], "end": [533, 56], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.image_isVonNBounded_iff_finset_seminorm_bounded", "code": "theorem WithSeminorms.image_isVonNBounded_iff_finset_seminorm_bounded (f : G \u2192 E) {s : Set G}\n    (hp : WithSeminorms p) :\n    Bornology.IsVonNBounded \ud835\udd5c (f '' s) \u2194\n      \u2200 I : Finset \u03b9, \u2203 r > 0, \u2200 x \u2208 s, I.sup p (f x) < r", "start": [538, 1], "end": [542, 77], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.isVonNBounded_iff_seminorm_bounded", "code": "theorem WithSeminorms.isVonNBounded_iff_seminorm_bounded {s : Set E} (hp : WithSeminorms p) :\n    Bornology.IsVonNBounded \ud835\udd5c s \u2194 \u2200 i : \u03b9, \u2203 r > 0, \u2200 x \u2208 s, p i x < r", "start": [547, 1], "end": [566, 49], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.image_isVonNBounded_iff_seminorm_bounded", "code": "theorem WithSeminorms.image_isVonNBounded_iff_seminorm_bounded (f : G \u2192 E) {s : Set G}\n    (hp : WithSeminorms p) :\n    Bornology.IsVonNBounded \ud835\udd5c (f '' s) \u2194 \u2200 i : \u03b9, \u2203 r > 0, \u2200 x \u2208 s, p i (f x) < r", "start": [571, 1], "end": [574, 70], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuous_of_continuous_comp", "code": "theorem continuous_of_continuous_comp {q : SeminormFamily \ud835\udd5d\u2082 F \u03b9'} [TopologicalSpace E]\n    [TopologicalAddGroup E] [TopologicalSpace F] (hq : WithSeminorms q)\n    (f : E \u2192\u209b\u2097[\u03c4\u2081\u2082] F) (hf : \u2200 i, Continuous ((q i).comp f)) : Continuous f", "start": [600, 1], "end": [609, 26], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuous_iff_continuous_comp", "code": "theorem continuous_iff_continuous_comp {q : SeminormFamily \ud835\udd5c\u2082 F \u03b9'} [TopologicalSpace E]\n    [TopologicalAddGroup E] [TopologicalSpace F] (hq : WithSeminorms q) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F) :\n    Continuous f \u2194 \u2200 i, Continuous ((q i).comp f)", "start": [612, 1], "end": [618, 85], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuous_from_bounded", "code": "theorem continuous_from_bounded {p : SeminormFamily \ud835\udd5d E \u03b9} {q : SeminormFamily \ud835\udd5d\u2082 F \u03b9'}\n    {_ : TopologicalSpace E} (hp : WithSeminorms p) {_ : TopologicalSpace F} (hq : WithSeminorms q)\n    (f : E \u2192\u209b\u2097[\u03c4\u2081\u2082] F) (hf : Seminorm.IsBounded p q f) : Continuous f", "start": [621, 1], "end": [634, 90], "kind": "commanddeclaration"}, {"full_name": "Seminorm.cont_withSeminorms_normedSpace", "code": "theorem cont_withSeminorms_normedSpace (F) [SeminormedAddCommGroup F] [NormedSpace \ud835\udd5d\u2082 F]\n    [TopologicalSpace E] {p : \u03b9 \u2192 Seminorm \ud835\udd5d E} (hp : WithSeminorms p)\n    (f : E \u2192\u209b\u2097[\u03c4\u2081\u2082] F) (hf : \u2203 (s : Finset \u03b9) (C : \u211d\u22650), (normSeminorm \ud835\udd5d\u2082 F).comp f \u2264 C \u2022 s.sup p) :\n    Continuous f", "start": [637, 1], "end": [642, 66], "kind": "commanddeclaration"}, {"full_name": "Seminorm.cont_normedSpace_to_withSeminorms", "code": "theorem cont_normedSpace_to_withSeminorms (E) [SeminormedAddCommGroup E] [NormedSpace \ud835\udd5d E]\n    [TopologicalSpace F] {q : \u03b9 \u2192 Seminorm \ud835\udd5d\u2082 F} (hq : WithSeminorms q)\n    (f : E \u2192\u209b\u2097[\u03c4\u2081\u2082] F) (hf : \u2200 i : \u03b9, \u2203 C : \u211d\u22650, (q i).comp f \u2264 C \u2022 normSeminorm \ud835\udd5d E) :\n    Continuous f", "start": [645, 1], "end": [650, 65], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.equicontinuous_TFAE", "code": "protected theorem _root_.WithSeminorms.equicontinuous_TFAE {\u03ba : Type*}\n    {q : SeminormFamily \ud835\udd5c\u2082 F \u03b9'} [UniformSpace E] [UniformAddGroup E] [u : UniformSpace F]\n    [hu : UniformAddGroup F] (hq : WithSeminorms q) [ContinuousSMul \ud835\udd5c E]\n    (f : \u03ba \u2192 E \u2192\u209b\u2097[\u03c3\u2081\u2082] F) : TFAE\n    [ EquicontinuousAt ((\u2191) \u2218 f) 0,\n      Equicontinuous ((\u2191) \u2218 f),\n      UniformEquicontinuous ((\u2191) \u2218 f),\n      \u2200 i, \u2203 p : Seminorm \ud835\udd5c E, Continuous p \u2227 \u2200 k, (q i).comp (f k) \u2264 p,\n      \u2200 i, BddAbove (range fun k \u21a6 (q i).comp (f k)) \u2227 Continuous (\u2a06 k, (q i).comp (f k)) ]", "start": [653, 1], "end": [708, 14], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.uniformEquicontinuous_iff_exists_continuous_seminorm", "code": "theorem _root_.WithSeminorms.uniformEquicontinuous_iff_exists_continuous_seminorm {\u03ba : Type*}\n    {q : SeminormFamily \ud835\udd5c\u2082 F \u03b9'} [UniformSpace E] [UniformAddGroup E] [u : UniformSpace F]\n    [hu : UniformAddGroup F] (hq : WithSeminorms q) [ContinuousSMul \ud835\udd5c E]\n    (f : \u03ba \u2192 E \u2192\u209b\u2097[\u03c3\u2081\u2082] F) :\n    UniformEquicontinuous ((\u2191) \u2218 f) \u2194\n    \u2200 i, \u2203 p : Seminorm \ud835\udd5c E, Continuous p \u2227 \u2200 k, (q i).comp (f k) \u2264 p", "start": [710, 1], "end": [716, 37], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.uniformEquicontinuous_iff_bddAbove_and_continuous_iSup", "code": "theorem _root_.WithSeminorms.uniformEquicontinuous_iff_bddAbove_and_continuous_iSup {\u03ba : Type*}\n    {q : SeminormFamily \ud835\udd5c\u2082 F \u03b9'} [UniformSpace E] [UniformAddGroup E] [u : UniformSpace F]\n    [hu : UniformAddGroup F] (hq : WithSeminorms q) [ContinuousSMul \ud835\udd5c E]\n    (f : \u03ba \u2192 E \u2192\u209b\u2097[\u03c3\u2081\u2082] F) :\n    UniformEquicontinuous ((\u2191) \u2218 f) \u2194 \u2200 i,\n    BddAbove (range fun k \u21a6 (q i).comp (f k)) \u2227\n      Continuous (\u2a06 k, (q i).comp (f k))", "start": [718, 1], "end": [725, 37], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.congr", "code": "protected theorem congr {p : SeminormFamily \ud835\udd5c E \u03b9} {q : SeminormFamily \ud835\udd5c E \u03b9'}\n    [t : TopologicalSpace E] (hp : WithSeminorms p) (hpq : Seminorm.IsBounded p q LinearMap.id)\n    (hqp : Seminorm.IsBounded q p LinearMap.id) : WithSeminorms q", "start": [738, 1], "end": [754, 33], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.finset_sups", "code": "protected theorem finset_sups {p : SeminormFamily \ud835\udd5c E \u03b9} [TopologicalSpace E]\n    (hp : WithSeminorms p) : WithSeminorms (fun s : Finset \u03b9 \u21a6 s.sup p)", "start": [756, 1], "end": [766, 8], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.partial_sups", "code": "protected theorem partial_sups [Preorder \u03b9] [LocallyFiniteOrderBot \u03b9] {p : SeminormFamily \ud835\udd5c E \u03b9}\n    [TopologicalSpace E] (hp : WithSeminorms p) : WithSeminorms (fun i \u21a6 (Finset.Iic i).sup p)", "start": [768, 1], "end": [778, 83], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.congr_equiv", "code": "protected theorem congr_equiv {p : SeminormFamily \ud835\udd5c E \u03b9} [t : TopologicalSpace E]\n    (hp : WithSeminorms p) (e : \u03b9' \u2243 \u03b9) : WithSeminorms (p \u2218 e)", "start": [780, 1], "end": [785, 7], "kind": "commanddeclaration"}, {"full_name": "Seminorm.map_eq_zero_of_norm_zero", "code": "lemma map_eq_zero_of_norm_zero (q : Seminorm \ud835\udd5c F)\n    (hq : Continuous q) {x : F} (hx : \u2016x\u2016 = 0) : q x = 0 :=\n  (map_zero q) \u25b8\n    ((specializes_iff_mem_closure.mpr $ mem_closure_zero_iff_norm.mpr hx).map hq).eq.symm", "start": [801, 1], "end": [805, 90], "kind": "mathlibtacticlemma"}, {"full_name": "Seminorm.bound_of_continuous_normedSpace", "code": "lemma bound_of_continuous_normedSpace (q : Seminorm \ud835\udd5c F)\n    (hq : Continuous q) : \u2203 C, 0 < C \u2227 (\u2200 x : F, q x \u2264 C * \u2016x\u2016) := by\n  have hq' : Tendsto q (\ud835\udcdd 0) (\ud835\udcdd 0) := map_zero q \u25b8 hq.tendsto 0\n  rcases NormedAddCommGroup.nhds_zero_basis_norm_lt.mem_iff.mp (hq' $ Iio_mem_nhds one_pos)\n    with \u27e8\u03b5, \u03b5_pos, h\u03b5\u27e9\n  rcases NormedField.exists_one_lt_norm \ud835\udd5c with \u27e8c, hc\u27e9\n  have : 0 < \u2016c\u2016 / \u03b5 := by positivity\n  refine \u27e8\u2016c\u2016 / \u03b5, this, fun x \u21a6 ?_\u27e9\n  by_cases hx : \u2016x\u2016 = 0\n  \u00b7 rw [hx, mul_zero]\n    exact le_of_eq (map_eq_zero_of_norm_zero q hq hx)\n  \u00b7 refine (normSeminorm \ud835\udd5c F).bound_of_shell q \u03b5_pos hc (fun x hle hlt \u21a6 ?_) hx\n    refine (le_of_lt <| show q x < _ from h\u03b5 hlt).trans ?_\n    rwa [\u2190 div_le_iff' this, one_div_div]", "start": [807, 1], "end": [826, 42], "kind": "mathlibtacticlemma"}, {"full_name": "Seminorm.bound_of_continuous", "code": "lemma bound_of_continuous [Nonempty \u03b9] [t : TopologicalSpace E] (hp : WithSeminorms p)\n    (q : Seminorm \ud835\udd5c E) (hq : Continuous q) :\n    \u2203 s : Finset \u03b9, \u2203 C : \u211d\u22650, C \u2260 0 \u2227 q \u2264 C \u2022 s.sup p := by\n  rcases hp.hasBasis.mem_iff.mp (ball_mem_nhds hq one_pos) with \u27e8V, hV, h\u03b5\u27e9\n  rcases p.basisSets_iff.mp hV with \u27e8s, \u03b5, \u03b5_pos, rfl\u27e9\n  clear hp hq t\n  let _ : SeminormedAddCommGroup E := (s.sup p).toSeminormedAddCommGroup\n  let _ : NormedSpace \ud835\udd5c E := { norm_smul_le := fun a b \u21a6 le_of_eq (map_smul_eq_mul (s.sup p) a b) }\n  have : Continuous q :=\n    Seminorm.continuous (r := 1) (mem_of_superset (Metric.ball_mem_nhds _ \u03b5_pos) h\u03b5)\n  rcases bound_of_continuous_normedSpace q this with \u27e8C, C_pos, hC\u27e9\n  exact \u27e8s, \u27e8C, C_pos.le\u27e9, fun H \u21a6 C_pos.ne.symm (congr_arg NNReal.toReal H), hC\u27e9", "start": [828, 1], "end": [849, 82], "kind": "mathlibtacticlemma"}, {"full_name": "WithSeminorms.toLocallyConvexSpace", "code": "theorem WithSeminorms.toLocallyConvexSpace {p : SeminormFamily \ud835\udd5c E \u03b9} (hp : WithSeminorms p) :\n    LocallyConvexSpace \u211d E", "start": [865, 1], "end": [875, 28], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.toLocallyConvexSpace'", "code": "theorem NormedSpace.toLocallyConvexSpace' [NormedSpace \ud835\udd5c E] [Module \u211d E] [IsScalarTower \u211d \ud835\udd5c E] :\n    LocallyConvexSpace \u211d E", "start": [884, 1], "end": [888, 48], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.toLocallyConvexSpace", "code": "instance NormedSpace.toLocallyConvexSpace [NormedSpace \u211d E] : LocallyConvexSpace \u211d E :=\n  NormedSpace.toLocallyConvexSpace' \u211d", "start": [891, 1], "end": [894, 38], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.comp", "code": "def SeminormFamily.comp (q : SeminormFamily \ud835\udd5c\u2082 F \u03b9) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F) : SeminormFamily \ud835\udd5c E \u03b9 :=\n  fun i => (q i).comp f", "start": [907, 1], "end": [909, 24], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.comp_apply", "code": "theorem SeminormFamily.comp_apply (q : SeminormFamily \ud835\udd5c\u2082 F \u03b9) (i : \u03b9) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F) :\n    q.comp f i = (q i).comp f", "start": [912, 1], "end": [914, 6], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.finset_sup_comp", "code": "theorem SeminormFamily.finset_sup_comp (q : SeminormFamily \ud835\udd5c\u2082 F \u03b9) (s : Finset \u03b9)\n    (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F) : (s.sup q).comp f = s.sup (q.comp f)", "start": [917, 1], "end": [921, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.withSeminorms_induced", "code": "theorem LinearMap.withSeminorms_induced [h\u03b9 : Nonempty \u03b9] {q : SeminormFamily \ud835\udd5c\u2082 F \u03b9}\n    (hq : WithSeminorms q) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F) :\n    WithSeminorms (topology := induced f inferInstance) (q.comp f)", "start": [926, 1], "end": [935, 27], "kind": "commanddeclaration"}, {"full_name": "Inducing.withSeminorms", "code": "theorem Inducing.withSeminorms [h\u03b9 : Nonempty \u03b9] {q : SeminormFamily \ud835\udd5c\u2082 F \u03b9} (hq : WithSeminorms q)\n    [TopologicalSpace E] {f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F} (hf : Inducing f) : WithSeminorms (q.comp f)", "start": [938, 1], "end": [941, 35], "kind": "commanddeclaration"}, {"full_name": "SeminormFamily.sigma", "code": "protected def SeminormFamily.sigma {\u03ba : \u03b9 \u2192 Type*} (p : (i : \u03b9) \u2192 SeminormFamily \ud835\udd5c E (\u03ba i)) :\n    SeminormFamily \ud835\udd5c E ((i : \u03b9) \u00d7 \u03ba i) :=\n  fun \u27e8i, k\u27e9 => p i k", "start": [944, 1], "end": [947, 22], "kind": "commanddeclaration"}, {"full_name": "withSeminorms_iInf", "code": "theorem withSeminorms_iInf {\u03ba : \u03b9 \u2192 Type*} [Nonempty ((i : \u03b9) \u00d7 \u03ba i)] [\u2200 i, Nonempty (\u03ba i)]\n    {p : (i : \u03b9) \u2192 SeminormFamily \ud835\udd5c E (\u03ba i)} {t : \u03b9 \u2192 TopologicalSpace E}\n    [\u2200 i, @TopologicalAddGroup E (t i) _] (hp : \u2200 i, WithSeminorms (topology := t i) (p i)) :\n    WithSeminorms (topology := \u2a05 i, t i) (SeminormFamily.sigma p)", "start": [949, 1], "end": [956, 22], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.first_countable", "code": "theorem WithSeminorms.first_countable (hp : WithSeminorms p) :\n    TopologicalSpace.FirstCountableTopology E", "start": [968, 1], "end": [979, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Module/StrongTopology.lean", "imports": ["Mathlib/Topology/Algebra/UniformConvergence.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousLinearMap.strongTopology", "code": "def strongTopology [TopologicalSpace F] [TopologicalAddGroup F] (\ud835\udd16 : Set (Set E)) :\n    TopologicalSpace (E \u2192SL[\u03c3] F) :=\n  (@UniformOnFun.topologicalSpace E F (TopologicalAddGroup.toUniformSpace F) \ud835\udd16).induced\n    (FunLike.coe : (E \u2192SL[\u03c3] F) \u2192 (E \u2192\u1d64[\ud835\udd16] F))", "start": [69, 1], "end": [78, 47], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.strongUniformity", "code": "def strongUniformity [UniformSpace F] [UniformAddGroup F] (\ud835\udd16 : Set (Set E)) :\n    UniformSpace (E \u2192SL[\u03c3] F) :=\n  @UniformSpace.replaceTopology _ (strongTopology \u03c3 F \ud835\udd16)\n    ((UniformOnFun.uniformSpace E F \ud835\udd16).comap (FunLike.coe : (E \u2192SL[\u03c3] F) \u2192 (E \u2192\u1d64[\ud835\udd16] F)))\n    (by rw [strongTopology, UniformAddGroup.toUniformSpace_eq]; rfl)", "start": [81, 1], "end": [87, 69], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.strongUniformity_topology_eq", "code": "@[simp]\ntheorem strongUniformity_topology_eq [UniformSpace F] [UniformAddGroup F] (\ud835\udd16 : Set (Set E)) :\n    (strongUniformity \u03c3 F \ud835\udd16).toTopologicalSpace = strongTopology \u03c3 F \ud835\udd16", "start": [90, 1], "end": [93, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.strongUniformity.uniformEmbedding_coeFn", "code": "theorem strongUniformity.uniformEmbedding_coeFn [UniformSpace F] [UniformAddGroup F]\n    (\ud835\udd16 : Set (Set E)) :\n    @UniformEmbedding (E \u2192SL[\u03c3] F) (E \u2192\u1d64[\ud835\udd16] F) (strongUniformity \u03c3 F \ud835\udd16)\n      (UniformOnFun.uniformSpace E F \ud835\udd16) FunLike.coe", "start": [96, 1], "end": [101, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.strongTopology.embedding_coeFn", "code": "theorem strongTopology.embedding_coeFn [UniformSpace F] [UniformAddGroup F] (\ud835\udd16 : Set (Set E)) :\n    @Embedding (E \u2192SL[\u03c3] F) (E \u2192\u1d64[\ud835\udd16] F) (strongTopology \u03c3 F \ud835\udd16)\n    (UniformOnFun.topologicalSpace E F \ud835\udd16) (UniformOnFun.ofFun \ud835\udd16 \u2218 FunLike.coe)", "start": [104, 1], "end": [107, 100], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.strongUniformity.uniformAddGroup", "code": "theorem strongUniformity.uniformAddGroup [UniformSpace F] [UniformAddGroup F] (\ud835\udd16 : Set (Set E)) :\n    @UniformAddGroup (E \u2192SL[\u03c3] F) (strongUniformity \u03c3 F \ud835\udd16) _", "start": [110, 1], "end": [116, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.strongTopology.topologicalAddGroup", "code": "theorem strongTopology.topologicalAddGroup [TopologicalSpace F] [TopologicalAddGroup F]\n    (\ud835\udd16 : Set (Set E)) : @TopologicalAddGroup (E \u2192SL[\u03c3] F) (strongTopology \u03c3 F \ud835\udd16) _", "start": [119, 1], "end": [125, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.strongTopology.t2Space", "code": "theorem strongTopology.t2Space [TopologicalSpace F] [TopologicalAddGroup F] [T2Space F]\n    (\ud835\udd16 : Set (Set E)) (h\ud835\udd16 : \u22c3\u2080 \ud835\udd16 = Set.univ) : @T2Space (E \u2192SL[\u03c3] F) (strongTopology \u03c3 F \ud835\udd16)", "start": [128, 1], "end": [134, 55], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.strongTopology.continuousSMul", "code": "theorem strongTopology.continuousSMul [RingHomSurjective \u03c3] [RingHomIsometric \u03c3]\n    [TopologicalSpace F] [TopologicalAddGroup F] [ContinuousSMul \ud835\udd5c\u2082 F] (\ud835\udd16 : Set (Set E))\n    (h\ud835\udd16\u2081 : \ud835\udd16.Nonempty) (h\ud835\udd16\u2082 : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16)\n    (h\ud835\udd16\u2083 : \u2200 S \u2208 \ud835\udd16, Bornology.IsVonNBounded \ud835\udd5c\u2081 S) :\n    @ContinuousSMul \ud835\udd5c\u2082 (E \u2192SL[\u03c3] F) _ _ (strongTopology \u03c3 F \ud835\udd16)", "start": [137, 1], "end": [149, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.strongTopology.hasBasis_nhds_zero_of_basis", "code": "theorem strongTopology.hasBasis_nhds_zero_of_basis [TopologicalSpace F] [TopologicalAddGroup F]\n    {\u03b9 : Type*} (\ud835\udd16 : Set (Set E)) (h\ud835\udd16\u2081 : \ud835\udd16.Nonempty) (h\ud835\udd16\u2082 : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16) {p : \u03b9 \u2192 Prop}\n    {b : \u03b9 \u2192 Set F} (h : (\ud835\udcdd 0 : Filter F).HasBasis p b) :\n    (@nhds (E \u2192SL[\u03c3] F) (strongTopology \u03c3 F \ud835\udd16) 0).HasBasis\n      (fun Si : Set E \u00d7 \u03b9 => Si.1 \u2208 \ud835\udd16 \u2227 p Si.2)\n      fun Si => { f : E \u2192SL[\u03c3] F | \u2200 x \u2208 Si.1, f x \u2208 b Si.2 }", "start": [152, 1], "end": [164, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.strongTopology.hasBasis_nhds_zero", "code": "theorem strongTopology.hasBasis_nhds_zero [TopologicalSpace F] [TopologicalAddGroup F]\n    (\ud835\udd16 : Set (Set E)) (h\ud835\udd16\u2081 : \ud835\udd16.Nonempty) (h\ud835\udd16\u2082 : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16) :\n    (@nhds (E \u2192SL[\u03c3] F) (strongTopology \u03c3 F \ud835\udd16) 0).HasBasis\n      (fun SV : Set E \u00d7 Set F => SV.1 \u2208 \ud835\udd16 \u2227 SV.2 \u2208 (\ud835\udcdd 0 : Filter F)) fun SV =>\n      { f : E \u2192SL[\u03c3] F | \u2200 x \u2208 SV.1, f x \u2208 SV.2 }", "start": [167, 1], "end": [172, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.topologicalSpace", "code": "instance topologicalSpace [TopologicalSpace F] [TopologicalAddGroup F] :\n    TopologicalSpace (E \u2192SL[\u03c3] F) :=\n  strongTopology \u03c3 F { S | Bornology.IsVonNBounded \ud835\udd5c\u2081 S }", "start": [184, 1], "end": [188, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.topologicalAddGroup", "code": "instance topologicalAddGroup [TopologicalSpace F] [TopologicalAddGroup F] :\n    TopologicalAddGroup (E \u2192SL[\u03c3] F) :=\n  strongTopology.topologicalAddGroup \u03c3 F _", "start": [190, 1], "end": [192, 43], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.continuousSMul", "code": "instance continuousSMul [RingHomSurjective \u03c3] [RingHomIsometric \u03c3] [TopologicalSpace F]\n    [TopologicalAddGroup F] [ContinuousSMul \ud835\udd5c\u2082 F] : ContinuousSMul \ud835\udd5c\u2082 (E \u2192SL[\u03c3] F) :=\n  strongTopology.continuousSMul \u03c3 F { S | Bornology.IsVonNBounded \ud835\udd5c\u2081 S }\n    \u27e8\u2205, Bornology.isVonNBounded_empty \ud835\udd5c\u2081 E\u27e9\n    (directedOn_of_sup_mem fun _ _ => Bornology.IsVonNBounded.union) fun _ hs => hs", "start": [194, 1], "end": [198, 84], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.uniformSpace", "code": "instance uniformSpace [UniformSpace F] [UniformAddGroup F] : UniformSpace (E \u2192SL[\u03c3] F) :=\n  strongUniformity \u03c3 F { S | Bornology.IsVonNBounded \ud835\udd5c\u2081 S }", "start": [200, 1], "end": [201, 60], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.uniformAddGroup", "code": "instance uniformAddGroup [UniformSpace F] [UniformAddGroup F] : UniformAddGroup (E \u2192SL[\u03c3] F) :=\n  strongUniformity.uniformAddGroup \u03c3 F _", "start": [203, 1], "end": [204, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.hasBasis_nhds_zero_of_basis", "code": "protected theorem hasBasis_nhds_zero_of_basis [TopologicalSpace F] [TopologicalAddGroup F]\n    {\u03b9 : Type*} {p : \u03b9 \u2192 Prop} {b : \u03b9 \u2192 Set F} (h : (\ud835\udcdd 0 : Filter F).HasBasis p b) :\n    (\ud835\udcdd (0 : E \u2192SL[\u03c3] F)).HasBasis (fun Si : Set E \u00d7 \u03b9 => Bornology.IsVonNBounded \ud835\udd5c\u2081 Si.1 \u2227 p Si.2)\n      fun Si => { f : E \u2192SL[\u03c3] F | \u2200 x \u2208 Si.1, f x \u2208 b Si.2 }", "start": [212, 1], "end": [218, 71], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.hasBasis_nhds_zero", "code": "protected theorem hasBasis_nhds_zero [TopologicalSpace F] [TopologicalAddGroup F] :\n    (\ud835\udcdd (0 : E \u2192SL[\u03c3] F)).HasBasis\n      (fun SV : Set E \u00d7 Set F => Bornology.IsVonNBounded \ud835\udd5c\u2081 SV.1 \u2227 SV.2 \u2208 (\ud835\udcdd 0 : Filter F))\n      fun SV => { f : E \u2192SL[\u03c3] F | \u2200 x \u2208 SV.1, f x \u2208 SV.2 }", "start": [221, 1], "end": [225, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.precomp", "code": "@[simps]\ndef precomp [TopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c\u2083 G] [RingHomSurjective \u03c3]\n    [RingHomIsometric \u03c3] (L : E \u2192SL[\u03c3] F) : (F \u2192SL[\u03c4] G) \u2192L[\ud835\udd5c\u2083] E \u2192SL[\u03c1] G\n    where\n  toFun f := f.comp L\n  map_add' f g := add_comp f g L\n  map_smul' a f := smul_comp a f L\n  cont := by\n    letI : UniformSpace G := TopologicalAddGroup.toUniformSpace G\n    haveI : UniformAddGroup G := comm_topologicalAddGroup_is_uniform\n    rw [(strongTopology.embedding_coeFn _ _ _).continuous_iff]\n    change Continuous ((\u03bb f \u21a6 UniformOnFun.ofFun _ (f \u2218 L)) \u2218 FunLike.coe)\n    exact (UniformOnFun.precomp_uniformContinuous fun S hS => hS.image L).continuous.comp\n        (strongTopology.embedding_coeFn _ _ _).continuous", "start": [230, 1], "end": [247, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.postcomp", "code": "@[simps]\ndef postcomp [TopologicalAddGroup F] [TopologicalAddGroup G] [ContinuousConstSMul \ud835\udd5c\u2083 G]\n    [ContinuousConstSMul \ud835\udd5c\u2082 F] (L : F \u2192SL[\u03c4] G) : (E \u2192SL[\u03c3] F) \u2192SL[\u03c4] E \u2192SL[\u03c1] G\n    where\n  toFun f := L.comp f\n  map_add' := comp_add L\n  map_smul' := comp_smul\u209b\u2097 L\n  cont := by\n    letI : UniformSpace G := TopologicalAddGroup.toUniformSpace G\n    haveI : UniformAddGroup G := comm_topologicalAddGroup_is_uniform\n    letI : UniformSpace F := TopologicalAddGroup.toUniformSpace F\n    haveI : UniformAddGroup F := comm_topologicalAddGroup_is_uniform\n    rw [(strongTopology.embedding_coeFn _ _ _).continuous_iff]\n    exact\n      (UniformOnFun.postcomp_uniformContinuous L.uniformContinuous).continuous.comp\n        (strongTopology.embedding_coeFn _ _ _).continuous", "start": [252, 1], "end": [270, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.arrowCongrSL", "code": "@[simps]\ndef arrowCongrSL (e\u2081\u2082 : E \u2243SL[\u03c3\u2081\u2082] F) (e\u2084\u2083 : H \u2243SL[\u03c3\u2084\u2083] G) :\n    (E \u2192SL[\u03c3\u2081\u2084] H) \u2243SL[\u03c3\u2084\u2083] F \u2192SL[\u03c3\u2082\u2083] G :=\n{ e\u2081\u2082.arrowCongrEquiv e\u2084\u2083 with\n    toFun := fun L => (e\u2084\u2083 : H \u2192SL[\u03c3\u2084\u2083] G).comp (L.comp (e\u2081\u2082.symm : F \u2192SL[\u03c3\u2082\u2081] E))\n    invFun := fun L => (e\u2084\u2083.symm : G \u2192SL[\u03c3\u2083\u2084] H).comp (L.comp (e\u2081\u2082 : E \u2192SL[\u03c3\u2081\u2082] F))\n    map_add' := fun f g => by simp only [add_comp, comp_add]\n    map_smul' := fun t f => by simp only [smul_comp, comp_smul\u209b\u2097]\n    continuous_toFun := ((postcomp F e\u2084\u2083.toContinuousLinearMap).comp\n      (precomp H e\u2081\u2082.symm.toContinuousLinearMap)).continuous\n    continuous_invFun := ((precomp H e\u2081\u2082.toContinuousLinearMap).comp\n      (postcomp F e\u2084\u2083.symm.toContinuousLinearMap)).continuous }", "start": [296, 1], "end": [311, 64], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.arrowCongrSL_toLinearEquiv_apply", "code": "theorem arrowCongrSL_toLinearEquiv_apply (e\u2081\u2082 : E \u2243SL[\u03c3\u2081\u2082] F) (e\u2084\u2083 : H \u2243SL[\u03c3\u2084\u2083] G)\n    (L : E \u2192SL[\u03c3\u2081\u2084] H) : (e\u2081\u2082.arrowCongrSL e\u2084\u2083).toLinearEquiv L =\n      (e\u2084\u2083 : H \u2192SL[\u03c3\u2084\u2083] G).comp (L.comp (e\u2081\u2082.symm : F \u2192SL[\u03c3\u2082\u2081] E))", "start": [322, 1], "end": [325, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.arrowCongrSL_toLinearEquiv_symm_apply", "code": "@[simp]\ntheorem arrowCongrSL_toLinearEquiv_symm_apply (e\u2081\u2082 : E \u2243SL[\u03c3\u2081\u2082] F) (e\u2084\u2083 : H \u2243SL[\u03c3\u2084\u2083] G)\n    (L : F \u2192SL[\u03c3\u2082\u2083] G) : (e\u2081\u2082.arrowCongrSL e\u2084\u2083).toLinearEquiv.symm L =\n      (e\u2084\u2083.symm : G \u2192SL[\u03c3\u2083\u2084] H).comp (L.comp (e\u2081\u2082 : E \u2192SL[\u03c3\u2081\u2082] F))", "start": [329, 1], "end": [333, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.arrowCongr", "code": "def arrowCongr (e\u2081 : E \u2243L[\ud835\udd5c] F) (e\u2082 : H \u2243L[\ud835\udd5c] G) : (E \u2192L[\ud835\udd5c] H) \u2243L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G :=\n  e\u2081.arrowCongrSL e\u2082", "start": [347, 1], "end": [350, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.arg", "code": "noncomputable def arg (x : \u2102) : \u211d :=\n  if 0 \u2264 x.re then Real.arcsin (x.im / abs x)\n  else if 0 \u2264 x.im then Real.arcsin ((-x).im / abs x) + \u03c0 else Real.arcsin ((-x).im / abs x) - \u03c0", "start": [28, 1], "end": [33, 97], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_arg", "code": "theorem sin_arg (x : \u2102) : Real.sin (arg x) = x.im / abs x", "start": [36, 1], "end": [40, 60], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_arg", "code": "theorem cos_arg {x : \u2102} (hx : x \u2260 0) : Real.cos (arg x) = x.re / abs x", "start": [43, 1], "end": [53, 42], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_mul_exp_arg_mul_I", "code": "@[simp]\ntheorem abs_mul_exp_arg_mul_I (x : \u2102) : \u2191(abs x) * exp (arg x * I) = x", "start": [56, 1], "end": [61, 69], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_mul_cos_add_sin_mul_I", "code": "@[simp]\ntheorem abs_mul_cos_add_sin_mul_I (x : \u2102) : (abs x * (cos (arg x) + sin (arg x) * I) : \u2102) = x", "start": [65, 1], "end": [67, 42], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_eq_one_iff", "code": "theorem abs_eq_one_iff (z : \u2102) : abs z = 1 \u2194 \u2203 \u03b8 : \u211d, exp (\u03b8 * I) = z", "start": [71, 1], "end": [78, 41], "kind": "commanddeclaration"}, {"full_name": "Complex.range_exp_mul_I", "code": "@[simp]\ntheorem range_exp_mul_I : (Set.range fun x : \u211d => exp (x * I)) = Metric.sphere 0 1", "start": [81, 1], "end": [84, 83], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_mul_cos_add_sin_mul_I", "code": "theorem arg_mul_cos_add_sin_mul_I {r : \u211d} (hr : 0 < r) {\u03b8 : \u211d} (h\u03b8 : \u03b8 \u2208 Set.Ioc (-\u03c0) \u03c0) :\n    arg (r * (cos \u03b8 + sin \u03b8 * I)) = \u03b8", "start": [88, 1], "end": [109, 49], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_cos_add_sin_mul_I", "code": "theorem arg_cos_add_sin_mul_I {\u03b8 : \u211d} (h\u03b8 : \u03b8 \u2208 Set.Ioc (-\u03c0) \u03c0) : arg (cos \u03b8 + sin \u03b8 * I) = \u03b8", "start": [113, 1], "end": [114, 81], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_zero", "code": "@[simp]\ntheorem arg_zero : arg 0 = 0", "start": [118, 1], "end": [119, 55], "kind": "commanddeclaration"}, {"full_name": "Complex.ext_abs_arg", "code": "theorem ext_abs_arg {x y : \u2102} (h\u2081 : abs x = abs y) (h\u2082 : x.arg = y.arg) : x = y", "start": [122, 1], "end": [123, 68], "kind": "commanddeclaration"}, {"full_name": "Complex.ext_abs_arg_iff", "code": "theorem ext_abs_arg_iff {x y : \u2102} : x = y \u2194 abs x = abs y \u2227 arg x = arg y", "start": [126, 1], "end": [127, 51], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_mem_Ioc", "code": "theorem arg_mem_Ioc (z : \u2102) : arg z \u2208 Set.Ioc (-\u03c0) \u03c0", "start": [130, 1], "end": [139, 13], "kind": "commanddeclaration"}, {"full_name": "Complex.range_arg", "code": "@[simp]\ntheorem range_arg : Set.range arg = Set.Ioc (-\u03c0) \u03c0", "start": [142, 1], "end": [144, 90], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_le_pi", "code": "theorem arg_le_pi (x : \u2102) : arg x \u2264 \u03c0", "start": [147, 1], "end": [148, 20], "kind": "commanddeclaration"}, {"full_name": "Complex.neg_pi_lt_arg", "code": "theorem neg_pi_lt_arg (x : \u2102) : -\u03c0 < arg x", "start": [151, 1], "end": [152, 20], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_arg_le_pi", "code": "theorem abs_arg_le_pi (z : \u2102) : |arg z| \u2264 \u03c0", "start": [155, 1], "end": [156, 47], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_nonneg_iff", "code": "@[simp]\ntheorem arg_nonneg_iff {z : \u2102} : 0 \u2264 arg z \u2194 0 \u2264 z.im", "start": [159, 1], "end": [168, 64], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_neg_iff", "code": "@[simp]\ntheorem arg_neg_iff {z : \u2102} : arg z < 0 \u2194 z.im < 0", "start": [172, 1], "end": [174, 40], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_real_mul", "code": "theorem arg_real_mul (x : \u2102) {r : \u211d} (hr : 0 < r) : arg (r * x) = arg x", "start": [177, 1], "end": [181, 73], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_eq_arg_iff", "code": "theorem arg_eq_arg_iff {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0) :\n    arg x = arg y \u2194 (abs y / abs x : \u2102) * x = y", "start": [184, 1], "end": [189, 42], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_one", "code": "@[simp]\ntheorem arg_one : arg 1 = 0", "start": [192, 1], "end": [193, 58], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_neg_one", "code": "@[simp]\ntheorem arg_neg_one : arg (-1) = \u03c0", "start": [196, 1], "end": [197, 88], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_I", "code": "@[simp]\ntheorem arg_I : arg I = \u03c0 / 2", "start": [200, 1], "end": [201, 56], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_neg_I", "code": "@[simp]\ntheorem arg_neg_I : arg (-I) = -(\u03c0 / 2)", "start": [205, 1], "end": [206, 66], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_arg", "code": "@[simp]\ntheorem tan_arg (x : \u2102) : Real.tan (arg x) = x.im / x.re", "start": [210, 1], "end": [214, 95], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_ofReal_of_nonneg", "code": "theorem arg_ofReal_of_nonneg {x : \u211d} (hx : 0 \u2264 x) : arg x = 0", "start": [217, 1], "end": [217, 83], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_eq_zero_iff", "code": "theorem arg_eq_zero_iff {z : \u2102} : arg z = 0 \u2194 0 \u2264 z.re \u2227 z.im = 0", "start": [220, 1], "end": [226, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_eq_pi_iff", "code": "theorem arg_eq_pi_iff {z : \u2102} : arg z = \u03c0 \u2194 z.re < 0 \u2227 z.im = 0", "start": [229, 1], "end": [238, 24], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_lt_pi_iff", "code": "theorem arg_lt_pi_iff {z : \u2102} : arg z < \u03c0 \u2194 0 \u2264 z.re \u2228 z.im \u2260 0", "start": [241, 1], "end": [242, 95], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_ofReal_of_neg", "code": "theorem arg_ofReal_of_neg {x : \u211d} (hx : x < 0) : arg x = \u03c0", "start": [245, 1], "end": [246, 28], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_eq_pi_div_two_iff", "code": "theorem arg_eq_pi_div_two_iff {z : \u2102} : arg z = \u03c0 / 2 \u2194 z.re = 0 \u2227 0 < z.im", "start": [249, 1], "end": [257, 82], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_eq_neg_pi_div_two_iff", "code": "theorem arg_eq_neg_pi_div_two_iff {z : \u2102} : arg z = -(\u03c0 / 2) \u2194 z.re = 0 \u2227 z.im < 0", "start": [260, 1], "end": [269, 9], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_of_re_nonneg", "code": "theorem arg_of_re_nonneg {x : \u2102} (hx : 0 \u2264 x.re) : arg x = Real.arcsin (x.im / abs x)", "start": [272, 1], "end": [273, 12], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_of_re_neg_of_im_nonneg", "code": "theorem arg_of_re_neg_of_im_nonneg {x : \u2102} (hx_re : x.re < 0) (hx_im : 0 \u2264 x.im) :\n    arg x = Real.arcsin ((-x).im / abs x) + \u03c0", "start": [276, 1], "end": [278, 58], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_of_re_neg_of_im_neg", "code": "theorem arg_of_re_neg_of_im_neg {x : \u2102} (hx_re : x.re < 0) (hx_im : x.im < 0) :\n    arg x = Real.arcsin ((-x).im / abs x) - \u03c0", "start": [281, 1], "end": [283, 56], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_of_im_nonneg_of_ne_zero", "code": "theorem arg_of_im_nonneg_of_ne_zero {z : \u2102} (h\u2081 : 0 \u2264 z.im) (h\u2082 : z \u2260 0) :\n    arg z = Real.arccos (z.re / abs z)", "start": [286, 1], "end": [288, 73], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_of_im_pos", "code": "theorem arg_of_im_pos {z : \u2102} (hz : 0 < z.im) : arg z = Real.arccos (z.re / abs z)", "start": [291, 1], "end": [292, 68], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_of_im_neg", "code": "theorem arg_of_im_neg {z : \u2102} (hz : z.im < 0) : arg z = -Real.arccos (z.re / abs z)", "start": [295, 1], "end": [298, 77], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_conj", "code": "theorem arg_conj (x : \u2102) : arg (conj x) = if arg x = \u03c0 then \u03c0 else -arg x", "start": [301, 1], "end": [314, 35], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_inv", "code": "theorem arg_inv (x : \u2102) : arg x\u207b\u00b9 = if arg x = \u03c0 then \u03c0 else -arg x", "start": [317, 1], "end": [321, 47], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_le_pi_div_two_iff", "code": "theorem arg_le_pi_div_two_iff {z : \u2102} : arg z \u2264 \u03c0 / 2 \u2194 0 \u2264 re z \u2228 im z < 0", "start": [324, 1], "end": [336, 77], "kind": "commanddeclaration"}, {"full_name": "Complex.neg_pi_div_two_le_arg_iff", "code": "theorem neg_pi_div_two_le_arg_iff {z : \u2102} : -(\u03c0 / 2) \u2264 arg z \u2194 0 \u2264 re z \u2228 0 \u2264 im z", "start": [339, 1], "end": [351, 57], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_arg_le_pi_div_two_iff", "code": "@[simp]\ntheorem abs_arg_le_pi_div_two_iff {z : \u2102} : |arg z| \u2264 \u03c0 / 2 \u2194 0 \u2264 re z", "start": [354, 1], "end": [357, 36], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_conj_coe_angle", "code": "@[simp]\ntheorem arg_conj_coe_angle (x : \u2102) : (arg (conj x) : Real.Angle) = -arg x", "start": [360, 1], "end": [362, 48], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_inv_coe_angle", "code": "@[simp]\ntheorem arg_inv_coe_angle (x : \u2102) : (arg x\u207b\u00b9 : Real.Angle) = -arg x", "start": [365, 1], "end": [367, 47], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_neg_eq_arg_sub_pi_of_im_pos", "code": "theorem arg_neg_eq_arg_sub_pi_of_im_pos {x : \u2102} (hi : 0 < x.im) : arg (-x) = arg x - \u03c0", "start": [370, 1], "end": [372, 34], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_neg_eq_arg_add_pi_of_im_neg", "code": "theorem arg_neg_eq_arg_add_pi_of_im_neg {x : \u2102} (hi : x.im < 0) : arg (-x) = arg x + \u03c0", "start": [375, 1], "end": [377, 62], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_neg_eq_arg_sub_pi_iff", "code": "theorem arg_neg_eq_arg_sub_pi_iff {x : \u2102} :\n    arg (-x) = arg x - \u03c0 \u2194 0 < x.im \u2228 x.im = 0 \u2227 x.re < 0", "start": [380, 1], "end": [392, 47], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_neg_eq_arg_add_pi_iff", "code": "theorem arg_neg_eq_arg_add_pi_iff {x : \u2102} :\n    arg (-x) = arg x + \u03c0 \u2194 x.im < 0 \u2228 x.im = 0 \u2227 0 < x.re", "start": [395, 1], "end": [407, 47], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_neg_coe_angle", "code": "theorem arg_neg_coe_angle {x : \u2102} (hx : x \u2260 0) : (arg (-x) : Real.Angle) = arg x + \u03c0", "start": [410, 1], "end": [420, 101], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_mul_cos_add_sin_mul_I_eq_toIocMod", "code": "theorem arg_mul_cos_add_sin_mul_I_eq_toIocMod {r : \u211d} (hr : 0 < r) (\u03b8 : \u211d) :\n    arg (r * (cos \u03b8 + sin \u03b8 * I)) = toIocMod Real.two_pi_pos (-\u03c0) \u03b8", "start": [423, 1], "end": [429, 66], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_cos_add_sin_mul_I_eq_toIocMod", "code": "theorem arg_cos_add_sin_mul_I_eq_toIocMod (\u03b8 : \u211d) :\n    arg (cos \u03b8 + sin \u03b8 * I) = toIocMod Real.two_pi_pos (-\u03c0) \u03b8", "start": [433, 1], "end": [435, 90], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_mul_cos_add_sin_mul_I_sub", "code": "theorem arg_mul_cos_add_sin_mul_I_sub {r : \u211d} (hr : 0 < r) (\u03b8 : \u211d) :\n    arg (r * (cos \u03b8 + sin \u03b8 * I)) - \u03b8 = 2 * \u03c0 * \u230a(\u03c0 - \u03b8) / (2 * \u03c0)\u230b", "start": [439, 1], "end": [443, 10], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_cos_add_sin_mul_I_sub", "code": "theorem arg_cos_add_sin_mul_I_sub (\u03b8 : \u211d) :\n    arg (cos \u03b8 + sin \u03b8 * I) - \u03b8 = 2 * \u03c0 * \u230a(\u03c0 - \u03b8) / (2 * \u03c0)\u230b", "start": [447, 1], "end": [449, 82], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_mul_cos_add_sin_mul_I_coe_angle", "code": "theorem arg_mul_cos_add_sin_mul_I_coe_angle {r : \u211d} (hr : 0 < r) (\u03b8 : Real.Angle) :\n    (arg (r * (Real.Angle.cos \u03b8 + Real.Angle.sin \u03b8 * I)) : Real.Angle) = \u03b8", "start": [453, 1], "end": [458, 52], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_cos_add_sin_mul_I_coe_angle", "code": "theorem arg_cos_add_sin_mul_I_coe_angle (\u03b8 : Real.Angle) :\n    (arg (Real.Angle.cos \u03b8 + Real.Angle.sin \u03b8 * I) : Real.Angle) = \u03b8", "start": [462, 1], "end": [464, 88], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_mul_coe_angle", "code": "theorem arg_mul_coe_angle {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0) :\n    (arg (x * y) : Real.Angle) = arg x + arg y", "start": [468, 1], "end": [476, 38], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_div_coe_angle", "code": "theorem arg_div_coe_angle {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0) :\n    (arg (x / y) : Real.Angle) = arg x - arg y", "start": [479, 1], "end": [481, 96], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_coe_angle_toReal_eq_arg", "code": "@[simp]\ntheorem arg_coe_angle_toReal_eq_arg (z : \u2102) : (arg z : Real.Angle).toReal = arg z", "start": [484, 1], "end": [487, 22], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_coe_angle_eq_iff_eq_toReal", "code": "theorem arg_coe_angle_eq_iff_eq_toReal {z : \u2102} {\u03b8 : Real.Angle} :\n    (arg z : Real.Angle) = \u03b8 \u2194 arg z = \u03b8.toReal", "start": [490, 1], "end": [492, 60], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_coe_angle_eq_iff", "code": "@[simp]\ntheorem arg_coe_angle_eq_iff {x y : \u2102} : (arg x : Real.Angle) = arg y \u2194 arg x = arg y", "start": [495, 1], "end": [497, 65], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_eq_nhds_of_re_pos", "code": "theorem arg_eq_nhds_of_re_pos (hx : 0 < x.re) : arg =\u1da0[\ud835\udcdd x] fun x => Real.arcsin (x.im / abs x)", "start": [504, 1], "end": [505, 98], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_eq_nhds_of_re_neg_of_im_pos", "code": "theorem arg_eq_nhds_of_re_neg_of_im_pos (hx_re : x.re < 0) (hx_im : 0 < x.im) :\n    arg =\u1da0[\ud835\udcdd x] fun x => Real.arcsin ((-x).im / abs x) + \u03c0", "start": [508, 1], "end": [514, 99], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_eq_nhds_of_re_neg_of_im_neg", "code": "theorem arg_eq_nhds_of_re_neg_of_im_neg (hx_re : x.re < 0) (hx_im : x.im < 0) :\n    arg =\u1da0[\ud835\udcdd x] fun x => Real.arcsin ((-x).im / abs x) - \u03c0", "start": [517, 1], "end": [523, 99], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_eq_nhds_of_im_pos", "code": "theorem arg_eq_nhds_of_im_pos (hz : 0 < im z) : arg =\u1da0[\ud835\udcdd z] fun x => Real.arccos (x.re / abs x)", "start": [526, 1], "end": [527, 86], "kind": "commanddeclaration"}, {"full_name": "Complex.arg_eq_nhds_of_im_neg", "code": "theorem arg_eq_nhds_of_im_neg (hz : im z < 0) : arg =\u1da0[\ud835\udcdd z] fun x => -Real.arccos (x.re / abs x)", "start": [530, 1], "end": [531, 86], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousAt_arg", "code": "theorem continuousAt_arg (h : 0 < x.re \u2228 x.im \u2260 0) : ContinuousAt arg x", "start": [534, 1], "end": [549, 42], "kind": "commanddeclaration"}, {"full_name": "Complex.tendsto_arg_nhdsWithin_im_neg_of_re_neg_of_im_zero", "code": "theorem tendsto_arg_nhdsWithin_im_neg_of_re_neg_of_im_zero {z : \u2102} (hre : z.re < 0)\n    (him : z.im = 0) : Tendsto arg (\ud835\udcdd[{ z : \u2102 | z.im < 0 }] z) (\ud835\udcdd (-\u03c0))", "start": [552, 1], "end": [570, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousWithinAt_arg_of_re_neg_of_im_zero", "code": "theorem continuousWithinAt_arg_of_re_neg_of_im_zero {z : \u2102} (hre : z.re < 0) (him : z.im = 0) :\n    ContinuousWithinAt arg { z : \u2102 | 0 \u2264 z.im } z", "start": [574, 1], "end": [589, 47], "kind": "commanddeclaration"}, {"full_name": "Complex.tendsto_arg_nhdsWithin_im_nonneg_of_re_neg_of_im_zero", "code": "theorem tendsto_arg_nhdsWithin_im_nonneg_of_re_neg_of_im_zero {z : \u2102} (hre : z.re < 0)\n    (him : z.im = 0) : Tendsto arg (\ud835\udcdd[{ z : \u2102 | 0 \u2264 z.im }] z) (\ud835\udcdd \u03c0)", "start": [592, 1], "end": [595, 66], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousAt_arg_coe_angle", "code": "theorem continuousAt_arg_coe_angle (h : x \u2260 0) : ContinuousAt ((\u2191) \u2218 arg : \u2102 \u2192 Real.Angle) x", "start": [599, 1], "end": [619, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Exp.lean", "Mathlib/Data/Nat/Factorization/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.log", "code": "noncomputable def log (x : \u211d) : \u211d :=\n  if hx : x = 0 then 0 else expOrderIso.symm \u27e8|x|, abs_pos.2 hx\u27e9", "start": [38, 1], "end": [44, 65], "kind": "commanddeclaration"}, {"full_name": "Real.log_of_ne_zero", "code": "theorem log_of_ne_zero (hx : x \u2260 0) : log x = expOrderIso.symm \u27e8|x|, abs_pos.2 hx\u27e9", "start": [47, 1], "end": [48, 13], "kind": "commanddeclaration"}, {"full_name": "Real.log_of_pos", "code": "theorem log_of_pos (hx : 0 < x) : log x = expOrderIso.symm \u27e8x, hx\u27e9", "start": [51, 1], "end": [54, 22], "kind": "commanddeclaration"}, {"full_name": "Real.exp_log_eq_abs", "code": "theorem exp_log_eq_abs (hx : x \u2260 0) : exp (log x) = |x|", "start": [57, 1], "end": [58, 93], "kind": "commanddeclaration"}, {"full_name": "Real.exp_log", "code": "theorem exp_log (hx : 0 < x) : exp (log x) = x", "start": [61, 1], "end": [63, 22], "kind": "commanddeclaration"}, {"full_name": "Real.exp_log_of_neg", "code": "theorem exp_log_of_neg (hx : x < 0) : exp (log x) = -x", "start": [66, 1], "end": [68, 22], "kind": "commanddeclaration"}, {"full_name": "Real.le_exp_log", "code": "theorem le_exp_log (x : \u211d) : x \u2264 exp (log x)", "start": [71, 1], "end": [76, 24], "kind": "commanddeclaration"}, {"full_name": "Real.log_exp", "code": "@[simp]\ntheorem log_exp (x : \u211d) : log (exp x) = x", "start": [79, 1], "end": [81, 39], "kind": "commanddeclaration"}, {"full_name": "Real.surjOn_log", "code": "theorem surjOn_log : SurjOn log (Ioi 0) univ", "start": [84, 1], "end": [84, 89], "kind": "commanddeclaration"}, {"full_name": "Real.log_surjective", "code": "theorem log_surjective : Surjective log", "start": [87, 1], "end": [87, 71], "kind": "commanddeclaration"}, {"full_name": "Real.range_log", "code": "@[simp]\ntheorem range_log : range log = univ", "start": [90, 1], "end": [92, 26], "kind": "commanddeclaration"}, {"full_name": "Real.log_zero", "code": "@[simp]\ntheorem log_zero : log 0 = 0", "start": [95, 1], "end": [97, 14], "kind": "commanddeclaration"}, {"full_name": "Real.log_one", "code": "@[simp]\ntheorem log_one : log 1 = 0", "start": [100, 1], "end": [102, 57], "kind": "commanddeclaration"}, {"full_name": "Real.log_abs", "code": "@[simp]\ntheorem log_abs (x : \u211d) : log |x| = log x", "start": [105, 1], "end": [109, 83], "kind": "commanddeclaration"}, {"full_name": "Real.log_neg_eq_log", "code": "@[simp]\ntheorem log_neg_eq_log (x : \u211d) : log (-x) = log x", "start": [112, 1], "end": [113, 98], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_log", "code": "theorem sinh_log {x : \u211d} (hx : 0 < x) : sinh (log x) = (x - x\u207b\u00b9) / 2", "start": [116, 1], "end": [117, 36], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_log", "code": "theorem cosh_log {x : \u211d} (hx : 0 < x) : cosh (log x) = (x + x\u207b\u00b9) / 2", "start": [120, 1], "end": [121, 36], "kind": "commanddeclaration"}, {"full_name": "Real.surjOn_log'", "code": "theorem surjOn_log' : SurjOn log (Iio 0) univ", "start": [124, 1], "end": [125, 72], "kind": "commanddeclaration"}, {"full_name": "Real.log_mul", "code": "theorem log_mul (hx : x \u2260 0) (hy : y \u2260 0) : log (x * y) = log x + log y", "start": [128, 1], "end": [130, 100], "kind": "commanddeclaration"}, {"full_name": "Real.log_div", "code": "theorem log_div (hx : x \u2260 0) (hy : y \u2260 0) : log (x / y) = log x - log y", "start": [133, 1], "end": [135, 100], "kind": "commanddeclaration"}, {"full_name": "Real.log_inv", "code": "@[simp]\ntheorem log_inv (x : \u211d) : log x\u207b\u00b9 = -log x", "start": [138, 1], "end": [141, 90], "kind": "commanddeclaration"}, {"full_name": "Real.log_le_log", "code": "theorem log_le_log (h : 0 < x) (h\u2081 : 0 < y) : log x \u2264 log y \u2194 x \u2264 y", "start": [144, 1], "end": [145, 43], "kind": "commanddeclaration"}, {"full_name": "Real.log_lt_log", "code": "@[gcongr]\ntheorem log_lt_log (hx : 0 < x) : x < y \u2192 log x < log y", "start": [148, 1], "end": [151, 58], "kind": "commanddeclaration"}, {"full_name": "Real.log_le_log'", "code": "@[gcongr]\ntheorem log_le_log' (hx : 0 < x) : x \u2264 y \u2192 log x \u2264 log y", "start": [154, 1], "end": [159, 51], "kind": "commanddeclaration"}, {"full_name": "Real.log_lt_log_iff", "code": "theorem log_lt_log_iff (hx : 0 < x) (hy : 0 < y) : log x < log y \u2194 x < y", "start": [161, 1], "end": [162, 44], "kind": "commanddeclaration"}, {"full_name": "Real.log_le_iff_le_exp", "code": "theorem log_le_iff_le_exp (hx : 0 < x) : log x \u2264 y \u2194 x \u2264 exp y", "start": [165, 1], "end": [165, 99], "kind": "commanddeclaration"}, {"full_name": "Real.log_lt_iff_lt_exp", "code": "theorem log_lt_iff_lt_exp (hx : 0 < x) : log x < y \u2194 x < exp y", "start": [168, 1], "end": [168, 99], "kind": "commanddeclaration"}, {"full_name": "Real.le_log_iff_exp_le", "code": "theorem le_log_iff_exp_le (hy : 0 < y) : x \u2264 log y \u2194 exp x \u2264 y", "start": [171, 1], "end": [171, 99], "kind": "commanddeclaration"}, {"full_name": "Real.lt_log_iff_exp_lt", "code": "theorem lt_log_iff_exp_lt (hy : 0 < y) : x < log y \u2194 exp x < y", "start": [174, 1], "end": [174, 99], "kind": "commanddeclaration"}, {"full_name": "Real.log_pos_iff", "code": "theorem log_pos_iff (hx : 0 < x) : 0 < log x \u2194 1 < x", "start": [177, 1], "end": [179, 38], "kind": "commanddeclaration"}, {"full_name": "Real.log_pos", "code": "theorem log_pos (hx : 1 < x) : 0 < log x", "start": [182, 1], "end": [183, 47], "kind": "commanddeclaration"}, {"full_name": "Real.log_pos_of_lt_neg_one", "code": "theorem log_pos_of_lt_neg_one (hx : x < -1) : 0 < log x", "start": [186, 1], "end": [189, 21], "kind": "commanddeclaration"}, {"full_name": "Real.log_neg_iff", "code": "theorem log_neg_iff (h : 0 < x) : log x < 0 \u2194 x < 1", "start": [191, 1], "end": [193, 37], "kind": "commanddeclaration"}, {"full_name": "Real.log_neg", "code": "theorem log_neg (h0 : 0 < x) (h1 : x < 1) : log x < 0", "start": [196, 1], "end": [197, 24], "kind": "commanddeclaration"}, {"full_name": "Real.log_neg_of_lt_zero", "code": "theorem log_neg_of_lt_zero (h0 : x < 0) (h1 : -1 < x) : log x < 0", "start": [200, 1], "end": [204, 24], "kind": "commanddeclaration"}, {"full_name": "Real.log_nonneg_iff", "code": "theorem log_nonneg_iff (hx : 0 < x) : 0 \u2264 log x \u2194 1 \u2264 x", "start": [206, 1], "end": [206, 100], "kind": "commanddeclaration"}, {"full_name": "Real.log_nonneg", "code": "theorem log_nonneg (hx : 1 \u2264 x) : 0 \u2264 log x", "start": [209, 1], "end": [210, 50], "kind": "commanddeclaration"}, {"full_name": "Real.log_nonpos_iff", "code": "theorem log_nonpos_iff (hx : 0 < x) : log x \u2264 0 \u2194 x \u2264 1", "start": [213, 1], "end": [213, 100], "kind": "commanddeclaration"}, {"full_name": "Real.log_nonpos_iff'", "code": "theorem log_nonpos_iff' (hx : 0 \u2264 x) : log x \u2264 0 \u2194 x \u2264 1", "start": [216, 1], "end": [219, 26], "kind": "commanddeclaration"}, {"full_name": "Real.log_nonpos", "code": "theorem log_nonpos (hx : 0 \u2264 x) (h'x : x \u2264 1) : log x \u2264 0", "start": [222, 1], "end": [223, 29], "kind": "commanddeclaration"}, {"full_name": "Real.log_nat_cast_nonneg", "code": "theorem log_nat_cast_nonneg (n : \u2115) : 0 \u2264 log n", "start": [226, 1], "end": [231, 26], "kind": "commanddeclaration"}, {"full_name": "Real.log_neg_nat_cast_nonneg", "code": "theorem log_neg_nat_cast_nonneg (n : \u2115) : 0 \u2264 log (-n)", "start": [233, 1], "end": [235, 30], "kind": "commanddeclaration"}, {"full_name": "Real.log_int_cast_nonneg", "code": "theorem log_int_cast_nonneg (n : \u2124) : 0 \u2264 log n", "start": [237, 1], "end": [248, 32], "kind": "commanddeclaration"}, {"full_name": "Real.strictMonoOn_log", "code": "theorem strictMonoOn_log : StrictMonoOn log (Set.Ioi 0)", "start": [250, 1], "end": [250, 97], "kind": "commanddeclaration"}, {"full_name": "Real.strictAntiOn_log", "code": "theorem strictAntiOn_log : StrictAntiOn log (Set.Iio 0)", "start": [253, 1], "end": [257, 53], "kind": "commanddeclaration"}, {"full_name": "Real.log_injOn_pos", "code": "theorem log_injOn_pos : Set.InjOn log (Set.Ioi 0)", "start": [260, 1], "end": [261, 25], "kind": "commanddeclaration"}, {"full_name": "Real.log_lt_sub_one_of_pos", "code": "theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x \u2260 1) : log x < x - 1", "start": [264, 1], "end": [268, 54], "kind": "commanddeclaration"}, {"full_name": "Real.eq_one_of_pos_of_log_eq_zero", "code": "theorem eq_one_of_pos_of_log_eq_zero {x : \u211d} (h\u2081 : 0 < x) (h\u2082 : log x = 0) : x = 1", "start": [271, 1], "end": [272, 92], "kind": "commanddeclaration"}, {"full_name": "Real.log_ne_zero_of_pos_of_ne_one", "code": "theorem log_ne_zero_of_pos_of_ne_one {x : \u211d} (hx_pos : 0 < x) (hx : x \u2260 1) : log x \u2260 0", "start": [275, 1], "end": [276, 46], "kind": "commanddeclaration"}, {"full_name": "Real.log_eq_zero", "code": "@[simp]\ntheorem log_eq_zero {x : \u211d} : log x = 0 \u2194 x = 0 \u2228 x = 1 \u2228 x = -1", "start": [279, 1], "end": [289, 79], "kind": "commanddeclaration"}, {"full_name": "Real.log_ne_zero", "code": "theorem log_ne_zero {x : \u211d} : log x \u2260 0 \u2194 x \u2260 0 \u2227 x \u2260 1 \u2227 x \u2260 -1", "start": [292, 1], "end": [293, 44], "kind": "commanddeclaration"}, {"full_name": "Real.log_pow", "code": "@[simp]\ntheorem log_pow (x : \u211d) (n : \u2115) : log (x ^ n) = n * log x", "start": [296, 1], "end": [302, 85], "kind": "commanddeclaration"}, {"full_name": "Real.log_zpow", "code": "@[simp]\ntheorem log_zpow (x : \u211d) (n : \u2124) : log (x ^ n) = n * log x", "start": [305, 1], "end": [309, 94], "kind": "commanddeclaration"}, {"full_name": "Real.log_sqrt", "code": "theorem log_sqrt {x : \u211d} (hx : 0 \u2264 x) : log (sqrt x) = log x / 2", "start": [312, 1], "end": [314, 20], "kind": "commanddeclaration"}, {"full_name": "Real.log_le_sub_one_of_pos", "code": "theorem log_le_sub_one_of_pos {x : \u211d} (hx : 0 < x) : log x \u2264 x - 1", "start": [317, 1], "end": [320, 18], "kind": "commanddeclaration"}, {"full_name": "Real.abs_log_mul_self_lt", "code": "theorem abs_log_mul_self_lt (x : \u211d) (h1 : 0 < x) (h2 : x \u2264 1) : |log x * x| < 1", "start": [323, 1], "end": [336, 13], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_log_atTop", "code": "theorem tendsto_log_atTop : Tendsto log atTop atTop", "start": [339, 1], "end": [341, 71], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_log_nhdsWithin_zero", "code": "theorem tendsto_log_nhdsWithin_zero : Tendsto log (\ud835\udcdd[\u2260] 0) atBot", "start": [344, 1], "end": [347, 52], "kind": "commanddeclaration"}, {"full_name": "Real.continuousOn_log", "code": "theorem continuousOn_log : ContinuousOn log {0}\u1d9c", "start": [350, 1], "end": [353, 84], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_log", "code": "@[continuity]\ntheorem continuous_log : Continuous fun x : { x : \u211d // x \u2260 0 } => log x", "start": [356, 1], "end": [358, 78], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_log'", "code": "@[continuity]\ntheorem continuous_log' : Continuous fun x : { x : \u211d // 0 < x } => log x", "start": [361, 1], "end": [363, 90], "kind": "commanddeclaration"}, {"full_name": "Real.continuousAt_log", "code": "theorem continuousAt_log (hx : x \u2260 0) : ContinuousAt log x", "start": [366, 1], "end": [367, 77], "kind": "commanddeclaration"}, {"full_name": "Real.continuousAt_log_iff", "code": "@[simp]\ntheorem continuousAt_log_iff : ContinuousAt log x \u2194 x \u2260 0", "start": [370, 1], "end": [375, 38], "kind": "commanddeclaration"}, {"full_name": "Real.log_prod", "code": "theorem log_prod {\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u211d) (hf : \u2200 x \u2208 s, f x \u2260 0) :\n    log (\u220f i in s, f i) = \u2211 i in s, log (f i)", "start": [380, 1], "end": [385, 66], "kind": "commanddeclaration"}, {"full_name": "Finsupp.log_prod", "code": "protected theorem _root_.Finsupp.log_prod {\u03b1 \u03b2 : Type*} [Zero \u03b2] (f : \u03b1 \u2192\u2080 \u03b2) (g : \u03b1 \u2192 \u03b2 \u2192 \u211d)\n    (hg : \u2200 a, g a (f a) = 0 \u2192 f a = 0) : log (f.prod g) = f.sum fun a b \u21a6 log (g a b)", "start": [389, 1], "end": [391, 70], "kind": "commanddeclaration"}, {"full_name": "Real.log_nat_eq_sum_factorization", "code": "theorem log_nat_eq_sum_factorization (n : \u2115) :\n    log n = n.factorization.sum fun p t => t * log p", "start": [393, 1], "end": [400, 75], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_pow_log_div_mul_add_atTop", "code": "theorem tendsto_pow_log_div_mul_add_atTop (a b : \u211d) (n : \u2115) (ha : a \u2260 0) :\n    Tendsto (fun x => log x ^ n / (a * x + b)) atTop (\ud835\udcdd 0)", "start": [403, 1], "end": [406, 86], "kind": "commanddeclaration"}, {"full_name": "Real.isLittleO_pow_log_id_atTop", "code": "theorem isLittleO_pow_log_id_atTop {n : \u2115} : (fun x => log x ^ n) =o[atTop] id", "start": [409, 1], "end": [412, 79], "kind": "commanddeclaration"}, {"full_name": "Real.isLittleO_log_id_atTop", "code": "theorem isLittleO_log_id_atTop : log =o[atTop] id", "start": [415, 1], "end": [416, 59], "kind": "commanddeclaration"}, {"full_name": "Real.isLittleO_const_log_atTop", "code": "theorem isLittleO_const_log_atTop {c : \u211d} : (fun _ => c) =o[atTop] log", "start": [419, 1], "end": [423, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.log", "code": "theorem Filter.Tendsto.log {f : \u03b1 \u2192 \u211d} {l : Filter \u03b1} {x : \u211d} (h : Tendsto f l (\ud835\udcdd x)) (hx : x \u2260 0) :\n    Tendsto (fun x => log (f x)) l (\ud835\udcdd (log x))", "start": [433, 1], "end": [435, 39], "kind": "commanddeclaration"}, {"full_name": "Continuous.log", "code": "theorem Continuous.log (hf : Continuous f) (h\u2080 : \u2200 x, f x \u2260 0) : Continuous fun x => log (f x)", "start": [440, 1], "end": [441, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.log", "code": "nonrec theorem ContinuousAt.log (hf : ContinuousAt f a) (h\u2080 : f a \u2260 0) :\n    ContinuousAt (fun x => log (f x)) a", "start": [444, 1], "end": [446, 12], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.log", "code": "nonrec theorem ContinuousWithinAt.log (hf : ContinuousWithinAt f s a) (h\u2080 : f a \u2260 0) :\n    ContinuousWithinAt (fun x => log (f x)) s a", "start": [449, 1], "end": [451, 12], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.log", "code": "theorem ContinuousOn.log (hf : ContinuousOn f s) (h\u2080 : \u2200 x \u2208 s, f x \u2260 0) :\n    ContinuousOn (fun x => log (f x)) s", "start": [454, 1], "end": [455, 79], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_log_comp_add_sub_log", "code": "theorem tendsto_log_comp_add_sub_log (y : \u211d) :\n    Tendsto (fun x : \u211d => log (x + y) - log x) atTop (\ud835\udcdd 0)", "start": [466, 1], "end": [473, 71], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_log_nat_add_one_sub_log", "code": "theorem tendsto_log_nat_add_one_sub_log : Tendsto (fun k : \u2115 => log (k + 1) - log k) atTop (\ud835\udcdd 0)", "start": [476, 1], "end": [477, 69], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.log_nonneg_of_isNat", "code": "lemma log_nonneg_of_isNat (h : NormNum.IsNat e n) : 0 \u2264 Real.log (e : \u211d) := by\n  rw [NormNum.IsNat.to_eq h rfl]\n  exact Real.log_nat_cast_nonneg _", "start": [487, 1], "end": [489, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.log_pos_of_isNat", "code": "lemma log_pos_of_isNat (h : NormNum.IsNat e n) (w : Nat.blt 1 n = true) : 0 < Real.log (e : \u211d) := by\n  rw [NormNum.IsNat.to_eq h rfl]\n  apply Real.log_pos\n  simpa using w", "start": [491, 1], "end": [494, 16], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.log_nonneg_of_isNegNat", "code": "lemma log_nonneg_of_isNegNat (h : NormNum.IsInt e (.negOfNat n)) : 0 \u2264 Real.log (e : \u211d) := by\n  rw [NormNum.IsInt.neg_to_eq h rfl]\n  exact Real.log_neg_nat_cast_nonneg _", "start": [496, 1], "end": [498, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.log_pos_of_isNegNat", "code": "lemma log_pos_of_isNegNat (h : NormNum.IsInt e (.negOfNat n)) (w : Nat.blt 1 n = true) :\n    0 < Real.log (e : \u211d) := by\n  rw [NormNum.IsInt.neg_to_eq h rfl]\n  rw [Real.log_neg_eq_log]\n  apply Real.log_pos\n  simpa using w", "start": [500, 1], "end": [505, 16], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.log_pos_of_isRat", "code": "lemma log_pos_of_isRat :\n    (NormNum.IsRat e n d) \u2192 (decide ((1 : \u211a) < n / d)) \u2192 (0 < Real.log (e : \u211d))\n  | \u27e8inv, eq\u27e9, h => by\n    rw [eq, invOf_eq_inv, \u2190div_eq_mul_inv]\n    have : 1 < (n : \u211d) / d := by exact_mod_cast of_decide_eq_true h\n    exact Real.log_pos this", "start": [507, 1], "end": [512, 28], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.log_pos_of_isRat_neg", "code": "lemma log_pos_of_isRat_neg :\n    (NormNum.IsRat e n d) \u2192 (decide (n / d < (-1 : \u211a))) \u2192 (0 < Real.log (e : \u211d))\n  | \u27e8inv, eq\u27e9, h => by\n    rw [eq, invOf_eq_inv, \u2190div_eq_mul_inv]\n    have : (n : \u211d) / d < -1 := by exact_mod_cast of_decide_eq_true h\n    exact Real.log_pos_of_lt_neg_one this", "start": [514, 1], "end": [519, 42], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.log_nz_of_isRat", "code": "lemma log_nz_of_isRat : (NormNum.IsRat e n d) \u2192 (decide ((0 : \u211a) < n / d))\n    \u2192 (decide (n / d < (1 : \u211a))) \u2192 (Real.log (e : \u211d) \u2260 0)\n  | \u27e8inv, eq\u27e9, h\u2081, h\u2082 => by\n    rw [eq, invOf_eq_inv, \u2190div_eq_mul_inv]\n    have h\u2081' : 0 < (n : \u211d) / d := by exact_mod_cast of_decide_eq_true h\u2081\n    have h\u2082' : (n : \u211d) / d < 1 := by exact_mod_cast of_decide_eq_true h\u2082\n    exact ne_of_lt <| Real.log_neg h\u2081' h\u2082'", "start": [521, 1], "end": [527, 43], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.log_nz_of_isRat_neg", "code": "lemma log_nz_of_isRat_neg : (NormNum.IsRat e n d) \u2192 (decide (n / d < (0 : \u211a)))\n    \u2192 (decide ((-1 : \u211a) < n / d)) \u2192 (Real.log (e : \u211d) \u2260 0)\n  | \u27e8inv, eq\u27e9, h\u2081, h\u2082 => by\n    rw [eq, invOf_eq_inv, \u2190div_eq_mul_inv]\n    have h\u2081' : (n : \u211d) / d < 0 := by exact_mod_cast of_decide_eq_true h\u2081\n    have h\u2082' : -1 < (n : \u211d) / d := by exact_mod_cast of_decide_eq_true h\u2082\n    exact ne_of_lt <| Real.log_neg_of_lt_zero h\u2081' h\u2082'", "start": [529, 1], "end": [535, 54], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.evalLogNatCast", "code": "@[positivity Real.log (Nat.cast _)]\ndef evalLogNatCast : PositivityExt where eval {_ _} _z\u03b1 _p\u03b1 e := do\n  let .app (f : Q(\u211d \u2192 \u211d)) (.app _ (a : Q(\u2115))) \u2190 withReducible (whnf e) | throwError \"not Real.log\"\n  guard <|\u2190 withDefault <| withNewMCtxDepth <| isDefEq f q(Real.log)\n  pure (.nonnegative (q(Real.log_nat_cast_nonneg $a) : Lean.Expr))", "start": [537, 1], "end": [542, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalLogIntCast", "code": "@[positivity Real.log (Int.cast _)]\ndef evalLogIntCast : PositivityExt where eval {_ _} _z\u03b1 _p\u03b1 e := do\n  let .app (f : Q(\u211d \u2192 \u211d)) (.app _ (a : Q(\u2124))) \u2190 withReducible (whnf e) | throwError \"not Real.log\"\n  guard <|\u2190 withDefault <| withNewMCtxDepth <| isDefEq f q(Real.log)\n  pure (.nonnegative (q(Real.log_int_cast_nonneg $a) : Lean.Expr))", "start": [544, 1], "end": [549, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalLogNatLit", "code": "@[positivity Real.log _]\ndef evalLogNatLit : PositivityExt where eval {_ _} _z\u03b1 _p\u03b1 e := do\n  let .app (f : Q(\u211d \u2192 \u211d)) (a : Q(\u211d)) \u2190 withReducible (whnf e) | throwError \"not Real.log\"\n  guard <|\u2190 withDefault <| withNewMCtxDepth <| isDefEq f q(Real.log)\n  match \u2190NormNum.derive a with\n  | .isNat (_ : Q(AddMonoidWithOne \u211d)) lit p =>\n    assumeInstancesCommute\n    have p : Q(NormNum.IsNat $a $lit) := p\n    if 1 < lit.natLit! then\n      let p' : Q(Nat.blt 1 $lit = true) := (q(Eq.refl true) : Lean.Expr)\n      pure (.positive (q(log_pos_of_isNat $p $p') : Lean.Expr))\n    else\n      pure (.nonnegative (q(log_nonneg_of_isNat $p) : Lean.Expr))\n  | .isNegNat _ lit p =>\n    assumeInstancesCommute\n    have p : Q(NormNum.IsInt $a (Int.negOfNat $lit)) := p\n    if 1 < lit.natLit! then\n      let p' : Q(Nat.blt 1 $lit = true) := (q(Eq.refl true) : Lean.Expr)\n      pure (.positive (q(log_pos_of_isNegNat $p $p') : Lean.Expr))\n    else\n      pure (.nonnegative (q(log_nonneg_of_isNegNat $p) : Lean.Expr))\n  | .isRat (i : Q(DivisionRing \u211d)) q n d p =>\n    assumeInstancesCommute\n    have p : Q(by clear! \u00ab$i\u00bb; exact NormNum.IsRat $a $n $d) := p\n    if 0 < q \u2227 q < 1 then\n      let w\u2081 : Q(decide ((0 : \u211a) < $n / $d) = true) := (q(Eq.refl true) : Lean.Expr)\n      let w\u2082 : Q(decide ($n / $d < (1 : \u211a)) = true) := (q(Eq.refl true) : Lean.Expr)\n      pure (.nonzero (q(log_nz_of_isRat $p $w\u2081 $w\u2082) : Lean.Expr))\n    else if 1 < q then\n      let w : Q(decide ((1 : \u211a) < $n / $d) = true) := (q(Eq.refl true) : Lean.Expr)\n      pure (.positive (q(log_pos_of_isRat $p $w) : Lean.Expr))\n    else if -1 < q \u2227 q < 0 then\n      let w\u2081 : Q(decide ($n / $d < (0 : \u211a)) = true) := (q(Eq.refl true) : Lean.Expr)\n      let w\u2082 : Q(decide ((-1 : \u211a) < $n / $d) = true) := (q(Eq.refl true) : Lean.Expr)\n      pure (.nonzero (q(log_nz_of_isRat_neg $p $w\u2081 $w\u2082) : Lean.Expr))\n    else if q < -1 then\n      let w : Q(decide ($n / $d < (-1 : \u211a)) = true) := (q(Eq.refl true) : Lean.Expr)\n      pure (.positive (q(log_pos_of_isRat_neg $p $w) : Lean.Expr))\n    else\n      failure\n  | _ => failure", "start": [551, 1], "end": [592, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Equiv/TransferInstance.lean", "imports": ["Mathlib/Logic/Equiv/Defs.lean", "Mathlib/Algebra/Field/Basic.lean", "Mathlib/Algebra/Algebra/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Equiv.one", "code": "@[reducible, to_additive \"Transfer `Zero` across an `Equiv`\"]\nprotected def one [One \u03b2] : One \u03b1 :=\n  \u27e8e.symm 1\u27e9", "start": [43, 1], "end": [46, 13], "kind": "commanddeclaration"}, {"full_name": "Equiv.one_def", "code": "@[to_additive]\ntheorem one_def [One \u03b2] :\n    letI := e.one\n    1 = e.symm 1", "start": [50, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.mul", "code": "@[reducible, to_additive \"Transfer `Add` across an `Equiv`\"]\nprotected def mul [Mul \u03b2] : Mul \u03b1 :=\n  \u27e8fun x y => e.symm (e x * e y)\u27e9", "start": [58, 1], "end": [61, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.mul_def", "code": "@[to_additive]\ntheorem mul_def [Mul \u03b2] (x y : \u03b1) :\n    letI := Equiv.mul e\n    x * y = e.symm (e x * e y)", "start": [65, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.div", "code": "@[reducible, to_additive \"Transfer `Sub` across an `Equiv`\"]\nprotected def div [Div \u03b2] : Div \u03b1 :=\n  \u27e8fun x y => e.symm (e x / e y)\u27e9", "start": [73, 1], "end": [76, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.div_def", "code": "@[to_additive]\ntheorem div_def [Div \u03b2] (x y : \u03b1) :\n    letI := Equiv.div e\n    x / y = e.symm (e x / e y)", "start": [80, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Inv", "code": "@[reducible, to_additive \"Transfer `Neg` across an `Equiv`\"]\nprotected def Inv [Inv \u03b2] : Inv \u03b1 :=\n  \u27e8fun x => e.symm (e x)\u207b\u00b9\u27e9", "start": [90, 1], "end": [93, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.inv_def", "code": "@[to_additive]\ntheorem inv_def [Inv \u03b2] (x : \u03b1) :\n    letI := Equiv.Inv e\n    x\u207b\u00b9 = e.symm (e x)\u207b\u00b9", "start": [97, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.smul", "code": "@[reducible]\nprotected def smul (R : Type*) [SMul R \u03b2] : SMul R \u03b1 :=\n  \u27e8fun r x => e.symm (r \u2022 e x)\u27e9", "start": [105, 1], "end": [108, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.smul_def", "code": "theorem smul_def {R : Type*} [SMul R \u03b2] (r : R) (x : \u03b1) :\n    letI := e.smul R\n    r \u2022 x = e.symm (r \u2022 e x)", "start": [111, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.pow", "code": "@[reducible, to_additive existing smul]\nprotected def pow (N : Type*) [Pow \u03b2 N] : Pow \u03b1 N :=\n  \u27e8fun x n => e.symm (e x ^ n)\u27e9", "start": [117, 1], "end": [120, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.pow_def", "code": "theorem pow_def {N : Type*} [Pow \u03b2 N] (n : N) (x : \u03b1) :\n    letI := e.pow N\n    x ^ n = e.symm (e x ^ n)", "start": [123, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.mulEquiv", "code": "@[to_additive \"An equivalence `e : \u03b1 \u2243 \u03b2` gives an additive equivalence `\u03b1 \u2243+ \u03b2` where\nthe additive structure on `\u03b1` is the one obtained by transporting an additive structure\non `\u03b2` back along `e`.\"]\ndef mulEquiv (e : \u03b1 \u2243 \u03b2) [Mul \u03b2] :\n    let mul := Equiv.mul e\n    \u03b1 \u2243* \u03b2 := by\n  intros\n  exact\n    { e with\n      map_mul' := fun x y => by\n        apply e.symm.injective\n        simp [mul_def] }", "start": [129, 1], "end": [143, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.mulEquiv_apply", "code": "@[to_additive (attr := simp)]\ntheorem mulEquiv_apply (e : \u03b1 \u2243 \u03b2) [Mul \u03b2] (a : \u03b1) : (mulEquiv e) a = e a", "start": [147, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.mulEquiv_symm_apply", "code": "@[to_additive]\ntheorem mulEquiv_symm_apply (e : \u03b1 \u2243 \u03b2) [Mul \u03b2] (b : \u03b2) :\n    letI := Equiv.mul e\n    (mulEquiv e).symm b = e.symm b", "start": [153, 1], "end": [157, 17], "kind": "commanddeclaration"}, {"full_name": "Equiv.ringEquiv", "code": "def ringEquiv (e : \u03b1 \u2243 \u03b2) [Add \u03b2] [Mul \u03b2] : by\n    let add := Equiv.add e\n    let mul := Equiv.mul e\n    exact \u03b1 \u2243+* \u03b2 := by\n  intros\n  exact\n    { e with\n      map_add' := fun x y => by\n        apply e.symm.injective\n        simp [add_def]\n      map_mul' := fun x y => by\n        apply e.symm.injective\n        simp [mul_def] }", "start": [161, 1], "end": [177, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.ringEquiv_apply", "code": "@[simp]\ntheorem ringEquiv_apply (e : \u03b1 \u2243 \u03b2) [Add \u03b2] [Mul \u03b2] (a : \u03b1) : (ringEquiv e) a = e a", "start": [180, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.ringEquiv_symm_apply", "code": "theorem ringEquiv_symm_apply (e : \u03b1 \u2243 \u03b2) [Add \u03b2] [Mul \u03b2] (b : \u03b2) : by\n    letI := Equiv.add e\n    letI := Equiv.mul e\n    exact (ringEquiv e).symm b = e.symm b", "start": [185, 1], "end": [188, 60], "kind": "commanddeclaration"}, {"full_name": "Equiv.semigroup", "code": "@[reducible, to_additive \"Transfer `add_semigroup` across an `Equiv`\"]\nprotected def semigroup [Semigroup \u03b2] : Semigroup \u03b1 := by\n  let mul := e.mul\n  apply e.injective.semigroup _; intros; exact e.apply_symm_apply _", "start": [191, 1], "end": [195, 68], "kind": "commanddeclaration"}, {"full_name": "Equiv.semigroupWithZero", "code": "@[reducible]\nprotected def semigroupWithZero [SemigroupWithZero \u03b2] : SemigroupWithZero \u03b1 := by\n  let mul := e.mul\n  let zero := e.zero\n  apply e.injective.semigroupWithZero _ <;> intros <;> exact e.apply_symm_apply _", "start": [199, 1], "end": [204, 82], "kind": "commanddeclaration"}, {"full_name": "Equiv.commSemigroup", "code": "@[reducible, to_additive \"Transfer `AddCommSemigroup` across an `Equiv`\"]\nprotected def commSemigroup [CommSemigroup \u03b2] : CommSemigroup \u03b1 := by\n  let mul := e.mul\n  apply e.injective.commSemigroup _; intros; exact e.apply_symm_apply _", "start": [207, 1], "end": [211, 72], "kind": "commanddeclaration"}, {"full_name": "Equiv.mulZeroClass", "code": "@[reducible]\nprotected def mulZeroClass [MulZeroClass \u03b2] : MulZeroClass \u03b1 := by\n  let zero := e.zero\n  let mul := e.mul\n  apply e.injective.mulZeroClass _ <;> intros <;> exact e.apply_symm_apply _", "start": [215, 1], "end": [220, 77], "kind": "commanddeclaration"}, {"full_name": "Equiv.mulOneClass", "code": "@[reducible, to_additive \"Transfer `AddZeroClass` across an `Equiv`\"]\nprotected def mulOneClass [MulOneClass \u03b2] : MulOneClass \u03b1 := by\n  let one := e.one\n  let mul := e.mul\n  apply e.injective.mulOneClass _ <;> intros <;> exact e.apply_symm_apply _", "start": [223, 1], "end": [228, 76], "kind": "commanddeclaration"}, {"full_name": "Equiv.mulZeroOneClass", "code": "@[reducible]\nprotected def mulZeroOneClass [MulZeroOneClass \u03b2] : MulZeroOneClass \u03b1 := by\n  let zero := e.zero\n  let one := e.one\n  let mul := e.mul\n  apply e.injective.mulZeroOneClass _ <;> intros <;> exact e.apply_symm_apply _", "start": [232, 1], "end": [238, 80], "kind": "commanddeclaration"}, {"full_name": "Equiv.monoid", "code": "@[reducible, to_additive \"Transfer `AddMonoid` across an `Equiv`\"]\nprotected def monoid [Monoid \u03b2] : Monoid \u03b1 := by\n  let one := e.one\n  let mul := e.mul\n  let pow := e.pow \u2115\n  apply e.injective.monoid _ <;> intros <;> exact e.apply_symm_apply _", "start": [241, 1], "end": [247, 71], "kind": "commanddeclaration"}, {"full_name": "Equiv.commMonoid", "code": "@[reducible, to_additive \"Transfer `AddCommMonoid` across an `Equiv`\"]\nprotected def commMonoid [CommMonoid \u03b2] : CommMonoid \u03b1 := by\n  let one := e.one\n  let mul := e.mul\n  let pow := e.pow \u2115\n  apply e.injective.commMonoid _ <;> intros <;> exact e.apply_symm_apply _", "start": [251, 1], "end": [257, 75], "kind": "commanddeclaration"}, {"full_name": "Equiv.group", "code": "@[reducible, to_additive \"Transfer `AddGroup` across an `Equiv`\"]\nprotected def group [Group \u03b2] : Group \u03b1 := by\n  let one := e.one\n  let mul := e.mul\n  let inv := e.Inv\n  let div := e.div\n  let npow := e.pow \u2115\n  let zpow := e.pow \u2124\n  apply e.injective.group _ <;> intros <;> exact e.apply_symm_apply _", "start": [261, 1], "end": [270, 70], "kind": "commanddeclaration"}, {"full_name": "Equiv.commGroup", "code": "@[reducible, to_additive \"Transfer `AddCommGroup` across an `Equiv`\"]\nprotected def commGroup [CommGroup \u03b2] : CommGroup \u03b1 := by\n  let one := e.one\n  let mul := e.mul\n  let inv := e.Inv\n  let div := e.div\n  let npow := e.pow \u2115\n  let zpow := e.pow \u2124\n  apply e.injective.commGroup _ <;> intros <;> exact e.apply_symm_apply _", "start": [274, 1], "end": [283, 74], "kind": "commanddeclaration"}, {"full_name": "Equiv.nonUnitalNonAssocSemiring", "code": "@[reducible]\nprotected def nonUnitalNonAssocSemiring [NonUnitalNonAssocSemiring \u03b2] :\n    NonUnitalNonAssocSemiring \u03b1 := by\n  let zero := e.zero\n  let add := e.add\n  let mul := e.mul\n  let nsmul := e.smul \u2115\n  apply e.injective.nonUnitalNonAssocSemiring _ <;> intros <;> exact e.apply_symm_apply _", "start": [287, 1], "end": [295, 90], "kind": "commanddeclaration"}, {"full_name": "Equiv.nonUnitalSemiring", "code": "@[reducible]\nprotected def nonUnitalSemiring [NonUnitalSemiring \u03b2] : NonUnitalSemiring \u03b1 := by\n  let zero := e.zero\n  let add := e.add\n  let mul := e.mul\n  let nsmul := e.smul \u2115\n  apply e.injective.nonUnitalSemiring _ <;> intros <;> exact e.apply_symm_apply _", "start": [298, 1], "end": [305, 82], "kind": "commanddeclaration"}, {"full_name": "Equiv.addMonoidWithOne", "code": "@[reducible]\nprotected def addMonoidWithOne [AddMonoidWithOne \u03b2] : AddMonoidWithOne \u03b1 :=\n  { e.addMonoid, e.one with\n    natCast := fun n => e.symm n\n    natCast_zero := e.injective (by simp [zero_def])\n    natCast_succ := fun n => e.injective (by simp [add_def, one_def]) }", "start": [308, 1], "end": [314, 72], "kind": "commanddeclaration"}, {"full_name": "Equiv.addGroupWithOne", "code": "@[reducible]\nprotected def addGroupWithOne [AddGroupWithOne \u03b2] : AddGroupWithOne \u03b1 :=\n  { e.addMonoidWithOne,\n    e.addGroup with\n    intCast := fun n => e.symm n\n    intCast_ofNat := fun n => by simp only [Int.cast_ofNat]; rfl\n    intCast_negSucc := fun n =>\n      congr_arg e.symm <| (Int.cast_negSucc _).trans <| congr_arg _ (e.apply_symm_apply _).symm }", "start": [317, 1], "end": [325, 98], "kind": "commanddeclaration"}, {"full_name": "Equiv.nonAssocSemiring", "code": "@[reducible]\nprotected def nonAssocSemiring [NonAssocSemiring \u03b2] : NonAssocSemiring \u03b1 := by\n  let mul := e.mul\n  let add_monoid_with_one := e.addMonoidWithOne\n  apply e.injective.nonAssocSemiring _ <;> intros <;> exact e.apply_symm_apply _", "start": [328, 1], "end": [333, 81], "kind": "commanddeclaration"}, {"full_name": "Equiv.semiring", "code": "@[reducible]\nprotected def semiring [Semiring \u03b2] : Semiring \u03b1 := by\n  let mul := e.mul\n  let add_monoid_with_one := e.addMonoidWithOne\n  let npow := e.pow \u2115\n  apply e.injective.semiring _ <;> intros <;> exact e.apply_symm_apply _", "start": [336, 1], "end": [342, 73], "kind": "commanddeclaration"}, {"full_name": "Equiv.nonUnitalCommSemiring", "code": "@[reducible]\nprotected def nonUnitalCommSemiring [NonUnitalCommSemiring \u03b2] : NonUnitalCommSemiring \u03b1 := by\n  let zero := e.zero\n  let add := e.add\n  let mul := e.mul\n  let nsmul := e.smul \u2115\n  apply e.injective.nonUnitalCommSemiring _ <;> intros <;> exact e.apply_symm_apply _", "start": [345, 1], "end": [352, 86], "kind": "commanddeclaration"}, {"full_name": "Equiv.commSemiring", "code": "@[reducible]\nprotected def commSemiring [CommSemiring \u03b2] : CommSemiring \u03b1 := by\n  let mul := e.mul\n  let add_monoid_with_one := e.addMonoidWithOne\n  let npow := e.pow \u2115\n  apply e.injective.commSemiring _ <;> intros <;> exact e.apply_symm_apply _", "start": [355, 1], "end": [361, 77], "kind": "commanddeclaration"}, {"full_name": "Equiv.nonUnitalNonAssocRing", "code": "@[reducible]\nprotected def nonUnitalNonAssocRing [NonUnitalNonAssocRing \u03b2] : NonUnitalNonAssocRing \u03b1 := by\n  let zero := e.zero\n  let add := e.add\n  let mul := e.mul\n  let neg := e.Neg\n  let sub := e.sub\n  let nsmul := e.smul \u2115\n  let zsmul := e.smul \u2124\n  apply e.injective.nonUnitalNonAssocRing _ <;> intros <;> exact e.apply_symm_apply _", "start": [364, 1], "end": [374, 86], "kind": "commanddeclaration"}, {"full_name": "Equiv.nonUnitalRing", "code": "@[reducible]\nprotected def nonUnitalRing [NonUnitalRing \u03b2] : NonUnitalRing \u03b1 := by\n  let zero := e.zero\n  let add := e.add\n  let mul := e.mul\n  let neg := e.Neg\n  let sub := e.sub\n  let nsmul := e.smul \u2115\n  let zsmul := e.smul \u2124\n  apply e.injective.nonUnitalRing _ <;> intros <;> exact e.apply_symm_apply _", "start": [377, 1], "end": [387, 78], "kind": "commanddeclaration"}, {"full_name": "Equiv.nonAssocRing", "code": "@[reducible]\nprotected def nonAssocRing [NonAssocRing \u03b2] : NonAssocRing \u03b1 := by\n  let add_group_with_one := e.addGroupWithOne\n  let mul := e.mul\n  apply e.injective.nonAssocRing _ <;> intros <;> exact e.apply_symm_apply _", "start": [390, 1], "end": [395, 77], "kind": "commanddeclaration"}, {"full_name": "Equiv.ring", "code": "@[reducible]\nprotected def ring [Ring \u03b2] : Ring \u03b1 := by\n  let mul := e.mul\n  let add_group_with_one := e.addGroupWithOne\n  let npow := e.pow \u2115\n  apply e.injective.ring _ <;> intros <;> exact e.apply_symm_apply _", "start": [398, 1], "end": [404, 69], "kind": "commanddeclaration"}, {"full_name": "Equiv.nonUnitalCommRing", "code": "@[reducible]\nprotected def nonUnitalCommRing [NonUnitalCommRing \u03b2] : NonUnitalCommRing \u03b1 := by\n  let zero := e.zero\n  let add := e.add\n  let mul := e.mul\n  let neg := e.Neg\n  let sub := e.sub\n  let nsmul := e.smul \u2115\n  let zsmul := e.smul \u2124\n  apply e.injective.nonUnitalCommRing _ <;> intros <;> exact e.apply_symm_apply _", "start": [407, 1], "end": [417, 82], "kind": "commanddeclaration"}, {"full_name": "Equiv.commRing", "code": "@[reducible]\nprotected def commRing [CommRing \u03b2] : CommRing \u03b1 := by\n  let mul := e.mul\n  let add_group_with_one := e.addGroupWithOne\n  let npow := e.pow \u2115\n  apply e.injective.commRing _ <;> intros <;> exact e.apply_symm_apply _", "start": [420, 1], "end": [426, 73], "kind": "commanddeclaration"}, {"full_name": "Equiv.nontrivial", "code": "@[reducible]\nprotected theorem nontrivial [Nontrivial \u03b2] : Nontrivial \u03b1", "start": [429, 1], "end": [432, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.isDomain", "code": "@[reducible]\nprotected theorem isDomain [Ring \u03b1] [Ring \u03b2] [IsDomain \u03b2] (e : \u03b1 \u2243+* \u03b2) : IsDomain \u03b1", "start": [435, 1], "end": [438, 54], "kind": "commanddeclaration"}, {"full_name": "Equiv.RatCast", "code": "@[reducible]\nprotected def RatCast [RatCast \u03b2] : RatCast \u03b1 where ratCast n := e.symm n", "start": [441, 1], "end": [443, 74], "kind": "commanddeclaration"}, {"full_name": "Equiv.divisionRing", "code": "@[reducible]\nprotected def divisionRing [DivisionRing \u03b2] : DivisionRing \u03b1 := by\n  let add_group_with_one := e.addGroupWithOne\n  let inv := e.Inv\n  let div := e.div\n  let mul := e.mul\n  let npow := e.pow \u2115\n  let zpow := e.pow \u2124\n  let rat_cast := e.RatCast\n  let qsmul := e.smul \u211a\n  apply e.injective.divisionRing _ <;> intros <;> exact e.apply_symm_apply _", "start": [446, 1], "end": [457, 77], "kind": "commanddeclaration"}, {"full_name": "Equiv.field", "code": "@[reducible]\nprotected def field [Field \u03b2] : Field \u03b1 := by\n  let add_group_with_one := e.addGroupWithOne\n  let neg := e.Neg\n  let inv := e.Inv\n  let div := e.div\n  let mul := e.mul\n  let npow := e.pow \u2115\n  let zpow := e.pow \u2124\n  let rat_cast := e.RatCast\n  let qsmul := e.smul \u211a\n  apply e.injective.field _ <;> intros <;> exact e.apply_symm_apply _", "start": [460, 1], "end": [472, 70], "kind": "commanddeclaration"}, {"full_name": "Equiv.mulAction", "code": "@[reducible]\nprotected def mulAction (e : \u03b1 \u2243 \u03b2) [MulAction R \u03b2] : MulAction R \u03b1 :=\n  { e.smul R with\n    one_smul := by simp [smul_def]\n    mul_smul := by simp [smul_def, mul_smul] }", "start": [483, 1], "end": [488, 47], "kind": "commanddeclaration"}, {"full_name": "Equiv.distribMulAction", "code": "@[reducible]\nprotected def distribMulAction (e : \u03b1 \u2243 \u03b2) [AddCommMonoid \u03b2] :\n    letI := Equiv.addCommMonoid e\n    \u2200 [DistribMulAction R \u03b2], DistribMulAction R \u03b1 := by\n  intros\n  letI := Equiv.addCommMonoid e\n  exact\n    ({ Equiv.mulAction R e with\n        smul_zero := by simp [zero_def, smul_def]\n        smul_add := by simp [add_def, smul_def, smul_add] } :\n      DistribMulAction R \u03b1)", "start": [491, 1], "end": [502, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.module", "code": "@[reducible]\nprotected def module (e : \u03b1 \u2243 \u03b2) [AddCommMonoid \u03b2] :\n    let addCommMonoid := Equiv.addCommMonoid e\n    \u2200 [Module R \u03b2], Module R \u03b1 := by\n  intros\n  exact\n    ({ Equiv.distribMulAction R e with\n        zero_smul := by simp [smul_def, zero_smul, zero_def]\n        add_smul := by simp [add_def, smul_def, add_smul] } :\n      Module R \u03b1)", "start": [511, 1], "end": [521, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.linearEquiv", "code": "def linearEquiv (e : \u03b1 \u2243 \u03b2) [AddCommMonoid \u03b2] [Module R \u03b2] : by\n    let addCommMonoid := Equiv.addCommMonoid e\n    let module := Equiv.module R e\n    exact \u03b1 \u2243\u2097[R] \u03b2 := by\n  intros\n  exact\n    { Equiv.addEquiv e with\n      map_smul' := fun r x => by\n        apply e.symm.injective\n        simp only [toFun_as_coe_apply, RingHom.id_apply, EmbeddingLike.apply_eq_iff_eq]\n        exact Iff.mpr (apply_eq_iff_eq_symm_apply _) rfl }", "start": [524, 1], "end": [538, 59], "kind": "commanddeclaration"}, {"full_name": "Equiv.algebra", "code": "@[reducible]\nprotected def algebra (e : \u03b1 \u2243 \u03b2) [Semiring \u03b2] :\n    let semiring := Equiv.semiring e\n    \u2200 [Algebra R \u03b2], Algebra R \u03b1 := by\n  intros\n  fapply RingHom.toAlgebra'\n  \u00b7 exact ((ringEquiv e).symm : \u03b2 \u2192+* \u03b1).comp (algebraMap R \u03b2)\n  \u00b7 intro r x\n    simp only [Function.comp_apply, RingHom.coe_comp]\n    have p := ringEquiv_symm_apply e\n    dsimp at p\n    erw [p]\n    clear p\n    apply (ringEquiv e).injective\n    simp only [(ringEquiv e).map_mul]\n    simp [Algebra.commutes]", "start": [547, 1], "end": [563, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.algEquiv", "code": "def algEquiv (e : \u03b1 \u2243 \u03b2) [Semiring \u03b2] [Algebra R \u03b2] : by\n    let semiring := Equiv.semiring e\n    let algebra := Equiv.algebra R e\n    exact \u03b1 \u2243\u2090[R] \u03b2 := by\n  intros\n  exact\n    { Equiv.ringEquiv e with\n      commutes' := fun r => by\n        apply e.symm.injective\n        simp\n        rfl }", "start": [566, 1], "end": [580, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/JacobsonIdeal.lean", "imports": ["Mathlib/RingTheory/Polynomial/Quotient.lean", "Mathlib/RingTheory/Ideal/Quotient.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ideal.jacobson", "code": "def jacobson (I : Ideal R) : Ideal R :=\n  sInf { J : Ideal R | I \u2264 J \u2227 IsMaximal J }", "start": [59, 1], "end": [61, 45], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_jacobson", "code": "theorem le_jacobson : I \u2264 jacobson I", "start": [64, 1], "end": [64, 88], "kind": "commanddeclaration"}, {"full_name": "Ideal.jacobson_idem", "code": "@[simp]\ntheorem jacobson_idem : jacobson (jacobson I) = jacobson I", "start": [67, 1], "end": [69, 72], "kind": "commanddeclaration"}, {"full_name": "Ideal.jacobson_top", "code": "@[simp]\ntheorem jacobson_top : jacobson (\u22a4 : Ideal R) = \u22a4", "start": [72, 1], "end": [74, 27], "kind": "commanddeclaration"}, {"full_name": "Ideal.jacobson_eq_top_iff", "code": "@[simp]\ntheorem jacobson_eq_top_iff : jacobson I = \u22a4 \u2194 I = \u22a4", "start": [77, 1], "end": [84, 64], "kind": "commanddeclaration"}, {"full_name": "Ideal.jacobson_eq_bot", "code": "theorem jacobson_eq_bot : jacobson I = \u22a5 \u2192 I = \u22a5", "start": [87, 1], "end": [87, 94], "kind": "commanddeclaration"}, {"full_name": "Ideal.jacobson_eq_self_of_isMaximal", "code": "theorem jacobson_eq_self_of_isMaximal [H : IsMaximal I] : I.jacobson = I", "start": [90, 1], "end": [91, 54], "kind": "commanddeclaration"}, {"full_name": "Ideal.jacobson.isMaximal", "code": "instance (priority := 100) jacobson.isMaximal [H : IsMaximal I] : IsMaximal (jacobson I) :=\n  \u27e8\u27e8fun htop => H.1.1 (jacobson_eq_top_iff.1 htop), fun _ hJ =>\n    H.1.2 _ (lt_of_le_of_lt le_jacobson hJ)\u27e9\u27e9", "start": [94, 1], "end": [96, 46], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_jacobson_iff", "code": "theorem mem_jacobson_iff {x : R} : x \u2208 jacobson I \u2194 \u2200 y, \u2203 z, z * y * x + z - 1 \u2208 I", "start": [99, 1], "end": [121, 48], "kind": "commanddeclaration"}, {"full_name": "Ideal.exists_mul_sub_mem_of_sub_one_mem_jacobson", "code": "theorem exists_mul_sub_mem_of_sub_one_mem_jacobson {I : Ideal R} (r : R) (h : r - 1 \u2208 jacobson I) :\n    \u2203 s, s * r - 1 \u2208 I", "start": [124, 1], "end": [128, 27], "kind": "commanddeclaration"}, {"full_name": "Ideal.eq_jacobson_iff_sInf_maximal", "code": "theorem eq_jacobson_iff_sInf_maximal :\n    I.jacobson = I \u2194 \u2203 M : Set (Ideal R), (\u2200 J \u2208 M, IsMaximal J \u2228 J = \u22a4) \u2227 I = sInf M", "start": [131, 1], "end": [142, 42], "kind": "commanddeclaration"}, {"full_name": "Ideal.eq_jacobson_iff_sInf_maximal'", "code": "theorem eq_jacobson_iff_sInf_maximal' :\n    I.jacobson = I \u2194 \u2203 M : Set (Ideal R), (\u2200 J \u2208 M, \u2200 (K : Ideal R), J < K \u2192 K = \u22a4) \u2227 I = sInf M", "start": [145, 1], "end": [159, 18], "kind": "commanddeclaration"}, {"full_name": "Ideal.eq_jacobson_iff_not_mem", "code": "theorem eq_jacobson_iff_not_mem :\n    I.jacobson = I \u2194 \u2200 (x) (_ : x \u2209 I), \u2203 M : Ideal R, (I \u2264 M \u2227 M.IsMaximal) \u2227 x \u2209 M", "start": [162, 1], "end": [175, 17], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_jacobson_of_surjective", "code": "theorem map_jacobson_of_surjective {f : R \u2192+* S} (hf : Function.Surjective f) :\n    RingHom.ker f \u2264 I \u2192 map f I.jacobson = (map f I).jacobson", "start": [178, 1], "end": [195, 60], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_jacobson_of_bijective", "code": "theorem map_jacobson_of_bijective {f : R \u2192+* S} (hf : Function.Bijective f) :\n    map f I.jacobson = (map f I).jacobson", "start": [198, 1], "end": [201, 72], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_jacobson", "code": "theorem comap_jacobson {f : R \u2192+* S} {K : Ideal S} :\n    comap f K.jacobson = sInf (comap f '' { J : Ideal S | K \u2264 J \u2227 J.IsMaximal })", "start": [204, 1], "end": [206, 50], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_jacobson_of_surjective", "code": "theorem comap_jacobson_of_surjective {f : R \u2192+* S} (hf : Function.Surjective f) {K : Ideal S} :\n    comap f K.jacobson = (comap f K).jacobson", "start": [209, 1], "end": [227, 77], "kind": "commanddeclaration"}, {"full_name": "Ideal.jacobson_mono", "code": "@[mono]\ntheorem jacobson_mono {I J : Ideal R} : I \u2264 J \u2192 I.jacobson \u2264 J.jacobson", "start": [230, 1], "end": [234, 60], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_le_jacobson", "code": "theorem radical_le_jacobson : radical I \u2264 jacobson I", "start": [243, 1], "end": [244, 95], "kind": "commanddeclaration"}, {"full_name": "Ideal.isRadical_of_eq_jacobson", "code": "theorem isRadical_of_eq_jacobson (h : jacobson I = I) : I.IsRadical", "start": [247, 1], "end": [248, 33], "kind": "commanddeclaration"}, {"full_name": "Ideal.isUnit_of_sub_one_mem_jacobson_bot", "code": "theorem isUnit_of_sub_one_mem_jacobson_bot (r : R) (h : r - 1 \u2208 jacobson (\u22a5 : Ideal R)) :\n    IsUnit r", "start": [251, 1], "end": [255, 36], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_jacobson_bot", "code": "theorem mem_jacobson_bot {x : R} : x \u2208 jacobson (\u22a5 : Ideal R) \u2194 \u2200 y, IsUnit (x * y + 1)", "start": [258, 1], "end": [266, 51], "kind": "commanddeclaration"}, {"full_name": "Ideal.jacobson_eq_iff_jacobson_quotient_eq_bot", "code": "theorem jacobson_eq_iff_jacobson_quotient_eq_bot :\n    I.jacobson = I \u2194 jacobson (\u22a5 : Ideal (R \u29f8 I)) = \u22a5", "start": [269, 1], "end": [283, 18], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_eq_jacobson_iff_radical_quotient_eq_jacobson_bot", "code": "theorem radical_eq_jacobson_iff_radical_quotient_eq_jacobson_bot :\n    I.radical = I.jacobson \u2194 radical (\u22a5 : Ideal (R \u29f8 I)) = jacobson \u22a5", "start": [286, 1], "end": [302, 21], "kind": "commanddeclaration"}, {"full_name": "Ideal.jacobson_radical_eq_jacobson", "code": "theorem jacobson_radical_eq_jacobson : I.radical.jacobson = I.jacobson", "start": [305, 1], "end": [309, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.jacobson_bot_polynomial_le_sInf_map_maximal", "code": "theorem jacobson_bot_polynomial_le_sInf_map_maximal :\n    jacobson (\u22a5 : Ideal R[X]) \u2264 sInf (map (C : R \u2192+* R[X]) '' { J : Ideal R | J.IsMaximal })", "start": [322, 1], "end": [340, 51], "kind": "commanddeclaration"}, {"full_name": "Ideal.jacobson_bot_polynomial_of_jacobson_bot", "code": "theorem jacobson_bot_polynomial_of_jacobson_bot (h : jacobson (\u22a5 : Ideal R) = \u22a5) :\n    jacobson (\u22a5 : Ideal R[X]) = \u22a5", "start": [346, 1], "end": [352, 86], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsLocal", "code": "class IsLocal (I : Ideal R) : Prop where\n  \n  out : IsMaximal (jacobson I)", "start": [361, 1], "end": [364, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.isLocal_iff", "code": "theorem isLocal_iff {I : Ideal R} : IsLocal I \u2194 IsMaximal (jacobson I)", "start": [367, 1], "end": [368, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.isLocal_of_isMaximal_radical", "code": "theorem isLocal_of_isMaximal_radical {I : Ideal R} (hi : IsMaximal (radical I)) : IsLocal I", "start": [371, 1], "end": [375, 48], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsLocal.le_jacobson", "code": "theorem IsLocal.le_jacobson {I J : Ideal R} (hi : IsLocal I) (hij : I \u2264 J) (hj : J \u2260 \u22a4) :\n    J \u2264 jacobson I", "start": [378, 1], "end": [381, 96], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsLocal.mem_jacobson_or_exists_inv", "code": "theorem IsLocal.mem_jacobson_or_exists_inv {I : Ideal R} (hi : IsLocal I) (x : R) :\n    x \u2208 jacobson I \u2228 \u2203 y, y * x - 1 \u2208 I", "start": [384, 1], "end": [393, 97], "kind": "commanddeclaration"}, {"full_name": "Ideal.isPrimary_of_isMaximal_radical", "code": "theorem isPrimary_of_isMaximal_radical [CommRing R] {I : Ideal R} (hi : IsMaximal (radical I)) :\n    IsPrimary I", "start": [398, 1], "end": [408, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Matrix/DMatrix.lean", "imports": ["Mathlib/Algebra/Group/Pi.lean", "Mathlib/Data/Fintype/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DMatrix", "code": "@[nolint unusedArguments]\ndef DMatrix (m : Type u) (n : Type u') [Fintype m] [Fintype n] (\u03b1 : m \u2192 n \u2192 Type v) :\n    Type max u u' v :=\n  \u2200 i j, \u03b1 i j", "start": [18, 1], "end": [24, 15], "kind": "commanddeclaration"}, {"full_name": "DMatrix.ext_iff", "code": "theorem ext_iff : (\u2200 i j, M i j = N i j) \u2194 M = N", "start": [37, 1], "end": [38, 65], "kind": "commanddeclaration"}, {"full_name": "DMatrix.ext", "code": "@[ext]\ntheorem ext : (\u2200 i j, M i j = N i j) \u2192 M = N", "start": [41, 1], "end": [43, 13], "kind": "commanddeclaration"}, {"full_name": "DMatrix.map", "code": "def map (M : DMatrix m n \u03b1) {\u03b2 : m \u2192 n \u2192 Type w} (f : \u2200 \u2983i j\u2984, \u03b1 i j \u2192 \u03b2 i j) : DMatrix m n \u03b2 :=\n  fun i j => f (M i j)", "start": [48, 1], "end": [50, 23], "kind": "commanddeclaration"}, {"full_name": "DMatrix.map_apply", "code": "@[simp]\ntheorem map_apply {M : DMatrix m n \u03b1} {\u03b2 : m \u2192 n \u2192 Type w} {f : \u2200 \u2983i j\u2984, \u03b1 i j \u2192 \u03b2 i j} {i : m}\n    {j : n} : M.map f i j = f (M i j)", "start": [53, 1], "end": [55, 45], "kind": "commanddeclaration"}, {"full_name": "DMatrix.map_map", "code": "@[simp]\ntheorem map_map {M : DMatrix m n \u03b1} {\u03b2 : m \u2192 n \u2192 Type w} {\u03b3 : m \u2192 n \u2192 Type z}\n    {f : \u2200 \u2983i j\u2984, \u03b1 i j \u2192 \u03b2 i j} {g : \u2200 \u2983i j\u2984, \u03b2 i j \u2192 \u03b3 i j} :\n    (M.map f).map g = M.map fun i j x => g (f x)", "start": [58, 1], "end": [61, 65], "kind": "commanddeclaration"}, {"full_name": "DMatrix.transpose", "code": "def transpose (M : DMatrix m n \u03b1) : DMatrix n m fun j i => \u03b1 i j\n  | x, y => M y x", "start": [64, 1], "end": [66, 18], "kind": "commanddeclaration"}, {"full_name": "DMatrix.col", "code": "def col {\u03b1 : m \u2192 Type v} (w : \u2200 i, \u03b1 i) : DMatrix m Unit fun i _j => \u03b1 i\n  | x, _y => w x", "start": [72, 1], "end": [74, 17], "kind": "commanddeclaration"}, {"full_name": "DMatrix.row", "code": "def row {\u03b1 : n \u2192 Type v} (v : \u2200 j, \u03b1 j) : DMatrix Unit n fun _i j => \u03b1 j\n  | _x, y => v y", "start": [77, 1], "end": [79, 17], "kind": "commanddeclaration"}, {"full_name": "DMatrix.zero_apply", "code": "@[simp]\ntheorem zero_apply [\u2200 i j, Zero (\u03b1 i j)] (i j) : (0 : DMatrix m n \u03b1) i j = 0", "start": [123, 1], "end": [124, 84], "kind": "commanddeclaration"}, {"full_name": "DMatrix.neg_apply", "code": "@[simp]\ntheorem neg_apply [\u2200 i j, Neg (\u03b1 i j)] (M : DMatrix m n \u03b1) (i j) : (-M) i j = -M i j", "start": [127, 1], "end": [128, 92], "kind": "commanddeclaration"}, {"full_name": "DMatrix.add_apply", "code": "@[simp]\ntheorem add_apply [\u2200 i j, Add (\u03b1 i j)] (M N : DMatrix m n \u03b1) (i j) : (M + N) i j = M i j + N i j", "start": [131, 1], "end": [133, 6], "kind": "commanddeclaration"}, {"full_name": "DMatrix.sub_apply", "code": "@[simp]\ntheorem sub_apply [\u2200 i j, Sub (\u03b1 i j)] (M N : DMatrix m n \u03b1) (i j) : (M - N) i j = M i j - N i j", "start": [136, 1], "end": [138, 6], "kind": "commanddeclaration"}, {"full_name": "DMatrix.map_zero", "code": "@[simp]\ntheorem map_zero [\u2200 i j, Zero (\u03b1 i j)] {\u03b2 : m \u2192 n \u2192 Type w} [\u2200 i j, Zero (\u03b2 i j)]\n    {f : \u2200 \u2983i j\u2984, \u03b1 i j \u2192 \u03b2 i j} (h : \u2200 i j, f (0 : \u03b1 i j) = 0) : (0 : DMatrix m n \u03b1).map f = 0", "start": [141, 1], "end": [144, 19], "kind": "commanddeclaration"}, {"full_name": "DMatrix.map_add", "code": "theorem map_add [\u2200 i j, AddMonoid (\u03b1 i j)] {\u03b2 : m \u2192 n \u2192 Type w} [\u2200 i j, AddMonoid (\u03b2 i j)]\n    (f : \u2200 \u2983i j\u2984, \u03b1 i j \u2192+ \u03b2 i j) (M N : DMatrix m n \u03b1) :\n    ((M + N).map fun i j => @f i j) = (M.map fun i j => @f i j) + N.map fun i j => @f i j", "start": [147, 1], "end": [150, 12], "kind": "commanddeclaration"}, {"full_name": "DMatrix.map_sub", "code": "theorem map_sub [\u2200 i j, AddGroup (\u03b1 i j)] {\u03b2 : m \u2192 n \u2192 Type w} [\u2200 i j, AddGroup (\u03b2 i j)]\n    (f : \u2200 \u2983i j\u2984, \u03b1 i j \u2192+ \u03b2 i j) (M N : DMatrix m n \u03b1) :\n    ((M - N).map fun i j => @f i j) = (M.map fun i j => @f i j) - N.map fun i j => @f i j", "start": [153, 1], "end": [156, 12], "kind": "commanddeclaration"}, {"full_name": "DMatrix.subsingleton_of_empty_left", "code": "instance subsingleton_of_empty_left [IsEmpty m] : Subsingleton (DMatrix m n \u03b1) :=\n  \u27e8fun M N => by\n    ext i\n    exact isEmptyElim i\u27e9", "start": [159, 1], "end": [162, 25], "kind": "commanddeclaration"}, {"full_name": "DMatrix.subsingleton_of_empty_right", "code": "instance subsingleton_of_empty_right [IsEmpty n] : Subsingleton (DMatrix m n \u03b1) :=\n  \u27e8fun M N => by ext i j; exact isEmptyElim j\u27e9", "start": [165, 1], "end": [166, 47], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mapDMatrix", "code": "def AddMonoidHom.mapDMatrix [\u2200 i j, AddMonoid (\u03b1 i j)] {\u03b2 : m \u2192 n \u2192 Type w}\n    [\u2200 i j, AddMonoid (\u03b2 i j)] (f : \u2200 \u2983i j\u2984, \u03b1 i j \u2192+ \u03b2 i j) : DMatrix m n \u03b1 \u2192+ DMatrix m n \u03b2\n    where\n  toFun M := M.map fun i j => @f i j\n  map_zero' := by simp\n  map_add' := DMatrix.map_add f", "start": [171, 1], "end": [178, 32], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mapDMatrix_apply", "code": "@[simp]\ntheorem AddMonoidHom.mapDMatrix_apply [\u2200 i j, AddMonoid (\u03b1 i j)] {\u03b2 : m \u2192 n \u2192 Type w}\n    [\u2200 i j, AddMonoid (\u03b2 i j)] (f : \u2200 \u2983i j\u2984, \u03b1 i j \u2192+ \u03b2 i j) (M : DMatrix m n \u03b1) :\n    AddMonoidHom.mapDMatrix f M = M.map fun i j => @f i j", "start": [181, 1], "end": [184, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/MatrixAlgebra.lean", "imports": ["Mathlib/RingTheory/TensorProduct.lean", "Mathlib/Data/Matrix/Basis.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MatrixEquivTensor.toFunBilinear", "code": "def toFunBilinear : A \u2192\u2097[R] Matrix n n R \u2192\u2097[R] Matrix n n A :=\n  (Algebra.lsmul R R (Matrix n n A)).toLinearMap.compl\u2082 (Algebra.linearMap R A).mapMatrix", "start": [39, 1], "end": [44, 90], "kind": "commanddeclaration"}, {"full_name": "MatrixEquivTensor.toFunBilinear_apply", "code": "@[simp]\ntheorem toFunBilinear_apply (a : A) (m : Matrix n n R) :\n    toFunBilinear R A n a m = a \u2022 m.map (algebraMap R A)", "start": [47, 1], "end": [50, 6], "kind": "commanddeclaration"}, {"full_name": "MatrixEquivTensor.toFunLinear", "code": "def toFunLinear : A \u2297[R] Matrix n n R \u2192\u2097[R] Matrix n n A :=\n  TensorProduct.lift (toFunBilinear R A n)", "start": [53, 1], "end": [58, 43], "kind": "commanddeclaration"}, {"full_name": "MatrixEquivTensor.toFunAlgHom", "code": "def toFunAlgHom : A \u2297[R] Matrix n n R \u2192\u2090[R] Matrix n n A :=\n  algHomOfLinearMapTensorProduct (toFunLinear R A n)\n    (by\n      intros\n      simp_rw [toFunLinear, lift.tmul, toFunBilinear_apply, Matrix.map_mul]\n      ext\n      dsimp\n      simp_rw [Matrix.mul_apply, Matrix.smul_apply, Matrix.map_apply, smul_eq_mul, Finset.mul_sum,\n        _root_.mul_assoc, Algebra.left_comm])\n    (by\n      simp_rw [toFunLinear, lift.tmul, toFunBilinear_apply,\n        Matrix.map_one (algebraMap R A) (map_zero _) (map_one _), one_smul])", "start": [63, 1], "end": [76, 77], "kind": "commanddeclaration"}, {"full_name": "MatrixEquivTensor.toFunAlgHom_apply", "code": "@[simp]\ntheorem toFunAlgHom_apply (a : A) (m : Matrix n n R) :\n    toFunAlgHom R A n (a \u2297\u209c m) = a \u2022 m.map (algebraMap R A)", "start": [79, 1], "end": [81, 67], "kind": "commanddeclaration"}, {"full_name": "MatrixEquivTensor.invFun", "code": "def invFun (M : Matrix n n A) : A \u2297[R] Matrix n n R :=\n  \u2211 p : n \u00d7 n, M p.1 p.2 \u2297\u209c stdBasisMatrix p.1 p.2 1", "start": [84, 1], "end": [90, 53], "kind": "commanddeclaration"}, {"full_name": "MatrixEquivTensor.invFun_zero", "code": "@[simp]\ntheorem invFun_zero : invFun R A n 0 = 0", "start": [93, 1], "end": [94, 61], "kind": "commanddeclaration"}, {"full_name": "MatrixEquivTensor.invFun_add", "code": "@[simp]\ntheorem invFun_add (M N : Matrix n n A) : invFun R A n (M + N) = invFun R A n M + invFun R A n N", "start": [97, 1], "end": [99, 53], "kind": "commanddeclaration"}, {"full_name": "MatrixEquivTensor.invFun_smul", "code": "@[simp]\ntheorem invFun_smul (a : A) (M : Matrix n n A) : invFun R A n (a \u2022 M) = a \u2297\u209c 1 * invFun R A n M", "start": [102, 1], "end": [104, 35], "kind": "commanddeclaration"}, {"full_name": "MatrixEquivTensor.invFun_algebraMap", "code": "@[simp]\ntheorem invFun_algebraMap (M : Matrix n n R) : invFun R A n (M.map (algebraMap R A)) = 1 \u2297\u209c M", "start": [107, 1], "end": [113, 55], "kind": "commanddeclaration"}, {"full_name": "MatrixEquivTensor.right_inv", "code": "theorem right_inv (M : Matrix n n A) : (toFunAlgHom R A n) (invFun R A n M) = M", "start": [116, 1], "end": [124, 22], "kind": "commanddeclaration"}, {"full_name": "MatrixEquivTensor.left_inv", "code": "theorem left_inv (M : A \u2297[R] Matrix n n R) : invFun R A n (toFunAlgHom R A n M) = M", "start": [127, 1], "end": [133, 46], "kind": "commanddeclaration"}, {"full_name": "MatrixEquivTensor.equiv", "code": "def equiv : A \u2297[R] Matrix n n R \u2243 Matrix n n A where\n  toFun := toFunAlgHom R A n\n  invFun := invFun R A n\n  left_inv := left_inv R A n\n  right_inv := right_inv R A n", "start": [136, 1], "end": [144, 31], "kind": "commanddeclaration"}, {"full_name": "matrixEquivTensor", "code": "def matrixEquivTensor : Matrix n n A \u2243\u2090[R] A \u2297[R] Matrix n n R :=\n  AlgEquiv.symm { MatrixEquivTensor.toFunAlgHom R A n, MatrixEquivTensor.equiv R A n with }", "start": [151, 1], "end": [154, 92], "kind": "commanddeclaration"}, {"full_name": "matrixEquivTensor_apply", "code": "@[simp]\ntheorem matrixEquivTensor_apply (M : Matrix n n A) :\n    matrixEquivTensor R A n M = \u2211 p : n \u00d7 n, M p.1 p.2 \u2297\u209c stdBasisMatrix p.1 p.2 1", "start": [159, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "matrixEquivTensor_apply_std_basis", "code": "@[simp (high)]\ntheorem matrixEquivTensor_apply_std_basis (i j : n) (x : A) :\n    matrixEquivTensor R A n (stdBasisMatrix i j x) = x \u2297\u209c stdBasisMatrix i j 1", "start": [166, 1], "end": [170, 37], "kind": "commanddeclaration"}, {"full_name": "matrixEquivTensor_apply_symm", "code": "@[simp]\ntheorem matrixEquivTensor_apply_symm (a : A) (M : Matrix n n R) :\n    (matrixEquivTensor R A n).symm (a \u2297\u209c M) = M.map fun x => a * algebraMap R A x", "start": [173, 1], "end": [176, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Over.lean", "imports": ["Mathlib/CategoryTheory/Functor/EpiMono.lean", "Mathlib/CategoryTheory/StructuredArrow.lean", "Mathlib/CategoryTheory/PUnit.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Functor/ReflectsIso.lean"], "premises": [{"full_name": "CategoryTheory.Over", "code": "def Over (X : T) :=\n  CostructuredArrow (\ud835\udfed T) X", "start": [35, 1], "end": [41, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.inhabited", "code": "instance Over.inhabited [Inhabited T] : Inhabited (Over (default : T)) where\n  default :=\n    { left := default\n      right := default\n      hom := \ud835\udfd9 _ }", "start": [47, 1], "end": [51, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.OverMorphism.ext", "code": "@[ext]\ntheorem OverMorphism.ext {X : T} {U V : Over X} {f g : U \u27f6 V} (h : f.left = g.left) : f = g", "start": [58, 1], "end": [63, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.over_right", "code": "theorem over_right (U : Over X) : U.right = \u27e8\u27e8\u27e9\u27e9", "start": [67, 1], "end": [67, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.id_left", "code": "@[simp]\ntheorem id_left (U : Over X) : CommaMorphism.left (\ud835\udfd9 U) = \ud835\udfd9 U.left", "start": [70, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.comp_left", "code": "@[simp]\ntheorem comp_left (a b c : Over X) (f : a \u27f6 b) (g : b \u27f6 c) : (f \u226b g).left = f.left \u226b g.left", "start": [75, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.w", "code": "@[reassoc (attr := simp)]\ntheorem w {A B : Over X} (f : A \u27f6 B) : f.left \u226b B.hom = A.hom", "start": [80, 1], "end": [81, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.mk", "code": "@[simps! left hom]\ndef mk {X Y : T} (f : Y \u27f6 X) : Over X :=\n  CostructuredArrow.mk f", "start": [84, 1], "end": [87, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.coeFromHom", "code": "def coeFromHom {X Y : T} : CoeOut (Y \u27f6 X) (Over X) where coe := mk", "start": [90, 1], "end": [92, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.coe_hom", "code": "@[simp]\ntheorem coe_hom {X Y : T} (f : Y \u27f6 X) : (f : Over X).hom = f", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.homMk", "code": "@[simps!]\ndef homMk {U V : Over X} (f : U.left \u27f6 V.left) (w : f \u226b V.hom = U.hom := by aesop_cat) : U \u27f6 V :=\n  CostructuredArrow.homMk f w", "start": [106, 1], "end": [110, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.isoMk", "code": "@[simps!]\ndef isoMk {f g : Over X} (hl : f.left \u2245 g.left) (hw : hl.hom \u226b g.hom = f.hom := by aesop_cat) :\n    f \u2245 g :=\n  CostructuredArrow.isoMk hl hw", "start": [116, 1], "end": [122, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.forget", "code": "def forget : Over X \u2964 T :=\n  Comma.fst _ _", "start": [132, 1], "end": [137, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.forget_obj", "code": "@[simp]\ntheorem forget_obj {U : Over X} : (forget X).obj U = U.left", "start": [142, 1], "end": [144, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.forget_map", "code": "@[simp]\ntheorem forget_map {U V : Over X} {f : U \u27f6 V} : (forget X).map f = f.left", "start": [147, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.forgetCocone", "code": "@[simps]\ndef forgetCocone (X : T) : Limits.Cocone (forget X) :=\n  { pt := X\n    \u03b9 := { app := Comma.hom } }", "start": [152, 1], "end": [156, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.map", "code": "def map {Y : T} (f : X \u27f6 Y) : Over X \u2964 Over Y :=\n  Comma.mapRight _ <| Discrete.natTrans fun _ => f", "start": [159, 1], "end": [164, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.map_obj_left", "code": "@[simp]\ntheorem map_obj_left : ((map f).obj U).left = U.left", "start": [171, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.map_obj_hom", "code": "@[simp]\ntheorem map_obj_hom : ((map f).obj U).hom = U.hom \u226b f", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.map_map_left", "code": "@[simp]\ntheorem map_map_left : ((map f).map g).left = g.left", "start": [181, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.mapId", "code": "def mapId : map (\ud835\udfd9 Y) \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)", "start": [186, 1], "end": [188, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.mapComp", "code": "def mapComp {Y Z : T} (f : X \u27f6 Y) (g : Y \u27f6 Z) : map (f \u226b g) \u2245 map f \u22d9 map g :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)", "start": [191, 1], "end": [193, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.forget_reflects_iso", "code": "instance forget_reflects_iso : ReflectsIsomorphisms (forget X) where\n  reflects {Y Z} f t := by\n    let g : Z \u27f6 Y := Over.homMk (inv ((forget X).map f))\n      ((asIso ((forget X).map f)).inv_comp_eq.2 (Over.w f).symm)\n    dsimp [forget] at t\n    refine \u27e8\u27e8g, \u27e8?_,?_\u27e9\u27e9\u27e9\n    repeat (ext; simp)", "start": [198, 1], "end": [204, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.mkIdTerminal", "code": "def mkIdTerminal : Limits.IsTerminal (mk (\ud835\udfd9 X)) :=\n  CostructuredArrow.mkIdTerminal", "start": [207, 1], "end": [209, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.forget_faithful", "code": "instance forget_faithful : Faithful (forget X) where", "start": [211, 1], "end": [211, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.epi_of_epi_left", "code": "theorem epi_of_epi_left {f g : Over X} (k : f \u27f6 g) [hk : Epi k.left] : Epi k", "start": [215, 1], "end": [222, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.mono_of_mono_left", "code": "theorem mono_of_mono_left {f g : Over X} (k : f \u27f6 g) [hk : Mono k.left] : Mono k", "start": [225, 1], "end": [233, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.mono_left_of_mono", "code": "instance mono_left_of_mono {f g : Over X} (k : f \u27f6 g) [Mono k] : Mono k.left := by\n  refine' \u27e8fun { Y : T } l m a => _\u27e9\n  let l' : mk (m \u226b f.hom) \u27f6 f := homMk l (by\n        dsimp; rw [\u2190 Over.w k, \u2190Category.assoc, congrArg (\u00b7 \u226b g.hom) a, Category.assoc])\n  suffices l' = (homMk m : mk (m \u226b f.hom) \u27f6 f) by apply congrArg CommaMorphism.left this\n  rw [\u2190 cancel_mono k]\n  ext\n  apply a", "start": [236, 1], "end": [248, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.iteratedSliceForward", "code": "@[simps]\ndef iteratedSliceForward : Over f \u2964 Over f.left\n    where\n  obj \u03b1 := Over.mk \u03b1.hom.left\n  map \u03ba := Over.homMk \u03ba.left.left (by dsimp; rw [\u2190 Over.w \u03ba]; rfl)", "start": [255, 1], "end": [260, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.iteratedSliceBackward", "code": "@[simps]\ndef iteratedSliceBackward : Over f.left \u2964 Over f\n    where\n  obj g := mk (homMk g.hom : mk (g.hom \u226b f.hom) \u27f6 f)\n  map \u03b1 := homMk (homMk \u03b1.left (w_assoc \u03b1 f.hom)) (OverMorphism.ext (w \u03b1))", "start": [263, 1], "end": [268, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.iteratedSliceEquiv", "code": "@[simps]\ndef iteratedSliceEquiv : Over f \u224c Over f.left\n    where\n  functor := iteratedSliceForward f\n  inverse := iteratedSliceBackward f\n  unitIso := NatIso.ofComponents (fun g => Over.isoMk (Over.isoMk (Iso.refl _)))\n  counitIso := NatIso.ofComponents (fun g => Over.isoMk (Iso.refl _))", "start": [271, 1], "end": [278, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.iteratedSliceForward_forget", "code": "theorem iteratedSliceForward_forget :\n    iteratedSliceForward f \u22d9 forget f.left = forget f \u22d9 forget X", "start": [281, 1], "end": [283, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.iteratedSliceBackward_forget_forget", "code": "theorem iteratedSliceBackward_forget_forget :\n    iteratedSliceBackward f \u22d9 forget f \u22d9 forget X = forget f.left", "start": [286, 1], "end": [288, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.post", "code": "@[simps]\ndef post (F : T \u2964 D) : Over X \u2964 Over (F.obj X)\n    where\n  obj Y := mk <| F.map Y.hom\n  map f := Over.homMk (F.map f.left)\n    (by simp only [Functor.id_obj, mk_left, Functor.const_obj_obj, mk_hom, \u2190 F.map_comp, w])", "start": [297, 1], "end": [303, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.toOver", "code": "@[simps!]\ndef toOver (F : D \u2964 T) (X : T) : CostructuredArrow F X \u2964 Over X :=\n  CostructuredArrow.pre F (\ud835\udfed T) X", "start": [314, 1], "end": [318, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.isEquivalenceToOver", "code": "noncomputable def isEquivalenceToOver (F : D \u2964 T) (X : T) [IsEquivalence F] :\n    IsEquivalence (toOver F X) :=\n  CostructuredArrow.isEquivalencePre _ _ _", "start": [329, 1], "end": [332, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under", "code": "def Under (X : T) :=\n  StructuredArrow X (\ud835\udfed T)", "start": [336, 1], "end": [339, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.inhabited", "code": "instance Under.inhabited [Inhabited T] : Inhabited (Under (default : T)) where\n  default :=\n    { left := default\n      right := default\n      hom := \ud835\udfd9 _ }", "start": [345, 1], "end": [349, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.UnderMorphism.ext", "code": "@[ext]\ntheorem UnderMorphism.ext {X : T} {U V : Under X} {f g : U \u27f6 V} (h : f.right = g.right) :\n    f = g", "start": [356, 1], "end": [360, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.under_left", "code": "theorem under_left (U : Under X) : U.left = \u27e8\u27e8\u27e9\u27e9", "start": [364, 1], "end": [364, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.id_right", "code": "@[simp]\ntheorem id_right (U : Under X) : CommaMorphism.right (\ud835\udfd9 U) = \ud835\udfd9 U.right", "start": [367, 1], "end": [369, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.comp_right", "code": "@[simp]\ntheorem comp_right (a b c : Under X) (f : a \u27f6 b) (g : b \u27f6 c) : (f \u226b g).right = f.right \u226b g.right", "start": [372, 1], "end": [374, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.w", "code": "@[reassoc (attr := simp)]\ntheorem w {A B : Under X} (f : A \u27f6 B) : A.hom \u226b f.right = B.hom", "start": [377, 1], "end": [378, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.mk", "code": "@[simps! right hom]\ndef mk {X Y : T} (f : X \u27f6 Y) : Under X :=\n  StructuredArrow.mk f", "start": [381, 1], "end": [384, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.homMk", "code": "@[simps!]\ndef homMk {U V : Under X} (f : U.right \u27f6 V.right) (w : U.hom \u226b f = V.hom := by aesop_cat) : U \u27f6 V :=\n  StructuredArrow.homMk f w", "start": [387, 1], "end": [391, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.isoMk", "code": "def isoMk {f g : Under X} (hr : f.right \u2245 g.right)\n    (hw : f.hom \u226b hr.hom = g.hom := by aesop_cat) : f \u2245 g :=\n  StructuredArrow.isoMk hr hw", "start": [397, 1], "end": [402, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.isoMk_hom_right", "code": "@[simp]\ntheorem isoMk_hom_right {f g : Under X} (hr : f.right \u2245 g.right) (hw : f.hom \u226b hr.hom = g.hom) :\n    (isoMk hr hw).hom.right = hr.hom", "start": [405, 1], "end": [408, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.isoMk_inv_right", "code": "@[simp]\ntheorem isoMk_inv_right {f g : Under X} (hr : f.right \u2245 g.right) (hw : f.hom \u226b hr.hom = g.hom) :\n    (isoMk hr hw).inv.right = hr.inv", "start": [411, 1], "end": [414, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.forget", "code": "def forget : Under X \u2964 T :=\n  Comma.snd _ _", "start": [421, 1], "end": [423, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.forget_obj", "code": "@[simp]\ntheorem forget_obj {U : Under X} : (forget X).obj U = U.right", "start": [428, 1], "end": [430, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.forget_map", "code": "@[simp]\ntheorem forget_map {U V : Under X} {f : U \u27f6 V} : (forget X).map f = f.right", "start": [433, 1], "end": [435, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.forgetCone", "code": "@[simps]\ndef forgetCone (X : T) : Limits.Cone (forget X) :=\n  { pt := X\n    \u03c0 := { app := Comma.hom } }", "start": [438, 1], "end": [442, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.map", "code": "def map {Y : T} (f : X \u27f6 Y) : Under Y \u2964 Under X :=\n  Comma.mapLeft _ <| Discrete.natTrans fun _ => f", "start": [445, 1], "end": [447, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.map_obj_right", "code": "@[simp]\ntheorem map_obj_right : ((map f).obj U).right = U.right", "start": [454, 1], "end": [456, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.map_obj_hom", "code": "@[simp]\ntheorem map_obj_hom : ((map f).obj U).hom = f \u226b U.hom", "start": [459, 1], "end": [461, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.map_map_right", "code": "@[simp]\ntheorem map_map_right : ((map f).map g).right = g.right", "start": [464, 1], "end": [466, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.mapId", "code": "def mapId : map (\ud835\udfd9 Y) \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)", "start": [469, 1], "end": [471, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.mapComp", "code": "def mapComp {Y Z : T} (f : X \u27f6 Y) (g : Y \u27f6 Z) : map (f \u226b g) \u2245 map g \u22d9 map f :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)", "start": [474, 1], "end": [476, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.forget_reflects_iso", "code": "instance forget_reflects_iso : ReflectsIsomorphisms (forget X) where\n  reflects {Y Z} f t := by\n    let g : Z \u27f6 Y := Under.homMk (inv ((Under.forget X).map f))\n      ((IsIso.comp_inv_eq _).2 (Under.w f).symm)\n    dsimp [forget] at t\n    refine \u27e8\u27e8g, \u27e8?_,?_\u27e9\u27e9\u27e9\n    repeat (ext; simp)", "start": [481, 1], "end": [487, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.mkIdInitial", "code": "def mkIdInitial : Limits.IsInitial (mk (\ud835\udfd9 X)) :=\n  StructuredArrow.mkIdInitial", "start": [490, 1], "end": [492, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.forget_faithful", "code": "instance forget_faithful : Faithful (forget X) where", "start": [494, 1], "end": [494, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.mono_of_mono_right", "code": "theorem mono_of_mono_right {f g : Under X} (k : f \u27f6 g) [hk : Mono k.right] : Mono k", "start": [498, 1], "end": [504, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.epi_of_epi_right", "code": "theorem epi_of_epi_right {f g : Under X} (k : f \u27f6 g) [hk : Epi k.right] : Epi k", "start": [507, 1], "end": [515, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.epi_right_of_epi", "code": "instance epi_right_of_epi {f g : Under X} (k : f \u27f6 g) [Epi k] : Epi k.right := by\n  refine' \u27e8fun { Y : T } l m a => _\u27e9\n  let l' : g \u27f6 mk (g.hom \u226b m) := homMk l (by\n    dsimp; rw [\u2190 Under.w k, Category.assoc, a, Category.assoc])\n  suffices l' = (homMk m : g \u27f6 mk (g.hom \u226b m)) by apply congrArg CommaMorphism.right this\n  rw [\u2190 cancel_epi k]; ext; apply a", "start": [518, 1], "end": [529, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.post", "code": "@[simps]\ndef post {X : T} (F : T \u2964 D) : Under X \u2964 Under (F.obj X) where\n  obj Y := mk <| F.map Y.hom\n  map f := Under.homMk (F.map f.right)\n    (by simp only [Functor.id_obj, Functor.const_obj_obj, mk_right, mk_hom, \u2190 F.map_comp, w])", "start": [536, 1], "end": [541, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.toUnder", "code": "@[simps!]\ndef toUnder (X : T) (F : D \u2964 T) : StructuredArrow X F \u2964 Under X :=\n  StructuredArrow.pre X F (\ud835\udfed T)", "start": [552, 1], "end": [556, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.isEquivalenceToUnder", "code": "noncomputable def isEquivalenceToUnder (X : T) (F : D \u2964 T) [IsEquivalence F] :\n    IsEquivalence (toUnder X F) :=\n  StructuredArrow.isEquivalencePre _ _ _", "start": [567, 1], "end": [570, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toOver", "code": "@[simps! obj_left map_left]\ndef toOver (F : S \u2964 T) (X : T) (f : (Y : S) \u2192 F.obj Y \u27f6 X)\n    (h : \u2200 {Y Z : S} (g : Y \u27f6 Z), F.map g \u226b f Z = f Y) : S \u2964 Over X :=\n  F.toCostructuredArrow (\ud835\udfed _) X f h", "start": [578, 1], "end": [584, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toOverCompForget", "code": "def toOverCompForget (F : S \u2964 T) (X : T) (f : (Y : S) \u2192 F.obj Y \u27f6 X)\n    (h : \u2200 {Y Z : S} (g : Y \u27f6 Z), F.map g \u226b f Z = f Y) : F.toOver X f h \u22d9 Over.forget _ \u2245 F :=\n  Iso.refl _", "start": [586, 1], "end": [590, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toOver_comp_forget", "code": "@[simp]\nlemma toOver_comp_forget (F : S \u2964 T) (X : T) (f : (Y : S) \u2192 F.obj Y \u27f6 X)\n    (h : \u2200 {Y Z : S} (g : Y \u27f6 Z), F.map g \u226b f Z = f Y) : F.toOver X f h \u22d9 Over.forget _ = F :=\n  rfl", "start": [592, 1], "end": [595, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.toUnder", "code": "@[simps! obj_right map_right]\ndef toUnder (F : S \u2964 T) (X : T) (f : (Y : S) \u2192 X \u27f6 F.obj Y)\n    (h : \u2200 {Y Z : S} (g : Y \u27f6 Z), f Y \u226b F.map g = f Z) : S \u2964 Under X :=\n  F.toStructuredArrow X (\ud835\udfed _) f h", "start": [597, 1], "end": [603, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toUnderCompForget", "code": "def toUnderCompForget (F : S \u2964 T) (X : T) (f : (Y : S) \u2192 X \u27f6 F.obj Y)\n    (h : \u2200 {Y Z : S} (g : Y \u27f6 Z), f Y \u226b F.map g = f Z) : F.toUnder X f h \u22d9 Under.forget _ \u2245 F :=\n  Iso.refl _", "start": [605, 1], "end": [609, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toUnder_comp_forget", "code": "@[simp]\nlemma toUnder_comp_forget (F : S \u2964 T) (X : T) (f : (Y : S) \u2192 X \u27f6 F.obj Y)\n    (h : \u2200 {Y Z : S} (g : Y \u27f6 Z), f Y \u226b F.map g = f Z) : F.toUnder X f h \u22d9 Under.forget _ = F :=\n  rfl", "start": [611, 1], "end": [614, 6], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/RingTheory/SimpleModule.lean", "imports": ["Mathlib/LinearAlgebra/Isomorphisms.lean", "Mathlib/Order/JordanHolder.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsSimpleModule", "code": "abbrev IsSimpleModule :=\n  IsSimpleOrder (Submodule R M)", "start": [34, 1], "end": [36, 32], "kind": "commanddeclaration"}, {"full_name": "IsSemisimpleModule", "code": "abbrev IsSemisimpleModule :=\n  ComplementedLattice (Submodule R M)", "start": [39, 1], "end": [42, 38], "kind": "commanddeclaration"}, {"full_name": "IsSimpleModule.nontrivial", "code": "theorem IsSimpleModule.nontrivial [IsSimpleModule R M] : Nontrivial M", "start": [46, 1], "end": [51, 57], "kind": "commanddeclaration"}, {"full_name": "IsSimpleModule.congr", "code": "theorem IsSimpleModule.congr (l : M \u2243\u2097[R] N) [IsSimpleModule R N] : IsSimpleModule R M", "start": [57, 1], "end": [58, 47], "kind": "commanddeclaration"}, {"full_name": "isSimpleModule_iff_isAtom", "code": "theorem isSimpleModule_iff_isAtom : IsSimpleModule R m \u2194 IsAtom m", "start": [61, 1], "end": [64, 38], "kind": "commanddeclaration"}, {"full_name": "isSimpleModule_iff_isCoatom", "code": "theorem isSimpleModule_iff_isCoatom : IsSimpleModule R (M \u29f8 m) \u2194 IsCoatom m", "start": [67, 1], "end": [70, 35], "kind": "commanddeclaration"}, {"full_name": "covby_iff_quot_is_simple", "code": "theorem covby_iff_quot_is_simple {A B : Submodule R M} (hAB : A \u2264 B) :\n    A \u22d6 B \u2194 IsSimpleModule R (B \u29f8 Submodule.comap B.subtype A)", "start": [73, 1], "end": [80, 24], "kind": "commanddeclaration"}, {"full_name": "IsSimpleModule.isAtom", "code": "@[simp]\ntheorem isAtom : IsAtom m", "start": [87, 1], "end": [89, 33], "kind": "commanddeclaration"}, {"full_name": "is_semisimple_of_sSup_simples_eq_top", "code": "theorem is_semisimple_of_sSup_simples_eq_top\n    (h : sSup { m : Submodule R M | IsSimpleModule R m } = \u22a4) : IsSemisimpleModule R M", "start": [94, 1], "end": [96, 89], "kind": "commanddeclaration"}, {"full_name": "IsSemisimpleModule.sSup_simples_eq_top", "code": "theorem sSup_simples_eq_top : sSup { m : Submodule R M | IsSimpleModule R m } = \u22a4", "start": [103, 1], "end": [105, 26], "kind": "commanddeclaration"}, {"full_name": "IsSemisimpleModule.is_semisimple_submodule", "code": "instance is_semisimple_submodule {m : Submodule R M} : IsSemisimpleModule R m :=\n  haveI f : Submodule R m \u2243o Set.Iic m := Submodule.MapSubtype.relIso m\n  f.complementedLattice_iff.2 IsModularLattice.complementedLattice_Iic", "start": [108, 1], "end": [110, 71], "kind": "commanddeclaration"}, {"full_name": "is_semisimple_iff_top_eq_sSup_simples", "code": "theorem is_semisimple_iff_top_eq_sSup_simples :\n    sSup { m : Submodule R M | IsSimpleModule R m } = \u22a4 \u2194 IsSemisimpleModule R M", "start": [115, 1], "end": [119, 50], "kind": "commanddeclaration"}, {"full_name": "LinearMap.injective_or_eq_zero", "code": "theorem injective_or_eq_zero [IsSimpleModule R M] (f : M \u2192\u2097[R] N) :\n    Function.Injective f \u2228 f = 0", "start": [124, 1], "end": [127, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.injective_of_ne_zero", "code": "theorem injective_of_ne_zero [IsSimpleModule R M] {f : M \u2192\u2097[R] N} (h : f \u2260 0) :\n    Function.Injective f", "start": [130, 1], "end": [132, 41], "kind": "commanddeclaration"}, {"full_name": "LinearMap.surjective_or_eq_zero", "code": "theorem surjective_or_eq_zero [IsSimpleModule R N] (f : M \u2192\u2097[R] N) :\n    Function.Surjective f \u2228 f = 0", "start": [135, 1], "end": [138, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.surjective_of_ne_zero", "code": "theorem surjective_of_ne_zero [IsSimpleModule R N] {f : M \u2192\u2097[R] N} (h : f \u2260 0) :\n    Function.Surjective f", "start": [141, 1], "end": [143, 42], "kind": "commanddeclaration"}, {"full_name": "LinearMap.bijective_or_eq_zero", "code": "theorem bijective_or_eq_zero [IsSimpleModule R M] [IsSimpleModule R N] (f : M \u2192\u2097[R] N) :\n    Function.Bijective f \u2228 f = 0", "start": [146, 1], "end": [152, 74], "kind": "commanddeclaration"}, {"full_name": "LinearMap.bijective_of_ne_zero", "code": "theorem bijective_of_ne_zero [IsSimpleModule R M] [IsSimpleModule R N] {f : M \u2192\u2097[R] N} (h : f \u2260 0) :\n    Function.Bijective f", "start": [155, 1], "end": [157, 41], "kind": "commanddeclaration"}, {"full_name": "LinearMap.isCoatom_ker_of_surjective", "code": "theorem isCoatom_ker_of_surjective [IsSimpleModule R N] {f : M \u2192\u2097[R] N}\n    (hf : Function.Surjective f) : IsCoatom (LinearMap.ker f)", "start": [160, 1], "end": [163, 61], "kind": "commanddeclaration"}, {"full_name": "Module.End.divisionRing", "code": "noncomputable instance _root_.Module.End.divisionRing\n    [DecidableEq (Module.End R M)] [IsSimpleModule R M] : DivisionRing (Module.End R M) :=\n  {\n    (Module.End.ring :\n      Ring\n        (Module.End R\n          M)) with\n    inv := fun f =>\n      if h : f = 0 then 0\n      else\n        LinearMap.inverse f (Equiv.ofBijective _ (bijective_of_ne_zero h)).invFun\n          (Equiv.ofBijective _ (bijective_of_ne_zero h)).left_inv\n          (Equiv.ofBijective _ (bijective_of_ne_zero h)).right_inv\n    exists_pair_ne :=\n      \u27e80, 1, by\n        haveI := IsSimpleModule.nontrivial R M\n        have h := exists_pair_ne M\n        contrapose! h\n        intro x y\n        simp_rw [ext_iff, one_apply, zero_apply] at h\n        rw [\u2190 h x, h y]\u27e9\n    mul_inv_cancel := by\n      intro a a0\n      change a * dite _ _ _ = 1\n      ext x\n      rw [dif_neg a0, mul_eq_comp, one_apply, comp_apply]\n      exact (Equiv.ofBijective _ (bijective_of_ne_zero a0)).right_inv x\n    inv_zero := dif_pos rfl }", "start": [166, 1], "end": [194, 30], "kind": "commanddeclaration"}, {"full_name": "JordanHolderModule.Iso", "code": "def Iso (X Y : Submodule R M \u00d7 Submodule R M) : Prop :=\n  Nonempty <| (X.2 \u29f8 X.1.comap X.2.subtype) \u2243\u2097[R] Y.2 \u29f8 Y.1.comap Y.2.subtype", "start": [204, 1], "end": [207, 78], "kind": "commanddeclaration"}, {"full_name": "JordanHolderModule.iso_symm", "code": "theorem iso_symm {X Y : Submodule R M \u00d7 Submodule R M} : Iso X Y \u2192 Iso Y X", "start": [209, 1], "end": [210, 22], "kind": "commanddeclaration"}, {"full_name": "JordanHolderModule.iso_trans", "code": "theorem iso_trans {X Y Z : Submodule R M \u00d7 Submodule R M} : Iso X Y \u2192 Iso Y Z \u2192 Iso X Z", "start": [212, 1], "end": [213, 29], "kind": "commanddeclaration"}, {"full_name": "JordanHolderModule.second_iso", "code": "@[nolint unusedArguments]\ntheorem second_iso {X Y : Submodule R M} (_ : X \u22d6 X \u2294 Y) :\n    Iso (X,X \u2294 Y) (X \u2293 Y,Y)", "start": [215, 1], "end": [221, 57], "kind": "commanddeclaration"}, {"full_name": "JordanHolderModule.instJordanHolderLattice", "code": "instance instJordanHolderLattice : JordanHolderLattice (Submodule R M) where\n  IsMaximal := (\u00b7 \u22d6 \u00b7)\n  lt_of_isMaximal := Covby.lt\n  sup_eq_of_isMaximal hxz hyz := Wcovby.sup_eq hxz.wcovby hyz.wcovby\n  isMaximal_inf_left_of_isMaximal_sup := inf_covby_of_covby_sup_of_covby_sup_left\n  Iso := Iso\n  iso_symm := iso_symm\n  iso_trans := iso_trans\n  second_iso := second_iso", "start": [223, 1], "end": [231, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Determinant.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Basis.lean", "Mathlib/LinearAlgebra/GeneralLinearGroup.lean", "Mathlib/LinearAlgebra/FiniteDimensional.lean", "Mathlib/Tactic/FieldSimp.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "Mathlib/LinearAlgebra/Matrix/Reindex.lean"], "premises": [{"full_name": "equivOfPiLEquivPi", "code": "def equivOfPiLEquivPi {R : Type*} [CommRing R] [Nontrivial R] (e : (m \u2192 R) \u2243\u2097[R] n \u2192 R) : m \u2243 n :=\n  Basis.indexEquiv (Basis.ofEquivFun e.symm) (Pi.basisFun _ _)", "start": [65, 1], "end": [67, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.indexEquivOfInv", "code": "def indexEquivOfInv [Nontrivial A] [DecidableEq m] [DecidableEq n] {M : Matrix m n A}\n    {M' : Matrix n m A} (hMM' : M * M' = 1) (hM'M : M' * M = 1) : m \u2243 n :=\n  equivOfPiLEquivPi (toLin'OfInv hMM' hM'M)", "start": [72, 1], "end": [76, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_comm", "code": "theorem det_comm [DecidableEq n] (M N : Matrix n n A) : det (M * N) = det (N * M)", "start": [79, 1], "end": [80, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_comm'", "code": "theorem det_comm' [DecidableEq m] [DecidableEq n] {M : Matrix n m A} {N : Matrix m n A}\n    {M' : Matrix m n A} (hMM' : M * M' = 1) (hM'M : M' * M = 1) : det (M * N) = det (N * M)", "start": [83, 1], "end": [92, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_conj_of_mul_eq_one", "code": "theorem det_conj_of_mul_eq_one [DecidableEq m] [DecidableEq n] {M : Matrix m n A}\n    {M' : Matrix n m A} {N : Matrix n n A} (hMM' : M * M' = 1) (hM'M : M' * M = 1) :\n    det (M * N * M') = det N", "start": [95, 1], "end": [101, 71], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_toMatrix_eq_det_toMatrix", "code": "theorem det_toMatrix_eq_det_toMatrix [DecidableEq \u03ba] (b : Basis \u03b9 A M) (c : Basis \u03ba A M)\n    (f : M \u2192\u2097[A] M) : det (LinearMap.toMatrix b b f) = det (LinearMap.toMatrix c c f)", "start": [117, 1], "end": [122, 58], "kind": "commanddeclaration"}, {"full_name": "LinearMap.detAux", "code": "irreducible_def detAux : Trunc (Basis \u03b9 A M) \u2192 (M \u2192\u2097[A] M) \u2192* A :=\n  Trunc.lift\n    (fun b : Basis \u03b9 A M => detMonoidHom.comp (toMatrixAlgEquiv b : (M \u2192\u2097[A] M) \u2192* Matrix \u03b9 \u03b9 A))\n    fun b c => MonoidHom.ext <| det_toMatrix_eq_det_toMatrix b c", "start": [126, 1], "end": [138, 65], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "LinearMap.detAux_def'", "code": "theorem detAux_def' (b : Basis \u03b9 A M) (f : M \u2192\u2097[A] M) :\n    LinearMap.detAux (Trunc.mk b) f = Matrix.det (LinearMap.toMatrix b b f)", "start": [141, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.detAux_def''", "code": "theorem detAux_def'' {\u03b9' : Type*} [Fintype \u03b9'] [DecidableEq \u03b9'] (tb : Trunc <| Basis \u03b9 A M)\n    (b' : Basis \u03b9' A M) (f : M \u2192\u2097[A] M) :\n    LinearMap.detAux tb f = Matrix.det (LinearMap.toMatrix b' b' f)", "start": [151, 1], "end": [155, 63], "kind": "commanddeclaration"}, {"full_name": "LinearMap.detAux_id", "code": "@[simp]\ntheorem detAux_id (b : Trunc <| Basis \u03b9 A M) : LinearMap.detAux b LinearMap.id = 1", "start": [158, 1], "end": [160, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.detAux_comp", "code": "@[simp]\ntheorem detAux_comp (b : Trunc <| Basis \u03b9 A M) (f g : M \u2192\u2097[A] M) :\n    LinearMap.detAux b (f.comp g) = LinearMap.detAux b f * LinearMap.detAux b g", "start": [163, 1], "end": [166, 35], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det", "code": "protected irreducible_def det : (M \u2192\u2097[A] M) \u2192* A :=\n  if H : \u2203 s : Finset M, Nonempty (Basis s A M) then LinearMap.detAux (Trunc.mk H.choose_spec.some)\n  else 1", "start": [174, 1], "end": [180, 9], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "LinearMap.coe_det", "code": "theorem coe_det [DecidableEq M] :\n    \u21d1(LinearMap.det : (M \u2192\u2097[A] M) \u2192* A) =\n      if H : \u2203 s : Finset M, Nonempty (Basis s A M) then\n        LinearMap.detAux (Trunc.mk H.choose_spec.some)\n      else 1", "start": [184, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_eq_det_toMatrix_of_finset", "code": "theorem det_eq_det_toMatrix_of_finset [DecidableEq M] {s : Finset M} (b : Basis s A M)\n    (f : M \u2192\u2097[A] M) : LinearMap.det f = Matrix.det (LinearMap.toMatrix b b f)", "start": [200, 1], "end": [203, 67], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_toMatrix", "code": "@[simp]\ntheorem det_toMatrix (b : Basis \u03b9 A M) (f : M \u2192\u2097[A] M) :\n    Matrix.det (toMatrix b b f) = LinearMap.det f", "start": [206, 1], "end": [213, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_toMatrix'", "code": "@[simp]\ntheorem det_toMatrix' {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (f : (\u03b9 \u2192 A) \u2192\u2097[A] \u03b9 \u2192 A) :\n    Matrix.det (LinearMap.toMatrix' f) = LinearMap.det f", "start": [216, 1], "end": [218, 94], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_toLin", "code": "@[simp]\ntheorem det_toLin (b : Basis \u03b9 R M) (f : Matrix \u03b9 \u03b9 R) :\n    LinearMap.det (Matrix.toLin b b f) = f.det", "start": [221, 1], "end": [224, 60], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_toLin'", "code": "@[simp]\ntheorem det_toLin' (f : Matrix \u03b9 \u03b9 R) : LinearMap.det (Matrix.toLin' f) = Matrix.det f", "start": [227, 1], "end": [229, 43], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_cases", "code": "theorem det_cases [DecidableEq M] {P : A \u2192 Prop} (f : M \u2192\u2097[A] M)\n    (hb : \u2200 (s : Finset M) (b : Basis s A M), P (Matrix.det (toMatrix b b f))) (h1 : P 1) :\n    P (LinearMap.det f)", "start": [232, 1], "end": [243, 13], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_comp", "code": "@[simp]\ntheorem det_comp (f g : M \u2192\u2097[A] M) :\n    LinearMap.det (f.comp g) = LinearMap.det f * LinearMap.det g", "start": [246, 1], "end": [249, 28], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_id", "code": "@[simp]\ntheorem det_id : LinearMap.det (LinearMap.id : M \u2192\u2097[A] M) = 1", "start": [252, 1], "end": [254, 24], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_smul", "code": "@[simp]\ntheorem det_smul {\ud835\udd5c : Type*} [Field \ud835\udd5c] {M : Type*} [AddCommGroup M] [Module \ud835\udd5c M] (c : \ud835\udd5c)\n    (f : M \u2192\u2097[\ud835\udd5c] M) :\n    LinearMap.det (c \u2022 f) = c ^ FiniteDimensional.finrank \ud835\udd5c M * LinearMap.det f", "start": [257, 1], "end": [270, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_zero'", "code": "theorem det_zero' {\u03b9 : Type*} [Finite \u03b9] [Nonempty \u03b9] (b : Basis \u03b9 A M) :\n    LinearMap.det (0 : M \u2192\u2097[A] M) = 0", "start": [273, 1], "end": [277, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_zero", "code": "@[simp]\ntheorem det_zero {\ud835\udd5c : Type*} [Field \ud835\udd5c] {M : Type*} [AddCommGroup M] [Module \ud835\udd5c M] :\n    LinearMap.det (0 : M \u2192\u2097[\ud835\udd5c] M) = (0 : \ud835\udd5c) ^ FiniteDimensional.finrank \ud835\udd5c M", "start": [280, 1], "end": [286, 82], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_eq_one_of_subsingleton", "code": "theorem det_eq_one_of_subsingleton [Subsingleton M] (f : M \u2192\u2097[R] M) :\n    LinearMap.det (f : M \u2192\u2097[R] M) = 1", "start": [289, 1], "end": [293, 27], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_eq_one_of_finrank_eq_zero", "code": "theorem det_eq_one_of_finrank_eq_zero {\ud835\udd5c : Type*} [Field \ud835\udd5c] {M : Type*} [AddCommGroup M]\n    [Module \ud835\udd5c M] (h : FiniteDimensional.finrank \ud835\udd5c M = 0) (f : M \u2192\u2097[\ud835\udd5c] M) :\n    LinearMap.det (f : M \u2192\u2097[\ud835\udd5c] M) = 1", "start": [296, 1], "end": [305, 29], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_conj", "code": "@[simp]\ntheorem det_conj {N : Type*} [AddCommGroup N] [Module A N] (f : M \u2192\u2097[A] M) (e : M \u2243\u2097[A] N) :\n    LinearMap.det ((e : M \u2192\u2097[A] N) \u2218\u2097 f \u2218\u2097 (e.symm : N \u2192\u2097[A] M)) = LinearMap.det f", "start": [308, 1], "end": [325, 63], "kind": "commanddeclaration"}, {"full_name": "LinearMap.isUnit_det", "code": "theorem isUnit_det {A : Type*} [CommRing A] [Module A M] (f : M \u2192\u2097[A] M) (hf : IsUnit f) :\n    IsUnit (LinearMap.det f)", "start": [328, 1], "end": [334, 38], "kind": "commanddeclaration"}, {"full_name": "LinearMap.finiteDimensional_of_det_ne_one", "code": "theorem finiteDimensional_of_det_ne_one {\ud835\udd5c : Type*} [Field \ud835\udd5c] [Module \ud835\udd5c M] (f : M \u2192\u2097[\ud835\udd5c] M)\n    (hf : LinearMap.det f \u2260 1) : FiniteDimensional \ud835\udd5c M", "start": [337, 1], "end": [343, 48], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_lt_top_of_det_eq_zero", "code": "theorem range_lt_top_of_det_eq_zero {\ud835\udd5c : Type*} [Field \ud835\udd5c] [Module \ud835\udd5c M] {f : M \u2192\u2097[\ud835\udd5c] M}\n    (hf : LinearMap.det f = 0) : LinearMap.range f < \u22a4", "start": [346, 1], "end": [352, 47], "kind": "commanddeclaration"}, {"full_name": "LinearMap.bot_lt_ker_of_det_eq_zero", "code": "theorem bot_lt_ker_of_det_eq_zero {\ud835\udd5c : Type*} [Field \ud835\udd5c] [Module \ud835\udd5c M] {f : M \u2192\u2097[\ud835\udd5c] M}\n    (hf : LinearMap.det f = 0) : \u22a5 < LinearMap.ker f", "start": [355, 1], "end": [361, 47], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.det", "code": "protected def det : (M \u2243\u2097[R] M) \u2192* R\u02e3 :=\n  (Units.map (LinearMap.det : (M \u2192\u2097[R] M) \u2192* R)).comp\n    (LinearMap.GeneralLinearGroup.generalLinearEquiv R M).symm.toMonoidHom", "start": [369, 1], "end": [372, 75], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_det", "code": "@[simp]\ntheorem coe_det (f : M \u2243\u2097[R] M) : \u2191(LinearEquiv.det f) = LinearMap.det (f : M \u2192\u2097[R] M)", "start": [375, 1], "end": [377, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_inv_det", "code": "@[simp]\ntheorem coe_inv_det (f : M \u2243\u2097[R] M) : \u2191(LinearEquiv.det f)\u207b\u00b9 = LinearMap.det (f.symm : M \u2192\u2097[R] M)", "start": [380, 1], "end": [382, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.det_refl", "code": "@[simp]\ntheorem det_refl : LinearEquiv.det (LinearEquiv.refl R M) = 1", "start": [385, 1], "end": [387, 32], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.det_trans", "code": "@[simp]\ntheorem det_trans (f g : M \u2243\u2097[R] M) :\n    LinearEquiv.det (f.trans g) = LinearEquiv.det g * LinearEquiv.det f", "start": [390, 1], "end": [393, 16], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.det_symm", "code": "@[simp, nolint simpNF]\ntheorem det_symm (f : M \u2243\u2097[R] M) : LinearEquiv.det f.symm = LinearEquiv.det f\u207b\u00b9", "start": [396, 1], "end": [398, 14], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.det_conj", "code": "@[simp]\ntheorem det_conj (f : M \u2243\u2097[R] M) (e : M \u2243\u2097[R] M') :\n    LinearEquiv.det ((e.symm.trans f).trans e) = LinearEquiv.det f", "start": [401, 1], "end": [405, 84], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.det_mul_det_symm", "code": "@[simp]\ntheorem LinearEquiv.det_mul_det_symm {A : Type*} [CommRing A] [Module A M] (f : M \u2243\u2097[A] M) :\n    LinearMap.det (f : M \u2192\u2097[A] M) * LinearMap.det (f.symm : M \u2192\u2097[A] M) = 1", "start": [412, 1], "end": [416, 30], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.det_symm_mul_det", "code": "@[simp]\ntheorem LinearEquiv.det_symm_mul_det {A : Type*} [CommRing A] [Module A M] (f : M \u2243\u2097[A] M) :\n    LinearMap.det (f.symm : M \u2192\u2097[A] M) * LinearMap.det (f : M \u2192\u2097[A] M) = 1", "start": [419, 1], "end": [423, 33], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.isUnit_det", "code": "theorem LinearEquiv.isUnit_det (f : M \u2243\u2097[R] M') (v : Basis \u03b9 R M) (v' : Basis \u03b9 R M') :\n    IsUnit (LinearMap.toMatrix v v' f).det", "start": [427, 1], "end": [430, 61], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.isUnit_det'", "code": "theorem LinearEquiv.isUnit_det' {A : Type*} [CommRing A] [Module A M] (f : M \u2243\u2097[A] M) :\n    IsUnit (LinearMap.det (f : M \u2192\u2097[A] M))", "start": [433, 1], "end": [436, 46], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.det_coe_symm", "code": "theorem LinearEquiv.det_coe_symm {\ud835\udd5c : Type*} [Field \ud835\udd5c] [Module \ud835\udd5c M] (f : M \u2243\u2097[\ud835\udd5c] M) :\n    LinearMap.det (f.symm : M \u2192\u2097[\ud835\udd5c] M) = (LinearMap.det (f : M \u2192\u2097[\ud835\udd5c] M))\u207b\u00b9", "start": [439, 1], "end": [442, 44], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofIsUnitDet", "code": "@[simps]\ndef LinearEquiv.ofIsUnitDet {f : M \u2192\u2097[R] M'} {v : Basis \u03b9 R M} {v' : Basis \u03b9 R M'}\n    (h : IsUnit (LinearMap.toMatrix v v' f).det) : M \u2243\u2097[R] M' where\n  toFun := f\n  map_add' := f.map_add\n  map_smul' := f.map_smul\n  invFun := toLin v' v (toMatrix v v' f)\u207b\u00b9\n  left_inv x :=\n    calc\n      toLin v' v (toMatrix v v' f)\u207b\u00b9 (f x) = toLin v v ((toMatrix v v' f)\u207b\u00b9 * toMatrix v v' f) x :=\n        by rw [toLin_mul v v' v, toLin_toMatrix, LinearMap.comp_apply]\n      _ = x := by simp [h]\n  right_inv x :=\n    calc\n      f (toLin v' v (toMatrix v v' f)\u207b\u00b9 x) =\n          toLin v' v' (toMatrix v v' f * (toMatrix v v' f)\u207b\u00b9) x :=\n        by rw [toLin_mul v' v v', LinearMap.comp_apply, toLin_toMatrix v v']\n      _ = x := by simp [h]", "start": [445, 1], "end": [463, 27], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_ofIsUnitDet", "code": "@[simp]\ntheorem LinearEquiv.coe_ofIsUnitDet {f : M \u2192\u2097[R] M'} {v : Basis \u03b9 R M} {v' : Basis \u03b9 R M'}\n    (h : IsUnit (LinearMap.toMatrix v v' f).det) :\n    (LinearEquiv.ofIsUnitDet h : M \u2192\u2097[R] M') = f", "start": [466, 1], "end": [471, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.equivOfDetNeZero", "code": "@[reducible]\ndef LinearMap.equivOfDetNeZero {\ud835\udd5c : Type*} [Field \ud835\udd5c] {M : Type*} [AddCommGroup M] [Module \ud835\udd5c M]\n    [FiniteDimensional \ud835\udd5c M] (f : M \u2192\u2097[\ud835\udd5c] M) (hf : LinearMap.det f \u2260 0) : M \u2243\u2097[\ud835\udd5c] M :=\n  have : IsUnit (LinearMap.toMatrix (FiniteDimensional.finBasis \ud835\udd5c M)\n      (FiniteDimensional.finBasis \ud835\udd5c M) f).det := by\n    rw [LinearMap.det_toMatrix]\n    exact isUnit_iff_ne_zero.2 hf\n  LinearEquiv.ofIsUnitDet this", "start": [474, 1], "end": [483, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.associated_det_of_eq_comp", "code": "theorem LinearMap.associated_det_of_eq_comp (e : M \u2243\u2097[R] M) (f f' : M \u2192\u2097[R] M)\n    (h : \u2200 x, f x = f' (e x)) : Associated (LinearMap.det f) (LinearMap.det f')", "start": [486, 1], "end": [493, 76], "kind": "commanddeclaration"}, {"full_name": "LinearMap.associated_det_comp_equiv", "code": "theorem LinearMap.associated_det_comp_equiv {N : Type*} [AddCommGroup N] [Module R N]\n    (f : N \u2192\u2097[R] M) (e e' : M \u2243\u2097[R] N) :\n    Associated (LinearMap.det (f \u2218\u2097 \u2191e)) (LinearMap.det (f \u2218\u2097 \u2191e'))", "start": [496, 1], "end": [502, 34], "kind": "commanddeclaration"}, {"full_name": "Basis.det", "code": "nonrec def Basis.det : AlternatingMap R M R \u03b9 where\n  toFun v := det (e.toMatrix v)\n  map_add' := by\n    intro inst v i x y\n    cases Subsingleton.elim inst \u2039_\u203a\n    simp only [e.toMatrix_update, LinearEquiv.map_add, Finsupp.coe_add]\n    convert det_updateColumn_add (e.toMatrix v) i (e.repr x) (e.repr y)\n  map_smul' := by\n    intro inst u i c x\n    cases Subsingleton.elim inst \u2039_\u203a\n    simp only [e.toMatrix_update, Algebra.id.smul_eq_mul, LinearEquiv.map_smul]\n    convert det_updateColumn_smul (e.toMatrix u) i c (e.repr x)\n  map_eq_zero_of_eq' := by\n    intro v i j h hij\n    simp only\n    rw [\u2190 Function.update_eq_self i v, h, \u2190 det_transpose, e.toMatrix_update, \u2190 updateRow_transpose,\n      \u2190 e.toMatrix_transpose_apply]\n    apply det_zero_of_row_eq hij\n    rw [updateRow_ne hij.symm, updateRow_self]", "start": [505, 1], "end": [528, 47], "kind": "commanddeclaration"}, {"full_name": "Basis.det_apply", "code": "theorem Basis.det_apply (v : \u03b9 \u2192 M) : e.det v = Matrix.det (e.toMatrix v)", "start": [531, 1], "end": [532, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.det_self", "code": "theorem Basis.det_self : e.det e = 1", "start": [535, 1], "end": [535, 62], "kind": "commanddeclaration"}, {"full_name": "Basis.det_isEmpty", "code": "@[simp]\ntheorem Basis.det_isEmpty [IsEmpty \u03b9] : e.det = AlternatingMap.constOfIsEmpty R M \u03b9 1", "start": [538, 1], "end": [541, 27], "kind": "commanddeclaration"}, {"full_name": "Basis.det_ne_zero", "code": "theorem Basis.det_ne_zero [Nontrivial R] : e.det \u2260 0", "start": [544, 1], "end": [545, 95], "kind": "commanddeclaration"}, {"full_name": "is_basis_iff_det", "code": "theorem is_basis_iff_det {v : \u03b9 \u2192 M} :\n    LinearIndependent R v \u2227 span R (Set.range v) = \u22a4 \u2194 IsUnit (e.det v)", "start": [548, 1], "end": [564, 45], "kind": "commanddeclaration"}, {"full_name": "Basis.isUnit_det", "code": "theorem Basis.isUnit_det (e' : Basis \u03b9 R M) : IsUnit (e.det e')", "start": [567, 1], "end": [568, 61], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.eq_smul_basis_det", "code": "theorem AlternatingMap.eq_smul_basis_det (f : AlternatingMap R M R \u03b9) : f = f e \u2022 e.det", "start": [571, 1], "end": [577, 49], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_basis_eq_zero_iff", "code": "@[simp]\ntheorem AlternatingMap.map_basis_eq_zero_iff {\u03b9 : Type*} [Finite \u03b9] (e : Basis \u03b9 R M)\n    (f : AlternatingMap R M R \u03b9) : f e = 0 \u2194 f = 0", "start": [580, 1], "end": [587, 50], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_basis_ne_zero_iff", "code": "theorem AlternatingMap.map_basis_ne_zero_iff {\u03b9 : Type*} [Finite \u03b9] (e : Basis \u03b9 R M)\n    (f : AlternatingMap R M R \u03b9) : f e \u2260 0 \u2194 f \u2260 0", "start": [590, 1], "end": [592, 41], "kind": "commanddeclaration"}, {"full_name": "Basis.det_comp", "code": "@[simp]\ntheorem Basis.det_comp (e : Basis \u03b9 A M) (f : M \u2192\u2097[A] M) (v : \u03b9 \u2192 M) :\n    e.det (f \u2218 v) = (LinearMap.det f) * e.det v", "start": [597, 1], "end": [602, 19], "kind": "commanddeclaration"}, {"full_name": "Basis.det_comp_basis", "code": "@[simp]\ntheorem Basis.det_comp_basis [Module A M'] (b : Basis \u03b9 A M) (b' : Basis \u03b9 A M') (f : M \u2192\u2097[A] M') :\n    b'.det (f \u2218 b) = LinearMap.det (f \u2218\u2097 (b'.equiv b (Equiv.refl \u03b9) : M' \u2192\u2097[A] M))", "start": [605, 1], "end": [611, 75], "kind": "commanddeclaration"}, {"full_name": "Basis.det_reindex", "code": "theorem Basis.det_reindex {\u03b9' : Type*} [Fintype \u03b9'] [DecidableEq \u03b9'] (b : Basis \u03b9 R M) (v : \u03b9' \u2192 M)\n    (e : \u03b9 \u2243 \u03b9') : (b.reindex e).det v = b.det (v \u2218 e)", "start": [614, 1], "end": [616, 86], "kind": "commanddeclaration"}, {"full_name": "Basis.det_reindex'", "code": "theorem Basis.det_reindex' {\u03b9' : Type*} [Fintype \u03b9'] [DecidableEq \u03b9'] (b : Basis \u03b9 R M)\n    (e : \u03b9 \u2243 \u03b9') : (b.reindex e).det = b.det.domDomCongr e", "start": [619, 1], "end": [621, 54], "kind": "commanddeclaration"}, {"full_name": "Basis.det_reindex_symm", "code": "theorem Basis.det_reindex_symm {\u03b9' : Type*} [Fintype \u03b9'] [DecidableEq \u03b9'] (b : Basis \u03b9 R M)\n    (v : \u03b9 \u2192 M) (e : \u03b9' \u2243 \u03b9) : (b.reindex e.symm).det (v \u2218 e) = b.det v", "start": [624, 1], "end": [626, 88], "kind": "commanddeclaration"}, {"full_name": "Basis.det_map", "code": "@[simp]\ntheorem Basis.det_map (b : Basis \u03b9 R M) (f : M \u2243\u2097[R] M') (v : \u03b9 \u2192 M') :\n    (b.map f).det v = b.det (f.symm \u2218 v)", "start": [629, 1], "end": [632, 60], "kind": "commanddeclaration"}, {"full_name": "Basis.det_map'", "code": "theorem Basis.det_map' (b : Basis \u03b9 R M) (f : M \u2243\u2097[R] M') :\n    (b.map f).det = b.det.compLinearMap f.symm", "start": [635, 1], "end": [637, 36], "kind": "commanddeclaration"}, {"full_name": "Pi.basisFun_det", "code": "@[simp]\ntheorem Pi.basisFun_det : (Pi.basisFun R \u03b9).det = Matrix.detRowAlternating", "start": [640, 1], "end": [643, 81], "kind": "commanddeclaration"}, {"full_name": "Basis.det_smul_mk_coord_eq_det_update", "code": "theorem Basis.det_smul_mk_coord_eq_det_update {v : \u03b9 \u2192 M} (hli : LinearIndependent R v)\n    (hsp : \u22a4 \u2264 span R (range v)) (i : \u03b9) :\n    e.det v \u2022 (Basis.mk hli hsp).coord i = e.det.toMultilinearMap.toLinearMap v i", "start": [646, 1], "end": [659, 79], "kind": "commanddeclaration"}, {"full_name": "Basis.det_unitsSMul", "code": "theorem Basis.det_unitsSMul (e : Basis \u03b9 R M) (w : \u03b9 \u2192 R\u02e3) :\n    (e.unitsSMul w).det = (\u2191(\u220f i, w i)\u207b\u00b9 : R) \u2022 e.det", "start": [662, 1], "end": [673, 12], "kind": "commanddeclaration"}, {"full_name": "Basis.det_unitsSMul_self", "code": "@[simp]\ntheorem Basis.det_unitsSMul_self (w : \u03b9 \u2192 R\u02e3) : e.det (e.unitsSMul w) = \u220f i, (w i : R)", "start": [676, 1], "end": [679, 25], "kind": "commanddeclaration"}, {"full_name": "Basis.det_isUnitSMul", "code": "@[simp]\ntheorem Basis.det_isUnitSMul {w : \u03b9 \u2192 R} (hw : \u2200 i, IsUnit (w i)) :\n    e.det (e.isUnitSMul hw) = \u220f i, w i", "start": [682, 1], "end": [686, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Basic.lean", "Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "Mathlib/Topology/Semicontinuous.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Instances/EReal.lean", "Mathlib/MeasureTheory/Group/Arithmetic.lean", "Mathlib/Analysis/Normed/Group/Basic.lean", "Mathlib/Topology/GDelta.lean", "Mathlib/MeasureTheory/Function/AEMeasurableSequence.lean", "Mathlib/Topology/Algebra/Order/LiminfLimsup.lean", "Mathlib/MeasureTheory/Lattice.lean", "Mathlib/Topology/Order/Lattice.lean"], "premises": [{"full_name": "borel", "code": "def borel (\u03b1 : Type u) [TopologicalSpace \u03b1] : MeasurableSpace \u03b1 :=\n  generateFrom { s : Set \u03b1 | IsOpen s }", "start": [58, 1], "end": [60, 40], "kind": "commanddeclaration"}, {"full_name": "borel_anti", "code": "theorem borel_anti : Antitone (@borel \u03b1)", "start": [63, 1], "end": [64, 64], "kind": "commanddeclaration"}, {"full_name": "borel_eq_top_of_discrete", "code": "theorem borel_eq_top_of_discrete [TopologicalSpace \u03b1] [DiscreteTopology \u03b1] : borel \u03b1 = \u22a4", "start": [67, 1], "end": [68, 73], "kind": "commanddeclaration"}, {"full_name": "borel_eq_top_of_countable", "code": "theorem borel_eq_top_of_countable [TopologicalSpace \u03b1] [T1Space \u03b1] [Countable \u03b1] : borel \u03b1 = \u22a4", "start": [71, 1], "end": [77, 40], "kind": "commanddeclaration"}, {"full_name": "borel_eq_generateFrom_of_subbasis", "code": "theorem borel_eq_generateFrom_of_subbasis {s : Set (Set \u03b1)} [t : TopologicalSpace \u03b1]\n    [SecondCountableTopology \u03b1] (hs : t = .generateFrom s) : borel \u03b1 = .generateFrom s", "start": [80, 1], "end": [95, 95], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom", "code": "theorem TopologicalSpace.IsTopologicalBasis.borel_eq_generateFrom [TopologicalSpace \u03b1]\n    [SecondCountableTopology \u03b1] {s : Set (Set \u03b1)} (hs : IsTopologicalBasis s) :\n    borel \u03b1 = .generateFrom s", "start": [98, 1], "end": [101, 55], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_isOpen", "code": "theorem isPiSystem_isOpen [TopologicalSpace \u03b1] : IsPiSystem (IsOpen : Set \u03b1 \u2192 Prop)", "start": [104, 1], "end": [105, 42], "kind": "commanddeclaration"}, {"full_name": "borel_eq_generateFrom_isClosed", "code": "theorem borel_eq_generateFrom_isClosed [TopologicalSpace \u03b1] :\n    borel \u03b1 = .generateFrom { s | IsClosed s }", "start": [108, 1], "end": [115, 99], "kind": "commanddeclaration"}, {"full_name": "borel_eq_generateFrom_Iio", "code": "theorem borel_eq_generateFrom_Iio : borel \u03b1 = .generateFrom (range Iio)", "start": [124, 1], "end": [154, 48], "kind": "commanddeclaration"}, {"full_name": "borel_eq_generateFrom_Ioi", "code": "theorem borel_eq_generateFrom_Ioi : borel \u03b1 = .generateFrom (range Ioi)", "start": [157, 1], "end": [158, 87], "kind": "commanddeclaration"}, {"full_name": "borel_eq_generateFrom_Iic", "code": "theorem borel_eq_generateFrom_Iic :\n    borel \u03b1 = MeasurableSpace.generateFrom (range Iic)", "start": [161, 1], "end": [172, 86], "kind": "commanddeclaration"}, {"full_name": "borel_eq_generateFrom_Ici", "code": "theorem borel_eq_generateFrom_Ici : borel \u03b1 = MeasurableSpace.generateFrom (range Ici)", "start": [175, 1], "end": [176, 41], "kind": "commanddeclaration"}, {"full_name": "borel_comap", "code": "theorem borel_comap {f : \u03b1 \u2192 \u03b2} {t : TopologicalSpace \u03b2} :\n    @borel \u03b1 (t.induced f) = (@borel \u03b2 t).comap f", "start": [181, 1], "end": [183, 26], "kind": "commanddeclaration"}, {"full_name": "Continuous.borel_measurable", "code": "theorem Continuous.borel_measurable [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Continuous f) : @Measurable \u03b1 \u03b2 (borel \u03b1) (borel \u03b2) f", "start": [186, 1], "end": [189, 84], "kind": "commanddeclaration"}, {"full_name": "OpensMeasurableSpace", "code": "class OpensMeasurableSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] [h : MeasurableSpace \u03b1] : Prop where\n  \n  borel_le : borel \u03b1 \u2264 h", "start": [192, 1], "end": [196, 25], "kind": "commanddeclaration"}, {"full_name": "BorelSpace", "code": "class BorelSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] : Prop where\n  \n  measurable_eq : \u2039MeasurableSpace \u03b1\u203a = borel \u03b1", "start": [200, 1], "end": [204, 48], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Borelize.addBorelInstance", "code": "def addBorelInstance (e : Expr) : TacticM Unit := do\n  let t \u2190 Lean.Elab.Term.exprToSyntax e\n  evalTactic <| \u2190 `(tactic|\n    refine_lift\n      letI : MeasurableSpace $t := borel $t\n      haveI : BorelSpace $t := \u27e8rfl\u27e9\n      ?_)", "start": [222, 1], "end": [229, 10], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Borelize.borelToRefl", "code": "def borelToRefl (e : Expr) (i : FVarId) : TacticM Unit := do\n  let t \u2190 Lean.Elab.Term.exprToSyntax e\n  evalTactic <| \u2190 `(tactic|\n    have := @BorelSpace.measurable_eq $t _ _ _)\n  liftMetaTactic fun m => return [\u2190 subst m i]\n  evalTactic <| \u2190 `(tactic|\n    refine_lift\n      letI : MeasurableSpace $t := borel $t\n      ?_)", "start": [231, 1], "end": [241, 10], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Borelize.borelize", "code": "def borelize (t : Term) : TacticM Unit := withMainContext <| do\n  let u \u2190 mkFreshLevelMVar\n  let e \u2190 withoutRecover <| Tactic.elabTermEnsuringType t (mkSort (mkLevelSucc u))\n  let i? \u2190 findLocalDeclWithType? (\u2190 mkAppOptM ``MeasurableSpace #[e])\n  i?.elim (addBorelInstance e) (borelToRefl e)", "start": [243, 1], "end": [250, 47], "kind": "commanddeclaration"}, {"full_name": "OrderDual.opensMeasurableSpace", "code": "instance (priority := 100) OrderDual.opensMeasurableSpace {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [h : OpensMeasurableSpace \u03b1] : OpensMeasurableSpace \u03b1\u1d52\u1d48 where\n  borel_le := h.borel_le", "start": [257, 1], "end": [259, 25], "kind": "commanddeclaration"}, {"full_name": "OrderDual.borelSpace", "code": "instance (priority := 100) OrderDual.borelSpace {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [h : BorelSpace \u03b1] : BorelSpace \u03b1\u1d52\u1d48 where\n  measurable_eq := h.measurable_eq", "start": [262, 1], "end": [264, 35], "kind": "commanddeclaration"}, {"full_name": "BorelSpace.opensMeasurable", "code": "instance (priority := 100) BorelSpace.opensMeasurable {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [BorelSpace \u03b1] : OpensMeasurableSpace \u03b1 :=\n  \u27e8ge_of_eq <| BorelSpace.measurable_eq\u27e9", "start": [267, 1], "end": [270, 41], "kind": "commanddeclaration"}, {"full_name": "Subtype.borelSpace", "code": "instance Subtype.borelSpace {\u03b1 : Type*} [TopologicalSpace \u03b1] [MeasurableSpace \u03b1]\n    [h\u03b1 : BorelSpace \u03b1] (s : Set \u03b1) : BorelSpace s :=\n  \u27e8by borelize \u03b1; symm; apply borel_comap\u27e9", "start": [273, 1], "end": [275, 43], "kind": "commanddeclaration"}, {"full_name": "Subtype.opensMeasurableSpace", "code": "instance Subtype.opensMeasurableSpace {\u03b1 : Type*} [TopologicalSpace \u03b1] [MeasurableSpace \u03b1]\n    [h : OpensMeasurableSpace \u03b1] (s : Set \u03b1) : OpensMeasurableSpace s :=\n  \u27e8by\n    rw [borel_comap]\n    exact comap_mono h.1\u27e9", "start": [278, 1], "end": [282, 26], "kind": "commanddeclaration"}, {"full_name": "opensMeasurableSpace_iff_forall_measurableSet", "code": "lemma opensMeasurableSpace_iff_forall_measurableSet\n    [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] :\n    OpensMeasurableSpace \u03b1 \u2194  (\u2200 (s : Set \u03b1), IsOpen s \u2192 MeasurableSet s) := by\n  refine \u27e8fun h s hs \u21a6 ?_, fun h \u21a6 \u27e8generateFrom_le h\u27e9\u27e9\n  exact OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ hs", "start": [285, 1], "end": [289, 73], "kind": "mathlibtacticlemma"}, {"full_name": "BorelSpace.countablyGenerated", "code": "instance (priority := 100) BorelSpace.countablyGenerated {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [MeasurableSpace \u03b1] [BorelSpace \u03b1] [SecondCountableTopology \u03b1] : CountablyGenerated \u03b1 := by\n  obtain \u27e8b, bct, -, hb\u27e9 := exists_countable_basis \u03b1\n  refine' \u27e8\u27e8b, bct, _\u27e9\u27e9\n  borelize \u03b1\n  exact hb.borel_eq_generateFrom", "start": [291, 1], "end": [296, 33], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.induction_on_open", "code": "theorem MeasurableSet.induction_on_open [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] [BorelSpace \u03b1]\n    {C : Set \u03b1 \u2192 Prop} (h_open : \u2200 U, IsOpen U \u2192 C U)\n    (h_compl : \u2200 t, MeasurableSet t \u2192 C t \u2192 C t\u1d9c)\n    (h_union :\n      \u2200 f : \u2115 \u2192 Set \u03b1,\n        Pairwise (Disjoint on f) \u2192 (\u2200 i, MeasurableSet (f i)) \u2192 (\u2200 i, C (f i)) \u2192 C (\u22c3 i, f i)) :\n    \u2200 \u2983t\u2984, MeasurableSet t \u2192 C t", "start": [299, 1], "end": [307, 51], "kind": "commanddeclaration"}, {"full_name": "IsOpen.measurableSet", "code": "theorem IsOpen.measurableSet (h : IsOpen s) : MeasurableSet s", "start": [316, 1], "end": [317, 66], "kind": "commanddeclaration"}, {"full_name": "measurableSet_interior", "code": "@[measurability]\ntheorem measurableSet_interior : MeasurableSet (interior s)", "start": [324, 1], "end": [326, 32], "kind": "commanddeclaration"}, {"full_name": "IsG\u03b4.measurableSet", "code": "theorem IsG\u03b4.measurableSet (h : IsG\u03b4 s) : MeasurableSet s", "start": [329, 1], "end": [331, 70], "kind": "commanddeclaration"}, {"full_name": "measurableSet_of_continuousAt", "code": "theorem measurableSet_of_continuousAt {\u03b2} [EMetricSpace \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    MeasurableSet { x | ContinuousAt f x }", "start": [335, 1], "end": [337, 44], "kind": "commanddeclaration"}, {"full_name": "IsClosed.measurableSet", "code": "theorem IsClosed.measurableSet (h : IsClosed s) : MeasurableSet s", "start": [340, 1], "end": [341, 40], "kind": "commanddeclaration"}, {"full_name": "IsCompact.measurableSet", "code": "theorem IsCompact.measurableSet [T2Space \u03b1] (h : IsCompact s) : MeasurableSet s", "start": [344, 1], "end": [345, 27], "kind": "commanddeclaration"}, {"full_name": "measurableSet_closure", "code": "@[measurability]\ntheorem measurableSet_closure : MeasurableSet (closure s)", "start": [348, 1], "end": [350, 33], "kind": "commanddeclaration"}, {"full_name": "measurable_of_isOpen", "code": "theorem measurable_of_isOpen {f : \u03b4 \u2192 \u03b3} (hf : \u2200 s, IsOpen s \u2192 MeasurableSet (f \u207b\u00b9' s)) :\n    Measurable f", "start": [353, 1], "end": [356, 35], "kind": "commanddeclaration"}, {"full_name": "measurable_of_isClosed", "code": "theorem measurable_of_isClosed {f : \u03b4 \u2192 \u03b3} (hf : \u2200 s, IsClosed s \u2192 MeasurableSet (f \u207b\u00b9' s)) :\n    Measurable f", "start": [359, 1], "end": [362, 96], "kind": "commanddeclaration"}, {"full_name": "measurable_of_is_closed'", "code": "theorem measurable_of_is_closed' {f : \u03b4 \u2192 \u03b3}\n    (hf : \u2200 s, IsClosed s \u2192 s.Nonempty \u2192 s \u2260 univ \u2192 MeasurableSet (f \u207b\u00b9' s)) : Measurable f", "start": [365, 1], "end": [370, 22], "kind": "commanddeclaration"}, {"full_name": "nhds_isMeasurablyGenerated", "code": "instance nhds_isMeasurablyGenerated (a : \u03b1) : (\ud835\udcdd a).IsMeasurablyGenerated := by\n  rw [nhds, iInf_subtype']\n  refine' @Filter.iInf_isMeasurablyGenerated \u03b1 _ _ _ fun i => _\n  exact i.2.2.measurableSet.principal_isMeasurablyGenerated", "start": [373, 1], "end": [376, 60], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.nhdsWithin_isMeasurablyGenerated", "code": "theorem MeasurableSet.nhdsWithin_isMeasurablyGenerated {s : Set \u03b1} (hs : MeasurableSet s) (a : \u03b1) :\n    (\ud835\udcdd[s] a).IsMeasurablyGenerated", "start": [379, 1], "end": [385, 39], "kind": "commanddeclaration"}, {"full_name": "OpensMeasurableSpace.toMeasurableSingletonClass", "code": "instance (priority := 100) OpensMeasurableSpace.toMeasurableSingletonClass [T1Space \u03b1] :\n    MeasurableSingletonClass \u03b1 :=\n  \u27e8fun _ => isClosed_singleton.measurableSet\u27e9", "start": [389, 1], "end": [391, 46], "kind": "commanddeclaration"}, {"full_name": "Pi.opensMeasurableSpace", "code": "instance Pi.opensMeasurableSpace {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [Countable \u03b9]\n    [t' : \u2200 i, TopologicalSpace (\u03c0 i)] [\u2200 i, MeasurableSpace (\u03c0 i)]\n    [\u2200 i, SecondCountableTopology (\u03c0 i)] [\u2200 i, OpensMeasurableSpace (\u03c0 i)] :\n    OpensMeasurableSpace (\u2200 i, \u03c0 i) := by\n  constructor\n  have : Pi.topologicalSpace = .generateFrom { t | \u2203 (s : \u2200 a, Set (\u03c0 a)) (i : Finset \u03b9),\n      (\u2200 a \u2208 i, s a \u2208 countableBasis (\u03c0 a)) \u2227 t = pi (\u2191i) s } := by\n    rw [funext fun a => @eq_generateFrom_countableBasis (\u03c0 a) _ _, pi_generateFrom_eq]\n  rw [borel_eq_generateFrom_of_subbasis this]\n  apply generateFrom_le\n  rintro _ \u27e8s, i, hi, rfl\u27e9\n  refine' MeasurableSet.pi i.countable_toSet fun a ha => IsOpen.measurableSet _\n  rw [eq_generateFrom_countableBasis (\u03c0 a)]\n  exact .basic _ (hi a ha)", "start": [394, 1], "end": [407, 27], "kind": "commanddeclaration"}, {"full_name": "SecondCountableTopologyEither", "code": "class SecondCountableTopologyEither (\u03b1 \u03b2 : Type*) [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] :\n  Prop where\n  \n  out : SecondCountableTopology \u03b1 \u2228 SecondCountableTopology \u03b2", "start": [410, 1], "end": [416, 62], "kind": "commanddeclaration"}, {"full_name": "secondCountableTopologyEither_of_left", "code": "instance (priority := 100) secondCountableTopologyEither_of_left (\u03b1 \u03b2 : Type*) [TopologicalSpace \u03b1]\n    [TopologicalSpace \u03b2] [SecondCountableTopology \u03b1] : SecondCountableTopologyEither \u03b1 \u03b2 where\n  out := Or.inl (by infer_instance)", "start": [419, 1], "end": [421, 36], "kind": "commanddeclaration"}, {"full_name": "secondCountableTopologyEither_of_right", "code": "instance (priority := 100) secondCountableTopologyEither_of_right (\u03b1 \u03b2 : Type*)\n    [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [SecondCountableTopology \u03b2] :\n    SecondCountableTopologyEither \u03b1 \u03b2 where out := Or.inr (by infer_instance)", "start": [424, 1], "end": [426, 78], "kind": "commanddeclaration"}, {"full_name": "Prod.opensMeasurableSpace", "code": "instance Prod.opensMeasurableSpace [h : SecondCountableTopologyEither \u03b1 \u03b2] :\n    OpensMeasurableSpace (\u03b1 \u00d7 \u03b2) := by\n  apply opensMeasurableSpace_iff_forall_measurableSet.2 (fun s hs \u21a6 ?_)\n  rcases h.out with h\u03b1|h\u03b2\n  \u00b7 let F : Set \u03b1 \u2192 Set \u03b2 := fun a \u21a6 {y | \u2203 b, IsOpen b \u2227 y \u2208 b \u2227 a \u00d7\u02e2 b \u2286 s}\n    have A : \u2200 a, IsOpen (F a) := by\n      intro a\n      apply isOpen_iff_forall_mem_open.2\n      rintro y \u27e8b, b_open, yb, hb\u27e9\n      exact \u27e8b, fun z zb \u21a6 \u27e8b, b_open, zb, hb\u27e9, b_open, yb\u27e9\n    have : s = \u22c3 a \u2208 countableBasis \u03b1, a \u00d7\u02e2 F a := by\n      apply Subset.antisymm\n      \u00b7 rintro \u27e8y1, y2\u27e9 hy\n        rcases isOpen_prod_iff.1 hs y1 y2 hy with \u27e8u, v, u_open, v_open, yu, yv, huv\u27e9\n        obtain \u27e8a, ha, ya, au\u27e9 : \u2203 a \u2208 countableBasis \u03b1, y1 \u2208 a \u2227 a \u2286 u :=\n          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis \u03b1) yu u_open\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]\n        exact \u27e8a, ya, ha, v, v_open, yv, (Set.prod_mono_left au).trans huv\u27e9\n      \u00b7 rintro \u27e8y1, y2\u27e9 hy\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy\n        rcases hy with \u27e8a, ya, -, b, -, yb, hb\u27e9\n        exact hb (mem_prod.2 \u27e8ya, yb\u27e9)\n    rw [this]\n    apply MeasurableSet.biUnion (countable_countableBasis \u03b1) (fun a ha \u21a6 ?_)\n    exact (isOpen_of_mem_countableBasis ha).measurableSet.prod (A a).measurableSet\n  \u00b7 let F : Set \u03b2 \u2192 Set \u03b1 := fun a \u21a6 {y | \u2203 b, IsOpen b \u2227 y \u2208 b \u2227 b \u00d7\u02e2 a \u2286 s}\n    have A : \u2200 a, IsOpen (F a) := by\n      intro a\n      apply isOpen_iff_forall_mem_open.2\n      rintro y \u27e8b, b_open, yb, hb\u27e9\n      exact \u27e8b, fun z zb \u21a6 \u27e8b, b_open, zb, hb\u27e9, b_open, yb\u27e9\n    have : s = \u22c3 a \u2208 countableBasis \u03b2, F a \u00d7\u02e2 a := by\n      apply Subset.antisymm\n      \u00b7 rintro \u27e8y1, y2\u27e9 hy\n        rcases isOpen_prod_iff.1 hs y1 y2 hy with \u27e8u, v, u_open, v_open, yu, yv, huv\u27e9\n        obtain \u27e8a, ha, ya, au\u27e9 : \u2203 a \u2208 countableBasis \u03b2, y2 \u2208 a \u2227 a \u2286 v :=\n          IsTopologicalBasis.exists_subset_of_mem_open (isBasis_countableBasis \u03b2) yv v_open\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop]\n        exact \u27e8a, \u27e8u, u_open, yu, (Set.prod_mono_right au).trans huv\u27e9, ha, ya\u27e9\n      \u00b7 rintro \u27e8y1, y2\u27e9 hy\n        simp only [mem_iUnion, mem_prod, mem_setOf_eq, exists_and_left, exists_prop] at hy\n        rcases hy with \u27e8a, \u27e8b, -, yb, hb\u27e9, -, ya\u27e9\n        exact hb (mem_prod.2 \u27e8yb, ya\u27e9)\n    rw [this]\n    apply MeasurableSet.biUnion (countable_countableBasis \u03b2) (fun a ha \u21a6 ?_)\n    exact (A a).measurableSet.prod (isOpen_of_mem_countableBasis ha).measurableSet", "start": [429, 1], "end": [476, 83], "kind": "commanddeclaration"}, {"full_name": "interior_ae_eq_of_null_frontier", "code": "theorem interior_ae_eq_of_null_frontier {\u03bc : Measure \u03b1'} {s : Set \u03b1'} (h : \u03bc (frontier s) = 0) :\n    interior s =\u1d50[\u03bc] s", "start": [480, 1], "end": [482, 93], "kind": "commanddeclaration"}, {"full_name": "measure_interior_of_null_frontier", "code": "theorem measure_interior_of_null_frontier {\u03bc : Measure \u03b1'} {s : Set \u03b1'} (h : \u03bc (frontier s) = 0) :\n    \u03bc (interior s) = \u03bc s", "start": [485, 1], "end": [487, 52], "kind": "commanddeclaration"}, {"full_name": "nullMeasurableSet_of_null_frontier", "code": "theorem nullMeasurableSet_of_null_frontier {s : Set \u03b1} {\u03bc : Measure \u03b1} (h : \u03bc (frontier s) = 0) :\n    NullMeasurableSet s \u03bc", "start": [490, 1], "end": [492, 88], "kind": "commanddeclaration"}, {"full_name": "closure_ae_eq_of_null_frontier", "code": "theorem closure_ae_eq_of_null_frontier {\u03bc : Measure \u03b1'} {s : Set \u03b1'} (h : \u03bc (frontier s) = 0) :\n    closure s =\u1d50[\u03bc] s", "start": [495, 1], "end": [497, 95], "kind": "commanddeclaration"}, {"full_name": "measure_closure_of_null_frontier", "code": "theorem measure_closure_of_null_frontier {\u03bc : Measure \u03b1'} {s : Set \u03b1'} (h : \u03bc (frontier s) = 0) :\n    \u03bc (closure s) = \u03bc s", "start": [500, 1], "end": [502, 51], "kind": "commanddeclaration"}, {"full_name": "measurableSet_Ici", "code": "@[simp, measurability]\ntheorem measurableSet_Ici : MeasurableSet (Ici a)", "start": [509, 1], "end": [511, 29], "kind": "commanddeclaration"}, {"full_name": "measurableSet_Iic", "code": "@[simp, measurability]\ntheorem measurableSet_Iic : MeasurableSet (Iic a)", "start": [514, 1], "end": [516, 29], "kind": "commanddeclaration"}, {"full_name": "measurableSet_Icc", "code": "@[simp, measurability]\ntheorem measurableSet_Icc : MeasurableSet (Icc a b)", "start": [519, 1], "end": [521, 29], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ici_isMeasurablyGenerated", "code": "instance nhdsWithin_Ici_isMeasurablyGenerated : (\ud835\udcdd[Ici b] a).IsMeasurablyGenerated :=\n  measurableSet_Ici.nhdsWithin_isMeasurablyGenerated _", "start": [524, 1], "end": [525, 55], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Iic_isMeasurablyGenerated", "code": "instance nhdsWithin_Iic_isMeasurablyGenerated : (\ud835\udcdd[Iic b] a).IsMeasurablyGenerated :=\n  measurableSet_Iic.nhdsWithin_isMeasurablyGenerated _", "start": [528, 1], "end": [529, 55], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Icc_isMeasurablyGenerated", "code": "instance nhdsWithin_Icc_isMeasurablyGenerated : IsMeasurablyGenerated (\ud835\udcdd[Icc a b] x) := by\n  rw [\u2190 Ici_inter_Iic, nhdsWithin_inter]\n  infer_instance", "start": [532, 1], "end": [534, 17], "kind": "commanddeclaration"}, {"full_name": "atTop_isMeasurablyGenerated", "code": "instance atTop_isMeasurablyGenerated : (Filter.atTop : Filter \u03b1).IsMeasurablyGenerated :=\n  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>\n    (measurableSet_Ici : MeasurableSet (Ici a)).principal_isMeasurablyGenerated", "start": [537, 1], "end": [539, 80], "kind": "commanddeclaration"}, {"full_name": "atBot_isMeasurablyGenerated", "code": "instance atBot_isMeasurablyGenerated : (Filter.atBot : Filter \u03b1).IsMeasurablyGenerated :=\n  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>\n    (measurableSet_Iic : MeasurableSet (Iic a)).principal_isMeasurablyGenerated", "start": [542, 1], "end": [544, 80], "kind": "commanddeclaration"}, {"full_name": "measurableSet_le'", "code": "@[measurability]\ntheorem measurableSet_le' : MeasurableSet { p : \u03b1 \u00d7 \u03b1 | p.1 \u2264 p.2 }", "start": [553, 1], "end": [555, 49], "kind": "commanddeclaration"}, {"full_name": "measurableSet_le", "code": "@[measurability]\ntheorem measurableSet_le {f g : \u03b4 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    MeasurableSet { a | f a \u2264 g a }", "start": [558, 1], "end": [561, 34], "kind": "commanddeclaration"}, {"full_name": "measurableSet_Iio", "code": "@[simp, measurability]\ntheorem measurableSet_Iio : MeasurableSet (Iio a)", "start": [573, 1], "end": [575, 27], "kind": "commanddeclaration"}, {"full_name": "measurableSet_Ioi", "code": "@[simp, measurability]\ntheorem measurableSet_Ioi : MeasurableSet (Ioi a)", "start": [578, 1], "end": [580, 27], "kind": "commanddeclaration"}, {"full_name": "measurableSet_Ioo", "code": "@[simp, measurability]\ntheorem measurableSet_Ioo : MeasurableSet (Ioo a b)", "start": [583, 1], "end": [585, 27], "kind": "commanddeclaration"}, {"full_name": "measurableSet_Ioc", "code": "@[simp, measurability]\ntheorem measurableSet_Ioc : MeasurableSet (Ioc a b)", "start": [588, 1], "end": [590, 44], "kind": "commanddeclaration"}, {"full_name": "measurableSet_Ico", "code": "@[simp, measurability]\ntheorem measurableSet_Ico : MeasurableSet (Ico a b)", "start": [593, 1], "end": [595, 44], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ioi_isMeasurablyGenerated", "code": "instance nhdsWithin_Ioi_isMeasurablyGenerated : (\ud835\udcdd[Ioi b] a).IsMeasurablyGenerated :=\n  measurableSet_Ioi.nhdsWithin_isMeasurablyGenerated _", "start": [598, 1], "end": [599, 55], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Iio_isMeasurablyGenerated", "code": "instance nhdsWithin_Iio_isMeasurablyGenerated : (\ud835\udcdd[Iio b] a).IsMeasurablyGenerated :=\n  measurableSet_Iio.nhdsWithin_isMeasurablyGenerated _", "start": [602, 1], "end": [603, 55], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_uIcc_isMeasurablyGenerated", "code": "instance nhdsWithin_uIcc_isMeasurablyGenerated : IsMeasurablyGenerated (\ud835\udcdd[[[a, b]]] x) :=\n  nhdsWithin_Icc_isMeasurablyGenerated", "start": [606, 1], "end": [607, 39], "kind": "commanddeclaration"}, {"full_name": "measurableSet_lt'", "code": "@[measurability]\ntheorem measurableSet_lt' [SecondCountableTopology \u03b1] : MeasurableSet { p : \u03b1 \u00d7 \u03b1 | p.1 < p.2 }", "start": [610, 1], "end": [612, 58], "kind": "commanddeclaration"}, {"full_name": "measurableSet_lt", "code": "@[measurability]\ntheorem measurableSet_lt [SecondCountableTopology \u03b1] {f g : \u03b4 \u2192 \u03b1} (hf : Measurable f)\n    (hg : Measurable g) : MeasurableSet { a | f a < g a }", "start": [615, 1], "end": [618, 34], "kind": "commanddeclaration"}, {"full_name": "nullMeasurableSet_lt", "code": "theorem nullMeasurableSet_lt [SecondCountableTopology \u03b1] {\u03bc : Measure \u03b4} {f g : \u03b4 \u2192 \u03b1}\n    (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) : NullMeasurableSet { a | f a < g a } \u03bc", "start": [621, 1], "end": [623, 51], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.measurableSet", "code": "theorem Set.OrdConnected.measurableSet (h : OrdConnected s) : MeasurableSet s", "start": [626, 1], "end": [634, 43], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.measurableSet", "code": "theorem IsPreconnected.measurableSet (h : IsPreconnected s) : MeasurableSet s", "start": [637, 1], "end": [638, 31], "kind": "commanddeclaration"}, {"full_name": "generateFrom_Ico_mem_le_borel", "code": "theorem generateFrom_Ico_mem_le_borel {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderClosedTopology \u03b1] (s t : Set \u03b1) :\n    MeasurableSpace.generateFrom { S | \u2203 l \u2208 s, \u2203 u \u2208 t, l < u \u2227 Ico l u = S }\n      \u2264 borel \u03b1", "start": [641, 1], "end": [648, 26], "kind": "commanddeclaration"}, {"full_name": "Dense.borel_eq_generateFrom_Ico_mem_aux", "code": "theorem Dense.borel_eq_generateFrom_Ico_mem_aux {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] [SecondCountableTopology \u03b1] {s : Set \u03b1} (hd : Dense s)\n    (hbot : \u2200 x, IsBot x \u2192 x \u2208 s) (hIoo : \u2200 x y : \u03b1, x < y \u2192 Ioo x y = \u2205 \u2192 y \u2208 s) :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l \u2208 s, \u2203 u \u2208 s, l < u \u2227 Ico l u = S }", "start": [651, 1], "end": [685, 62], "kind": "commanddeclaration"}, {"full_name": "Dense.borel_eq_generateFrom_Ico_mem", "code": "theorem Dense.borel_eq_generateFrom_Ico_mem {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] [SecondCountableTopology \u03b1] [DenselyOrdered \u03b1] [NoMinOrder \u03b1] {s : Set \u03b1}\n    (hd : Dense s) :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l \u2208 s, \u2203 u \u2208 s, l < u \u2227 Ico l u = S }", "start": [688, 1], "end": [693, 43], "kind": "commanddeclaration"}, {"full_name": "borel_eq_generateFrom_Ico", "code": "theorem borel_eq_generateFrom_Ico (\u03b1 : Type*) [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1]\n    [LinearOrder \u03b1] [OrderTopology \u03b1] :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 (l u : \u03b1), l < u \u2227 Ico l u = S }", "start": [696, 1], "end": [701, 17], "kind": "commanddeclaration"}, {"full_name": "Dense.borel_eq_generateFrom_Ioc_mem_aux", "code": "theorem Dense.borel_eq_generateFrom_Ioc_mem_aux {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] [SecondCountableTopology \u03b1] {s : Set \u03b1} (hd : Dense s)\n    (hbot : \u2200 x, IsTop x \u2192 x \u2208 s) (hIoo : \u2200 x y : \u03b1, x < y \u2192 Ioo x y = \u2205 \u2192 x \u2208 s) :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l \u2208 s, \u2203 u \u2208 s, l < u \u2227 Ioc l u = S }", "start": [704, 1], "end": [714, 13], "kind": "commanddeclaration"}, {"full_name": "Dense.borel_eq_generateFrom_Ioc_mem", "code": "theorem Dense.borel_eq_generateFrom_Ioc_mem {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] [SecondCountableTopology \u03b1] [DenselyOrdered \u03b1] [NoMaxOrder \u03b1] {s : Set \u03b1}\n    (hd : Dense s) :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l \u2208 s, \u2203 u \u2208 s, l < u \u2227 Ioc l u = S }", "start": [717, 1], "end": [722, 43], "kind": "commanddeclaration"}, {"full_name": "borel_eq_generateFrom_Ioc", "code": "theorem borel_eq_generateFrom_Ioc (\u03b1 : Type*) [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1]\n    [LinearOrder \u03b1] [OrderTopology \u03b1] :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l u, l < u \u2227 Ioc l u = S }", "start": [725, 1], "end": [730, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_of_Ico_finite", "code": "theorem ext_of_Ico_finite {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] (\u03bc \u03bd : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] (h\u03bc\u03bd : \u03bc univ = \u03bd univ) (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ico a b) = \u03bd (Ico a b)) :\n    \u03bc = \u03bd", "start": [735, 1], "end": [747, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_of_Ioc_finite", "code": "theorem ext_of_Ioc_finite {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] (\u03bc \u03bd : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] (h\u03bc\u03bd : \u03bc univ = \u03bd univ) (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ioc a b) = \u03bd (Ioc a b)) :\n    \u03bc = \u03bd", "start": [750, 1], "end": [760, 14], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_of_Ico'", "code": "theorem ext_of_Ico' {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] [NoMaxOrder \u03b1]\n    (\u03bc \u03bd : Measure \u03b1) (h\u03bc : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ico a b) \u2260 \u221e)\n    (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ico a b) = \u03bd (Ico a b)) : \u03bc = \u03bd", "start": [763, 1], "end": [786, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_of_Ioc'", "code": "theorem ext_of_Ioc' {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] [NoMinOrder \u03b1]\n    (\u03bc \u03bd : Measure \u03b1) (h\u03bc : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ioc a b) \u2260 \u221e)\n    (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ioc a b) = \u03bd (Ioc a b)) : \u03bc = \u03bd", "start": [789, 1], "end": [796, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_of_Ico", "code": "theorem ext_of_Ico {\u03b1 : Type*} [TopologicalSpace \u03b1] {_m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [ConditionallyCompleteLinearOrder \u03b1] [OrderTopology \u03b1]\n    [BorelSpace \u03b1] [NoMaxOrder \u03b1] (\u03bc \u03bd : Measure \u03b1) [IsLocallyFiniteMeasure \u03bc]\n    (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ico a b) = \u03bd (Ico a b)) : \u03bc = \u03bd", "start": [799, 1], "end": [805, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_of_Ioc", "code": "theorem ext_of_Ioc {\u03b1 : Type*} [TopologicalSpace \u03b1] {_m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [ConditionallyCompleteLinearOrder \u03b1] [OrderTopology \u03b1]\n    [BorelSpace \u03b1] [NoMinOrder \u03b1] (\u03bc \u03bd : Measure \u03b1) [IsLocallyFiniteMeasure \u03bc]\n    (h : \u2200 \u2983a b\u2984, a < b \u2192 \u03bc (Ioc a b) = \u03bd (Ioc a b)) : \u03bc = \u03bd", "start": [808, 1], "end": [814, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_of_Iic", "code": "theorem ext_of_Iic {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] (\u03bc \u03bd : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] (h : \u2200 a, \u03bc (Iic a) = \u03bd (Iic a)) : \u03bc = \u03bd", "start": [817, 1], "end": [830, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_of_Ici", "code": "theorem ext_of_Ici {\u03b1 : Type*} [TopologicalSpace \u03b1] {m : MeasurableSpace \u03b1}\n    [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [BorelSpace \u03b1] (\u03bc \u03bd : Measure \u03b1)\n    [IsFiniteMeasure \u03bc] (h : \u2200 a, \u03bc (Ici a) = \u03bd (Ici a)) : \u03bc = \u03bd", "start": [833, 1], "end": [838, 40], "kind": "commanddeclaration"}, {"full_name": "measurableSet_uIcc", "code": "@[measurability]\ntheorem measurableSet_uIcc : MeasurableSet (uIcc a b)", "start": [849, 1], "end": [851, 20], "kind": "commanddeclaration"}, {"full_name": "measurableSet_uIoc", "code": "@[measurability]\ntheorem measurableSet_uIoc : MeasurableSet (uIoc a b)", "start": [854, 1], "end": [856, 20], "kind": "commanddeclaration"}, {"full_name": "Measurable.max", "code": "@[measurability]\ntheorem Measurable.max {f g : \u03b4 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => max (f a) (g a)", "start": [861, 1], "end": [864, 71], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.max", "code": "@[measurability]\nnonrec theorem AEMeasurable.max {f g : \u03b4 \u2192 \u03b1} {\u03bc : Measure \u03b4} (hf : AEMeasurable f \u03bc)\n    (hg : AEMeasurable g \u03bc) : AEMeasurable (fun a => max (f a) (g a)) \u03bc", "start": [867, 1], "end": [871, 50], "kind": "commanddeclaration"}, {"full_name": "Measurable.min", "code": "@[measurability]\ntheorem Measurable.min {f g : \u03b4 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => min (f a) (g a)", "start": [874, 1], "end": [877, 70], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.min", "code": "@[measurability]\nnonrec theorem AEMeasurable.min {f g : \u03b4 \u2192 \u03b1} {\u03bc : Measure \u03b4} (hf : AEMeasurable f \u03bc)\n    (hg : AEMeasurable g \u03bc) : AEMeasurable (fun a => min (f a) (g a)) \u03bc", "start": [880, 1], "end": [884, 50], "kind": "commanddeclaration"}, {"full_name": "Continuous.measurable", "code": "theorem Continuous.measurable {f : \u03b1 \u2192 \u03b3} (hf : Continuous f) : Measurable f", "start": [889, 1], "end": [892, 96], "kind": "commanddeclaration"}, {"full_name": "Continuous.aemeasurable", "code": "theorem Continuous.aemeasurable {f : \u03b1 \u2192 \u03b3} (h : Continuous f) {\u03bc : Measure \u03b1} : AEMeasurable f \u03bc", "start": [895, 1], "end": [898, 28], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.measurable", "code": "theorem ClosedEmbedding.measurable {f : \u03b1 \u2192 \u03b3} (hf : ClosedEmbedding f) : Measurable f", "start": [901, 1], "end": [902, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.measurable_piecewise", "code": "theorem ContinuousOn.measurable_piecewise {f g : \u03b1 \u2192 \u03b3} {s : Set \u03b1} [\u2200 j : \u03b1, Decidable (j \u2208 s)]\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s\u1d9c) (hs : MeasurableSet s) :\n    Measurable (s.piecewise f g)", "start": [905, 1], "end": [918, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousMul.measurableMul", "code": "@[to_additive]\ninstance (priority := 100) ContinuousMul.measurableMul [Mul \u03b3] [ContinuousMul \u03b3] :\n    MeasurableMul \u03b3 where\n  measurable_const_mul _ := (continuous_const.mul continuous_id).measurable\n  measurable_mul_const _ := (continuous_id.mul continuous_const).measurable", "start": [921, 1], "end": [925, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousSub.measurableSub", "code": "instance (priority := 100) ContinuousSub.measurableSub [Sub \u03b3] [ContinuousSub \u03b3] :\n    MeasurableSub \u03b3 where\n  measurable_const_sub _ := (continuous_const.sub continuous_id).measurable\n  measurable_sub_const _ := (continuous_id.sub continuous_const).measurable", "start": [929, 1], "end": [932, 76], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.measurableInv", "code": "@[to_additive]\ninstance (priority := 100) TopologicalGroup.measurableInv [Group \u03b3] [TopologicalGroup \u03b3] :\n    MeasurableInv \u03b3 :=\n  \u27e8continuous_inv.measurable\u27e9", "start": [935, 1], "end": [938, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousSMul.measurableSMul", "code": "instance (priority := 100) ContinuousSMul.measurableSMul {M \u03b1} [TopologicalSpace M]\n    [TopologicalSpace \u03b1] [MeasurableSpace M] [MeasurableSpace \u03b1] [OpensMeasurableSpace M]\n    [BorelSpace \u03b1] [SMul M \u03b1] [ContinuousSMul M \u03b1] : MeasurableSMul M \u03b1 :=\n  \u27e8fun _ => (continuous_const_smul _).measurable, fun _ =>\n    (continuous_id.smul continuous_const).measurable\u27e9", "start": [942, 1], "end": [946, 54], "kind": "commanddeclaration"}, {"full_name": "ContinuousSup.measurableSup", "code": "instance (priority := 100) ContinuousSup.measurableSup [Sup \u03b3] [ContinuousSup \u03b3] :\n    MeasurableSup \u03b3 where\n  measurable_const_sup _ := (continuous_const.sup continuous_id).measurable\n  measurable_sup_const _ := (continuous_id.sup continuous_const).measurable", "start": [951, 1], "end": [954, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousSup.measurableSup\u2082", "code": "instance (priority := 100) ContinuousSup.measurableSup\u2082 [SecondCountableTopology \u03b3] [Sup \u03b3]\n    [ContinuousSup \u03b3] : MeasurableSup\u2082 \u03b3 :=\n  \u27e8continuous_sup.measurable\u27e9", "start": [957, 1], "end": [959, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousInf.measurableInf", "code": "instance (priority := 100) ContinuousInf.measurableInf [Inf \u03b3] [ContinuousInf \u03b3] :\n    MeasurableInf \u03b3 where\n  measurable_const_inf _ := (continuous_const.inf continuous_id).measurable\n  measurable_inf_const _ := (continuous_id.inf continuous_const).measurable", "start": [962, 1], "end": [965, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousInf.measurableInf\u2082", "code": "instance (priority := 100) ContinuousInf.measurableInf\u2082 [SecondCountableTopology \u03b3] [Inf \u03b3]\n    [ContinuousInf \u03b3] : MeasurableInf\u2082 \u03b3 :=\n  \u27e8continuous_inf.measurable\u27e9", "start": [968, 1], "end": [970, 30], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.measurable", "code": "@[measurability]\nprotected theorem Homeomorph.measurable (h : \u03b1 \u2243\u209c \u03b3) : Measurable h", "start": [977, 1], "end": [979, 26], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.toMeasurableEquiv", "code": "def Homeomorph.toMeasurableEquiv (h : \u03b3 \u2243\u209c \u03b3\u2082) : \u03b3 \u2243\u1d50 \u03b3\u2082 where\n  measurable_toFun := h.measurable\n  measurable_invFun := h.symm.measurable\n  toEquiv := h.toEquiv", "start": [982, 1], "end": [986, 23], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.measurableEmbedding", "code": "lemma Homeomorph.measurableEmbedding (h : \u03b3 \u2243\u209c \u03b3\u2082) : MeasurableEmbedding h :=\n  h.toMeasurableEquiv.measurableEmbedding", "start": [989, 1], "end": [990, 42], "kind": "mathlibtacticlemma"}, {"full_name": "Homeomorph.toMeasurableEquiv_coe", "code": "@[simp]\ntheorem Homeomorph.toMeasurableEquiv_coe (h : \u03b3 \u2243\u209c \u03b3\u2082) : (h.toMeasurableEquiv : \u03b3 \u2192 \u03b3\u2082) = h", "start": [992, 1], "end": [994, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.toMeasurableEquiv_symm_coe", "code": "@[simp]\ntheorem Homeomorph.toMeasurableEquiv_symm_coe (h : \u03b3 \u2243\u209c \u03b3\u2082) :\n    (h.toMeasurableEquiv.symm : \u03b3\u2082 \u2192 \u03b3) = h.symm", "start": [997, 1], "end": [1000, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.measurable", "code": "@[measurability]\ntheorem ContinuousMap.measurable (f : C(\u03b1, \u03b3)) : Measurable f", "start": [1005, 1], "end": [1007, 26], "kind": "commanddeclaration"}, {"full_name": "measurable_of_continuousOn_compl_singleton", "code": "theorem measurable_of_continuousOn_compl_singleton [T1Space \u03b1] {f : \u03b1 \u2192 \u03b3} (a : \u03b1)\n    (hf : ContinuousOn f {a}\u1d9c) : Measurable f", "start": [1010, 1], "end": [1013, 59], "kind": "commanddeclaration"}, {"full_name": "Continuous.measurable2", "code": "theorem Continuous.measurable2 [SecondCountableTopologyEither \u03b1 \u03b2] {f : \u03b4 \u2192 \u03b1}\n    {g : \u03b4 \u2192 \u03b2} {c : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (h : Continuous fun p : \u03b1 \u00d7 \u03b2 => c p.1 p.2) (hf : Measurable f)\n    (hg : Measurable g) : Measurable fun a => c (f a) (g a)", "start": [1016, 1], "end": [1019, 36], "kind": "commanddeclaration"}, {"full_name": "Continuous.aemeasurable2", "code": "theorem Continuous.aemeasurable2 [SecondCountableTopologyEither \u03b1 \u03b2]\n    {f : \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b2} {c : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {\u03bc : Measure \u03b4}\n    (h : Continuous fun p : \u03b1 \u00d7 \u03b2 => c p.1 p.2) (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    AEMeasurable (fun a => c (f a) (g a)) \u03bc", "start": [1022, 1], "end": [1026, 49], "kind": "commanddeclaration"}, {"full_name": "HasContinuousInv\u2080.measurableInv", "code": "instance (priority := 100) HasContinuousInv\u2080.measurableInv [GroupWithZero \u03b3] [T1Space \u03b3]\n    [HasContinuousInv\u2080 \u03b3] : MeasurableInv \u03b3 :=\n  \u27e8measurable_of_continuousOn_compl_singleton 0 continuousOn_inv\u2080\u27e9", "start": [1029, 1], "end": [1031, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousMul.measurableMul\u2082", "code": "@[to_additive]\ninstance (priority := 100) ContinuousMul.measurableMul\u2082 [SecondCountableTopology \u03b3] [Mul \u03b3]\n    [ContinuousMul \u03b3] : MeasurableMul\u2082 \u03b3 :=\n  \u27e8continuous_mul.measurable\u27e9", "start": [1034, 1], "end": [1037, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousSub.measurableSub\u2082", "code": "instance (priority := 100) ContinuousSub.measurableSub\u2082 [SecondCountableTopology \u03b3] [Sub \u03b3]\n    [ContinuousSub \u03b3] : MeasurableSub\u2082 \u03b3 :=\n  \u27e8continuous_sub.measurable\u27e9", "start": [1041, 1], "end": [1043, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousSMul.measurableSMul\u2082", "code": "instance (priority := 100) ContinuousSMul.measurableSMul\u2082 {M \u03b1} [TopologicalSpace M]\n    [MeasurableSpace M] [OpensMeasurableSpace M] [TopologicalSpace \u03b1]\n    [SecondCountableTopologyEither M \u03b1] [MeasurableSpace \u03b1] [BorelSpace \u03b1] [SMul M \u03b1]\n    [ContinuousSMul M \u03b1] : MeasurableSMul\u2082 M \u03b1 :=\n  \u27e8continuous_smul.measurable\u27e9", "start": [1046, 1], "end": [1050, 31], "kind": "commanddeclaration"}, {"full_name": "pi_le_borel_pi", "code": "theorem pi_le_borel_pi {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]\n    [\u2200 i, MeasurableSpace (\u03c0 i)] [\u2200 i, BorelSpace (\u03c0 i)] :\n      MeasurableSpace.pi \u2264 borel (\u2200 i, \u03c0 i)", "start": [1061, 1], "end": [1067, 88], "kind": "commanddeclaration"}, {"full_name": "prod_le_borel_prod", "code": "theorem prod_le_borel_prod : Prod.instMeasurableSpace \u2264 borel (\u03b1 \u00d7 \u03b2)", "start": [1070, 1], "end": [1074, 66], "kind": "commanddeclaration"}, {"full_name": "Pi.borelSpace", "code": "instance Pi.borelSpace {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [Countable \u03b9] [\u2200 i, TopologicalSpace (\u03c0 i)]\n    [\u2200 i, MeasurableSpace (\u03c0 i)] [\u2200 i, SecondCountableTopology (\u03c0 i)] [\u2200 i, BorelSpace (\u03c0 i)] :\n    BorelSpace (\u2200 i, \u03c0 i) :=\n  \u27e8le_antisymm pi_le_borel_pi OpensMeasurableSpace.borel_le\u27e9", "start": [1077, 1], "end": [1080, 61], "kind": "commanddeclaration"}, {"full_name": "Prod.borelSpace", "code": "instance Prod.borelSpace [SecondCountableTopologyEither \u03b1 \u03b2] :\n    BorelSpace (\u03b1 \u00d7 \u03b2) :=\n  \u27e8le_antisymm prod_le_borel_prod OpensMeasurableSpace.borel_le\u27e9", "start": [1083, 1], "end": [1085, 65], "kind": "commanddeclaration"}, {"full_name": "Embedding.measurableEmbedding", "code": "protected theorem Embedding.measurableEmbedding {f : \u03b1 \u2192 \u03b2} (h\u2081 : Embedding f)\n    (h\u2082 : MeasurableSet (range f)) : MeasurableEmbedding f", "start": [1088, 1], "end": [1092, 86], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.measurableEmbedding", "code": "protected theorem ClosedEmbedding.measurableEmbedding {f : \u03b1 \u2192 \u03b2} (h : ClosedEmbedding f) :\n    MeasurableEmbedding f", "start": [1095, 1], "end": [1097, 65], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.measurableEmbedding", "code": "protected theorem OpenEmbedding.measurableEmbedding {f : \u03b1 \u2192 \u03b2} (h : OpenEmbedding f) :\n    MeasurableEmbedding f", "start": [1100, 1], "end": [1102, 63], "kind": "commanddeclaration"}, {"full_name": "measurable_of_Iio", "code": "theorem measurable_of_Iio {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Iio x)) : Measurable f", "start": [1109, 1], "end": [1112, 32], "kind": "commanddeclaration"}, {"full_name": "UpperSemicontinuous.measurable", "code": "theorem UpperSemicontinuous.measurable [TopologicalSpace \u03b4] [OpensMeasurableSpace \u03b4] {f : \u03b4 \u2192 \u03b1}\n    (hf : UpperSemicontinuous f) : Measurable f", "start": [1115, 1], "end": [1117, 66], "kind": "commanddeclaration"}, {"full_name": "measurable_of_Ioi", "code": "theorem measurable_of_Ioi {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Ioi x)) : Measurable f", "start": [1120, 1], "end": [1123, 32], "kind": "commanddeclaration"}, {"full_name": "LowerSemicontinuous.measurable", "code": "theorem LowerSemicontinuous.measurable [TopologicalSpace \u03b4] [OpensMeasurableSpace \u03b4] {f : \u03b4 \u2192 \u03b1}\n    (hf : LowerSemicontinuous f) : Measurable f", "start": [1126, 1], "end": [1128, 66], "kind": "commanddeclaration"}, {"full_name": "measurable_of_Iic", "code": "theorem measurable_of_Iic {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Iic x)) : Measurable f", "start": [1131, 1], "end": [1134, 13], "kind": "commanddeclaration"}, {"full_name": "measurable_of_Ici", "code": "theorem measurable_of_Ici {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Ici x)) : Measurable f", "start": [1137, 1], "end": [1140, 13], "kind": "commanddeclaration"}, {"full_name": "Measurable.isLUB", "code": "theorem Measurable.isLUB {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i))\n    (hg : \u2200 b, IsLUB { a | \u2203 i, f i b = a } (g b)) : Measurable g", "start": [1143, 1], "end": [1152, 72], "kind": "commanddeclaration"}, {"full_name": "Measurable.isLUB_of_mem", "code": "theorem Measurable.isLUB_of_mem {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g g' : \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, Measurable (f i))\n    {s : Set \u03b4} (hs : MeasurableSet s) (hg : \u2200 b \u2208 s, IsLUB { a | \u2203 i, f i b = a } (g b))\n    (hg' : EqOn g g' s\u1d9c) (g'_meas : Measurable g') : Measurable g", "start": [1155, 1], "end": [1192, 46], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.isLUB", "code": "theorem AEMeasurable.isLUB {\u03b9} {\u03bc : Measure \u03b4} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, AEMeasurable (f i) \u03bc) (hg : \u2200\u1d50 b \u2202\u03bc, IsLUB { a | \u2203 i, f i b = a } (g b)) :\n    AEMeasurable g \u03bc", "start": [1194, 1], "end": [1218, 59], "kind": "commanddeclaration"}, {"full_name": "Measurable.isGLB", "code": "theorem Measurable.isGLB {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i))\n    (hg : \u2200 b, IsGLB { a | \u2203 i, f i b = a } (g b)) : Measurable g", "start": [1221, 1], "end": [1225, 36], "kind": "commanddeclaration"}, {"full_name": "Measurable.isGLB_of_mem", "code": "theorem Measurable.isGLB_of_mem {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g g' : \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, Measurable (f i))\n    {s : Set \u03b4} (hs : MeasurableSet s) (hg : \u2200 b \u2208 s, IsGLB { a | \u2203 i, f i b = a } (g b))\n    (hg' : EqOn g g' s\u1d9c) (g'_meas : Measurable g') : Measurable g", "start": [1228, 1], "end": [1234, 59], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.isGLB", "code": "theorem AEMeasurable.isGLB {\u03b9} {\u03bc : Measure \u03b4} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, AEMeasurable (f i) \u03bc) (hg : \u2200\u1d50 b \u2202\u03bc, IsGLB { a | \u2203 i, f i b = a } (g b)) :\n    AEMeasurable g \u03bc", "start": [1236, 1], "end": [1239, 38], "kind": "commanddeclaration"}, {"full_name": "Monotone.measurable", "code": "protected theorem Monotone.measurable [LinearOrder \u03b2] [OrderClosedTopology \u03b2] {f : \u03b2 \u2192 \u03b1}\n    (hf : Monotone f) : Measurable f", "start": [1242, 1], "end": [1245, 83], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_restrict_of_monotoneOn", "code": "theorem aemeasurable_restrict_of_monotoneOn [LinearOrder \u03b2] [OrderClosedTopology \u03b2] {\u03bc : Measure \u03b2}\n    {s : Set \u03b2} (hs : MeasurableSet s) {f : \u03b2 \u2192 \u03b1} (hf : MonotoneOn f s) :\n    AEMeasurable f (\u03bc.restrict s)", "start": [1248, 1], "end": [1252, 65], "kind": "commanddeclaration"}, {"full_name": "Antitone.measurable", "code": "protected theorem Antitone.measurable [LinearOrder \u03b2] [OrderClosedTopology \u03b2] {f : \u03b2 \u2192 \u03b1}\n    (hf : Antitone f) : Measurable f", "start": [1255, 1], "end": [1257, 60], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_restrict_of_antitoneOn", "code": "theorem aemeasurable_restrict_of_antitoneOn [LinearOrder \u03b2] [OrderClosedTopology \u03b2] {\u03bc : Measure \u03b2}\n    {s : Set \u03b2} (hs : MeasurableSet s) {f : \u03b2 \u2192 \u03b1} (hf : AntitoneOn f s) :\n    AEMeasurable f (\u03bc.restrict s)", "start": [1260, 1], "end": [1263, 83], "kind": "commanddeclaration"}, {"full_name": "measurableSet_of_mem_nhdsWithin_Ioi_aux", "code": "theorem measurableSet_of_mem_nhdsWithin_Ioi_aux {s : Set \u03b1} (h : \u2200 x \u2208 s, s \u2208 \ud835\udcdd[>] x)\n    (h' : \u2200 x \u2208 s, \u2203 y, x < y) : MeasurableSet s", "start": [1266, 1], "end": [1287, 49], "kind": "commanddeclaration"}, {"full_name": "measurableSet_of_mem_nhdsWithin_Ioi", "code": "theorem measurableSet_of_mem_nhdsWithin_Ioi {s : Set \u03b1} (h : \u2200 x \u2208 s, s \u2208 \ud835\udcdd[>] x) :\n    MeasurableSet s", "start": [1290, 1], "end": [1307, 12], "kind": "commanddeclaration"}, {"full_name": "measurableSet_bddAbove_range", "code": "lemma measurableSet_bddAbove_range {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    MeasurableSet {b | BddAbove (range (fun i \u21a6 f i b))} := by\n  rcases isEmpty_or_nonempty \u03b1 with h\u03b1|h\u03b1\n  \u00b7 have : \u2200 b, range (fun i \u21a6 f i b) = \u2205 := fun b \u21a6 Iff.mp toFinset_eq_empty rfl\n    simp [this]\n  have A : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c} := by\n    intro i c\n    exact measurableSet_le (hf i) measurable_const\n  have B : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 i, f i x \u2264 c} := by\n    intro c\n    rw [setOf_forall]\n    exact MeasurableSet.iInter (fun i \u21a6 A i c)\n  obtain \u27e8u, hu\u27e9 : \u2203 (u : \u2115 \u2192 \u03b1), Tendsto u atTop atTop := exists_seq_tendsto (atTop : Filter \u03b1)\n  have : {b | BddAbove (range (fun i \u21a6 f i b))} = {x | \u2203 n, \u2200 i, f i x \u2264 u n} := by\n    apply Subset.antisymm\n    \u00b7 rintro x \u27e8c, hc\u27e9\n      obtain \u27e8n, hn\u27e9 : \u2203 n, c \u2264 u n := (tendsto_atTop.1 hu c).exists\n      exact \u27e8n, fun i \u21a6 (hc ((mem_range_self i))).trans hn\u27e9\n    \u00b7 rintro x \u27e8n, hn\u27e9\n      refine \u27e8u n, ?_\u27e9\n      rintro - \u27e8i, rfl\u27e9\n      exact hn i\n  rw [this, setOf_exists]\n  exact MeasurableSet.iUnion (fun n \u21a6 B (u n))", "start": [1310, 1], "end": [1333, 47], "kind": "mathlibtacticlemma"}, {"full_name": "measurableSet_bddBelow_range", "code": "lemma measurableSet_bddBelow_range {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    MeasurableSet {b | BddBelow (range (fun i \u21a6 f i b))} :=\n  measurableSet_bddAbove_range (\u03b1 := \u03b1\u1d52\u1d48) hf", "start": [1335, 1], "end": [1337, 45], "kind": "mathlibtacticlemma"}, {"full_name": "Measurable.iSup_Prop", "code": "@[measurability]\ntheorem Measurable.iSup_Prop {\u03b1} [MeasurableSpace \u03b1] [ConditionallyCompleteLattice \u03b1]\n    (p : Prop) {f : \u03b4 \u2192 \u03b1} (hf : Measurable f) : Measurable fun b => \u2a06 _ : p, f b", "start": [1341, 1], "end": [1345, 64], "kind": "commanddeclaration"}, {"full_name": "Measurable.iInf_Prop", "code": "@[measurability]\ntheorem Measurable.iInf_Prop {\u03b1} [MeasurableSpace \u03b1] [ConditionallyCompleteLattice \u03b1]\n    (p : Prop) {f : \u03b4 \u2192 \u03b1} (hf : Measurable f) : Measurable fun b => \u2a05 _ : p, f b", "start": [1348, 1], "end": [1352, 64], "kind": "commanddeclaration"}, {"full_name": "measurable_iSup", "code": "@[measurability]\ntheorem measurable_iSup {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    Measurable (fun b \u21a6 \u2a06 i, f i b)", "start": [1359, 1], "end": [1375, 13], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_iSup", "code": "@[measurability]\ntheorem aemeasurable_iSup {\u03b9} {\u03bc : Measure \u03b4} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, AEMeasurable (f i) \u03bc) : AEMeasurable (fun b => \u2a06 i, f i b) \u03bc", "start": [1377, 1], "end": [1381, 87], "kind": "commanddeclaration"}, {"full_name": "measurable_iInf", "code": "@[measurability]\ntheorem measurable_iInf {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    Measurable fun b => \u2a05 i, f i b", "start": [1384, 1], "end": [1387, 32], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_iInf", "code": "@[measurability]\ntheorem aemeasurable_iInf {\u03b9} {\u03bc : Measure \u03b4} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, AEMeasurable (f i) \u03bc) : AEMeasurable (fun b => \u2a05 i, f i b) \u03bc", "start": [1390, 1], "end": [1393, 34], "kind": "commanddeclaration"}, {"full_name": "measurable_sSup", "code": "theorem measurable_sSup {\u03b9} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {s : Set \u03b9} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, Measurable (f i)) :\n    Measurable fun x => sSup ((fun i => f i x) '' s)", "start": [1396, 1], "end": [1403, 41], "kind": "commanddeclaration"}, {"full_name": "measurable_sInf", "code": "theorem measurable_sInf {\u03b9} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {s : Set \u03b9} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, Measurable (f i)) :\n    Measurable fun x => sInf ((fun i => f i x) '' s)", "start": [1406, 1], "end": [1409, 35], "kind": "commanddeclaration"}, {"full_name": "measurable_biSup", "code": "theorem measurable_biSup {\u03b9} (s : Set \u03b9) {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, Measurable (f i)) : Measurable fun b => \u2a06 i \u2208 s, f i b", "start": [1412, 1], "end": [1424, 51], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_biSup", "code": "theorem aemeasurable_biSup {\u03b9} {\u03bc : Measure \u03b4} (s : Set \u03b9) {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, AEMeasurable (f i) \u03bc) : AEMeasurable (fun b => \u2a06 i \u2208 s, f i b) \u03bc", "start": [1427, 1], "end": [1441, 16], "kind": "commanddeclaration"}, {"full_name": "measurable_biInf", "code": "theorem measurable_biInf {\u03b9} (s : Set \u03b9) {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, Measurable (f i)) : Measurable fun b => \u2a05 i \u2208 s, f i b", "start": [1444, 1], "end": [1446, 38], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_biInf", "code": "theorem aemeasurable_biInf {\u03b9} {\u03bc : Measure \u03b4} (s : Set \u03b9) {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, AEMeasurable (f i) \u03bc) : AEMeasurable (fun b => \u2a05 i \u2208 s, f i b) \u03bc", "start": [1449, 1], "end": [1451, 40], "kind": "commanddeclaration"}, {"full_name": "measurable_liminf'", "code": "theorem measurable_liminf' {\u03b9 \u03b9'} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {v : Filter \u03b9} (hf : \u2200 i, Measurable (f i))\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} (hv : v.HasCountableBasis p s) (hs : \u2200 j, (s j).Countable) :\n    Measurable fun x => liminf (fun i => f i x) v", "start": [1454, 1], "end": [1505, 37], "kind": "commanddeclaration"}, {"full_name": "measurable_limsup'", "code": "theorem measurable_limsup' {\u03b9 \u03b9'} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {u : Filter \u03b9} (hf : \u2200 i, Measurable (f i))\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} (hu : u.HasCountableBasis p s) (hs : \u2200 i, (s i).Countable) :\n    Measurable fun x => limsup (fun i => f i x) u", "start": [1508, 1], "end": [1513, 41], "kind": "commanddeclaration"}, {"full_name": "measurable_liminf", "code": "@[measurability]\ntheorem measurable_liminf {f : \u2115 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    Measurable fun x => liminf (fun i => f i x) atTop", "start": [1516, 1], "end": [1521, 70], "kind": "commanddeclaration"}, {"full_name": "measurable_limsup", "code": "@[measurability]\ntheorem measurable_limsup {f : \u2115 \u2192 \u03b4 \u2192 \u03b1} (hf : \u2200 i, Measurable (f i)) :\n    Measurable fun x => limsup (fun i => f i x) atTop", "start": [1524, 1], "end": [1529, 70], "kind": "commanddeclaration"}, {"full_name": "Homemorph.toMeasurableEquiv", "code": "def Homemorph.toMeasurableEquiv (h : \u03b1 \u2243\u209c \u03b2) : \u03b1 \u2243\u1d50 \u03b2 where\n  toEquiv := h.toEquiv\n  measurable_toFun := h.continuous_toFun.measurable\n  measurable_invFun := h.continuous_invFun.measurable", "start": [1534, 1], "end": [1538, 54], "kind": "commanddeclaration"}, {"full_name": "IsFiniteMeasureOnCompacts.map", "code": "protected theorem IsFiniteMeasureOnCompacts.map {\u03b1 : Type*} {m0 : MeasurableSpace \u03b1}\n    [TopologicalSpace \u03b1] [OpensMeasurableSpace \u03b1] {\u03b2 : Type*} [MeasurableSpace \u03b2]\n    [TopologicalSpace \u03b2] [BorelSpace \u03b2] [T2Space \u03b2] (\u03bc : Measure \u03b1) [IsFiniteMeasureOnCompacts \u03bc]\n    (f : \u03b1 \u2243\u209c \u03b2) : IsFiniteMeasureOnCompacts (Measure.map f \u03bc)", "start": [1541, 1], "end": [1549, 32], "kind": "commanddeclaration"}, {"full_name": "Empty.borelSpace", "code": "instance Empty.borelSpace : BorelSpace Empty :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9", "start": [1554, 1], "end": [1555, 34], "kind": "commanddeclaration"}, {"full_name": "Unit.borelSpace", "code": "instance Unit.borelSpace : BorelSpace Unit :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9", "start": [1558, 1], "end": [1559, 34], "kind": "commanddeclaration"}, {"full_name": "Bool.borelSpace", "code": "instance Bool.borelSpace : BorelSpace Bool :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9", "start": [1562, 1], "end": [1563, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.borelSpace", "code": "instance Nat.borelSpace : BorelSpace \u2115 :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9", "start": [1566, 1], "end": [1567, 34], "kind": "commanddeclaration"}, {"full_name": "Int.borelSpace", "code": "instance Int.borelSpace : BorelSpace \u2124 :=\n  \u27e8borel_eq_top_of_discrete.symm\u27e9", "start": [1570, 1], "end": [1571, 34], "kind": "commanddeclaration"}, {"full_name": "Rat.borelSpace", "code": "instance Rat.borelSpace : BorelSpace \u211a :=\n  \u27e8borel_eq_top_of_countable.symm\u27e9", "start": [1574, 1], "end": [1575, 35], "kind": "commanddeclaration"}, {"full_name": "Real.measurableSpace", "code": "instance Real.measurableSpace : MeasurableSpace \u211d :=\n  borel \u211d", "start": [1580, 1], "end": [1581, 10], "kind": "commanddeclaration"}, {"full_name": "Real.borelSpace", "code": "instance Real.borelSpace : BorelSpace \u211d :=\n  \u27e8rfl\u27e9", "start": [1584, 1], "end": [1585, 8], "kind": "commanddeclaration"}, {"full_name": "NNReal.measurableSpace", "code": "instance NNReal.measurableSpace : MeasurableSpace \u211d\u22650 :=\n  Subtype.instMeasurableSpace", "start": [1588, 1], "end": [1589, 30], "kind": "commanddeclaration"}, {"full_name": "NNReal.borelSpace", "code": "instance NNReal.borelSpace : BorelSpace \u211d\u22650 :=\n  Subtype.borelSpace _", "start": [1592, 1], "end": [1593, 23], "kind": "commanddeclaration"}, {"full_name": "ENNReal.measurableSpace", "code": "instance ENNReal.measurableSpace : MeasurableSpace \u211d\u22650\u221e :=\n  borel \u211d\u22650\u221e", "start": [1596, 1], "end": [1597, 13], "kind": "commanddeclaration"}, {"full_name": "ENNReal.borelSpace", "code": "instance ENNReal.borelSpace : BorelSpace \u211d\u22650\u221e :=\n  \u27e8rfl\u27e9", "start": [1600, 1], "end": [1601, 8], "kind": "commanddeclaration"}, {"full_name": "EReal.measurableSpace", "code": "instance EReal.measurableSpace : MeasurableSpace EReal :=\n  borel EReal", "start": [1604, 1], "end": [1605, 14], "kind": "commanddeclaration"}, {"full_name": "EReal.borelSpace", "code": "instance EReal.borelSpace : BorelSpace EReal :=\n  \u27e8rfl\u27e9", "start": [1608, 1], "end": [1609, 8], "kind": "commanddeclaration"}, {"full_name": "measure_eq_measure_preimage_add_measure_tsum_Ico_zpow", "code": "theorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1)\n    {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) {s : Set \u03b1} (hs : MeasurableSet s) {t : \u211d\u22650} (ht : 1 < t) :\n    \u03bc s =\n      \u03bc (s \u2229 f \u207b\u00b9' {0}) + \u03bc (s \u2229 f \u207b\u00b9' {\u221e}) +\n      \u2211' n : \u2124, \u03bc (s \u2229 f \u207b\u00b9' Ico ((t : \u211d\u22650\u221e) ^ n) ((t : \u211d\u22650\u221e) ^ (n + 1)))", "start": [1612, 1], "end": [1664, 26], "kind": "commanddeclaration"}, {"full_name": "measurableSet_ball", "code": "@[measurability]\ntheorem measurableSet_ball : MeasurableSet (Metric.ball x \u03b5)", "start": [1675, 1], "end": [1677, 35], "kind": "commanddeclaration"}, {"full_name": "measurableSet_closedBall", "code": "@[measurability]\ntheorem measurableSet_closedBall : MeasurableSet (Metric.closedBall x \u03b5)", "start": [1680, 1], "end": [1682, 37], "kind": "commanddeclaration"}, {"full_name": "measurable_infDist", "code": "@[measurability]\ntheorem measurable_infDist {s : Set \u03b1} : Measurable fun x => infDist x s", "start": [1685, 1], "end": [1687, 39], "kind": "commanddeclaration"}, {"full_name": "Measurable.infDist", "code": "@[measurability]\ntheorem Measurable.infDist {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} :\n    Measurable fun x => infDist (f x) s", "start": [1690, 1], "end": [1693, 29], "kind": "commanddeclaration"}, {"full_name": "measurable_infNndist", "code": "@[measurability]\ntheorem measurable_infNndist {s : Set \u03b1} : Measurable fun x => infNndist x s", "start": [1696, 1], "end": [1698, 41], "kind": "commanddeclaration"}, {"full_name": "Measurable.infNndist", "code": "@[measurability]\ntheorem Measurable.infNndist {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} :\n    Measurable fun x => infNndist (f x) s", "start": [1701, 1], "end": [1704, 31], "kind": "commanddeclaration"}, {"full_name": "measurable_dist", "code": "@[measurability]\ntheorem measurable_dist : Measurable fun p : \u03b1 \u00d7 \u03b1 => dist p.1 p.2", "start": [1711, 1], "end": [1713, 29], "kind": "commanddeclaration"}, {"full_name": "Measurable.dist", "code": "@[measurability]\ntheorem Measurable.dist {f g : \u03b2 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun b => dist (f b) (g b)", "start": [1716, 1], "end": [1719, 43], "kind": "commanddeclaration"}, {"full_name": "measurable_nndist", "code": "@[measurability]\ntheorem measurable_nndist : Measurable fun p : \u03b1 \u00d7 \u03b1 => nndist p.1 p.2", "start": [1722, 1], "end": [1724, 31], "kind": "commanddeclaration"}, {"full_name": "Measurable.nndist", "code": "@[measurability]\ntheorem Measurable.nndist {f g : \u03b2 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun b => nndist (f b) (g b)", "start": [1727, 1], "end": [1730, 45], "kind": "commanddeclaration"}, {"full_name": "measurableSet_eball", "code": "@[measurability]\ntheorem measurableSet_eball : MeasurableSet (EMetric.ball x \u03b5)", "start": [1745, 1], "end": [1747, 36], "kind": "commanddeclaration"}, {"full_name": "measurable_edist_right", "code": "@[measurability]\ntheorem measurable_edist_right : Measurable (edist x)", "start": [1750, 1], "end": [1752, 52], "kind": "commanddeclaration"}, {"full_name": "measurable_edist_left", "code": "@[measurability]\ntheorem measurable_edist_left : Measurable fun y => edist y x", "start": [1755, 1], "end": [1757, 52], "kind": "commanddeclaration"}, {"full_name": "measurable_infEdist", "code": "@[measurability]\ntheorem measurable_infEdist {s : Set \u03b1} : Measurable fun x => infEdist x s", "start": [1760, 1], "end": [1762, 33], "kind": "commanddeclaration"}, {"full_name": "Measurable.infEdist", "code": "@[measurability]\ntheorem Measurable.infEdist {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} :\n    Measurable fun x => infEdist (f x) s", "start": [1765, 1], "end": [1768, 30], "kind": "commanddeclaration"}, {"full_name": "tendsto_measure_cthickening", "code": "theorem tendsto_measure_cthickening {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (cthickening R s) \u2260 \u221e) :\n    Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd 0) (\ud835\udcdd (\u03bc (closure s)))", "start": [1773, 1], "end": [1788, 43], "kind": "commanddeclaration"}, {"full_name": "tendsto_measure_cthickening_of_isClosed", "code": "theorem tendsto_measure_cthickening_of_isClosed {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (cthickening R s) \u2260 \u221e) (h's : IsClosed s) :\n    Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd 0) (\ud835\udcdd (\u03bc s))", "start": [1791, 1], "end": [1797, 28], "kind": "commanddeclaration"}, {"full_name": "tendsto_measure_thickening", "code": "theorem tendsto_measure_thickening {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (thickening R s) \u2260 \u221e) :\n    Tendsto (fun r => \u03bc (thickening r s)) (\ud835\udcdd[>] 0) (\ud835\udcdd (\u03bc (closure s)))", "start": [1800, 1], "end": [1807, 48], "kind": "commanddeclaration"}, {"full_name": "tendsto_measure_thickening_of_isClosed", "code": "theorem tendsto_measure_thickening_of_isClosed {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (thickening R s) \u2260 \u221e) (h's : IsClosed s) :\n    Tendsto (fun r => \u03bc (thickening r s)) (\ud835\udcdd[>] 0) (\ud835\udcdd (\u03bc s))", "start": [1809, 1], "end": [1815, 28], "kind": "commanddeclaration"}, {"full_name": "measurable_edist", "code": "@[measurability]\ntheorem measurable_edist : Measurable fun p : \u03b1 \u00d7 \u03b1 => edist p.1 p.2", "start": [1819, 1], "end": [1821, 30], "kind": "commanddeclaration"}, {"full_name": "Measurable.edist", "code": "@[measurability]\ntheorem Measurable.edist {f g : \u03b2 \u2192 \u03b1} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun b => edist (f b) (g b)", "start": [1824, 1], "end": [1827, 44], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.edist", "code": "@[measurability]\ntheorem AEMeasurable.edist {f g : \u03b2 \u2192 \u03b1} {\u03bc : Measure \u03b2} (hf : AEMeasurable f \u03bc)\n    (hg : AEMeasurable g \u03bc) : AEMeasurable (fun a => edist (f a) (g a)) \u03bc", "start": [1830, 1], "end": [1833, 46], "kind": "commanddeclaration"}, {"full_name": "tendsto_measure_cthickening_of_isCompact", "code": "theorem tendsto_measure_cthickening_of_isCompact [MetricSpace \u03b1] [MeasurableSpace \u03b1]\n    [OpensMeasurableSpace \u03b1] [ProperSpace \u03b1] {\u03bc : Measure \u03b1} [IsFiniteMeasureOnCompacts \u03bc]\n    {s : Set \u03b1} (hs : IsCompact s) :\n    Tendsto (fun r => \u03bc (Metric.cthickening r s)) (\ud835\udcdd 0) (\ud835\udcdd (\u03bc s))", "start": [1838, 1], "end": [1845, 77], "kind": "commanddeclaration"}, {"full_name": "Real.borel_eq_generateFrom_Ioo_rat", "code": "theorem borel_eq_generateFrom_Ioo_rat :\n    borel \u211d = .generateFrom (\u22c3 (a : \u211a) (b : \u211a) (_ : a < b), {Ioo (a : \u211d) (b : \u211d)})", "start": [1852, 1], "end": [1854, 51], "kind": "commanddeclaration"}, {"full_name": "Real.borel_eq_generateFrom_Iio_rat", "code": "theorem borel_eq_generateFrom_Iio_rat : borel \u211d = .generateFrom (\u22c3 a : \u211a, {Iio (a : \u211d)})", "start": [1857, 1], "end": [1867, 64], "kind": "commanddeclaration"}, {"full_name": "Real.borel_eq_generateFrom_Ioi_rat", "code": "theorem borel_eq_generateFrom_Ioi_rat : borel \u211d = .generateFrom (\u22c3 a : \u211a, {Ioi (a : \u211d)})", "start": [1869, 1], "end": [1879, 64], "kind": "commanddeclaration"}, {"full_name": "Real.borel_eq_generateFrom_Iic_rat", "code": "theorem borel_eq_generateFrom_Iic_rat : borel \u211d = .generateFrom (\u22c3 a : \u211a, {Iic (a : \u211d)})", "start": [1881, 1], "end": [1887, 76], "kind": "commanddeclaration"}, {"full_name": "Real.borel_eq_generateFrom_Ici_rat", "code": "theorem borel_eq_generateFrom_Ici_rat : borel \u211d = .generateFrom (\u22c3 a : \u211a, {Ici (a : \u211d)})", "start": [1889, 1], "end": [1895, 76], "kind": "commanddeclaration"}, {"full_name": "Real.isPiSystem_Ioo_rat", "code": "theorem isPiSystem_Ioo_rat :\n    IsPiSystem (\u22c3 (a : \u211a) (b : \u211a) (_ : a < b), {Ioo (a : \u211d) (b : \u211d)})", "start": [1897, 1], "end": [1901, 17], "kind": "commanddeclaration"}, {"full_name": "Real.isPiSystem_Iio_rat", "code": "theorem isPiSystem_Iio_rat : IsPiSystem (\u22c3 a : \u211a, {Iio (a : \u211d)})", "start": [1904, 1], "end": [1907, 96], "kind": "commanddeclaration"}, {"full_name": "Real.isPiSystem_Ioi_rat", "code": "theorem isPiSystem_Ioi_rat : IsPiSystem (\u22c3 a : \u211a, {Ioi (a : \u211d)})", "start": [1909, 1], "end": [1912, 96], "kind": "commanddeclaration"}, {"full_name": "Real.isPiSystem_Iic_rat", "code": "theorem isPiSystem_Iic_rat : IsPiSystem (\u22c3 a : \u211a, {Iic (a : \u211d)})", "start": [1914, 1], "end": [1917, 96], "kind": "commanddeclaration"}, {"full_name": "Real.isPiSystem_Ici_rat", "code": "theorem isPiSystem_Ici_rat : IsPiSystem (\u22c3 a : \u211a, {Ici (a : \u211d)})", "start": [1919, 1], "end": [1922, 96], "kind": "commanddeclaration"}, {"full_name": "Real.finiteSpanningSetsInIooRat", "code": "def finiteSpanningSetsInIooRat (\u03bc : Measure \u211d) [IsLocallyFiniteMeasure \u03bc] :\n    \u03bc.FiniteSpanningSetsIn (\u22c3 (a : \u211a) (b : \u211a) (_ : a < b), {Ioo (a : \u211d) (b : \u211d)}) where\n  set n := Ioo (-(n + 1)) (n + 1)\n  set_mem n := by\n    simp only [mem_iUnion, mem_singleton_iff]\n    refine' \u27e8-(n + 1 : \u2115), n + 1, _, by simp\u27e9\n    exact (neg_nonpos.2 (@Nat.cast_nonneg \u211a _ (n + 1))).trans_lt n.cast_add_one_pos\n  finite n := measure_Ioo_lt_top\n  spanning :=\n    iUnion_eq_univ_iff.2 fun x =>\n      \u27e8\u230a|x|\u230b\u208a, neg_lt.1 ((neg_le_abs_self x).trans_lt (Nat.lt_floor_add_one _)),\n        (le_abs_self x).trans_lt (Nat.lt_floor_add_one _)\u27e9", "start": [1924, 1], "end": [1938, 59], "kind": "commanddeclaration"}, {"full_name": "Real.measure_ext_Ioo_rat", "code": "theorem measure_ext_Ioo_rat {\u03bc \u03bd : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]\n    (h : \u2200 a b : \u211a, \u03bc (Ioo a b) = \u03bd (Ioo a b)) : \u03bc = \u03bd", "start": [1941, 1], "end": [1946, 12], "kind": "commanddeclaration"}, {"full_name": "measurable_real_toNNReal", "code": "@[measurability]\ntheorem measurable_real_toNNReal : Measurable Real.toNNReal", "start": [1953, 1], "end": [1955, 38], "kind": "commanddeclaration"}, {"full_name": "Measurable.real_toNNReal", "code": "@[measurability]\ntheorem Measurable.real_toNNReal {f : \u03b1 \u2192 \u211d} (hf : Measurable f) :\n    Measurable fun x => Real.toNNReal (f x)", "start": [1958, 1], "end": [1961, 35], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.real_toNNReal", "code": "@[measurability]\ntheorem AEMeasurable.real_toNNReal {f : \u03b1 \u2192 \u211d} {\u03bc : Measure \u03b1} (hf : AEMeasurable f \u03bc) :\n    AEMeasurable (fun x => Real.toNNReal (f x)) \u03bc", "start": [1964, 1], "end": [1967, 48], "kind": "commanddeclaration"}, {"full_name": "measurable_coe_nnreal_real", "code": "@[measurability]\ntheorem measurable_coe_nnreal_real : Measurable ((\u2191) : \u211d\u22650 \u2192 \u211d)", "start": [1970, 1], "end": [1972, 35], "kind": "commanddeclaration"}, {"full_name": "Measurable.coe_nnreal_real", "code": "@[measurability]\ntheorem Measurable.coe_nnreal_real {f : \u03b1 \u2192 \u211d\u22650} (hf : Measurable f) :\n    Measurable fun x => (f x : \u211d)", "start": [1975, 1], "end": [1978, 37], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.coe_nnreal_real", "code": "@[measurability]\ntheorem AEMeasurable.coe_nnreal_real {f : \u03b1 \u2192 \u211d\u22650} {\u03bc : Measure \u03b1} (hf : AEMeasurable f \u03bc) :\n    AEMeasurable (fun x => (f x : \u211d)) \u03bc", "start": [1981, 1], "end": [1984, 50], "kind": "commanddeclaration"}, {"full_name": "measurable_coe_nnreal_ennreal", "code": "@[measurability]\ntheorem measurable_coe_nnreal_ennreal : Measurable ((\u2191) : \u211d\u22650 \u2192 \u211d\u22650\u221e)", "start": [1987, 1], "end": [1989, 36], "kind": "commanddeclaration"}, {"full_name": "Measurable.coe_nnreal_ennreal", "code": "@[measurability]\ntheorem Measurable.coe_nnreal_ennreal {f : \u03b1 \u2192 \u211d\u22650} (hf : Measurable f) :\n    Measurable fun x => (f x : \u211d\u22650\u221e)", "start": [1992, 1], "end": [1995, 44], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.coe_nnreal_ennreal", "code": "@[measurability]\ntheorem AEMeasurable.coe_nnreal_ennreal {f : \u03b1 \u2192 \u211d\u22650} {\u03bc : Measure \u03b1} (hf : AEMeasurable f \u03bc) :\n    AEMeasurable (fun x => (f x : \u211d\u22650\u221e)) \u03bc", "start": [1998, 1], "end": [2001, 57], "kind": "commanddeclaration"}, {"full_name": "Measurable.ennreal_ofReal", "code": "@[measurability]\ntheorem Measurable.ennreal_ofReal {f : \u03b1 \u2192 \u211d} (hf : Measurable f) :\n    Measurable fun x => ENNReal.ofReal (f x)", "start": [2004, 1], "end": [2007, 47], "kind": "commanddeclaration"}, {"full_name": "measurable_coe_nnreal_real_iff", "code": "@[simp, norm_cast]\ntheorem measurable_coe_nnreal_real_iff {f : \u03b1 \u2192 \u211d\u22650} :\n    Measurable (fun x => f x : \u03b1 \u2192 \u211d) \u2194 Measurable f", "start": [2010, 1], "end": [2013, 97], "kind": "commanddeclaration"}, {"full_name": "aEMeasurable_coe_nnreal_real_iff", "code": "@[simp, norm_cast]\ntheorem aEMeasurable_coe_nnreal_real_iff {f : \u03b1 \u2192 \u211d\u22650} {\u03bc : Measure \u03b1} :\n    AEMeasurable (fun x => f x : \u03b1 \u2192 \u211d) \u03bc \u2194 AEMeasurable f \u03bc", "start": [2016, 1], "end": [2019, 99], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.ennrealEquivNNReal", "code": "def MeasurableEquiv.ennrealEquivNNReal : { r : \u211d\u22650\u221e | r \u2260 \u221e } \u2243\u1d50 \u211d\u22650 :=\n  ENNReal.neTopHomeomorphNNReal.toMeasurableEquiv", "start": [2022, 1], "end": [2024, 50], "kind": "commanddeclaration"}, {"full_name": "ENNReal.measurable_of_measurable_nnreal", "code": "theorem measurable_of_measurable_nnreal {f : \u211d\u22650\u221e \u2192 \u03b1} (h : Measurable fun p : \u211d\u22650 => f p) :\n    Measurable f", "start": [2029, 1], "end": [2032, 70], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ennrealEquivSum", "code": "def ennrealEquivSum : \u211d\u22650\u221e \u2243\u1d50 Sum \u211d\u22650 Unit :=\n  { Equiv.optionEquivSumPUnit \u211d\u22650 with\n    measurable_toFun := measurable_of_measurable_nnreal measurable_inl\n    measurable_invFun :=\n      measurable_sum measurable_coe_nnreal_ennreal (@measurable_const \u211d\u22650\u221e Unit _ _ \u221e) }", "start": [2035, 1], "end": [2040, 89], "kind": "commanddeclaration"}, {"full_name": "ENNReal.measurable_of_measurable_nnreal_prod", "code": "theorem measurable_of_measurable_nnreal_prod [MeasurableSpace \u03b2] [MeasurableSpace \u03b3]\n    {f : \u211d\u22650\u221e \u00d7 \u03b2 \u2192 \u03b3} (H\u2081 : Measurable fun p : \u211d\u22650 \u00d7 \u03b2 => f (p.1, p.2))\n    (H\u2082 : Measurable fun x => f (\u221e, x)) : Measurable f", "start": [2045, 1], "end": [2051, 80], "kind": "commanddeclaration"}, {"full_name": "ENNReal.measurable_of_measurable_nnreal_nnreal", "code": "theorem measurable_of_measurable_nnreal_nnreal [MeasurableSpace \u03b2] {f : \u211d\u22650\u221e \u00d7 \u211d\u22650\u221e \u2192 \u03b2}\n    (h\u2081 : Measurable fun p : \u211d\u22650 \u00d7 \u211d\u22650 => f (p.1, p.2)) (h\u2082 : Measurable fun r : \u211d\u22650 => f (\u221e, r))\n    (h\u2083 : Measurable fun r : \u211d\u22650 => f (r, \u221e)) : Measurable f", "start": [2054, 1], "end": [2059, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.measurable_ofReal", "code": "@[measurability]\ntheorem measurable_ofReal : Measurable ENNReal.ofReal", "start": [2062, 1], "end": [2064, 39], "kind": "commanddeclaration"}, {"full_name": "ENNReal.measurable_toReal", "code": "@[measurability]\ntheorem measurable_toReal : Measurable ENNReal.toReal", "start": [2067, 1], "end": [2069, 69], "kind": "commanddeclaration"}, {"full_name": "ENNReal.measurable_toNNReal", "code": "@[measurability]\ntheorem measurable_toNNReal : Measurable ENNReal.toNNReal", "start": [2072, 1], "end": [2074, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.instMeasurableMul\u2082", "code": "instance instMeasurableMul\u2082 : MeasurableMul\u2082 \u211d\u22650\u221e := by\n  refine' \u27e8measurable_of_measurable_nnreal_nnreal _ _ _\u27e9\n  \u00b7 simp only [\u2190 ENNReal.coe_mul, measurable_mul.coe_nnreal_ennreal]\n  \u00b7 simp only [ENNReal.top_mul', ENNReal.coe_eq_zero]\n    exact measurable_const.piecewise (measurableSet_singleton _) measurable_const\n  \u00b7 simp only [ENNReal.mul_top', ENNReal.coe_eq_zero]\n    exact measurable_const.piecewise (measurableSet_singleton _) measurable_const", "start": [2077, 1], "end": [2083, 82], "kind": "commanddeclaration"}, {"full_name": "ENNReal.instMeasurableSub\u2082", "code": "instance instMeasurableSub\u2082 : MeasurableSub\u2082 \u211d\u22650\u221e :=\n  \u27e8by\n    apply measurable_of_measurable_nnreal_nnreal <;>\n      simp [\u2190 WithTop.coe_sub]; exact continuous_sub.measurable.coe_nnreal_ennreal\u27e9", "start": [2086, 1], "end": [2089, 84], "kind": "commanddeclaration"}, {"full_name": "ENNReal.instMeasurableInv", "code": "instance instMeasurableInv : MeasurableInv \u211d\u22650\u221e :=\n  \u27e8continuous_inv.measurable\u27e9", "start": [2092, 1], "end": [2093, 30], "kind": "commanddeclaration"}, {"full_name": "Measurable.ennreal_toNNReal", "code": "@[measurability]\ntheorem Measurable.ennreal_toNNReal {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    Measurable fun x => (f x).toNNReal", "start": [2098, 1], "end": [2101, 38], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.ennreal_toNNReal", "code": "@[measurability]\ntheorem AEMeasurable.ennreal_toNNReal {f : \u03b1 \u2192 \u211d\u22650\u221e} {\u03bc : Measure \u03b1} (hf : AEMeasurable f \u03bc) :\n    AEMeasurable (fun x => (f x).toNNReal) \u03bc", "start": [2104, 1], "end": [2107, 51], "kind": "commanddeclaration"}, {"full_name": "measurable_coe_nnreal_ennreal_iff", "code": "@[simp, norm_cast]\ntheorem measurable_coe_nnreal_ennreal_iff {f : \u03b1 \u2192 \u211d\u22650} :\n    (Measurable fun x => (f x : \u211d\u22650\u221e)) \u2194 Measurable f", "start": [2110, 1], "end": [2113, 63], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_coe_nnreal_ennreal_iff", "code": "@[simp, norm_cast]\ntheorem aemeasurable_coe_nnreal_ennreal_iff {f : \u03b1 \u2192 \u211d\u22650} {\u03bc : Measure \u03b1} :\n    AEMeasurable (fun x => (f x : \u211d\u22650\u221e)) \u03bc \u2194 AEMeasurable f \u03bc", "start": [2116, 1], "end": [2119, 63], "kind": "commanddeclaration"}, {"full_name": "Measurable.ennreal_toReal", "code": "@[measurability]\ntheorem Measurable.ennreal_toReal {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    Measurable fun x => ENNReal.toReal (f x)", "start": [2122, 1], "end": [2125, 36], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.ennreal_toReal", "code": "@[measurability]\ntheorem AEMeasurable.ennreal_toReal {f : \u03b1 \u2192 \u211d\u22650\u221e} {\u03bc : Measure \u03b1} (hf : AEMeasurable f \u03bc) :\n    AEMeasurable (fun x => ENNReal.toReal (f x)) \u03bc", "start": [2128, 1], "end": [2131, 49], "kind": "commanddeclaration"}, {"full_name": "Measurable.ennreal_tsum", "code": "@[measurability]\ntheorem Measurable.ennreal_tsum {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200 i, Measurable (f i)) :\n    Measurable fun x => \u2211' i, f i x", "start": [2134, 1], "end": [2140, 49], "kind": "commanddeclaration"}, {"full_name": "Measurable.ennreal_tsum'", "code": "@[measurability]\ntheorem Measurable.ennreal_tsum' {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200 i, Measurable (f i)) :\n    Measurable (\u2211' i, f i)", "start": [2143, 1], "end": [2147, 61], "kind": "commanddeclaration"}, {"full_name": "Measurable.nnreal_tsum", "code": "@[measurability]\ntheorem Measurable.nnreal_tsum {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650} (h : \u2200 i, Measurable (f i)) :\n    Measurable fun x => \u2211' i, f i x", "start": [2150, 1], "end": [2154, 85], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.ennreal_tsum", "code": "@[measurability]\ntheorem AEMeasurable.ennreal_tsum {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} {\u03bc : Measure \u03b1}\n    (h : \u2200 i, AEMeasurable (f i) \u03bc) : AEMeasurable (fun x => \u2211' i, f i x) \u03bc", "start": [2157, 1], "end": [2162, 58], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.nnreal_tsum", "code": "@[measurability]\ntheorem AEMeasurable.nnreal_tsum {\u03b1 : Type*} [MeasurableSpace \u03b1] {\u03b9 : Type*} [Countable \u03b9]\n    {f : \u03b9 \u2192 \u03b1 \u2192 NNReal} {\u03bc : MeasureTheory.Measure \u03b1} (h : \u2200 i : \u03b9, AEMeasurable (f i) \u03bc) :\n    AEMeasurable (fun x : \u03b1 => \u2211' i : \u03b9, f i x) \u03bc", "start": [2165, 1], "end": [2170, 87], "kind": "commanddeclaration"}, {"full_name": "measurable_coe_real_ereal", "code": "@[measurability]\ntheorem measurable_coe_real_ereal : Measurable ((\u2191) : \u211d \u2192 EReal)", "start": [2173, 1], "end": [2175, 39], "kind": "commanddeclaration"}, {"full_name": "Measurable.coe_real_ereal", "code": "@[measurability]\ntheorem Measurable.coe_real_ereal {f : \u03b1 \u2192 \u211d} (hf : Measurable f) :\n    Measurable fun x => (f x : EReal)", "start": [2178, 1], "end": [2181, 36], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.coe_real_ereal", "code": "@[measurability]\ntheorem AEMeasurable.coe_real_ereal {f : \u03b1 \u2192 \u211d} {\u03bc : Measure \u03b1} (hf : AEMeasurable f \u03bc) :\n    AEMeasurable (fun x => (f x : EReal)) \u03bc", "start": [2184, 1], "end": [2187, 49], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.erealEquivReal", "code": "def MeasurableEquiv.erealEquivReal : ({\u22a5, \u22a4}\u1d9c : Set EReal) \u2243\u1d50 \u211d :=\n  EReal.neBotTopHomeomorphReal.toMeasurableEquiv", "start": [2190, 1], "end": [2192, 49], "kind": "commanddeclaration"}, {"full_name": "EReal.measurable_of_measurable_real", "code": "theorem EReal.measurable_of_measurable_real {f : EReal \u2192 \u03b1} (h : Measurable fun p : \u211d => f p) :\n    Measurable f", "start": [2195, 1], "end": [2198, 66], "kind": "commanddeclaration"}, {"full_name": "measurable_ereal_toReal", "code": "@[measurability]\ntheorem measurable_ereal_toReal : Measurable EReal.toReal", "start": [2201, 1], "end": [2203, 69], "kind": "commanddeclaration"}, {"full_name": "Measurable.ereal_toReal", "code": "@[measurability]\ntheorem Measurable.ereal_toReal {f : \u03b1 \u2192 EReal} (hf : Measurable f) :\n    Measurable fun x => (f x).toReal", "start": [2206, 1], "end": [2209, 34], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.ereal_toReal", "code": "@[measurability]\ntheorem AEMeasurable.ereal_toReal {f : \u03b1 \u2192 EReal} {\u03bc : Measure \u03b1} (hf : AEMeasurable f \u03bc) :\n    AEMeasurable (fun x => (f x).toReal) \u03bc", "start": [2212, 1], "end": [2215, 47], "kind": "commanddeclaration"}, {"full_name": "measurable_coe_ennreal_ereal", "code": "@[measurability]\ntheorem measurable_coe_ennreal_ereal : Measurable ((\u2191) : \u211d\u22650\u221e \u2192 EReal)", "start": [2218, 1], "end": [2220, 42], "kind": "commanddeclaration"}, {"full_name": "Measurable.coe_ereal_ennreal", "code": "@[measurability]\ntheorem Measurable.coe_ereal_ennreal {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    Measurable fun x => (f x : EReal)", "start": [2223, 1], "end": [2226, 39], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.coe_ereal_ennreal", "code": "@[measurability]\ntheorem AEMeasurable.coe_ereal_ennreal {f : \u03b1 \u2192 \u211d\u22650\u221e} {\u03bc : Measure \u03b1} (hf : AEMeasurable f \u03bc) :\n    AEMeasurable (fun x => (f x : EReal)) \u03bc", "start": [2229, 1], "end": [2232, 52], "kind": "commanddeclaration"}, {"full_name": "measurable_norm", "code": "@[measurability]\ntheorem measurable_norm : Measurable (norm : \u03b1 \u2192 \u211d)", "start": [2239, 1], "end": [2241, 29], "kind": "commanddeclaration"}, {"full_name": "Measurable.norm", "code": "@[measurability]\ntheorem Measurable.norm {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) : Measurable fun a => norm (f a)", "start": [2244, 1], "end": [2246, 26], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.norm", "code": "@[measurability]\ntheorem AEMeasurable.norm {f : \u03b2 \u2192 \u03b1} {\u03bc : Measure \u03b2} (hf : AEMeasurable f \u03bc) :\n    AEMeasurable (fun a => norm (f a)) \u03bc", "start": [2249, 1], "end": [2252, 39], "kind": "commanddeclaration"}, {"full_name": "measurable_nnnorm", "code": "@[measurability]\ntheorem measurable_nnnorm : Measurable (nnnorm : \u03b1 \u2192 \u211d\u22650)", "start": [2255, 1], "end": [2257, 31], "kind": "commanddeclaration"}, {"full_name": "Measurable.nnnorm", "code": "@[measurability]\ntheorem Measurable.nnnorm {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) : Measurable fun a => \u2016f a\u2016\u208a", "start": [2260, 1], "end": [2262, 28], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.nnnorm", "code": "@[measurability]\ntheorem AEMeasurable.nnnorm {f : \u03b2 \u2192 \u03b1} {\u03bc : Measure \u03b2} (hf : AEMeasurable f \u03bc) :\n    AEMeasurable (fun a => \u2016f a\u2016\u208a) \u03bc", "start": [2265, 1], "end": [2268, 41], "kind": "commanddeclaration"}, {"full_name": "measurable_ennnorm", "code": "@[measurability]\ntheorem measurable_ennnorm : Measurable fun x : \u03b1 => (\u2016x\u2016\u208a : \u211d\u22650\u221e)", "start": [2271, 1], "end": [2273, 39], "kind": "commanddeclaration"}, {"full_name": "Measurable.ennnorm", "code": "@[measurability]\ntheorem Measurable.ennnorm {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) : Measurable fun a => (\u2016f a\u2016\u208a : \u211d\u22650\u221e)", "start": [2276, 1], "end": [2278, 31], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.ennnorm", "code": "@[measurability]\ntheorem AEMeasurable.ennnorm {f : \u03b2 \u2192 \u03b1} {\u03bc : Measure \u03b2} (hf : AEMeasurable f \u03bc) :\n    AEMeasurable (fun a => (\u2016f a\u2016\u208a : \u211d\u22650\u221e)) \u03bc", "start": [2281, 1], "end": [2284, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/Dirac.lean", "imports": ["Mathlib/MeasureTheory/Measure/MutuallySingular.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.Measure.dirac", "code": "def dirac (a : \u03b1) : Measure \u03b1 := (OuterMeasure.dirac a).toMeasure (by simp)", "start": [27, 1], "end": [28, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_dirac_apply", "code": "theorem le_dirac_apply {a} : s.indicator 1 a \u2264 dirac a s", "start": [34, 1], "end": [35, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.dirac_apply'", "code": "@[simp]\ntheorem dirac_apply' (a : \u03b1) (hs : MeasurableSet s) : dirac a s = s.indicator 1 a", "start": [38, 1], "end": [40, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.dirac_apply_of_mem", "code": "@[simp]\ntheorem dirac_apply_of_mem {a : \u03b1} (h : a \u2208 s) : dirac a s = 1", "start": [43, 1], "end": [48, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.dirac_apply", "code": "@[simp]\ntheorem dirac_apply [MeasurableSingletonClass \u03b1] (a : \u03b1) (s : Set \u03b1) :\n    dirac a s = s.indicator 1 a", "start": [51, 1], "end": [58, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_dirac", "code": "theorem map_dirac {f : \u03b1 \u2192 \u03b2} (hf : Measurable f) (a : \u03b1) : (dirac a).map f = dirac (f a)", "start": [62, 1], "end": [63, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.restrict_singleton", "code": "@[simp]\ntheorem restrict_singleton (\u03bc : Measure \u03b1) (a : \u03b1) : \u03bc.restrict {a} = \u03bc {a} \u2022 dirac a", "start": [66, 1], "end": [73, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.map_eq_sum", "code": "theorem map_eq_sum [Countable \u03b2] [MeasurableSingletonClass \u03b2] (\u03bc : Measure \u03b1) (f : \u03b1 \u2192 \u03b2)\n    (hf : Measurable f) : \u03bc.map f = sum fun b : \u03b2 => \u03bc (f \u207b\u00b9' {b}) \u2022 dirac b", "start": [76, 1], "end": [82, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.sum_smul_dirac", "code": "@[simp]\ntheorem sum_smul_dirac [Countable \u03b1] [MeasurableSingletonClass \u03b1] (\u03bc : Measure \u03b1) :\n    (sum fun a => \u03bc {a} \u2022 dirac a) = \u03bc", "start": [85, 1], "end": [88, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.tsum_indicator_apply_singleton", "code": "theorem tsum_indicator_apply_singleton [Countable \u03b1] [MeasurableSingletonClass \u03b1] (\u03bc : Measure \u03b1)\n    (s : Set \u03b1) (hs : MeasurableSet s) : (\u2211' x : \u03b1, s.indicator (fun x => \u03bc {x}) x) = \u03bc s", "start": [91, 1], "end": [100, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem_ae_dirac_iff", "code": "theorem mem_ae_dirac_iff {a : \u03b1} (hs : MeasurableSet s) : s \u2208 (dirac a).ae \u2194 a \u2208 s", "start": [107, 1], "end": [108, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_dirac_iff", "code": "theorem ae_dirac_iff {a : \u03b1} {p : \u03b1 \u2192 Prop} (hp : MeasurableSet { x | p x }) :\n    (\u2200\u1d50 x \u2202dirac a, p x) \u2194 p a", "start": [111, 1], "end": [113, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_dirac_eq", "code": "@[simp]\ntheorem ae_dirac_eq [MeasurableSingletonClass \u03b1] (a : \u03b1) : (dirac a).ae = pure a", "start": [116, 1], "end": [119, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_dirac'", "code": "theorem ae_eq_dirac' [MeasurableSingletonClass \u03b2] {a : \u03b1} {f : \u03b1 \u2192 \u03b2} (hf : Measurable f) :\n    f =\u1d50[dirac a] const \u03b1 (f a)", "start": [122, 1], "end": [124, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_dirac", "code": "theorem ae_eq_dirac [MeasurableSingletonClass \u03b1] {a : \u03b1} (f : \u03b1 \u2192 \u03b4) :\n    f =\u1d50[dirac a] const \u03b1 (f a)", "start": [127, 1], "end": [128, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.dirac.isProbabilityMeasure", "code": "instance Measure.dirac.isProbabilityMeasure [MeasurableSpace \u03b1] {x : \u03b1} :\n    IsProbabilityMeasure (dirac x) :=\n  \u27e8dirac_apply_of_mem <| mem_univ x\u27e9", "start": [131, 1], "end": [133, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.restrict_dirac'", "code": "theorem restrict_dirac' (hs : MeasurableSet s) [Decidable (a \u2208 s)] :\n    (Measure.dirac a).restrict s = if a \u2208 s then Measure.dirac a else 0", "start": [136, 1], "end": [141, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.restrict_dirac", "code": "theorem restrict_dirac [MeasurableSingletonClass \u03b1] [Decidable (a \u2208 s)] :\n    (Measure.dirac a).restrict s = if a \u2208 s then Measure.dirac a else 0", "start": [144, 1], "end": [149, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mutuallySingular_dirac", "code": "lemma mutuallySingular_dirac [MeasurableSingletonClass \u03b1] (x : \u03b1) (\u03bc : Measure \u03b1) [NoAtoms \u03bc] :\n    Measure.dirac x \u27c2\u2098 \u03bc :=\n  \u27e8{x}\u1d9c, (MeasurableSet.singleton x).compl, by simp, by simp\u27e9", "start": [152, 1], "end": [154, 62], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Analysis/NormedSpace/AddTorsor.lean", "imports": ["Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "Mathlib/Topology/Instances/RealVectorSpace.lean", "Mathlib/LinearAlgebra/AffineSpace/MidpointZero.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/NormedSpace/Basic.lean", "Mathlib/Analysis/Normed/Group/AddTorsor.lean"], "premises": [{"full_name": "AffineSubspace.isClosed_direction_iff", "code": "theorem AffineSubspace.isClosed_direction_iff (s : AffineSubspace \ud835\udd5c Q) :\n    IsClosed (s.direction : Set W) \u2194 IsClosed (s : Set Q)", "start": [36, 1], "end": [41, 6], "kind": "commanddeclaration"}, {"full_name": "dist_center_homothety", "code": "@[simp]\ntheorem dist_center_homothety (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    dist p\u2081 (homothety p\u2081 c p\u2082) = \u2016c\u2016 * dist p\u2081 p\u2082", "start": [44, 1], "end": [49, 53], "kind": "commanddeclaration"}, {"full_name": "nndist_center_homothety", "code": "@[simp]\ntheorem nndist_center_homothety (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    nndist p\u2081 (homothety p\u2081 c p\u2082) = \u2016c\u2016\u208a * nndist p\u2081 p\u2082", "start": [52, 1], "end": [55, 43], "kind": "commanddeclaration"}, {"full_name": "dist_homothety_center", "code": "@[simp]\ntheorem dist_homothety_center (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    dist (homothety p\u2081 c p\u2082) p\u2081 = \u2016c\u2016 * dist p\u2081 p\u2082", "start": [58, 1], "end": [60, 95], "kind": "commanddeclaration"}, {"full_name": "nndist_homothety_center", "code": "@[simp]\ntheorem nndist_homothety_center (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    nndist (homothety p\u2081 c p\u2082) p\u2081 = \u2016c\u2016\u208a * nndist p\u2081 p\u2082", "start": [63, 1], "end": [66, 43], "kind": "commanddeclaration"}, {"full_name": "dist_lineMap_lineMap", "code": "@[simp]\ntheorem dist_lineMap_lineMap (p\u2081 p\u2082 : P) (c\u2081 c\u2082 : \ud835\udd5c) :\n    dist (lineMap p\u2081 p\u2082 c\u2081) (lineMap p\u2081 p\u2082 c\u2082) = dist c\u2081 c\u2082 * dist p\u2081 p\u2082", "start": [69, 1], "end": [76, 88], "kind": "commanddeclaration"}, {"full_name": "nndist_lineMap_lineMap", "code": "@[simp]\ntheorem nndist_lineMap_lineMap (p\u2081 p\u2082 : P) (c\u2081 c\u2082 : \ud835\udd5c) :\n    nndist (lineMap p\u2081 p\u2082 c\u2081) (lineMap p\u2081 p\u2082 c\u2082) = nndist c\u2081 c\u2082 * nndist p\u2081 p\u2082", "start": [79, 1], "end": [82, 44], "kind": "commanddeclaration"}, {"full_name": "lipschitzWith_lineMap", "code": "theorem lipschitzWith_lineMap (p\u2081 p\u2082 : P) : LipschitzWith (nndist p\u2081 p\u2082) (lineMap p\u2081 p\u2082 : \ud835\udd5c \u2192 P)", "start": [85, 1], "end": [87, 65], "kind": "commanddeclaration"}, {"full_name": "dist_lineMap_left", "code": "@[simp]\ntheorem dist_lineMap_left (p\u2081 p\u2082 : P) (c : \ud835\udd5c) : dist (lineMap p\u2081 p\u2082 c) p\u2081 = \u2016c\u2016 * dist p\u2081 p\u2082", "start": [90, 1], "end": [94, 69], "kind": "commanddeclaration"}, {"full_name": "nndist_lineMap_left", "code": "@[simp]\ntheorem nndist_lineMap_left (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    nndist (lineMap p\u2081 p\u2082 c) p\u2081 = \u2016c\u2016\u208a * nndist p\u2081 p\u2082", "start": [97, 1], "end": [100, 39], "kind": "commanddeclaration"}, {"full_name": "dist_left_lineMap", "code": "@[simp]\ntheorem dist_left_lineMap (p\u2081 p\u2082 : P) (c : \ud835\udd5c) : dist p\u2081 (lineMap p\u2081 p\u2082 c) = \u2016c\u2016 * dist p\u2081 p\u2082", "start": [103, 1], "end": [105, 50], "kind": "commanddeclaration"}, {"full_name": "nndist_left_lineMap", "code": "@[simp]\ntheorem nndist_left_lineMap (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    nndist p\u2081 (lineMap p\u2081 p\u2082 c) = \u2016c\u2016\u208a * nndist p\u2081 p\u2082", "start": [108, 1], "end": [111, 39], "kind": "commanddeclaration"}, {"full_name": "dist_lineMap_right", "code": "@[simp]\ntheorem dist_lineMap_right (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    dist (lineMap p\u2081 p\u2082 c) p\u2082 = \u20161 - c\u2016 * dist p\u2081 p\u2082", "start": [114, 1], "end": [119, 66], "kind": "commanddeclaration"}, {"full_name": "nndist_lineMap_right", "code": "@[simp]\ntheorem nndist_lineMap_right (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    nndist (lineMap p\u2081 p\u2082 c) p\u2082 = \u20161 - c\u2016\u208a * nndist p\u2081 p\u2082", "start": [122, 1], "end": [125, 40], "kind": "commanddeclaration"}, {"full_name": "dist_right_lineMap", "code": "@[simp]\ntheorem dist_right_lineMap (p\u2081 p\u2082 : P) (c : \ud835\udd5c) : dist p\u2082 (lineMap p\u2081 p\u2082 c) = \u20161 - c\u2016 * dist p\u2081 p\u2082", "start": [128, 1], "end": [130, 51], "kind": "commanddeclaration"}, {"full_name": "nndist_right_lineMap", "code": "@[simp]\ntheorem nndist_right_lineMap (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    nndist p\u2082 (lineMap p\u2081 p\u2082 c) = \u20161 - c\u2016\u208a * nndist p\u2081 p\u2082", "start": [133, 1], "end": [136, 40], "kind": "commanddeclaration"}, {"full_name": "dist_homothety_self", "code": "@[simp]\ntheorem dist_homothety_self (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    dist (homothety p\u2081 c p\u2082) p\u2082 = \u20161 - c\u2016 * dist p\u2081 p\u2082", "start": [139, 1], "end": [142, 48], "kind": "commanddeclaration"}, {"full_name": "nndist_homothety_self", "code": "@[simp]\ntheorem nndist_homothety_self (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    nndist (homothety p\u2081 c p\u2082) p\u2082 = \u20161 - c\u2016\u208a * nndist p\u2081 p\u2082", "start": [145, 1], "end": [148, 41], "kind": "commanddeclaration"}, {"full_name": "dist_self_homothety", "code": "@[simp]\ntheorem dist_self_homothety (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    dist p\u2082 (homothety p\u2081 c p\u2082) = \u20161 - c\u2016 * dist p\u2081 p\u2082", "start": [151, 1], "end": [153, 97], "kind": "commanddeclaration"}, {"full_name": "nndist_self_homothety", "code": "@[simp]\ntheorem nndist_self_homothety (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    nndist p\u2082 (homothety p\u2081 c p\u2082) = \u20161 - c\u2016\u208a * nndist p\u2081 p\u2082", "start": [156, 1], "end": [159, 41], "kind": "commanddeclaration"}, {"full_name": "dist_left_midpoint", "code": "@[simp]\ntheorem dist_left_midpoint (p\u2081 p\u2082 : P) : dist p\u2081 (midpoint \ud835\udd5c p\u2081 p\u2082) = \u2016(2 : \ud835\udd5c)\u2016\u207b\u00b9 * dist p\u2081 p\u2082", "start": [166, 1], "end": [168, 72], "kind": "commanddeclaration"}, {"full_name": "nndist_left_midpoint", "code": "@[simp]\ntheorem nndist_left_midpoint (p\u2081 p\u2082 : P) :\n    nndist p\u2081 (midpoint \ud835\udd5c p\u2081 p\u2082) = \u2016(2 : \ud835\udd5c)\u2016\u208a\u207b\u00b9 * nndist p\u2081 p\u2082", "start": [171, 1], "end": [174, 38], "kind": "commanddeclaration"}, {"full_name": "dist_midpoint_left", "code": "@[simp]\ntheorem dist_midpoint_left (p\u2081 p\u2082 : P) : dist (midpoint \ud835\udd5c p\u2081 p\u2082) p\u2081 = \u2016(2 : \ud835\udd5c)\u2016\u207b\u00b9 * dist p\u2081 p\u2082", "start": [177, 1], "end": [179, 37], "kind": "commanddeclaration"}, {"full_name": "nndist_midpoint_left", "code": "@[simp]\ntheorem nndist_midpoint_left (p\u2081 p\u2082 : P) :\n    nndist (midpoint \ud835\udd5c p\u2081 p\u2082) p\u2081 = \u2016(2 : \ud835\udd5c)\u2016\u208a\u207b\u00b9 * nndist p\u2081 p\u2082", "start": [182, 1], "end": [185, 38], "kind": "commanddeclaration"}, {"full_name": "dist_midpoint_right", "code": "@[simp]\ntheorem dist_midpoint_right (p\u2081 p\u2082 : P) :\n    dist (midpoint \ud835\udd5c p\u2081 p\u2082) p\u2082 = \u2016(2 : \ud835\udd5c)\u2016\u207b\u00b9 * dist p\u2081 p\u2082", "start": [188, 1], "end": [191, 52], "kind": "commanddeclaration"}, {"full_name": "nndist_midpoint_right", "code": "@[simp]\ntheorem nndist_midpoint_right (p\u2081 p\u2082 : P) :\n    nndist (midpoint \ud835\udd5c p\u2081 p\u2082) p\u2082 = \u2016(2 : \ud835\udd5c)\u2016\u208a\u207b\u00b9 * nndist p\u2081 p\u2082", "start": [194, 1], "end": [197, 39], "kind": "commanddeclaration"}, {"full_name": "dist_right_midpoint", "code": "@[simp]\ntheorem dist_right_midpoint (p\u2081 p\u2082 : P) :\n    dist p\u2082 (midpoint \ud835\udd5c p\u2081 p\u2082) = \u2016(2 : \ud835\udd5c)\u2016\u207b\u00b9 * dist p\u2081 p\u2082", "start": [200, 1], "end": [203, 38], "kind": "commanddeclaration"}, {"full_name": "nndist_right_midpoint", "code": "@[simp]\ntheorem nndist_right_midpoint (p\u2081 p\u2082 : P) :\n    nndist p\u2082 (midpoint \ud835\udd5c p\u2081 p\u2082) = \u2016(2 : \ud835\udd5c)\u2016\u208a\u207b\u00b9 * nndist p\u2081 p\u2082", "start": [206, 1], "end": [209, 39], "kind": "commanddeclaration"}, {"full_name": "dist_midpoint_midpoint_le'", "code": "theorem dist_midpoint_midpoint_le' (p\u2081 p\u2082 p\u2083 p\u2084 : P) :\n    dist (midpoint \ud835\udd5c p\u2081 p\u2082) (midpoint \ud835\udd5c p\u2083 p\u2084) \u2264 (dist p\u2081 p\u2083 + dist p\u2082 p\u2084) / \u2016(2 : \ud835\udd5c)\u2016", "start": [212, 1], "end": [217, 69], "kind": "commanddeclaration"}, {"full_name": "nndist_midpoint_midpoint_le'", "code": "theorem nndist_midpoint_midpoint_le' (p\u2081 p\u2082 p\u2083 p\u2084 : P) :\n    nndist (midpoint \ud835\udd5c p\u2081 p\u2082) (midpoint \ud835\udd5c p\u2083 p\u2084) \u2264 (nndist p\u2081 p\u2083 + nndist p\u2082 p\u2084) / \u2016(2 : \ud835\udd5c)\u2016\u208a", "start": [220, 1], "end": [222, 37], "kind": "commanddeclaration"}, {"full_name": "dist_pointReflection_left", "code": "@[simp] theorem dist_pointReflection_left (p q : P) :\n    dist (Equiv.pointReflection p q) p = dist p q", "start": [227, 1], "end": [229, 71], "kind": "commanddeclaration"}, {"full_name": "dist_left_pointReflection", "code": "@[simp] theorem dist_left_pointReflection (p q : P) :\n    dist p (Equiv.pointReflection p q) = dist p q", "start": [231, 1], "end": [233, 56], "kind": "commanddeclaration"}, {"full_name": "dist_pointReflection_right", "code": "@[simp] theorem dist_pointReflection_right (p q : P) :\n    dist (Equiv.pointReflection p q) q = \u2016(2 : \ud835\udd5c)\u2016 * dist p q", "start": [235, 1], "end": [238, 37], "kind": "commanddeclaration"}, {"full_name": "dist_right_pointReflection", "code": "@[simp] theorem dist_right_pointReflection (p q : P) :\n    dist q (Equiv.pointReflection p q) = \u2016(2 : \ud835\udd5c)\u2016 * dist p q", "start": [240, 1], "end": [242, 57], "kind": "commanddeclaration"}, {"full_name": "antilipschitzWith_lineMap", "code": "theorem antilipschitzWith_lineMap {p\u2081 p\u2082 : Q} (h : p\u2081 \u2260 p\u2082) :\n    AntilipschitzWith (nndist p\u2081 p\u2082)\u207b\u00b9 (lineMap p\u2081 p\u2082 : \ud835\udd5c \u2192 Q)", "start": [244, 1], "end": [248, 50], "kind": "commanddeclaration"}, {"full_name": "eventually_homothety_mem_of_mem_interior", "code": "theorem eventually_homothety_mem_of_mem_interior (x : Q) {s : Set Q} {y : Q} (hy : y \u2208 interior s) :\n    \u2200\u1da0 \u03b4 in \ud835\udcdd (1 : \ud835\udd5c), homothety x \u03b4 y \u2208 s", "start": [253, 1], "end": [264, 85], "kind": "commanddeclaration"}, {"full_name": "eventually_homothety_image_subset_of_finite_subset_interior", "code": "theorem eventually_homothety_image_subset_of_finite_subset_interior (x : Q) {s : Set Q} {t : Set Q}\n    (ht : t.Finite) (h : t \u2286 interior s) : \u2200\u1da0 \u03b4 in \ud835\udcdd (1 : \ud835\udd5c), homothety x \u03b4 '' t \u2286 s", "start": [267, 1], "end": [273, 60], "kind": "commanddeclaration"}, {"full_name": "dist_midpoint_midpoint_le", "code": "theorem dist_midpoint_midpoint_le (p\u2081 p\u2082 p\u2083 p\u2084 : V) :\n    dist (midpoint \u211d p\u2081 p\u2082) (midpoint \u211d p\u2083 p\u2084) \u2264 (dist p\u2081 p\u2083 + dist p\u2082 p\u2084) / 2", "start": [280, 1], "end": [285, 13], "kind": "commanddeclaration"}, {"full_name": "nndist_midpoint_midpoint_le", "code": "theorem nndist_midpoint_midpoint_le (p\u2081 p\u2082 p\u2083 p\u2084 : V) :\n    nndist (midpoint \u211d p\u2081 p\u2082) (midpoint \u211d p\u2083 p\u2084) \u2264 (nndist p\u2081 p\u2083 + nndist p\u2082 p\u2084) / 2", "start": [288, 1], "end": [290, 36], "kind": "commanddeclaration"}, {"full_name": "AffineMap.ofMapMidpoint", "code": "def AffineMap.ofMapMidpoint (f : P \u2192 Q) (h : \u2200 x y, f (midpoint \u211d x y) = midpoint \u211d (f x) (f y))\n    (hfc : Continuous f) : P \u2192\u1d43[\u211d] Q :=\n  let c := Classical.arbitrary P\n  AffineMap.mk' f (\u2191((AddMonoidHom.ofMapMidpoint \u211d \u211d\n    ((AffineEquiv.vaddConst \u211d (f <| c)).symm \u2218 f \u2218 AffineEquiv.vaddConst \u211d c) (by simp)\n    fun x y => by simp only [Function.comp_apply, AffineEquiv.vaddConst_apply, AffineEquiv.vaddConst_symm_apply]\n      conv_lhs => rw [(midpoint_self \u211d (Classical.arbitrary P)).symm, midpoint_vadd_midpoint, h, h,\n          midpoint_vsub_midpoint]).toRealLinearMap <| by\n        apply_rules [Continuous.vadd, Continuous.vsub, continuous_const, hfc.comp, continuous_id]))\n    c fun p => by simp", "start": [293, 1], "end": [305, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/AffineSpace/Ordered.lean", "imports": ["Mathlib/Algebra/Order/Module.lean", "Mathlib/LinearAlgebra/AffineSpace/MidpointZero.lean", "Mathlib/Tactic/FieldSimp.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/AffineSpace/Slope.lean", "Mathlib/Algebra/Order/Invertible.lean"], "premises": [{"full_name": "lineMap_mono_left", "code": "theorem lineMap_mono_left (ha : a \u2264 a') (hr : r \u2264 1) : lineMap a b r \u2264 lineMap a' b r", "start": [51, 1], "end": [53, 73], "kind": "commanddeclaration"}, {"full_name": "lineMap_strict_mono_left", "code": "theorem lineMap_strict_mono_left (ha : a < a') (hr : r < 1) : lineMap a b r < lineMap a' b r", "start": [56, 1], "end": [58, 67], "kind": "commanddeclaration"}, {"full_name": "lineMap_mono_right", "code": "theorem lineMap_mono_right (hb : b \u2264 b') (hr : 0 \u2264 r) : lineMap a b r \u2264 lineMap a b' r", "start": [61, 1], "end": [63, 57], "kind": "commanddeclaration"}, {"full_name": "lineMap_strict_mono_right", "code": "theorem lineMap_strict_mono_right (hb : b < b') (hr : 0 < r) : lineMap a b r < lineMap a b' r", "start": [66, 1], "end": [68, 54], "kind": "commanddeclaration"}, {"full_name": "lineMap_mono_endpoints", "code": "theorem lineMap_mono_endpoints (ha : a \u2264 a') (hb : b \u2264 b') (h\u2080 : 0 \u2264 r) (h\u2081 : r \u2264 1) :\n    lineMap a b r \u2264 lineMap a' b' r", "start": [71, 1], "end": [73, 61], "kind": "commanddeclaration"}, {"full_name": "lineMap_strict_mono_endpoints", "code": "theorem lineMap_strict_mono_endpoints (ha : a < a') (hb : b < b') (h\u2080 : 0 \u2264 r) (h\u2081 : r \u2264 1) :\n    lineMap a b r < lineMap a' b' r", "start": [76, 1], "end": [79, 80], "kind": "commanddeclaration"}, {"full_name": "lineMap_lt_lineMap_iff_of_lt", "code": "theorem lineMap_lt_lineMap_iff_of_lt (h : r < r') : lineMap a b r < lineMap a b r' \u2194 a < b", "start": [82, 1], "end": [85, 68], "kind": "commanddeclaration"}, {"full_name": "left_lt_lineMap_iff_lt", "code": "theorem left_lt_lineMap_iff_lt (h : 0 < r) : a < lineMap a b r \u2194 a < b", "start": [88, 1], "end": [89, 74], "kind": "commanddeclaration"}, {"full_name": "lineMap_lt_left_iff_lt", "code": "theorem lineMap_lt_left_iff_lt (h : 0 < r) : lineMap a b r < a \u2194 b < a", "start": [92, 1], "end": [93, 48], "kind": "commanddeclaration"}, {"full_name": "lineMap_lt_right_iff_lt", "code": "theorem lineMap_lt_right_iff_lt (h : r < 1) : lineMap a b r < b \u2194 a < b", "start": [96, 1], "end": [97, 73], "kind": "commanddeclaration"}, {"full_name": "right_lt_lineMap_iff_lt", "code": "theorem right_lt_lineMap_iff_lt (h : r < 1) : b < lineMap a b r \u2194 b < a", "start": [100, 1], "end": [101, 49], "kind": "commanddeclaration"}, {"full_name": "midpoint_le_midpoint", "code": "theorem midpoint_le_midpoint (ha : a \u2264 a') (hb : b \u2264 b') : midpoint k a b \u2264 midpoint k a' b'", "start": [111, 1], "end": [112, 87], "kind": "commanddeclaration"}, {"full_name": "lineMap_le_lineMap_iff_of_lt", "code": "theorem lineMap_le_lineMap_iff_of_lt (h : r < r') : lineMap a b r \u2264 lineMap a b r' \u2194 a \u2264 b", "start": [127, 1], "end": [130, 68], "kind": "commanddeclaration"}, {"full_name": "left_le_lineMap_iff_le", "code": "theorem left_le_lineMap_iff_le (h : 0 < r) : a \u2264 lineMap a b r \u2194 a \u2264 b", "start": [133, 1], "end": [134, 74], "kind": "commanddeclaration"}, {"full_name": "left_le_midpoint", "code": "@[simp]\ntheorem left_le_midpoint : a \u2264 midpoint k a b \u2194 a \u2264 b", "start": [137, 1], "end": [139, 50], "kind": "commanddeclaration"}, {"full_name": "lineMap_le_left_iff_le", "code": "theorem lineMap_le_left_iff_le (h : 0 < r) : lineMap a b r \u2264 a \u2194 b \u2264 a", "start": [142, 1], "end": [143, 48], "kind": "commanddeclaration"}, {"full_name": "midpoint_le_left", "code": "@[simp]\ntheorem midpoint_le_left : midpoint k a b \u2264 a \u2194 b \u2264 a", "start": [146, 1], "end": [148, 50], "kind": "commanddeclaration"}, {"full_name": "lineMap_le_right_iff_le", "code": "theorem lineMap_le_right_iff_le (h : r < 1) : lineMap a b r \u2264 b \u2194 a \u2264 b", "start": [151, 1], "end": [152, 73], "kind": "commanddeclaration"}, {"full_name": "midpoint_le_right", "code": "@[simp]\ntheorem midpoint_le_right : midpoint k a b \u2264 b \u2194 a \u2264 b", "start": [155, 1], "end": [157, 51], "kind": "commanddeclaration"}, {"full_name": "right_le_lineMap_iff_le", "code": "theorem right_le_lineMap_iff_le (h : r < 1) : b \u2264 lineMap a b r \u2194 b \u2264 a", "start": [160, 1], "end": [161, 49], "kind": "commanddeclaration"}, {"full_name": "right_le_midpoint", "code": "@[simp]\ntheorem right_le_midpoint : b \u2264 midpoint k a b \u2194 b \u2264 a", "start": [164, 1], "end": [166, 51], "kind": "commanddeclaration"}, {"full_name": "map_le_lineMap_iff_slope_le_slope_left", "code": "theorem map_le_lineMap_iff_slope_le_slope_left (h : 0 < r * (b - a)) :\n    f c \u2264 lineMap (f a) (f b) r \u2194 slope f a c \u2264 slope f a b", "start": [205, 1], "end": [214, 48], "kind": "commanddeclaration"}, {"full_name": "lineMap_le_map_iff_slope_le_slope_left", "code": "theorem lineMap_le_map_iff_slope_le_slope_left (h : 0 < r * (b - a)) :\n    lineMap (f a) (f b) r \u2264 f c \u2194 slope f a b \u2264 slope f a c", "start": [217, 1], "end": [221, 66], "kind": "commanddeclaration"}, {"full_name": "map_lt_lineMap_iff_slope_lt_slope_left", "code": "theorem map_lt_lineMap_iff_slope_lt_slope_left (h : 0 < r * (b - a)) :\n    f c < lineMap (f a) (f b) r \u2194 slope f a c < slope f a b", "start": [224, 1], "end": [229, 47], "kind": "commanddeclaration"}, {"full_name": "lineMap_lt_map_iff_slope_lt_slope_left", "code": "theorem lineMap_lt_map_iff_slope_lt_slope_left (h : 0 < r * (b - a)) :\n    lineMap (f a) (f b) r < f c \u2194 slope f a b < slope f a c", "start": [232, 1], "end": [236, 66], "kind": "commanddeclaration"}, {"full_name": "map_le_lineMap_iff_slope_le_slope_right", "code": "theorem map_le_lineMap_iff_slope_le_slope_right (h : 0 < (1 - r) * (b - a)) :\n    f c \u2264 lineMap (f a) (f b) r \u2194 slope f a b \u2264 slope f c b", "start": [239, 1], "end": [248, 37], "kind": "commanddeclaration"}, {"full_name": "lineMap_le_map_iff_slope_le_slope_right", "code": "theorem lineMap_le_map_iff_slope_le_slope_right (h : 0 < (1 - r) * (b - a)) :\n    lineMap (f a) (f b) r \u2264 f c \u2194 slope f c b \u2264 slope f a b", "start": [251, 1], "end": [255, 67], "kind": "commanddeclaration"}, {"full_name": "map_lt_lineMap_iff_slope_lt_slope_right", "code": "theorem map_lt_lineMap_iff_slope_lt_slope_right (h : 0 < (1 - r) * (b - a)) :\n    f c < lineMap (f a) (f b) r \u2194 slope f a b < slope f c b", "start": [258, 1], "end": [263, 48], "kind": "commanddeclaration"}, {"full_name": "lineMap_lt_map_iff_slope_lt_slope_right", "code": "theorem lineMap_lt_map_iff_slope_lt_slope_right (h : 0 < (1 - r) * (b - a)) :\n    lineMap (f a) (f b) r < f c \u2194 slope f c b < slope f a b", "start": [266, 1], "end": [270, 67], "kind": "commanddeclaration"}, {"full_name": "map_le_lineMap_iff_slope_le_slope", "code": "theorem map_le_lineMap_iff_slope_le_slope (hab : a < b) (h\u2080 : 0 < r) (h\u2081 : r < 1) :\n    f c \u2264 lineMap (f a) (f b) r \u2194 slope f a c \u2264 slope f c b", "start": [273, 1], "end": [278, 77], "kind": "commanddeclaration"}, {"full_name": "lineMap_le_map_iff_slope_le_slope", "code": "theorem lineMap_le_map_iff_slope_le_slope (hab : a < b) (h\u2080 : 0 < r) (h\u2081 : r < 1) :\n    lineMap (f a) (f b) r \u2264 f c \u2194 slope f c b \u2264 slope f a c", "start": [281, 1], "end": [285, 69], "kind": "commanddeclaration"}, {"full_name": "map_lt_lineMap_iff_slope_lt_slope", "code": "theorem map_lt_lineMap_iff_slope_lt_slope (hab : a < b) (h\u2080 : 0 < r) (h\u2081 : r < 1) :\n    f c < lineMap (f a) (f b) r \u2194 slope f a c < slope f c b", "start": [288, 1], "end": [293, 50], "kind": "commanddeclaration"}, {"full_name": "lineMap_lt_map_iff_slope_lt_slope", "code": "theorem lineMap_lt_map_iff_slope_lt_slope (hab : a < b) (h\u2080 : 0 < r) (h\u2081 : r < 1) :\n    lineMap (f a) (f b) r < f c \u2194 slope f c b < slope f a c", "start": [296, 1], "end": [300, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/ContinuousFunction/Algebra.lean", "imports": ["Mathlib/Algebra/Star/StarAlgHom.lean", "Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/Topology/ContinuousFunction/Ordered.lean", "Mathlib/Topology/Algebra/Star.lean", "Mathlib/Topology/Algebra/UniformGroup.lean", "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "Mathlib/Tactic/FieldSimp.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/UniformSpace/CompactConvergence.lean", "Mathlib/Algebra/Periodic.lean", "Mathlib/Algebra/Algebra/Pi.lean", "Mathlib/Topology/Algebra/Ring/Basic.lean", "Mathlib/Algebra/Order/LatticeGroup.lean", "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean"], "premises": [{"full_name": "ContinuousMap.instMul", "code": "@[to_additive]\ninstance instMul [Mul \u03b2] [ContinuousMul \u03b2] : Mul C(\u03b1, \u03b2) :=\n  \u27e8fun f g => \u27e8f * g, continuous_mul.comp (f.continuous.prod_mk g.continuous : _)\u27e9\u27e9", "start": [59, 1], "end": [61, 84], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_mul", "code": "@[to_additive (attr := norm_cast, simp)]\ntheorem coe_mul [Mul \u03b2] [ContinuousMul \u03b2] (f g : C(\u03b1, \u03b2)) : \u21d1(f * g) = f * g", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.mul_apply", "code": "@[to_additive (attr := simp)]\ntheorem mul_apply [Mul \u03b2] [ContinuousMul \u03b2] (f g : C(\u03b1, \u03b2)) (x : \u03b1) : (f * g) x = f x * g x", "start": [71, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.mul_comp", "code": "@[to_additive (attr := simp)]\ntheorem mul_comp [Mul \u03b3] [ContinuousMul \u03b3] (f\u2081 f\u2082 : C(\u03b2, \u03b3)) (g : C(\u03b1, \u03b2)) :\n    (f\u2081 * f\u2082).comp g = f\u2081.comp g * f\u2082.comp g", "start": [77, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_one", "code": "@[to_additive (attr := norm_cast, simp)]\ntheorem coe_one [One \u03b2] : \u21d1(1 : C(\u03b1, \u03b2)) = 1", "start": [89, 1], "end": [91, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.one_apply", "code": "@[to_additive (attr := simp)]\ntheorem one_apply [One \u03b2] (x : \u03b1) : (1 : C(\u03b1, \u03b2)) x = 1", "start": [95, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.one_comp", "code": "@[to_additive (attr := simp)]\ntheorem one_comp [One \u03b3] (g : C(\u03b1, \u03b2)) : (1 : C(\u03b2, \u03b3)).comp g = 1", "start": [101, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_nat_cast", "code": "@[simp, norm_cast]\ntheorem coe_nat_cast [NatCast \u03b2] (n : \u2115) : ((n : C(\u03b1, \u03b2)) : \u03b1 \u2192 \u03b2) = n", "start": [111, 1], "end": [113, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.nat_cast_apply", "code": "@[simp]\ntheorem nat_cast_apply [NatCast \u03b2] (n : \u2115) (x : \u03b1) : (n : C(\u03b1, \u03b2)) x = n", "start": [116, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_int_cast", "code": "@[simp, norm_cast]\ntheorem coe_int_cast [IntCast \u03b2] (n : \u2124) : ((n : C(\u03b1, \u03b2)) : \u03b1 \u2192 \u03b2) = n", "start": [125, 1], "end": [127, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.int_cast_apply", "code": "@[simp]\ntheorem int_cast_apply [IntCast \u03b2] (n : \u2124) (x : \u03b1) : (n : C(\u03b1, \u03b2)) x = n", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.instNSMul", "code": "instance instNSMul [AddMonoid \u03b2] [ContinuousAdd \u03b2] : SMul \u2115 C(\u03b1, \u03b2) :=\n  \u27e8fun n f => \u27e8n \u2022 \u21d1f, f.continuous.nsmul n\u27e9\u27e9", "start": [136, 1], "end": [137, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.instPow", "code": "@[to_additive existing]\ninstance instPow [Monoid \u03b2] [ContinuousMul \u03b2] : Pow C(\u03b1, \u03b2) \u2115 :=\n  \u27e8fun f n => \u27e8(\u21d1f) ^ n, f.continuous.pow n\u27e9\u27e9", "start": [140, 1], "end": [142, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_pow", "code": "@[to_additive (attr := norm_cast)]\ntheorem coe_pow [Monoid \u03b2] [ContinuousMul \u03b2] (f : C(\u03b1, \u03b2)) (n : \u2115) : \u21d1(f ^ n) = (\u21d1f) ^ n", "start": [145, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.pow_apply", "code": "@[to_additive (attr := norm_cast)]\ntheorem pow_apply [Monoid \u03b2] [ContinuousMul \u03b2] (f : C(\u03b1, \u03b2)) (n : \u2115) (x : \u03b1) :\n    (f ^ n) x = f x ^ n", "start": [151, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.pow_comp", "code": "@[to_additive]\ntheorem pow_comp [Monoid \u03b3] [ContinuousMul \u03b3] (f : C(\u03b2, \u03b3)) (n : \u2115) (g : C(\u03b1, \u03b2)) :\n    (f ^ n).comp g = f.comp g ^ n", "start": [162, 1], "end": [165, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_inv", "code": "@[to_additive (attr := simp)]\ntheorem coe_inv [Group \u03b2] [TopologicalGroup \u03b2] (f : C(\u03b1, \u03b2)) : \u21d1f\u207b\u00b9 = (\u21d1f)\u207b\u00b9", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.inv_apply", "code": "@[to_additive (attr := simp)]\ntheorem inv_apply [Group \u03b2] [TopologicalGroup \u03b2] (f : C(\u03b1, \u03b2)) (x : \u03b1) : f\u207b\u00b9 x = (f x)\u207b\u00b9", "start": [182, 1], "end": [184, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.inv_comp", "code": "@[to_additive (attr := simp)]\ntheorem inv_comp [Group \u03b3] [TopologicalGroup \u03b3] (f : C(\u03b2, \u03b3)) (g : C(\u03b1, \u03b2)) :\n    f\u207b\u00b9.comp g = (f.comp g)\u207b\u00b9", "start": [188, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_div", "code": "@[to_additive (attr := norm_cast, simp)]\ntheorem coe_div [Div \u03b2] [ContinuousDiv \u03b2] (f g : C(\u03b1, \u03b2)) : \u21d1(f / g) = f / g", "start": [200, 1], "end": [202, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.div_apply", "code": "@[to_additive (attr := simp)]\ntheorem div_apply [Div \u03b2] [ContinuousDiv \u03b2] (f g : C(\u03b1, \u03b2)) (x : \u03b1) : (f / g) x = f x / g x", "start": [206, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.div_comp", "code": "@[to_additive (attr := simp)]\ntheorem div_comp [Div \u03b3] [ContinuousDiv \u03b3] (f g : C(\u03b2, \u03b3)) (h : C(\u03b1, \u03b2)) :\n    (f / g).comp h = f.comp h / g.comp h", "start": [212, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.instZSMul", "code": "instance instZSMul [AddGroup \u03b2] [TopologicalAddGroup \u03b2] : SMul \u2124 C(\u03b1, \u03b2) where\n  smul z f := \u27e8z \u2022 \u21d1f, f.continuous.zsmul z\u27e9", "start": [220, 1], "end": [221, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.instZPow", "code": "@[to_additive existing]\ninstance instZPow [Group \u03b2] [TopologicalGroup \u03b2] : Pow C(\u03b1, \u03b2) \u2124 where\n  pow f z := \u27e8(\u21d1f) ^ z, f.continuous.zpow z\u27e9", "start": [224, 1], "end": [226, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_zpow", "code": "@[to_additive (attr := norm_cast)]\ntheorem coe_zpow [Group \u03b2] [TopologicalGroup \u03b2] (f : C(\u03b1, \u03b2)) (z : \u2124) : \u21d1(f ^ z) = (\u21d1f) ^ z", "start": [229, 1], "end": [231, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.zpow_apply", "code": "@[to_additive]\ntheorem zpow_apply [Group \u03b2] [TopologicalGroup \u03b2] (f : C(\u03b1, \u03b2)) (z : \u2124) (x : \u03b1) :\n    (f ^ z) x = f x ^ z", "start": [235, 1], "end": [238, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.zpow_comp", "code": "@[to_additive]\ntheorem zpow_comp [Group \u03b3] [TopologicalGroup \u03b3] (f : C(\u03b2, \u03b3)) (z : \u2124) (g : C(\u03b1, \u03b2)) :\n    (f ^ z).comp g = f.comp g ^ z", "start": [246, 1], "end": [249, 6], "kind": "commanddeclaration"}, {"full_name": "continuousSubmonoid", "code": "@[to_additive \"The `AddSubmonoid` of continuous maps `\u03b1 \u2192 \u03b2`. \"]\ndef continuousSubmonoid (\u03b1 : Type*) (\u03b2 : Type*) [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]\n    [MulOneClass \u03b2] [ContinuousMul \u03b2] : Submonoid (\u03b1 \u2192 \u03b2) where\n  carrier := { f : \u03b1 \u2192 \u03b2 | Continuous f }\n  one_mem' := @continuous_const _ _ _ _ 1\n  mul_mem' fc gc := fc.mul gc", "start": [270, 1], "end": [276, 30], "kind": "commanddeclaration"}, {"full_name": "continuousSubgroup", "code": "@[to_additive \"The `AddSubgroup` of continuous maps `\u03b1 \u2192 \u03b2`. \"]\ndef continuousSubgroup (\u03b1 : Type*) (\u03b2 : Type*) [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [Group \u03b2]\n    [TopologicalGroup \u03b2] : Subgroup (\u03b1 \u2192 \u03b2) :=\n  { continuousSubmonoid \u03b1 \u03b2 with inv_mem' := fun fc => Continuous.inv fc }", "start": [280, 1], "end": [284, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coeFnMonoidHom", "code": "@[to_additive (attr := simps)\n  \"Coercion to a function as an `AddMonoidHom`. Similar to `AddMonoidHom.coeFn`.\" ]\ndef coeFnMonoidHom [Monoid \u03b2] [ContinuousMul \u03b2] : C(\u03b1, \u03b2) \u2192* \u03b1 \u2192 \u03b2 where\n  toFun f := f\n  map_one' := coe_one\n  map_mul' := coe_mul", "start": [336, 1], "end": [342, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.compLeftContinuous", "code": "@[to_additive (attr := simps)\n\"Composition on the left by a (continuous) homomorphism of topological `AddMonoid`s, as an\n`AddMonoidHom`. Similar to `AddMonoidHom.comp_left`.\"]\nprotected def _root_.MonoidHom.compLeftContinuous {\u03b3 : Type*} [Monoid \u03b2] [ContinuousMul \u03b2]\n    [TopologicalSpace \u03b3] [Monoid \u03b3] [ContinuousMul \u03b3] (g : \u03b2 \u2192* \u03b3) (hg : Continuous g) :\n    C(\u03b1, \u03b2) \u2192* C(\u03b1, \u03b3) where\n  toFun f := (\u27e8g, hg\u27e9 : C(\u03b2, \u03b3)).comp f\n  map_one' := ext fun _ => g.map_one\n  map_mul' _ _ := ext fun _ => g.map_mul _ _", "start": [348, 1], "end": [358, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compMonoidHom'", "code": "@[to_additive (attr := simps)\n      \"Composition on the right as an `AddMonoidHom`. Similar to `AddMonoidHom.compHom'`.\"]\ndef compMonoidHom' {\u03b3 : Type*} [TopologicalSpace \u03b3] [MulOneClass \u03b3] [ContinuousMul \u03b3]\n    (g : C(\u03b1, \u03b2)) : C(\u03b2, \u03b3) \u2192* C(\u03b1, \u03b3) where\n  toFun f := f.comp g\n  map_one' := one_comp g\n  map_mul' f\u2081 f\u2082 := mul_comp f\u2081 f\u2082 g", "start": [364, 1], "end": [371, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_prod", "code": "@[to_additive (attr := simp)]\ntheorem coe_prod [CommMonoid \u03b2] [ContinuousMul \u03b2] {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 C(\u03b1, \u03b2)) :\n    \u21d1(\u220f i in s, f i) = \u220f i in s, (f i : \u03b1 \u2192 \u03b2)", "start": [377, 1], "end": [380, 47], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.prod_apply", "code": "@[to_additive]\ntheorem prod_apply [CommMonoid \u03b2] [ContinuousMul \u03b2] {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 C(\u03b1, \u03b2))\n    (a : \u03b1) : (\u220f i in s, f i) a = \u220f i in s, f i a", "start": [384, 1], "end": [386, 61], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.instCommGroupContinuousMap", "code": "@[to_additive]\ninstance instCommGroupContinuousMap [CommGroup \u03b2] [TopologicalGroup \u03b2] : CommGroup C(\u03b1, \u03b2) :=\n  coe_injective.commGroup _ coe_one coe_mul coe_inv coe_div coe_pow coe_zpow", "start": [394, 1], "end": [396, 77], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.hasSum_apply", "code": "theorem hasSum_apply {\u03b3 : Type*} [AddCommMonoid \u03b2] [ContinuousAdd \u03b2]\n    {f : \u03b3 \u2192 C(\u03b1, \u03b2)} {g : C(\u03b1, \u03b2)} (hf : HasSum f g) (x : \u03b1) :\n    HasSum (fun i : \u03b3 => f i x) (g x)", "start": [422, 1], "end": [429, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.summable_apply", "code": "theorem summable_apply [AddCommMonoid \u03b2] [ContinuousAdd \u03b2] {\u03b3 : Type*} {f : \u03b3 \u2192 C(\u03b1, \u03b2)}\n    (hf : Summable f) (x : \u03b1) : Summable fun i : \u03b3 => f i x", "start": [432, 1], "end": [434, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.tsum_apply", "code": "theorem tsum_apply [T2Space \u03b2] [AddCommMonoid \u03b2] [ContinuousAdd \u03b2] {\u03b3 : Type*} {f : \u03b3 \u2192 C(\u03b1, \u03b2)}\n    (hf : Summable f) (x : \u03b1) :\n    \u2211' i : \u03b3, f i x = (\u2211' i : \u03b3, f i) x", "start": [437, 1], "end": [440, 37], "kind": "commanddeclaration"}, {"full_name": "continuousSubsemiring", "code": "def continuousSubsemiring (\u03b1 : Type*) (R : Type*) [TopologicalSpace \u03b1] [TopologicalSpace R]\n    [NonAssocSemiring R] [TopologicalSemiring R] : Subsemiring (\u03b1 \u2192 R) :=\n  { continuousAddSubmonoid \u03b1 R, continuousSubmonoid \u03b1 R with }", "start": [459, 1], "end": [462, 63], "kind": "commanddeclaration"}, {"full_name": "continuousSubring", "code": "def continuousSubring (\u03b1 : Type*) (R : Type*) [TopologicalSpace \u03b1] [TopologicalSpace R] [Ring R]\n    [TopologicalRing R] : Subring (\u03b1 \u2192 R) :=\n  { continuousAddSubgroup \u03b1 R, continuousSubsemiring \u03b1 R with }", "start": [465, 1], "end": [468, 64], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.instRingContinuousMap", "code": "instance instRingContinuousMap {\u03b1 : Type*} {\u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]\n    [Ring \u03b2] [TopologicalRing \u03b2] : Ring C(\u03b1, \u03b2) :=\n  coe_injective.ring _ coe_zero coe_one coe_add coe_mul coe_neg coe_sub coe_nsmul coe_zsmul coe_pow\n    coe_nat_cast coe_int_cast", "start": [508, 1], "end": [511, 30], "kind": "commanddeclaration"}, {"full_name": "RingHom.compLeftContinuous", "code": "@[simps!]\nprotected def _root_.RingHom.compLeftContinuous (\u03b1 : Type*) {\u03b2 : Type*} {\u03b3 : Type*}\n    [TopologicalSpace \u03b1]\n    [TopologicalSpace \u03b2] [Semiring \u03b2] [TopologicalSemiring \u03b2] [TopologicalSpace \u03b3] [Semiring \u03b3]\n    [TopologicalSemiring \u03b3] (g : \u03b2 \u2192+* \u03b3) (hg : Continuous g) : C(\u03b1, \u03b2) \u2192+* C(\u03b1, \u03b3) :=\n  { g.toMonoidHom.compLeftContinuous \u03b1 hg, g.toAddMonoidHom.compLeftContinuous \u03b1 hg with }", "start": [530, 1], "end": [537, 91], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coeFnRingHom", "code": "@[simps!]\ndef coeFnRingHom {\u03b1 : Type*} {\u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [Semiring \u03b2]\n    [TopologicalSemiring \u03b2] : C(\u03b1, \u03b2) \u2192+* \u03b1 \u2192 \u03b2 :=\n  { (coeFnMonoidHom : C(\u03b1, \u03b2) \u2192* _),\n    (coeFnAddMonoidHom : C(\u03b1, \u03b2) \u2192+ _) with }", "start": [540, 1], "end": [545, 46], "kind": "commanddeclaration"}, {"full_name": "continuousSubmodule", "code": "def continuousSubmodule : Submodule R (\u03b1 \u2192 M) :=\n  { continuousAddSubgroup \u03b1 M with\n    carrier := { f : \u03b1 \u2192 M | Continuous f }\n    smul_mem' := fun c _ hf => hf.const_smul c }", "start": [575, 1], "end": [579, 49], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.instSMul", "code": "@[to_additive]\ninstance instSMul [SMul R M] [ContinuousConstSMul R M] : SMul R C(\u03b1, M) :=\n  \u27e8fun r f => \u27e8r \u2022 \u21d1f, f.continuous.const_smul r\u27e9\u27e9", "start": [589, 1], "end": [591, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_smul", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_smul [SMul R M] [ContinuousConstSMul R M] (c : R) (f : C(\u03b1, M)) : \u21d1(c \u2022 f) = c \u2022 \u21d1f", "start": [609, 1], "end": [611, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.smul_apply", "code": "@[to_additive (attr := simp)]\ntheorem smul_apply [SMul R M] [ContinuousConstSMul R M] (c : R) (f : C(\u03b1, M)) (a : \u03b1) :\n    (c \u2022 f) a = c \u2022 f a", "start": [616, 1], "end": [619, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.smul_comp", "code": "@[to_additive (attr := simp)]\ntheorem smul_comp [SMul R M] [ContinuousConstSMul R M] (r : R) (f : C(\u03b2, M)) (g : C(\u03b1, \u03b2)) :\n    (r \u2022 f).comp g = r \u2022 f.comp g", "start": [623, 1], "end": [626, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.module", "code": "instance module : Module R C(\u03b1, M) :=\n  Function.Injective.module R coeFnAddMonoidHom coe_injective coe_smul", "start": [655, 1], "end": [656, 71], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compLeftContinuous", "code": "@[simps]\nprotected def _root_.ContinuousLinearMap.compLeftContinuous (\u03b1 : Type*) [TopologicalSpace \u03b1]\n    (g : M \u2192L[R] M\u2082) : C(\u03b1, M) \u2192\u2097[R] C(\u03b1, M\u2082) :=\n  { g.toLinearMap.toAddMonoidHom.compLeftContinuous \u03b1 g.continuous with\n    map_smul' := fun c _ => ext fun _ => g.map_smul' c _ }", "start": [661, 1], "end": [667, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coeFnLinearMap", "code": "@[simps]\ndef coeFnLinearMap : C(\u03b1, M) \u2192\u2097[R] \u03b1 \u2192 M :=\n  { (coeFnAddMonoidHom : C(\u03b1, M) \u2192+ _) with\n    map_smul' := coe_smul }", "start": [670, 1], "end": [674, 28], "kind": "commanddeclaration"}, {"full_name": "continuousSubalgebra", "code": "def continuousSubalgebra : Subalgebra R (\u03b1 \u2192 A) :=\n  { continuousSubsemiring \u03b1 A with\n    carrier := { f : \u03b1 \u2192 A | Continuous f }\n    algebraMap_mem' := fun r => (continuous_const : Continuous fun _ : \u03b1 => algebraMap R A r) }", "start": [696, 1], "end": [700, 96], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.C", "code": "def ContinuousMap.C : R \u2192+* C(\u03b1, A) where\n  toFun := fun c : R => \u27e8fun _ : \u03b1 => (algebraMap R A) c, continuous_const\u27e9\n  map_one' := by ext _; exact (algebraMap R A).map_one\n  map_mul' c\u2081 c\u2082 := by ext _; exact (algebraMap R A).map_mul _ _\n  map_zero' := by ext _; exact (algebraMap R A).map_zero\n  map_add' c\u2081 c\u2082 := by ext _; exact (algebraMap R A).map_add _ _", "start": [711, 1], "end": [717, 65], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.C_apply", "code": "@[simp]\ntheorem ContinuousMap.C_apply (r : R) (a : \u03b1) : ContinuousMap.C r a = algebraMap R A r", "start": [721, 1], "end": [723, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.algebra", "code": "instance ContinuousMap.algebra : Algebra R C(\u03b1, A) where\n  toRingHom := ContinuousMap.C\n  commutes' c f := by ext x; exact Algebra.commutes' _ _\n  smul_def' c f := by ext x; exact Algebra.smul_def' _ _", "start": [727, 1], "end": [730, 57], "kind": "commanddeclaration"}, {"full_name": "AlgHom.compLeftContinuous", "code": "@[simps!]\nprotected def AlgHom.compLeftContinuous {\u03b1 : Type*} [TopologicalSpace \u03b1] (g : A \u2192\u2090[R] A\u2082)\n    (hg : Continuous g) : C(\u03b1, A) \u2192\u2090[R] C(\u03b1, A\u2082) :=\n  { g.toRingHom.compLeftContinuous \u03b1 hg with\n    commutes' := fun _ => ContinuousMap.ext fun _ => g.commutes' _ }", "start": [735, 1], "end": [741, 69], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compRightAlgHom", "code": "@[simps]\ndef ContinuousMap.compRightAlgHom {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]\n    (f : C(\u03b1, \u03b2)) : C(\u03b2, A) \u2192\u2090[R] C(\u03b1, A) where\n  toFun g := g.comp f\n  map_zero' := by\n    ext\n    rfl\n  map_add' g\u2081 g\u2082 := by\n    ext\n    rfl\n  map_one' := by\n    ext\n    rfl\n  map_mul' g\u2081 g\u2082 := by\n    ext\n    rfl\n  commutes' r := by\n    ext\n    rfl", "start": [746, 1], "end": [766, 8], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coeFnAlgHom", "code": "@[simps!]\ndef ContinuousMap.coeFnAlgHom : C(\u03b1, A) \u2192\u2090[R] \u03b1 \u2192 A :=\n  { (ContinuousMap.coeFnRingHom : C(\u03b1, A) \u2192+* _) with\n    commutes' := fun _ => rfl }", "start": [771, 1], "end": [775, 32], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.SeparatesPoints", "code": "abbrev Subalgebra.SeparatesPoints (s : Subalgebra R C(\u03b1, A)) : Prop :=\n  Set.SeparatesPoints ((fun f : C(\u03b1, A) => (f : \u03b1 \u2192 A)) '' (s : Set C(\u03b1, A)))", "start": [780, 1], "end": [784, 78], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.separatesPoints_monotone", "code": "theorem Subalgebra.separatesPoints_monotone :\n    Monotone fun s : Subalgebra R C(\u03b1, A) => s.SeparatesPoints", "start": [787, 1], "end": [791, 32], "kind": "commanddeclaration"}, {"full_name": "algebraMap_apply", "code": "@[simp]\ntheorem algebraMap_apply (k : R) (a : \u03b1) : algebraMap R C(\u03b1, A) k a = k \u2022 (1 : A)", "start": [794, 1], "end": [797, 6], "kind": "commanddeclaration"}, {"full_name": "Set.SeparatesPointsStrongly", "code": "def Set.SeparatesPointsStrongly (s : Set C(\u03b1, \ud835\udd5c)) : Prop :=\n  \u2200 (v : \u03b1 \u2192 \ud835\udd5c) (x y : \u03b1), \u2203 f \u2208 s, (f x : \ud835\udd5c) = v x \u2227 f y = v y", "start": [804, 1], "end": [817, 64], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.SeparatesPoints.strongly", "code": "theorem Subalgebra.SeparatesPoints.strongly {s : Subalgebra \ud835\udd5c C(\u03b1, \ud835\udd5c)} (h : s.SeparatesPoints) :\n    (s : Set C(\u03b1, \ud835\udd5c)).SeparatesPointsStrongly", "start": [822, 1], "end": [841, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.subsingleton_subalgebra", "code": "instance ContinuousMap.subsingleton_subalgebra (\u03b1 : Type*) [TopologicalSpace \u03b1] (R : Type*)\n    [CommSemiring R] [TopologicalSpace R] [TopologicalSemiring R] [Subsingleton \u03b1] :\n    Subsingleton (Subalgebra R C(\u03b1, R)) :=\n  \u27e8fun s\u2081 s\u2082 => by\n    cases isEmpty_or_nonempty \u03b1\n    \u00b7 haveI : Subsingleton C(\u03b1, R) := FunLike.coe_injective.subsingleton\n      exact Subsingleton.elim _ _\n    \u00b7 inhabit \u03b1\n      ext f\n      have h : f = algebraMap R C(\u03b1, R) (f default) := by\n        ext x'\n        simp only [mul_one, Algebra.id.smul_eq_mul, algebraMap_apply]\n        congr\n        simp\n      rw [h]\n      simp only [Subalgebra.algebraMap_mem]\u27e9", "start": [846, 1], "end": [861, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.instSMul'", "code": "instance instSMul' {\u03b1 : Type*} [TopologicalSpace \u03b1] {R : Type*} [Semiring R] [TopologicalSpace R]\n    {M : Type*} [TopologicalSpace M] [AddCommMonoid M] [Module R M] [ContinuousSMul R M] :\n    SMul C(\u03b1, R) C(\u03b1, M) :=\n  \u27e8fun f g => \u27e8fun x => f x \u2022 g x, Continuous.smul f.2 g.2\u27e9\u27e9", "start": [877, 1], "end": [880, 61], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.module'", "code": "instance module' {\u03b1 : Type*} [TopologicalSpace \u03b1] (R : Type*) [Semiring R] [TopologicalSpace R]\n    [TopologicalSemiring R] (M : Type*) [TopologicalSpace M] [AddCommMonoid M] [ContinuousAdd M]\n    [Module R M] [ContinuousSMul R M] : Module C(\u03b1, R) C(\u03b1, M) where\n  smul := (\u00b7 \u2022 \u00b7)\n  smul_add c f g := by ext x; exact smul_add (c x) (f x) (g x)\n  add_smul c\u2081 c\u2082 f := by ext x; exact add_smul (c\u2081 x) (c\u2082 x) (f x)\n  mul_smul c\u2081 c\u2082 f := by ext x; exact mul_smul (c\u2081 x) (c\u2082 x) (f x)\n  one_smul f := by ext x; exact one_smul R (f x)\n  zero_smul f := by ext x; exact zero_smul _ _\n  smul_zero r := by ext x; exact smul_zero _", "start": [883, 1], "end": [892, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.instCovariantClass_mul_le_left", "code": "@[to_additive]\ninstance instCovariantClass_mul_le_left [PartialOrder \u03b2] [Mul \u03b2] [ContinuousMul \u03b2]\n  [CovariantClass \u03b2 \u03b2 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] :\n  CovariantClass C(\u03b1, \u03b2) C(\u03b1, \u03b2) (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) :=\n\u27e8fun _ _ _ hg\u2081\u2082 x => mul_le_mul_left' (hg\u2081\u2082 x) _\u27e9", "start": [914, 1], "end": [918, 50], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.instCovariantClass_mul_le_right", "code": "@[to_additive]\ninstance instCovariantClass_mul_le_right [PartialOrder \u03b2] [Mul \u03b2] [ContinuousMul \u03b2]\n  [CovariantClass \u03b2 \u03b2 (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] :\n  CovariantClass C(\u03b1, \u03b2) C(\u03b1, \u03b2) (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7) :=\n\u27e8fun _ _ _ hg\u2081\u2082 x => mul_le_mul_right' (hg\u2081\u2082 x) _\u27e9", "start": [920, 1], "end": [924, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_star", "code": "@[simp]\ntheorem coe_star (f : C(\u03b1, \u03b2)) : \u21d1(star f) = star (\u21d1f)", "start": [954, 1], "end": [956, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.star_apply", "code": "@[simp]\ntheorem star_apply (f : C(\u03b1, \u03b2)) (x : \u03b1) : star f x = star (f x)", "start": [959, 1], "end": [961, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.starAddMonoid", "code": "instance starAddMonoid [AddMonoid \u03b2] [ContinuousAdd \u03b2] [StarAddMonoid \u03b2] [ContinuousStar \u03b2] :\n    StarAddMonoid C(\u03b1, \u03b2) where\n  star_add _ _ := ext fun _ => star_add _ _", "start": [969, 1], "end": [971, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.starMul", "code": "instance starMul [Mul \u03b2] [ContinuousMul \u03b2] [StarMul \u03b2] [ContinuousStar \u03b2] :\n    StarMul C(\u03b1, \u03b2) where\n  star_mul _ _ := ext fun _ => star_mul _ _", "start": [973, 1], "end": [975, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compStarAlgHom'", "code": "@[simps]\ndef compStarAlgHom' (f : C(X, Y)) : C(Y, A) \u2192\u22c6\u2090[\ud835\udd5c] C(X, A) where\n  toFun g := g.comp f\n  map_one' := one_comp _\n  map_mul' _ _ := rfl\n  map_zero' := zero_comp f\n  map_add' _ _ := rfl\n  commutes' _ := rfl\n  map_star' _ := rfl", "start": [995, 1], "end": [1008, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compStarAlgHom'_id", "code": "theorem compStarAlgHom'_id : compStarAlgHom' \ud835\udd5c A (ContinuousMap.id X) = StarAlgHom.id \ud835\udd5c C(X, A)", "start": [1011, 1], "end": [1014, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compStarAlgHom'_comp", "code": "theorem compStarAlgHom'_comp (g : C(Y, Z)) (f : C(X, Y)) :\n    compStarAlgHom' \ud835\udd5c A (g.comp f) = (compStarAlgHom' \ud835\udd5c A f).comp (compStarAlgHom' \ud835\udd5c A g)", "start": [1017, 1], "end": [1020, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.periodic_tsum_comp_add_zsmul", "code": "theorem periodic_tsum_comp_add_zsmul [AddCommGroup X] [TopologicalAddGroup X] [AddCommMonoid Y]\n    [ContinuousAdd Y] [T2Space Y] (f : C(X, Y)) (p : X) :\n    Function.Periodic (\u21d1(\u2211' n : \u2124, f.comp (ContinuousMap.addRight (n \u2022 p)))) p", "start": [1027, 1], "end": [1045, 40], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.compStarAlgEquiv'", "code": "@[simps]\ndef compStarAlgEquiv' (f : X \u2243\u209c Y) : C(Y, A) \u2243\u22c6\u2090[\ud835\udd5c] C(X, A) :=\n  { f.toContinuousMap.compStarAlgHom' \ud835\udd5c A with\n    toFun := (f : C(X, Y)).compStarAlgHom' \ud835\udd5c A\n    invFun := (f.symm : C(Y, X)).compStarAlgHom' \ud835\udd5c A\n    left_inv := fun g => by\n      simp only [ContinuousMap.compStarAlgHom'_apply, ContinuousMap.comp_assoc,\n        toContinuousMap_comp_symm, ContinuousMap.comp_id]\n    right_inv := fun g => by\n      simp only [ContinuousMap.compStarAlgHom'_apply, ContinuousMap.comp_assoc,\n        symm_comp_toContinuousMap, ContinuousMap.comp_id]\n    map_smul' := fun k a => map_smul (f.toContinuousMap.compStarAlgHom' \ud835\udd5c A) k a }", "start": [1062, 1], "end": [1075, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/OperatorNorm.lean", "imports": ["Mathlib/Analysis/NormedSpace/ContinuousLinearMap.lean", "Mathlib/Tactic/SuppressCompilation.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Algebra/Tower.lean", "Mathlib/Topology/Algebra/Module/StrongTopology.lean", "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "Mathlib/Analysis/NormedSpace/LinearIsometry.lean"], "premises": [{"full_name": "norm_image_of_norm_zero", "code": "theorem norm_image_of_norm_zero [SemilinearMapClass \ud835\udcd5 \u03c3\u2081\u2082 E F] (f : \ud835\udcd5) (hf : Continuous f) {x : E}\n    (hx : \u2016x\u2016 = 0) : \u2016f x\u2016 = 0", "start": [49, 1], "end": [53, 18], "kind": "commanddeclaration"}, {"full_name": "SemilinearMapClass.bound_of_shell_semi_normed", "code": "theorem SemilinearMapClass.bound_of_shell_semi_normed [SemilinearMapClass \ud835\udcd5 \u03c3\u2081\u2082 E F] (f : \ud835\udcd5)\n    {\u03b5 C : \u211d} (\u03b5_pos : 0 < \u03b5) {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016)\n    (hf : \u2200 x, \u03b5 / \u2016c\u2016 \u2264 \u2016x\u2016 \u2192 \u2016x\u2016 < \u03b5 \u2192 \u2016f x\u2016 \u2264 C * \u2016x\u2016) {x : E} (hx : \u2016x\u2016 \u2260 0) :\n    \u2016f x\u2016 \u2264 C * \u2016x\u2016", "start": [60, 1], "end": [65, 19], "kind": "commanddeclaration"}, {"full_name": "SemilinearMapClass.bound_of_continuous", "code": "theorem SemilinearMapClass.bound_of_continuous [SemilinearMapClass \ud835\udcd5 \u03c3\u2081\u2082 E F] (f : \ud835\udcd5)\n    (hf : Continuous f) : \u2203 C, 0 < C \u2227 \u2200 x : E, \u2016f x\u2016 \u2264 C * \u2016x\u2016", "start": [68, 1], "end": [75, 89], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.bound", "code": "theorem bound [RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192SL[\u03c3\u2081\u2082] F) : \u2203 C, 0 < C \u2227 \u2200 x : E, \u2016f x\u2016 \u2264 C * \u2016x\u2016", "start": [82, 1], "end": [83, 47], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.toSpanSingleton", "code": "def _root_.LinearIsometry.toSpanSingleton {v : E} (hv : \u2016v\u2016 = 1) : \ud835\udd5c \u2192\u2097\u1d62[\ud835\udd5c] E :=\n  { LinearMap.toSpanSingleton \ud835\udd5c E v with norm_map' := fun x => by simp [norm_smul, hv] }", "start": [92, 1], "end": [95, 89], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.toSpanSingleton_apply", "code": "@[simp]\ntheorem _root_.LinearIsometry.toSpanSingleton_apply {v : E} (hv : \u2016v\u2016 = 1) (a : \ud835\udd5c) :\n    LinearIsometry.toSpanSingleton \ud835\udd5c E hv a = a \u2022 v", "start": [100, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.coe_toSpanSingleton", "code": "@[simp]\ntheorem _root_.LinearIsometry.coe_toSpanSingleton {v : E} (hv : \u2016v\u2016 = 1) :\n    (LinearIsometry.toSpanSingleton \ud835\udd5c E hv).toLinearMap = LinearMap.toSpanSingleton \ud835\udd5c E v", "start": [106, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.opNorm", "code": "def opNorm (f : E \u2192SL[\u03c3\u2081\u2082] F) :=\n  sInf { c | 0 \u2264 c \u2227 \u2200 x, \u2016f x\u2016 \u2264 c * \u2016x\u2016 }", "start": [118, 1], "end": [120, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.hasOpNorm", "code": "instance hasOpNorm : Norm (E \u2192SL[\u03c3\u2081\u2082] F) :=\n  \u27e8opNorm\u27e9", "start": [123, 1], "end": [124, 11], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_def", "code": "theorem norm_def (f : E \u2192SL[\u03c3\u2081\u2082] F) : \u2016f\u2016 = sInf { c | 0 \u2264 c \u2227 \u2200 x, \u2016f x\u2016 \u2264 c * \u2016x\u2016 }", "start": [127, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.bounds_nonempty", "code": "theorem bounds_nonempty [RingHomIsometric \u03c3\u2081\u2082] {f : E \u2192SL[\u03c3\u2081\u2082] F} :\n    \u2203 c, c \u2208 { c | 0 \u2264 c \u2227 \u2200 x, \u2016f x\u2016 \u2264 c * \u2016x\u2016 }", "start": [133, 1], "end": [136, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.bounds_bddBelow", "code": "theorem bounds_bddBelow {f : E \u2192SL[\u03c3\u2081\u2082] F} : BddBelow { c | 0 \u2264 c \u2227 \u2200 x, \u2016f x\u2016 \u2264 c * \u2016x\u2016 }", "start": [139, 1], "end": [140, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isLeast_op_norm", "code": "theorem isLeast_op_norm [RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192SL[\u03c3\u2081\u2082] F) :\n    IsLeast {c | 0 \u2264 c \u2227 \u2200 x, \u2016f x\u2016 \u2264 c * \u2016x\u2016} \u2016f\u2016", "start": [143, 1], "end": [147, 88], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_le_bound", "code": "theorem op_norm_le_bound (f : E \u2192SL[\u03c3\u2081\u2082] F) {M : \u211d} (hMp : 0 \u2264 M) (hM : \u2200 x, \u2016f x\u2016 \u2264 M * \u2016x\u2016) :\n    \u2016f\u2016 \u2264 M", "start": [149, 1], "end": [152, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_le_bound'", "code": "theorem op_norm_le_bound' (f : E \u2192SL[\u03c3\u2081\u2082] F) {M : \u211d} (hMp : 0 \u2264 M)\n    (hM : \u2200 x, \u2016x\u2016 \u2260 0 \u2192 \u2016f x\u2016 \u2264 M * \u2016x\u2016) : \u2016f\u2016 \u2264 M", "start": [155, 1], "end": [160, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_le_of_lipschitz", "code": "theorem op_norm_le_of_lipschitz {f : E \u2192SL[\u03c3\u2081\u2082] F} {K : \u211d\u22650} (hf : LipschitzWith K f) : \u2016f\u2016 \u2264 K", "start": [163, 1], "end": [165, 70], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_eq_of_bounds", "code": "theorem op_norm_eq_of_bounds {\u03c6 : E \u2192SL[\u03c3\u2081\u2082] F} {M : \u211d} (M_nonneg : 0 \u2264 M)\n    (h_above : \u2200 x, \u2016\u03c6 x\u2016 \u2264 M * \u2016x\u2016) (h_below : \u2200 N \u2265 0, (\u2200 x, \u2016\u03c6 x\u2016 \u2264 N * \u2016x\u2016) \u2192 M \u2264 N) :\n    \u2016\u03c6\u2016 = M", "start": [168, 1], "end": [173, 53], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_neg", "code": "theorem op_norm_neg (f : E \u2192SL[\u03c3\u2081\u2082] F) : \u2016-f\u2016 = \u2016f\u2016", "start": [176, 1], "end": [176, 100], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_nonneg", "code": "theorem op_norm_nonneg (f : E \u2192SL[\u03c3\u2081\u2082] F) : 0 \u2264 \u2016f\u2016", "start": [179, 1], "end": [180, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_zero", "code": "theorem op_norm_zero : \u2016(0 : E \u2192SL[\u03c3\u2081\u2082] F)\u2016 = 0", "start": [183, 1], "end": [185, 77], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_id_le", "code": "theorem norm_id_le : \u2016id \ud835\udd5c E\u2016 \u2264 1", "start": [188, 1], "end": [191, 50], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.le_op_norm", "code": "theorem le_op_norm : \u2016f x\u2016 \u2264 \u2016f\u2016 * \u2016x\u2016", "start": [199, 1], "end": [200, 68], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.dist_le_op_norm", "code": "theorem dist_le_op_norm (x y : E) : dist (f x) (f y) \u2264 \u2016f\u2016 * dist x y", "start": [203, 1], "end": [204, 50], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.le_of_op_norm_le_of_le", "code": "theorem le_of_op_norm_le_of_le {x} {a b : \u211d} (hf : \u2016f\u2016 \u2264 a) (hx : \u2016x\u2016 \u2264 b) :\n    \u2016f x\u2016 \u2264 a * b", "start": [207, 1], "end": [209, 73], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.le_op_norm_of_le", "code": "theorem le_op_norm_of_le {c : \u211d} {x} (h : \u2016x\u2016 \u2264 c) : \u2016f x\u2016 \u2264 \u2016f\u2016 * c", "start": [211, 1], "end": [212, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.le_of_op_norm_le", "code": "theorem le_of_op_norm_le {c : \u211d} (h : \u2016f\u2016 \u2264 c) (x : E) : \u2016f x\u2016 \u2264 c * \u2016x\u2016", "start": [215, 1], "end": [216, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_le_iff", "code": "theorem op_norm_le_iff {f : E \u2192SL[\u03c3\u2081\u2082] F} {M : \u211d} (hMp : 0 \u2264 M) :\n    \u2016f\u2016 \u2264 M \u2194 \u2200 x, \u2016f x\u2016 \u2264 M * \u2016x\u2016", "start": [219, 1], "end": [221, 47], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ratio_le_op_norm", "code": "theorem ratio_le_op_norm : \u2016f x\u2016 / \u2016x\u2016 \u2264 \u2016f\u2016", "start": [223, 1], "end": [224, 79], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.unit_le_op_norm", "code": "theorem unit_le_op_norm : \u2016x\u2016 \u2264 1 \u2192 \u2016f x\u2016 \u2264 \u2016f\u2016", "start": [227, 1], "end": [229, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_le_of_shell", "code": "theorem op_norm_le_of_shell {f : E \u2192SL[\u03c3\u2081\u2082] F} {\u03b5 C : \u211d} (\u03b5_pos : 0 < \u03b5) (hC : 0 \u2264 C) {c : \ud835\udd5c}\n    (hc : 1 < \u2016c\u2016) (hf : \u2200 x, \u03b5 / \u2016c\u2016 \u2264 \u2016x\u2016 \u2192 \u2016x\u2016 < \u03b5 \u2192 \u2016f x\u2016 \u2264 C * \u2016x\u2016) : \u2016f\u2016 \u2264 C", "start": [232, 1], "end": [234, 100], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_le_of_ball", "code": "theorem op_norm_le_of_ball {f : E \u2192SL[\u03c3\u2081\u2082] F} {\u03b5 : \u211d} {C : \u211d} (\u03b5_pos : 0 < \u03b5) (hC : 0 \u2264 C)\n    (hf : \u2200 x \u2208 ball (0 : E) \u03b5, \u2016f x\u2016 \u2264 C * \u2016x\u2016) : \u2016f\u2016 \u2264 C", "start": [237, 1], "end": [241, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_le_of_nhds_zero", "code": "theorem op_norm_le_of_nhds_zero {f : E \u2192SL[\u03c3\u2081\u2082] F} {C : \u211d} (hC : 0 \u2264 C)\n    (hf : \u2200\u1da0 x in \ud835\udcdd (0 : E), \u2016f x\u2016 \u2264 C * \u2016x\u2016) : \u2016f\u2016 \u2264 C", "start": [244, 1], "end": [247, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_le_of_shell'", "code": "theorem op_norm_le_of_shell' {f : E \u2192SL[\u03c3\u2081\u2082] F} {\u03b5 C : \u211d} (\u03b5_pos : 0 < \u03b5) (hC : 0 \u2264 C) {c : \ud835\udd5c}\n    (hc : \u2016c\u2016 < 1) (hf : \u2200 x, \u03b5 * \u2016c\u2016 \u2264 \u2016x\u2016 \u2192 \u2016x\u2016 < \u03b5 \u2192 \u2016f x\u2016 \u2264 C * \u2016x\u2016) : \u2016f\u2016 \u2264 C", "start": [250, 1], "end": [258, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_le_of_unit_norm", "code": "theorem op_norm_le_of_unit_norm [NormedSpace \u211d E] [NormedSpace \u211d F] {f : E \u2192L[\u211d] F} {C : \u211d}\n    (hC : 0 \u2264 C) (hf : \u2200 x, \u2016x\u2016 = 1 \u2192 \u2016f x\u2016 \u2264 C) : \u2016f\u2016 \u2264 C", "start": [261, 1], "end": [269, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_add_le", "code": "theorem op_norm_add_le : \u2016f + g\u2016 \u2264 \u2016f\u2016 + \u2016g\u2016", "start": [272, 1], "end": [275, 88], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_id_of_nontrivial_seminorm", "code": "theorem norm_id_of_nontrivial_seminorm (h : \u2203 x : E, \u2016x\u2016 \u2260 0) : \u2016id \ud835\udd5c E\u2016 = 1", "start": [278, 1], "end": [284, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_smul_le", "code": "theorem op_norm_smul_le {\ud835\udd5c' : Type*} [NormedField \ud835\udd5c'] [NormedSpace \ud835\udd5c' F] [SMulCommClass \ud835\udd5c\u2082 \ud835\udd5c' F]\n    (c : \ud835\udd5c') (f : E \u2192SL[\u03c3\u2081\u2082] F) : \u2016c \u2022 f\u2016 \u2264 \u2016c\u2016 * \u2016f\u2016", "start": [287, 1], "end": [291, 69], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.tmpSeminormedAddCommGroup", "code": "protected def tmpSeminormedAddCommGroup : SeminormedAddCommGroup (E \u2192SL[\u03c3\u2081\u2082] F) :=\n  AddGroupSeminorm.toSeminormedAddCommGroup\n    { toFun := norm\n      map_zero' := op_norm_zero\n      add_le' := op_norm_add_le\n      neg' := op_norm_neg }", "start": [294, 1], "end": [303, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.tmpPseudoMetricSpace", "code": "protected def tmpPseudoMetricSpace : PseudoMetricSpace (E \u2192SL[\u03c3\u2081\u2082] F) :=\n  ContinuousLinearMap.tmpSeminormedAddCommGroup.toPseudoMetricSpace", "start": [306, 1], "end": [310, 68], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.tmpUniformSpace", "code": "protected def tmpUniformSpace : UniformSpace (E \u2192SL[\u03c3\u2081\u2082] F) :=\n  ContinuousLinearMap.tmpPseudoMetricSpace.toUniformSpace", "start": [313, 1], "end": [317, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.tmpTopologicalSpace", "code": "protected def tmpTopologicalSpace : TopologicalSpace (E \u2192SL[\u03c3\u2081\u2082] F) :=\n  ContinuousLinearMap.tmpUniformSpace.toTopologicalSpace", "start": [320, 1], "end": [324, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.tmpTopologicalAddGroup", "code": "protected theorem tmpTopologicalAddGroup : TopologicalAddGroup (E \u2192SL[\u03c3\u2081\u2082] F)", "start": [335, 1], "end": [336, 16], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.tmp_closedBall_div_subset", "code": "protected theorem tmp_closedBall_div_subset {a b : \u211d} (ha : 0 < a) (hb : 0 < b) :\n    closedBall (0 : E \u2192SL[\u03c3\u2081\u2082] F) (a / b) \u2286\n      { f | \u2200 x \u2208 closedBall (0 : E) b, f x \u2208 closedBall (0 : F) a }", "start": [339, 1], "end": [347, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.tmp_topology_eq", "code": "protected theorem tmp_topology_eq :\n    (ContinuousLinearMap.tmpTopologicalSpace : TopologicalSpace (E \u2192SL[\u03c3\u2081\u2082] F)) =\n      ContinuousLinearMap.topologicalSpace", "start": [352, 1], "end": [373, 99], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.tmpUniformSpace_eq", "code": "protected theorem tmpUniformSpace_eq :\n    (ContinuousLinearMap.tmpUniformSpace : UniformSpace (E \u2192SL[\u03c3\u2081\u2082] F)) =\n      ContinuousLinearMap.uniformSpace", "start": [376, 1], "end": [382, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toPseudoMetricSpace", "code": "instance toPseudoMetricSpace : PseudoMetricSpace (E \u2192SL[\u03c3\u2081\u2082] F) :=\n  ContinuousLinearMap.tmpPseudoMetricSpace.replaceUniformity\n    (congr_arg _ ContinuousLinearMap.tmpUniformSpace_eq.symm)", "start": [385, 1], "end": [387, 62], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toSeminormedAddCommGroup", "code": "instance toSeminormedAddCommGroup : SeminormedAddCommGroup (E \u2192SL[\u03c3\u2081\u2082] F) where\n  dist_eq := ContinuousLinearMap.tmpSeminormedAddCommGroup.dist_eq", "start": [390, 1], "end": [393, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.nnnorm_def", "code": "theorem nnnorm_def (f : E \u2192SL[\u03c3\u2081\u2082] F) : \u2016f\u2016\u208a = sInf { c | \u2200 x, \u2016f x\u2016\u208a \u2264 c * \u2016x\u2016\u208a }", "start": [396, 1], "end": [400, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_nnnorm_le_bound", "code": "theorem op_nnnorm_le_bound (f : E \u2192SL[\u03c3\u2081\u2082] F) (M : \u211d\u22650) (hM : \u2200 x, \u2016f x\u2016\u208a \u2264 M * \u2016x\u2016\u208a) : \u2016f\u2016\u208a \u2264 M", "start": [403, 1], "end": [405, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_nnnorm_le_bound'", "code": "theorem op_nnnorm_le_bound' (f : E \u2192SL[\u03c3\u2081\u2082] F) (M : \u211d\u22650) (hM : \u2200 x, \u2016x\u2016\u208a \u2260 0 \u2192 \u2016f x\u2016\u208a \u2264 M * \u2016x\u2016\u208a) :\n    \u2016f\u2016\u208a \u2264 M", "start": [408, 1], "end": [411, 84], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_nnnorm_le_of_unit_nnnorm", "code": "theorem op_nnnorm_le_of_unit_nnnorm [NormedSpace \u211d E] [NormedSpace \u211d F] {f : E \u2192L[\u211d] F} {C : \u211d\u22650}\n    (hf : \u2200 x, \u2016x\u2016\u208a = 1 \u2192 \u2016f x\u2016\u208a \u2264 C) : \u2016f\u2016\u208a \u2264 C", "start": [414, 1], "end": [418, 88], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_nnnorm_le_of_lipschitz", "code": "theorem op_nnnorm_le_of_lipschitz {f : E \u2192SL[\u03c3\u2081\u2082] F} {K : \u211d\u22650} (hf : LipschitzWith K f) :\n    \u2016f\u2016\u208a \u2264 K", "start": [421, 1], "end": [423, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_nnnorm_eq_of_bounds", "code": "theorem op_nnnorm_eq_of_bounds {\u03c6 : E \u2192SL[\u03c3\u2081\u2082] F} (M : \u211d\u22650) (h_above : \u2200 x, \u2016\u03c6 x\u2016 \u2264 M * \u2016x\u2016)\n    (h_below : \u2200 N, (\u2200 x, \u2016\u03c6 x\u2016\u208a \u2264 N * \u2016x\u2016\u208a) \u2192 M \u2264 N) : \u2016\u03c6\u2016\u208a = M", "start": [426, 1], "end": [428, 89], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_nnnorm_le_iff", "code": "theorem op_nnnorm_le_iff {f : E \u2192SL[\u03c3\u2081\u2082] F} {C : \u211d\u22650} : \u2016f\u2016\u208a \u2264 C \u2194 \u2200 x, \u2016f x\u2016\u208a \u2264 C * \u2016x\u2016\u208a", "start": [431, 1], "end": [432, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isLeast_op_nnnorm", "code": "theorem isLeast_op_nnnorm : IsLeast {C : \u211d\u22650 | \u2200 x, \u2016f x\u2016\u208a \u2264 C * \u2016x\u2016\u208a} \u2016f\u2016\u208a", "start": [434, 1], "end": [435, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toNormedSpace", "code": "instance toNormedSpace {\ud835\udd5c' : Type*} [NormedField \ud835\udd5c'] [NormedSpace \ud835\udd5c' F] [SMulCommClass \ud835\udd5c\u2082 \ud835\udd5c' F] :\n    NormedSpace \ud835\udd5c' (E \u2192SL[\u03c3\u2081\u2082] F) :=\n  \u27e8op_norm_smul_le\u27e9", "start": [437, 1], "end": [439, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_comp_le", "code": "theorem op_norm_comp_le (f : E \u2192SL[\u03c3\u2081\u2082] F) : \u2016h.comp f\u2016 \u2264 \u2016h\u2016 * \u2016f\u2016", "start": [442, 1], "end": [447, 49], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_comp_le'", "code": "theorem op_norm_comp_le' (h : E\u2097 \u2192L[\ud835\udd5c] F\u2097) (f : E \u2192L[\ud835\udd5c] E\u2097) : \u2016h.comp f\u2016 \u2264 \u2016h\u2016 * \u2016f\u2016", "start": [451, 1], "end": [453, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_nnnorm_comp_le", "code": "theorem op_nnnorm_comp_le [RingHomIsometric \u03c3\u2081\u2083] (f : E \u2192SL[\u03c3\u2081\u2082] F) : \u2016h.comp f\u2016\u208a \u2264 \u2016h\u2016\u208a * \u2016f\u2016\u208a", "start": [455, 1], "end": [456, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toSemiNormedRing", "code": "instance toSemiNormedRing : SeminormedRing (E \u2192L[\ud835\udd5c] E) :=\n  { ContinuousLinearMap.toSeminormedAddCommGroup, ContinuousLinearMap.ring with\n    norm_mul := fun f g => op_norm_comp_le f g }", "start": [459, 1], "end": [462, 49], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toNormedAlgebra", "code": "instance toNormedAlgebra : NormedAlgebra \ud835\udd5c (E \u2192L[\ud835\udd5c] E) :=\n  { (algebra : Algebra \ud835\udd5c (E \u2192L[\ud835\udd5c] E)) with\n    norm_smul_le := by\n      intro c f\n      apply op_norm_smul_le c f}", "start": [467, 1], "end": [473, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.le_op_nnnorm", "code": "theorem le_op_nnnorm : \u2016f x\u2016\u208a \u2264 \u2016f\u2016\u208a * \u2016x\u2016\u208a", "start": [476, 1], "end": [477, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.nndist_le_op_nnnorm", "code": "theorem nndist_le_op_nnnorm (x y : E) : nndist (f x) (f y) \u2264 \u2016f\u2016\u208a * nndist x y", "start": [480, 1], "end": [481, 24], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.lipschitz", "code": "theorem lipschitz : LipschitzWith \u2016f\u2016\u208a f", "start": [484, 1], "end": [486, 65], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.lipschitz_apply", "code": "theorem lipschitz_apply (x : E) : LipschitzWith \u2016x\u2016\u208a fun f : E \u2192SL[\u03c3\u2081\u2082] F => f x", "start": [489, 1], "end": [491, 92], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.exists_mul_lt_apply_of_lt_op_nnnorm", "code": "theorem exists_mul_lt_apply_of_lt_op_nnnorm (f : E \u2192SL[\u03c3\u2081\u2082] F) {r : \u211d\u22650} (hr : r < \u2016f\u2016\u208a) :\n    \u2203 x, r * \u2016x\u2016\u208a < \u2016f x\u2016\u208a", "start": [500, 1], "end": [504, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.exists_mul_lt_of_lt_op_norm", "code": "theorem exists_mul_lt_of_lt_op_norm (f : E \u2192SL[\u03c3\u2081\u2082] F) {r : \u211d} (hr\u2080 : 0 \u2264 r) (hr : r < \u2016f\u2016) :\n    \u2203 x, r * \u2016x\u2016 < \u2016f x\u2016", "start": [507, 1], "end": [510, 49], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.exists_lt_apply_of_lt_op_nnnorm", "code": "theorem exists_lt_apply_of_lt_op_nnnorm {\ud835\udd5c \ud835\udd5c\u2082 E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField \ud835\udd5c] [NontriviallyNormedField \ud835\udd5c\u2082] {\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082}\n    [NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c\u2082 F] [RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192SL[\u03c3\u2081\u2082] F) {r : \u211d\u22650}\n    (hr : r < \u2016f\u2016\u208a) : \u2203 x : E, \u2016x\u2016\u208a < 1 \u2227 r < \u2016f x\u2016\u208a", "start": [513, 1], "end": [527, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.exists_lt_apply_of_lt_op_norm", "code": "theorem exists_lt_apply_of_lt_op_norm {\ud835\udd5c \ud835\udd5c\u2082 E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField \ud835\udd5c] [NontriviallyNormedField \ud835\udd5c\u2082] {\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082}\n    [NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c\u2082 F] [RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192SL[\u03c3\u2081\u2082] F) {r : \u211d}\n    (hr : r < \u2016f\u2016) : \u2203 x : E, \u2016x\u2016 < 1 \u2227 r < \u2016f x\u2016", "start": [530, 1], "end": [537, 47], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.sSup_unit_ball_eq_nnnorm", "code": "theorem sSup_unit_ball_eq_nnnorm {\ud835\udd5c \ud835\udd5c\u2082 E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField \ud835\udd5c] [NontriviallyNormedField \ud835\udd5c\u2082] {\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082}\n    [NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c\u2082 F] [RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192SL[\u03c3\u2081\u2082] F) :\n    sSup ((fun x => \u2016f x\u2016\u208a) '' ball 0 1) = \u2016f\u2016\u208a", "start": [540, 1], "end": [549, 53], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.sSup_unit_ball_eq_norm", "code": "theorem sSup_unit_ball_eq_norm {\ud835\udd5c \ud835\udd5c\u2082 E F : Type*} [NormedAddCommGroup E] [SeminormedAddCommGroup F]\n    [DenselyNormedField \ud835\udd5c] [NontriviallyNormedField \ud835\udd5c\u2082] {\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [NormedSpace \ud835\udd5c E]\n    [NormedSpace \ud835\udd5c\u2082 F] [RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192SL[\u03c3\u2081\u2082] F) :\n    sSup ((fun x => \u2016f x\u2016) '' ball 0 1) = \u2016f\u2016", "start": [552, 1], "end": [556, 97], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.sSup_closed_unit_ball_eq_nnnorm", "code": "theorem sSup_closed_unit_ball_eq_nnnorm {\ud835\udd5c \ud835\udd5c\u2082 E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField \ud835\udd5c] [NontriviallyNormedField \ud835\udd5c\u2082] {\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082}\n    [NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c\u2082 F] [RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192SL[\u03c3\u2081\u2082] F) :\n    sSup ((fun x => \u2016f x\u2016\u208a) '' closedBall 0 1) = \u2016f\u2016\u208a", "start": [559, 1], "end": [569, 48], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.sSup_closed_unit_ball_eq_norm", "code": "theorem sSup_closed_unit_ball_eq_norm {\ud835\udd5c \ud835\udd5c\u2082 E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField \ud835\udd5c] [NontriviallyNormedField \ud835\udd5c\u2082] {\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082}\n    [NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c\u2082 F] [RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192SL[\u03c3\u2081\u2082] F) :\n    sSup ((fun x => \u2016f x\u2016) '' closedBall 0 1) = \u2016f\u2016", "start": [572, 1], "end": [577, 54], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_ext", "code": "theorem op_norm_ext [RingHomIsometric \u03c3\u2081\u2083] (f : E \u2192SL[\u03c3\u2081\u2082] F) (g : E \u2192SL[\u03c3\u2081\u2083] G)\n    (h : \u2200 x, \u2016f x\u2016 = \u2016g x\u2016) : \u2016f\u2016 = \u2016g\u2016", "start": [584, 1], "end": [593, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_le_bound\u2082", "code": "theorem op_norm_le_bound\u2082 (f : E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G) {C : \u211d} (h0 : 0 \u2264 C)\n    (hC : \u2200 x y, \u2016f x y\u2016 \u2264 C * \u2016x\u2016 * \u2016y\u2016) : \u2016f\u2016 \u2264 C", "start": [598, 1], "end": [600, 96], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.le_op_norm\u2082", "code": "theorem le_op_norm\u2082 [RingHomIsometric \u03c3\u2081\u2083] (f : E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G) (x : E) (y : F) :\n    \u2016f x y\u2016 \u2264 \u2016f\u2016 * \u2016x\u2016 * \u2016y\u2016", "start": [603, 1], "end": [605, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.le_of_op_norm\u2082_le_of_le", "code": "theorem le_of_op_norm\u2082_le_of_le [RingHomIsometric \u03c3\u2081\u2083] (f : E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G) {x : E} {y : F}\n    {a b c : \u211d} (hf : \u2016f\u2016 \u2264 a) (hx : \u2016x\u2016 \u2264 b) (hy : \u2016y\u2016 \u2264 c)  :\n    \u2016f x y\u2016 \u2264 a * b * c", "start": [609, 1], "end": [612, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_prod", "code": "@[simp]\ntheorem op_norm_prod (f : E \u2192L[\ud835\udd5c] F\u2097) (g : E \u2192L[\ud835\udd5c] G\u2097) : \u2016f.prod g\u2016 = \u2016(f, g)\u2016", "start": [616, 1], "end": [626, 60], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_nnnorm_prod", "code": "@[simp]\ntheorem op_nnnorm_prod (f : E \u2192L[\ud835\udd5c] F\u2097) (g : E \u2192L[\ud835\udd5c] G\u2097) : \u2016f.prod g\u2016\u208a = \u2016(f, g)\u2016\u208a", "start": [629, 1], "end": [631, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.prod\u2097\u1d62", "code": "def prod\u2097\u1d62 (R : Type*) [Semiring R] [Module R F\u2097] [Module R G\u2097] [ContinuousConstSMul R F\u2097]\n    [ContinuousConstSMul R G\u2097] [SMulCommClass \ud835\udd5c R F\u2097] [SMulCommClass \ud835\udd5c R G\u2097] :\n    (E \u2192L[\ud835\udd5c] F\u2097) \u00d7 (E \u2192L[\ud835\udd5c] G\u2097) \u2243\u2097\u1d62[R] E \u2192L[\ud835\udd5c] F\u2097 \u00d7 G\u2097 :=\n  \u27e8prod\u2097 R, fun \u27e8f, g\u27e9 => op_norm_prod f g\u27e9", "start": [634, 1], "end": [638, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_subsingleton", "code": "@[simp, nontriviality]\ntheorem op_norm_subsingleton [Subsingleton E] : \u2016f\u2016 = 0", "start": [643, 1], "end": [648, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isBigOWith_id", "code": "theorem isBigOWith_id (l : Filter E) : IsBigOWith \u2016f\u2016 l f fun x => x", "start": [661, 1], "end": [662, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isBigO_id", "code": "theorem isBigO_id (l : Filter E) : f =O[l] fun x => x", "start": [665, 1], "end": [666, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isBigOWith_comp", "code": "theorem isBigOWith_comp [RingHomIsometric \u03c3\u2082\u2083] {\u03b1 : Type*} (g : F \u2192SL[\u03c3\u2082\u2083] G) (f : \u03b1 \u2192 F)\n    (l : Filter \u03b1) : IsBigOWith \u2016g\u2016 l (fun x' => g (f x')) f", "start": [669, 1], "end": [671, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isBigO_comp", "code": "theorem isBigO_comp [RingHomIsometric \u03c3\u2082\u2083] {\u03b1 : Type*} (g : F \u2192SL[\u03c3\u2082\u2083] G) (f : \u03b1 \u2192 F)\n    (l : Filter \u03b1) : (fun x' => g (f x')) =O[l] f", "start": [674, 1], "end": [676, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isBigOWith_sub", "code": "theorem isBigOWith_sub (f : E \u2192SL[\u03c3\u2081\u2082] F) (l : Filter E) (x : E) :\n    IsBigOWith \u2016f\u2016 l (fun x' => f (x' - x)) fun x' => x' - x", "start": [679, 1], "end": [681, 24], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isBigO_sub", "code": "theorem isBigO_sub (f : E \u2192SL[\u03c3\u2081\u2082] F) (l : Filter E) (x : E) :\n    (fun x' => f (x' - x)) =O[l] fun x' => x' - x", "start": [684, 1], "end": [686, 20], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.norm_toContinuousLinearMap_le", "code": "theorem norm_toContinuousLinearMap_le (f : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] F) : \u2016f.toContinuousLinearMap\u2016 \u2264 1", "start": [695, 1], "end": [696, 72], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mkContinuous_norm_le", "code": "theorem mkContinuous_norm_le (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F) {C : \u211d} (hC : 0 \u2264 C) (h : \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) :\n    \u2016f.mkContinuous C h\u2016 \u2264 C", "start": [703, 1], "end": [707, 46], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mkContinuous_norm_le'", "code": "theorem mkContinuous_norm_le' (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F) {C : \u211d} (h : \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) :\n    \u2016f.mkContinuous C h\u2016 \u2264 max C 0", "start": [710, 1], "end": [715, 80], "kind": "commanddeclaration"}, {"full_name": "LinearMap.norm_mkContinuous\u2082_aux", "code": "lemma norm_mkContinuous\u2082_aux (f : E \u2192\u209b\u2097[\u03c3\u2081\u2083] F \u2192\u209b\u2097[\u03c3\u2082\u2083] G) (C : \u211d)\n    (h : \u2200 x y, \u2016f x y\u2016 \u2264 C * \u2016x\u2016 * \u2016y\u2016) (x : E) :\n    \u2016(f x).mkContinuous (C * \u2016x\u2016) (h x)\u2016 \u2264 max C 0 * \u2016x\u2016 :=\n  (mkContinuous_norm_le' (f x) (h x)).trans_eq <| by\n    rw [max_mul_of_nonneg _ _ (norm_nonneg x), zero_mul]", "start": [720, 1], "end": [724, 57], "kind": "mathlibtacticlemma"}, {"full_name": "LinearMap.mkContinuousOfExistsBound\u2082", "code": "def mkContinuousOfExistsBound\u2082 (f : E \u2192\u209b\u2097[\u03c3\u2081\u2083] F \u2192\u209b\u2097[\u03c3\u2082\u2083] G)\n    (h : \u2203 C, \u2200 x y, \u2016f x y\u2016 \u2264 C * \u2016x\u2016 * \u2016y\u2016) : E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G :=\n  LinearMap.mkContinuousOfExistsBound\n    { toFun := fun x => (f x).mkContinuousOfExistsBound <| let \u27e8C, hC\u27e9 := h; \u27e8C * \u2016x\u2016, hC x\u27e9\n      map_add' := fun x y => by\n        ext z\n        rw [ContinuousLinearMap.add_apply, mkContinuousOfExistsBound_apply,\n          mkContinuousOfExistsBound_apply, mkContinuousOfExistsBound_apply, map_add, add_apply]\n      map_smul' := fun c x => by\n        ext z\n        rw [ContinuousLinearMap.smul_apply, mkContinuousOfExistsBound_apply,\n          mkContinuousOfExistsBound_apply, map_smul\u209b\u2097, smul_apply] } <|\n    let \u27e8C, hC\u27e9 := h; \u27e8max C 0, norm_mkContinuous\u2082_aux f C hC\u27e9", "start": [726, 1], "end": [744, 63], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mkContinuous\u2082", "code": "def mkContinuous\u2082 (f : E \u2192\u209b\u2097[\u03c3\u2081\u2083] F \u2192\u209b\u2097[\u03c3\u2082\u2083] G) (C : \u211d) (hC : \u2200 x y, \u2016f x y\u2016 \u2264 C * \u2016x\u2016 * \u2016y\u2016) :\n    E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G :=\n  mkContinuousOfExistsBound\u2082 f \u27e8C, hC\u27e9", "start": [746, 1], "end": [752, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mkContinuous\u2082_apply", "code": "@[simp]\ntheorem mkContinuous\u2082_apply (f : E \u2192\u209b\u2097[\u03c3\u2081\u2083] F \u2192\u209b\u2097[\u03c3\u2082\u2083] G) {C : \u211d}\n    (hC : \u2200 x y, \u2016f x y\u2016 \u2264 C * \u2016x\u2016 * \u2016y\u2016) (x : E) (y : F) : f.mkContinuous\u2082 C hC x y = f x y", "start": [755, 1], "end": [758, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mkContinuous\u2082_norm_le'", "code": "theorem mkContinuous\u2082_norm_le' (f : E \u2192\u209b\u2097[\u03c3\u2081\u2083] F \u2192\u209b\u2097[\u03c3\u2082\u2083] G) {C : \u211d}\n    (hC : \u2200 x y, \u2016f x y\u2016 \u2264 C * \u2016x\u2016 * \u2016y\u2016) : \u2016f.mkContinuous\u2082 C hC\u2016 \u2264 max C 0", "start": [761, 1], "end": [763, 89], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mkContinuous\u2082_norm_le", "code": "theorem mkContinuous\u2082_norm_le (f : E \u2192\u209b\u2097[\u03c3\u2081\u2083] F \u2192\u209b\u2097[\u03c3\u2082\u2083] G) {C : \u211d} (h0 : 0 \u2264 C)\n    (hC : \u2200 x y, \u2016f x y\u2016 \u2264 C * \u2016x\u2016 * \u2016y\u2016) : \u2016f.mkContinuous\u2082 C hC\u2016 \u2264 C", "start": [766, 1], "end": [768, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.flip", "code": "def flip (f : E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G) : F \u2192SL[\u03c3\u2082\u2083] E \u2192SL[\u03c3\u2081\u2083] G :=\n  LinearMap.mkContinuous\u2082\n    (LinearMap.mk\u2082'\u209b\u2097 \u03c3\u2082\u2083 \u03c3\u2081\u2083 (fun y x => f x y) (fun x y z => (f z).map_add x y)\n      (fun c y x => (f x).map_smul\u209b\u2097 c y) (fun z x y => by simp only [f.map_add, add_apply])\n        (fun c y x => by simp only [f.map_smul\u209b\u2097, smul_apply]))\n    \u2016f\u2016 fun y x => (f.le_op_norm\u2082 x y).trans_eq <| by simp only [mul_right_comm]", "start": [777, 1], "end": [787, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.le_norm_flip", "code": "private theorem le_norm_flip (f : E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G) : \u2016f\u2016 \u2264 \u2016flip f\u2016", "start": [792, 1], "end": [795, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.flip_apply", "code": "@[simp]\ntheorem flip_apply (f : E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G) (x : E) (y : F) : f.flip y x = f x y", "start": [797, 1], "end": [799, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.flip_flip", "code": "@[simp]\ntheorem flip_flip (f : E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G) : f.flip.flip = f", "start": [802, 1], "end": [805, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_flip", "code": "@[simp]\ntheorem op_norm_flip (f : E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G) : \u2016f.flip\u2016 = \u2016f\u2016", "start": [808, 1], "end": [810, 85], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.flip_add", "code": "@[simp]\ntheorem flip_add (f g : E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G) : (f + g).flip = f.flip + g.flip", "start": [813, 1], "end": [815, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.flip_smul", "code": "@[simp]\ntheorem flip_smul (c : \ud835\udd5c\u2083) (f : E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G) : (c \u2022 f).flip = c \u2022 f.flip", "start": [818, 1], "end": [820, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.flip\u2097\u1d62'", "code": "def flip\u2097\u1d62' : (E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G) \u2243\u2097\u1d62[\ud835\udd5c\u2083] F \u2192SL[\u03c3\u2082\u2083] E \u2192SL[\u03c3\u2081\u2083] G where\n  toFun := flip\n  invFun := flip\n  map_add' := flip_add\n  map_smul' := flip_smul\n  left_inv := flip_flip\n  right_inv := flip_flip\n  norm_map' := op_norm_flip", "start": [825, 1], "end": [835, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.flip\u2097\u1d62'_symm", "code": "@[simp]\ntheorem flip\u2097\u1d62'_symm : (flip\u2097\u1d62' E F G \u03c3\u2082\u2083 \u03c3\u2081\u2083).symm = flip\u2097\u1d62' F E G \u03c3\u2081\u2083 \u03c3\u2082\u2083", "start": [840, 1], "end": [842, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_flip\u2097\u1d62'", "code": "@[simp]\ntheorem coe_flip\u2097\u1d62' : \u21d1(flip\u2097\u1d62' E F G \u03c3\u2082\u2083 \u03c3\u2081\u2083) = flip", "start": [845, 1], "end": [847, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.flip\u2097\u1d62", "code": "def flip\u2097\u1d62 : (E \u2192L[\ud835\udd5c] F\u2097 \u2192L[\ud835\udd5c] G\u2097) \u2243\u2097\u1d62[\ud835\udd5c] F\u2097 \u2192L[\ud835\udd5c] E \u2192L[\ud835\udd5c] G\u2097 where\n  toFun := flip\n  invFun := flip\n  map_add' := flip_add\n  map_smul' := flip_smul\n  left_inv := flip_flip\n  right_inv := flip_flip\n  norm_map' := op_norm_flip", "start": [852, 1], "end": [862, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.flip\u2097\u1d62_symm", "code": "@[simp]\ntheorem flip\u2097\u1d62_symm : (flip\u2097\u1d62 \ud835\udd5c E F\u2097 G\u2097).symm = flip\u2097\u1d62 \ud835\udd5c F\u2097 E G\u2097", "start": [867, 1], "end": [869, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_flip\u2097\u1d62", "code": "@[simp]\ntheorem coe_flip\u2097\u1d62 : \u21d1(flip\u2097\u1d62 \ud835\udd5c E F\u2097 G\u2097) = flip", "start": [872, 1], "end": [874, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.apply'", "code": "def apply' : E \u2192SL[\u03c3\u2081\u2082] (E \u2192SL[\u03c3\u2081\u2082] F) \u2192L[\ud835\udd5c\u2082] F :=\n  flip (id \ud835\udd5c\u2082 (E \u2192SL[\u03c3\u2081\u2082] F))", "start": [879, 1], "end": [884, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.apply_apply'", "code": "@[simp]\ntheorem apply_apply' (v : E) (f : E \u2192SL[\u03c3\u2081\u2082] F) : apply' F \u03c3\u2081\u2082 v f = f v", "start": [889, 1], "end": [891, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.apply", "code": "def apply : E \u2192L[\ud835\udd5c] (E \u2192L[\ud835\udd5c] F\u2097) \u2192L[\ud835\udd5c] F\u2097 :=\n  flip (id \ud835\udd5c (E \u2192L[\ud835\udd5c] F\u2097))", "start": [896, 1], "end": [901, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.apply_apply", "code": "@[simp]\ntheorem apply_apply (v : E) (f : E \u2192L[\ud835\udd5c] F\u2097) : apply \ud835\udd5c F\u2097 v f = f v", "start": [906, 1], "end": [908, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compSL", "code": "def compSL : (F \u2192SL[\u03c3\u2082\u2083] G) \u2192L[\ud835\udd5c\u2083] (E \u2192SL[\u03c3\u2081\u2082] F) \u2192SL[\u03c3\u2082\u2083] E \u2192SL[\u03c3\u2081\u2083] G :=\n  LinearMap.mkContinuous\u2082\n    (LinearMap.mk\u2082'\u209b\u2097 (RingHom.id \ud835\udd5c\u2083) \u03c3\u2082\u2083 comp add_comp smul_comp comp_add fun c f g => by\n      ext\n      simp only [ContinuousLinearMap.map_smul\u209b\u2097, coe_smul', coe_comp', Function.comp_apply,\n        Pi.smul_apply])\n    1 fun f g => by simpa only [one_mul] using op_norm_comp_le f g", "start": [915, 1], "end": [922, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_compSL_le", "code": "theorem norm_compSL_le : \u2016compSL E F G \u03c3\u2081\u2082 \u03c3\u2082\u2083\u2016 \u2264 1", "start": [929, 1], "end": [930, 50], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compSL_apply", "code": "@[simp]\ntheorem compSL_apply (f : F \u2192SL[\u03c3\u2082\u2083] G) (g : E \u2192SL[\u03c3\u2081\u2082] F) : compSL E F G \u03c3\u2081\u2082 \u03c3\u2082\u2083 f g = f.comp g", "start": [935, 1], "end": [937, 6], "kind": "commanddeclaration"}, {"full_name": "Continuous.const_clm_comp", "code": "theorem _root_.Continuous.const_clm_comp {X} [TopologicalSpace X] {f : X \u2192 E \u2192SL[\u03c3\u2081\u2082] F}\n    (hf : Continuous f) (g : F \u2192SL[\u03c3\u2082\u2083] G) :\n    Continuous (fun x => g.comp (f x) : X \u2192 E \u2192SL[\u03c3\u2081\u2083] G)", "start": [940, 1], "end": [943, 46], "kind": "commanddeclaration"}, {"full_name": "Continuous.clm_comp_const", "code": "theorem _root_.Continuous.clm_comp_const {X} [TopologicalSpace X] {g : X \u2192 F \u2192SL[\u03c3\u2082\u2083] G}\n    (hg : Continuous g) (f : E \u2192SL[\u03c3\u2081\u2082] F) :\n    Continuous (fun x => (g x).comp f : X \u2192 E \u2192SL[\u03c3\u2081\u2083] G)", "start": [947, 1], "end": [951, 49], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compL", "code": "def compL : (F\u2097 \u2192L[\ud835\udd5c] G\u2097) \u2192L[\ud835\udd5c] (E \u2192L[\ud835\udd5c] F\u2097) \u2192L[\ud835\udd5c] E \u2192L[\ud835\udd5c] G\u2097 :=\n  compSL E F\u2097 G\u2097 (RingHom.id \ud835\udd5c) (RingHom.id \ud835\udd5c)", "start": [956, 1], "end": [958, 47], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_compL_le", "code": "theorem norm_compL_le : \u2016compL \ud835\udd5c E F\u2097 G\u2097\u2016 \u2264 1", "start": [965, 1], "end": [966, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compL_apply", "code": "@[simp]\ntheorem compL_apply (f : F\u2097 \u2192L[\ud835\udd5c] G\u2097) (g : E \u2192L[\ud835\udd5c] F\u2097) : compL \ud835\udd5c E F\u2097 G\u2097 f g = f.comp g", "start": [969, 1], "end": [971, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.precompR", "code": "@[simps! apply]\ndef precompR (L : E \u2192L[\ud835\udd5c] F\u2097 \u2192L[\ud835\udd5c] G\u2097) : E \u2192L[\ud835\udd5c] (E\u2097 \u2192L[\ud835\udd5c] F\u2097) \u2192L[\ud835\udd5c] E\u2097 \u2192L[\ud835\udd5c] G\u2097 :=\n  (compL \ud835\udd5c E\u2097 F\u2097 G\u2097).comp L", "start": [976, 1], "end": [979, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.precompL", "code": "def precompL (L : E \u2192L[\ud835\udd5c] F\u2097 \u2192L[\ud835\udd5c] G\u2097) : (E\u2097 \u2192L[\ud835\udd5c] E) \u2192L[\ud835\udd5c] F\u2097 \u2192L[\ud835\udd5c] E\u2097 \u2192L[\ud835\udd5c] G\u2097 :=\n  (precompR E\u2097 (flip L)).flip", "start": [982, 1], "end": [984, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_precompR_le", "code": "theorem norm_precompR_le (L : E \u2192L[\ud835\udd5c] F\u2097 \u2192L[\ud835\udd5c] G\u2097) : \u2016precompR E\u2097 L\u2016 \u2264 \u2016L\u2016", "start": [991, 1], "end": [995, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_precompL_le", "code": "theorem norm_precompL_le (L : E \u2192L[\ud835\udd5c] F\u2097 \u2192L[\ud835\udd5c] G\u2097) : \u2016precompL E\u2097 L\u2016 \u2264 \u2016L\u2016", "start": [1002, 1], "end": [1004, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.prodMapL", "code": "def prodMapL : (M\u2081 \u2192L[\ud835\udd5c] M\u2082) \u00d7 (M\u2083 \u2192L[\ud835\udd5c] M\u2084) \u2192L[\ud835\udd5c] M\u2081 \u00d7 M\u2083 \u2192L[\ud835\udd5c] M\u2082 \u00d7 M\u2084 :=\n  ContinuousLinearMap.copy\n    (have \u03a6\u2081 : (M\u2081 \u2192L[\ud835\udd5c] M\u2082) \u2192L[\ud835\udd5c] M\u2081 \u2192L[\ud835\udd5c] M\u2082 \u00d7 M\u2084 :=\n      ContinuousLinearMap.compL \ud835\udd5c M\u2081 M\u2082 (M\u2082 \u00d7 M\u2084) (ContinuousLinearMap.inl \ud835\udd5c M\u2082 M\u2084)\n    have \u03a6\u2082 : (M\u2083 \u2192L[\ud835\udd5c] M\u2084) \u2192L[\ud835\udd5c] M\u2083 \u2192L[\ud835\udd5c] M\u2082 \u00d7 M\u2084 :=\n      ContinuousLinearMap.compL \ud835\udd5c M\u2083 M\u2084 (M\u2082 \u00d7 M\u2084) (ContinuousLinearMap.inr \ud835\udd5c M\u2082 M\u2084)\n    have \u03a6\u2081' :=\n      (ContinuousLinearMap.compL \ud835\udd5c (M\u2081 \u00d7 M\u2083) M\u2081 (M\u2082 \u00d7 M\u2084)).flip (ContinuousLinearMap.fst \ud835\udd5c M\u2081 M\u2083)\n    have \u03a6\u2082' :=\n      (ContinuousLinearMap.compL \ud835\udd5c (M\u2081 \u00d7 M\u2083) M\u2083 (M\u2082 \u00d7 M\u2084)).flip (ContinuousLinearMap.snd \ud835\udd5c M\u2081 M\u2083)\n    have \u03a8\u2081 : (M\u2081 \u2192L[\ud835\udd5c] M\u2082) \u00d7 (M\u2083 \u2192L[\ud835\udd5c] M\u2084) \u2192L[\ud835\udd5c] M\u2081 \u2192L[\ud835\udd5c] M\u2082 :=\n      ContinuousLinearMap.fst \ud835\udd5c (M\u2081 \u2192L[\ud835\udd5c] M\u2082) (M\u2083 \u2192L[\ud835\udd5c] M\u2084)\n    have \u03a8\u2082 : (M\u2081 \u2192L[\ud835\udd5c] M\u2082) \u00d7 (M\u2083 \u2192L[\ud835\udd5c] M\u2084) \u2192L[\ud835\udd5c] M\u2083 \u2192L[\ud835\udd5c] M\u2084 :=\n      ContinuousLinearMap.snd \ud835\udd5c (M\u2081 \u2192L[\ud835\udd5c] M\u2082) (M\u2083 \u2192L[\ud835\udd5c] M\u2084)\n    \u03a6\u2081' \u2218L \u03a6\u2081 \u2218L \u03a8\u2081 + \u03a6\u2082' \u2218L \u03a6\u2082 \u2218L \u03a8\u2082)\n    (fun p : (M\u2081 \u2192L[\ud835\udd5c] M\u2082) \u00d7 (M\u2083 \u2192L[\ud835\udd5c] M\u2084) => p.1.prodMap p.2) (by\n      apply funext\n      rintro \u27e8\u03c6, \u03c8\u27e9\n      refine' ContinuousLinearMap.ext fun \u27e8x\u2081, x\u2082\u27e9 => _\n      repeat first | rw [add_apply] | rw [comp_apply] | rw [flip_apply] | rw [compL_apply]\n      simp only [coe_prodMap', Prod_map, coe_fst', inl_apply, coe_snd', inr_apply, Prod.mk_add_mk,\n        add_zero, zero_add])", "start": [1018, 1], "end": [1053, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.prodMapL_apply", "code": "@[simp]\ntheorem prodMapL_apply (p : (M\u2081 \u2192L[\ud835\udd5c] M\u2082) \u00d7 (M\u2083 \u2192L[\ud835\udd5c] M\u2084)) :\n    ContinuousLinearMap.prodMapL \ud835\udd5c M\u2081 M\u2082 M\u2083 M\u2084 p = p.1.prodMap p.2", "start": [1058, 1], "end": [1061, 6], "kind": "commanddeclaration"}, {"full_name": "Continuous.prod_mapL", "code": "theorem _root_.Continuous.prod_mapL {f : X \u2192 M\u2081 \u2192L[\ud835\udd5c] M\u2082} {g : X \u2192 M\u2083 \u2192L[\ud835\udd5c] M\u2084} (hf : Continuous f)\n    (hg : Continuous g) : Continuous fun x => (f x).prodMap (g x)", "start": [1066, 1], "end": [1068, 59], "kind": "commanddeclaration"}, {"full_name": "Continuous.prod_map_equivL", "code": "theorem _root_.Continuous.prod_map_equivL {f : X \u2192 M\u2081 \u2243L[\ud835\udd5c] M\u2082} {g : X \u2192 M\u2083 \u2243L[\ud835\udd5c] M\u2084}\n    (hf : Continuous fun x => (f x : M\u2081 \u2192L[\ud835\udd5c] M\u2082)) (hg : Continuous fun x => (g x : M\u2083 \u2192L[\ud835\udd5c] M\u2084)) :\n    Continuous fun x => ((f x).prod (g x) : M\u2081 \u00d7 M\u2083 \u2192L[\ud835\udd5c] M\u2082 \u00d7 M\u2084)", "start": [1071, 1], "end": [1074, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.prod_mapL", "code": "theorem _root_.ContinuousOn.prod_mapL {f : X \u2192 M\u2081 \u2192L[\ud835\udd5c] M\u2082} {g : X \u2192 M\u2083 \u2192L[\ud835\udd5c] M\u2084} {s : Set X}\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => (f x).prodMap (g x)) s", "start": [1077, 1], "end": [1080, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.prod_map_equivL", "code": "theorem _root_.ContinuousOn.prod_map_equivL {f : X \u2192 M\u2081 \u2243L[\ud835\udd5c] M\u2082} {g : X \u2192 M\u2083 \u2243L[\ud835\udd5c] M\u2084} {s : Set X}\n    (hf : ContinuousOn (fun x => (f x : M\u2081 \u2192L[\ud835\udd5c] M\u2082)) s)\n    (hg : ContinuousOn (fun x => (g x : M\u2083 \u2192L[\ud835\udd5c] M\u2084)) s) :\n    ContinuousOn (fun x => ((f x).prod (g x) : M\u2081 \u00d7 M\u2083 \u2192L[\ud835\udd5c] M\u2082 \u00d7 M\u2084)) s", "start": [1083, 1], "end": [1087, 69], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mul", "code": "def mul : \ud835\udd5c' \u2192L[\ud835\udd5c] \ud835\udd5c' \u2192L[\ud835\udd5c] \ud835\udd5c' :=\n  (LinearMap.mul \ud835\udd5c \ud835\udd5c').mkContinuous\u2082 1 fun x y => by simpa using norm_mul_le x y", "start": [1100, 1], "end": [1102, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mul_apply'", "code": "@[simp]\ntheorem mul_apply' (x y : \ud835\udd5c') : mul \ud835\udd5c \ud835\udd5c' x y = x * y", "start": [1105, 1], "end": [1107, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_mul_apply_le", "code": "@[simp]\ntheorem op_norm_mul_apply_le (x : \ud835\udd5c') : \u2016mul \ud835\udd5c \ud835\udd5c' x\u2016 \u2264 \u2016x\u2016", "start": [1110, 1], "end": [1112, 53], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_mul_le", "code": "theorem op_norm_mul_le : \u2016mul \ud835\udd5c \ud835\udd5c'\u2016 \u2264 1", "start": [1115, 1], "end": [1116, 50], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.Lmul", "code": "def _root_.NonUnitalAlgHom.Lmul : \ud835\udd5c' \u2192\u2099\u2090[\ud835\udd5c] \ud835\udd5c' \u2192L[\ud835\udd5c] \ud835\udd5c' :=\n  { mul \ud835\udd5c \ud835\udd5c' with\n    map_mul' := fun _ _ \u21a6 ext fun _ \u21a6 mul_assoc _ _ _\n    map_zero' := ext fun _ \u21a6 zero_mul _ }", "start": [1119, 1], "end": [1130, 42], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_Lmul", "code": "@[simp]\ntheorem _root_.NonUnitalAlgHom.coe_Lmul : \u21d1(NonUnitalAlgHom.Lmul \ud835\udd5c \ud835\udd5c') = mul \ud835\udd5c \ud835\udd5c'", "start": [1133, 1], "end": [1135, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mulLeftRight", "code": "def mulLeftRight : \ud835\udd5c' \u2192L[\ud835\udd5c] \ud835\udd5c' \u2192L[\ud835\udd5c] \ud835\udd5c' \u2192L[\ud835\udd5c] \ud835\udd5c' :=\n  ((compL \ud835\udd5c \ud835\udd5c' \ud835\udd5c' \ud835\udd5c').comp (mul \ud835\udd5c \ud835\udd5c').flip).flip.comp (mul \ud835\udd5c \ud835\udd5c')", "start": [1137, 1], "end": [1141, 65], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mulLeftRight_apply", "code": "@[simp]\ntheorem mulLeftRight_apply (x y z : \ud835\udd5c') : mulLeftRight \ud835\udd5c \ud835\udd5c' x y z = x * z * y", "start": [1144, 1], "end": [1146, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_mulLeftRight_apply_apply_le", "code": "theorem op_norm_mulLeftRight_apply_apply_le (x y : \ud835\udd5c') : \u2016mulLeftRight \ud835\udd5c \ud835\udd5c' x y\u2016 \u2264 \u2016x\u2016 * \u2016y\u2016", "start": [1149, 1], "end": [1154, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_mulLeftRight_apply_le", "code": "theorem op_norm_mulLeftRight_apply_le (x : \ud835\udd5c') : \u2016mulLeftRight \ud835\udd5c \ud835\udd5c' x\u2016 \u2264 \u2016x\u2016", "start": [1157, 1], "end": [1158, 82], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_mulLeftRight_le", "code": "theorem op_norm_mulLeftRight_le : \u2016mulLeftRight \ud835\udd5c \ud835\udd5c'\u2016 \u2264 1", "start": [1165, 1], "end": [1166, 100], "kind": "commanddeclaration"}, {"full_name": "RegularNormedAlgebra", "code": "class _root_.RegularNormedAlgebra : Prop :=\n  \n  isometry_mul' : Isometry (mul \ud835\udd5c \ud835\udd5c')", "start": [1169, 1], "end": [1179, 38], "kind": "commanddeclaration"}, {"full_name": "NormedAlgebra.instRegularNormedAlgebra", "code": "instance _root_.NormedAlgebra.instRegularNormedAlgebra {\ud835\udd5c \ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c]\n    [SeminormedRing \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormOneClass \ud835\udd5c'] : RegularNormedAlgebra \ud835\udd5c \ud835\udd5c'  where\n  isometry_mul' := AddMonoidHomClass.isometry_of_norm (mul \ud835\udd5c \ud835\udd5c') <|\n    fun x => le_antisymm (op_norm_mul_apply_le _ _ _) <| by\n      convert ratio_le_op_norm ((mul \ud835\udd5c \ud835\udd5c') x) (1 : \ud835\udd5c')\n      simp [norm_one]", "start": [1181, 1], "end": [1187, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isometry_mul", "code": "lemma isometry_mul : Isometry (mul \ud835\udd5c \ud835\udd5c') :=\n  RegularNormedAlgebra.isometry_mul'", "start": [1191, 1], "end": [1192, 37], "kind": "mathlibtacticlemma"}, {"full_name": "ContinuousLinearMap.op_norm_mul_apply", "code": "@[simp]\nlemma op_norm_mul_apply (x : \ud835\udd5c') : \u2016mul \ud835\udd5c \ud835\udd5c' x\u2016 = \u2016x\u2016 :=\n  (AddMonoidHomClass.isometry_iff_norm (mul \ud835\udd5c \ud835\udd5c')).mp (isometry_mul \ud835\udd5c \ud835\udd5c') x", "start": [1194, 1], "end": [1196, 76], "kind": "mathlibtacticlemma"}, {"full_name": "ContinuousLinearMap.op_nnnorm_mul_apply", "code": "@[simp]\nlemma op_nnnorm_mul_apply (x : \ud835\udd5c') : \u2016mul \ud835\udd5c \ud835\udd5c' x\u2016\u208a = \u2016x\u2016\u208a :=\n  Subtype.ext <| op_norm_mul_apply \ud835\udd5c \ud835\udd5c' x", "start": [1199, 1], "end": [1201, 42], "kind": "mathlibtacticlemma"}, {"full_name": "ContinuousLinearMap.mul\u2097\u1d62", "code": "def mul\u2097\u1d62 : \ud835\udd5c' \u2192\u2097\u1d62[\ud835\udd5c] \ud835\udd5c' \u2192L[\ud835\udd5c] \ud835\udd5c' where\n  toLinearMap := mul \ud835\udd5c \ud835\udd5c'\n  norm_map' x := op_norm_mul_apply \ud835\udd5c \ud835\udd5c' x", "start": [1203, 1], "end": [1207, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_mul\u2097\u1d62", "code": "@[simp]\ntheorem coe_mul\u2097\u1d62 : \u21d1(mul\u2097\u1d62 \ud835\udd5c \ud835\udd5c') = mul \ud835\udd5c \ud835\udd5c'", "start": [1210, 1], "end": [1212, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.lsmul", "code": "def lsmul : \ud835\udd5c' \u2192L[\ud835\udd5c] E \u2192L[\ud835\udd5c] E :=\n  ((Algebra.lsmul \ud835\udd5c \ud835\udd5c E).toLinearMap : \ud835\udd5c' \u2192\u2097[\ud835\udd5c] E \u2192\u2097[\ud835\udd5c] E).mkContinuous\u2082 1 fun c x => by\n    simpa only [one_mul] using norm_smul_le c x", "start": [1225, 1], "end": [1228, 48], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.lsmul_apply", "code": "@[simp]\ntheorem lsmul_apply (c : \ud835\udd5c') (x : E) : lsmul \ud835\udd5c \ud835\udd5c' c x = c \u2022 x", "start": [1231, 1], "end": [1233, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_toSpanSingleton", "code": "theorem norm_toSpanSingleton (x : E) : \u2016toSpanSingleton \ud835\udd5c x\u2016 = \u2016x\u2016", "start": [1238, 1], "end": [1243, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_lsmul_apply_le", "code": "theorem op_norm_lsmul_apply_le (x : \ud835\udd5c') : \u2016(lsmul \ud835\udd5c \ud835\udd5c' x : E \u2192L[\ud835\udd5c] E)\u2016 \u2264 \u2016x\u2016", "start": [1248, 1], "end": [1249, 83], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_lsmul_le", "code": "theorem op_norm_lsmul_le : \u2016(lsmul \ud835\udd5c \ud835\udd5c' : \ud835\udd5c' \u2192L[\ud835\udd5c] E \u2192L[\ud835\udd5c] E)\u2016 \u2264 1", "start": [1252, 1], "end": [1256, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_restrictScalars", "code": "@[simp]\ntheorem norm_restrictScalars (f : E \u2192L[\ud835\udd5c] F\u2097) : \u2016f.restrictScalars \ud835\udd5c'\u2016 = \u2016f\u2016", "start": [1269, 1], "end": [1272, 65], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.restrictScalarsIsometry", "code": "def restrictScalarsIsometry : (E \u2192L[\ud835\udd5c] F\u2097) \u2192\u2097\u1d62[\ud835\udd5c''] E \u2192L[\ud835\udd5c'] F\u2097 :=\n  \u27e8restrictScalars\u2097 \ud835\udd5c E F\u2097 \ud835\udd5c' \ud835\udd5c'', norm_restrictScalars\u27e9", "start": [1280, 1], "end": [1282, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_restrictScalarsIsometry", "code": "@[simp]\ntheorem coe_restrictScalarsIsometry :\n    \u21d1(restrictScalarsIsometry \ud835\udd5c E F\u2097 \ud835\udd5c' \ud835\udd5c'') = restrictScalars \ud835\udd5c'", "start": [1287, 1], "end": [1290, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.restrictScalarsIsometry_toLinearMap", "code": "@[simp]\ntheorem restrictScalarsIsometry_toLinearMap :\n    (restrictScalarsIsometry \ud835\udd5c E F\u2097 \ud835\udd5c' \ud835\udd5c'').toLinearMap = restrictScalars\u2097 \ud835\udd5c E F\u2097 \ud835\udd5c' \ud835\udd5c''", "start": [1293, 1], "end": [1296, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.restrictScalarsL", "code": "def restrictScalarsL : (E \u2192L[\ud835\udd5c] F\u2097) \u2192L[\ud835\udd5c''] E \u2192L[\ud835\udd5c'] F\u2097 :=\n  (restrictScalarsIsometry \ud835\udd5c E F\u2097 \ud835\udd5c' \ud835\udd5c'').toContinuousLinearMap", "start": [1303, 1], "end": [1305, 64], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_restrictScalarsL", "code": "@[simp]\ntheorem coe_restrictScalarsL : (restrictScalarsL \ud835\udd5c E F\u2097 \ud835\udd5c' \ud835\udd5c'' : (E \u2192L[\ud835\udd5c] F\u2097) \u2192\u2097[\ud835\udd5c''] E \u2192L[\ud835\udd5c'] F\u2097) =\n    restrictScalars\u2097 \ud835\udd5c E F\u2097 \ud835\udd5c' \ud835\udd5c''", "start": [1310, 1], "end": [1313, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_restrict_scalarsL'", "code": "@[simp]\ntheorem coe_restrict_scalarsL' : \u21d1(restrictScalarsL \ud835\udd5c E F\u2097 \ud835\udd5c' \ud835\udd5c'') = restrictScalars \ud835\udd5c'", "start": [1316, 1], "end": [1318, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.norm_subtypeL_le", "code": "theorem norm_subtypeL_le (K : Submodule \ud835\udd5c E) : \u2016K.subtypeL\u2016 \u2264 1", "start": [1327, 1], "end": [1328, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.lipschitz", "code": "protected theorem lipschitz : LipschitzWith \u2016(e : E \u2192SL[\u03c3\u2081\u2082] F)\u2016\u208a e", "start": [1344, 1], "end": [1345, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.isBigO_comp", "code": "theorem isBigO_comp {\u03b1 : Type*} (f : \u03b1 \u2192 E) (l : Filter \u03b1) : (fun x' => e (f x')) =O[l] f", "start": [1348, 1], "end": [1349, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.isBigO_sub", "code": "theorem isBigO_sub (l : Filter E) (x : E) : (fun x' => e (x' - x)) =O[l] fun x' => x' - x", "start": [1352, 1], "end": [1353, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.isBigO_comp_rev", "code": "theorem isBigO_comp_rev {\u03b1 : Type*} (f : \u03b1 \u2192 E) (l : Filter \u03b1) : f =O[l] fun x' => e (f x')", "start": [1362, 1], "end": [1363, 68], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.isBigO_sub_rev", "code": "theorem isBigO_sub_rev (l : Filter E) (x : E) : (fun x' => x' - x) =O[l] fun x' => e (x' - x)", "start": [1366, 1], "end": [1367, 24], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.bilinearComp", "code": "def bilinearComp (f : E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G) (gE : E' \u2192SL[\u03c3\u2081'] E) (gF : F' \u2192SL[\u03c3\u2082'] F) :\n    E' \u2192SL[\u03c3\u2081\u2083'] F' \u2192SL[\u03c3\u2082\u2083'] G :=\n  ((f.comp gE).flip.comp gF).flip", "start": [1383, 1], "end": [1387, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.bilinearComp_apply", "code": "@[simp]\ntheorem bilinearComp_apply (f : E \u2192SL[\u03c3\u2081\u2083] F \u2192SL[\u03c3\u2082\u2083] G) (gE : E' \u2192SL[\u03c3\u2081'] E) (gF : F' \u2192SL[\u03c3\u2082'] F)\n    (x : E') (y : F') : f.bilinearComp gE gF x y = f (gE x) (gF y)", "start": [1390, 1], "end": [1393, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.deriv\u2082", "code": "def deriv\u2082 (f : E \u2192L[\ud835\udd5c] F\u2097 \u2192L[\ud835\udd5c] G\u2097) : E \u00d7 F\u2097 \u2192L[\ud835\udd5c] E \u00d7 F\u2097 \u2192L[\ud835\udd5c] G\u2097 :=\n  f.bilinearComp (fst _ _ _) (snd _ _ _) + f.flip.bilinearComp (snd _ _ _) (fst _ _ _)", "start": [1398, 1], "end": [1401, 87], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_deriv\u2082", "code": "@[simp]\ntheorem coe_deriv\u2082 (f : E \u2192L[\ud835\udd5c] F\u2097 \u2192L[\ud835\udd5c] G\u2097) (p : E \u00d7 F\u2097) :\n    \u21d1(f.deriv\u2082 p) = fun q : E \u00d7 F\u2097 => f p.1 q.2 + f q.1 p.2", "start": [1404, 1], "end": [1407, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_add_add", "code": "theorem map_add_add (f : E \u2192L[\ud835\udd5c] F\u2097 \u2192L[\ud835\udd5c] G\u2097) (x x' : E) (y y' : F\u2097) :\n    f (x + x') (y + y') = f x y + f.deriv\u2082 (x, y) (x', y') + f x' y'", "start": [1410, 1], "end": [1413, 7], "kind": "commanddeclaration"}, {"full_name": "LinearMap.bound_of_shell", "code": "theorem bound_of_shell [RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F) {\u03b5 C : \u211d} (\u03b5_pos : 0 < \u03b5) {c : \ud835\udd5c}\n    (hc : 1 < \u2016c\u2016) (hf : \u2200 x, \u03b5 / \u2016c\u2016 \u2264 \u2016x\u2016 \u2192 \u2016x\u2016 < \u03b5 \u2192 \u2016f x\u2016 \u2264 C * \u2016x\u2016) (x : E) :\n    \u2016f x\u2016 \u2264 C * \u2016x\u2016", "start": [1435, 1], "end": [1440, 100], "kind": "commanddeclaration"}, {"full_name": "LinearMap.bound_of_ball_bound", "code": "theorem bound_of_ball_bound {r : \u211d} (r_pos : 0 < r) (c : \u211d) (f : E \u2192\u2097[\ud835\udd5c] F\u2097)\n    (h : \u2200 z \u2208 Metric.ball (0 : E) r, \u2016f z\u2016 \u2264 c) : \u2203 C, \u2200 z : E, \u2016f z\u2016 \u2264 C * \u2016z\u2016", "start": [1443, 1], "end": [1458, 37], "kind": "commanddeclaration"}, {"full_name": "LinearMap.antilipschitz_of_comap_nhds_le", "code": "theorem antilipschitz_of_comap_nhds_le [h : RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F)\n    (hf : (\ud835\udcdd 0).comap f \u2264 \ud835\udcdd 0) : \u2203 K, AntilipschitzWith K f", "start": [1461, 1], "end": [1481, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_zero_iff", "code": "theorem op_norm_zero_iff [RingHomIsometric \u03c3\u2081\u2082] : \u2016f\u2016 = 0 \u2194 f = 0", "start": [1492, 1], "end": [1501, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_id", "code": "@[simp]\ntheorem norm_id [Nontrivial E] : \u2016id \ud835\udd5c E\u2016 = 1", "start": [1504, 1], "end": [1509, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.normOneClass", "code": "instance normOneClass [Nontrivial E] : NormOneClass (E \u2192L[\ud835\udd5c] E) :=\n  \u27e8norm_id\u27e9", "start": [1512, 1], "end": [1513, 12], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toNormedAddCommGroup", "code": "instance toNormedAddCommGroup [RingHomIsometric \u03c3\u2081\u2082] : NormedAddCommGroup (E \u2192SL[\u03c3\u2081\u2082] F) :=\n  NormedAddCommGroup.ofSeparation fun f => (op_norm_zero_iff f).mp", "start": [1516, 1], "end": [1519, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toNormedRing", "code": "instance toNormedRing : NormedRing (E \u2192L[\ud835\udd5c] E) :=\n  { ContinuousLinearMap.toNormedAddCommGroup, ContinuousLinearMap.toSemiNormedRing with }", "start": [1522, 1], "end": [1524, 90], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.homothety_norm", "code": "theorem homothety_norm [RingHomIsometric \u03c3\u2081\u2082] [Nontrivial E] (f : E \u2192SL[\u03c3\u2081\u2082] F) {a : \u211d}\n    (hf : \u2200 x, \u2016f x\u2016 = a * \u2016x\u2016) : \u2016f\u2016 = a", "start": [1529, 1], "end": [1535, 61], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.antilipschitz_of_embedding", "code": "theorem antilipschitz_of_embedding (f : E \u2192L[\ud835\udd5c] F\u2097) (hf : Embedding f) :\n    \u2203 K, AntilipschitzWith K f", "start": [1540, 1], "end": [1544, 87], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ofMemClosureImageCoeBounded", "code": "@[simps! (config := { fullyApplied := false }) apply]\ndef ofMemClosureImageCoeBounded (f : E' \u2192 F) {s : Set (E' \u2192SL[\u03c3\u2081\u2082] F)} (hs : IsBounded s)\n    (hf : f \u2208 closure (((\u2191) : (E' \u2192SL[\u03c3\u2081\u2082] F) \u2192 E' \u2192 F) '' s)) : E' \u2192SL[\u03c3\u2081\u2082] F := by\n  refine' (linearMapOfMemClosureRangeCoe f _).mkContinuousOfExistsBound _\n  \u00b7 refine' closure_mono (image_subset_iff.2 fun g _ => _) hf\n    exact \u27e8g, rfl\u27e9\n  \u00b7 rcases isBounded_iff_forall_norm_le.1 hs with \u27e8C, hC\u27e9\n    have : \u2200 x, IsClosed { g : E' \u2192 F | \u2016g x\u2016 \u2264 C * \u2016x\u2016 } := fun x =>\n      isClosed_Iic.preimage (@continuous_apply E' (fun _ => F) _ x).norm\n    refine' \u27e8C, fun x => (this x).closure_subset_iff.2 (image_subset_iff.2 fun g hg => _) hf\u27e9\n    exact g.le_of_op_norm_le (hC _ hg) _", "start": [1555, 1], "end": [1571, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ofTendstoOfBoundedRange", "code": "@[simps! (config := { fullyApplied := false }) apply]\ndef ofTendstoOfBoundedRange {\u03b1 : Type*} {l : Filter \u03b1} [l.NeBot] (f : E' \u2192 F)\n    (g : \u03b1 \u2192 E' \u2192SL[\u03c3\u2081\u2082] F) (hf : Tendsto (fun a x => g a x) l (\ud835\udcdd f))\n    (hg : IsBounded (Set.range g)) : E' \u2192SL[\u03c3\u2081\u2082] F :=\n  ofMemClosureImageCoeBounded f hg <| mem_closure_of_tendsto hf <|\n    eventually_of_forall fun _ => mem_image_of_mem _ <| Set.mem_range_self _", "start": [1574, 1], "end": [1582, 77], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.tendsto_of_tendsto_pointwise_of_cauchySeq", "code": "theorem tendsto_of_tendsto_pointwise_of_cauchySeq {f : \u2115 \u2192 E' \u2192SL[\u03c3\u2081\u2082] F} {g : E' \u2192SL[\u03c3\u2081\u2082] F}\n    (hg : Tendsto (fun n x => f n x) atTop (\ud835\udcdd g)) (hf : CauchySeq f) : Tendsto f atTop (\ud835\udcdd g)", "start": [1585, 1], "end": [1604, 61], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isCompact_closure_image_coe_of_bounded", "code": "theorem isCompact_closure_image_coe_of_bounded [ProperSpace F] {s : Set (E' \u2192SL[\u03c3\u2081\u2082] F)}\n    (hb : IsBounded s) : IsCompact (closure (((\u2191) : (E' \u2192SL[\u03c3\u2081\u2082] F) \u2192 E' \u2192 F) '' s))", "start": [1626, 1], "end": [1634, 79], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isCompact_image_coe_of_bounded_of_closed_image", "code": "theorem isCompact_image_coe_of_bounded_of_closed_image [ProperSpace F] {s : Set (E' \u2192SL[\u03c3\u2081\u2082] F)}\n    (hb : IsBounded s) (hc : IsClosed (((\u2191) : (E' \u2192SL[\u03c3\u2081\u2082] F) \u2192 E' \u2192 F) '' s)) :\n    IsCompact (((\u2191) : (E' \u2192SL[\u03c3\u2081\u2082] F) \u2192 E' \u2192 F) '' s)", "start": [1637, 1], "end": [1645, 60], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isClosed_image_coe_of_bounded_of_weak_closed", "code": "theorem isClosed_image_coe_of_bounded_of_weak_closed {s : Set (E' \u2192SL[\u03c3\u2081\u2082] F)} (hb : IsBounded s)\n    (hc : \u2200 f : E' \u2192SL[\u03c3\u2081\u2082] F,\n      (\u21d1f : E' \u2192 F) \u2208 closure (((\u2191) : (E' \u2192SL[\u03c3\u2081\u2082] F) \u2192 E' \u2192 F) '' s) \u2192 f \u2208 s) :\n    IsClosed (((\u2191) : (E' \u2192SL[\u03c3\u2081\u2082] F) \u2192 E' \u2192 F) '' s)", "start": [1648, 1], "end": [1658, 92], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isCompact_image_coe_of_bounded_of_weak_closed", "code": "theorem isCompact_image_coe_of_bounded_of_weak_closed [ProperSpace F] {s : Set (E' \u2192SL[\u03c3\u2081\u2082] F)}\n    (hb : IsBounded s) (hc : \u2200 f : E' \u2192SL[\u03c3\u2081\u2082] F,\n      (\u21d1f : E' \u2192 F) \u2208 closure (((\u2191) : (E' \u2192SL[\u03c3\u2081\u2082] F) \u2192 E' \u2192 F) '' s) \u2192 f \u2208 s) :\n    IsCompact (((\u2191) : (E' \u2192SL[\u03c3\u2081\u2082] F) \u2192 E' \u2192 F) '' s)", "start": [1661, 1], "end": [1670, 55], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.is_weak_closed_closedBall", "code": "theorem is_weak_closed_closedBall (f\u2080 : E' \u2192SL[\u03c3\u2081\u2082] F) (r : \u211d) \u2983f : E' \u2192SL[\u03c3\u2081\u2082] F\u2984\n    (hf : \u21d1f \u2208 closure (((\u2191) : (E' \u2192SL[\u03c3\u2081\u2082] F) \u2192 E' \u2192 F) '' closedBall f\u2080 r)) :\n    f \u2208 closedBall f\u2080 r", "start": [1673, 1], "end": [1683, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isClosed_image_coe_closedBall", "code": "theorem isClosed_image_coe_closedBall (f\u2080 : E \u2192SL[\u03c3\u2081\u2082] F) (r : \u211d) :\n    IsClosed (((\u2191) : (E \u2192SL[\u03c3\u2081\u2082] F) \u2192 E \u2192 F) '' closedBall f\u2080 r)", "start": [1686, 1], "end": [1691, 101], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isCompact_image_coe_closedBall", "code": "theorem isCompact_image_coe_closedBall [ProperSpace F] (f\u2080 : E \u2192SL[\u03c3\u2081\u2082] F) (r : \u211d) :\n    IsCompact (((\u2191) : (E \u2192SL[\u03c3\u2081\u2082] F) \u2192 E \u2192 F) '' closedBall f\u2080 r)", "start": [1694, 1], "end": [1701, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.extend", "code": "def extend : F\u2097 \u2192SL[\u03c3\u2081\u2082] F :=\n  have cont := (uniformContinuous_uniformly_extend h_e h_dense f.uniformContinuous).continuous\n  have eq := uniformly_extend_of_ind h_e h_dense f.uniformContinuous\n  { toFun := (h_e.denseInducing h_dense).extend f\n    map_add' := by\n      refine' h_dense.induction_on\u2082 _ _\n      \u00b7 exact isClosed_eq (cont.comp continuous_add)\n          ((cont.comp continuous_fst).add (cont.comp continuous_snd))\n      \u00b7 intro x y\n        simp only [eq, \u2190 e.map_add]\n        exact f.map_add _ _\n    map_smul' := fun k => by\n      refine' fun b => h_dense.induction_on b _ _\n      \u00b7 exact isClosed_eq (cont.comp (continuous_const_smul _))\n          ((continuous_const_smul _).comp cont)\n      \u00b7 intro x\n        rw [\u2190 map_smul]\n        simp only [eq]\n        exact ContinuousLinearMap.map_smul\u209b\u2097 _ _ _\n    cont }", "start": [1714, 1], "end": [1737, 11], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.extend_eq", "code": "@[simp]\ntheorem extend_eq (x : E) : extend f e h_dense h_e (e x) = f x", "start": [1741, 1], "end": [1743, 63], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.extend_unique", "code": "theorem extend_unique (g : F\u2097 \u2192SL[\u03c3\u2081\u2082] F) (H : g.comp e = f) : extend f e h_dense h_e = g", "start": [1746, 1], "end": [1748, 87], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.extend_zero", "code": "@[simp]\ntheorem extend_zero : extend (0 : E \u2192SL[\u03c3\u2081\u2082] F) e h_dense h_e = 0", "start": [1751, 1], "end": [1753, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_extend_le", "code": "theorem op_norm_extend_le :\n    \u2016f.extend e h_dense (uniformEmbedding_of_bound _ h_e).toUniformInducing\u2016 \u2264 N * \u2016f\u2016", "start": [1762, 1], "end": [1781, 64], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.norm_toContinuousLinearMap", "code": "@[simp]\ntheorem norm_toContinuousLinearMap [Nontrivial E] [RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] F) :\n    \u2016f.toContinuousLinearMap\u2016 = 1", "start": [1794, 1], "end": [1797, 52], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.norm_toContinuousLinearMap_comp", "code": "theorem norm_toContinuousLinearMap_comp [RingHomIsometric \u03c3\u2081\u2082] (f : F \u2192\u209b\u2097\u1d62[\u03c3\u2082\u2083] G)\n    {g : E \u2192SL[\u03c3\u2081\u2082] F} : \u2016f.toContinuousLinearMap.comp g\u2016 = \u2016g\u2016", "start": [1802, 1], "end": [1807, 84], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_comp_linearIsometryEquiv", "code": "theorem op_norm_comp_linearIsometryEquiv (f : F \u2192SL[\u03c3\u2082\u2083] G) (g : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F) :\n    \u2016f.comp g.toLinearIsometry.toContinuousLinearMap\u2016 = \u2016f\u2016", "start": [1826, 1], "end": [1840, 62], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_smulRight_apply", "code": "@[simp]\ntheorem norm_smulRight_apply (c : E \u2192L[\ud835\udd5c] \ud835\udd5c) (f : F\u2097) : \u2016smulRight c f\u2016 = \u2016c\u2016 * \u2016f\u2016", "start": [1843, 1], "end": [1862, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.nnnorm_smulRight_apply", "code": "@[simp]\ntheorem nnnorm_smulRight_apply (c : E \u2192L[\ud835\udd5c] \ud835\udd5c) (f : F\u2097) : \u2016smulRight c f\u2016\u208a = \u2016c\u2016\u208a * \u2016f\u2016\u208a", "start": [1865, 1], "end": [1869, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.smulRightL", "code": "def smulRightL : (E \u2192L[\ud835\udd5c] \ud835\udd5c) \u2192L[\ud835\udd5c] F\u2097 \u2192L[\ud835\udd5c] E \u2192L[\ud835\udd5c] F\u2097 :=\n  LinearMap.mkContinuous\u2082\n    { toFun := smulRight\u2097\n      map_add' := fun c\u2081 c\u2082 => by\n        ext x\n        simp only [add_smul, coe_smulRight\u2097, add_apply, smulRight_apply, LinearMap.add_apply]\n      map_smul' := fun m c => by\n        ext x\n        simp only [smul_smul, coe_smulRight\u2097, Algebra.id.smul_eq_mul, coe_smul', smulRight_apply,\n          LinearMap.smul_apply, RingHom.id_apply, Pi.smul_apply] }\n    1 fun c x => by\n      simp only [coe_smulRight\u2097, one_mul, norm_smulRight_apply, LinearMap.coe_mk, AddHom.coe_mk,\n        le_refl]", "start": [1876, 1], "end": [1890, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_smulRightL_apply", "code": "@[simp]\ntheorem norm_smulRightL_apply (c : E \u2192L[\ud835\udd5c] \ud835\udd5c) (f : F\u2097) : \u2016smulRightL \ud835\udd5c E F\u2097 c f\u2016 = \u2016c\u2016 * \u2016f\u2016", "start": [1895, 1], "end": [1897, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_smulRightL", "code": "@[simp]\ntheorem norm_smulRightL (c : E \u2192L[\ud835\udd5c] \ud835\udd5c) [Nontrivial F\u2097] : \u2016smulRightL \ud835\udd5c E F\u2097 c\u2016 = \u2016c\u2016", "start": [1900, 1], "end": [1902, 62], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_mul", "code": "@[simp]\ntheorem op_norm_mul : \u2016mul \ud835\udd5c \ud835\udd5c'\u2016 = 1", "start": [1912, 1], "end": [1914, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_nnnorm_mul", "code": "@[simp]\ntheorem op_nnnorm_mul : \u2016mul \ud835\udd5c \ud835\udd5c'\u2016\u208a = 1", "start": [1917, 1], "end": [1919, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.op_norm_lsmul", "code": "@[simp]\ntheorem op_norm_lsmul [NormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' E]\n    [IsScalarTower \ud835\udd5c \ud835\udd5c' E] [Nontrivial E] : \u2016(lsmul \ud835\udd5c \ud835\udd5c' : \ud835\udd5c' \u2192L[\ud835\udd5c] E \u2192L[\ud835\udd5c] E)\u2016 = 1", "start": [1924, 1], "end": [1937, 26], "kind": "commanddeclaration"}, {"full_name": "Submodule.norm_subtypeL", "code": "theorem norm_subtypeL (K : Submodule \ud835\udd5c E) [Nontrivial K] : \u2016K.subtypeL\u2016 = 1", "start": [1947, 1], "end": [1948, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.antilipschitz", "code": "protected theorem antilipschitz (e : E \u2243SL[\u03c3\u2081\u2082] F) :\n    AntilipschitzWith \u2016(e.symm : F \u2192SL[\u03c3\u2082\u2081] E)\u2016\u208a e", "start": [1964, 1], "end": [1966, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.one_le_norm_mul_norm_symm", "code": "theorem one_le_norm_mul_norm_symm [RingHomIsometric \u03c3\u2081\u2082] [Nontrivial E] (e : E \u2243SL[\u03c3\u2081\u2082] F) :\n    1 \u2264 \u2016(e : E \u2192SL[\u03c3\u2081\u2082] F)\u2016 * \u2016(e.symm : F \u2192SL[\u03c3\u2082\u2081] E)\u2016", "start": [1969, 1], "end": [1973, 56], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.norm_pos", "code": "theorem norm_pos [RingHomIsometric \u03c3\u2081\u2082] [Nontrivial E] (e : E \u2243SL[\u03c3\u2081\u2082] F) :\n    0 < \u2016(e : E \u2192SL[\u03c3\u2081\u2082] F)\u2016", "start": [1976, 1], "end": [1978, 95], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.norm_symm_pos", "code": "theorem norm_symm_pos [RingHomIsometric \u03c3\u2081\u2082] [Nontrivial E] (e : E \u2243SL[\u03c3\u2081\u2082] F) :\n    0 < \u2016(e.symm : F \u2192SL[\u03c3\u2082\u2081] E)\u2016", "start": [1981, 1], "end": [1983, 90], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.nnnorm_symm_pos", "code": "theorem nnnorm_symm_pos [RingHomIsometric \u03c3\u2081\u2082] [Nontrivial E] (e : E \u2243SL[\u03c3\u2081\u2082] F) :\n    0 < \u2016(e.symm : F \u2192SL[\u03c3\u2082\u2081] E)\u2016\u208a", "start": [1986, 1], "end": [1988, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.subsingleton_or_norm_symm_pos", "code": "theorem subsingleton_or_norm_symm_pos [RingHomIsometric \u03c3\u2081\u2082] (e : E \u2243SL[\u03c3\u2081\u2082] F) :\n    Subsingleton E \u2228 0 < \u2016(e.symm : F \u2192SL[\u03c3\u2082\u2081] E)\u2016", "start": [1991, 1], "end": [1997, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.subsingleton_or_nnnorm_symm_pos", "code": "theorem subsingleton_or_nnnorm_symm_pos [RingHomIsometric \u03c3\u2081\u2082] (e : E \u2243SL[\u03c3\u2081\u2082] F) :\n    Subsingleton E \u2228 0 < \u2016(e.symm : F \u2192SL[\u03c3\u2082\u2081] E)\u2016\u208a", "start": [2000, 1], "end": [2002, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coord_norm", "code": "@[simp]\ntheorem coord_norm (x : E) (h : x \u2260 0) : \u2016coord \ud835\udd5c x h\u2016 = \u2016x\u2016\u207b\u00b9", "start": [2007, 1], "end": [2012, 72], "kind": "commanddeclaration"}, {"full_name": "IsCoercive", "code": "def IsCoercive [NormedAddCommGroup E] [NormedSpace \u211d E] (B : E \u2192L[\u211d] E \u2192L[\u211d] \u211d) : Prop :=\n  \u2203 C, 0 < C \u2227 \u2200 u, C * \u2016u\u2016 * \u2016u\u2016 \u2264 B u u", "start": [2021, 1], "end": [2025, 42], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.equicontinuous_TFAE", "code": "protected theorem NormedSpace.equicontinuous_TFAE : List.TFAE\n    [ EquicontinuousAt ((\u2191) \u2218 f) 0,\n      Equicontinuous ((\u2191) \u2218 f),\n      UniformEquicontinuous ((\u2191) \u2218 f),\n      \u2203 C, \u2200 i x, \u2016f i x\u2016 \u2264 C * \u2016x\u2016,\n      \u2203 C \u2265 0, \u2200 i x, \u2016f i x\u2016 \u2264 C * \u2016x\u2016,\n      \u2203 C, \u2200 i, \u2016f i\u2016 \u2264 C,\n      \u2203 C \u2265 0, \u2200 i, \u2016f i\u2016 \u2264 C,\n      BddAbove (Set.range (\u2016f \u00b7\u2016)),\n      (\u2a06 i, (\u2016f i\u2016\u208a : ENNReal)) < \u22a4 ]", "start": [2034, 1], "end": [2085, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Order/Lattice.lean", "imports": ["Mathlib/Analysis/Normed/Group/Basic.lean", "Mathlib/Topology/Order/Lattice.lean", "Mathlib/Algebra/Order/LatticeGroup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HasSolidNorm", "code": "class HasSolidNorm (\u03b1 : Type*) [NormedAddCommGroup \u03b1] [Lattice \u03b1] : Prop where\n  solid : \u2200 \u2983x y : \u03b1\u2984, |x| \u2264 |y| \u2192 \u2016x\u2016 \u2264 \u2016y\u2016", "start": [45, 1], "end": [49, 45], "kind": "commanddeclaration"}, {"full_name": "norm_le_norm_of_abs_le_abs", "code": "theorem norm_le_norm_of_abs_le_abs {a b : \u03b1} (h : |a| \u2264 |b|) : \u2016a\u2016 \u2264 \u2016b\u2016", "start": [54, 1], "end": [55, 23], "kind": "commanddeclaration"}, {"full_name": "LatticeOrderedAddCommGroup.isSolid_ball", "code": "theorem LatticeOrderedAddCommGroup.isSolid_ball (r : \u211d) :\n    LatticeOrderedAddCommGroup.IsSolid (Metric.ball (0 : \u03b1) r)", "start": [58, 1], "end": [61, 86], "kind": "commanddeclaration"}, {"full_name": "NormedLatticeAddCommGroup", "code": "class NormedLatticeAddCommGroup (\u03b1 : Type*) extends NormedAddCommGroup \u03b1, Lattice \u03b1, HasSolidNorm \u03b1\n  where\n  add_le_add_left : \u2200 a b : \u03b1, a \u2264 b \u2192 \u2200 c : \u03b1, c + a \u2264 c + b", "start": [70, 1], "end": [78, 62], "kind": "commanddeclaration"}, {"full_name": "Real.normedLatticeAddCommGroup", "code": "instance Real.normedLatticeAddCommGroup : NormedLatticeAddCommGroup \u211d where\n  add_le_add_left _ _ h _ := add_le_add le_rfl h", "start": [81, 1], "end": [82, 49], "kind": "commanddeclaration"}, {"full_name": "NormedLatticeAddCommGroup.toOrderedAddCommGroup", "code": "instance (priority := 100) NormedLatticeAddCommGroup.toOrderedAddCommGroup {\u03b1 : Type*}\n    [h : NormedLatticeAddCommGroup \u03b1] : OrderedAddCommGroup \u03b1 :=\n  { h with }", "start": [85, 1], "end": [89, 13], "kind": "commanddeclaration"}, {"full_name": "dual_solid", "code": "theorem dual_solid (a b : \u03b1) (h : b \u2293 -b \u2264 a \u2293 -a) : \u2016a\u2016 \u2264 \u2016b\u2016", "start": [96, 1], "end": [103, 83], "kind": "commanddeclaration"}, {"full_name": "OrderDual.normedLatticeAddCommGroup", "code": "instance (priority := 100) OrderDual.normedLatticeAddCommGroup : NormedLatticeAddCommGroup \u03b1\u1d52\u1d48 :=\n  { OrderDual.orderedAddCommGroup, OrderDual.normedAddCommGroup, OrderDual.lattice \u03b1 with\n    solid := dual_solid (\u03b1 := \u03b1) }", "start": [107, 1], "end": [112, 35], "kind": "commanddeclaration"}, {"full_name": "norm_abs_eq_norm", "code": "theorem norm_abs_eq_norm (a : \u03b1) : \u2016|a|\u2016 = \u2016a\u2016", "start": [114, 1], "end": [115, 62], "kind": "commanddeclaration"}, {"full_name": "norm_inf_sub_inf_le_add_norm", "code": "theorem norm_inf_sub_inf_le_add_norm (a b c d : \u03b1) : \u2016a \u2293 b - c \u2293 d\u2016 \u2264 \u2016a - c\u2016 + \u2016b - d\u2016", "start": [118, 1], "end": [129, 43], "kind": "commanddeclaration"}, {"full_name": "norm_sup_sub_sup_le_add_norm", "code": "theorem norm_sup_sub_sup_le_add_norm (a b c d : \u03b1) : \u2016a \u2294 b - c \u2294 d\u2016 \u2264 \u2016a - c\u2016 + \u2016b - d\u2016", "start": [132, 1], "end": [143, 43], "kind": "commanddeclaration"}, {"full_name": "norm_inf_le_add", "code": "theorem norm_inf_le_add (x y : \u03b1) : \u2016x \u2293 y\u2016 \u2264 \u2016x\u2016 + \u2016y\u2016", "start": [146, 1], "end": [148, 42], "kind": "commanddeclaration"}, {"full_name": "norm_sup_le_add", "code": "theorem norm_sup_le_add (x y : \u03b1) : \u2016x \u2294 y\u2016 \u2264 \u2016x\u2016 + \u2016y\u2016", "start": [151, 1], "end": [153, 42], "kind": "commanddeclaration"}, {"full_name": "NormedLatticeAddCommGroup.continuousInf", "code": "instance (priority := 100) NormedLatticeAddCommGroup.continuousInf : ContinuousInf \u03b1 := by\n  refine' \u27e8continuous_iff_continuousAt.2 fun q => tendsto_iff_norm_sub_tendsto_zero.2 <| _\u27e9\n  have : \u2200 p : \u03b1 \u00d7 \u03b1, \u2016p.1 \u2293 p.2 - q.1 \u2293 q.2\u2016 \u2264 \u2016p.1 - q.1\u2016 + \u2016p.2 - q.2\u2016 := fun _ =>\n    norm_inf_sub_inf_le_add_norm _ _ _ _\n  refine' squeeze_zero (fun e => norm_nonneg _) this _\n  convert ((continuous_fst.tendsto q).sub <| tendsto_const_nhds).norm.add\n    ((continuous_snd.tendsto q).sub <| tendsto_const_nhds).norm\n  simp", "start": [157, 1], "end": [166, 7], "kind": "commanddeclaration"}, {"full_name": "NormedLatticeAddCommGroup.continuousSup", "code": "instance (priority := 100) NormedLatticeAddCommGroup.continuousSup {\u03b1 : Type*}\n    [NormedLatticeAddCommGroup \u03b1] : ContinuousSup \u03b1 :=\n  OrderDual.continuousSup \u03b1\u1d52\u1d48", "start": [170, 1], "end": [172, 30], "kind": "commanddeclaration"}, {"full_name": "NormedLatticeAddCommGroup.toTopologicalLattice", "code": "instance (priority := 100) NormedLatticeAddCommGroup.toTopologicalLattice : TopologicalLattice \u03b1 :=\n  TopologicalLattice.mk", "start": [176, 1], "end": [180, 24], "kind": "commanddeclaration"}, {"full_name": "norm_abs_sub_abs", "code": "theorem norm_abs_sub_abs (a b : \u03b1) : \u2016|a| - |b|\u2016 \u2264 \u2016a - b\u2016", "start": [183, 1], "end": [184, 57], "kind": "commanddeclaration"}, {"full_name": "norm_sup_sub_sup_le_norm", "code": "theorem norm_sup_sub_sup_le_norm (x y z : \u03b1) : \u2016x \u2294 z - y \u2294 z\u2016 \u2264 \u2016x - y\u2016", "start": [187, 1], "end": [188, 39], "kind": "commanddeclaration"}, {"full_name": "norm_inf_sub_inf_le_norm", "code": "theorem norm_inf_sub_inf_le_norm (x y z : \u03b1) : \u2016x \u2293 z - y \u2293 z\u2016 \u2264 \u2016x - y\u2016", "start": [191, 1], "end": [192, 39], "kind": "commanddeclaration"}, {"full_name": "lipschitzWith_sup_right", "code": "theorem lipschitzWith_sup_right (z : \u03b1) : LipschitzWith 1 fun x => x \u2294 z", "start": [195, 1], "end": [198, 41], "kind": "commanddeclaration"}, {"full_name": "lipschitzWith_pos", "code": "theorem lipschitzWith_pos : LipschitzWith 1 (PosPart.pos : \u03b1 \u2192 \u03b1)", "start": [201, 1], "end": [202, 28], "kind": "commanddeclaration"}, {"full_name": "continuous_pos", "code": "theorem continuous_pos : Continuous (PosPart.pos : \u03b1 \u2192 \u03b1)", "start": [205, 1], "end": [206, 45], "kind": "commanddeclaration"}, {"full_name": "continuous_neg'", "code": "theorem continuous_neg' : Continuous (NegPart.neg : \u03b1 \u2192 \u03b1)", "start": [209, 1], "end": [210, 90], "kind": "commanddeclaration"}, {"full_name": "isClosed_nonneg", "code": "theorem isClosed_nonneg {E} [NormedLatticeAddCommGroup E] : IsClosed { x : E | 0 \u2264 x }", "start": [214, 1], "end": [220, 78], "kind": "commanddeclaration"}, {"full_name": "isClosed_le_of_isClosed_nonneg", "code": "theorem isClosed_le_of_isClosed_nonneg {G} [OrderedAddCommGroup G] [TopologicalSpace G]\n    [ContinuousSub G] (h : IsClosed { x : G | 0 \u2264 x }) :\n    IsClosed { p : G \u00d7 G | p.fst \u2264 p.snd }", "start": [225, 1], "end": [231, 64], "kind": "commanddeclaration"}, {"full_name": "NormedLatticeAddCommGroup.orderClosedTopology", "code": "instance (priority := 100) NormedLatticeAddCommGroup.orderClosedTopology {E}\n    [NormedLatticeAddCommGroup E] : OrderClosedTopology E :=\n  \u27e8isClosed_le_of_isClosed_nonneg isClosed_nonneg\u27e9", "start": [235, 1], "end": [237, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.log", "code": "noncomputable def log (x : \u2102) : \u2102 :=\n  x.abs.log + arg x * I", "start": [26, 1], "end": [30, 24], "kind": "commanddeclaration"}, {"full_name": "Complex.log_re", "code": "theorem log_re (x : \u2102) : x.log.re = x.abs.log", "start": [33, 1], "end": [33, 63], "kind": "commanddeclaration"}, {"full_name": "Complex.log_im", "code": "theorem log_im (x : \u2102) : x.log.im = x.arg", "start": [36, 1], "end": [36, 59], "kind": "commanddeclaration"}, {"full_name": "Complex.neg_pi_lt_log_im", "code": "theorem neg_pi_lt_log_im (x : \u2102) : -\u03c0 < (log x).im", "start": [39, 1], "end": [39, 91], "kind": "commanddeclaration"}, {"full_name": "Complex.log_im_le_pi", "code": "theorem log_im_le_pi (x : \u2102) : (log x).im \u2264 \u03c0", "start": [42, 1], "end": [42, 82], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_log", "code": "theorem exp_log {x : \u2102} (hx : x \u2260 0) : exp (log x) = x", "start": [45, 1], "end": [49, 71], "kind": "commanddeclaration"}, {"full_name": "Complex.range_exp", "code": "@[simp]\ntheorem range_exp : Set.range exp = {0}\u1d9c", "start": [52, 1], "end": [57, 58], "kind": "commanddeclaration"}, {"full_name": "Complex.log_exp", "code": "theorem log_exp {x : \u2102} (hx\u2081 : -\u03c0 < x.im) (hx\u2082 : x.im \u2264 \u03c0) : log (exp x) = x", "start": [60, 1], "end": [62, 70], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_inj_of_neg_pi_lt_of_le_pi", "code": "theorem exp_inj_of_neg_pi_lt_of_le_pi {x y : \u2102} (hx\u2081 : -\u03c0 < x.im) (hx\u2082 : x.im \u2264 \u03c0) (hy\u2081 : -\u03c0 < y.im)\n    (hy\u2082 : y.im \u2264 \u03c0) (hxy : exp x = exp y) : x = y", "start": [65, 1], "end": [67, 49], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_log", "code": "theorem ofReal_log {x : \u211d} (hx : 0 \u2264 x) : (x.log : \u2102) = log x", "start": [70, 1], "end": [72, 57], "kind": "commanddeclaration"}, {"full_name": "Complex.log_ofReal_re", "code": "theorem log_ofReal_re (x : \u211d) : (log (x : \u2102)).re = Real.log x", "start": [75, 1], "end": [75, 82], "kind": "commanddeclaration"}, {"full_name": "Complex.log_ofReal_mul", "code": "theorem log_ofReal_mul {r : \u211d} (hr : 0 < r) {x : \u2102} (hx : x \u2260 0) :\n    log (r * x) = Real.log r + log x", "start": [78, 1], "end": [82, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.log_mul_ofReal", "code": "theorem log_mul_ofReal (r : \u211d) (hr : 0 < r) (x : \u2102) (hx : x \u2260 0) :\n    log (x * r) = Real.log r + log x", "start": [85, 1], "end": [86, 89], "kind": "commanddeclaration"}, {"full_name": "Complex.log_zero", "code": "@[simp]\ntheorem log_zero : log 0 = 0", "start": [89, 1], "end": [90, 46], "kind": "commanddeclaration"}, {"full_name": "Complex.log_one", "code": "@[simp]\ntheorem log_one : log 1 = 0", "start": [93, 1], "end": [94, 45], "kind": "commanddeclaration"}, {"full_name": "Complex.log_neg_one", "code": "theorem log_neg_one : log (-1) = \u03c0 * I", "start": [97, 1], "end": [97, 56], "kind": "commanddeclaration"}, {"full_name": "Complex.log_I", "code": "theorem log_I : log I = \u03c0 / 2 * I", "start": [100, 1], "end": [100, 51], "kind": "commanddeclaration"}, {"full_name": "Complex.log_neg_I", "code": "theorem log_neg_I : log (-I) = -(\u03c0 / 2) * I", "start": [104, 1], "end": [104, 61], "kind": "commanddeclaration"}, {"full_name": "Complex.log_conj_eq_ite", "code": "theorem log_conj_eq_ite (x : \u2102) : log (conj x) = if x.arg = \u03c0 then log x else conj (log x)", "start": [108, 1], "end": [112, 49], "kind": "commanddeclaration"}, {"full_name": "Complex.log_conj", "code": "theorem log_conj (x : \u2102) (h : x.arg \u2260 \u03c0) : log (conj x) = conj (log x)", "start": [115, 1], "end": [116, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.log_inv_eq_ite", "code": "theorem log_inv_eq_ite (x : \u2102) : log x\u207b\u00b9 = if x.arg = \u03c0 then -conj (log x) else -log x", "start": [119, 1], "end": [130, 22], "kind": "commanddeclaration"}, {"full_name": "Complex.log_inv", "code": "theorem log_inv (x : \u2102) (hx : x.arg \u2260 \u03c0) : log x\u207b\u00b9 = -log x", "start": [133, 1], "end": [133, 97], "kind": "commanddeclaration"}, {"full_name": "Complex.two_pi_I_ne_zero", "code": "theorem two_pi_I_ne_zero : (2 * \u03c0 * I : \u2102) \u2260 0", "start": [136, 1], "end": [136, 91], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_eq_one_iff", "code": "theorem exp_eq_one_iff {x : \u2102} : exp x = 1 \u2194 \u2203 n : \u2124, x = n * (2 * \u03c0 * I)", "start": [140, 1], "end": [149, 53], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_eq_exp_iff_exp_sub_eq_one", "code": "theorem exp_eq_exp_iff_exp_sub_eq_one {x y : \u2102} : exp x = exp y \u2194 exp (x - y) = 1", "start": [152, 1], "end": [153, 50], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_eq_exp_iff_exists_int", "code": "theorem exp_eq_exp_iff_exists_int {x y : \u2102} : exp x = exp y \u2194 \u2203 n : \u2124, x = y + n * (2 * \u03c0 * I)", "start": [156, 1], "end": [157, 80], "kind": "commanddeclaration"}, {"full_name": "Complex.countable_preimage_exp", "code": "@[simp]\ntheorem countable_preimage_exp {s : Set \u2102} : (exp \u207b\u00b9' s).Countable \u2194 s.Countable", "start": [160, 1], "end": [173, 31], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.preimage_cexp", "code": "alias \u27e8_, _root_.Set.Countable.preimage_cexp\u27e9 := countable_preimage_exp", "start": [176, 1], "end": [176, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Complex.tendsto_log_nhdsWithin_im_neg_of_re_neg_of_im_zero", "code": "theorem tendsto_log_nhdsWithin_im_neg_of_re_neg_of_im_zero {z : \u2102} (hre : z.re < 0)\n    (him : z.im = 0) : Tendsto log (\ud835\udcdd[{ z : \u2102 | z.im < 0 }] z) (\ud835\udcdd <| Real.log (abs z) - \u03c0 * I)", "start": [179, 1], "end": [189, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousWithinAt_log_of_re_neg_of_im_zero", "code": "theorem continuousWithinAt_log_of_re_neg_of_im_zero {z : \u2102} (hre : z.re < 0) (him : z.im = 0) :\n    ContinuousWithinAt log { z : \u2102 | 0 \u2264 z.im } z", "start": [192, 1], "end": [201, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.tendsto_log_nhdsWithin_im_nonneg_of_re_neg_of_im_zero", "code": "theorem tendsto_log_nhdsWithin_im_nonneg_of_re_neg_of_im_zero {z : \u2102} (hre : z.re < 0)\n    (him : z.im = 0) : Tendsto log (\ud835\udcdd[{ z : \u2102 | 0 \u2264 z.im }] z) (\ud835\udcdd <| Real.log (abs z) + \u03c0 * I)", "start": [205, 1], "end": [208, 66], "kind": "commanddeclaration"}, {"full_name": "Complex.map_exp_comap_re_atBot", "code": "@[simp]\ntheorem map_exp_comap_re_atBot : map exp (comap re atBot) = \ud835\udcdd[\u2260] 0", "start": [211, 1], "end": [213, 63], "kind": "commanddeclaration"}, {"full_name": "Complex.map_exp_comap_re_atTop", "code": "@[simp]\ntheorem map_exp_comap_re_atTop : map exp (comap re atTop) = comap abs atTop", "start": [216, 1], "end": [219, 60], "kind": "commanddeclaration"}, {"full_name": "continuousAt_clog", "code": "theorem continuousAt_clog {x : \u2102} (h : 0 < x.re \u2228 x.im \u2260 0) : ContinuousAt log x", "start": [232, 1], "end": [241, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.clog", "code": "theorem _root_.Filter.Tendsto.clog {l : Filter \u03b1} {f : \u03b1 \u2192 \u2102} {x : \u2102} (h : Tendsto f l (\ud835\udcdd x))\n    (hx : 0 < x.re \u2228 x.im \u2260 0) : Tendsto (fun t => log (f t)) l (\ud835\udcdd <| log x)", "start": [244, 1], "end": [246, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.clog", "code": "nonrec\ntheorem _root_.ContinuousAt.clog {f : \u03b1 \u2192 \u2102} {x : \u03b1} (h\u2081 : ContinuousAt f x)\n    (h\u2082 : 0 < (f x).re \u2228 (f x).im \u2260 0) : ContinuousAt (fun t => log (f t)) x", "start": [251, 1], "end": [254, 13], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.clog", "code": "nonrec\ntheorem _root_.ContinuousWithinAt.clog {f : \u03b1 \u2192 \u2102} {s : Set \u03b1} {x : \u03b1}\n    (h\u2081 : ContinuousWithinAt f s x) (h\u2082 : 0 < (f x).re \u2228 (f x).im \u2260 0) :\n    ContinuousWithinAt (fun t => log (f t)) s x", "start": [257, 1], "end": [261, 13], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.clog", "code": "nonrec\ntheorem _root_.ContinuousOn.clog {f : \u03b1 \u2192 \u2102} {s : Set \u03b1} (h\u2081 : ContinuousOn f s)\n    (h\u2082 : \u2200 x \u2208 s, 0 < (f x).re \u2228 (f x).im \u2260 0) : ContinuousOn (fun t => log (f t)) s", "start": [264, 1], "end": [267, 27], "kind": "commanddeclaration"}, {"full_name": "Continuous.clog", "code": "nonrec\ntheorem _root_.Continuous.clog {f : \u03b1 \u2192 \u2102} (h\u2081 : Continuous f)\n    (h\u2082 : \u2200 x, 0 < (f x).re \u2228 (f x).im \u2260 0) : Continuous fun t => log (f t)", "start": [270, 1], "end": [273, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Ideal/LocalRing.lean", "imports": ["Mathlib/RingTheory/JacobsonIdeal.lean", "Mathlib/Algebra/Algebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/TFAE.lean", "Mathlib/Logic/Equiv/TransferInstance.lean", "Mathlib/RingTheory/Ideal/Operations.lean"], "premises": [{"full_name": "LocalRing", "code": "class LocalRing (R : Type u) [Semiring R] extends Nontrivial R : Prop where\n  of_is_unit_or_is_unit_of_add_one ::\n  \n  isUnit_or_isUnit_of_add_one {a b : R} (h : a + b = 1) : IsUnit a \u2228 IsUnit b", "start": [39, 1], "end": [45, 78], "kind": "commanddeclaration"}, {"full_name": "LocalRing.of_isUnit_or_isUnit_of_isUnit_add", "code": "theorem of_isUnit_or_isUnit_of_isUnit_add [Nontrivial R]\n    (h : \u2200 a b : R, IsUnit (a + b) \u2192 IsUnit a \u2228 IsUnit b) : LocalRing R", "start": [54, 1], "end": [56, 52], "kind": "commanddeclaration"}, {"full_name": "LocalRing.of_nonunits_add", "code": "theorem of_nonunits_add [Nontrivial R]\n    (h : \u2200 a b : R, a \u2208 nonunits R \u2192 b \u2208 nonunits R \u2192 a + b \u2208 nonunits R) : LocalRing R", "start": [59, 1], "end": [62, 90], "kind": "commanddeclaration"}, {"full_name": "LocalRing.of_unique_max_ideal", "code": "theorem of_unique_max_ideal (h : \u2203! I : Ideal R, I.IsMaximal) : LocalRing R", "start": [65, 1], "end": [77, 65], "kind": "commanddeclaration"}, {"full_name": "LocalRing.of_unique_nonzero_prime", "code": "theorem of_unique_nonzero_prime (h : \u2203! P : Ideal R, P \u2260 \u22a5 \u2227 Ideal.IsPrime P) : LocalRing R", "start": [80, 1], "end": [88, 68], "kind": "commanddeclaration"}, {"full_name": "LocalRing.isUnit_or_isUnit_of_isUnit_add", "code": "theorem isUnit_or_isUnit_of_isUnit_add {a b : R} (h : IsUnit (a + b)) : IsUnit a \u2228 IsUnit b", "start": [93, 1], "end": [96, 89], "kind": "commanddeclaration"}, {"full_name": "LocalRing.nonunits_add", "code": "theorem nonunits_add {a b : R} (ha : a \u2208 nonunits R) (hb : b \u2208 nonunits R) : a + b \u2208 nonunits R", "start": [99, 1], "end": [100, 66], "kind": "commanddeclaration"}, {"full_name": "LocalRing.maximalIdeal", "code": "def maximalIdeal : Ideal R where\n  carrier := nonunits R\n  zero_mem' := zero_mem_nonunits.2 <| zero_ne_one\n  add_mem' {_ _} hx hy := nonunits_add hx hy\n  smul_mem' _ _ := mul_mem_nonunits_right", "start": [105, 1], "end": [110, 42], "kind": "commanddeclaration"}, {"full_name": "LocalRing.maximalIdeal.isMaximal", "code": "instance maximalIdeal.isMaximal : (maximalIdeal R).IsMaximal := by\n  rw [Ideal.isMaximal_iff]\n  constructor\n  \u00b7 intro h\n    apply h\n    exact isUnit_one\n  \u00b7 intro I x _ hx H\n    erw [Classical.not_not] at hx\n    rcases hx with \u27e8u, rfl\u27e9\n    simpa using I.mul_mem_left (\u2191u\u207b\u00b9) H", "start": [113, 1], "end": [122, 40], "kind": "commanddeclaration"}, {"full_name": "LocalRing.maximal_ideal_unique", "code": "theorem maximal_ideal_unique : \u2203! I : Ideal R, I.IsMaximal", "start": [125, 1], "end": [127, 95], "kind": "commanddeclaration"}, {"full_name": "LocalRing.eq_maximalIdeal", "code": "theorem eq_maximalIdeal {I : Ideal R} (hI : I.IsMaximal) : I = maximalIdeal R", "start": [132, 1], "end": [133, 78], "kind": "commanddeclaration"}, {"full_name": "LocalRing.le_maximalIdeal", "code": "theorem le_maximalIdeal {J : Ideal R} (hJ : J \u2260 \u22a4) : J \u2264 maximalIdeal R", "start": [136, 1], "end": [138, 30], "kind": "commanddeclaration"}, {"full_name": "LocalRing.mem_maximalIdeal", "code": "@[simp]\ntheorem mem_maximalIdeal (x) : x \u2208 maximalIdeal R \u2194 x \u2208 nonunits R", "start": [141, 1], "end": [143, 10], "kind": "commanddeclaration"}, {"full_name": "LocalRing.isField_iff_maximalIdeal_eq", "code": "theorem isField_iff_maximalIdeal_eq : IsField R \u2194 maximalIdeal R = \u22a5", "start": [146, 1], "end": [149, 80], "kind": "commanddeclaration"}, {"full_name": "LocalRing.of_isUnit_or_isUnit_one_sub_self", "code": "theorem of_isUnit_or_isUnit_one_sub_self [Nontrivial R] (h : \u2200 a : R, IsUnit a \u2228 IsUnit (1 - a)) :\n    LocalRing R", "start": [162, 1], "end": [164, 58], "kind": "commanddeclaration"}, {"full_name": "LocalRing.isUnit_or_isUnit_one_sub_self", "code": "theorem isUnit_or_isUnit_one_sub_self (a : R) : IsUnit a \u2228 IsUnit (1 - a)", "start": [169, 1], "end": [170, 82], "kind": "commanddeclaration"}, {"full_name": "LocalRing.isUnit_of_mem_nonunits_one_sub_self", "code": "theorem isUnit_of_mem_nonunits_one_sub_self (a : R) (h : 1 - a \u2208 nonunits R) : IsUnit a", "start": [173, 1], "end": [174, 61], "kind": "commanddeclaration"}, {"full_name": "LocalRing.isUnit_one_sub_self_of_mem_nonunits", "code": "theorem isUnit_one_sub_self_of_mem_nonunits (a : R) (h : a \u2208 nonunits R) : IsUnit (1 - a)", "start": [177, 1], "end": [178, 60], "kind": "commanddeclaration"}, {"full_name": "LocalRing.of_surjective'", "code": "theorem of_surjective' [CommRing S] [Nontrivial S] (f : R \u2192+* S) (hf : Function.Surjective f) :\n    LocalRing S", "start": [181, 1], "end": [188, 24], "kind": "commanddeclaration"}, {"full_name": "LocalRing.jacobson_eq_maximalIdeal", "code": "theorem jacobson_eq_maximalIdeal (I : Ideal R) (h : I \u2260 \u22a4) :\n    I.jacobson = LocalRing.maximalIdeal R", "start": [191, 1], "end": [195, 101], "kind": "commanddeclaration"}, {"full_name": "IsLocalRingHom", "code": "class IsLocalRingHom [Semiring R] [Semiring S] (f : R \u2192+* S) : Prop where\n  \n  map_nonunit : \u2200 a, IsUnit (f a) \u2192 IsUnit a", "start": [202, 1], "end": [207, 45], "kind": "commanddeclaration"}, {"full_name": "isLocalRingHom_id", "code": "instance isLocalRingHom_id (R : Type*) [Semiring R] : IsLocalRingHom (RingHom.id R) where\n  map_nonunit _ := id", "start": [214, 1], "end": [215, 22], "kind": "commanddeclaration"}, {"full_name": "isUnit_map_iff", "code": "@[simp]\ntheorem isUnit_map_iff (f : R \u2192+* S) [IsLocalRingHom f] (a) : IsUnit (f a) \u2194 IsUnit a", "start": [218, 1], "end": [220, 47], "kind": "commanddeclaration"}, {"full_name": "map_mem_nonunits_iff", "code": "@[simp (high)]\ntheorem map_mem_nonunits_iff (f : R \u2192+* S) [IsLocalRingHom f] (a) :\n    f a \u2208 nonunits S \u2194 a \u2208 nonunits R", "start": [224, 1], "end": [227, 94], "kind": "commanddeclaration"}, {"full_name": "isLocalRingHom_comp", "code": "instance isLocalRingHom_comp (g : S \u2192+* T) (f : R \u2192+* S) [IsLocalRingHom g] [IsLocalRingHom f] :\n    IsLocalRingHom (g.comp f) where\n  map_nonunit a := IsLocalRingHom.map_nonunit a \u2218 IsLocalRingHom.map_nonunit (f a)", "start": [230, 1], "end": [232, 83], "kind": "commanddeclaration"}, {"full_name": "isLocalRingHom_equiv", "code": "instance isLocalRingHom_equiv (f : R \u2243+* S) : IsLocalRingHom (f : R \u2192+* S) where\n  map_nonunit a ha := by\n    convert RingHom.isUnit_map (f.symm : S \u2192+* R) ha\n    exact (RingEquiv.symm_apply_apply f a).symm", "start": [235, 1], "end": [238, 48], "kind": "commanddeclaration"}, {"full_name": "isUnit_of_map_unit", "code": "@[simp]\ntheorem isUnit_of_map_unit (f : R \u2192+* S) [IsLocalRingHom f] (a) (h : IsUnit (f a)) : IsUnit a", "start": [241, 1], "end": [243, 33], "kind": "commanddeclaration"}, {"full_name": "of_irreducible_map", "code": "theorem of_irreducible_map (f : R \u2192+* S) [h : IsLocalRingHom f] {x} (hfx : Irreducible (f x)) :\n    Irreducible x", "start": [246, 1], "end": [250, 82], "kind": "commanddeclaration"}, {"full_name": "isLocalRingHom_of_comp", "code": "theorem isLocalRingHom_of_comp (f : R \u2192+* S) (g : S \u2192+* T) [IsLocalRingHom (g.comp f)] :\n    IsLocalRingHom f", "start": [253, 1], "end": [255, 67], "kind": "commanddeclaration"}, {"full_name": "RingHom.domain_localRing", "code": "theorem RingHom.domain_localRing {R S : Type*} [CommSemiring R] [CommSemiring S] [H : LocalRing S]\n    (f : R \u2192+* S) [IsLocalRingHom f] : LocalRing R", "start": [258, 1], "end": [265, 31], "kind": "commanddeclaration"}, {"full_name": "map_nonunit", "code": "theorem map_nonunit (f : R \u2192+* S) [IsLocalRingHom f] (a : R) (h : a \u2208 maximalIdeal R) :\n    f a \u2208 maximalIdeal S", "start": [276, 1], "end": [280, 67], "kind": "commanddeclaration"}, {"full_name": "LocalRing.local_hom_TFAE", "code": "theorem local_hom_TFAE (f : R \u2192+* S) :\n    List.TFAE\n      [IsLocalRingHom f, f '' (maximalIdeal R).1 \u2286 maximalIdeal S,\n        (maximalIdeal R).map f \u2264 maximalIdeal S, maximalIdeal R \u2264 (maximalIdeal S).comap f,\n        (maximalIdeal S).comap f = maximalIdeal R]", "start": [291, 1], "end": [316, 14], "kind": "commanddeclaration"}, {"full_name": "LocalRing.of_surjective", "code": "theorem of_surjective [CommSemiring R] [LocalRing R] [CommSemiring S] [Nontrivial S] (f : R \u2192+* S)\n    [IsLocalRingHom f] (hf : Function.Surjective f) : LocalRing S", "start": [321, 1], "end": [330, 22], "kind": "commanddeclaration"}, {"full_name": "LocalRing.surjective_units_map_of_local_ringHom", "code": "theorem surjective_units_map_of_local_ringHom [CommRing R] [CommRing S] (f : R \u2192+* S)\n    (hf : Function.Surjective f) (h : IsLocalRingHom f) :\n    Function.Surjective (Units.map <| f.toMonoidHom)", "start": [333, 1], "end": [341, 11], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField", "code": "def ResidueField :=\n  R \u29f8 maximalIdeal R", "start": [348, 1], "end": [350, 21], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueFieldCommRing", "code": "instance ResidueFieldCommRing : CommRing (ResidueField R) :=\n  show CommRing (R \u29f8 maximalIdeal R) from inferInstance", "start": [354, 1], "end": [355, 56], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueFieldInhabited", "code": "instance ResidueFieldInhabited : Inhabited (ResidueField R) :=\n  show Inhabited (R \u29f8 maximalIdeal R) from inferInstance", "start": [357, 1], "end": [358, 57], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.field", "code": "noncomputable instance ResidueField.field : Field (ResidueField R) :=\n  Ideal.Quotient.field (maximalIdeal R)", "start": [360, 1], "end": [361, 40], "kind": "commanddeclaration"}, {"full_name": "LocalRing.residue", "code": "def residue : R \u2192+* ResidueField R :=\n  Ideal.Quotient.mk _", "start": [364, 1], "end": [366, 22], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.algebra", "code": "instance ResidueField.algebra : Algebra R (ResidueField R) :=\n  Ideal.Quotient.algebra _", "start": [369, 1], "end": [370, 27], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.algebraMap_eq", "code": "theorem ResidueField.algebraMap_eq : algebraMap R (ResidueField R) = residue R", "start": [373, 1], "end": [374, 6], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.lift", "code": "def lift {R S : Type*} [CommRing R] [LocalRing R] [Field S] (f : R \u2192+* S) [IsLocalRingHom f] :\n    LocalRing.ResidueField R \u2192+* S :=\n  Ideal.Quotient.lift _ f fun a ha =>\n    by_contradiction fun h => ha (isUnit_of_map_unit f a (isUnit_iff_ne_zero.mpr h))", "start": [385, 1], "end": [389, 85], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.lift_comp_residue", "code": "theorem lift_comp_residue {R S : Type*} [CommRing R] [LocalRing R] [Field S] (f : R \u2192+* S)\n    [IsLocalRingHom f] : (lift f).comp (residue R) = f", "start": [392, 1], "end": [394, 27], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.lift_residue_apply", "code": "@[simp]\ntheorem lift_residue_apply {R S : Type*} [CommRing R] [LocalRing R] [Field S] (f : R \u2192+* S)\n    [IsLocalRingHom f] (x) : lift f (residue R x) = f x", "start": [397, 1], "end": [400, 6], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.map", "code": "def map (f : R \u2192+* S) [IsLocalRingHom f] : ResidueField R \u2192+* ResidueField S :=\n  Ideal.Quotient.lift (maximalIdeal R) ((Ideal.Quotient.mk _).comp f) fun a ha => by\n    erw [Ideal.Quotient.eq_zero_iff_mem]\n    exact map_nonunit f a ha", "start": [403, 1], "end": [407, 29], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.map_id", "code": "@[simp]\ntheorem map_id :\n    LocalRing.ResidueField.map (RingHom.id R) = RingHom.id (LocalRing.ResidueField R)", "start": [410, 1], "end": [415, 57], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.map_comp", "code": "theorem map_comp (f : T \u2192+* R) (g : R \u2192+* S) [IsLocalRingHom f] [IsLocalRingHom g] :\n    LocalRing.ResidueField.map (g.comp f) =\n      (LocalRing.ResidueField.map g).comp (LocalRing.ResidueField.map f)", "start": [418, 1], "end": [423, 57], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.map_comp_residue", "code": "theorem map_comp_residue (f : R \u2192+* S) [IsLocalRingHom f] :\n    (ResidueField.map f).comp (residue R) = (residue S).comp f", "start": [426, 1], "end": [428, 6], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.map_residue", "code": "theorem map_residue (f : R \u2192+* S) [IsLocalRingHom f] (r : R) :\n    ResidueField.map f (residue R r) = residue S (f r)", "start": [431, 1], "end": [433, 6], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.map_id_apply", "code": "theorem map_id_apply (x : ResidueField R) : map (RingHom.id R) x = x", "start": [436, 1], "end": [437, 29], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.map_map", "code": "@[simp]\ntheorem map_map (f : R \u2192+* S) (g : S \u2192+* T) (x : ResidueField R) [IsLocalRingHom f]\n    [IsLocalRingHom g] : map g (map f x) = map (g.comp f) x", "start": [440, 1], "end": [443, 42], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.mapEquiv", "code": "@[simps apply]\ndef mapEquiv (f : R \u2243+* S) : LocalRing.ResidueField R \u2243+* LocalRing.ResidueField S where\n  toFun := map (f : R \u2192+* S)\n  invFun := map (f.symm : S \u2192+* R)\n  left_inv x := by simp only [map_map, RingEquiv.symm_comp, map_id, RingHom.id_apply]\n  right_inv x := by simp only [map_map, RingEquiv.comp_symm, map_id, RingHom.id_apply]\n  map_mul' := RingHom.map_mul _\n  map_add' := RingHom.map_add _", "start": [446, 1], "end": [454, 32], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.mapEquiv.symm", "code": "@[simp]\ntheorem mapEquiv.symm (f : R \u2243+* S) : (mapEquiv f).symm = mapEquiv f.symm", "start": [457, 1], "end": [459, 6], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.mapEquiv_trans", "code": "@[simp]\ntheorem mapEquiv_trans (e\u2081 : R \u2243+* S) (e\u2082 : S \u2243+* T) :\n    mapEquiv (e\u2081.trans e\u2082) = (mapEquiv e\u2081).trans (mapEquiv e\u2082)", "start": [462, 1], "end": [465, 74], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.mapEquiv_refl", "code": "@[simp]\ntheorem mapEquiv_refl : mapEquiv (RingEquiv.refl R) = RingEquiv.refl _", "start": [468, 1], "end": [470, 39], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.mapAut", "code": "@[simps]\ndef mapAut : RingAut R \u2192* RingAut (LocalRing.ResidueField R) where\n  toFun := mapEquiv\n  map_mul' e\u2081 e\u2082 := mapEquiv_trans e\u2082 e\u2081\n  map_one' := mapEquiv_refl", "start": [473, 1], "end": [479, 28], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ResidueField.residue_smul", "code": "@[simp]\ntheorem residue_smul (g : G) (r : R) : residue R (g \u2022 r) = g \u2022 residue R r", "start": [490, 1], "end": [492, 6], "kind": "commanddeclaration"}, {"full_name": "LocalRing.ker_eq_maximalIdeal", "code": "theorem ker_eq_maximalIdeal [Field K] (\u03c6 : R \u2192+* K) (h\u03c6 : Function.Surjective \u03c6) :\n    RingHom.ker \u03c6 = maximalIdeal R", "start": [499, 1], "end": [501, 74], "kind": "commanddeclaration"}, {"full_name": "LocalRing.isLocalRingHom_residue", "code": "theorem isLocalRingHom_residue : IsLocalRingHom (LocalRing.residue R)", "start": [504, 1], "end": [509, 23], "kind": "commanddeclaration"}, {"full_name": "LocalRing.maximalIdeal_eq_bot", "code": "theorem LocalRing.maximalIdeal_eq_bot {R : Type*} [Field R] : LocalRing.maximalIdeal R = \u22a5", "start": [530, 1], "end": [531, 63], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.localRing", "code": "@[reducible]\nprotected theorem localRing {A B : Type*} [CommSemiring A] [LocalRing A] [CommSemiring B]\n    (e : A \u2243+* B) : LocalRing B", "start": [536, 1], "end": [540, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/PolynomialAlgebra.lean", "imports": ["Mathlib/Data/Matrix/Basis.lean", "Mathlib/Data/Polynomial/AlgebraMap.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/MatrixAlgebra.lean", "Mathlib/Data/Matrix/DMatrix.lean"], "premises": [{"full_name": "PolyEquivTensor.toFunBilinear", "code": "@[simps! apply_apply]\ndef toFunBilinear : A \u2192\u2097[A] R[X] \u2192\u2097[R] A[X] :=\n  LinearMap.toSpanSingleton A _ (aeval (Polynomial.X : A[X])).toLinearMap", "start": [48, 1], "end": [55, 74], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.toFunBilinear_apply_eq_sum", "code": "theorem toFunBilinear_apply_eq_sum (a : A) (p : R[X]) :\n    toFunBilinear R A a p = p.sum fun n r => monomial n (a * algebraMap R A r)", "start": [58, 1], "end": [63, 39], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.toFunLinear", "code": "def toFunLinear : A \u2297[R] R[X] \u2192\u2097[R] A[X] :=\n  TensorProduct.lift (toFunBilinear R A)", "start": [66, 1], "end": [71, 41], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.toFunLinear_tmul_apply", "code": "@[simp]\ntheorem toFunLinear_tmul_apply (a : A) (p : R[X]) :\n    toFunLinear R A (a \u2297\u209c[R] p) = toFunBilinear R A a p", "start": [74, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.toFunLinear_mul_tmul_mul_aux_1", "code": "theorem toFunLinear_mul_tmul_mul_aux_1 (p : R[X]) (k : \u2115) (h : Decidable \u00acp.coeff k = 0) (a : A) :\n    ite (\u00accoeff p k = 0) (a * (algebraMap R A) (coeff p k)) 0 = a * (algebraMap R A) (coeff p k)", "start": [82, 1], "end": [84, 38], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.toFunLinear_mul_tmul_mul_aux_2", "code": "theorem toFunLinear_mul_tmul_mul_aux_2 (k : \u2115) (a\u2081 a\u2082 : A) (p\u2081 p\u2082 : R[X]) :\n    a\u2081 * a\u2082 * (algebraMap R A) ((p\u2081 * p\u2082).coeff k) =\n      (Finset.Nat.antidiagonal k).sum fun x =>\n        a\u2081 * (algebraMap R A) (coeff p\u2081 x.1) * (a\u2082 * (algebraMap R A) (coeff p\u2082 x.2))", "start": [87, 1], "end": [93, 79], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.toFunLinear_mul_tmul_mul", "code": "theorem toFunLinear_mul_tmul_mul (a\u2081 a\u2082 : A) (p\u2081 p\u2082 : R[X]) :\n    (toFunLinear R A) ((a\u2081 * a\u2082) \u2297\u209c[R] (p\u2081 * p\u2082)) =\n      (toFunLinear R A) (a\u2081 \u2297\u209c[R] p\u2081) * (toFunLinear R A) (a\u2082 \u2297\u209c[R] p\u2082)", "start": [96, 1], "end": [108, 77], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.toFunLinear_one_tmul_one", "code": "theorem toFunLinear_one_tmul_one :\n    toFunLinear R A (1 \u2297\u209c[R] 1) = 1", "start": [111, 1], "end": [113, 89], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.toFunAlgHom", "code": "def toFunAlgHom : A \u2297[R] R[X] \u2192\u2090[R] A[X] :=\n  algHomOfLinearMapTensorProduct (toFunLinear R A) (toFunLinear_mul_tmul_mul R A)\n    (toFunLinear_one_tmul_one R A)", "start": [116, 1], "end": [121, 35], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.toFunAlgHom_apply_tmul", "code": "@[simp]\ntheorem toFunAlgHom_apply_tmul (a : A) (p : R[X]) :\n    toFunAlgHom R A (a \u2297\u209c[R] p) = p.sum fun n r => monomial n (a * (algebraMap R A) r)", "start": [124, 1], "end": [127, 37], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.invFun", "code": "def invFun (p : A[X]) : A \u2297[R] R[X] :=\n  p.eval\u2082 (includeLeft : A \u2192\u2090[R] A \u2297[R] R[X]) ((1 : A) \u2297\u209c[R] (X : R[X]))", "start": [130, 1], "end": [136, 73], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.invFun_add", "code": "@[simp]\ntheorem invFun_add {p q} : invFun R A (p + q) = invFun R A p + invFun R A q", "start": [139, 1], "end": [141, 32], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.invFun_monomial", "code": "theorem invFun_monomial (n : \u2115) (a : A) :\n    invFun R A (monomial n a) = (a \u2297\u209c[R] 1) * 1 \u2297\u209c[R] X ^ n", "start": [144, 1], "end": [146, 21], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.left_inv", "code": "theorem left_inv (x : A \u2297 R[X]) : invFun R A ((toFunAlgHom R A) x) = x", "start": [149, 1], "end": [162, 51], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.right_inv", "code": "theorem right_inv (x : A[X]) : (toFunAlgHom R A) (invFun R A x) = x", "start": [165, 1], "end": [173, 11], "kind": "commanddeclaration"}, {"full_name": "PolyEquivTensor.equiv", "code": "def equiv : A \u2297[R] R[X] \u2243 A[X] where\n  toFun := toFunAlgHom R A\n  invFun := invFun R A\n  left_inv := left_inv R A\n  right_inv := right_inv R A", "start": [176, 1], "end": [184, 29], "kind": "commanddeclaration"}, {"full_name": "polyEquivTensor", "code": "def polyEquivTensor : A[X] \u2243\u2090[R] A \u2297[R] R[X] :=\n  AlgEquiv.symm { PolyEquivTensor.toFunAlgHom R A, PolyEquivTensor.equiv R A with }", "start": [191, 1], "end": [194, 84], "kind": "commanddeclaration"}, {"full_name": "polyEquivTensor_apply", "code": "@[simp]\ntheorem polyEquivTensor_apply (p : A[X]) :\n    polyEquivTensor R A p =\n      p.eval\u2082 (includeLeft : A \u2192\u2090[R] A \u2297[R] R[X]) ((1 : A) \u2297\u209c[R] (X : R[X]))", "start": [197, 1], "end": [201, 6], "kind": "commanddeclaration"}, {"full_name": "polyEquivTensor_symm_apply_tmul", "code": "@[simp]\ntheorem polyEquivTensor_symm_apply_tmul (a : A) (p : R[X]) :\n    (polyEquivTensor R A).symm (a \u2297\u209c p) = p.sum fun n r => monomial n (a * algebraMap R A r)", "start": [204, 1], "end": [207, 33], "kind": "commanddeclaration"}, {"full_name": "matPolyEquiv", "code": "noncomputable def matPolyEquiv : Matrix n n R[X] \u2243\u2090[R] (Matrix n n R)[X] :=\n  ((matrixEquivTensor R R[X] n).trans (Algebra.TensorProduct.comm R _ _)).trans\n    (polyEquivTensor R (Matrix n n R)).symm", "start": [216, 1], "end": [225, 44], "kind": "commanddeclaration"}, {"full_name": "matPolyEquiv_coeff_apply_aux_1", "code": "theorem matPolyEquiv_coeff_apply_aux_1 (i j : n) (k : \u2115) (x : R) :\n    matPolyEquiv (stdBasisMatrix i j <| monomial k x) = monomial k (stdBasisMatrix i j x)", "start": [230, 1], "end": [239, 42], "kind": "commanddeclaration"}, {"full_name": "matPolyEquiv_coeff_apply_aux_2", "code": "theorem matPolyEquiv_coeff_apply_aux_2 (i j : n) (p : R[X]) (k : \u2115) :\n    coeff (matPolyEquiv (stdBasisMatrix i j p)) k = stdBasisMatrix i j (coeff p k)", "start": [242, 1], "end": [252, 13], "kind": "commanddeclaration"}, {"full_name": "matPolyEquiv_coeff_apply", "code": "@[simp]\ntheorem matPolyEquiv_coeff_apply (m : Matrix n n R[X]) (k : \u2115) (i j : n) :\n    coeff (matPolyEquiv m) k i j = coeff (m i j) k", "start": [255, 1], "end": [268, 31], "kind": "commanddeclaration"}, {"full_name": "matPolyEquiv_symm_apply_coeff", "code": "@[simp]\ntheorem matPolyEquiv_symm_apply_coeff (p : (Matrix n n R)[X]) (i j : n) (k : \u2115) :\n    coeff (matPolyEquiv.symm p i j) k = coeff p k i j", "start": [271, 1], "end": [276, 39], "kind": "commanddeclaration"}, {"full_name": "matPolyEquiv_smul_one", "code": "theorem matPolyEquiv_smul_one (p : R[X]) :\n    matPolyEquiv (p \u2022 (1 : Matrix n n R[X])) = p.map (algebraMap R (Matrix n n R))", "start": [279, 1], "end": [284, 49], "kind": "commanddeclaration"}, {"full_name": "support_subset_support_matPolyEquiv", "code": "theorem support_subset_support_matPolyEquiv (m : Matrix n n R[X]) (i j : n) :\n    support (m i j) \u2286 support (matPolyEquiv m)", "start": [287, 1], "end": [294, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Preserves/Basic.lean", "imports": ["Mathlib/CategoryTheory/Limits/HasLimits.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.PreservesLimit", "code": "class PreservesLimit (K : J \u2964 C) (F : C \u2964 D) where\n  preserves : \u2200 {c : Cone K}, IsLimit c \u2192 IsLimit (F.mapCone c)", "start": [53, 1], "end": [57, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesColimit", "code": "class PreservesColimit (K : J \u2964 C) (F : C \u2964 D) where\n  preserves : \u2200 {c : Cocone K}, IsColimit c \u2192 IsColimit (F.mapCocone c)", "start": [60, 1], "end": [64, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesLimitsOfShape", "code": "class PreservesLimitsOfShape (J : Type w) [Category.{w'} J] (F : C \u2964 D) where\n  preservesLimit : \u2200 {K : J \u2964 C}, PreservesLimit K F := by infer_instance", "start": [67, 1], "end": [70, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesColimitsOfShape", "code": "class PreservesColimitsOfShape (J : Type w) [Category.{w'} J] (F : C \u2964 D) where\n  preservesColimit : \u2200 {K : J \u2964 C}, PreservesColimit K F := by infer_instance", "start": [74, 1], "end": [77, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesLimitsOfSize", "code": "@[nolint checkUnivs, pp_with_univ]\nclass PreservesLimitsOfSize (F : C \u2964 D) where\n  preservesLimitsOfShape : \u2200 {J : Type w} [Category.{w'} J], PreservesLimitsOfShape J F := by\n    infer_instance", "start": [82, 1], "end": [87, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesLimits", "code": "abbrev PreservesLimits (F : C \u2964 D) :=\n  PreservesLimitsOfSize.{v\u2082, v\u2082} F", "start": [91, 1], "end": [94, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesColimitsOfSize", "code": "@[nolint checkUnivs, pp_with_univ]\nclass PreservesColimitsOfSize (F : C \u2964 D) where\n  preservesColimitsOfShape : \u2200 {J : Type w} [Category.{w'} J], PreservesColimitsOfShape J F := by\n    infer_instance", "start": [98, 1], "end": [103, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesColimits", "code": "abbrev PreservesColimits (F : C \u2964 D) :=\n  PreservesColimitsOfSize.{v\u2082, v\u2082} F", "start": [107, 1], "end": [110, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitOfPreserves", "code": "def isLimitOfPreserves (F : C \u2964 D) {c : Cone K} (t : IsLimit c) [PreservesLimit K F] :\n    IsLimit (F.mapCone c) :=\n  PreservesLimit.preserves t", "start": [120, 1], "end": [125, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitOfPreserves", "code": "def isColimitOfPreserves (F : C \u2964 D) {c : Cocone K} (t : IsColimit c) [PreservesColimit K F] :\n    IsColimit (F.mapCocone c) :=\n  PreservesColimit.preserves t", "start": [128, 1], "end": [134, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimit_subsingleton", "code": "instance preservesLimit_subsingleton (K : J \u2964 C) (F : C \u2964 D) :\n    Subsingleton (PreservesLimit K F) := by\n  constructor; rintro \u27e8a\u27e9 \u27e8b\u27e9; congr!", "start": [137, 1], "end": [139, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimit_subsingleton", "code": "instance preservesColimit_subsingleton (K : J \u2964 C) (F : C \u2964 D) :\n    Subsingleton (PreservesColimit K F) := by\n  constructor; rintro \u27e8a\u27e9 \u27e8b\u27e9; congr!", "start": [142, 1], "end": [144, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOfShape_subsingleton", "code": "instance preservesLimitsOfShape_subsingleton (J : Type w) [Category.{w'} J] (F : C \u2964 D) :\n    Subsingleton (PreservesLimitsOfShape J F) := by\n  constructor; rintro \u27e8a\u27e9 \u27e8b\u27e9; congr!", "start": [147, 1], "end": [149, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsOfShape_subsingleton", "code": "instance preservesColimitsOfShape_subsingleton (J : Type w) [Category.{w'} J] (F : C \u2964 D) :\n    Subsingleton (PreservesColimitsOfShape J F) := by\n  constructor; rintro \u27e8a\u27e9 \u27e8b\u27e9; congr!", "start": [152, 1], "end": [154, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preserves_limits_subsingleton", "code": "instance preserves_limits_subsingleton (F : C \u2964 D) :\n    Subsingleton (PreservesLimitsOfSize.{w', w} F) := by\n  constructor; rintro \u27e8a\u27e9 \u27e8b\u27e9; congr; funext; congr!", "start": [157, 1], "end": [159, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preserves_colimits_subsingleton", "code": "instance preserves_colimits_subsingleton (F : C \u2964 D) :\n    Subsingleton (PreservesColimitsOfSize.{w', w} F) := by\n  constructor; rintro \u27e8a\u27e9 \u27e8b\u27e9; congr; funext; congr!", "start": [162, 1], "end": [164, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.idPreservesLimits", "code": "instance idPreservesLimits : PreservesLimitsOfSize.{w', w} (\ud835\udfed C) where\n  preservesLimitsOfShape {J} \ud835\udca5 :=\n    {\n      preservesLimit := fun {K} =>\n        \u27e8fun {c} h =>\n          \u27e8fun s => h.lift \u27e8s.pt, fun j => s.\u03c0.app j, fun j j' f => s.\u03c0.naturality f\u27e9, by\n            cases K; rcases c with \u27e8_, _, _\u27e9; intro s j; cases s; exact h.fac _ j, by\n            cases K; rcases c with \u27e8_, _, _\u27e9; intro s m w; rcases s with \u27e8_, _, _\u27e9;\n              exact h.uniq _ m w\u27e9\u27e9 }", "start": [167, 1], "end": [175, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.idPreservesColimits", "code": "instance idPreservesColimits : PreservesColimitsOfSize.{w', w} (\ud835\udfed C) where\n  preservesColimitsOfShape {J} \ud835\udca5 :=\n    {\n      preservesColimit := fun {K} =>\n        \u27e8fun {c} h =>\n          \u27e8fun s => h.desc \u27e8s.pt, fun j => s.\u03b9.app j, fun j j' f => s.\u03b9.naturality f\u27e9, by\n            cases K; rcases c with \u27e8_, _, _\u27e9; intro s j; cases s; exact h.fac _ j, by\n            cases K; rcases c with \u27e8_, _, _\u27e9; intro s m w; rcases s with \u27e8_, _, _\u27e9;\n              exact h.uniq _ m w\u27e9\u27e9 }", "start": [178, 1], "end": [186, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.compPreservesLimit", "code": "instance compPreservesLimit [PreservesLimit K F] [PreservesLimit (K \u22d9 F) G] :\n    PreservesLimit K (F \u22d9 G) :=\n  \u27e8fun h => PreservesLimit.preserves (PreservesLimit.preserves h)\u27e9", "start": [198, 1], "end": [200, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.compPreservesLimitsOfShape", "code": "instance compPreservesLimitsOfShape [PreservesLimitsOfShape J F] [PreservesLimitsOfShape J G] :\n    PreservesLimitsOfShape J (F \u22d9 G) where", "start": [203, 1], "end": [204, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.compPreservesLimits", "code": "instance compPreservesLimits [PreservesLimitsOfSize.{w', w} F] [PreservesLimitsOfSize.{w', w} G] :\n    PreservesLimitsOfSize.{w', w} (F \u22d9 G) where", "start": [207, 1], "end": [208, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.compPreservesColimit", "code": "instance compPreservesColimit [PreservesColimit K F] [PreservesColimit (K \u22d9 F) G] :\n    PreservesColimit K (F \u22d9 G) :=\n  \u27e8fun h => PreservesColimit.preserves (PreservesColimit.preserves h)\u27e9", "start": [211, 1], "end": [213, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.compPreservesColimitsOfShape", "code": "instance compPreservesColimitsOfShape [PreservesColimitsOfShape J F]\n    [PreservesColimitsOfShape J G] : PreservesColimitsOfShape J (F \u22d9 G) where", "start": [216, 1], "end": [217, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.compPreservesColimits", "code": "instance compPreservesColimits [PreservesColimitsOfSize.{w', w} F]\n    [PreservesColimitsOfSize.{w', w} G] : PreservesColimitsOfSize.{w', w} (F \u22d9 G) where", "start": [220, 1], "end": [221, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitOfPreservesLimitCone", "code": "def preservesLimitOfPreservesLimitCone {F : C \u2964 D} {t : Cone K} (h : IsLimit t)\n    (hF : IsLimit (F.mapCone t)) : PreservesLimit K F :=\n  \u27e8fun h' => IsLimit.ofIsoLimit hF (Functor.mapIso _ (IsLimit.uniqueUpToIso h h'))\u27e9", "start": [226, 1], "end": [230, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitOfIsoDiagram", "code": "def preservesLimitOfIsoDiagram {K\u2081 K\u2082 : J \u2964 C} (F : C \u2964 D) (h : K\u2081 \u2245 K\u2082) [PreservesLimit K\u2081 F] :\n    PreservesLimit K\u2082 F where\n  preserves {c} t := by\n    apply IsLimit.postcomposeInvEquiv (isoWhiskerRight h F : _) _ _\n    have := (IsLimit.postcomposeInvEquiv h c).symm t\n    apply IsLimit.ofIsoLimit (isLimitOfPreserves F this)\n    refine' Cones.ext (Iso.refl _)", "start": [233, 1], "end": [240, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitOfNatIso", "code": "def preservesLimitOfNatIso (K : J \u2964 C) {F G : C \u2964 D} (h : F \u2245 G) [PreservesLimit K F] :\n    PreservesLimit K G where\n  preserves t := IsLimit.mapConeEquiv h (PreservesLimit.preserves t)", "start": [243, 1], "end": [246, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOfShapeOfNatIso", "code": "def preservesLimitsOfShapeOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [PreservesLimitsOfShape J F] :\n    PreservesLimitsOfShape J G where\n  preservesLimit {K} := preservesLimitOfNatIso K h", "start": [249, 1], "end": [252, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOfNatIso", "code": "def preservesLimitsOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [PreservesLimitsOfSize.{w, w'} F] :\n    PreservesLimitsOfSize.{w, w'} G where\n  preservesLimitsOfShape {_J} _\ud835\udca5\u2081 := preservesLimitsOfShapeOfNatIso h", "start": [255, 1], "end": [258, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOfShapeOfEquiv", "code": "def preservesLimitsOfShapeOfEquiv {J' : Type w\u2082} [Category.{w\u2082'} J'] (e : J \u224c J') (F : C \u2964 D)\n    [PreservesLimitsOfShape J F] : PreservesLimitsOfShape J' F where\n  preservesLimit {K} :=\n    { preserves := fun {c} t => by\n        let equ := e.invFunIdAssoc (K \u22d9 F)\n        have := (isLimitOfPreserves F (t.whiskerEquivalence e)).whiskerEquivalence e.symm\n        apply ((IsLimit.postcomposeHomEquiv equ _).symm this).ofIsoLimit\n        refine' Cones.ext (Iso.refl _) fun j => _\n        \u00b7 dsimp\n          simp [\u2190 Functor.map_comp] }", "start": [261, 1], "end": [271, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOfSizeShrink", "code": "def preservesLimitsOfSizeShrink (F : C \u2964 D) [PreservesLimitsOfSize.{max w w\u2082, max w' w\u2082'} F] :\n    PreservesLimitsOfSize.{w, w'} F :=\n  \u27e8fun {J} _ => preservesLimitsOfShapeOfEquiv (ULiftHomULiftCategory.equiv.{w\u2082, w\u2082'} J).symm F\u27e9", "start": [275, 1], "end": [280, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesSmallestLimitsOfPreservesLimits", "code": "def preservesSmallestLimitsOfPreservesLimits (F : C \u2964 D) [PreservesLimitsOfSize.{v\u2083, u\u2083} F] :\n    PreservesLimitsOfSize.{0, 0} F :=\n  preservesLimitsOfSizeShrink F", "start": [283, 1], "end": [286, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitOfPreservesColimitCocone", "code": "def preservesColimitOfPreservesColimitCocone {F : C \u2964 D} {t : Cocone K} (h : IsColimit t)\n    (hF : IsColimit (F.mapCocone t)) : PreservesColimit K F :=\n  \u27e8fun h' => IsColimit.ofIsoColimit hF (Functor.mapIso _ (IsColimit.uniqueUpToIso h h'))\u27e9", "start": [289, 1], "end": [293, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitOfIsoDiagram", "code": "def preservesColimitOfIsoDiagram {K\u2081 K\u2082 : J \u2964 C} (F : C \u2964 D) (h : K\u2081 \u2245 K\u2082) [PreservesColimit K\u2081 F] :\n    PreservesColimit K\u2082 F where\n  preserves {c} t := by\n    apply IsColimit.precomposeHomEquiv (isoWhiskerRight h F : _) _ _\n    have := (IsColimit.precomposeHomEquiv h c).symm t\n    apply IsColimit.ofIsoColimit (isColimitOfPreserves F this)\n    refine' Cocones.ext (Iso.refl _)", "start": [296, 1], "end": [303, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitOfNatIso", "code": "def preservesColimitOfNatIso (K : J \u2964 C) {F G : C \u2964 D} (h : F \u2245 G) [PreservesColimit K F] :\n    PreservesColimit K G where\n  preserves t := IsColimit.mapCoconeEquiv h (PreservesColimit.preserves t)", "start": [306, 1], "end": [309, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsOfShapeOfNatIso", "code": "def preservesColimitsOfShapeOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [PreservesColimitsOfShape J F] :\n    PreservesColimitsOfShape J G where\n  preservesColimit {K}  := preservesColimitOfNatIso K h", "start": [312, 1], "end": [315, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsOfNatIso", "code": "def preservesColimitsOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [PreservesColimitsOfSize.{w, w'} F] :\n    PreservesColimitsOfSize.{w, w'} G where\n  preservesColimitsOfShape {_J} _\ud835\udca5\u2081 := preservesColimitsOfShapeOfNatIso h", "start": [318, 1], "end": [321, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsOfShapeOfEquiv", "code": "def preservesColimitsOfShapeOfEquiv {J' : Type w\u2082} [Category.{w\u2082'} J'] (e : J \u224c J') (F : C \u2964 D)\n    [PreservesColimitsOfShape J F] : PreservesColimitsOfShape J' F where\n  preservesColimit {K} :=\n    {\n      preserves := fun {c} t => by\n        let equ := e.invFunIdAssoc (K \u22d9 F)\n        have := (isColimitOfPreserves F (t.whiskerEquivalence e)).whiskerEquivalence e.symm\n        apply ((IsColimit.precomposeInvEquiv equ _).symm this).ofIsoColimit\n        refine' Cocones.ext (Iso.refl _) fun j => _\n        \u00b7 dsimp\n          simp [\u2190 Functor.map_comp] }", "start": [324, 1], "end": [335, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsOfSizeShrink", "code": "def preservesColimitsOfSizeShrink (F : C \u2964 D) [PreservesColimitsOfSize.{max w w\u2082, max w' w\u2082'} F] :\n    PreservesColimitsOfSize.{w, w'} F :=\n  \u27e8fun {J} =>\n    preservesColimitsOfShapeOfEquiv (ULiftHomULiftCategory.equiv.{w\u2082, w\u2082'} J).symm F\u27e9", "start": [339, 1], "end": [346, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesSmallestColimitsOfPreservesColimits", "code": "def preservesSmallestColimitsOfPreservesColimits (F : C \u2964 D) [PreservesColimitsOfSize.{v\u2083, u\u2083} F] :\n    PreservesColimitsOfSize.{0, 0} F :=\n  preservesColimitsOfSizeShrink F", "start": [349, 1], "end": [352, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ReflectsLimit", "code": "class ReflectsLimit (K : J \u2964 C) (F : C \u2964 D) where\n  reflects : \u2200 {c : Cone K}, IsLimit (F.mapCone c) \u2192 IsLimit c", "start": [355, 1], "end": [361, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ReflectsColimit", "code": "class ReflectsColimit (K : J \u2964 C) (F : C \u2964 D) where\n  reflects : \u2200 {c : Cocone K}, IsColimit (F.mapCocone c) \u2192 IsColimit c", "start": [364, 1], "end": [370, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ReflectsLimitsOfShape", "code": "class ReflectsLimitsOfShape (J : Type w) [Category.{w'} J] (F : C \u2964 D) where\n  reflectsLimit : \u2200 {K : J \u2964 C}, ReflectsLimit K F := by infer_instance", "start": [373, 1], "end": [379, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ReflectsColimitsOfShape", "code": "class ReflectsColimitsOfShape (J : Type w) [Category.{w'} J] (F : C \u2964 D) where\n  reflectsColimit : \u2200 {K : J \u2964 C}, ReflectsColimit K F := by infer_instance", "start": [382, 1], "end": [388, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ReflectsLimitsOfSize", "code": "@[nolint checkUnivs, pp_with_univ]\nclass ReflectsLimitsOfSize (F : C \u2964 D) where\n  reflectsLimitsOfShape : \u2200 {J : Type w} [Category.{w'} J], ReflectsLimitsOfShape J F := by\n    infer_instance", "start": [392, 1], "end": [400, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ReflectsLimits", "code": "abbrev ReflectsLimits (F : C \u2964 D) :=\n  ReflectsLimitsOfSize.{v\u2082, v\u2082} F", "start": [403, 1], "end": [409, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ReflectsColimitsOfSize", "code": "@[nolint checkUnivs, pp_with_univ]\nclass ReflectsColimitsOfSize (F : C \u2964 D) where\n  reflectsColimitsOfShape : \u2200 {J : Type w} [Category.{w'} J], ReflectsColimitsOfShape J F := by\n    infer_instance", "start": [413, 1], "end": [421, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ReflectsColimits", "code": "abbrev ReflectsColimits (F : C \u2964 D) :=\n  ReflectsColimitsOfSize.{v\u2082, v\u2082} F", "start": [424, 1], "end": [430, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitOfReflects", "code": "def isLimitOfReflects (F : C \u2964 D) {c : Cone K} (t : IsLimit (F.mapCone c))\n    [ReflectsLimit K F] : IsLimit c := ReflectsLimit.reflects t", "start": [433, 1], "end": [437, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitOfReflects", "code": "def isColimitOfReflects (F : C \u2964 D) {c : Cocone K} (t : IsColimit (F.mapCocone c))\n    [ReflectsColimit K F] : IsColimit c :=\n  ReflectsColimit.reflects t", "start": [440, 1], "end": [446, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsLimit_subsingleton", "code": "instance reflectsLimit_subsingleton (K : J \u2964 C) (F : C \u2964 D) : Subsingleton (ReflectsLimit K F) := by\n  constructor; rintro \u27e8a\u27e9 \u27e8b\u27e9; congr!", "start": [449, 1], "end": [450, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsColimit_subsingleton", "code": "instance\n  reflectsColimit_subsingleton (K : J \u2964 C) (F : C \u2964 D) : Subsingleton (ReflectsColimit K F) := by\n  constructor; rintro \u27e8a\u27e9 \u27e8b\u27e9; congr!", "start": [453, 1], "end": [455, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsLimitsOfShape_subsingleton", "code": "instance reflectsLimitsOfShape_subsingleton (J : Type w) [Category.{w'} J] (F : C \u2964 D) :\n    Subsingleton (ReflectsLimitsOfShape J F) := by\n  constructor; rintro \u27e8a\u27e9 \u27e8b\u27e9; congr!", "start": [458, 1], "end": [460, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsColimitsOfShape_subsingleton", "code": "instance reflectsColimitsOfShape_subsingleton (J : Type w) [Category.{w'} J] (F : C \u2964 D) :\n    Subsingleton (ReflectsColimitsOfShape J F) := by\n  constructor; rintro \u27e8a\u27e9 \u27e8b\u27e9; congr!", "start": [463, 1], "end": [465, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflects_limits_subsingleton", "code": "instance\n  reflects_limits_subsingleton (F : C \u2964 D) : Subsingleton (ReflectsLimitsOfSize.{w', w} F) := by\n  constructor; rintro \u27e8a\u27e9 \u27e8b\u27e9; congr; funext; congr!", "start": [468, 1], "end": [470, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflects_colimits_subsingleton", "code": "instance reflects_colimits_subsingleton (F : C \u2964 D) :\n    Subsingleton (ReflectsColimitsOfSize.{w', w} F) := by\n  constructor; rintro \u27e8a\u27e9 \u27e8b\u27e9; congr; funext; congr!", "start": [473, 1], "end": [475, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsLimitOfReflectsLimitsOfShape", "code": "instance (priority := 100) reflectsLimitOfReflectsLimitsOfShape (K : J \u2964 C) (F : C \u2964 D)\n    [ReflectsLimitsOfShape J F] : ReflectsLimit K F :=\n  ReflectsLimitsOfShape.reflectsLimit", "start": [479, 1], "end": [481, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsColimitOfReflectsColimitsOfShape", "code": "instance (priority := 100) reflectsColimitOfReflectsColimitsOfShape (K : J \u2964 C) (F : C \u2964 D)\n    [ReflectsColimitsOfShape J F] : ReflectsColimit K F :=\n  ReflectsColimitsOfShape.reflectsColimit", "start": [485, 1], "end": [487, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsLimitsOfShapeOfReflectsLimits", "code": "instance (priority := 100) reflectsLimitsOfShapeOfReflectsLimits (J : Type w) [Category.{w'} J]\n    (F : C \u2964 D) [ReflectsLimitsOfSize.{w', w} F] : ReflectsLimitsOfShape J F :=\n  ReflectsLimitsOfSize.reflectsLimitsOfShape", "start": [491, 1], "end": [493, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsColimitsOfShapeOfReflectsColimits", "code": "instance (priority := 100) reflectsColimitsOfShapeOfReflectsColimits (J : Type w) [Category.{w'} J]\n    (F : C \u2964 D) [ReflectsColimitsOfSize.{w', w} F] : ReflectsColimitsOfShape J F :=\n  ReflectsColimitsOfSize.reflectsColimitsOfShape", "start": [497, 1], "end": [499, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.idReflectsLimits", "code": "instance idReflectsLimits : ReflectsLimitsOfSize.{w, w'} (\ud835\udfed C) where\n  reflectsLimitsOfShape {J} \ud835\udca5 :=\n    {\n      reflectsLimit := fun {K} =>\n        \u27e8fun {c} h =>\n          \u27e8fun s => h.lift \u27e8s.pt, fun j => s.\u03c0.app j, fun j j' f => s.\u03c0.naturality f\u27e9, by\n            cases K; rcases c with \u27e8_, _, _\u27e9; intro s j; cases s; exact h.fac _ j, by\n            cases K; rcases c with \u27e8_, _, _\u27e9; intro s m w; rcases s with \u27e8_, _, _\u27e9;\n              exact h.uniq _ m w\u27e9\u27e9 }", "start": [502, 1], "end": [510, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.idReflectsColimits", "code": "instance idReflectsColimits : ReflectsColimitsOfSize.{w, w'} (\ud835\udfed C) where\n  reflectsColimitsOfShape {J} \ud835\udca5 :=\n    {\n      reflectsColimit := fun {K} =>\n        \u27e8fun {c} h =>\n          \u27e8fun s => h.desc \u27e8s.pt, fun j => s.\u03b9.app j, fun j j' f => s.\u03b9.naturality f\u27e9, by\n            cases K; rcases c with \u27e8_, _, _\u27e9; intro s j; cases s; exact h.fac _ j, by\n            cases K; rcases c with \u27e8_, _, _\u27e9; intro s m w; rcases s with \u27e8_, _, _\u27e9;\n              exact h.uniq _ m w\u27e9\u27e9 }", "start": [513, 1], "end": [521, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.compReflectsLimit", "code": "instance compReflectsLimit [ReflectsLimit K F] [ReflectsLimit (K \u22d9 F) G] :\n    ReflectsLimit K (F \u22d9 G) :=\n  \u27e8fun h => ReflectsLimit.reflects (ReflectsLimit.reflects h)\u27e9", "start": [530, 1], "end": [532, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.compReflectsLimitsOfShape", "code": "instance compReflectsLimitsOfShape [ReflectsLimitsOfShape J F] [ReflectsLimitsOfShape J G] :\n    ReflectsLimitsOfShape J (F \u22d9 G) where", "start": [535, 1], "end": [536, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.compReflectsLimits", "code": "instance compReflectsLimits [ReflectsLimitsOfSize.{w', w} F] [ReflectsLimitsOfSize.{w', w} G] :\n    ReflectsLimitsOfSize.{w', w} (F \u22d9 G) where", "start": [539, 1], "end": [540, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.compReflectsColimit", "code": "instance compReflectsColimit [ReflectsColimit K F] [ReflectsColimit (K \u22d9 F) G] :\n    ReflectsColimit K (F \u22d9 G) :=\n  \u27e8fun h => ReflectsColimit.reflects (ReflectsColimit.reflects h)\u27e9", "start": [543, 1], "end": [545, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.compReflectsColimitsOfShape", "code": "instance compReflectsColimitsOfShape [ReflectsColimitsOfShape J F] [ReflectsColimitsOfShape J G] :\n    ReflectsColimitsOfShape J (F \u22d9 G) where", "start": [548, 1], "end": [549, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.compReflectsColimits", "code": "instance compReflectsColimits [ReflectsColimitsOfSize.{w', w} F]\n    [ReflectsColimitsOfSize.{w', w} G] : ReflectsColimitsOfSize.{w', w} (F \u22d9 G) where", "start": [552, 1], "end": [553, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitOfReflectsOfPreserves", "code": "def preservesLimitOfReflectsOfPreserves [PreservesLimit K (F \u22d9 G)] [ReflectsLimit (K \u22d9 F) G] :\n    PreservesLimit K F :=\n  \u27e8fun h => by\n    apply isLimitOfReflects G\n    apply isLimitOfPreserves (F \u22d9 G) h\u27e9", "start": [556, 1], "end": [562, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOfShapeOfReflectsOfPreserves", "code": "def preservesLimitsOfShapeOfReflectsOfPreserves [PreservesLimitsOfShape J (F \u22d9 G)]\n    [ReflectsLimitsOfShape J G] : PreservesLimitsOfShape J F where\n  preservesLimit := preservesLimitOfReflectsOfPreserves F G", "start": [565, 1], "end": [571, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOfReflectsOfPreserves", "code": "def preservesLimitsOfReflectsOfPreserves [PreservesLimitsOfSize.{w', w} (F \u22d9 G)]\n    [ReflectsLimitsOfSize.{w', w} G] : PreservesLimitsOfSize.{w', w} F where\n  preservesLimitsOfShape := preservesLimitsOfShapeOfReflectsOfPreserves F G", "start": [574, 1], "end": [577, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsLimitOfIsoDiagram", "code": "def reflectsLimitOfIsoDiagram {K\u2081 K\u2082 : J \u2964 C} (F : C \u2964 D) (h : K\u2081 \u2245 K\u2082) [ReflectsLimit K\u2081 F] :\n    ReflectsLimit K\u2082 F where\n  reflects {c} t := by\n    apply IsLimit.postcomposeInvEquiv h c (isLimitOfReflects F _)\n    apply ((IsLimit.postcomposeInvEquiv (isoWhiskerRight h F : _) _).symm t).ofIsoLimit _\n    exact Cones.ext (Iso.refl _)", "start": [580, 1], "end": [586, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsLimitOfNatIso", "code": "def reflectsLimitOfNatIso (K : J \u2964 C) {F G : C \u2964 D} (h : F \u2245 G) [ReflectsLimit K F] :\n    ReflectsLimit K G where\n  reflects t := ReflectsLimit.reflects (IsLimit.mapConeEquiv h.symm t)", "start": [589, 1], "end": [592, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsLimitsOfShapeOfNatIso", "code": "def reflectsLimitsOfShapeOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [ReflectsLimitsOfShape J F] :\n    ReflectsLimitsOfShape J G where\n  reflectsLimit {K} := reflectsLimitOfNatIso K h", "start": [595, 1], "end": [598, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsLimitsOfNatIso", "code": "def reflectsLimitsOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [ReflectsLimitsOfSize.{w', w} F] :\n    ReflectsLimitsOfSize.{w', w} G where\n  reflectsLimitsOfShape := reflectsLimitsOfShapeOfNatIso h", "start": [601, 1], "end": [604, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsLimitsOfShapeOfEquiv", "code": "def reflectsLimitsOfShapeOfEquiv {J' : Type w\u2082} [Category.{w\u2082'} J'] (e : J \u224c J') (F : C \u2964 D)\n    [ReflectsLimitsOfShape J F] : ReflectsLimitsOfShape J' F where\n  reflectsLimit {K} :=\n    {\n      reflects := fun {c} t => by\n        apply IsLimit.ofWhiskerEquivalence e\n        apply isLimitOfReflects F\n        apply IsLimit.ofIsoLimit _ (Functor.mapConeWhisker _).symm\n        exact IsLimit.whiskerEquivalence t _ }", "start": [607, 1], "end": [616, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsLimitsOfSizeShrink", "code": "def reflectsLimitsOfSizeShrink (F : C \u2964 D) [ReflectsLimitsOfSize.{max w w\u2082, max w' w\u2082'} F] :\n    ReflectsLimitsOfSize.{w, w'} F :=\n  \u27e8fun {J} => reflectsLimitsOfShapeOfEquiv (ULiftHomULiftCategory.equiv.{w\u2082, w\u2082'} J).symm F\u27e9", "start": [619, 1], "end": [624, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsSmallestLimitsOfReflectsLimits", "code": "def reflectsSmallestLimitsOfReflectsLimits (F : C \u2964 D) [ReflectsLimitsOfSize.{v\u2083, u\u2083} F] :\n    ReflectsLimitsOfSize.{0, 0} F :=\n  reflectsLimitsOfSizeShrink F", "start": [627, 1], "end": [630, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsLimitOfReflectsIsomorphisms", "code": "def reflectsLimitOfReflectsIsomorphisms (F : J \u2964 C) (G : C \u2964 D) [ReflectsIsomorphisms G]\n    [HasLimit F] [PreservesLimit F G] : ReflectsLimit F G where\n  reflects {c} t := by\n    suffices IsIso (IsLimit.lift (limit.isLimit F) c) from by\n      apply IsLimit.ofPointIso (limit.isLimit F)\n    change IsIso ((Cones.forget _).map ((limit.isLimit F).liftConeMorphism c))\n    suffices IsIso (IsLimit.liftConeMorphism (limit.isLimit F) c) from by\n      apply (Cones.forget F).map_isIso _\n    suffices IsIso (Prefunctor.map (Cones.functoriality F G).toPrefunctor\n      (IsLimit.liftConeMorphism (limit.isLimit F) c)) from by\n        apply isIso_of_reflects_iso _ (Cones.functoriality F G)\n    refine' t.hom_isIso (isLimitOfPreserves G (limit.isLimit F)) _", "start": [633, 1], "end": [647, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsLimitsOfShapeOfReflectsIsomorphisms", "code": "def reflectsLimitsOfShapeOfReflectsIsomorphisms {G : C \u2964 D} [ReflectsIsomorphisms G]\n    [HasLimitsOfShape J C] [PreservesLimitsOfShape J G] : ReflectsLimitsOfShape J G where\n  reflectsLimit {F} := reflectsLimitOfReflectsIsomorphisms F G", "start": [650, 1], "end": [655, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsLimitsOfReflectsIsomorphisms", "code": "def reflectsLimitsOfReflectsIsomorphisms {G : C \u2964 D} [ReflectsIsomorphisms G]\n    [HasLimitsOfSize.{w', w} C] [PreservesLimitsOfSize.{w', w} G] : ReflectsLimitsOfSize.{w', w} G\n    where\n  reflectsLimitsOfShape := reflectsLimitsOfShapeOfReflectsIsomorphisms", "start": [658, 1], "end": [664, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitOfReflectsOfPreserves", "code": "def preservesColimitOfReflectsOfPreserves [PreservesColimit K (F \u22d9 G)] [ReflectsColimit (K \u22d9 F) G] :\n    PreservesColimit K F :=\n  \u27e8fun {c} h => by\n    apply isColimitOfReflects G\n    apply isColimitOfPreserves (F \u22d9 G) h\u27e9", "start": [667, 1], "end": [673, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsOfShapeOfReflectsOfPreserves", "code": "def preservesColimitsOfShapeOfReflectsOfPreserves [PreservesColimitsOfShape J (F \u22d9 G)]\n    [ReflectsColimitsOfShape J G] : PreservesColimitsOfShape J F where\n  preservesColimit := preservesColimitOfReflectsOfPreserves F G", "start": [676, 1], "end": [681, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsOfReflectsOfPreserves", "code": "def preservesColimitsOfReflectsOfPreserves [PreservesColimitsOfSize.{w', w} (F \u22d9 G)]\n    [ReflectsColimitsOfSize.{w', w} G] : PreservesColimitsOfSize.{w', w} F where\n  preservesColimitsOfShape := preservesColimitsOfShapeOfReflectsOfPreserves F G", "start": [684, 1], "end": [687, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsColimitOfIsoDiagram", "code": "def reflectsColimitOfIsoDiagram {K\u2081 K\u2082 : J \u2964 C} (F : C \u2964 D) (h : K\u2081 \u2245 K\u2082) [ReflectsColimit K\u2081 F] :\n    ReflectsColimit K\u2082 F where\n  reflects {c} t := by\n    apply IsColimit.precomposeHomEquiv h c (isColimitOfReflects F _)\n    apply ((IsColimit.precomposeHomEquiv (isoWhiskerRight h F : _) _).symm t).ofIsoColimit _\n    exact Cocones.ext (Iso.refl _)", "start": [690, 1], "end": [696, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsColimitOfNatIso", "code": "def reflectsColimitOfNatIso (K : J \u2964 C) {F G : C \u2964 D} (h : F \u2245 G) [ReflectsColimit K F] :\n    ReflectsColimit K G where\n  reflects t := ReflectsColimit.reflects (IsColimit.mapCoconeEquiv h.symm t)", "start": [699, 1], "end": [702, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsColimitsOfShapeOfNatIso", "code": "def reflectsColimitsOfShapeOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [ReflectsColimitsOfShape J F] :\n    ReflectsColimitsOfShape J G where\n  reflectsColimit {K} := reflectsColimitOfNatIso K h", "start": [705, 1], "end": [708, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsColimitsOfNatIso", "code": "def reflectsColimitsOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [ReflectsColimitsOfSize.{w, w'} F] :\n    ReflectsColimitsOfSize.{w, w'} G where\n  reflectsColimitsOfShape := reflectsColimitsOfShapeOfNatIso h", "start": [711, 1], "end": [714, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsColimitsOfShapeOfEquiv", "code": "def reflectsColimitsOfShapeOfEquiv {J' : Type w\u2082} [Category.{w\u2082'} J'] (e : J \u224c J') (F : C \u2964 D)\n    [ReflectsColimitsOfShape J F] : ReflectsColimitsOfShape J' F where\n  reflectsColimit :=\n    {\n      reflects := fun {c} t => by\n        apply IsColimit.ofWhiskerEquivalence e\n        apply isColimitOfReflects F\n        apply IsColimit.ofIsoColimit _ (Functor.mapCoconeWhisker _).symm\n        exact IsColimit.whiskerEquivalence t _ }", "start": [717, 1], "end": [726, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsColimitsOfSizeShrink", "code": "def reflectsColimitsOfSizeShrink (F : C \u2964 D) [ReflectsColimitsOfSize.{max w w\u2082, max w' w\u2082'} F] :\n    ReflectsColimitsOfSize.{w, w'} F :=\n  \u27e8fun {J} => reflectsColimitsOfShapeOfEquiv (ULiftHomULiftCategory.equiv.{w\u2082, w\u2082'} J).symm F\u27e9", "start": [729, 1], "end": [734, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsSmallestColimitsOfReflectsColimits", "code": "def reflectsSmallestColimitsOfReflectsColimits (F : C \u2964 D) [ReflectsColimitsOfSize.{v\u2083, u\u2083} F] :\n    ReflectsColimitsOfSize.{0, 0} F :=\n  reflectsColimitsOfSizeShrink F", "start": [737, 1], "end": [740, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsColimitOfReflectsIsomorphisms", "code": "def reflectsColimitOfReflectsIsomorphisms (F : J \u2964 C) (G : C \u2964 D) [ReflectsIsomorphisms G]\n    [HasColimit F] [PreservesColimit F G] : ReflectsColimit F G where\n  reflects {c} t := by\n    suffices IsIso (IsColimit.desc (colimit.isColimit F) c) from by\n      apply IsColimit.ofPointIso (colimit.isColimit F)\n    change IsIso ((Cocones.forget _).map ((colimit.isColimit F).descCoconeMorphism c))\n    suffices IsIso (IsColimit.descCoconeMorphism (colimit.isColimit F) c) from by\n      apply (Cocones.forget F).map_isIso _\n    suffices IsIso (Prefunctor.map (Cocones.functoriality F G).toPrefunctor\n      (IsColimit.descCoconeMorphism (colimit.isColimit F) c)) from by\n        apply isIso_of_reflects_iso _ (Cocones.functoriality F G)\n    refine' (isColimitOfPreserves G (colimit.isColimit F)).hom_isIso t _", "start": [743, 1], "end": [757, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsColimitsOfShapeOfReflectsIsomorphisms", "code": "def reflectsColimitsOfShapeOfReflectsIsomorphisms {G : C \u2964 D} [ReflectsIsomorphisms G]\n    [HasColimitsOfShape J C] [PreservesColimitsOfShape J G] : ReflectsColimitsOfShape J G where\n  reflectsColimit {F} := reflectsColimitOfReflectsIsomorphisms F G", "start": [760, 1], "end": [766, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.reflectsColimitsOfReflectsIsomorphisms", "code": "def reflectsColimitsOfReflectsIsomorphisms {G : C \u2964 D} [ReflectsIsomorphisms G]\n    [HasColimitsOfSize.{w', w} C] [PreservesColimitsOfSize.{w', w} G] :\n    ReflectsColimitsOfSize.{w', w} G where\n  reflectsColimitsOfShape := reflectsColimitsOfShapeOfReflectsIsomorphisms", "start": [769, 1], "end": [776, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.fullyFaithfulReflectsLimits", "code": "def fullyFaithfulReflectsLimits [Full F] [Faithful F] : ReflectsLimitsOfSize.{w, w'} F where\n  reflectsLimitsOfShape {J} \ud835\udca5\u2081 :=\n    { reflectsLimit := fun {K} =>\n        { reflects := fun {c} t =>\n            (IsLimit.mkConeMorphism fun s =>\n                (Cones.functoriality K F).preimage (t.liftConeMorphism _)) <| by\n              apply fun s m => (Cones.functoriality K F).map_injective _\n              intro s m\n              rw [Functor.image_preimage]\n              apply t.uniq_cone_morphism } }", "start": [783, 1], "end": [793, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.fullyFaithfulReflectsColimits", "code": "def fullyFaithfulReflectsColimits [Full F] [Faithful F] : ReflectsColimitsOfSize.{w, w'} F where\n  reflectsColimitsOfShape {J} \ud835\udca5\u2081 :=\n    { reflectsColimit := fun {K} =>\n        { reflects := fun {c} t =>\n            (IsColimit.mkCoconeMorphism fun s =>\n                (Cocones.functoriality K F).preimage (t.descCoconeMorphism _)) <| by\n              apply fun s m => (Cocones.functoriality K F).map_injective _\n              intro s m\n              rw [Functor.image_preimage]\n              apply t.uniq_cocone_morphism }}", "start": [796, 1], "end": [806, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "imports": ["Mathlib/CategoryTheory/DiscreteCategory.lean", "Mathlib/CategoryTheory/EpiMono.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "Mathlib/CategoryTheory/Over.lean"], "premises": [{"full_name": "CategoryTheory.Limits.WalkingPair", "code": "inductive WalkingPair : Type\n  | left\n  | right\n  deriving DecidableEq, Inhabited", "start": [42, 1], "end": [46, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingPair.swap", "code": "def WalkingPair.swap : WalkingPair \u2243 WalkingPair\n    where\n  toFun j := WalkingPair.recOn j right left\n  invFun j := WalkingPair.recOn j right left\n  left_inv j := by cases j; repeat rfl\n  right_inv j := by cases j; repeat rfl", "start": [51, 1], "end": [58, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingPair.swap_apply_left", "code": "@[simp]\ntheorem WalkingPair.swap_apply_left : WalkingPair.swap left = right", "start": [61, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingPair.swap_apply_right", "code": "@[simp]\ntheorem WalkingPair.swap_apply_right : WalkingPair.swap right = left", "start": [66, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingPair.swap_symm_apply_tt", "code": "@[simp]\ntheorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right", "start": [71, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingPair.swap_symm_apply_ff", "code": "@[simp]\ntheorem WalkingPair.swap_symm_apply_ff : WalkingPair.swap.symm right = left", "start": [76, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingPair.equivBool", "code": "def WalkingPair.equivBool : WalkingPair \u2243 Bool\n    where\n  toFun j := WalkingPair.recOn j true false\n  invFun b := Bool.recOn b right left\n  left_inv j := by cases j; repeat rfl\n  right_inv b := by cases b; repeat rfl", "start": [81, 1], "end": [89, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingPair.equivBool_apply_left", "code": "@[simp]\ntheorem WalkingPair.equivBool_apply_left : WalkingPair.equivBool left = true", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingPair.equivBool_apply_right", "code": "@[simp]\ntheorem WalkingPair.equivBool_apply_right : WalkingPair.equivBool right = false", "start": [97, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingPair.equivBool_symm_apply_true", "code": "@[simp]\ntheorem WalkingPair.equivBool_symm_apply_true : WalkingPair.equivBool.symm true = left", "start": [102, 1], "end": [104, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingPair.equivBool_symm_apply_false", "code": "@[simp]\ntheorem WalkingPair.equivBool_symm_apply_false : WalkingPair.equivBool.symm false = right", "start": [107, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pairFunction", "code": "def pairFunction (X Y : C) : WalkingPair \u2192 C := fun j => WalkingPair.casesOn j X Y", "start": [114, 1], "end": [115, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pairFunction_left", "code": "@[simp]\ntheorem pairFunction_left (X Y : C) : pairFunction X Y left = X", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pairFunction_right", "code": "@[simp]\ntheorem pairFunction_right (X Y : C) : pairFunction X Y right = Y", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pair", "code": "def pair (X Y : C) : Discrete WalkingPair \u2964 C :=\n  Discrete.functor fun j => WalkingPair.casesOn j X Y", "start": [130, 1], "end": [132, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pair_obj_left", "code": "@[simp]\ntheorem pair_obj_left (X Y : C) : (pair X Y).obj \u27e8left\u27e9 = X", "start": [135, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pair_obj_right", "code": "@[simp]\ntheorem pair_obj_right (X Y : C) : (pair X Y).obj \u27e8right\u27e9 = Y", "start": [140, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.mapPair", "code": "def mapPair : F \u27f6 G where\n  app j := Discrete.recOn j fun j => WalkingPair.casesOn j f g\n  naturality := fun \u27e8X\u27e9 \u27e8Y\u27e9 \u27e8\u27e8u\u27e9\u27e9 => by aesop_cat", "start": [153, 1], "end": [157, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.mapPair_left", "code": "@[simp]\ntheorem mapPair_left : (mapPair f g).app \u27e8left\u27e9 = f", "start": [160, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.mapPair_right", "code": "@[simp]\ntheorem mapPair_right : (mapPair f g).app \u27e8right\u27e9 = g", "start": [165, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.mapPairIso", "code": "@[simps!]\ndef mapPairIso (f : F.obj \u27e8left\u27e9 \u2245 G.obj \u27e8left\u27e9) (g : F.obj \u27e8right\u27e9 \u2245 G.obj \u27e8right\u27e9) : F \u2245 G :=\n  NatIso.ofComponents (fun j => Discrete.recOn j fun j => WalkingPair.casesOn j f g)\n    (fun \u27e8\u27e8u\u27e9\u27e9 => by aesop_cat)", "start": [170, 1], "end": [175, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.diagramIsoPair", "code": "@[simps!]\ndef diagramIsoPair (F : Discrete WalkingPair \u2964 C) :\n    F \u2245 pair (F.obj \u27e8WalkingPair.left\u27e9) (F.obj \u27e8WalkingPair.right\u27e9) :=\n  mapPairIso (Iso.refl _) (Iso.refl _)", "start": [180, 1], "end": [184, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pairComp", "code": "def pairComp (X Y : C) (F : C \u2964 D) : pair X Y \u22d9 F \u2245 pair (F.obj X) (F.obj Y) :=\n  diagramIsoPair _", "start": [191, 1], "end": [193, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan", "code": "abbrev BinaryFan (X Y : C) :=\n  Cone (pair X Y)", "start": [198, 1], "end": [200, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.fst", "code": "abbrev BinaryFan.fst {X Y : C} (s : BinaryFan X Y) :=\n  s.\u03c0.app \u27e8WalkingPair.left\u27e9", "start": [203, 1], "end": [205, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.snd", "code": "abbrev BinaryFan.snd {X Y : C} (s : BinaryFan X Y) :=\n  s.\u03c0.app \u27e8WalkingPair.right\u27e9", "start": [208, 1], "end": [210, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.\u03c0_app_left", "code": "@[simp]\ntheorem BinaryFan.\u03c0_app_left {X Y : C} (s : BinaryFan X Y) : s.\u03c0.app \u27e8WalkingPair.left\u27e9 = s.fst", "start": [213, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.\u03c0_app_right", "code": "@[simp]\ntheorem BinaryFan.\u03c0_app_right {X Y : C} (s : BinaryFan X Y) : s.\u03c0.app \u27e8WalkingPair.right\u27e9 = s.snd", "start": [218, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.IsLimit.mk", "code": "def BinaryFan.IsLimit.mk {X Y : C} (s : BinaryFan X Y)\n    (lift : \u2200 {T : C} (_ : T \u27f6 X) (_ : T \u27f6 Y), T \u27f6 s.pt)\n    (hl\u2081 : \u2200 {T : C} (f : T \u27f6 X) (g : T \u27f6 Y), lift f g \u226b s.fst = f)\n    (hl\u2082 : \u2200 {T : C} (f : T \u27f6 X) (g : T \u27f6 Y), lift f g \u226b s.snd = g)\n    (uniq :\n      \u2200 {T : C} (f : T \u27f6 X) (g : T \u27f6 Y) (m : T \u27f6 s.pt) (_ : m \u226b s.fst = f) (_ : m \u226b s.snd = g),\n        m = lift f g) :\n    IsLimit s :=\n  Limits.IsLimit.mk (fun t => lift (BinaryFan.fst t) (BinaryFan.snd t))\n    (by\n      rintro t (rfl | rfl)\n      \u00b7 exact hl\u2081 _ _\n      \u00b7 exact hl\u2082 _ _)\n    fun t m h => uniq _ _ _ (h \u27e8WalkingPair.left\u27e9) (h \u27e8WalkingPair.right\u27e9)", "start": [223, 1], "end": [237, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.IsLimit.hom_ext", "code": "theorem BinaryFan.IsLimit.hom_ext {W X Y : C} {s : BinaryFan X Y} (h : IsLimit s) {f g : W \u27f6 s.pt}\n    (h\u2081 : f \u226b s.fst = g \u226b s.fst) (h\u2082 : f \u226b s.snd = g \u226b s.snd) : f = g", "start": [240, 1], "end": [242, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan", "code": "abbrev BinaryCofan (X Y : C) := Cocone (pair X Y)", "start": [245, 1], "end": [246, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.inl", "code": "abbrev BinaryCofan.inl {X Y : C} (s : BinaryCofan X Y) := s.\u03b9.app \u27e8WalkingPair.left\u27e9", "start": [249, 1], "end": [250, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.inr", "code": "abbrev BinaryCofan.inr {X Y : C} (s : BinaryCofan X Y) := s.\u03b9.app \u27e8WalkingPair.right\u27e9", "start": [253, 1], "end": [254, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.\u03b9_app_left", "code": "@[simp]\ntheorem BinaryCofan.\u03b9_app_left {X Y : C} (s : BinaryCofan X Y) :\n    s.\u03b9.app \u27e8WalkingPair.left\u27e9 = s.inl", "start": [257, 1], "end": [259, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.\u03b9_app_right", "code": "@[simp]\ntheorem BinaryCofan.\u03b9_app_right {X Y : C} (s : BinaryCofan X Y) :\n    s.\u03b9.app \u27e8WalkingPair.right\u27e9 = s.inr", "start": [262, 1], "end": [264, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.IsColimit.mk", "code": "def BinaryCofan.IsColimit.mk {X Y : C} (s : BinaryCofan X Y)\n    (desc : \u2200 {T : C} (_ : X \u27f6 T) (_ : Y \u27f6 T), s.pt \u27f6 T)\n    (hd\u2081 : \u2200 {T : C} (f : X \u27f6 T) (g : Y \u27f6 T), s.inl \u226b desc f g = f)\n    (hd\u2082 : \u2200 {T : C} (f : X \u27f6 T) (g : Y \u27f6 T), s.inr \u226b desc f g = g)\n    (uniq :\n      \u2200 {T : C} (f : X \u27f6 T) (g : Y \u27f6 T) (m : s.pt \u27f6 T) (_ : s.inl \u226b m = f) (_ : s.inr \u226b m = g),\n        m = desc f g) :\n    IsColimit s :=\n  Limits.IsColimit.mk (fun t => desc (BinaryCofan.inl t) (BinaryCofan.inr t))\n    (by\n      rintro t (rfl | rfl)\n      \u00b7 exact hd\u2081 _ _\n      \u00b7 exact hd\u2082 _ _)\n    fun t m h => uniq _ _ _ (h \u27e8WalkingPair.left\u27e9) (h \u27e8WalkingPair.right\u27e9)", "start": [267, 1], "end": [281, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.IsColimit.hom_ext", "code": "theorem BinaryCofan.IsColimit.hom_ext {W X Y : C} {s : BinaryCofan X Y} (h : IsColimit s)\n    {f g : s.pt \u27f6 W} (h\u2081 : s.inl \u226b f = s.inl \u226b g) (h\u2082 : s.inr \u226b f = s.inr \u226b g) : f = g", "start": [284, 1], "end": [286, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.mk", "code": "@[simps pt]\ndef BinaryFan.mk {P : C} (\u03c0\u2081 : P \u27f6 X) (\u03c0\u2082 : P \u27f6 Y) : BinaryFan X Y where\n  pt := P\n  \u03c0 :=\n    { app := fun \u27e8j\u27e9 => by cases j <;> simpa }", "start": [298, 1], "end": [303, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.mk", "code": "@[simps pt]\ndef BinaryCofan.mk {P : C} (\u03b9\u2081 : X \u27f6 P) (\u03b9\u2082 : Y \u27f6 P) : BinaryCofan X Y where\n  pt := P\n  \u03b9 :=\n    { app := fun \u27e8j\u27e9 => by cases j <;> simpa }", "start": [306, 1], "end": [311, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.mk_fst", "code": "@[simp]\ntheorem BinaryFan.mk_fst {P : C} (\u03c0\u2081 : P \u27f6 X) (\u03c0\u2082 : P \u27f6 Y) : (BinaryFan.mk \u03c0\u2081 \u03c0\u2082).fst = \u03c0\u2081", "start": [316, 1], "end": [318, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.mk_snd", "code": "@[simp]\ntheorem BinaryFan.mk_snd {P : C} (\u03c0\u2081 : P \u27f6 X) (\u03c0\u2082 : P \u27f6 Y) : (BinaryFan.mk \u03c0\u2081 \u03c0\u2082).snd = \u03c0\u2082", "start": [321, 1], "end": [323, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.mk_inl", "code": "@[simp]\ntheorem BinaryCofan.mk_inl {P : C} (\u03b9\u2081 : X \u27f6 P) (\u03b9\u2082 : Y \u27f6 P) : (BinaryCofan.mk \u03b9\u2081 \u03b9\u2082).inl = \u03b9\u2081", "start": [326, 1], "end": [328, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.mk_inr", "code": "@[simp]\ntheorem BinaryCofan.mk_inr {P : C} (\u03b9\u2081 : X \u27f6 P) (\u03b9\u2082 : Y \u27f6 P) : (BinaryCofan.mk \u03b9\u2081 \u03b9\u2082).inr = \u03b9\u2082", "start": [331, 1], "end": [333, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isoBinaryFanMk", "code": "def isoBinaryFanMk {X Y : C} (c : BinaryFan X Y) : c \u2245 BinaryFan.mk c.fst c.snd :=\n    Cones.ext (Iso.refl _) fun j => by cases' j with l; cases l; repeat simp", "start": [336, 1], "end": [338, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isoBinaryCofanMk", "code": "def isoBinaryCofanMk {X Y : C} (c : BinaryCofan X Y) : c \u2245 BinaryCofan.mk c.inl c.inr :=\n    Cocones.ext (Iso.refl _) fun j => by cases' j with l; cases l; repeat simp", "start": [341, 1], "end": [343, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.isLimitMk", "code": "def BinaryFan.isLimitMk {W : C} {fst : W \u27f6 X} {snd : W \u27f6 Y} (lift : \u2200 s : BinaryFan X Y, s.pt \u27f6 W)\n    (fac_left : \u2200 s : BinaryFan X Y, lift s \u226b fst = s.fst)\n    (fac_right : \u2200 s : BinaryFan X Y, lift s \u226b snd = s.snd)\n    (uniq :\n      \u2200 (s : BinaryFan X Y) (m : s.pt \u27f6 W) (_ : m \u226b fst = s.fst) (_ : m \u226b snd = s.snd),\n        m = lift s) :\n    IsLimit (BinaryFan.mk fst snd) :=\n  { lift := lift\n    fac := fun s j => by\n      rcases j with \u27e8\u27e8\u27e9\u27e9\n      exacts [fac_left s, fac_right s]\n    uniq := fun s m w => uniq s m (w \u27e8WalkingPair.left\u27e9) (w \u27e8WalkingPair.right\u27e9) }", "start": [346, 1], "end": [360, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.isColimitMk", "code": "def BinaryCofan.isColimitMk {W : C} {inl : X \u27f6 W} {inr : Y \u27f6 W}\n    (desc : \u2200 s : BinaryCofan X Y, W \u27f6 s.pt)\n    (fac_left : \u2200 s : BinaryCofan X Y, inl \u226b desc s = s.inl)\n    (fac_right : \u2200 s : BinaryCofan X Y, inr \u226b desc s = s.inr)\n    (uniq :\n      \u2200 (s : BinaryCofan X Y) (m : W \u27f6 s.pt) (_ : inl \u226b m = s.inl) (_ : inr \u226b m = s.inr),\n        m = desc s) :\n    IsColimit (BinaryCofan.mk inl inr) :=\n  { desc := desc\n    fac := fun s j => by\n      rcases j with \u27e8\u27e8\u27e9\u27e9\n      exacts [fac_left s, fac_right s]\n    uniq := fun s m w => uniq s m (w \u27e8WalkingPair.left\u27e9) (w \u27e8WalkingPair.right\u27e9) }", "start": [363, 1], "end": [378, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.IsLimit.lift'", "code": "@[simps]\ndef BinaryFan.IsLimit.lift' {W X Y : C} {s : BinaryFan X Y} (h : IsLimit s) (f : W \u27f6 X)\n    (g : W \u27f6 Y) : { l : W \u27f6 s.pt // l \u226b s.fst = f \u2227 l \u226b s.snd = g } :=\n  \u27e8h.lift <| BinaryFan.mk f g, h.fac _ _, h.fac _ _\u27e9", "start": [381, 1], "end": [387, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.IsColimit.desc'", "code": "@[simps]\ndef BinaryCofan.IsColimit.desc' {W X Y : C} {s : BinaryCofan X Y} (h : IsColimit s) (f : X \u27f6 W)\n    (g : Y \u27f6 W) : { l : s.pt \u27f6 W // s.inl \u226b l = f \u2227 s.inr \u226b l = g } :=\n  \u27e8h.desc <| BinaryCofan.mk f g, h.fac _ _, h.fac _ _\u27e9", "start": [390, 1], "end": [396, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.isLimitFlip", "code": "def BinaryFan.isLimitFlip {X Y : C} {c : BinaryFan X Y} (hc : IsLimit c) :\n    IsLimit (BinaryFan.mk c.snd c.fst) :=\n  BinaryFan.isLimitMk (fun s => hc.lift (BinaryFan.mk s.snd s.fst)) (fun _ => hc.fac _ _)\n    (fun _ => hc.fac _ _) fun s _ e\u2081 e\u2082 =>\n    BinaryFan.IsLimit.hom_ext hc\n      (e\u2082.trans (hc.fac (BinaryFan.mk s.snd s.fst) \u27e8WalkingPair.left\u27e9).symm)\n      (e\u2081.trans (hc.fac (BinaryFan.mk s.snd s.fst) \u27e8WalkingPair.right\u27e9).symm)", "start": [399, 1], "end": [406, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.isLimit_iff_isIso_fst", "code": "theorem BinaryFan.isLimit_iff_isIso_fst {X Y : C} (h : IsTerminal Y) (c : BinaryFan X Y) :\n    Nonempty (IsLimit c) \u2194 IsIso c.fst", "start": [409, 1], "end": [422, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.isLimit_iff_isIso_snd", "code": "theorem BinaryFan.isLimit_iff_isIso_snd {X Y : C} (h : IsTerminal X) (c : BinaryFan X Y) :\n    Nonempty (IsLimit c) \u2194 IsIso c.snd", "start": [425, 1], "end": [430, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.isLimitCompLeftIso", "code": "noncomputable def BinaryFan.isLimitCompLeftIso {X Y X' : C} (c : BinaryFan X Y) (f : X \u27f6 X')\n    [IsIso f] (h : IsLimit c) : IsLimit (BinaryFan.mk (c.fst \u226b f) c.snd) := by\n  fapply BinaryFan.isLimitMk\n  \u00b7 exact fun s => h.lift (BinaryFan.mk (s.fst \u226b inv f) s.snd)\n  \u00b7 intro s simp only [Category.comp_id,BinaryFan.\u03c0_app_left,IsIso.inv_hom_id,\n      BinaryFan.mk_fst,IsLimit.fac_assoc,eq_self_iff_true,Category.assoc]\n  \u00b7 intro s simp only [BinaryFan.\u03c0_app_right,BinaryFan.mk_snd,eq_self_iff_true,IsLimit.fac]\n  \u00b7 intro s m e\u2081 e\u2082\n     apply BinaryFan.IsLimit.hom_ext h\n    \u00b7 simpa only\n      [BinaryFan.\u03c0_app_left,BinaryFan.mk_fst,Category.assoc,IsLimit.fac,IsIso.eq_comp_inv]\n    \u00b7 simpa only [BinaryFan.\u03c0_app_right,BinaryFan.mk_snd,IsLimit.fac]", "start": [433, 1], "end": [448, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryFan.isLimitCompRightIso", "code": "noncomputable def BinaryFan.isLimitCompRightIso {X Y Y' : C} (c : BinaryFan X Y) (f : Y \u27f6 Y')\n    [IsIso f] (h : IsLimit c) : IsLimit (BinaryFan.mk c.fst (c.snd \u226b f)) :=\n  BinaryFan.isLimitFlip <| BinaryFan.isLimitCompLeftIso _ f (BinaryFan.isLimitFlip h)", "start": [451, 1], "end": [454, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.isColimitFlip", "code": "def BinaryCofan.isColimitFlip {X Y : C} {c : BinaryCofan X Y} (hc : IsColimit c) :\n    IsColimit (BinaryCofan.mk c.inr c.inl) :=\n  BinaryCofan.isColimitMk (fun s => hc.desc (BinaryCofan.mk s.inr s.inl)) (fun _ => hc.fac _ _)\n    (fun _ => hc.fac _ _) fun s _ e\u2081 e\u2082 =>\n    BinaryCofan.IsColimit.hom_ext hc\n      (e\u2082.trans (hc.fac (BinaryCofan.mk s.inr s.inl) \u27e8WalkingPair.left\u27e9).symm)\n      (e\u2081.trans (hc.fac (BinaryCofan.mk s.inr s.inl) \u27e8WalkingPair.right\u27e9).symm)", "start": [457, 1], "end": [464, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.isColimit_iff_isIso_inl", "code": "theorem BinaryCofan.isColimit_iff_isIso_inl {X Y : C} (h : IsInitial Y) (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) \u2194 IsIso c.inl", "start": [467, 1], "end": [480, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.isColimit_iff_isIso_inr", "code": "theorem BinaryCofan.isColimit_iff_isIso_inr {X Y : C} (h : IsInitial X) (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) \u2194 IsIso c.inr", "start": [483, 1], "end": [488, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.isColimitCompLeftIso", "code": "noncomputable def BinaryCofan.isColimitCompLeftIso {X Y X' : C} (c : BinaryCofan X Y) (f : X' \u27f6 X)\n    [IsIso f] (h : IsColimit c) : IsColimit (BinaryCofan.mk (f \u226b c.inl) c.inr) := by\n  fapply BinaryCofan.isColimitMk\n  \u00b7 exact fun s => h.desc (BinaryCofan.mk (inv f \u226b s.inl) s.inr)\n  \u00b7 intro s\n    simp only [IsColimit.fac,BinaryCofan.\u03b9_app_left,eq_self_iff_true,\n      Category.assoc,BinaryCofan.mk_inl,IsIso.hom_inv_id_assoc]\n  \u00b7 intro s\n    simp only [IsColimit.fac,BinaryCofan.\u03b9_app_right,eq_self_iff_true,BinaryCofan.mk_inr]\n  \u00b7 intro s m e\u2081 e\u2082\n    apply BinaryCofan.IsColimit.hom_ext h\n    \u00b7 rw [\u2190 cancel_epi f]\n    simpa only [IsColimit.fac,BinaryCofan.\u03b9_app_left,eq_self_iff_true,\n      Category.assoc,BinaryCofan.mk_inl,IsIso.hom_inv_id_assoc] using e\u2081\n    \u00b7 simpa only [IsColimit.fac,BinaryCofan.\u03b9_app_right,eq_self_iff_true,BinaryCofan.mk_inr]", "start": [491, 1], "end": [510, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.BinaryCofan.isColimitCompRightIso", "code": "noncomputable def BinaryCofan.isColimitCompRightIso {X Y Y' : C} (c : BinaryCofan X Y) (f : Y' \u27f6 Y)\n    [IsIso f] (h : IsColimit c) : IsColimit (BinaryCofan.mk c.inl (f \u226b c.inr)) :=\n  BinaryCofan.isColimitFlip <| BinaryCofan.isColimitCompLeftIso _ f (BinaryCofan.isColimitFlip h)", "start": [513, 1], "end": [516, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasBinaryProduct", "code": "abbrev HasBinaryProduct (X Y : C) :=\n  HasLimit (pair X Y)", "start": [519, 1], "end": [521, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasBinaryCoproduct", "code": "abbrev HasBinaryCoproduct (X Y : C) :=\n  HasColimit (pair X Y)", "start": [524, 1], "end": [526, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod", "code": "abbrev prod (X Y : C) [HasBinaryProduct X Y] :=\n  limit (pair X Y)", "start": [529, 1], "end": [532, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod", "code": "abbrev coprod (X Y : C) [HasBinaryCoproduct X Y] :=\n  colimit (pair X Y)", "start": [535, 1], "end": [538, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.fst", "code": "abbrev prod.fst {X Y : C} [HasBinaryProduct X Y] : X \u2a2f Y \u27f6 X :=\n  limit.\u03c0 (pair X Y) \u27e8WalkingPair.left\u27e9", "start": [547, 1], "end": [549, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.snd", "code": "abbrev prod.snd {X Y : C} [HasBinaryProduct X Y] : X \u2a2f Y \u27f6 Y :=\n  limit.\u03c0 (pair X Y) \u27e8WalkingPair.right\u27e9", "start": [552, 1], "end": [554, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.inl", "code": "abbrev coprod.inl {X Y : C} [HasBinaryCoproduct X Y] : X \u27f6 X \u2a3f Y :=\n  colimit.\u03b9 (pair X Y) \u27e8WalkingPair.left\u27e9", "start": [557, 1], "end": [559, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.inr", "code": "abbrev coprod.inr {X Y : C} [HasBinaryCoproduct X Y] : Y \u27f6 X \u2a3f Y :=\n  colimit.\u03b9 (pair X Y) \u27e8WalkingPair.right\u27e9", "start": [562, 1], "end": [564, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prodIsProd", "code": "def prodIsProd (X Y : C) [HasBinaryProduct X Y] :\n    IsLimit (BinaryFan.mk (prod.fst : X \u2a2f Y \u27f6 X) prod.snd) :=\n  (limit.isLimit _).ofIsoLimit (Cones.ext (Iso.refl _) (fun \u27e8u\u27e9 => by\n    cases u\n    \u00b7 dsimp; simp only [Category.id_comp]; rfl\n    \u00b7 dsimp; simp only [Category.id_comp]; rfl\n  ))", "start": [567, 1], "end": [574, 5], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprodIsCoprod", "code": "def coprodIsCoprod (X Y : C) [HasBinaryCoproduct X Y] :\n    IsColimit (BinaryCofan.mk (coprod.inl : X \u27f6 X \u2a3f Y) coprod.inr) :=\n  (colimit.isColimit _).ofIsoColimit (Cocones.ext (Iso.refl _) (fun \u27e8u\u27e9 => by\n    cases u\n    \u00b7 dsimp; simp only [Category.comp_id]\n    \u00b7 dsimp; simp only [Category.comp_id]\n  ))", "start": [577, 1], "end": [584, 5], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.hom_ext", "code": "@[ext 1100]\ntheorem prod.hom_ext {W X Y : C} [HasBinaryProduct X Y] {f g : W \u27f6 X \u2a2f Y}\n    (h\u2081 : f \u226b prod.fst = g \u226b prod.fst) (h\u2082 : f \u226b prod.snd = g \u226b prod.snd) : f = g", "start": [587, 1], "end": [590, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.hom_ext", "code": "@[ext 1100]\ntheorem coprod.hom_ext {W X Y : C} [HasBinaryCoproduct X Y] {f g : X \u2a3f Y \u27f6 W}\n    (h\u2081 : coprod.inl \u226b f = coprod.inl \u226b g) (h\u2082 : coprod.inr \u226b f = coprod.inr \u226b g) : f = g", "start": [593, 1], "end": [596, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.lift", "code": "abbrev prod.lift {W X Y : C} [HasBinaryProduct X Y] (f : W \u27f6 X) (g : W \u27f6 Y) : W \u27f6 X \u2a2f Y :=\n  limit.lift _ (BinaryFan.mk f g)", "start": [599, 1], "end": [602, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.diag", "code": "abbrev diag (X : C) [HasBinaryProduct X X] : X \u27f6 X \u2a2f X :=\n  prod.lift (\ud835\udfd9 _) (\ud835\udfd9 _)", "start": [605, 1], "end": [607, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.desc", "code": "abbrev coprod.desc {W X Y : C} [HasBinaryCoproduct X Y] (f : X \u27f6 W) (g : Y \u27f6 W) : X \u2a3f Y \u27f6 W :=\n  colimit.desc _ (BinaryCofan.mk f g)", "start": [610, 1], "end": [613, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.codiag", "code": "abbrev codiag (X : C) [HasBinaryCoproduct X X] : X \u2a3f X \u27f6 X :=\n  coprod.desc (\ud835\udfd9 _) (\ud835\udfd9 _)", "start": [616, 1], "end": [618, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.lift_fst", "code": "@[reassoc]\ntheorem prod.lift_fst {W X Y : C} [HasBinaryProduct X Y] (f : W \u27f6 X) (g : W \u27f6 Y) :\n    prod.lift f g \u226b prod.fst = f", "start": [622, 1], "end": [625, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.lift_snd", "code": "@[reassoc]\ntheorem prod.lift_snd {W X Y : C} [HasBinaryProduct X Y] (f : W \u27f6 X) (g : W \u27f6 Y) :\n    prod.lift f g \u226b prod.snd = g", "start": [630, 1], "end": [633, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.inl_desc", "code": "@[reassoc]\ntheorem coprod.inl_desc {W X Y : C} [HasBinaryCoproduct X Y] (f : X \u27f6 W) (g : Y \u27f6 W) :\n    coprod.inl \u226b coprod.desc f g = f", "start": [639, 1], "end": [642, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.inr_desc", "code": "@[reassoc]\ntheorem coprod.inr_desc {W X Y : C} [HasBinaryCoproduct X Y] (f : X \u27f6 W) (g : Y \u27f6 W) :\n    coprod.inr \u226b coprod.desc f g = g", "start": [648, 1], "end": [651, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.mono_lift_of_mono_left", "code": "instance prod.mono_lift_of_mono_left {W X Y : C} [HasBinaryProduct X Y] (f : W \u27f6 X) (g : W \u27f6 Y)\n    [Mono f] : Mono (prod.lift f g) :=\n  mono_of_mono_fac <| prod.lift_fst _ _", "start": [655, 1], "end": [657, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.mono_lift_of_mono_right", "code": "instance prod.mono_lift_of_mono_right {W X Y : C} [HasBinaryProduct X Y] (f : W \u27f6 X) (g : W \u27f6 Y)\n    [Mono g] : Mono (prod.lift f g) :=\n  mono_of_mono_fac <| prod.lift_snd _ _", "start": [660, 1], "end": [662, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.epi_desc_of_epi_left", "code": "instance coprod.epi_desc_of_epi_left {W X Y : C} [HasBinaryCoproduct X Y] (f : X \u27f6 W) (g : Y \u27f6 W)\n    [Epi f] : Epi (coprod.desc f g) :=\n  epi_of_epi_fac <| coprod.inl_desc _ _", "start": [665, 1], "end": [667, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.epi_desc_of_epi_right", "code": "instance coprod.epi_desc_of_epi_right {W X Y : C} [HasBinaryCoproduct X Y] (f : X \u27f6 W) (g : Y \u27f6 W)\n    [Epi g] : Epi (coprod.desc f g) :=\n  epi_of_epi_fac <| coprod.inr_desc _ _", "start": [670, 1], "end": [672, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.lift'", "code": "def prod.lift' {W X Y : C} [HasBinaryProduct X Y] (f : W \u27f6 X) (g : W \u27f6 Y) :\n    { l : W \u27f6 X \u2a2f Y // l \u226b prod.fst = f \u2227 l \u226b prod.snd = g } :=\n  \u27e8prod.lift f g, prod.lift_fst _ _, prod.lift_snd _ _\u27e9", "start": [675, 1], "end": [679, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.desc'", "code": "def coprod.desc' {W X Y : C} [HasBinaryCoproduct X Y] (f : X \u27f6 W) (g : Y \u27f6 W) :\n    { l : X \u2a3f Y \u27f6 W // coprod.inl \u226b l = f \u2227 coprod.inr \u226b l = g } :=\n  \u27e8coprod.desc f g, coprod.inl_desc _ _, coprod.inr_desc _ _\u27e9", "start": [682, 1], "end": [687, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.map", "code": "def prod.map {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W \u27f6 Y) (g : X \u27f6 Z) :\n    W \u2a2f X \u27f6 Y \u2a2f Z :=\n  limMap (mapPair f g)", "start": [690, 1], "end": [694, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.map", "code": "def coprod.map {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W \u27f6 Y)\n    (g : X \u27f6 Z) : W \u2a3f X \u27f6 Y \u2a3f Z :=\n  colimMap (mapPair f g)", "start": [697, 1], "end": [701, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.comp_lift", "code": "@[reassoc, simp]\ntheorem prod.comp_lift {V W X Y : C} [HasBinaryProduct X Y] (f : V \u27f6 W) (g : W \u27f6 X) (h : W \u27f6 Y) :\n    f \u226b prod.lift g h = prod.lift (f \u226b g) (f \u226b h)", "start": [707, 1], "end": [709, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.comp_diag", "code": "theorem prod.comp_diag {X Y : C} [HasBinaryProduct Y Y] (f : X \u27f6 Y) : f \u226b diag Y = prod.lift f f", "start": [713, 1], "end": [714, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.map_fst", "code": "@[reassoc (attr := simp)]\ntheorem prod.map_fst {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W \u27f6 Y)\n    (g : X \u27f6 Z) : prod.map f g \u226b prod.fst = prod.fst \u226b f", "start": [717, 1], "end": [720, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.map_snd", "code": "@[reassoc (attr := simp)]\ntheorem prod.map_snd {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W \u27f6 Y)\n    (g : X \u27f6 Z) : prod.map f g \u226b prod.snd = prod.snd \u226b g", "start": [724, 1], "end": [727, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.map_id_id", "code": "@[simp]\ntheorem prod.map_id_id {X Y : C} [HasBinaryProduct X Y] : prod.map (\ud835\udfd9 X) (\ud835\udfd9 Y) = \ud835\udfd9 _", "start": [731, 1], "end": [733, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.lift_fst_snd", "code": "@[simp]\ntheorem prod.lift_fst_snd {X Y : C} [HasBinaryProduct X Y] :\n    prod.lift prod.fst prod.snd = \ud835\udfd9 (X \u2a2f Y)", "start": [736, 1], "end": [738, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.lift_map", "code": "@[reassoc (attr := simp)]\ntheorem prod.lift_map {V W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : V \u27f6 W)\n    (g : V \u27f6 X) (h : W \u27f6 Y) (k : X \u27f6 Z) :\n    prod.lift f g \u226b prod.map h k = prod.lift (f \u226b h) (g \u226b k)", "start": [741, 1], "end": [744, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.lift_fst_comp_snd_comp", "code": "@[simp]\ntheorem prod.lift_fst_comp_snd_comp {W X Y Z : C} [HasBinaryProduct W Y] [HasBinaryProduct X Z]\n    (g : W \u27f6 X) (g' : Y \u27f6 Z) : prod.lift (prod.fst \u226b g) (prod.snd \u226b g') = prod.map g g'", "start": [748, 1], "end": [752, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.map_map", "code": "@[reassoc (attr := simp)]\ntheorem prod.map_map {A\u2081 A\u2082 A\u2083 B\u2081 B\u2082 B\u2083 : C} [HasBinaryProduct A\u2081 B\u2081] [HasBinaryProduct A\u2082 B\u2082]\n    [HasBinaryProduct A\u2083 B\u2083] (f : A\u2081 \u27f6 A\u2082) (g : B\u2081 \u27f6 B\u2082) (h : A\u2082 \u27f6 A\u2083) (k : B\u2082 \u27f6 B\u2083) :\n    prod.map f g \u226b prod.map h k = prod.map (f \u226b h) (g \u226b k)", "start": [758, 1], "end": [761, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.map_swap", "code": "@[reassoc]\ntheorem prod.map_swap {A B X Y : C} (f : A \u27f6 B) (g : X \u27f6 Y)\n    [HasLimitsOfShape (Discrete WalkingPair) C] :\n    prod.map (\ud835\udfd9 X) f \u226b prod.map g (\ud835\udfd9 B) = prod.map g (\ud835\udfd9 A) \u226b prod.map (\ud835\udfd9 Y) f", "start": [766, 1], "end": [769, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.map_comp_id", "code": "@[reassoc]\ntheorem prod.map_comp_id {X Y Z W : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [HasBinaryProduct X W]\n    [HasBinaryProduct Z W] [HasBinaryProduct Y W] :\n    prod.map (f \u226b g) (\ud835\udfd9 W) = prod.map f (\ud835\udfd9 W) \u226b prod.map g (\ud835\udfd9 W)", "start": [773, 1], "end": [776, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.map_id_comp", "code": "@[reassoc]\ntheorem prod.map_id_comp {X Y Z W : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [HasBinaryProduct W X]\n    [HasBinaryProduct W Y] [HasBinaryProduct W Z] :\n    prod.map (\ud835\udfd9 W) (f \u226b g) = prod.map (\ud835\udfd9 W) f \u226b prod.map (\ud835\udfd9 W) g", "start": [780, 1], "end": [783, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.mapIso", "code": "@[simps]\ndef prod.mapIso {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W \u2245 Y)\n    (g : X \u2245 Z) : W \u2a2f X \u2245 Y \u2a2f Z where\n  hom := prod.map f.hom g.hom\n  inv := prod.map f.inv g.inv", "start": [787, 1], "end": [793, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_prod", "code": "instance isIso_prod {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W \u27f6 Y)\n    (g : X \u27f6 Z) [IsIso f] [IsIso g] : IsIso (prod.map f g) :=\n  IsIso.of_iso (prod.mapIso (asIso f) (asIso g))", "start": [796, 1], "end": [798, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.map_mono", "code": "instance prod.map_mono {C : Type*} [Category C] {W X Y Z : C} (f : W \u27f6 Y) (g : X \u27f6 Z) [Mono f]\n    [Mono g] [HasBinaryProduct W X] [HasBinaryProduct Y Z] : Mono (prod.map f g) :=\n  \u27e8fun i\u2081 i\u2082 h => by\n    ext\n    \u00b7 rw [\u2190 cancel_mono f]\n      simpa using congr_arg (fun f => f \u226b prod.fst) h\n    \u00b7 rw [\u2190 cancel_mono g]\n      simpa using congr_arg (fun f => f \u226b prod.snd) h\u27e9", "start": [801, 1], "end": [808, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.diag_map", "code": "@[reassoc] theorem prod.diag_map {X Y : C} (f : X \u27f6 Y) [HasBinaryProduct X X] [HasBinaryProduct Y Y] :\n    diag X \u226b prod.map f f = f \u226b diag Y", "start": [811, 1], "end": [813, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.diag_map_fst_snd", "code": "@[reassoc] theorem prod.diag_map_fst_snd {X Y : C} [HasBinaryProduct X Y] [HasBinaryProduct (X \u2a2f Y) (X \u2a2f Y)] :\n    diag (X \u2a2f Y) \u226b prod.map prod.fst prod.snd = \ud835\udfd9 (X \u2a2f Y)", "start": [817, 1], "end": [819, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.diag_map_fst_snd_comp", "code": "@[reassoc] theorem prod.diag_map_fst_snd_comp [HasLimitsOfShape (Discrete WalkingPair) C] {X X' Y Y' : C}\n    (g : X \u27f6 Y) (g' : X' \u27f6 Y') :\n    diag (X \u2a2f X') \u226b prod.map (prod.fst \u226b g) (prod.snd \u226b g') = prod.map g g'", "start": [823, 1], "end": [826, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.desc_comp", "code": "@[simp] theorem coprod.desc_comp {V W X Y : C} [HasBinaryCoproduct X Y] (f : V \u27f6 W) (g : X \u27f6 V)\n    (h : Y \u27f6 V) : coprod.desc g h \u226b f = coprod.desc (g \u226b f) (h \u226b f)", "start": [838, 1], "end": [841, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.desc_comp_assoc", "code": "theorem coprod.desc_comp_assoc {C : Type u} [Category C] {V W X Y : C}\n    [HasBinaryCoproduct X Y] (f : V \u27f6 W) (g : X \u27f6 V) (h : Y \u27f6 V) {Z : C} (l : W \u27f6 Z) :\n    coprod.desc g h \u226b f \u226b l = coprod.desc (g \u226b f) (h \u226b f) \u226b l", "start": [845, 1], "end": [847, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.diag_comp", "code": "theorem coprod.diag_comp {X Y : C} [HasBinaryCoproduct X X] (f : X \u27f6 Y) :\n    codiag X \u226b f = coprod.desc f f", "start": [850, 1], "end": [851, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.inl_map", "code": "@[reassoc (attr := simp)]\ntheorem coprod.inl_map {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W \u27f6 Y)\n    (g : X \u27f6 Z) : coprod.inl \u226b coprod.map f g = f \u226b coprod.inl", "start": [854, 1], "end": [857, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.inr_map", "code": "@[reassoc (attr := simp)]\ntheorem coprod.inr_map {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W \u27f6 Y)\n    (g : X \u27f6 Z) : coprod.inr \u226b coprod.map f g = g \u226b coprod.inr", "start": [861, 1], "end": [864, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.map_id_id", "code": "@[simp]\ntheorem coprod.map_id_id {X Y : C} [HasBinaryCoproduct X Y] : coprod.map (\ud835\udfd9 X) (\ud835\udfd9 Y) = \ud835\udfd9 _", "start": [868, 1], "end": [870, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.desc_inl_inr", "code": "@[simp]\ntheorem coprod.desc_inl_inr {X Y : C} [HasBinaryCoproduct X Y] :\n    coprod.desc coprod.inl coprod.inr = \ud835\udfd9 (X \u2a3f Y)", "start": [873, 1], "end": [875, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.map_desc", "code": "@[reassoc, simp]\ntheorem coprod.map_desc {S T U V W : C} [HasBinaryCoproduct U W] [HasBinaryCoproduct T V]\n    (f : U \u27f6 S) (g : W \u27f6 S) (h : T \u27f6 U) (k : V \u27f6 W) :\n    coprod.map h k \u226b coprod.desc f g = coprod.desc (h \u226b f) (k \u226b g)", "start": [879, 1], "end": [883, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.desc_comp_inl_comp_inr", "code": "@[simp]\ntheorem coprod.desc_comp_inl_comp_inr {W X Y Z : C} [HasBinaryCoproduct W Y]\n    [HasBinaryCoproduct X Z] (g : W \u27f6 X) (g' : Y \u27f6 Z) :\n    coprod.desc (g \u226b coprod.inl) (g' \u226b coprod.inr) = coprod.map g g'", "start": [887, 1], "end": [891, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.map_map", "code": "@[reassoc (attr := simp)]\ntheorem coprod.map_map {A\u2081 A\u2082 A\u2083 B\u2081 B\u2082 B\u2083 : C} [HasBinaryCoproduct A\u2081 B\u2081] [HasBinaryCoproduct A\u2082 B\u2082]\n    [HasBinaryCoproduct A\u2083 B\u2083] (f : A\u2081 \u27f6 A\u2082) (g : B\u2081 \u27f6 B\u2082) (h : A\u2082 \u27f6 A\u2083) (k : B\u2082 \u27f6 B\u2083) :\n    coprod.map f g \u226b coprod.map h k = coprod.map (f \u226b h) (g \u226b k)", "start": [897, 1], "end": [901, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.map_swap", "code": "@[reassoc]\ntheorem coprod.map_swap {A B X Y : C} (f : A \u27f6 B) (g : X \u27f6 Y)\n    [HasColimitsOfShape (Discrete WalkingPair) C] :\n    coprod.map (\ud835\udfd9 X) f \u226b coprod.map g (\ud835\udfd9 B) = coprod.map g (\ud835\udfd9 A) \u226b coprod.map (\ud835\udfd9 Y) f", "start": [906, 1], "end": [909, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.map_comp_id", "code": "@[reassoc]\ntheorem coprod.map_comp_id {X Y Z W : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [HasBinaryCoproduct Z W]\n    [HasBinaryCoproduct Y W] [HasBinaryCoproduct X W] :\n    coprod.map (f \u226b g) (\ud835\udfd9 W) = coprod.map f (\ud835\udfd9 W) \u226b coprod.map g (\ud835\udfd9 W)", "start": [913, 1], "end": [916, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.map_id_comp", "code": "@[reassoc]\ntheorem coprod.map_id_comp {X Y Z W : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [HasBinaryCoproduct W X]\n    [HasBinaryCoproduct W Y] [HasBinaryCoproduct W Z] :\n    coprod.map (\ud835\udfd9 W) (f \u226b g) = coprod.map (\ud835\udfd9 W) f \u226b coprod.map (\ud835\udfd9 W) g", "start": [920, 1], "end": [923, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.mapIso", "code": "@[simps]\ndef coprod.mapIso {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W \u2245 Y)\n    (g : X \u2245 Z) : W \u2a3f X \u2245 Y \u2a3f Z where\n  hom := coprod.map f.hom g.hom\n  inv := coprod.map f.inv g.inv", "start": [927, 1], "end": [933, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_coprod", "code": "instance isIso_coprod {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W \u27f6 Y)\n    (g : X \u27f6 Z) [IsIso f] [IsIso g] : IsIso (coprod.map f g) :=\n  IsIso.of_iso (coprod.mapIso (asIso f) (asIso g))", "start": [936, 1], "end": [938, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.map_epi", "code": "instance coprod.map_epi {C : Type*} [Category C] {W X Y Z : C} (f : W \u27f6 Y) (g : X \u27f6 Z) [Epi f]\n    [Epi g] [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] : Epi (coprod.map f g) :=\n  \u27e8fun i\u2081 i\u2082 h => by\n    ext\n    \u00b7 rw [\u2190 cancel_epi f]\n      simpa using congr_arg (fun f => coprod.inl \u226b f) h\n    \u00b7 rw [\u2190 cancel_epi g]\n      simpa using congr_arg (fun f => coprod.inr \u226b f) h\u27e9", "start": [941, 1], "end": [948, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.map_codiag", "code": "@[reassoc]\ntheorem coprod.map_codiag {X Y : C} (f : X \u27f6 Y) [HasBinaryCoproduct X X] [HasBinaryCoproduct Y Y] :\n    coprod.map f f \u226b codiag Y = codiag X \u226b f", "start": [953, 1], "end": [955, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.map_inl_inr_codiag", "code": "@[reassoc]\ntheorem coprod.map_inl_inr_codiag {X Y : C} [HasBinaryCoproduct X Y]\n    [HasBinaryCoproduct (X \u2a3f Y) (X \u2a3f Y)] :\n    coprod.map coprod.inl coprod.inr \u226b codiag (X \u2a3f Y) = \ud835\udfd9 (X \u2a3f Y)", "start": [961, 1], "end": [964, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.map_comp_inl_inr_codiag", "code": "@[reassoc]\ntheorem coprod.map_comp_inl_inr_codiag [HasColimitsOfShape (Discrete WalkingPair) C] {X X' Y Y' : C}\n    (g : X \u27f6 Y) (g' : X' \u27f6 Y') :\n    coprod.map (g \u226b coprod.inl) (g' \u226b coprod.inr) \u226b codiag (Y \u2a3f Y') = coprod.map g g'", "start": [970, 1], "end": [973, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasBinaryProducts", "code": "abbrev HasBinaryProducts :=\n  HasLimitsOfShape (Discrete WalkingPair) C", "start": [981, 1], "end": [986, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasBinaryCoproducts", "code": "abbrev HasBinaryCoproducts :=\n  HasColimitsOfShape (Discrete WalkingPair) C", "start": [989, 1], "end": [994, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasBinaryProducts_of_hasLimit_pair", "code": "theorem hasBinaryProducts_of_hasLimit_pair [\u2200 {X Y : C}, HasLimit (pair X Y)] :\n    HasBinaryProducts C", "start": [997, 1], "end": [1000, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasBinaryCoproducts_of_hasColimit_pair", "code": "theorem hasBinaryCoproducts_of_hasColimit_pair [\u2200 {X Y : C}, HasColimit (pair X Y)] :\n    HasBinaryCoproducts C", "start": [1003, 1], "end": [1006, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.braiding", "code": "@[simps]\ndef prod.braiding (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] : P \u2a2f Q \u2245 Q \u2a2f P\n    where\n  hom := prod.lift prod.snd prod.fst\n  inv := prod.lift prod.snd prod.fst", "start": [1013, 1], "end": [1018, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.braid_natural", "code": "@[reassoc]\ntheorem braid_natural [HasBinaryProducts C] {W X Y Z : C} (f : X \u27f6 Y) (g : Z \u27f6 W) :\n    prod.map f g \u226b (prod.braiding _ _).hom = (prod.braiding _ _).hom \u226b prod.map g f", "start": [1021, 1], "end": [1024, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.symmetry'", "code": "@[reassoc]\ntheorem prod.symmetry' (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] :\n    prod.lift prod.snd prod.fst \u226b prod.lift prod.snd prod.fst = \ud835\udfd9 (P \u2a2f Q)", "start": [1028, 1], "end": [1031, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.symmetry", "code": "@[reassoc]\ntheorem prod.symmetry (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] :\n    (prod.braiding P Q).hom \u226b (prod.braiding Q P).hom = \ud835\udfd9 _", "start": [1035, 1], "end": [1039, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.associator", "code": "@[simps]\ndef prod.associator [HasBinaryProducts C] (P Q R : C) : (P \u2a2f Q) \u2a2f R \u2245 P \u2a2f Q \u2a2f R where\n  hom := prod.lift (prod.fst \u226b prod.fst) (prod.lift (prod.fst \u226b prod.snd) prod.snd)\n  inv := prod.lift (prod.lift prod.fst (prod.snd \u226b prod.fst)) (prod.snd \u226b prod.snd)", "start": [1043, 1], "end": [1047, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.pentagon", "code": "@[reassoc]\ntheorem prod.pentagon [HasBinaryProducts C] (W X Y Z : C) :\n    prod.map (prod.associator W X Y).hom (\ud835\udfd9 Z) \u226b\n        (prod.associator W (X \u2a2f Y) Z).hom \u226b prod.map (\ud835\udfd9 W) (prod.associator X Y Z).hom =\n      (prod.associator (W \u2a2f X) Y Z).hom \u226b (prod.associator W X (Y \u2a2f Z)).hom", "start": [1050, 1], "end": [1055, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.associator_naturality", "code": "@[reassoc]\ntheorem prod.associator_naturality [HasBinaryProducts C] {X\u2081 X\u2082 X\u2083 Y\u2081 Y\u2082 Y\u2083 : C} (f\u2081 : X\u2081 \u27f6 Y\u2081)\n    (f\u2082 : X\u2082 \u27f6 Y\u2082) (f\u2083 : X\u2083 \u27f6 Y\u2083) :\n    prod.map (prod.map f\u2081 f\u2082) f\u2083 \u226b (prod.associator Y\u2081 Y\u2082 Y\u2083).hom =\n      (prod.associator X\u2081 X\u2082 X\u2083).hom \u226b prod.map f\u2081 (prod.map f\u2082 f\u2083)", "start": [1059, 1], "end": [1064, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.leftUnitor", "code": "@[simps]\ndef prod.leftUnitor (P : C) [HasBinaryProduct (\u22a4_ C) P] : (\u22a4_ C) \u2a2f P \u2245 P where\n  hom := prod.snd\n  inv := prod.lift (terminal.from P) (\ud835\udfd9 _)\n  hom_inv_id := by apply prod.hom_ext <;> simp\n  inv_hom_id := by simp", "start": [1070, 1], "end": [1076, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.rightUnitor", "code": "@[simps]\ndef prod.rightUnitor (P : C) [HasBinaryProduct P (\u22a4_ C)] : P \u2a2f \u22a4_ C \u2245 P where\n  hom := prod.fst\n  inv := prod.lift (\ud835\udfd9 _) (terminal.from P)\n  hom_inv_id := by apply prod.hom_ext <;> simp\n  inv_hom_id := by simp", "start": [1079, 1], "end": [1085, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.leftUnitor_hom_naturality", "code": "@[reassoc]\ntheorem prod.leftUnitor_hom_naturality [HasBinaryProducts C] (f : X \u27f6 Y) :\n    prod.map (\ud835\udfd9 _) f \u226b (prod.leftUnitor Y).hom = (prod.leftUnitor X).hom \u226b f", "start": [1088, 1], "end": [1091, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.leftUnitor_inv_naturality", "code": "@[reassoc]\ntheorem prod.leftUnitor_inv_naturality [HasBinaryProducts C] (f : X \u27f6 Y) :\n    (prod.leftUnitor X).inv \u226b prod.map (\ud835\udfd9 _) f = f \u226b (prod.leftUnitor Y).inv", "start": [1095, 1], "end": [1098, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.rightUnitor_hom_naturality", "code": "@[reassoc]\ntheorem prod.rightUnitor_hom_naturality [HasBinaryProducts C] (f : X \u27f6 Y) :\n    prod.map f (\ud835\udfd9 _) \u226b (prod.rightUnitor Y).hom = (prod.rightUnitor X).hom \u226b f", "start": [1102, 1], "end": [1105, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod_rightUnitor_inv_naturality", "code": "@[reassoc]\ntheorem prod_rightUnitor_inv_naturality [HasBinaryProducts C] (f : X \u27f6 Y) :\n    (prod.rightUnitor X).inv \u226b prod.map f (\ud835\udfd9 _) = f \u226b (prod.rightUnitor Y).inv", "start": [1109, 1], "end": [1112, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.triangle", "code": "theorem prod.triangle [HasBinaryProducts C] (X Y : C) :\n    (prod.associator X (\u22a4_ C) Y).hom \u226b prod.map (\ud835\udfd9 X) (prod.leftUnitor Y).hom =\n      prod.map (prod.rightUnitor X).hom (\ud835\udfd9 Y)", "start": [1116, 1], "end": [1119, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.braiding", "code": "@[simps]\ndef coprod.braiding (P Q : C) : P \u2a3f Q \u2245 Q \u2a3f P where\n  hom := coprod.desc coprod.inr coprod.inl\n  inv := coprod.desc coprod.inr coprod.inl", "start": [1129, 1], "end": [1133, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.symmetry'", "code": "@[reassoc]\ntheorem coprod.symmetry' (P Q : C) :\n    coprod.desc coprod.inr coprod.inl \u226b coprod.desc coprod.inr coprod.inl = \ud835\udfd9 (P \u2a3f Q)", "start": [1136, 1], "end": [1139, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.symmetry", "code": "theorem coprod.symmetry (P Q : C) : (coprod.braiding P Q).hom \u226b (coprod.braiding Q P).hom = \ud835\udfd9 _", "start": [1143, 1], "end": [1145, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.associator", "code": "@[simps]\ndef coprod.associator (P Q R : C) : (P \u2a3f Q) \u2a3f R \u2245 P \u2a3f Q \u2a3f R where\n  hom := coprod.desc (coprod.desc coprod.inl (coprod.inl \u226b coprod.inr)) (coprod.inr \u226b coprod.inr)\n  inv := coprod.desc (coprod.inl \u226b coprod.inl) (coprod.desc (coprod.inr \u226b coprod.inl) coprod.inr)", "start": [1148, 1], "end": [1152, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.pentagon", "code": "theorem coprod.pentagon (W X Y Z : C) :\n    coprod.map (coprod.associator W X Y).hom (\ud835\udfd9 Z) \u226b\n        (coprod.associator W (X \u2a3f Y) Z).hom \u226b coprod.map (\ud835\udfd9 W) (coprod.associator X Y Z).hom =\n      (coprod.associator (W \u2a3f X) Y Z).hom \u226b (coprod.associator W X (Y \u2a3f Z)).hom", "start": [1155, 1], "end": [1159, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.associator_naturality", "code": "theorem coprod.associator_naturality {X\u2081 X\u2082 X\u2083 Y\u2081 Y\u2082 Y\u2083 : C} (f\u2081 : X\u2081 \u27f6 Y\u2081) (f\u2082 : X\u2082 \u27f6 Y\u2082)\n    (f\u2083 : X\u2083 \u27f6 Y\u2083) :\n    coprod.map (coprod.map f\u2081 f\u2082) f\u2083 \u226b (coprod.associator Y\u2081 Y\u2082 Y\u2083).hom =\n      (coprod.associator X\u2081 X\u2082 X\u2083).hom \u226b coprod.map f\u2081 (coprod.map f\u2082 f\u2083)", "start": [1162, 1], "end": [1166, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.leftUnitor", "code": "@[simps]\ndef coprod.leftUnitor (P : C) : (\u22a5_ C) \u2a3f P \u2245 P where\n  hom := coprod.desc (initial.to P) (\ud835\udfd9 _)\n  inv := coprod.inr\n  hom_inv_id := by apply coprod.hom_ext <;> simp\n  inv_hom_id := by simp", "start": [1171, 1], "end": [1177, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.rightUnitor", "code": "@[simps]\ndef coprod.rightUnitor (P : C) : P \u2a3f \u22a5_ C \u2245 P where\n  hom := coprod.desc (\ud835\udfd9 _) (initial.to P)\n  inv := coprod.inl\n  hom_inv_id := by apply coprod.hom_ext <;> simp\n  inv_hom_id := by simp", "start": [1180, 1], "end": [1186, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.triangle", "code": "theorem coprod.triangle (X Y : C) :\n    (coprod.associator X (\u22a5_ C) Y).hom \u226b coprod.map (\ud835\udfd9 X) (coprod.leftUnitor Y).hom =\n      coprod.map (coprod.rightUnitor X).hom (\ud835\udfd9 Y)", "start": [1189, 1], "end": [1192, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.functor", "code": "@[simps]\ndef prod.functor : C \u2964 C \u2964 C where\n  obj X :=\n    { obj := fun Y => X \u2a2f Y\n      map := fun {Y Z} => prod.map (\ud835\udfd9 X) }\n  map f :=\n    { app := fun T => prod.map f (\ud835\udfd9 T) }", "start": [1202, 1], "end": [1209, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prod.functorLeftComp", "code": "def prod.functorLeftComp (X Y : C) :\n    prod.functor.obj (X \u2a2f Y) \u2245 prod.functor.obj Y \u22d9 prod.functor.obj X :=\n  NatIso.ofComponents (prod.associator _ _)", "start": [1212, 1], "end": [1215, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.functor", "code": "@[simps]\ndef coprod.functor : C \u2964 C \u2964 C where\n  obj X :=\n    { obj := fun Y => X \u2a3f Y\n      map := fun {Y Z} => coprod.map (\ud835\udfd9 X) }\n  map f := { app := fun T => coprod.map f (\ud835\udfd9 T) }", "start": [1225, 1], "end": [1231, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprod.functorLeftComp", "code": "def coprod.functorLeftComp (X Y : C) :\n    coprod.functor.obj (X \u2a3f Y) \u2245 coprod.functor.obj Y \u22d9 coprod.functor.obj X :=\n  NatIso.ofComponents (coprod.associator _ _)", "start": [1234, 1], "end": [1237, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prodComparison", "code": "def prodComparison (F : C \u2964 D) (A B : C) [HasBinaryProduct A B]\n    [HasBinaryProduct (F.obj A) (F.obj B)] : F.obj (A \u2a2f B) \u27f6 F.obj A \u2a2f F.obj B :=\n  prod.lift (F.map prod.fst) (F.map prod.snd)", "start": [1254, 1], "end": [1260, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prodComparison_fst", "code": "@[reassoc (attr := simp)]\ntheorem prodComparison_fst : prodComparison F A B \u226b prod.fst = F.map prod.fst", "start": [1263, 1], "end": [1265, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prodComparison_snd", "code": "@[reassoc (attr := simp)]\ntheorem prodComparison_snd : prodComparison F A B \u226b prod.snd = F.map prod.snd", "start": [1269, 1], "end": [1271, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prodComparison_natural", "code": "@[reassoc]\ntheorem prodComparison_natural (f : A \u27f6 A') (g : B \u27f6 B') :\n    F.map (prod.map f g) \u226b prodComparison F A' B' =\n      prodComparison F A B \u226b prod.map (F.map f) (F.map g)", "start": [1275, 1], "end": [1281, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prodComparisonNatTrans", "code": "@[simps]\ndef prodComparisonNatTrans [HasBinaryProducts C] [HasBinaryProducts D] (F : C \u2964 D) (A : C) :\n    prod.functor.obj A \u22d9 F \u27f6 F \u22d9 prod.functor.obj (F.obj A)\n    where\n  app B := prodComparison F A B\n  naturality f := by simp [prodComparison_natural]", "start": [1285, 1], "end": [1293, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inv_prodComparison_map_fst", "code": "@[reassoc]\ntheorem inv_prodComparison_map_fst [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) \u226b F.map prod.fst = prod.fst", "start": [1296, 1], "end": [1298, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inv_prodComparison_map_snd", "code": "@[reassoc]\ntheorem inv_prodComparison_map_snd [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) \u226b F.map prod.snd = prod.snd", "start": [1302, 1], "end": [1304, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prodComparison_inv_natural", "code": "@[reassoc]\ntheorem prodComparison_inv_natural (f : A \u27f6 A') (g : B \u27f6 B') [IsIso (prodComparison F A B)]\n    [IsIso (prodComparison F A' B')] :\n    inv (prodComparison F A B) \u226b F.map (prod.map f g) =\n      prod.map (F.map f) (F.map g) \u226b inv (prodComparison F A' B')", "start": [1308, 1], "end": [1314, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.prodComparisonNatIso", "code": "@[simps]\ndef prodComparisonNatIso [HasBinaryProducts C] [HasBinaryProducts D] (A : C)\n    [\u2200 B, IsIso (prodComparison F A B)] :\n    prod.functor.obj A \u22d9 F \u2245 F \u22d9 prod.functor.obj (F.obj A) := by\n  refine { @asIso _ _ _ _ _ (?_) with hom := prodComparisonNatTrans F A }\n  apply NatIso.isIso_of_isIso_app", "start": [1318, 1], "end": [1327, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprodComparison", "code": "def coprodComparison (F : C \u2964 D) (A B : C) [HasBinaryCoproduct A B]\n    [HasBinaryCoproduct (F.obj A) (F.obj B)] : F.obj A \u2a3f F.obj B \u27f6 F.obj (A \u2a3f B) :=\n  coprod.desc (F.map coprod.inl) (F.map coprod.inr)", "start": [1344, 1], "end": [1351, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprodComparison_inl", "code": "@[reassoc (attr := simp)]\ntheorem coprodComparison_inl : coprod.inl \u226b coprodComparison F A B = F.map coprod.inl", "start": [1354, 1], "end": [1356, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprodComparison_inr", "code": "@[reassoc (attr := simp)]\ntheorem coprodComparison_inr : coprod.inr \u226b coprodComparison F A B = F.map coprod.inr", "start": [1360, 1], "end": [1362, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprodComparison_natural", "code": "@[reassoc]\ntheorem coprodComparison_natural (f : A \u27f6 A') (g : B \u27f6 B') :\n    coprodComparison F A B \u226b F.map (coprod.map f g) =\n      coprod.map (F.map f) (F.map g) \u226b coprodComparison F A' B'", "start": [1366, 1], "end": [1372, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprodComparisonNatTrans", "code": "@[simps]\ndef coprodComparisonNatTrans [HasBinaryCoproducts C] [HasBinaryCoproducts D] (F : C \u2964 D) (A : C) :\n    F \u22d9 coprod.functor.obj (F.obj A) \u27f6 coprod.functor.obj A \u22d9 F where\n  app B := coprodComparison F A B\n  naturality f := by simp [coprodComparison_natural]", "start": [1376, 1], "end": [1383, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.map_inl_inv_coprodComparison", "code": "@[reassoc]\ntheorem map_inl_inv_coprodComparison [IsIso (coprodComparison F A B)] :\n    F.map coprod.inl \u226b inv (coprodComparison F A B) = coprod.inl", "start": [1386, 1], "end": [1388, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.map_inr_inv_coprodComparison", "code": "@[reassoc]\ntheorem map_inr_inv_coprodComparison [IsIso (coprodComparison F A B)] :\n    F.map coprod.inr \u226b inv (coprodComparison F A B) = coprod.inr", "start": [1392, 1], "end": [1394, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprodComparison_inv_natural", "code": "@[reassoc]\ntheorem coprodComparison_inv_natural (f : A \u27f6 A') (g : B \u27f6 B') [IsIso (coprodComparison F A B)]\n    [IsIso (coprodComparison F A' B')] :\n    inv (coprodComparison F A B) \u226b coprod.map (F.map f) (F.map g) =\n      F.map (coprod.map f g) \u226b inv (coprodComparison F A' B')", "start": [1398, 1], "end": [1404, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coprodComparisonNatIso", "code": "@[simps]\ndef coprodComparisonNatIso [HasBinaryCoproducts C] [HasBinaryCoproducts D] (A : C)\n    [\u2200 B, IsIso (coprodComparison F A B)] :\n    F \u22d9 coprod.functor.obj (F.obj A) \u2245 coprod.functor.obj A \u22d9 F := by\n  refine { @asIso _ _ _ _ _ (?_) with hom := coprodComparisonNatTrans F A }\n  apply NatIso.isIso_of_isIso_app", "start": [1408, 1], "end": [1417, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.coprodObj", "code": "@[simps]\ndef Over.coprodObj [HasBinaryCoproducts C] {A : C} : Over A \u2192 Over A \u2964 Over A := fun f =>\n  { obj := fun g => Over.mk (coprod.desc f.hom g.hom)\n    map := fun k => Over.homMk (coprod.map (\ud835\udfd9 _) k.left) }", "start": [1430, 1], "end": [1434, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.coprod", "code": "@[simps]\ndef Over.coprod [HasBinaryCoproducts C] {A : C} : Over A \u2964 Over A \u2964 Over A where\n  obj f := Over.coprodObj f\n  map k :=\n    { app := fun g => Over.homMk (coprod.map k.left (\ud835\udfd9 _)) (by\n        dsimp; rw [coprod.map_desc, Category.id_comp, Over.w k])\n      naturality := fun f g k => by\n        ext;\n          \u00b7 dsimp; simp }\n  map_id X := by\n    ext\n    \u00b7 dsimp; simp\n  map_comp f g := by\n    ext\n    \u00b7 dsimp; simp", "start": [1437, 1], "end": [1452, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/WidePullbacks.lean", "imports": ["Mathlib/CategoryTheory/Limits/HasLimits.lean", "Mathlib/CategoryTheory/Thin.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.WidePullbackShape", "code": "def WidePullbackShape := Option J", "start": [40, 1], "end": [41, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape", "code": "def WidePushoutShape := Option J", "start": [48, 1], "end": [49, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.Hom", "code": "inductive Hom : WidePullbackShape J \u2192 WidePullbackShape J \u2192 Type w\n  | id : \u2200 X, Hom X X\n  | term : \u2200 j : J, Hom (some j) none\n  deriving DecidableEq", "start": [59, 1], "end": [63, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.struct", "code": "instance struct : CategoryStruct (WidePullbackShape J) where\n  Hom := Hom\n  id j := Hom.id j\n  comp f g := by\n    cases f\n    exact g\n    cases g\n    apply Hom.term _", "start": [70, 1], "end": [77, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.Hom.inhabited", "code": "instance Hom.inhabited : Inhabited (Hom (none : WidePullbackShape J) none) :=\n  \u27e8Hom.id (none : WidePullbackShape J)\u27e9", "start": [80, 1], "end": [81, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.evalCasesBash", "code": "def evalCasesBash : TacticM Unit := do\n  evalTactic\n    (\u2190 `(tactic| casesm* WidePullbackShape _,\n      (_: WidePullbackShape _) \u27f6 (_ : WidePullbackShape _) ))", "start": [87, 1], "end": [91, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.subsingleton_hom", "code": "instance subsingleton_hom : Quiver.IsThin (WidePullbackShape J) := fun _ _ => by\n  constructor\n  intro a b\n  casesm* WidePullbackShape _, (_: WidePullbackShape _) \u27f6 (_ : WidePullbackShape _)\n  rfl; rfl; rfl", "start": [95, 1], "end": [99, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.category", "code": "instance category : SmallCategory (WidePullbackShape J) :=\n  thin_category", "start": [102, 1], "end": [103, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.hom_id", "code": "@[simp]\ntheorem hom_id (X : WidePullbackShape J) : Hom.id X = \ud835\udfd9 X", "start": [106, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.wideCospan", "code": "@[simps]\ndef wideCospan (B : C) (objs : J \u2192 C) (arrows : \u2200 j : J, objs j \u27f6 B) : WidePullbackShape J \u2964 C where\n  obj j := Option.casesOn j B objs\n  map f := by\n    cases' f with _ j\n    \u00b7 apply \ud835\udfd9 _\n    \u00b7 exact arrows j", "start": [118, 1], "end": [127, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.diagramIsoWideCospan", "code": "def diagramIsoWideCospan (F : WidePullbackShape J \u2964 C) :\n    F \u2245 wideCospan (F.obj none) (fun j => F.obj (some j)) fun j => F.map (Hom.term j) :=\n  NatIso.ofComponents fun j => eqToIso <| by aesop_cat", "start": [130, 1], "end": [133, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.mkCone", "code": "@[simps]\ndef mkCone {F : WidePullbackShape J \u2964 C} {X : C} (f : X \u27f6 F.obj none) (\u03c0 : \u2200 j, X \u27f6 F.obj (some j))\n    (w : \u2200 j, \u03c0 j \u226b F.map (Hom.term j) = f) : Cone F :=\n  { pt := X\n    \u03c0 :=\n      { app := fun j =>\n          match j with\n          | none => f\n          | some j => \u03c0 j\n        naturality := fun j j' f => by\n          cases j <;> cases j' <;> cases f <;> refine id _ <;> dsimp <;> simp [w] } }", "start": [136, 1], "end": [147, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.equivalenceOfEquiv", "code": "def equivalenceOfEquiv (J' : Type w') (h : J \u2243 J') : WidePullbackShape J \u224c WidePullbackShape J'\n    where\n  functor := wideCospan none (fun j => some (h j)) fun j => Hom.term (h j)\n  inverse := wideCospan none (fun j => some (h.invFun j)) fun j => Hom.term (h.invFun j)\n  unitIso :=\n    NatIso.ofComponents (fun j => by aesop_cat) fun f =>\n      by simp only [eq_iff_true_of_subsingleton]\n  counitIso :=\n    NatIso.ofComponents (fun j => by aesop_cat)\n      fun f => by simp only [eq_iff_true_of_subsingleton]", "start": [150, 1], "end": [160, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.uliftEquivalence", "code": "def uliftEquivalence :\n    ULiftHom.{w'} (ULift.{w'} (WidePullbackShape J)) \u224c WidePullbackShape (ULift J) :=\n  (ULiftHomULiftCategory.equiv.{w', w', w, w} (WidePullbackShape J)).symm.trans\n    (equivalenceOfEquiv _ (Equiv.ulift.{w', w}.symm : J \u2243 ULift.{w'} J))", "start": [163, 1], "end": [167, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape.Hom", "code": "inductive Hom : WidePushoutShape J \u2192 WidePushoutShape J \u2192 Type w\n  | id : \u2200 X, Hom X X\n  | init : \u2200 j : J, Hom none (some j)\n  deriving DecidableEq", "start": [176, 1], "end": [180, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape.struct", "code": "instance struct : CategoryStruct (WidePushoutShape J) where\n  Hom := Hom\n  id j := Hom.id j\n  comp f g := by\n    cases f\n    exact g\n    cases g\n    apply Hom.init _", "start": [187, 1], "end": [194, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape.Hom.inhabited", "code": "instance Hom.inhabited : Inhabited (Hom (none : WidePushoutShape J) none) :=\n  \u27e8Hom.id (none : WidePushoutShape J)\u27e9", "start": [197, 1], "end": [198, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape.evalCasesBash'", "code": "def evalCasesBash' : TacticM Unit := do\n  evalTactic\n    (\u2190 `(tactic| casesm* WidePushoutShape _,\n      (_: WidePushoutShape _) \u27f6 (_ : WidePushoutShape _) ))", "start": [203, 1], "end": [207, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape.subsingleton_hom", "code": "instance subsingleton_hom : Quiver.IsThin (WidePushoutShape J) := fun _ _ => by\n  constructor\n  intro a b\n  casesm* WidePushoutShape _, (_: WidePushoutShape _) \u27f6 (_ : WidePushoutShape _)\n  repeat rfl", "start": [211, 1], "end": [215, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape.category", "code": "instance category : SmallCategory (WidePushoutShape J) :=\n  thin_category", "start": [218, 1], "end": [219, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape.hom_id", "code": "@[simp]\ntheorem hom_id (X : WidePushoutShape J) : Hom.id X = \ud835\udfd9 X", "start": [222, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape.wideSpan", "code": "@[simps]\ndef wideSpan (B : C) (objs : J \u2192 C) (arrows : \u2200 j : J, B \u27f6 objs j) : WidePushoutShape J \u2964 C where\n  obj j := Option.casesOn j B objs\n  map f := by\n    cases' f with _ j\n    \u00b7 apply \ud835\udfd9 _\n    \u00b7 exact arrows j\n  map_comp := fun f g => by\n    cases f\n    \u00b7 simp only [Eq.ndrec, hom_id, eq_rec_constant, Category.id_comp]; congr\n    \u00b7 cases g\n      \u00b7 simp only [Eq.ndrec, hom_id, eq_rec_constant, Category.comp_id]; congr", "start": [233, 1], "end": [247, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape.diagramIsoWideSpan", "code": "def diagramIsoWideSpan (F : WidePushoutShape J \u2964 C) :\n    F \u2245 wideSpan (F.obj none) (fun j => F.obj (some j)) fun j => F.map (Hom.init j) :=\n  NatIso.ofComponents fun j => eqToIso <| by cases j; repeat rfl", "start": [250, 1], "end": [253, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape.mkCocone", "code": "@[simps]\ndef mkCocone {F : WidePushoutShape J \u2964 C} {X : C} (f : F.obj none \u27f6 X) (\u03b9 : \u2200 j, F.obj (some j) \u27f6 X)\n    (w : \u2200 j, F.map (Hom.init j) \u226b \u03b9 j = f) : Cocone F :=\n  { pt := X\n    \u03b9 :=\n      { app := fun j =>\n          match j with\n          | none => f\n          | some j => \u03b9 j\n        naturality := fun j j' f => by\n          cases j <;> cases j' <;> cases f <;> refine id _ <;> dsimp <;> simp [w] } }", "start": [256, 1], "end": [267, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape.equivalenceOfEquiv", "code": "def equivalenceOfEquiv (J' : Type w') (h : J \u2243 J') : WidePushoutShape J \u224c WidePushoutShape J'\n    where\n  functor := wideSpan none (fun j => some (h j)) fun j => Hom.init (h j)\n  inverse := wideSpan none (fun j => some (h.invFun j)) fun j => Hom.init (h.invFun j)\n  unitIso :=\n    NatIso.ofComponents (fun j => by aesop_cat) fun f => by\n      simp only [eq_iff_true_of_subsingleton]\n  counitIso :=\n    NatIso.ofComponents (fun j => by aesop_cat) fun f => by\n      simp only [eq_iff_true_of_subsingleton]", "start": [270, 1], "end": [280, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape.uliftEquivalence", "code": "def uliftEquivalence :\n    ULiftHom.{w'} (ULift.{w'} (WidePushoutShape J)) \u224c WidePushoutShape (ULift J) :=\n  (ULiftHomULiftCategory.equiv.{w', w', w, w} (WidePushoutShape J)).symm.trans\n    (equivalenceOfEquiv _ (Equiv.ulift.{w', w}.symm : J \u2243 ULift.{w'} J))", "start": [282, 1], "end": [286, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasWidePullbacks", "code": "abbrev HasWidePullbacks : Prop :=\n  \u2200 J : Type w, HasLimitsOfShape (WidePullbackShape J) C", "start": [292, 1], "end": [294, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasWidePushouts", "code": "abbrev HasWidePushouts : Prop :=\n  \u2200 J : Type w, HasColimitsOfShape (WidePushoutShape J) C", "start": [297, 1], "end": [299, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasWidePullback", "code": "abbrev HasWidePullback (B : C) (objs : J \u2192 C) (arrows : \u2200 j : J, objs j \u27f6 B) : Prop :=\n  HasLimit (WidePullbackShape.wideCospan B objs arrows)", "start": [304, 1], "end": [306, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasWidePushout", "code": "abbrev HasWidePushout (B : C) (objs : J \u2192 C) (arrows : \u2200 j : J, B \u27f6 objs j) : Prop :=\n  HasColimit (WidePushoutShape.wideSpan B objs arrows)", "start": [309, 1], "end": [311, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.widePullback", "code": "noncomputable abbrev widePullback (B : C) (objs : J \u2192 C) (arrows : \u2200 j : J, objs j \u27f6 B)\n    [HasWidePullback B objs arrows] : C :=\n  limit (WidePullbackShape.wideCospan B objs arrows)", "start": [314, 1], "end": [317, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.widePushout", "code": "noncomputable abbrev widePushout (B : C) (objs : J \u2192 C) (arrows : \u2200 j : J, B \u27f6 objs j)\n    [HasWidePushout B objs arrows] : C :=\n  colimit (WidePushoutShape.wideSpan B objs arrows)", "start": [320, 1], "end": [323, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullback.\u03c0", "code": "noncomputable abbrev \u03c0 (j : J) : widePullback _ _ arrows \u27f6 objs j :=\n  limit.\u03c0 (WidePullbackShape.wideCospan _ _ _) (Option.some j)", "start": [334, 1], "end": [336, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullback.base", "code": "noncomputable abbrev base : widePullback _ _ arrows \u27f6 B :=\n  limit.\u03c0 (WidePullbackShape.wideCospan _ _ _) Option.none", "start": [340, 1], "end": [342, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullback.\u03c0_arrow", "code": "@[reassoc (attr := simp)]\ntheorem \u03c0_arrow (j : J) : \u03c0 arrows j \u226b arrows _ = base arrows", "start": [345, 1], "end": [347, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullback.lift", "code": "noncomputable abbrev lift {X : D} (f : X \u27f6 B) (fs : \u2200 j : J, X \u27f6 objs j)\n    (w : \u2200 j, fs j \u226b arrows j = f) : X \u27f6 widePullback _ _ arrows :=\n  limit.lift (WidePullbackShape.wideCospan _ _ _) (WidePullbackShape.mkCone f fs <| w)", "start": [352, 1], "end": [355, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullback.lift_\u03c0", "code": "@[reassoc]\ntheorem lift_\u03c0 (j : J) : lift f fs w \u226b \u03c0 arrows j = fs _", "start": [363, 1], "end": [365, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullback.lift_base", "code": "@[reassoc]\ntheorem lift_base : lift f fs w \u226b base arrows = f", "start": [369, 1], "end": [371, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullback.eq_lift_of_comp_eq", "code": "theorem eq_lift_of_comp_eq (g : X \u27f6 widePullback _ _ arrows) :\n    (\u2200 j : J, g \u226b \u03c0 arrows j = fs j) \u2192 g \u226b base arrows = f \u2192 g = lift f fs w", "start": [374, 1], "end": [382, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullback.hom_eq_lift", "code": "theorem hom_eq_lift (g : X \u27f6 widePullback _ _ arrows) :\n    g = lift (g \u226b base arrows) (fun j => g \u226b \u03c0 arrows j) (by aesop_cat)", "start": [385, 1], "end": [389, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullback.hom_ext", "code": "@[ext 1100]\ntheorem hom_ext (g1 g2 : X \u27f6 widePullback _ _ arrows) : (\u2200 j : J,\n    g1 \u226b \u03c0 arrows j = g2 \u226b \u03c0 arrows j) \u2192 g1 \u226b base arrows = g2 \u226b base arrows \u2192 g1 = g2", "start": [392, 1], "end": [399, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushout.\u03b9", "code": "noncomputable abbrev \u03b9 (j : J) : objs j \u27f6 widePushout _ _ arrows :=\n  colimit.\u03b9 (WidePushoutShape.wideSpan _ _ _) (Option.some j)", "start": [410, 1], "end": [412, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushout.head", "code": "noncomputable abbrev head : B \u27f6 widePushout B objs arrows :=\n  colimit.\u03b9 (WidePushoutShape.wideSpan _ _ _) Option.none", "start": [415, 1], "end": [417, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushout.arrow_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem arrow_\u03b9 (j : J) : arrows j \u226b \u03b9 arrows j = head arrows", "start": [420, 1], "end": [422, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushout.desc", "code": "noncomputable abbrev desc {X : D} (f : B \u27f6 X) (fs : \u2200 j : J, objs j \u27f6 X)\n    (w : \u2200 j, arrows j \u226b fs j = f) : widePushout _ _ arrows \u27f6 X :=\n  colimit.desc (WidePushoutShape.wideSpan B objs arrows) (WidePushoutShape.mkCocone f fs <| w)", "start": [430, 1], "end": [433, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushout.\u03b9_desc", "code": "@[reassoc]\ntheorem \u03b9_desc (j : J) : \u03b9 arrows j \u226b desc f fs w = fs _", "start": [441, 1], "end": [443, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushout.head_desc", "code": "@[reassoc]\ntheorem head_desc : head arrows \u226b desc f fs w = f", "start": [447, 1], "end": [449, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushout.eq_desc_of_comp_eq", "code": "theorem eq_desc_of_comp_eq (g : widePushout _ _ arrows \u27f6 X) :\n    (\u2200 j : J, \u03b9 arrows j \u226b g = fs j) \u2192 head arrows \u226b g = f \u2192 g = desc f fs w", "start": [452, 1], "end": [460, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushout.hom_eq_desc", "code": "theorem hom_eq_desc (g : widePushout _ _ arrows \u27f6 X) :\n    g =\n      desc (head arrows \u226b g) (fun j => \u03b9 arrows j \u226b g) fun j => by\n        rw [\u2190 Category.assoc]\n        simp", "start": [463, 1], "end": [470, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushout.hom_ext", "code": "@[ext 1100]\ntheorem hom_ext (g1 g2 : widePushout _ _ arrows \u27f6 X) : (\u2200 j : J,\n    \u03b9 arrows j \u226b g1 = \u03b9 arrows j \u226b g2) \u2192 head arrows \u226b g1 = head arrows \u226b g2 \u2192 g1 = g2", "start": [473, 1], "end": [480, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.widePullbackShapeOpMap", "code": "def widePullbackShapeOpMap :\n    \u2200 X Y : WidePullbackShape J,\n      (X \u27f6 Y) \u2192 ((op X : (WidePushoutShape J)\u1d52\u1d56) \u27f6 (op Y : (WidePushoutShape J)\u1d52\u1d56))\n  | _, _, WidePullbackShape.Hom.id X => Quiver.Hom.op (WidePushoutShape.Hom.id _)\n  | _, _, WidePullbackShape.Hom.term _ => Quiver.Hom.op (WidePushoutShape.Hom.init _)", "start": [487, 1], "end": [493, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.widePullbackShapeOp", "code": "@[simps]\ndef widePullbackShapeOp : WidePullbackShape J \u2964 (WidePushoutShape J)\u1d52\u1d56 where\n  obj X := op X\n  map {X\u2081} {X\u2082} := widePullbackShapeOpMap J X\u2081 X\u2082", "start": [496, 1], "end": [500, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.widePushoutShapeOpMap", "code": "def widePushoutShapeOpMap :\n    \u2200 X Y : WidePushoutShape J,\n      (X \u27f6 Y) \u2192 ((op X : (WidePullbackShape J)\u1d52\u1d56) \u27f6 (op Y : (WidePullbackShape J)\u1d52\u1d56))\n  | _, _, WidePushoutShape.Hom.id X => Quiver.Hom.op (WidePullbackShape.Hom.id _)\n  | _, _, WidePushoutShape.Hom.init _ => Quiver.Hom.op (WidePullbackShape.Hom.term _)", "start": [503, 1], "end": [509, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.widePushoutShapeOp", "code": "@[simps]\ndef widePushoutShapeOp : WidePushoutShape J \u2964 (WidePullbackShape J)\u1d52\u1d56 where\n  obj X := op X\n  map := fun {X} {Y} => widePushoutShapeOpMap J X Y", "start": [512, 1], "end": [516, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.widePullbackShapeUnop", "code": "@[simps!]\ndef widePullbackShapeUnop : (WidePullbackShape J)\u1d52\u1d56 \u2964 WidePushoutShape J :=\n  (widePullbackShapeOp J).leftOp", "start": [519, 1], "end": [522, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.widePushoutShapeUnop", "code": "@[simps!]\ndef widePushoutShapeUnop : (WidePushoutShape J)\u1d52\u1d56 \u2964 WidePullbackShape J :=\n  (widePushoutShapeOp J).leftOp", "start": [525, 1], "end": [528, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.widePushoutShapeOpUnop", "code": "def widePushoutShapeOpUnop : widePushoutShapeUnop J \u22d9 widePullbackShapeOp J \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents fun X => Iso.refl _", "start": [531, 1], "end": [534, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.widePushoutShapeUnopOp", "code": "def widePushoutShapeUnopOp : widePushoutShapeOp J \u22d9 widePullbackShapeUnop J \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents fun X => Iso.refl _", "start": [537, 1], "end": [540, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.widePullbackShapeOpUnop", "code": "def widePullbackShapeOpUnop : widePullbackShapeUnop J \u22d9 widePushoutShapeOp J \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents fun X => Iso.refl _", "start": [543, 1], "end": [546, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.widePullbackShapeUnopOp", "code": "def widePullbackShapeUnopOp : widePullbackShapeOp J \u22d9 widePushoutShapeUnop J \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents fun X => Iso.refl _", "start": [549, 1], "end": [552, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.widePushoutShapeOpEquiv", "code": "@[simps]\ndef widePushoutShapeOpEquiv : (WidePushoutShape J)\u1d52\u1d56 \u224c WidePullbackShape J where\n  functor := widePushoutShapeUnop J\n  inverse := widePullbackShapeOp J\n  unitIso := (widePushoutShapeOpUnop J).symm\n  counitIso := widePullbackShapeUnopOp J", "start": [555, 1], "end": [561, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.widePullbackShapeOpEquiv", "code": "@[simps]\ndef widePullbackShapeOpEquiv : (WidePullbackShape J)\u1d52\u1d56 \u224c WidePushoutShape J where\n  functor := widePullbackShapeUnop J\n  inverse := widePushoutShapeOp J\n  unitIso := (widePullbackShapeOpUnop J).symm\n  counitIso := widePushoutShapeUnopOp J", "start": [564, 1], "end": [570, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasWidePushouts_shrink", "code": "theorem hasWidePushouts_shrink [HasWidePushouts.{max w w'} C] : HasWidePushouts.{w} C", "start": [573, 1], "end": [576, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasWidePullbacks_shrink", "code": "theorem hasWidePullbacks_shrink [HasWidePullbacks.{max w w'} C] : HasWidePullbacks.{w} C", "start": [578, 1], "end": [581, 92], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Order/Basic.lean", "imports": ["Mathlib/Analysis/NormedSpace/Basic.lean", "Mathlib/Algebra/Order/Group/TypeTags.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NormedOrderedAddGroup", "code": "class NormedOrderedAddGroup (\u03b1 : Type*) extends OrderedAddCommGroup \u03b1, Norm \u03b1, MetricSpace \u03b1 where\n  \n  dist_eq : \u2200 x y, dist x y = \u2016x - y\u2016 := by aesop", "start": [25, 1], "end": [30, 50], "kind": "commanddeclaration"}, {"full_name": "NormedOrderedGroup", "code": "@[to_additive]\nclass NormedOrderedGroup (\u03b1 : Type*) extends OrderedCommGroup \u03b1, Norm \u03b1, MetricSpace \u03b1 where\n  \n  dist_eq : \u2200 x y, dist x y = \u2016x / y\u2016 := by aesop", "start": [33, 1], "end": [39, 50], "kind": "commanddeclaration"}, {"full_name": "NormedLinearOrderedAddGroup", "code": "class NormedLinearOrderedAddGroup (\u03b1 : Type*) extends LinearOrderedAddCommGroup \u03b1, Norm \u03b1,\n  MetricSpace \u03b1 where\n  \n  dist_eq : \u2200 x y, dist x y = \u2016x - y\u2016 := by aesop", "start": [42, 1], "end": [48, 50], "kind": "commanddeclaration"}, {"full_name": "NormedLinearOrderedGroup", "code": "@[to_additive]\nclass NormedLinearOrderedGroup (\u03b1 : Type*) extends LinearOrderedCommGroup \u03b1, Norm \u03b1,\n  MetricSpace \u03b1 where\n  \n  dist_eq : \u2200 x y, dist x y = \u2016x / y\u2016 := by aesop", "start": [51, 1], "end": [58, 50], "kind": "commanddeclaration"}, {"full_name": "NormedLinearOrderedField", "code": "class NormedLinearOrderedField (\u03b1 : Type*) extends LinearOrderedField \u03b1, Norm \u03b1,\n  MetricSpace \u03b1 where\n  \n  dist_eq : \u2200 x y, dist x y = \u2016x - y\u2016 := by aesop\n  \n  norm_mul' : \u2200 x y : \u03b1, \u2016x * y\u2016 = \u2016x\u2016 * \u2016y\u2016", "start": [61, 1], "end": [68, 45], "kind": "commanddeclaration"}, {"full_name": "NormedOrderedGroup.toNormedCommGroup", "code": "@[to_additive]\ninstance (priority := 100) NormedOrderedGroup.toNormedCommGroup [NormedOrderedGroup \u03b1] :\n    NormedCommGroup \u03b1 :=\n  \u27e8NormedOrderedGroup.dist_eq\u27e9", "start": [71, 1], "end": [74, 31], "kind": "commanddeclaration"}, {"full_name": "NormedLinearOrderedGroup.toNormedOrderedGroup", "code": "@[to_additive]\ninstance (priority := 100) NormedLinearOrderedGroup.toNormedOrderedGroup\n    [NormedLinearOrderedGroup \u03b1] : NormedOrderedGroup \u03b1 :=\n  \u27e8NormedLinearOrderedGroup.dist_eq\u27e9", "start": [78, 1], "end": [81, 37], "kind": "commanddeclaration"}, {"full_name": "NormedLinearOrderedField.toNormedField", "code": "instance (priority := 100) NormedLinearOrderedField.toNormedField (\u03b1 : Type*)\n    [NormedLinearOrderedField \u03b1] : NormedField \u03b1 where\n  dist_eq := NormedLinearOrderedField.dist_eq\n  norm_mul' := NormedLinearOrderedField.norm_mul'", "start": [85, 1], "end": [88, 50], "kind": "commanddeclaration"}, {"full_name": "Rat.normedLinearOrderedField", "code": "instance Rat.normedLinearOrderedField : NormedLinearOrderedField \u211a :=\n  \u27e8dist_eq_norm, norm_mul\u27e9", "start": [91, 1], "end": [92, 27], "kind": "commanddeclaration"}, {"full_name": "Real.normedLinearOrderedField", "code": "noncomputable instance Real.normedLinearOrderedField : NormedLinearOrderedField \u211d :=\n  \u27e8dist_eq_norm, norm_mul\u27e9", "start": [94, 1], "end": [95, 27], "kind": "commanddeclaration"}, {"full_name": "OrderDual.normedOrderedGroup", "code": "@[to_additive]\ninstance OrderDual.normedOrderedGroup [NormedOrderedGroup \u03b1] : NormedOrderedGroup \u03b1\u1d52\u1d48 :=\n  { @NormedOrderedGroup.toNormedCommGroup \u03b1 _, OrderDual.orderedCommGroup with }", "start": [97, 1], "end": [99, 81], "kind": "commanddeclaration"}, {"full_name": "OrderDual.normedLinearOrderedGroup", "code": "@[to_additive]\ninstance OrderDual.normedLinearOrderedGroup [NormedLinearOrderedGroup \u03b1] :\n    NormedLinearOrderedGroup \u03b1\u1d52\u1d48 :=\n  { OrderDual.normedOrderedGroup, OrderDual.instLinearOrder _ with }", "start": [101, 1], "end": [104, 69], "kind": "commanddeclaration"}, {"full_name": "Additive.normedOrderedAddGroup", "code": "instance Additive.normedOrderedAddGroup [NormedOrderedGroup \u03b1] :\n    NormedOrderedAddGroup (Additive \u03b1) :=\n  { Additive.normedAddCommGroup, Additive.orderedAddCommGroup with }", "start": [106, 1], "end": [108, 69], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.normedOrderedGroup", "code": "instance Multiplicative.normedOrderedGroup [NormedOrderedAddGroup \u03b1] :\n    NormedOrderedGroup (Multiplicative \u03b1) :=\n  { Multiplicative.normedCommGroup, Multiplicative.orderedCommGroup with }", "start": [110, 1], "end": [112, 75], "kind": "commanddeclaration"}, {"full_name": "Additive.normedLinearOrderedAddGroup", "code": "instance Additive.normedLinearOrderedAddGroup [NormedLinearOrderedGroup \u03b1] :\n    NormedLinearOrderedAddGroup (Additive \u03b1) :=\n  { Additive.normedAddCommGroup, Additive.linearOrderedAddCommGroup with }", "start": [114, 1], "end": [116, 75], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.normedlinearOrderedGroup", "code": "instance Multiplicative.normedlinearOrderedGroup [NormedLinearOrderedAddGroup \u03b1] :\n    NormedLinearOrderedGroup (Multiplicative \u03b1) :=\n  { Multiplicative.normedCommGroup, Multiplicative.linearOrderedCommGroup with }", "start": [118, 1], "end": [120, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Module/Simple.lean", "imports": ["Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/RingTheory/SimpleModule.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.isClosed_or_dense_ker", "code": "theorem LinearMap.isClosed_or_dense_ker (l : M \u2192\u2097[R] N) :\n    IsClosed (LinearMap.ker l : Set M) \u2228 Dense (LinearMap.ker l : Set M)", "start": [26, 1], "end": [34, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Module/Determinant.lean", "imports": ["Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/LinearAlgebra/Determinant.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousLinearMap.det", "code": "@[reducible]\nnoncomputable def det {R : Type*} [CommRing R] {M : Type*} [TopologicalSpace M] [AddCommGroup M]\n    [Module R M] (A : M \u2192L[R] M) : R :=\n  LinearMap.det (A : M \u2192\u2097[R] M)", "start": [19, 1], "end": [24, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.det_coe_symm", "code": "@[simp]\ntheorem det_coe_symm {R : Type*} [Field R] {M : Type*} [TopologicalSpace M] [AddCommGroup M]\n    [Module R M] (A : M \u2243L[R] M) : (A.symm : M \u2192L[R] M).det = (A : M \u2192L[R] M).det\u207b\u00b9", "start": [31, 1], "end": [34, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/AffineSpace/Restrict.lean", "imports": ["Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AffineSubspace.nonempty_map", "code": "theorem AffineSubspace.nonempty_map {E : AffineSubspace k P\u2081} [Ene : Nonempty E] {\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082} :\n    Nonempty (E.map \u03c6)", "start": [33, 1], "end": [36, 59], "kind": "commanddeclaration"}, {"full_name": "AffineMap.restrict", "code": "def AffineMap.restrict (\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082) {E : AffineSubspace k P\u2081} {F : AffineSubspace k P\u2082}\n    [Nonempty E] [Nonempty F] (hEF : E.map \u03c6 \u2264 F) : E \u2192\u1d43[k] F := by\n  refine' \u27e8_, _, _\u27e9\n  \u00b7 exact fun x => \u27e8\u03c6 x, hEF <| AffineSubspace.mem_map.mpr \u27e8x, x.property, rfl\u27e9\u27e9\n  \u00b7 refine' \u03c6.linear.restrict (_ : E.direction \u2264 F.direction.comap \u03c6.linear)\n    rw [\u2190 Submodule.map_le_iff_le_comap, \u2190 AffineSubspace.map_direction]\n    exact AffineSubspace.direction_le hEF\n  \u00b7 intro p v\n    simp only [Subtype.ext_iff, Subtype.coe_mk, AffineSubspace.coe_vadd]\n    apply AffineMap.map_vadd", "start": [42, 1], "end": [52, 29], "kind": "commanddeclaration"}, {"full_name": "AffineMap.restrict.coe_apply", "code": "theorem AffineMap.restrict.coe_apply (\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082) {E : AffineSubspace k P\u2081}\n    {F : AffineSubspace k P\u2082} [Nonempty E] [Nonempty F] (hEF : E.map \u03c6 \u2264 F) (x : E) :\n    \u2191(\u03c6.restrict hEF x) = \u03c6 x", "start": [55, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.restrict.linear_aux", "code": "theorem AffineMap.restrict.linear_aux {\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082} {E : AffineSubspace k P\u2081}\n    {F : AffineSubspace k P\u2082} (hEF : E.map \u03c6 \u2264 F) : E.direction \u2264 F.direction.comap \u03c6.linear", "start": [61, 1], "end": [64, 40], "kind": "commanddeclaration"}, {"full_name": "AffineMap.restrict.linear", "code": "theorem AffineMap.restrict.linear (\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082) {E : AffineSubspace k P\u2081}\n    {F : AffineSubspace k P\u2082} [Nonempty E] [Nonempty F] (hEF : E.map \u03c6 \u2264 F) :\n    (\u03c6.restrict hEF).linear = \u03c6.linear.restrict (AffineMap.restrict.linear_aux hEF)", "start": [67, 1], "end": [70, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.restrict.injective", "code": "theorem AffineMap.restrict.injective {\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082} (h\u03c6 : Function.Injective \u03c6)\n    {E : AffineSubspace k P\u2081} {F : AffineSubspace k P\u2082} [Nonempty E] [Nonempty F]\n    (hEF : E.map \u03c6 \u2264 F) : Function.Injective (AffineMap.restrict \u03c6 hEF)", "start": [73, 1], "end": [78, 13], "kind": "commanddeclaration"}, {"full_name": "AffineMap.restrict.surjective", "code": "theorem AffineMap.restrict.surjective (\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082) {E : AffineSubspace k P\u2081}\n    {F : AffineSubspace k P\u2082} [Nonempty E] [Nonempty F] (h : E.map \u03c6 = F) :\n    Function.Surjective (AffineMap.restrict \u03c6 (le_of_eq h))", "start": [81, 1], "end": [87, 23], "kind": "commanddeclaration"}, {"full_name": "AffineMap.restrict.bijective", "code": "theorem AffineMap.restrict.bijective {E : AffineSubspace k P\u2081} [Nonempty E] {\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082}\n    (h\u03c6 : Function.Injective \u03c6) : Function.Bijective (\u03c6.restrict (le_refl (E.map \u03c6)))", "start": [90, 1], "end": [92, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/SimpleFunc.lean", "imports": ["Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "Mathlib/Algebra/IndicatorFunction.lean", "Mathlib/Algebra/Support.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.SimpleFunc", "code": "structure SimpleFunc.{u, v} (\u03b1 : Type u) [MeasurableSpace \u03b1] (\u03b2 : Type v) where\n  toFun : \u03b1 \u2192 \u03b2\n  measurableSet_fiber' : \u2200 x, MeasurableSet (toFun \u207b\u00b9' {x})\n  finite_range' : (Set.range toFun).Finite", "start": [41, 1], "end": [47, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instCoeFun", "code": "instance instCoeFun : CoeFun (\u03b1 \u2192\u209b \u03b2) fun _ => \u03b1 \u2192 \u03b2 :=\n  \u27e8toFun\u27e9", "start": [63, 1], "end": [64, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_injective", "code": "theorem coe_injective \u2983f g : \u03b1 \u2192\u209b \u03b2\u2984 (H : (f : \u03b1 \u2192 \u03b2) = g) : f = g", "start": [67, 1], "end": [68, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.ext", "code": "@[ext]\ntheorem ext {f g : \u03b1 \u2192\u209b \u03b2} (H : \u2200 a, f a = g a) : f = g", "start": [71, 1], "end": [73, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.finite_range", "code": "theorem finite_range (f : \u03b1 \u2192\u209b \u03b2) : (Set.range f).Finite", "start": [76, 1], "end": [77, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.measurableSet_fiber", "code": "theorem measurableSet_fiber (f : \u03b1 \u2192\u209b \u03b2) (x : \u03b2) : MeasurableSet (f \u207b\u00b9' {x})", "start": [80, 1], "end": [81, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.apply_mk", "code": "theorem apply_mk (f : \u03b1 \u2192 \u03b2) (h h') (x : \u03b1) : SimpleFunc.mk f h h' x = f x", "start": [85, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.ofIsEmpty", "code": "def ofIsEmpty [IsEmpty \u03b1] : \u03b1 \u2192\u209b \u03b2 where\n  toFun := isEmptyElim\n  measurableSet_fiber' x := Subsingleton.measurableSet\n  finite_range' := by simp [range_eq_empty]", "start": [89, 1], "end": [93, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.ofFintype", "code": "def ofFintype [Fintype \u03b1] [MeasurableSingletonClass \u03b1] (f : \u03b1 \u2192 \u03b2) : \u03b1 \u2192\u209b \u03b2 where\n  toFun := f\n  measurableSet_fiber' x := Finite.measurableSet (toFinite (f \u207b\u00b9' {x}))\n  finite_range' := Set.finite_range f", "start": [96, 1], "end": [100, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.range", "code": "protected def range (f : \u03b1 \u2192\u209b \u03b2) : Finset \u03b2 :=\n  f.finite_range.toFinset", "start": [102, 1], "end": [104, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.mem_range", "code": "@[simp]\ntheorem mem_range {f : \u03b1 \u2192\u209b \u03b2} {b} : b \u2208 f.range \u2194 b \u2208 range f", "start": [107, 1], "end": [109, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.mem_range_self", "code": "theorem mem_range_self (f : \u03b1 \u2192\u209b \u03b2) (x : \u03b1) : f x \u2208 f.range", "start": [112, 1], "end": [113, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_range", "code": "@[simp]\ntheorem coe_range (f : \u03b1 \u2192\u209b \u03b2) : (\u2191f.range : Set \u03b2) = Set.range f", "start": [116, 1], "end": [118, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.mem_range_of_measure_ne_zero", "code": "theorem mem_range_of_measure_ne_zero {f : \u03b1 \u2192\u209b \u03b2} {x : \u03b2} {\u03bc : Measure \u03b1} (H : \u03bc (f \u207b\u00b9' {x}) \u2260 0) :\n    x \u2208 f.range", "start": [121, 1], "end": [124, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.forall_range_iff", "code": "theorem forall_range_iff {f : \u03b1 \u2192\u209b \u03b2} {p : \u03b2 \u2192 Prop} : (\u2200 y \u2208 f.range, p y) \u2194 \u2200 x, p (f x)", "start": [127, 1], "end": [128, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.exists_range_iff", "code": "theorem exists_range_iff {f : \u03b1 \u2192\u209b \u03b2} {p : \u03b2 \u2192 Prop} : (\u2203 y \u2208 f.range, p y) \u2194 \u2203 x, p (f x)", "start": [131, 1], "end": [132, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.preimage_eq_empty_iff", "code": "theorem preimage_eq_empty_iff (f : \u03b1 \u2192\u209b \u03b2) (b : \u03b2) : f \u207b\u00b9' {b} = \u2205 \u2194 b \u2209 f.range", "start": [135, 1], "end": [136, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.exists_forall_le", "code": "theorem exists_forall_le [Nonempty \u03b2] [Preorder \u03b2] [IsDirected \u03b2 (\u00b7 \u2264 \u00b7)] (f : \u03b1 \u2192\u209b \u03b2) :\n    \u2203 C, \u2200 x, f x \u2264 C", "start": [139, 1], "end": [141, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.const", "code": "def const (\u03b1) {\u03b2} [MeasurableSpace \u03b1] (b : \u03b2) : \u03b1 \u2192\u209b \u03b2 :=\n  \u27e8fun _ => b, fun _ => MeasurableSet.const _, finite_range_const\u27e9", "start": [144, 1], "end": [146, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instInhabited", "code": "instance instInhabited [Inhabited \u03b2] : Inhabited (\u03b1 \u2192\u209b \u03b2) :=\n  \u27e8const _ default\u27e9", "start": [149, 1], "end": [150, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.const_apply", "code": "theorem const_apply (a : \u03b1) (b : \u03b2) : (const \u03b1 b) a = b", "start": [153, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_const", "code": "@[simp]\ntheorem coe_const (b : \u03b2) : \u21d1(const \u03b1 b) = Function.const \u03b1 b", "start": [157, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.range_const", "code": "@[simp]\ntheorem range_const (\u03b1) [MeasurableSpace \u03b1] [Nonempty \u03b1] (b : \u03b2) : (const \u03b1 b).range = {b}", "start": [162, 1], "end": [164, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.range_const_subset", "code": "theorem range_const_subset (\u03b1) [MeasurableSpace \u03b1] (b : \u03b2) : (const \u03b1 b).range \u2286 {b}", "start": [167, 1], "end": [168, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.simpleFunc_bot", "code": "theorem simpleFunc_bot {\u03b1} (f : @SimpleFunc \u03b1 \u22a5 \u03b2) [Nonempty \u03b2] : \u2203 c, \u2200 x, f x = c", "start": [171, 1], "end": [174, 84], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.simpleFunc_bot'", "code": "theorem simpleFunc_bot' {\u03b1} [Nonempty \u03b2] (f : @SimpleFunc \u03b1 \u22a5 \u03b2) :\n    \u2203 c, f = @SimpleFunc.const \u03b1 _ \u22a5 c", "start": [177, 1], "end": [179, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.measurableSet_cut", "code": "theorem measurableSet_cut (r : \u03b1 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192\u209b \u03b2) (h : \u2200 b, MeasurableSet { a | r a b }) :\n    MeasurableSet { a | r a (f a) }", "start": [182, 1], "end": [191, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.measurableSet_preimage", "code": "@[measurability]\ntheorem measurableSet_preimage (f : \u03b1 \u2192\u209b \u03b2) (s) : MeasurableSet (f \u207b\u00b9' s)", "start": [194, 1], "end": [196, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.measurable", "code": "@[measurability]\nprotected theorem measurable [MeasurableSpace \u03b2] (f : \u03b1 \u2192\u209b \u03b2) : Measurable f", "start": [199, 1], "end": [202, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.aemeasurable", "code": "@[measurability]\nprotected theorem aemeasurable [MeasurableSpace \u03b2] {\u03bc : Measure \u03b1} (f : \u03b1 \u2192\u209b \u03b2) :\n    AEMeasurable f \u03bc", "start": [205, 1], "end": [208, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.sum_measure_preimage_singleton", "code": "protected theorem sum_measure_preimage_singleton (f : \u03b1 \u2192\u209b \u03b2) {\u03bc : Measure \u03b1} (s : Finset \u03b2) :\n    (\u2211 y in s, \u03bc (f \u207b\u00b9' {y})) = \u03bc (f \u207b\u00b9' \u2191s)", "start": [211, 1], "end": [213, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.sum_range_measure_preimage_singleton", "code": "theorem sum_range_measure_preimage_singleton (f : \u03b1 \u2192\u209b \u03b2) (\u03bc : Measure \u03b1) :\n    (\u2211 y in f.range, \u03bc (f \u207b\u00b9' {y})) = \u03bc univ", "start": [216, 1], "end": [218, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.piecewise", "code": "def piecewise (s : Set \u03b1) (hs : MeasurableSet s) (f g : \u03b1 \u2192\u209b \u03b2) : \u03b1 \u2192\u209b \u03b2 :=\n  \u27e8s.piecewise f g, fun _ =>\n    letI : MeasurableSpace \u03b2 := \u22a4\n    f.measurable.piecewise hs g.measurable trivial,\n    (f.finite_range.union g.finite_range).subset range_ite_subset\u27e9", "start": [221, 1], "end": [226, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_piecewise", "code": "@[simp]\ntheorem coe_piecewise {s : Set \u03b1} (hs : MeasurableSet s) (f g : \u03b1 \u2192\u209b \u03b2) :\n    \u21d1(piecewise s hs f g) = s.piecewise f g", "start": [229, 1], "end": [232, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.piecewise_apply", "code": "theorem piecewise_apply {s : Set \u03b1} (hs : MeasurableSet s) (f g : \u03b1 \u2192\u209b \u03b2) (a) :\n    piecewise s hs f g a = if a \u2208 s then f a else g a", "start": [235, 1], "end": [237, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.piecewise_compl", "code": "@[simp]\ntheorem piecewise_compl {s : Set \u03b1} (hs : MeasurableSet s\u1d9c) (f g : \u03b1 \u2192\u209b \u03b2) :\n    piecewise s\u1d9c hs f g = piecewise s hs.of_compl g f", "start": [240, 1], "end": [243, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.piecewise_univ", "code": "@[simp]\ntheorem piecewise_univ (f g : \u03b1 \u2192\u209b \u03b2) : piecewise univ MeasurableSet.univ f g = f", "start": [246, 1], "end": [248, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.piecewise_empty", "code": "@[simp]\ntheorem piecewise_empty (f g : \u03b1 \u2192\u209b \u03b2) : piecewise \u2205 MeasurableSet.empty f g = g", "start": [251, 1], "end": [253, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.support_indicator", "code": "theorem support_indicator [Zero \u03b2] {s : Set \u03b1} (hs : MeasurableSet s) (f : \u03b1 \u2192\u209b \u03b2) :\n    Function.support (f.piecewise s hs (SimpleFunc.const \u03b1 0)) = s \u2229 Function.support f", "start": [256, 1], "end": [258, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.range_indicator", "code": "theorem range_indicator {s : Set \u03b1} (hs : MeasurableSet s) (hs_nonempty : s.Nonempty)\n    (hs_ne_univ : s \u2260 univ) (x y : \u03b2) :\n    (piecewise s hs (const \u03b1 x) (const \u03b1 y)).range = {x, y}", "start": [261, 1], "end": [266, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.measurable_bind", "code": "theorem measurable_bind [MeasurableSpace \u03b3] (f : \u03b1 \u2192\u209b \u03b2) (g : \u03b2 \u2192 \u03b1 \u2192 \u03b3)\n    (hg : \u2200 b, Measurable (g b)) : Measurable fun a => g (f a) a", "start": [269, 1], "end": [271, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.bind", "code": "def bind (f : \u03b1 \u2192\u209b \u03b2) (g : \u03b2 \u2192 \u03b1 \u2192\u209b \u03b3) : \u03b1 \u2192\u209b \u03b3 :=\n  \u27e8fun a => g (f a) a, fun c =>\n    f.measurableSet_cut (fun a b => g b a = c) fun b => (g b).measurableSet_preimage {c},\n    (f.finite_range.biUnion fun b _ => (g b).finite_range).subset <| by\n      rintro _ \u27e8a, rfl\u27e9; simp; exact \u27e8a, a, rfl\u27e9\u27e9", "start": [274, 1], "end": [280, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.bind_apply", "code": "@[simp]\ntheorem bind_apply (f : \u03b1 \u2192\u209b \u03b2) (g : \u03b2 \u2192 \u03b1 \u2192\u209b \u03b3) (a) : f.bind g a = g (f a) a", "start": [283, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.map", "code": "def map (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192\u209b \u03b2) : \u03b1 \u2192\u209b \u03b3 :=\n  bind f (const \u03b1 \u2218 g)", "start": [288, 1], "end": [291, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.map_apply", "code": "theorem map_apply (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192\u209b \u03b2) (a) : f.map g a = g (f a)", "start": [294, 1], "end": [295, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.map_map", "code": "theorem map_map (g : \u03b2 \u2192 \u03b3) (h : \u03b3 \u2192 \u03b4) (f : \u03b1 \u2192\u209b \u03b2) : (f.map g).map h = f.map (h \u2218 g)", "start": [298, 1], "end": [299, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_map", "code": "@[simp]\ntheorem coe_map (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192\u209b \u03b2) : (f.map g : \u03b1 \u2192 \u03b3) = g \u2218 f", "start": [302, 1], "end": [304, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.range_map", "code": "@[simp]\ntheorem range_map [DecidableEq \u03b3] (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192\u209b \u03b2) : (f.map g).range = f.range.image g", "start": [307, 1], "end": [309, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.map_const", "code": "@[simp]\ntheorem map_const (g : \u03b2 \u2192 \u03b3) (b : \u03b2) : (const \u03b1 b).map g = const \u03b1 (g b)", "start": [312, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.map_preimage", "code": "theorem map_preimage (f : \u03b1 \u2192\u209b \u03b2) (g : \u03b2 \u2192 \u03b3) (s : Set \u03b3) :\n    f.map g \u207b\u00b9' s = f \u207b\u00b9' \u2191(f.range.filter fun b => g b \u2208 s)", "start": [317, 1], "end": [321, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.map_preimage_singleton", "code": "theorem map_preimage_singleton (f : \u03b1 \u2192\u209b \u03b2) (g : \u03b2 \u2192 \u03b3) (c : \u03b3) :\n    f.map g \u207b\u00b9' {c} = f \u207b\u00b9' \u2191(f.range.filter fun b => g b = c)", "start": [324, 1], "end": [326, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.comp", "code": "def comp [MeasurableSpace \u03b2] (f : \u03b2 \u2192\u209b \u03b3) (g : \u03b1 \u2192 \u03b2) (hgm : Measurable g) : \u03b1 \u2192\u209b \u03b3 where\n  toFun := f \u2218 g\n  finite_range' := f.finite_range.subset <| Set.range_comp_subset_range _ _\n  measurableSet_fiber' z := hgm (f.measurableSet_fiber z)", "start": [329, 1], "end": [333, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_comp", "code": "@[simp]\ntheorem coe_comp [MeasurableSpace \u03b2] (f : \u03b2 \u2192\u209b \u03b3) {g : \u03b1 \u2192 \u03b2} (hgm : Measurable g) :\n    \u21d1(f.comp g hgm) = f \u2218 g", "start": [336, 1], "end": [339, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.range_comp_subset_range", "code": "theorem range_comp_subset_range [MeasurableSpace \u03b2] (f : \u03b2 \u2192\u209b \u03b3) {g : \u03b1 \u2192 \u03b2} (hgm : Measurable g) :\n    (f.comp g hgm).range \u2286 f.range", "start": [342, 1], "end": [344, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.extend", "code": "def extend [MeasurableSpace \u03b2] (f\u2081 : \u03b1 \u2192\u209b \u03b3) (g : \u03b1 \u2192 \u03b2) (hg : MeasurableEmbedding g)\n    (f\u2082 : \u03b2 \u2192\u209b \u03b3) : \u03b2 \u2192\u209b \u03b3 where\n  toFun := Function.extend g f\u2081 f\u2082\n  finite_range' :=\n    (f\u2081.finite_range.union <| f\u2082.finite_range.subset (image_subset_range _ _)).subset\n      (range_extend_subset _ _ _)\n  measurableSet_fiber' := by\n    letI : MeasurableSpace \u03b3 := \u22a4; haveI : MeasurableSingletonClass \u03b3 := \u27e8fun _ => trivial\u27e9\n    exact fun x => hg.measurable_extend f\u2081.measurable f\u2082.measurable (measurableSet_singleton _)", "start": [347, 1], "end": [357, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.extend_apply", "code": "@[simp]\ntheorem extend_apply [MeasurableSpace \u03b2] (f\u2081 : \u03b1 \u2192\u209b \u03b3) {g : \u03b1 \u2192 \u03b2} (hg : MeasurableEmbedding g)\n    (f\u2082 : \u03b2 \u2192\u209b \u03b3) (x : \u03b1) : (f\u2081.extend g hg f\u2082) (g x) = f\u2081 x", "start": [360, 1], "end": [363, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.extend_apply'", "code": "@[simp]\ntheorem extend_apply' [MeasurableSpace \u03b2] (f\u2081 : \u03b1 \u2192\u209b \u03b3) {g : \u03b1 \u2192 \u03b2} (hg : MeasurableEmbedding g)\n    (f\u2082 : \u03b2 \u2192\u209b \u03b3) {y : \u03b2} (h : \u00ac\u2203 x, g x = y) : (f\u2081.extend g hg f\u2082) y = f\u2082 y", "start": [366, 1], "end": [369, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.extend_comp_eq'", "code": "@[simp]\ntheorem extend_comp_eq' [MeasurableSpace \u03b2] (f\u2081 : \u03b1 \u2192\u209b \u03b3) {g : \u03b1 \u2192 \u03b2} (hg : MeasurableEmbedding g)\n    (f\u2082 : \u03b2 \u2192\u209b \u03b3) : f\u2081.extend g hg f\u2082 \u2218 g = f\u2081", "start": [372, 1], "end": [375, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.extend_comp_eq", "code": "@[simp]\ntheorem extend_comp_eq [MeasurableSpace \u03b2] (f\u2081 : \u03b1 \u2192\u209b \u03b3) {g : \u03b1 \u2192 \u03b2} (hg : MeasurableEmbedding g)\n    (f\u2082 : \u03b2 \u2192\u209b \u03b3) : (f\u2081.extend g hg f\u2082).comp g hg.measurable = f\u2081", "start": [378, 1], "end": [381, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.seq", "code": "def seq (f : \u03b1 \u2192\u209b \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192\u209b \u03b2) : \u03b1 \u2192\u209b \u03b3 :=\n  f.bind fun f => g.map f", "start": [384, 1], "end": [387, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.seq_apply", "code": "@[simp]\ntheorem seq_apply (f : \u03b1 \u2192\u209b \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192\u209b \u03b2) (a : \u03b1) : f.seq g a = f a (g a)", "start": [390, 1], "end": [392, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.pair", "code": "def pair (f : \u03b1 \u2192\u209b \u03b2) (g : \u03b1 \u2192\u209b \u03b3) : \u03b1 \u2192\u209b \u03b2 \u00d7 \u03b3 :=\n  (f.map Prod.mk).seq g", "start": [395, 1], "end": [398, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.pair_apply", "code": "@[simp]\ntheorem pair_apply (f : \u03b1 \u2192\u209b \u03b2) (g : \u03b1 \u2192\u209b \u03b3) (a) : pair f g a = (f a, g a)", "start": [401, 1], "end": [403, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.pair_preimage", "code": "theorem pair_preimage (f : \u03b1 \u2192\u209b \u03b2) (g : \u03b1 \u2192\u209b \u03b3) (s : Set \u03b2) (t : Set \u03b3) :\n    pair f g \u207b\u00b9' s \u00d7\u02e2 t = f \u207b\u00b9' s \u2229 g \u207b\u00b9' t", "start": [406, 1], "end": [408, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.pair_preimage_singleton", "code": "theorem pair_preimage_singleton (f : \u03b1 \u2192\u209b \u03b2) (g : \u03b1 \u2192\u209b \u03b3) (b : \u03b2) (c : \u03b3) :\n    pair f g \u207b\u00b9' {(b, c)} = f \u207b\u00b9' {b} \u2229 g \u207b\u00b9' {c}", "start": [412, 1], "end": [415, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.bind_const", "code": "theorem bind_const (f : \u03b1 \u2192\u209b \u03b2) : f.bind (const \u03b1) = f", "start": [418, 1], "end": [418, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instOne", "code": "@[to_additive]\ninstance instOne [One \u03b2] : One (\u03b1 \u2192\u209b \u03b2) :=\n  \u27e8const \u03b1 1\u27e9", "start": [421, 1], "end": [423, 14], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instMul", "code": "@[to_additive]\ninstance instMul [Mul \u03b2] : Mul (\u03b1 \u2192\u209b \u03b2) :=\n  \u27e8fun f g => (f.map (\u00b7 * \u00b7)).seq g\u27e9", "start": [427, 1], "end": [429, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instDiv", "code": "@[to_additive]\ninstance instDiv [Div \u03b2] : Div (\u03b1 \u2192\u209b \u03b2) :=\n  \u27e8fun f g => (f.map (\u00b7 / \u00b7)).seq g\u27e9", "start": [433, 1], "end": [435, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instInv", "code": "@[to_additive]\ninstance instInv [Inv \u03b2] : Inv (\u03b1 \u2192\u209b \u03b2) :=\n  \u27e8fun f => f.map Inv.inv\u27e9", "start": [439, 1], "end": [441, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instSup", "code": "instance instSup [Sup \u03b2] : Sup (\u03b1 \u2192\u209b \u03b2) :=\n  \u27e8fun f g => (f.map (\u00b7 \u2294 \u00b7)).seq g\u27e9", "start": [445, 1], "end": [446, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instInf", "code": "instance instInf [Inf \u03b2] : Inf (\u03b1 \u2192\u209b \u03b2) :=\n  \u27e8fun f g => (f.map (\u00b7 \u2293 \u00b7)).seq g\u27e9", "start": [449, 1], "end": [450, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instLE", "code": "instance instLE [LE \u03b2] : LE (\u03b1 \u2192\u209b \u03b2) :=\n  \u27e8fun f g => \u2200 a, f a \u2264 g a\u27e9", "start": [453, 1], "end": [454, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.const_one", "code": "@[to_additive (attr := simp)]\ntheorem const_one [One \u03b2] : const \u03b1 (1 : \u03b2) = 1", "start": [457, 1], "end": [459, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_one", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one [One \u03b2] : \u21d1(1 : \u03b1 \u2192\u209b \u03b2) = 1", "start": [463, 1], "end": [465, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_mul", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul [Mul \u03b2] (f g : \u03b1 \u2192\u209b \u03b2) : \u21d1(f * g) = \u21d1f * \u21d1g", "start": [469, 1], "end": [471, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_inv", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv [Inv \u03b2] (f : \u03b1 \u2192\u209b \u03b2) : \u21d1(f\u207b\u00b9) = (\u21d1f)\u207b\u00b9", "start": [475, 1], "end": [477, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_div", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div [Div \u03b2] (f g : \u03b1 \u2192\u209b \u03b2) : \u21d1(f / g) = \u21d1f / \u21d1g", "start": [481, 1], "end": [483, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_le", "code": "@[simp, norm_cast]\ntheorem coe_le [Preorder \u03b2] {f g : \u03b1 \u2192\u209b \u03b2} : (f : \u03b1 \u2192 \u03b2) \u2264 g \u2194 f \u2264 g", "start": [487, 1], "end": [489, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_sup", "code": "@[simp, norm_cast]\ntheorem coe_sup [Sup \u03b2] (f g : \u03b1 \u2192\u209b \u03b2) : \u21d1(f \u2294 g) = \u21d1f \u2294 \u21d1g", "start": [492, 1], "end": [494, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf [Inf \u03b2] (f g : \u03b1 \u2192\u209b \u03b2) : \u21d1(f \u2293 g) = \u21d1f \u2293 \u21d1g", "start": [497, 1], "end": [499, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.mul_apply", "code": "@[to_additive]\ntheorem mul_apply [Mul \u03b2] (f g : \u03b1 \u2192\u209b \u03b2) (a : \u03b1) : (f * g) a = f a * g a", "start": [502, 1], "end": [504, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.div_apply", "code": "@[to_additive]\ntheorem div_apply [Div \u03b2] (f g : \u03b1 \u2192\u209b \u03b2) (x : \u03b1) : (f / g) x = f x / g x", "start": [508, 1], "end": [510, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.inv_apply", "code": "@[to_additive]\ntheorem inv_apply [Inv \u03b2] (f : \u03b1 \u2192\u209b \u03b2) (x : \u03b1) : f\u207b\u00b9 x = (f x)\u207b\u00b9", "start": [514, 1], "end": [516, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.sup_apply", "code": "theorem sup_apply [Sup \u03b2] (f g : \u03b1 \u2192\u209b \u03b2) (a : \u03b1) : (f \u2294 g) a = f a \u2294 g a", "start": [520, 1], "end": [521, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.inf_apply", "code": "theorem inf_apply [Inf \u03b2] (f g : \u03b1 \u2192\u209b \u03b2) (a : \u03b1) : (f \u2293 g) a = f a \u2293 g a", "start": [524, 1], "end": [525, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.range_one", "code": "@[to_additive (attr := simp)]\ntheorem range_one [Nonempty \u03b1] [One \u03b2] : (1 : \u03b1 \u2192\u209b \u03b2).range = {1}", "start": [528, 1], "end": [530, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.range_eq_empty_of_isEmpty", "code": "@[simp]\ntheorem range_eq_empty_of_isEmpty {\u03b2} [h\u03b1 : IsEmpty \u03b1] (f : \u03b1 \u2192\u209b \u03b2) : f.range = \u2205", "start": [534, 1], "end": [542, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.eq_zero_of_mem_range_zero", "code": "theorem eq_zero_of_mem_range_zero [Zero \u03b2] : \u2200 {y : \u03b2}, y \u2208 (0 : \u03b1 \u2192\u209b \u03b2).range \u2192 y = 0", "start": [545, 1], "end": [546, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.mul_eq_map\u2082", "code": "@[to_additive]\ntheorem mul_eq_map\u2082 [Mul \u03b2] (f g : \u03b1 \u2192\u209b \u03b2) : f * g = (pair f g).map fun p : \u03b2 \u00d7 \u03b2 => p.1 * p.2", "start": [549, 1], "end": [551, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.sup_eq_map\u2082", "code": "theorem sup_eq_map\u2082 [Sup \u03b2] (f g : \u03b1 \u2192\u209b \u03b2) : f \u2294 g = (pair f g).map fun p : \u03b2 \u00d7 \u03b2 => p.1 \u2294 p.2", "start": [555, 1], "end": [556, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.const_mul_eq_map", "code": "@[to_additive]\ntheorem const_mul_eq_map [Mul \u03b2] (f : \u03b1 \u2192\u209b \u03b2) (b : \u03b2) : const \u03b1 b * f = f.map fun a => b * a", "start": [559, 1], "end": [561, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.map_mul", "code": "@[to_additive]\ntheorem map_mul [Mul \u03b2] [Mul \u03b3] {g : \u03b2 \u2192 \u03b3} (hg : \u2200 x y, g (x * y) = g x * g y) (f\u2081 f\u2082 : \u03b1 \u2192\u209b \u03b2) :\n    (f\u2081 * f\u2082).map g = f\u2081.map g * f\u2082.map g", "start": [565, 1], "end": [568, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instSMul", "code": "instance instSMul [SMul K \u03b2] : SMul K (\u03b1 \u2192\u209b \u03b2) :=\n  \u27e8fun k f => f.map ((\u00b7 \u2022 \u00b7) k)\u27e9", "start": [574, 1], "end": [575, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_smul", "code": "@[simp]\ntheorem coe_smul [SMul K \u03b2] (c : K) (f : \u03b1 \u2192\u209b \u03b2) : \u21d1(c \u2022 f) = c \u2022 \u21d1f", "start": [578, 1], "end": [580, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.smul_apply", "code": "theorem smul_apply [SMul K \u03b2] (k : K) (f : \u03b1 \u2192\u209b \u03b2) (a : \u03b1) : (k \u2022 f) a = k \u2022 f a", "start": [583, 1], "end": [584, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.hasNatPow", "code": "instance hasNatPow [Monoid \u03b2] : Pow (\u03b1 \u2192\u209b \u03b2) \u2115 :=\n  \u27e8fun f n => f.map (\u00b7 ^ n)\u27e9", "start": [587, 1], "end": [588, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_pow", "code": "@[simp]\ntheorem coe_pow [Monoid \u03b2] (f : \u03b1 \u2192\u209b \u03b2) (n : \u2115) : \u21d1(f ^ n) = (\u21d1f) ^ n", "start": [591, 1], "end": [593, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.pow_apply", "code": "theorem pow_apply [Monoid \u03b2] (n : \u2115) (f : \u03b1 \u2192\u209b \u03b2) (a : \u03b1) : (f ^ n) a = f a ^ n", "start": [596, 1], "end": [597, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.hasIntPow", "code": "instance hasIntPow [DivInvMonoid \u03b2] : Pow (\u03b1 \u2192\u209b \u03b2) \u2124 :=\n  \u27e8fun f n => f.map (\u00b7 ^ n)\u27e9", "start": [600, 1], "end": [601, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_zpow", "code": "@[simp]\ntheorem coe_zpow [DivInvMonoid \u03b2] (f : \u03b1 \u2192\u209b \u03b2) (z : \u2124) : \u21d1(f ^ z) = (\u21d1f) ^ z", "start": [604, 1], "end": [606, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.zpow_apply", "code": "theorem zpow_apply [DivInvMonoid \u03b2] (z : \u2124) (f : \u03b1 \u2192\u209b \u03b2) (a : \u03b1) : (f ^ z) a = f a ^ z", "start": [609, 1], "end": [610, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instAddMonoid", "code": "instance instAddMonoid [AddMonoid \u03b2] : AddMonoid (\u03b1 \u2192\u209b \u03b2) :=\n  Function.Injective.addMonoid (fun f => show \u03b1 \u2192 \u03b2 from f) coe_injective coe_zero coe_add\n    fun _ _ => coe_smul _ _", "start": [617, 1], "end": [619, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instAddCommMonoid", "code": "instance instAddCommMonoid [AddCommMonoid \u03b2] : AddCommMonoid (\u03b1 \u2192\u209b \u03b2) :=\n  Function.Injective.addCommMonoid (fun f => show \u03b1 \u2192 \u03b2 from f) coe_injective coe_zero coe_add\n    fun _ _ => coe_smul _ _", "start": [622, 1], "end": [624, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instAddGroup", "code": "instance instAddGroup [AddGroup \u03b2] : AddGroup (\u03b1 \u2192\u209b \u03b2) :=\n  Function.Injective.addGroup (fun f => show \u03b1 \u2192 \u03b2 from f) coe_injective coe_zero coe_add coe_neg\n    coe_sub (fun _ _ => coe_smul _ _) fun _ _ => coe_smul _ _", "start": [627, 1], "end": [629, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instAddCommGroup", "code": "instance instAddCommGroup [AddCommGroup \u03b2] : AddCommGroup (\u03b1 \u2192\u209b \u03b2) :=\n  Function.Injective.addCommGroup (fun f => show \u03b1 \u2192 \u03b2 from f) coe_injective coe_zero coe_add\n    coe_neg coe_sub (fun _ _ => coe_smul _ _) fun _ _ => coe_smul _ _", "start": [632, 1], "end": [634, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instMonoid", "code": "@[to_additive existing]\ninstance instMonoid [Monoid \u03b2] : Monoid (\u03b1 \u2192\u209b \u03b2) :=\n  Function.Injective.monoid (fun f => show \u03b1 \u2192 \u03b2 from f) coe_injective coe_one coe_mul coe_pow", "start": [639, 1], "end": [641, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instCommMonoid", "code": "@[to_additive existing]\ninstance instCommMonoid [CommMonoid \u03b2] : CommMonoid (\u03b1 \u2192\u209b \u03b2) :=\n  Function.Injective.commMonoid (fun f => show \u03b1 \u2192 \u03b2 from f) coe_injective coe_one coe_mul coe_pow", "start": [644, 1], "end": [646, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instGroup", "code": "@[to_additive existing]\ninstance instGroup [Group \u03b2] : Group (\u03b1 \u2192\u209b \u03b2) :=\n  Function.Injective.group (fun f => show \u03b1 \u2192 \u03b2 from f) coe_injective coe_one coe_mul coe_inv\n    coe_div coe_pow coe_zpow", "start": [649, 1], "end": [652, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instCommGroup", "code": "@[to_additive existing]\ninstance instCommGroup [CommGroup \u03b2] : CommGroup (\u03b1 \u2192\u209b \u03b2) :=\n  Function.Injective.commGroup (fun f => show \u03b1 \u2192 \u03b2 from f) coe_injective coe_one coe_mul coe_inv\n    coe_div coe_pow coe_zpow", "start": [655, 1], "end": [658, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instModule", "code": "instance instModule [Semiring K] [AddCommMonoid \u03b2] [Module K \u03b2] : Module K (\u03b1 \u2192\u209b \u03b2) :=\n  Function.Injective.module K \u27e8\u27e8fun f => show \u03b1 \u2192 \u03b2 from f, coe_zero\u27e9, coe_add\u27e9\n    coe_injective coe_smul", "start": [661, 1], "end": [663, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.smul_eq_map", "code": "theorem smul_eq_map [SMul K \u03b2] (k : K) (f : \u03b1 \u2192\u209b \u03b2) : k \u2022 f = f.map ((\u00b7 \u2022 \u00b7) k)", "start": [666, 1], "end": [667, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instPreorder", "code": "instance instPreorder [Preorder \u03b2] : Preorder (\u03b1 \u2192\u209b \u03b2) :=\n  { SimpleFunc.instLE with\n    le_refl := fun f a => le_rfl\n    le_trans := fun f g h hfg hgh a => le_trans (hfg _) (hgh a) }", "start": [670, 1], "end": [673, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instPartialOrder", "code": "instance instPartialOrder [PartialOrder \u03b2] : PartialOrder (\u03b1 \u2192\u209b \u03b2) :=\n  { SimpleFunc.instPreorder with\n    le_antisymm := fun _f _g hfg hgf => ext fun a => le_antisymm (hfg a) (hgf a) }", "start": [676, 1], "end": [678, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instOrderBot", "code": "instance instOrderBot [LE \u03b2] [OrderBot \u03b2] : OrderBot (\u03b1 \u2192\u209b \u03b2) where\n  bot := const \u03b1 \u22a5\n  bot_le _ _ := bot_le", "start": [681, 1], "end": [683, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instOrderTop", "code": "instance instOrderTop [LE \u03b2] [OrderTop \u03b2] : OrderTop (\u03b1 \u2192\u209b \u03b2) where\n  top := const \u03b1 \u22a4\n  le_top _ _ := le_top", "start": [686, 1], "end": [688, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instSemilatticeInf", "code": "instance instSemilatticeInf [SemilatticeInf \u03b2] : SemilatticeInf (\u03b1 \u2192\u209b \u03b2) :=\n  { SimpleFunc.instPartialOrder with\n    inf := (\u00b7 \u2293 \u00b7)\n    inf_le_left := fun _ _ _ => inf_le_left\n    inf_le_right := fun _ _ _ => inf_le_right\n    le_inf := fun _f _g _h hfh hgh a => le_inf (hfh a) (hgh a) }", "start": [691, 1], "end": [696, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instSemilatticeSup", "code": "instance instSemilatticeSup [SemilatticeSup \u03b2] : SemilatticeSup (\u03b1 \u2192\u209b \u03b2) :=\n  { SimpleFunc.instPartialOrder with\n    sup := (\u00b7 \u2294 \u00b7)\n    le_sup_left := fun _ _ _ => le_sup_left\n    le_sup_right := fun _ _ _ => le_sup_right\n    sup_le := fun _f _g _h hfh hgh a => sup_le (hfh a) (hgh a) }", "start": [699, 1], "end": [704, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instLattice", "code": "instance instLattice [Lattice \u03b2] : Lattice (\u03b1 \u2192\u209b \u03b2) :=\n  { SimpleFunc.instSemilatticeSup, SimpleFunc.instSemilatticeInf with }", "start": [707, 1], "end": [708, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.instBoundedOrder", "code": "instance instBoundedOrder [LE \u03b2] [BoundedOrder \u03b2] : BoundedOrder (\u03b1 \u2192\u209b \u03b2) :=\n  { SimpleFunc.instOrderBot, SimpleFunc.instOrderTop with }", "start": [711, 1], "end": [712, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.finset_sup_apply", "code": "theorem finset_sup_apply [SemilatticeSup \u03b2] [OrderBot \u03b2] {f : \u03b3 \u2192 \u03b1 \u2192\u209b \u03b2} (s : Finset \u03b3) (a : \u03b1) :\n    s.sup f a = s.sup fun c => f c a", "start": [715, 1], "end": [719, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.restrict", "code": "def restrict (f : \u03b1 \u2192\u209b \u03b2) (s : Set \u03b1) : \u03b1 \u2192\u209b \u03b2 :=\n  if hs : MeasurableSet s then piecewise s hs f 0 else 0", "start": [726, 1], "end": [729, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.restrict_of_not_measurable", "code": "theorem restrict_of_not_measurable {f : \u03b1 \u2192\u209b \u03b2} {s : Set \u03b1} (hs : \u00acMeasurableSet s) :\n    restrict f s = 0", "start": [732, 1], "end": [734, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.coe_restrict", "code": "@[simp]\ntheorem coe_restrict (f : \u03b1 \u2192\u209b \u03b2) {s : Set \u03b1} (hs : MeasurableSet s) :\n    \u21d1(restrict f s) = indicator s f", "start": [737, 1], "end": [740, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.restrict_univ", "code": "@[simp]\ntheorem restrict_univ (f : \u03b1 \u2192\u209b \u03b2) : restrict f univ = f", "start": [743, 1], "end": [744, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.restrict_empty", "code": "@[simp]\ntheorem restrict_empty (f : \u03b1 \u2192\u209b \u03b2) : restrict f \u2205 = 0", "start": [747, 1], "end": [748, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.map_restrict_of_zero", "code": "theorem map_restrict_of_zero [Zero \u03b3] {g : \u03b2 \u2192 \u03b3} (hg : g 0 = 0) (f : \u03b1 \u2192\u209b \u03b2) (s : Set \u03b1) :\n    (f.restrict s).map g = (f.map g).restrict s", "start": [751, 1], "end": [755, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.map_coe_ennreal_restrict", "code": "theorem map_coe_ennreal_restrict (f : \u03b1 \u2192\u209b \u211d\u22650) (s : Set \u03b1) :\n    (f.restrict s).map ((\u2191) : \u211d\u22650 \u2192 \u211d\u22650\u221e) = (f.map (\u2191)).restrict s", "start": [758, 1], "end": [760, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.map_coe_nnreal_restrict", "code": "theorem map_coe_nnreal_restrict (f : \u03b1 \u2192\u209b \u211d\u22650) (s : Set \u03b1) :\n    (f.restrict s).map ((\u2191) : \u211d\u22650 \u2192 \u211d) = (f.map (\u2191)).restrict s", "start": [763, 1], "end": [765, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.restrict_apply", "code": "theorem restrict_apply (f : \u03b1 \u2192\u209b \u03b2) {s : Set \u03b1} (hs : MeasurableSet s) (a) :\n    restrict f s a = indicator s f a", "start": [768, 1], "end": [769, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.restrict_preimage", "code": "theorem restrict_preimage (f : \u03b1 \u2192\u209b \u03b2) {s : Set \u03b1} (hs : MeasurableSet s) {t : Set \u03b2}\n    (ht : (0 : \u03b2) \u2209 t) : restrict f s \u207b\u00b9' t = s \u2229 f \u207b\u00b9' t", "start": [772, 1], "end": [774, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.restrict_preimage_singleton", "code": "theorem restrict_preimage_singleton (f : \u03b1 \u2192\u209b \u03b2) {s : Set \u03b1} (hs : MeasurableSet s) {r : \u03b2}\n    (hr : r \u2260 0) : restrict f s \u207b\u00b9' {r} = s \u2229 f \u207b\u00b9' {r}", "start": [777, 1], "end": [779, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.mem_restrict_range", "code": "theorem mem_restrict_range {r : \u03b2} {s : Set \u03b1} {f : \u03b1 \u2192\u209b \u03b2} (hs : MeasurableSet s) :\n    r \u2208 (restrict f s).range \u2194 r = 0 \u2227 s \u2260 univ \u2228 r \u2208 f '' s", "start": [782, 1], "end": [784, 75], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.mem_image_of_mem_range_restrict", "code": "theorem mem_image_of_mem_range_restrict {r : \u03b2} {s : Set \u03b1} {f : \u03b1 \u2192\u209b \u03b2}\n    (hr : r \u2208 (restrict f s).range) (h0 : r \u2260 0) : r \u2208 f '' s", "start": [787, 1], "end": [792, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.restrict_mono", "code": "@[mono]\ntheorem restrict_mono [Preorder \u03b2] (s : Set \u03b1) {f g : \u03b1 \u2192\u209b \u03b2} (H : f \u2264 g) :\n    f.restrict s \u2264 g.restrict s", "start": [795, 1], "end": [800, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.approx", "code": "def approx (i : \u2115 \u2192 \u03b2) (f : \u03b1 \u2192 \u03b2) (n : \u2115) : \u03b1 \u2192\u209b \u03b2 :=\n  (Finset.range n).sup fun k => restrict (const \u03b1 (i k)) { a : \u03b1 | i k \u2264 f a }", "start": [811, 1], "end": [815, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.approx_apply", "code": "theorem approx_apply [TopologicalSpace \u03b2] [OrderClosedTopology \u03b2] [MeasurableSpace \u03b2]\n    [OpensMeasurableSpace \u03b2] {i : \u2115 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {n : \u2115} (a : \u03b1) (hf : Measurable f) :\n    (approx i f n : \u03b1 \u2192\u209b \u03b2) a = (Finset.range n).sup fun k => if i k \u2264 f a then i k else 0", "start": [818, 1], "end": [827, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.monotone_approx", "code": "theorem monotone_approx (i : \u2115 \u2192 \u03b2) (f : \u03b1 \u2192 \u03b2) : Monotone (approx i f)", "start": [830, 1], "end": [831, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.approx_comp", "code": "theorem approx_comp [TopologicalSpace \u03b2] [OrderClosedTopology \u03b2] [MeasurableSpace \u03b2]\n    [OpensMeasurableSpace \u03b2] [MeasurableSpace \u03b3] {i : \u2115 \u2192 \u03b2} {f : \u03b3 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} {n : \u2115} (a : \u03b1)\n    (hf : Measurable f) (hg : Measurable g) :\n    (approx i (f \u2218 g) n : \u03b1 \u2192\u209b \u03b2) a = (approx i f n : \u03b3 \u2192\u209b \u03b2) (g a)", "start": [834, 1], "end": [838, 75], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.iSup_approx_apply", "code": "theorem iSup_approx_apply [TopologicalSpace \u03b2] [CompleteLattice \u03b2] [OrderClosedTopology \u03b2] [Zero \u03b2]\n    [MeasurableSpace \u03b2] [OpensMeasurableSpace \u03b2] (i : \u2115 \u2192 \u03b2) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (hf : Measurable f)\n    (h_zero : (0 : \u03b2) = \u22a5) : \u2a06 n, (approx i f n : \u03b1 \u2192\u209b \u03b2) a = \u2a06 (k) (_ : i k \u2264 f a), i k", "start": [843, 1], "end": [856, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.ennrealRatEmbed", "code": "def ennrealRatEmbed (n : \u2115) : \u211d\u22650\u221e :=\n  ENNReal.ofReal ((Encodable.decode (\u03b1 := \u211a) n).getD (0 : \u211a))", "start": [863, 1], "end": [865, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.ennrealRatEmbed_encode", "code": "theorem ennrealRatEmbed_encode (q : \u211a) : ennrealRatEmbed (Encodable.encode q) = Real.toNNReal q", "start": [868, 1], "end": [869, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.eapprox", "code": "def eapprox : (\u03b1 \u2192 \u211d\u22650\u221e) \u2192 \u2115 \u2192 \u03b1 \u2192\u209b \u211d\u22650\u221e :=\n  approx ennrealRatEmbed", "start": [872, 1], "end": [874, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.eapprox_lt_top", "code": "theorem eapprox_lt_top (f : \u03b1 \u2192 \u211d\u22650\u221e) (n : \u2115) (a : \u03b1) : eapprox f n a < \u221e", "start": [877, 1], "end": [888, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.monotone_eapprox", "code": "@[mono]\ntheorem monotone_eapprox (f : \u03b1 \u2192 \u211d\u22650\u221e) : Monotone (eapprox f)", "start": [891, 1], "end": [893, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.iSup_eapprox_apply", "code": "theorem iSup_eapprox_apply (f : \u03b1 \u2192 \u211d\u22650\u221e) (hf : Measurable f) (a : \u03b1) :\n    \u2a06 n, (eapprox f n : \u03b1 \u2192\u209b \u211d\u22650\u221e) a = f a", "start": [896, 1], "end": [907, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.eapprox_comp", "code": "theorem eapprox_comp [MeasurableSpace \u03b3] {f : \u03b3 \u2192 \u211d\u22650\u221e} {g : \u03b1 \u2192 \u03b3} {n : \u2115} (hf : Measurable f)\n    (hg : Measurable g) : (eapprox (f \u2218 g) n : \u03b1 \u2192 \u211d\u22650\u221e) = (eapprox f n : \u03b3 \u2192\u209b \u211d\u22650\u221e) \u2218 g", "start": [910, 1], "end": [912, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.eapproxDiff", "code": "def eapproxDiff (f : \u03b1 \u2192 \u211d\u22650\u221e) : \u2115 \u2192 \u03b1 \u2192\u209b \u211d\u22650\n  | 0 => (eapprox f 0).map ENNReal.toNNReal\n  | n + 1 => (eapprox f (n + 1) - eapprox f n).map ENNReal.toNNReal", "start": [915, 1], "end": [919, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.sum_eapproxDiff", "code": "theorem sum_eapproxDiff (f : \u03b1 \u2192 \u211d\u22650\u221e) (n : \u2115) (a : \u03b1) :\n    (\u2211 k in Finset.range (n + 1), (eapproxDiff f k a : \u211d\u22650\u221e)) = eapprox f n a", "start": [922, 1], "end": [932, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.tsum_eapproxDiff", "code": "theorem tsum_eapproxDiff (f : \u03b1 \u2192 \u211d\u22650\u221e) (hf : Measurable f) (a : \u03b1) :\n    (\u2211' n, (eapproxDiff f n a : \u211d\u22650\u221e)) = f a", "start": [935, 1], "end": [938, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral", "code": "def lintegral {_m : MeasurableSpace \u03b1} (f : \u03b1 \u2192\u209b \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : \u211d\u22650\u221e :=\n  \u2211 x in f.range, x * \u03bc (f \u207b\u00b9' {x})", "start": [949, 1], "end": [951, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral_eq_of_subset", "code": "theorem lintegral_eq_of_subset (f : \u03b1 \u2192\u209b \u211d\u22650\u221e) {s : Finset \u211d\u22650\u221e}\n    (hs : \u2200 x, f x \u2260 0 \u2192 \u03bc (f \u207b\u00b9' {f x}) \u2260 0 \u2192 f x \u2208 s) :\n    f.lintegral \u03bc = \u2211 x in s, x * \u03bc (f \u207b\u00b9' {x})", "start": [954, 1], "end": [966, 8], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral_eq_of_subset'", "code": "theorem lintegral_eq_of_subset' (f : \u03b1 \u2192\u209b \u211d\u22650\u221e) {s : Finset \u211d\u22650\u221e} (hs : f.range \\ {0} \u2286 s) :\n    f.lintegral \u03bc = \u2211 x in s, x * \u03bc (f \u207b\u00b9' {x})", "start": [969, 1], "end": [972, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.map_lintegral", "code": "theorem map_lintegral (g : \u03b2 \u2192 \u211d\u22650\u221e) (f : \u03b1 \u2192\u209b \u03b2) :\n    (f.map g).lintegral \u03bc = \u2211 x in f.range, g x * \u03bc (f \u207b\u00b9' {x})", "start": [975, 1], "end": [987, 11], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.add_lintegral", "code": "theorem add_lintegral (f g : \u03b1 \u2192\u209b \u211d\u22650\u221e) : (f + g).lintegral \u03bc = f.lintegral \u03bc + g.lintegral \u03bc", "start": [990, 1], "end": [1000, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.const_mul_lintegral", "code": "theorem const_mul_lintegral (f : \u03b1 \u2192\u209b \u211d\u22650\u221e) (x : \u211d\u22650\u221e) :\n    (const \u03b1 x * f).lintegral \u03bc = x * f.lintegral \u03bc", "start": [1003, 1], "end": [1009, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral\u2097", "code": "def lintegral\u2097 {m : MeasurableSpace \u03b1} : (\u03b1 \u2192\u209b \u211d\u22650\u221e) \u2192\u2097[\u211d\u22650\u221e] Measure \u03b1 \u2192\u2097[\u211d\u22650\u221e] \u211d\u22650\u221e where\n  toFun f :=\n    { toFun := lintegral f\n      map_add' := by simp [lintegral, mul_add, Finset.sum_add_distrib]\n      map_smul' := fun c \u03bc => by\n        simp [lintegral, mul_left_comm _ c, Finset.mul_sum, Measure.smul_apply c] }\n  map_add' f g := LinearMap.ext fun \u03bc => add_lintegral f g\n  map_smul' c f := LinearMap.ext fun \u03bc => const_mul_lintegral f c", "start": [1012, 1], "end": [1020, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.zero_lintegral", "code": "@[simp]\ntheorem zero_lintegral : (0 : \u03b1 \u2192\u209b \u211d\u22650\u221e).lintegral \u03bc = 0", "start": [1023, 1], "end": [1025, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral_add", "code": "theorem lintegral_add {\u03bd} (f : \u03b1 \u2192\u209b \u211d\u22650\u221e) : f.lintegral (\u03bc + \u03bd) = f.lintegral \u03bc + f.lintegral \u03bd", "start": [1028, 1], "end": [1029, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral_smul", "code": "theorem lintegral_smul (f : \u03b1 \u2192\u209b \u211d\u22650\u221e) (c : \u211d\u22650\u221e) : f.lintegral (c \u2022 \u03bc) = c \u2022 f.lintegral \u03bc", "start": [1032, 1], "end": [1033, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral_zero", "code": "@[simp]\ntheorem lintegral_zero [MeasurableSpace \u03b1] (f : \u03b1 \u2192\u209b \u211d\u22650\u221e) : f.lintegral 0 = 0", "start": [1036, 1], "end": [1038, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral_sum", "code": "theorem lintegral_sum {m : MeasurableSpace \u03b1} {\u03b9} (f : \u03b1 \u2192\u209b \u211d\u22650\u221e) (\u03bc : \u03b9 \u2192 Measure \u03b1) :\n    f.lintegral (Measure.sum \u03bc) = \u2211' i, f.lintegral (\u03bc i)", "start": [1041, 1], "end": [1045, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.restrict_lintegral", "code": "theorem restrict_lintegral (f : \u03b1 \u2192\u209b \u211d\u22650\u221e) {s : Set \u03b1} (hs : MeasurableSet s) :\n    (restrict f s).lintegral \u03bc = \u2211 r in f.range, r * \u03bc (f \u207b\u00b9' {r} \u2229 s)", "start": [1048, 1], "end": [1060, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral_restrict", "code": "theorem lintegral_restrict {m : MeasurableSpace \u03b1} (f : \u03b1 \u2192\u209b \u211d\u22650\u221e) (s : Set \u03b1) (\u03bc : Measure \u03b1) :\n    f.lintegral (\u03bc.restrict s) = \u2211 y in f.range, y * \u03bc (f \u207b\u00b9' {y} \u2229 s)", "start": [1063, 1], "end": [1065, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.restrict_lintegral_eq_lintegral_restrict", "code": "theorem restrict_lintegral_eq_lintegral_restrict (f : \u03b1 \u2192\u209b \u211d\u22650\u221e) {s : Set \u03b1}\n    (hs : MeasurableSet s) : (restrict f s).lintegral \u03bc = f.lintegral (\u03bc.restrict s)", "start": [1068, 1], "end": [1070, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.const_lintegral", "code": "theorem const_lintegral (c : \u211d\u22650\u221e) : (const \u03b1 c).lintegral \u03bc = c * \u03bc univ", "start": [1073, 1], "end": [1077, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.const_lintegral_restrict", "code": "theorem const_lintegral_restrict (c : \u211d\u22650\u221e) (s : Set \u03b1) :\n    (const \u03b1 c).lintegral (\u03bc.restrict s) = c * \u03bc s", "start": [1080, 1], "end": [1082, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.restrict_const_lintegral", "code": "theorem restrict_const_lintegral (c : \u211d\u22650\u221e) {s : Set \u03b1} (hs : MeasurableSet s) :\n    ((const \u03b1 c).restrict s).lintegral \u03bc = c * \u03bc s", "start": [1085, 1], "end": [1087, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.le_sup_lintegral", "code": "theorem le_sup_lintegral (f g : \u03b1 \u2192\u209b \u211d\u22650\u221e) : f.lintegral \u03bc \u2294 g.lintegral \u03bc \u2264 (f \u2294 g).lintegral \u03bc", "start": [1090, 1], "end": [1100, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral_mono", "code": "@[mono]\ntheorem lintegral_mono {f g : \u03b1 \u2192\u209b \u211d\u22650\u221e} (hfg : f \u2264 g) (h\u03bc\u03bd : \u03bc \u2264 \u03bd) :\n    f.lintegral \u03bc \u2264 g.lintegral \u03bd", "start": [1103, 1], "end": [1112, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral_eq_of_measure_preimage", "code": "theorem lintegral_eq_of_measure_preimage [MeasurableSpace \u03b2] {f : \u03b1 \u2192\u209b \u211d\u22650\u221e} {g : \u03b2 \u2192\u209b \u211d\u22650\u221e}\n    {\u03bd : Measure \u03b2} (H : \u2200 y, \u03bc (f \u207b\u00b9' {y}) = \u03bd (g \u207b\u00b9' {y})) : f.lintegral \u03bc = g.lintegral \u03bd", "start": [1115, 1], "end": [1122, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral_congr", "code": "theorem lintegral_congr {f g : \u03b1 \u2192\u209b \u211d\u22650\u221e} (h : f =\u1d50[\u03bc] g) : f.lintegral \u03bc = g.lintegral \u03bc", "start": [1125, 1], "end": [1128, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral_map'", "code": "theorem lintegral_map' {\u03b2} [MeasurableSpace \u03b2] {\u03bc' : Measure \u03b2} (f : \u03b1 \u2192\u209b \u211d\u22650\u221e) (g : \u03b2 \u2192\u209b \u211d\u22650\u221e)\n    (m' : \u03b1 \u2192 \u03b2) (eq : \u2200 a, f a = g (m' a)) (h : \u2200 s, MeasurableSet s \u2192 \u03bc' s = \u03bc (m' \u207b\u00b9' s)) :\n    f.lintegral \u03bc = g.lintegral \u03bc'", "start": [1131, 1], "end": [1136, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral_map", "code": "theorem lintegral_map {\u03b2} [MeasurableSpace \u03b2] (g : \u03b2 \u2192\u209b \u211d\u22650\u221e) {f : \u03b1 \u2192 \u03b2} (hf : Measurable f) :\n    g.lintegral (Measure.map f \u03bc) = (g.comp f hf).lintegral \u03bc", "start": [1139, 1], "end": [1141, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.support_eq", "code": "theorem support_eq [MeasurableSpace \u03b1] [Zero \u03b2] (f : \u03b1 \u2192\u209b \u03b2) :\n    support f = \u22c3 y \u2208 f.range.filter fun y => y \u2260 0, f \u207b\u00b9' {y}", "start": [1150, 1], "end": [1154, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.measurableSet_support", "code": "theorem measurableSet_support [MeasurableSpace \u03b1] (f : \u03b1 \u2192\u209b \u03b2) : MeasurableSet (support f)", "start": [1159, 1], "end": [1161, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.FinMeasSupp", "code": "protected def FinMeasSupp {_m : MeasurableSpace \u03b1} (f : \u03b1 \u2192\u209b \u03b2) (\u03bc : Measure \u03b1) : Prop :=\n  f =\u1da0[\u03bc.cofinite] 0", "start": [1164, 1], "end": [1167, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.finMeasSupp_iff_support", "code": "theorem finMeasSupp_iff_support : f.FinMeasSupp \u03bc \u2194 \u03bc (support f) < \u221e", "start": [1170, 1], "end": [1171, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.finMeasSupp_iff", "code": "theorem finMeasSupp_iff : f.FinMeasSupp \u03bc \u2194 \u2200 y, y \u2260 0 \u2192 \u03bc (f \u207b\u00b9' {y}) < \u221e", "start": [1174, 1], "end": [1181, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.FinMeasSupp.meas_preimage_singleton_ne_zero", "code": "theorem meas_preimage_singleton_ne_zero (h : f.FinMeasSupp \u03bc) {y : \u03b2} (hy : y \u2260 0) :\n    \u03bc (f \u207b\u00b9' {y}) < \u221e", "start": [1186, 1], "end": [1188, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.FinMeasSupp.map", "code": "protected theorem map {g : \u03b2 \u2192 \u03b3} (hf : f.FinMeasSupp \u03bc) (hg : g 0 = 0) : (f.map g).FinMeasSupp \u03bc", "start": [1191, 1], "end": [1192, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.FinMeasSupp.of_map", "code": "theorem of_map {g : \u03b2 \u2192 \u03b3} (h : (f.map g).FinMeasSupp \u03bc) (hg : \u2200 b, g b = 0 \u2192 b = 0) :\n    f.FinMeasSupp \u03bc", "start": [1195, 1], "end": [1197, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.FinMeasSupp.map_iff", "code": "theorem map_iff {g : \u03b2 \u2192 \u03b3} (hg : \u2200 {b}, g b = 0 \u2194 b = 0) :\n    (f.map g).FinMeasSupp \u03bc \u2194 f.FinMeasSupp \u03bc", "start": [1200, 1], "end": [1202, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.FinMeasSupp.pair", "code": "protected theorem pair {g : \u03b1 \u2192\u209b \u03b3} (hf : f.FinMeasSupp \u03bc) (hg : g.FinMeasSupp \u03bc) :\n    (pair f g).FinMeasSupp \u03bc", "start": [1205, 1], "end": [1210, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.FinMeasSupp.map\u2082", "code": "protected theorem map\u2082 [Zero \u03b4] (hf : f.FinMeasSupp \u03bc) {g : \u03b1 \u2192\u209b \u03b3} (hg : g.FinMeasSupp \u03bc)\n    {op : \u03b2 \u2192 \u03b3 \u2192 \u03b4} (H : op 0 0 = 0) : ((pair f g).map (Function.uncurry op)).FinMeasSupp \u03bc", "start": [1213, 1], "end": [1215, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.FinMeasSupp.add", "code": "protected theorem add {\u03b2} [AddMonoid \u03b2] {f g : \u03b1 \u2192\u209b \u03b2} (hf : f.FinMeasSupp \u03bc)\n    (hg : g.FinMeasSupp \u03bc) : (f + g).FinMeasSupp \u03bc", "start": [1218, 1], "end": [1221, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.FinMeasSupp.mul", "code": "protected theorem mul {\u03b2} [MonoidWithZero \u03b2] {f g : \u03b1 \u2192\u209b \u03b2} (hf : f.FinMeasSupp \u03bc)\n    (hg : g.FinMeasSupp \u03bc) : (f * g).FinMeasSupp \u03bc", "start": [1224, 1], "end": [1227, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.FinMeasSupp.lintegral_lt_top", "code": "theorem lintegral_lt_top {f : \u03b1 \u2192\u209b \u211d\u22650\u221e} (hm : f.FinMeasSupp \u03bc) (hf : \u2200\u1d50 a \u2202\u03bc, f a \u2260 \u221e) :\n    f.lintegral \u03bc < \u221e", "start": [1230, 1], "end": [1239, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.FinMeasSupp.of_lintegral_ne_top", "code": "theorem of_lintegral_ne_top {f : \u03b1 \u2192\u209b \u211d\u22650\u221e} (h : f.lintegral \u03bc \u2260 \u221e) : f.FinMeasSupp \u03bc", "start": [1242, 1], "end": [1246, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.FinMeasSupp.iff_lintegral_lt_top", "code": "theorem iff_lintegral_lt_top {f : \u03b1 \u2192\u209b \u211d\u22650\u221e} (hf : \u2200\u1d50 a \u2202\u03bc, f a \u2260 \u221e) :\n    f.FinMeasSupp \u03bc \u2194 f.lintegral \u03bc < \u221e", "start": [1249, 1], "end": [1251, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.induction", "code": "@[elab_as_elim]\nprotected theorem induction {\u03b1 \u03b3} [MeasurableSpace \u03b1] [AddMonoid \u03b3] {P : SimpleFunc \u03b1 \u03b3 \u2192 Prop}\n    (h_ind :\n      \u2200 (c) {s} (hs : MeasurableSet s),\n        P (SimpleFunc.piecewise s hs (SimpleFunc.const _ c) (SimpleFunc.const _ 0)))\n    (h_add : \u2200 \u2983f g : SimpleFunc \u03b1 \u03b3\u2984, Disjoint (support f) (support g) \u2192 P f \u2192 P g \u2192 P (f + g))\n    (f : SimpleFunc \u03b1 \u03b3) : P f", "start": [1258, 1], "end": [1301, 71], "kind": "commanddeclaration"}, {"full_name": "Measurable.add_simpleFunc", "code": "theorem _root_.Measurable.add_simpleFunc\n    {E : Type*} {_ : MeasurableSpace \u03b1} [MeasurableSpace E] [AddGroup E] [MeasurableAdd E]\n    {g : \u03b1 \u2192 E} (hg : Measurable g) (f : SimpleFunc \u03b1 E) :\n    Measurable (g + (f : \u03b1 \u2192 E))", "start": [1304, 1], "end": [1327, 62], "kind": "commanddeclaration"}, {"full_name": "Measurable.simpleFunc_add", "code": "theorem _root_.Measurable.simpleFunc_add\n    {E : Type*} {_ : MeasurableSpace \u03b1} [MeasurableSpace E] [AddGroup E] [MeasurableAdd E]\n    {g : \u03b1 \u2192 E} (hg : Measurable g) (f : SimpleFunc \u03b1 E) :\n    Measurable ((f : \u03b1 \u2192 E) + g)", "start": [1329, 1], "end": [1352, 62], "kind": "commanddeclaration"}, {"full_name": "Measurable.ennreal_induction", "code": "@[elab_as_elim]\ntheorem Measurable.ennreal_induction {\u03b1} [MeasurableSpace \u03b1] {P : (\u03b1 \u2192 \u211d\u22650\u221e) \u2192 Prop}\n    (h_ind : \u2200 (c : \u211d\u22650\u221e) \u2983s\u2984, MeasurableSet s \u2192 P (Set.indicator s fun _ => c))\n    (h_add :\n      \u2200 \u2983f g : \u03b1 \u2192 \u211d\u22650\u221e\u2984,\n        Disjoint (support f) (support g) \u2192 Measurable f \u2192 Measurable g \u2192 P f \u2192 P g \u2192 P (f + g))\n    (h_iSup :\n      \u2200 \u2983f : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\u2984, (\u2200 n, Measurable (f n)) \u2192 Monotone f \u2192 (\u2200 n, P (f n)) \u2192\n        P fun x => \u2a06 n, f n x)\n    \u2983f : \u03b1 \u2192 \u211d\u22650\u221e\u2984 (hf : Measurable f) : P f", "start": [1360, 1], "end": [1383, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Dynamics/Ergodic/MeasurePreserving.lean", "imports": ["Mathlib/MeasureTheory/Measure/AEMeasurable.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.MeasurePreserving", "code": "structure MeasurePreserving (f : \u03b1 \u2192 \u03b2)\n  (\u03bca : Measure \u03b1 := by volume_tac) (\u03bcb : Measure \u03b2 := by volume_tac) : Prop where\n  protected measurable : Measurable f\n  protected map_eq : map f \u03bca = \u03bcb", "start": [40, 1], "end": [45, 35], "kind": "commanddeclaration"}, {"full_name": "Measurable.measurePreserving", "code": "protected theorem _root_.Measurable.measurePreserving\n    {f : \u03b1 \u2192 \u03b2} (h : Measurable f) (\u03bca : Measure \u03b1) : MeasurePreserving f \u03bca (map f \u03bca)", "start": [50, 1], "end": [52, 11], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.id", "code": "protected theorem id (\u03bc : Measure \u03b1) : MeasurePreserving id \u03bc \u03bc", "start": [57, 1], "end": [58, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.aemeasurable", "code": "protected theorem aemeasurable {f : \u03b1 \u2192 \u03b2} (hf : MeasurePreserving f \u03bca \u03bcb) : AEMeasurable f \u03bca", "start": [61, 1], "end": [62, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.of_isEmpty", "code": "@[nontriviality]\ntheorem of_isEmpty [IsEmpty \u03b2] (f : \u03b1 \u2192 \u03b2) (\u03bca : Measure \u03b1) (\u03bcb : Measure \u03b2) :\n    MeasurePreserving f \u03bca \u03bcb", "start": [65, 1], "end": [68, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.symm", "code": "theorem symm (e : \u03b1 \u2243\u1d50 \u03b2) {\u03bca : Measure \u03b1} {\u03bcb : Measure \u03b2} (h : MeasurePreserving e \u03bca \u03bcb) :\n    MeasurePreserving e.symm \u03bcb \u03bca", "start": [70, 1], "end": [73, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.restrict_preimage", "code": "theorem restrict_preimage {f : \u03b1 \u2192 \u03b2} (hf : MeasurePreserving f \u03bca \u03bcb) {s : Set \u03b2}\n    (hs : MeasurableSet s) : MeasurePreserving f (\u03bca.restrict (f \u207b\u00b9' s)) (\u03bcb.restrict s)", "start": [76, 1], "end": [78, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.restrict_preimage_emb", "code": "theorem restrict_preimage_emb {f : \u03b1 \u2192 \u03b2} (hf : MeasurePreserving f \u03bca \u03bcb)\n    (h\u2082 : MeasurableEmbedding f) (s : Set \u03b2) :\n    MeasurePreserving f (\u03bca.restrict (f \u207b\u00b9' s)) (\u03bcb.restrict s)", "start": [81, 1], "end": [84, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.restrict_image_emb", "code": "theorem restrict_image_emb {f : \u03b1 \u2192 \u03b2} (hf : MeasurePreserving f \u03bca \u03bcb) (h\u2082 : MeasurableEmbedding f)\n    (s : Set \u03b1) : MeasurePreserving f (\u03bca.restrict s) (\u03bcb.restrict (f '' s))", "start": [87, 1], "end": [89, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.aemeasurable_comp_iff", "code": "theorem aemeasurable_comp_iff {f : \u03b1 \u2192 \u03b2} (hf : MeasurePreserving f \u03bca \u03bcb)\n    (h\u2082 : MeasurableEmbedding f) {g : \u03b2 \u2192 \u03b3} : AEMeasurable (g \u2218 f) \u03bca \u2194 AEMeasurable g \u03bcb", "start": [92, 1], "end": [94, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.quasiMeasurePreserving", "code": "protected theorem quasiMeasurePreserving {f : \u03b1 \u2192 \u03b2} (hf : MeasurePreserving f \u03bca \u03bcb) :\n    QuasiMeasurePreserving f \u03bca \u03bcb", "start": [97, 1], "end": [99, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.comp", "code": "protected theorem comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : MeasurePreserving g \u03bcb \u03bcc)\n    (hf : MeasurePreserving f \u03bca \u03bcb) : MeasurePreserving (g \u2218 f) \u03bca \u03bcc", "start": [102, 1], "end": [104, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.comp_left_iff", "code": "protected theorem comp_left_iff {g : \u03b1 \u2192 \u03b2} {e : \u03b2 \u2243\u1d50 \u03b3} (h : MeasurePreserving e \u03bcb \u03bcc) :\n    MeasurePreserving (e \u2218 g) \u03bca \u03bcc \u2194 MeasurePreserving g \u03bca \u03bcb", "start": [107, 1], "end": [111, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.comp_right_iff", "code": "protected theorem comp_right_iff {g : \u03b1 \u2192 \u03b2} {e : \u03b3 \u2243\u1d50 \u03b1} (h : MeasurePreserving e \u03bcc \u03bca) :\n    MeasurePreserving (g \u2218 e) \u03bcc \u03bcb \u2194 MeasurePreserving g \u03bca \u03bcb", "start": [114, 1], "end": [118, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.sigmaFinite", "code": "protected theorem sigmaFinite {f : \u03b1 \u2192 \u03b2} (hf : MeasurePreserving f \u03bca \u03bcb) [SigmaFinite \u03bcb] :\n    SigmaFinite \u03bca", "start": [121, 1], "end": [123, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.measure_preimage", "code": "theorem measure_preimage {f : \u03b1 \u2192 \u03b2} (hf : MeasurePreserving f \u03bca \u03bcb) {s : Set \u03b2}\n    (hs : MeasurableSet s) : \u03bca (f \u207b\u00b9' s) = \u03bcb s", "start": [126, 1], "end": [127, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.measure_preimage_emb", "code": "theorem measure_preimage_emb {f : \u03b1 \u2192 \u03b2} (hf : MeasurePreserving f \u03bca \u03bcb)\n    (hfe : MeasurableEmbedding f) (s : Set \u03b2) : \u03bca (f \u207b\u00b9' s) = \u03bcb s", "start": [130, 1], "end": [132, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.iterate", "code": "protected theorem iterate {f : \u03b1 \u2192 \u03b1} (hf : MeasurePreserving f \u03bca \u03bca) :\n    \u2200 n, MeasurePreserving f^[n] \u03bca \u03bca", "start": [135, 1], "end": [138, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.measure_symmDiff_preimage_iterate_le", "code": "lemma measure_symmDiff_preimage_iterate_le\n    (hf : MeasurePreserving f \u03bc \u03bc) (hs : MeasurableSet s) (n : \u2115) :\n    \u03bc (s \u2206 (f^[n] \u207b\u00b9' s)) \u2264 n \u2022 \u03bc (s \u2206 (f \u207b\u00b9' s)) := by\n  induction' n with n ih; simp\n  simp only [add_smul, one_smul, \u2190 n.add_one]\n  refine' le_trans (measure_symmDiff_le s (f^[n] \u207b\u00b9' s) (f^[n+1] \u207b\u00b9' s)) (add_le_add ih _)\n  replace hs : MeasurableSet (s \u2206 (f \u207b\u00b9' s)) := hs.symmDiff $ hf.measurable hs\n  rw [iterate_succ', preimage_comp, \u2190 preimage_symmDiff, (hf.iterate n).measure_preimage hs]", "start": [143, 1], "end": [150, 93], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.MeasurePreserving.exists_mem_image_mem_of_volume_lt_mul_volume", "code": "theorem exists_mem_image_mem_of_volume_lt_mul_volume (hf : MeasurePreserving f \u03bc \u03bc)\n    (hs : MeasurableSet s) {n : \u2115} (hvol : \u03bc (Set.univ : Set \u03b1) < n * \u03bc s) :\n    \u2203 x \u2208 s, \u2203 m \u2208 Set.Ioo 0 n, f^[m] x \u2208 s", "start": [152, 1], "end": [167, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.exists_mem_image_mem", "code": "theorem exists_mem_image_mem [IsFiniteMeasure \u03bc] (hf : MeasurePreserving f \u03bc \u03bc)\n    (hs : MeasurableSet s) (hs' : \u03bc s \u2260 0) : \u2203 x \u2208 s, \u2203 (m : _) (_ : m \u2260 0), f^[m] x \u2208 s", "start": [170, 1], "end": [178, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurableEquiv.measurePreserving_symm", "code": "theorem measurePreserving_symm (\u03bc : Measure \u03b1) (e : \u03b1 \u2243\u1d50 \u03b2) :\n    MeasurePreserving e.symm (map e \u03bc) \u03bc", "start": [185, 1], "end": [187, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/Count.lean", "imports": ["Mathlib/MeasureTheory/Measure/Dirac.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.Measure.count", "code": "def count : Measure \u03b1 :=\n  sum dirac", "start": [27, 1], "end": [29, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_count_apply", "code": "theorem le_count_apply : \u2211' _ : s, (1 : \u211d\u22650\u221e) \u2264 count s", "start": [32, 1], "end": [36, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_apply", "code": "theorem count_apply (hs : MeasurableSet s) : count s = \u2211' i : s, 1", "start": [39, 1], "end": [40, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_empty", "code": "theorem count_empty : count (\u2205 : Set \u03b1) = 0", "start": [44, 1], "end": [44, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_apply_finset'", "code": "@[simp]\ntheorem count_apply_finset' {s : Finset \u03b1} (s_mble : MeasurableSet (s : Set \u03b1)) :\n    count (\u2191s : Set \u03b1) = s.card", "start": [47, 1], "end": [53, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_apply_finset", "code": "@[simp]\ntheorem count_apply_finset [MeasurableSingletonClass \u03b1] (s : Finset \u03b1) :\n    count (\u2191s : Set \u03b1) = s.card", "start": [57, 1], "end": [60, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_apply_finite'", "code": "theorem count_apply_finite' {s : Set \u03b1} (s_fin : s.Finite) (s_mble : MeasurableSet s) :\n    count s = s_fin.toFinset.card", "start": [63, 1], "end": [66, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_apply_finite", "code": "theorem count_apply_finite [MeasurableSingletonClass \u03b1] (s : Set \u03b1) (hs : s.Finite) :\n    count s = hs.toFinset.card", "start": [69, 1], "end": [70, 84], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_apply_infinite", "code": "theorem count_apply_infinite (hs : s.Infinite) : count s = \u221e", "start": [73, 1], "end": [81, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_apply_eq_top'", "code": "@[simp]\ntheorem count_apply_eq_top' (s_mble : MeasurableSet s) : count s = \u221e \u2194 s.Infinite", "start": [85, 1], "end": [90, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_apply_eq_top", "code": "@[simp]\ntheorem count_apply_eq_top [MeasurableSingletonClass \u03b1] : count s = \u221e \u2194 s.Infinite", "start": [93, 1], "end": [98, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_apply_lt_top'", "code": "@[simp]\ntheorem count_apply_lt_top' (s_mble : MeasurableSet s) : count s < \u221e \u2194 s.Finite", "start": [101, 1], "end": [106, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_apply_lt_top", "code": "@[simp]\ntheorem count_apply_lt_top [MeasurableSingletonClass \u03b1] : count s < \u221e \u2194 s.Finite", "start": [110, 1], "end": [115, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.empty_of_count_eq_zero'", "code": "theorem empty_of_count_eq_zero' (s_mble : MeasurableSet s) (hsc : count s = 0) : s = \u2205", "start": [119, 1], "end": [123, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.empty_of_count_eq_zero", "code": "theorem empty_of_count_eq_zero [MeasurableSingletonClass \u03b1] (hsc : count s = 0) : s = \u2205", "start": [126, 1], "end": [130, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_eq_zero_iff'", "code": "@[simp]\ntheorem count_eq_zero_iff' (s_mble : MeasurableSet s) : count s = 0 \u2194 s = \u2205", "start": [133, 1], "end": [135, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_eq_zero_iff", "code": "@[simp]\ntheorem count_eq_zero_iff [MeasurableSingletonClass \u03b1] : count s = 0 \u2194 s = \u2205", "start": [138, 1], "end": [140, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_ne_zero'", "code": "theorem count_ne_zero' (hs' : s.Nonempty) (s_mble : MeasurableSet s) : count s \u2260 0", "start": [143, 1], "end": [145, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_ne_zero", "code": "theorem count_ne_zero [MeasurableSingletonClass \u03b1] (hs' : s.Nonempty) : count s \u2260 0", "start": [148, 1], "end": [150, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_singleton'", "code": "@[simp]\ntheorem count_singleton' {a : \u03b1} (ha : MeasurableSet ({a} : Set \u03b1)) : count ({a} : Set \u03b1) = 1", "start": [153, 1], "end": [157, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_singleton", "code": "theorem count_singleton [MeasurableSingletonClass \u03b1] (a : \u03b1) : count ({a} : Set \u03b1) = 1", "start": [161, 1], "end": [162, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_injective_image'", "code": "theorem count_injective_image' {f : \u03b2 \u2192 \u03b1} (hf : Function.Injective f) {s : Set \u03b2}\n    (s_mble : MeasurableSet s) (fs_mble : MeasurableSet (f '' s)) : count (f '' s) = count s", "start": [165, 1], "end": [174, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count_injective_image", "code": "theorem count_injective_image [MeasurableSingletonClass \u03b1] [MeasurableSingletonClass \u03b2] {f : \u03b2 \u2192 \u03b1}\n    (hf : Function.Injective f) (s : Set \u03b2) : count (f '' s) = count s", "start": [177, 1], "end": [183, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.count.isFiniteMeasure", "code": "instance count.isFiniteMeasure [Finite \u03b1] [MeasurableSpace \u03b1] :\n    IsFiniteMeasure (Measure.count : Measure \u03b1) :=\n  \u27e8by\n    cases nonempty_fintype \u03b1\n    simpa [Measure.count_apply, tsum_fintype] using (ENNReal.nat_ne_top _).lt_top\u27e9", "start": [186, 1], "end": [190, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UrysohnsLemma.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Basic.lean", "Mathlib/LinearAlgebra/AffineSpace/Ordered.lean", "Mathlib/Analysis/NormedSpace/AddTorsor.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Urysohns.CU", "code": "structure CU (X : Type*) [TopologicalSpace X] where\n  protected (C U : Set X)\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C \u2286 U", "start": [81, 1], "end": [87, 27], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.left", "code": "@[simps C]\ndef left (c : CU X) : CU X where\n  C := c.C\n  U := (normal_exists_closure_subset c.closed_C c.open_U c.subset).choose\n  closed_C := c.closed_C\n  open_U := (normal_exists_closure_subset c.closed_C c.open_U c.subset).choose_spec.1\n  subset := (normal_exists_closure_subset c.closed_C c.open_U c.subset).choose_spec.2.1", "start": [97, 1], "end": [105, 88], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.right", "code": "@[simps U]\ndef right (c : CU X) : CU X where\n  C := closure (normal_exists_closure_subset c.closed_C c.open_U c.subset).choose\n  U := c.U\n  closed_C := isClosed_closure\n  open_U := c.open_U\n  subset := (normal_exists_closure_subset c.closed_C c.open_U c.subset).choose_spec.2.2", "start": [108, 1], "end": [116, 88], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.left_U_subset_right_C", "code": "theorem left_U_subset_right_C (c : CU X) : c.left.U \u2286 c.right.C", "start": [119, 1], "end": [120, 17], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.left_U_subset", "code": "theorem left_U_subset (c : CU X) : c.left.U \u2286 c.U", "start": [123, 1], "end": [124, 54], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.subset_right_C", "code": "theorem subset_right_C (c : CU X) : c.C \u2286 c.right.C", "start": [127, 1], "end": [128, 53], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.approx", "code": "noncomputable def approx : \u2115 \u2192 CU X \u2192 X \u2192 \u211d\n  | 0, c, x => indicator c.U\u1d9c 1 x\n  | n + 1, c, x => midpoint \u211d (approx n c.left x) (approx n c.right x)", "start": [131, 1], "end": [135, 71], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.approx_of_mem_C", "code": "theorem approx_of_mem_C (c : CU X) (n : \u2115) {x : X} (hx : x \u2208 c.C) : c.approx n x = 0", "start": [138, 1], "end": [143, 37], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.approx_of_nmem_U", "code": "theorem approx_of_nmem_U (c : CU X) (n : \u2115) {x : X} (hx : x \u2209 c.U) : c.approx n x = 1", "start": [146, 1], "end": [152, 52], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.approx_nonneg", "code": "theorem approx_nonneg (c : CU X) (n : \u2115) (x : X) : 0 \u2264 c.approx n x", "start": [155, 1], "end": [159, 81], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.approx_le_one", "code": "theorem approx_le_one (c : CU X) (n : \u2115) (x : X) : c.approx n x \u2264 1", "start": [162, 1], "end": [168, 48], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.bddAbove_range_approx", "code": "theorem bddAbove_range_approx (c : CU X) (x : X) : BddAbove (range fun n => c.approx n x)", "start": [171, 1], "end": [172, 49], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.approx_le_approx_of_U_sub_C", "code": "theorem approx_le_approx_of_U_sub_C {c\u2081 c\u2082 : CU X} (h : c\u2081.U \u2286 c\u2082.C) (n\u2081 n\u2082 : \u2115) (x : X) :\n    c\u2082.approx n\u2082 x \u2264 c\u2081.approx n\u2081 x", "start": [175, 1], "end": [183, 59], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.approx_mem_Icc_right_left", "code": "theorem approx_mem_Icc_right_left (c : CU X) (n : \u2115) (x : X) :\n    c.approx n x \u2208 Icc (c.right.approx n x) (c.left.approx n x)", "start": [186, 1], "end": [194, 44], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.approx_le_succ", "code": "theorem approx_le_succ (c : CU X) (n : \u2115) (x : X) : c.approx n x \u2264 c.approx (n + 1) x", "start": [197, 1], "end": [202, 47], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.approx_mono", "code": "theorem approx_mono (c : CU X) (x : X) : Monotone fun n => c.approx n x", "start": [205, 1], "end": [206, 56], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.lim", "code": "protected noncomputable def lim (c : CU X) (x : X) : \u211d :=\n  \u2a06 n, c.approx n x", "start": [209, 1], "end": [215, 20], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.tendsto_approx_atTop", "code": "theorem tendsto_approx_atTop (c : CU X) (x : X) :\n    Tendsto (fun n => c.approx n x) atTop (\ud835\udcdd <| c.lim x)", "start": [218, 1], "end": [220, 87], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.lim_of_mem_C", "code": "theorem lim_of_mem_C (c : CU X) (x : X) (h : x \u2208 c.C) : c.lim x = 0", "start": [223, 1], "end": [224, 54], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.lim_of_nmem_U", "code": "theorem lim_of_nmem_U (c : CU X) (x : X) (h : x \u2209 c.U) : c.lim x = 1", "start": [227, 1], "end": [228, 58], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.lim_eq_midpoint", "code": "theorem lim_eq_midpoint (c : CU X) (x : X) :\n    c.lim x = midpoint \u211d (c.left.lim x) (c.right.lim x)", "start": [231, 1], "end": [235, 82], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.approx_le_lim", "code": "theorem approx_le_lim (c : CU X) (x : X) (n : \u2115) : c.approx n x \u2264 c.lim x", "start": [238, 1], "end": [239, 41], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.lim_nonneg", "code": "theorem lim_nonneg (c : CU X) (x : X) : 0 \u2264 c.lim x", "start": [242, 1], "end": [243, 52], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.lim_le_one", "code": "theorem lim_le_one (c : CU X) (x : X) : c.lim x \u2264 1", "start": [246, 1], "end": [247, 40], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.lim_mem_Icc", "code": "theorem lim_mem_Icc (c : CU X) (x : X) : c.lim x \u2208 Icc (0 : \u211d) 1", "start": [250, 1], "end": [251, 35], "kind": "commanddeclaration"}, {"full_name": "Urysohns.CU.continuous_lim", "code": "theorem continuous_lim (c : CU X) : Continuous c.lim", "start": [254, 1], "end": [289, 37], "kind": "commanddeclaration"}, {"full_name": "exists_continuous_zero_one_of_closed", "code": "theorem exists_continuous_zero_one_of_closed {s t : Set X} (hs : IsClosed s) (ht : IsClosed t)\n    (hd : Disjoint s t) : \u2203 f : C(X, \u211d), EqOn f 0 s \u2227 EqOn f 1 t \u2227 \u2200 x, f x \u2208 Icc (0 : \u211d) 1", "start": [298, 1], "end": [310, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/ContinuousFunction/Bounded.lean", "imports": ["Mathlib/Analysis/Normed/Order/Lattice.lean", "Mathlib/Analysis/NormedSpace/OperatorNorm.lean", "Mathlib/Analysis/NormedSpace/Star/Basic.lean", "Mathlib/Topology/MetricSpace/Equicontinuity.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/ContinuousFunction/Algebra.lean", "Mathlib/Data/Real/Sqrt.lean"], "premises": [{"full_name": "BoundedContinuousFunction", "code": "structure BoundedContinuousFunction (\u03b1 : Type u) (\u03b2 : Type v) [TopologicalSpace \u03b1]\n    [PseudoMetricSpace \u03b2] extends ContinuousMap \u03b1 \u03b2 : Type max u v where\n  map_bounded' : \u2203 C, \u2200 x y, dist (toFun x) (toFun y) \u2264 C", "start": [34, 1], "end": [43, 58], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousMapClass", "code": "class BoundedContinuousMapClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [TopologicalSpace \u03b1]\n    [PseudoMetricSpace \u03b2] extends ContinuousMapClass F \u03b1 \u03b2 where\n  map_bounded (f : F) : \u2203 C, \u2200 x y, dist (f x) (f y) \u2264 C", "start": [52, 1], "end": [57, 57], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_to_continuous_fun", "code": "@[simp]\ntheorem coe_to_continuous_fun (f : \u03b1 \u2192\u1d47 \u03b2) : (f.toContinuousMap : \u03b1 \u2192 \u03b2) = f", "start": [92, 1], "end": [93, 84], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.Simps.apply", "code": "def Simps.apply (h : \u03b1 \u2192\u1d47 \u03b2) : \u03b1 \u2192 \u03b2 := h", "start": [96, 1], "end": [98, 42], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.bounded", "code": "protected theorem bounded (f : \u03b1 \u2192\u1d47 \u03b2) : \u2203 C, \u2200 x y : \u03b1, dist (f x) (f y) \u2264 C", "start": [103, 1], "end": [104, 17], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.continuous", "code": "protected theorem continuous (f : \u03b1 \u2192\u1d47 \u03b2) : Continuous f", "start": [107, 1], "end": [108, 31], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.ext", "code": "@[ext]\ntheorem ext (h : \u2200 x, f x = g x) : f = g", "start": [111, 1], "end": [113, 20], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.isBounded_range", "code": "theorem isBounded_range (f : \u03b1 \u2192\u1d47 \u03b2) : IsBounded (range f)", "start": [116, 1], "end": [117, 34], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.isBounded_image", "code": "theorem isBounded_image (f : \u03b1 \u2192\u1d47 \u03b2) (s : Set \u03b1) : IsBounded (f '' s)", "start": [120, 1], "end": [121, 53], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.eq_of_empty", "code": "theorem eq_of_empty [h : IsEmpty \u03b1] (f g : \u03b1 \u2192\u1d47 \u03b2) : f = g", "start": [124, 1], "end": [125, 16], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.mkOfBound", "code": "def mkOfBound (f : C(\u03b1, \u03b2)) (C : \u211d) (h : \u2200 x y : \u03b1, dist (f x) (f y) \u2264 C) : \u03b1 \u2192\u1d47 \u03b2 :=\n  \u27e8f, \u27e8C, h\u27e9\u27e9", "start": [128, 1], "end": [130, 14], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.mkOfBound_coe", "code": "@[simp]\ntheorem mkOfBound_coe {f} {C} {h} : (mkOfBound f C h : \u03b1 \u2192 \u03b2) = (f : \u03b1 \u2192 \u03b2)", "start": [133, 1], "end": [134, 83], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.mkOfCompact", "code": "def mkOfCompact [CompactSpace \u03b1] (f : C(\u03b1, \u03b2)) : \u03b1 \u2192\u1d47 \u03b2 :=\n  \u27e8f, isBounded_range_iff.1 (isCompact_range f.continuous).isBounded\u27e9", "start": [137, 1], "end": [139, 70], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.mkOfCompact_apply", "code": "@[simp]\ntheorem mkOfCompact_apply [CompactSpace \u03b1] (f : C(\u03b1, \u03b2)) (a : \u03b1) : mkOfCompact f a = f a", "start": [142, 1], "end": [143, 96], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.mkOfDiscrete", "code": "@[simps]\ndef mkOfDiscrete [DiscreteTopology \u03b1] (f : \u03b1 \u2192 \u03b2) (C : \u211d) (h : \u2200 x y : \u03b1, dist (f x) (f y) \u2264 C) :\n    \u03b1 \u2192\u1d47 \u03b2 :=\n  \u27e8\u27e8f, continuous_of_discreteTopology\u27e9, \u27e8C, h\u27e9\u27e9", "start": [146, 1], "end": [151, 48], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_eq", "code": "theorem dist_eq : dist f g = sInf { C | 0 \u2264 C \u2227 \u2200 x : \u03b1, dist (f x) (g x) \u2264 C }", "start": [158, 1], "end": [158, 87], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_set_exists", "code": "theorem dist_set_exists : \u2203 C, 0 \u2264 C \u2227 \u2200 x : \u03b1, dist (f x) (g x) \u2264 C", "start": [161, 1], "end": [165, 29], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_coe_le_dist", "code": "theorem dist_coe_le_dist (x : \u03b1) : dist (f x) (g x) \u2264 dist f g", "start": [168, 1], "end": [170, 46], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_nonneg'", "code": "private theorem dist_nonneg' : 0 \u2264 dist f g", "start": [176, 1], "end": [177, 45], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_le", "code": "theorem dist_le (C0 : (0 : \u211d) \u2264 C) : dist f g \u2264 C \u2194 \u2200 x : \u03b1, dist (f x) (g x) \u2264 C", "start": [179, 1], "end": [181, 97], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_le_iff_of_nonempty", "code": "theorem dist_le_iff_of_nonempty [Nonempty \u03b1] : dist f g \u2264 C \u2194 \u2200 x, dist (f x) (g x) \u2264 C", "start": [184, 1], "end": [186, 77], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_lt_of_nonempty_compact", "code": "theorem dist_lt_of_nonempty_compact [Nonempty \u03b1] [CompactSpace \u03b1]\n    (w : \u2200 x : \u03b1, dist (f x) (g x) < C) : dist f g < C", "start": [189, 1], "end": [194, 79], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_lt_iff_of_compact", "code": "theorem dist_lt_iff_of_compact [CompactSpace \u03b1] (C0 : (0 : \u211d) < C) :\n    dist f g < C \u2194 \u2200 x : \u03b1, dist (f x) (g x) < C", "start": [197, 1], "end": [208, 97], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_lt_iff_of_nonempty_compact", "code": "theorem dist_lt_iff_of_nonempty_compact [Nonempty \u03b1] [CompactSpace \u03b1] :\n    dist f g < C \u2194 \u2200 x : \u03b1, dist (f x) (g x) < C", "start": [211, 1], "end": [213, 82], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nndist_eq", "code": "theorem nndist_eq : nndist f g = sInf { C | \u2200 x : \u03b1, nndist (f x) (g x) \u2264 C }", "start": [231, 1], "end": [234, 81], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nndist_set_exists", "code": "theorem nndist_set_exists : \u2203 C, \u2200 x : \u03b1, nndist (f x) (g x) \u2264 C", "start": [237, 1], "end": [238, 69], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nndist_coe_le_nndist", "code": "theorem nndist_coe_le_nndist (x : \u03b1) : nndist (f x) (g x) \u2264 nndist f g", "start": [241, 1], "end": [242, 21], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_zero_of_empty", "code": "theorem dist_zero_of_empty [IsEmpty \u03b1] : dist f g = 0", "start": [245, 1], "end": [247, 44], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_eq_iSup", "code": "theorem dist_eq_iSup : dist f g = \u2a06 x : \u03b1, dist (f x) (g x)", "start": [250, 1], "end": [253, 64], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nndist_eq_iSup", "code": "theorem nndist_eq_iSup : nndist f g = \u2a06 x : \u03b1, nndist (f x) (g x)", "start": [256, 1], "end": [257, 85], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.tendsto_iff_tendstoUniformly", "code": "theorem tendsto_iff_tendstoUniformly {\u03b9 : Type*} {F : \u03b9 \u2192 \u03b1 \u2192\u1d47 \u03b2} {f : \u03b1 \u2192\u1d47 \u03b2} {l : Filter \u03b9} :\n    Tendsto F l (\ud835\udcdd f) \u2194 TendstoUniformly (fun i => F i) f l", "start": [260, 1], "end": [274, 34], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.inducing_coeFn", "code": "theorem inducing_coeFn : Inducing (UniformFun.ofFun \u2218 (\u21d1) : (\u03b1 \u2192\u1d47 \u03b2) \u2192 \u03b1 \u2192\u1d64 \u03b2)", "start": [277, 1], "end": [283, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.embedding_coeFn", "code": "theorem embedding_coeFn : Embedding (UniformFun.ofFun \u2218 (\u21d1) : (\u03b1 \u2192\u1d47 \u03b2) \u2192 \u03b1 \u2192\u1d64 \u03b2)", "start": [287, 1], "end": [288, 60], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.const", "code": "@[simps! (config := { fullyApplied := false })] def const (b : \u03b2) : \u03b1 \u2192\u1d47 \u03b2 :=\n  \u27e8ContinuousMap.const \u03b1 b, 0, by simp [le_rfl]\u27e9", "start": [293, 1], "end": [296, 49], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.const_apply'", "code": "theorem const_apply' (a : \u03b1) (b : \u03b2) : (const \u03b1 b : \u03b1 \u2192 \u03b2) a = b", "start": [301, 1], "end": [301, 72], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.lipschitz_evalx", "code": "theorem lipschitz_evalx (x : \u03b1) : LipschitzWith 1 fun f : \u03b1 \u2192\u1d47 \u03b2 => f x", "start": [308, 1], "end": [309, 53], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.uniformContinuous_coe", "code": "theorem uniformContinuous_coe : @UniformContinuous (\u03b1 \u2192\u1d47 \u03b2) (\u03b1 \u2192 \u03b2) _ _ (\u21d1)", "start": [312, 1], "end": [313, 72], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.continuous_coe", "code": "theorem continuous_coe : Continuous fun (f : \u03b1 \u2192\u1d47 \u03b2) x => f x", "start": [316, 1], "end": [317, 53], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.continuous_eval_const", "code": "@[continuity]\ntheorem continuous_eval_const {x : \u03b1} : Continuous fun f : \u03b1 \u2192\u1d47 \u03b2 => f x", "start": [320, 1], "end": [323, 43], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.continuous_eval", "code": "@[continuity]\ntheorem continuous_eval : Continuous fun p : (\u03b1 \u2192\u1d47 \u03b2) \u00d7 \u03b1 => p.1 p.2", "start": [326, 1], "end": [329, 93], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.compContinuous", "code": "def compContinuous {\u03b4 : Type*} [TopologicalSpace \u03b4] (f : \u03b1 \u2192\u1d47 \u03b2) (g : C(\u03b4, \u03b1)) : \u03b4 \u2192\u1d47 \u03b2 where\n  toContinuousMap := f.1.comp g\n  map_bounded' := f.map_bounded'.imp fun _ hC _ _ => hC _ _", "start": [368, 1], "end": [371, 60], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_compContinuous", "code": "@[simp]\ntheorem coe_compContinuous {\u03b4 : Type*} [TopologicalSpace \u03b4] (f : \u03b1 \u2192\u1d47 \u03b2) (g : C(\u03b4, \u03b1)) :\n    \u21d1(f.compContinuous g) = f \u2218 g", "start": [374, 1], "end": [376, 41], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.compContinuous_apply", "code": "@[simp]\ntheorem compContinuous_apply {\u03b4 : Type*} [TopologicalSpace \u03b4] (f : \u03b1 \u2192\u1d47 \u03b2) (g : C(\u03b4, \u03b1)) (x : \u03b4) :\n    f.compContinuous g x = f (g x)", "start": [379, 1], "end": [381, 42], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.lipschitz_compContinuous", "code": "theorem lipschitz_compContinuous {\u03b4 : Type*} [TopologicalSpace \u03b4] (g : C(\u03b4, \u03b1)) :\n    LipschitzWith 1 fun f : \u03b1 \u2192\u1d47 \u03b2 => f.compContinuous g", "start": [384, 1], "end": [386, 90], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.continuous_compContinuous", "code": "theorem continuous_compContinuous {\u03b4 : Type*} [TopologicalSpace \u03b4] (g : C(\u03b4, \u03b1)) :\n    Continuous fun f : \u03b1 \u2192\u1d47 \u03b2 => f.compContinuous g", "start": [389, 1], "end": [391, 42], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.restrict", "code": "def restrict (f : \u03b1 \u2192\u1d47 \u03b2) (s : Set \u03b1) : s \u2192\u1d47 \u03b2 :=\n  f.compContinuous <| (ContinuousMap.id _).restrict s", "start": [394, 1], "end": [396, 54], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_restrict", "code": "@[simp]\ntheorem coe_restrict (f : \u03b1 \u2192\u1d47 \u03b2) (s : Set \u03b1) : \u21d1(f.restrict s) = f \u2218 (\u2191)", "start": [399, 1], "end": [400, 81], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.restrict_apply", "code": "@[simp]\ntheorem restrict_apply (f : \u03b1 \u2192\u1d47 \u03b2) (s : Set \u03b1) (x : s) : f.restrict s x = f x", "start": [403, 1], "end": [404, 86], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.comp", "code": "def comp (G : \u03b2 \u2192 \u03b3) {C : \u211d\u22650} (H : LipschitzWith C G) (f : \u03b1 \u2192\u1d47 \u03b2) : \u03b1 \u2192\u1d47 \u03b3 :=\n  \u27e8\u27e8fun x => G (f x), H.continuous.comp f.continuous\u27e9,\n    let \u27e8D, hD\u27e9 := f.bounded\n    \u27e8max C 0 * D, fun x y =>\n      calc\n        dist (G (f x)) (G (f y)) \u2264 C * dist (f x) (f y) := H.dist_le_mul _ _\n        _ \u2264 max C 0 * dist (f x) (f y) := by gcongr; apply le_max_left\n        _ \u2264 max C 0 * D := by gcongr; apply hD\n        \u27e9\u27e9", "start": [407, 1], "end": [417, 11], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.lipschitz_comp", "code": "theorem lipschitz_comp {G : \u03b2 \u2192 \u03b3} {C : \u211d\u22650} (H : LipschitzWith C G) :\n    LipschitzWith C (comp G H : (\u03b1 \u2192\u1d47 \u03b2) \u2192 \u03b1 \u2192\u1d47 \u03b3)", "start": [420, 1], "end": [427, 62], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.uniformContinuous_comp", "code": "theorem uniformContinuous_comp {G : \u03b2 \u2192 \u03b3} {C : \u211d\u22650} (H : LipschitzWith C G) :\n    UniformContinuous (comp G H : (\u03b1 \u2192\u1d47 \u03b2) \u2192 \u03b1 \u2192\u1d47 \u03b3)", "start": [430, 1], "end": [433, 39], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.continuous_comp", "code": "theorem continuous_comp {G : \u03b2 \u2192 \u03b3} {C : \u211d\u22650} (H : LipschitzWith C G) :\n    Continuous (comp G H : (\u03b1 \u2192\u1d47 \u03b2) \u2192 \u03b1 \u2192\u1d47 \u03b3)", "start": [436, 1], "end": [439, 32], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.codRestrict", "code": "def codRestrict (s : Set \u03b2) (f : \u03b1 \u2192\u1d47 \u03b2) (H : \u2200 x, f x \u2208 s) : \u03b1 \u2192\u1d47 s :=\n  \u27e8\u27e8s.codRestrict f H, f.continuous.subtype_mk _\u27e9, f.bounded\u27e9", "start": [442, 1], "end": [444, 62], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.extend", "code": "nonrec def extend (f : \u03b1 \u21aa \u03b4) (g : \u03b1 \u2192\u1d47 \u03b2) (h : \u03b4 \u2192\u1d47 \u03b2) : \u03b4 \u2192\u1d47 \u03b2 where\n  toFun := extend f g h\n  continuous_toFun := continuous_of_discreteTopology\n  map_bounded' := by\n    rw [\u2190 isBounded_range_iff, range_extend f.injective]\n    exact g.isBounded_range.union (h.isBounded_image _)", "start": [451, 1], "end": [458, 56], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.extend_apply", "code": "@[simp]\ntheorem extend_apply (f : \u03b1 \u21aa \u03b4) (g : \u03b1 \u2192\u1d47 \u03b2) (h : \u03b4 \u2192\u1d47 \u03b2) (x : \u03b1) : extend f g h (f x) = g x", "start": [461, 1], "end": [463, 33], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.extend_comp", "code": "@[simp]\nnonrec theorem extend_comp (f : \u03b1 \u21aa \u03b4) (g : \u03b1 \u2192\u1d47 \u03b2) (h : \u03b4 \u2192\u1d47 \u03b2) : extend f g h \u2218 f = g", "start": [466, 1], "end": [468, 30], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.extend_apply'", "code": "nonrec theorem extend_apply' {f : \u03b1 \u21aa \u03b4} {x : \u03b4} (hx : x \u2209 range f) (g : \u03b1 \u2192\u1d47 \u03b2) (h : \u03b4 \u2192\u1d47 \u03b2) :\n    extend f g h x = h x", "start": [471, 1], "end": [473, 25], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.extend_of_empty", "code": "theorem extend_of_empty [IsEmpty \u03b1] (f : \u03b1 \u21aa \u03b4) (g : \u03b1 \u2192\u1d47 \u03b2) (h : \u03b4 \u2192\u1d47 \u03b2) : extend f g h = h", "start": [476, 1], "end": [477, 60], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_extend_extend", "code": "@[simp]\ntheorem dist_extend_extend (f : \u03b1 \u21aa \u03b4) (g\u2081 g\u2082 : \u03b1 \u2192\u1d47 \u03b2) (h\u2081 h\u2082 : \u03b4 \u2192\u1d47 \u03b2) :\n    dist (g\u2081.extend f h\u2081) (g\u2082.extend f h\u2082) =\n      max (dist g\u2081 g\u2082) (dist (h\u2081.restrict (range f)\u1d9c) (h\u2082.restrict (range f)\u1d9c))", "start": [480, 1], "end": [501, 34], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.isometry_extend", "code": "theorem isometry_extend (f : \u03b1 \u21aa \u03b4) (h : \u03b4 \u2192\u1d47 \u03b2) : Isometry fun g : \u03b1 \u2192\u1d47 \u03b2 => extend f g h", "start": [504, 1], "end": [505, 57], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.arzela_ascoli\u2081", "code": "theorem arzela_ascoli\u2081 [CompactSpace \u03b2] (A : Set (\u03b1 \u2192\u1d47 \u03b2)) (closed : IsClosed A)\n    (H : Equicontinuous ((\u2191) : A \u2192 \u03b1 \u2192 \u03b2)) : IsCompact A", "start": [522, 1], "end": [579, 45], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.arzela_ascoli\u2082", "code": "theorem arzela_ascoli\u2082 (s : Set \u03b2) (hs : IsCompact s) (A : Set (\u03b1 \u2192\u1d47 \u03b2)) (closed : IsClosed A)\n    (in_s : \u2200 (f : \u03b1 \u2192\u1d47 \u03b2) (x : \u03b1), f \u2208 A \u2192 f x \u2208 s) (H : Equicontinuous ((\u2191) : A \u2192 \u03b1 \u2192 \u03b2)) :\n    IsCompact A", "start": [582, 1], "end": [598, 23], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.arzela_ascoli", "code": "theorem arzela_ascoli [T2Space \u03b2] (s : Set \u03b2) (hs : IsCompact s) (A : Set (\u03b1 \u2192\u1d47 \u03b2))\n    (in_s : \u2200 (f : \u03b1 \u2192\u1d47 \u03b2) (x : \u03b1), f \u2208 A \u2192 f x \u2208 s) (H : Equicontinuous ((\u2191) : A \u2192 \u03b1 \u2192 \u03b2)) :\n    IsCompact (closure A)", "start": [601, 1], "end": [613, 32], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_one", "code": "@[to_additive (attr := simp)]\ntheorem coe_one : ((1 : \u03b1 \u2192\u1d47 \u03b2) : \u03b1 \u2192 \u03b2) = 1", "start": [626, 1], "end": [627, 52], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.mkOfCompact_one", "code": "@[to_additive (attr := simp)]\ntheorem mkOfCompact_one [CompactSpace \u03b1] : mkOfCompact (1 : C(\u03b1, \u03b2)) = 1", "start": [631, 1], "end": [632, 80], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.forall_coe_one_iff_one", "code": "@[to_additive]\ntheorem forall_coe_one_iff_one (f : \u03b1 \u2192\u1d47 \u03b2) : (\u2200 x, f x = 1) \u2194 f = 1", "start": [636, 1], "end": [638, 38], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.one_compContinuous", "code": "@[to_additive (attr := simp)]\ntheorem one_compContinuous [TopologicalSpace \u03b3] (f : C(\u03b3, \u03b1)) : (1 : \u03b1 \u2192\u1d47 \u03b2).compContinuous f = 1", "start": [642, 1], "end": [644, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_add", "code": "@[simp]\ntheorem coe_add : \u21d1(f + g) = f + g", "start": [682, 1], "end": [683, 42], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.add_apply", "code": "theorem add_apply : (f + g) x = f x + g x", "start": [686, 1], "end": [686, 49], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.mkOfCompact_add", "code": "@[simp]\ntheorem mkOfCompact_add [CompactSpace \u03b1] (f g : C(\u03b1, \u03b2)) :\n    mkOfCompact (f + g) = mkOfCompact f + mkOfCompact g", "start": [689, 1], "end": [691, 63], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.add_compContinuous", "code": "theorem add_compContinuous [TopologicalSpace \u03b3] (h : C(\u03b3, \u03b1)) :\n    (g + f).compContinuous h = g.compContinuous h + f.compContinuous h", "start": [694, 1], "end": [695, 78], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_nsmulRec", "code": "@[simp]\ntheorem coe_nsmulRec : \u2200 n, \u21d1(nsmulRec n f) = n \u2022 \u21d1f", "start": [698, 1], "end": [701, 67], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.hasNatScalar", "code": "instance hasNatScalar : SMul \u2115 (\u03b1 \u2192\u1d47 \u03b2) where\n  smul n f :=\n    { toContinuousMap := n \u2022 f.toContinuousMap\n      map_bounded' := by simpa [coe_nsmulRec] using (nsmulRec n f).map_bounded' }", "start": [704, 1], "end": [707, 82], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_nsmul", "code": "@[simp]\ntheorem coe_nsmul (r : \u2115) (f : \u03b1 \u2192\u1d47 \u03b2) : \u21d1(r \u2022 f) = r \u2022 \u21d1f", "start": [710, 1], "end": [711, 66], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nsmul_apply", "code": "@[simp]\ntheorem nsmul_apply (r : \u2115) (f : \u03b1 \u2192\u1d47 \u03b2) (v : \u03b1) : (r \u2022 f) v = r \u2022 f v", "start": [714, 1], "end": [715, 78], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.addMonoid", "code": "instance addMonoid : AddMonoid (\u03b1 \u2192\u1d47 \u03b2) :=\n  FunLike.coe_injective.addMonoid _ coe_zero coe_add fun _ _ => coe_nsmul _ _", "start": [718, 1], "end": [719, 78], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coeFnAddHom", "code": "@[simps]\ndef coeFnAddHom : (\u03b1 \u2192\u1d47 \u03b2) \u2192+ \u03b1 \u2192 \u03b2 where\n  toFun := (\u21d1)\n  map_zero' := coe_zero\n  map_add' := coe_add", "start": [733, 1], "end": [738, 22], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.toContinuousMapAddHom", "code": "@[simps]\ndef toContinuousMapAddHom : (\u03b1 \u2192\u1d47 \u03b2) \u2192+ C(\u03b1, \u03b2) where\n  toFun := toContinuousMap\n  map_zero' := rfl\n  map_add' := by\n    intros\n    ext\n    simp", "start": [743, 1], "end": [751, 9], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_sum", "code": "@[simp]\ntheorem coe_sum {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1 \u2192\u1d47 \u03b2) :\n    \u21d1(\u2211 i in s, f i) = \u2211 i in s, (f i : \u03b1 \u2192 \u03b2)", "start": [767, 1], "end": [770, 41], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.sum_apply", "code": "theorem sum_apply {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1 \u2192\u1d47 \u03b2) (a : \u03b1) :\n    (\u2211 i in s, f i) a = \u2211 i in s, f i a", "start": [773, 1], "end": [774, 51], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_def", "code": "theorem norm_def : \u2016f\u2016 = dist f 0", "start": [791, 1], "end": [791, 41], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_eq", "code": "theorem norm_eq (f : \u03b1 \u2192\u1d47 \u03b2) : \u2016f\u2016 = sInf { C : \u211d | 0 \u2264 C \u2227 \u2200 x : \u03b1, \u2016f x\u2016 \u2264 C }", "start": [794, 1], "end": [797, 53], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_eq_of_nonempty", "code": "theorem norm_eq_of_nonempty [h : Nonempty \u03b1] : \u2016f\u2016 = sInf { C : \u211d | \u2200 x : \u03b1, \u2016f x\u2016 \u2264 C }", "start": [800, 1], "end": [808, 54], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_eq_zero_of_empty", "code": "@[simp]\ntheorem norm_eq_zero_of_empty [IsEmpty \u03b1] : \u2016f\u2016 = 0", "start": [811, 1], "end": [813, 21], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_coe_le_norm", "code": "theorem norm_coe_le_norm (x : \u03b1) : \u2016f x\u2016 \u2264 \u2016f\u2016", "start": [816, 1], "end": [819, 34], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.neg_norm_le_apply", "code": "lemma neg_norm_le_apply (f : \u03b1 \u2192\u1d47 \u211d) (x : \u03b1) :\n    -\u2016f\u2016 \u2264 f x := (abs_le.mp (norm_coe_le_norm f x)).1", "start": [822, 1], "end": [823, 55], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedContinuousFunction.apply_le_norm", "code": "lemma apply_le_norm (f : \u03b1 \u2192\u1d47 \u211d) (x : \u03b1) :\n    f x \u2264 \u2016f\u2016 := (abs_le.mp (norm_coe_le_norm f x)).2", "start": [825, 1], "end": [826, 54], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedContinuousFunction.dist_le_two_norm'", "code": "theorem dist_le_two_norm' {f : \u03b3 \u2192 \u03b2} {C : \u211d} (hC : \u2200 x, \u2016f x\u2016 \u2264 C) (x y : \u03b3) :\n    dist (f x) (f y) \u2264 2 * C", "start": [828, 1], "end": [833, 34], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_le_two_norm", "code": "theorem dist_le_two_norm (x y : \u03b1) : dist (f x) (f y) \u2264 2 * \u2016f\u2016", "start": [836, 1], "end": [838, 43], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_le", "code": "theorem norm_le (C0 : (0 : \u211d) \u2264 C) : \u2016f\u2016 \u2264 C \u2194 \u2200 x : \u03b1, \u2016f x\u2016 \u2264 C", "start": [843, 1], "end": [845, 40], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_le_of_nonempty", "code": "theorem norm_le_of_nonempty [Nonempty \u03b1] {f : \u03b1 \u2192\u1d47 \u03b2} {M : \u211d} : \u2016f\u2016 \u2264 M \u2194 \u2200 x, \u2016f x\u2016 \u2264 M", "start": [848, 1], "end": [850, 32], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_lt_iff_of_compact", "code": "theorem norm_lt_iff_of_compact [CompactSpace \u03b1] {f : \u03b1 \u2192\u1d47 \u03b2} {M : \u211d} (M0 : 0 < M) :\n    \u2016f\u2016 < M \u2194 \u2200 x, \u2016f x\u2016 < M", "start": [853, 1], "end": [856, 34], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_lt_iff_of_nonempty_compact", "code": "theorem norm_lt_iff_of_nonempty_compact [Nonempty \u03b1] [CompactSpace \u03b1] {f : \u03b1 \u2192\u1d47 \u03b2} {M : \u211d} :\n    \u2016f\u2016 < M \u2194 \u2200 x, \u2016f x\u2016 < M", "start": [859, 1], "end": [862, 40], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_const_le", "code": "theorem norm_const_le (b : \u03b2) : \u2016const \u03b1 b\u2016 \u2264 \u2016b\u2016", "start": [867, 1], "end": [870, 46], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_const_eq", "code": "@[simp]\ntheorem norm_const_eq [h : Nonempty \u03b1] (b : \u03b2) : \u2016const \u03b1 b\u2016 = \u2016b\u2016", "start": [873, 1], "end": [875, 82], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.ofNormedAddCommGroup", "code": "def ofNormedAddCommGroup {\u03b1 : Type u} {\u03b2 : Type v} [TopologicalSpace \u03b1] [SeminormedAddCommGroup \u03b2]\n    (f : \u03b1 \u2192 \u03b2) (Hf : Continuous f) (C : \u211d) (H : \u2200 x, \u2016f x\u2016 \u2264 C) : \u03b1 \u2192\u1d47 \u03b2 :=\n  \u27e8\u27e8fun n => f n, Hf\u27e9, \u27e8_, dist_le_two_norm' H\u27e9\u27e9", "start": [878, 1], "end": [882, 49], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_ofNormedAddCommGroup", "code": "@[simp]\ntheorem coe_ofNormedAddCommGroup {\u03b1 : Type u} {\u03b2 : Type v} [TopologicalSpace \u03b1]\n    [SeminormedAddCommGroup \u03b2] (f : \u03b1 \u2192 \u03b2) (Hf : Continuous f) (C : \u211d) (H : \u2200 x, \u2016f x\u2016 \u2264 C) :\n    (ofNormedAddCommGroup f Hf C H : \u03b1 \u2192 \u03b2) = f", "start": [885, 1], "end": [888, 55], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_ofNormedAddCommGroup_le", "code": "theorem norm_ofNormedAddCommGroup_le {f : \u03b1 \u2192 \u03b2} (hfc : Continuous f) {C : \u211d} (hC : 0 \u2264 C)\n    (hfC : \u2200 x, \u2016f x\u2016 \u2264 C) : \u2016ofNormedAddCommGroup f hfc C hfC\u2016 \u2264 C", "start": [891, 1], "end": [893, 21], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.ofNormedAddCommGroupDiscrete", "code": "def ofNormedAddCommGroupDiscrete {\u03b1 : Type u} {\u03b2 : Type v} [TopologicalSpace \u03b1] [DiscreteTopology \u03b1]\n    [SeminormedAddCommGroup \u03b2] (f : \u03b1 \u2192 \u03b2) (C : \u211d) (H : \u2200 x, norm (f x) \u2264 C) : \u03b1 \u2192\u1d47 \u03b2 :=\n  ofNormedAddCommGroup f continuous_of_discreteTopology C H", "start": [896, 1], "end": [900, 60], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_ofNormedAddCommGroupDiscrete", "code": "@[simp]\ntheorem coe_ofNormedAddCommGroupDiscrete {\u03b1 : Type u} {\u03b2 : Type v} [TopologicalSpace \u03b1]\n    [DiscreteTopology \u03b1] [SeminormedAddCommGroup \u03b2] (f : \u03b1 \u2192 \u03b2) (C : \u211d) (H : \u2200 x, \u2016f x\u2016 \u2264 C) :\n    (ofNormedAddCommGroupDiscrete f C H : \u03b1 \u2192 \u03b2) = f", "start": [903, 1], "end": [906, 60], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.normComp", "code": "def normComp : \u03b1 \u2192\u1d47 \u211d :=\n  f.comp norm lipschitzWith_one_norm", "start": [909, 1], "end": [912, 37], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_normComp", "code": "@[simp]\ntheorem coe_normComp : (f.normComp : \u03b1 \u2192 \u211d) = norm \u2218 f", "start": [915, 1], "end": [916, 62], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_normComp", "code": "@[simp]\ntheorem norm_normComp : \u2016f.normComp\u2016 = \u2016f\u2016", "start": [919, 1], "end": [921, 62], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.bddAbove_range_norm_comp", "code": "theorem bddAbove_range_norm_comp : BddAbove <| Set.range <| norm \u2218 f", "start": [924, 1], "end": [925, 85], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_eq_iSup_norm", "code": "theorem norm_eq_iSup_norm : \u2016f\u2016 = \u2a06 x : \u03b1, \u2016f x\u2016", "start": [928, 1], "end": [929, 77], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_neg", "code": "@[simp]\ntheorem coe_neg : \u21d1(-f) = -f", "start": [950, 1], "end": [951, 36], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.neg_apply", "code": "theorem neg_apply : (-f) x = -f x", "start": [954, 1], "end": [954, 41], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_sub", "code": "@[simp]\ntheorem coe_sub : \u21d1(f - g) = f - g", "start": [957, 1], "end": [958, 42], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.sub_apply", "code": "theorem sub_apply : (f - g) x = f x - g x", "start": [961, 1], "end": [961, 49], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.mkOfCompact_neg", "code": "@[simp]\ntheorem mkOfCompact_neg [CompactSpace \u03b1] (f : C(\u03b1, \u03b2)) : mkOfCompact (-f) = -mkOfCompact f", "start": [964, 1], "end": [965, 98], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.mkOfCompact_sub", "code": "@[simp]\ntheorem mkOfCompact_sub [CompactSpace \u03b1] (f g : C(\u03b1, \u03b2)) :\n    mkOfCompact (f - g) = mkOfCompact f - mkOfCompact g", "start": [968, 1], "end": [970, 63], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_zsmulRec", "code": "@[simp]\ntheorem coe_zsmulRec : \u2200 z, \u21d1(zsmulRec z f) = z \u2022 \u21d1f", "start": [973, 1], "end": [976, 76], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.hasIntScalar", "code": "instance hasIntScalar : SMul \u2124 (\u03b1 \u2192\u1d47 \u03b2) where\n  smul n f :=\n    { toContinuousMap := n \u2022 f.toContinuousMap\n      map_bounded' := by simpa using (zsmulRec n f).map_bounded' }", "start": [979, 1], "end": [982, 67], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_zsmul", "code": "@[simp]\ntheorem coe_zsmul (r : \u2124) (f : \u03b1 \u2192\u1d47 \u03b2) : \u21d1(r \u2022 f) = r \u2022 \u21d1f", "start": [985, 1], "end": [986, 66], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.zsmul_apply", "code": "@[simp]\ntheorem zsmul_apply (r : \u2124) (f : \u03b1 \u2192\u1d47 \u03b2) (v : \u03b1) : (r \u2022 f) v = r \u2022 f v", "start": [989, 1], "end": [990, 78], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.seminormedAddCommGroup", "code": "instance seminormedAddCommGroup : SeminormedAddCommGroup (\u03b1 \u2192\u1d47 \u03b2) where\n  dist_eq f g := by simp only [norm_eq, dist_eq, dist_eq_norm, sub_apply]", "start": [997, 1], "end": [998, 74], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.normedAddCommGroup", "code": "instance normedAddCommGroup {\u03b1 \u03b2} [TopologicalSpace \u03b1] [NormedAddCommGroup \u03b2] :\n    NormedAddCommGroup (\u03b1 \u2192\u1d47 \u03b2) :=\n  { BoundedContinuousFunction.seminormedAddCommGroup with\n    eq_of_dist_eq_zero }", "start": [1000, 1], "end": [1004, 25], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nnnorm_def", "code": "theorem nnnorm_def : \u2016f\u2016\u208a = nndist f 0", "start": [1006, 1], "end": [1006, 46], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nnnorm_coe_le_nnnorm", "code": "theorem nnnorm_coe_le_nnnorm (x : \u03b1) : \u2016f x\u2016\u208a \u2264 \u2016f\u2016\u208a", "start": [1009, 1], "end": [1010, 23], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nndist_le_two_nnnorm", "code": "theorem nndist_le_two_nnnorm (x y : \u03b1) : nndist (f x) (f y) \u2264 2 * \u2016f\u2016\u208a", "start": [1013, 1], "end": [1014, 25], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nnnorm_le", "code": "theorem nnnorm_le (C : \u211d\u22650) : \u2016f\u2016\u208a \u2264 C \u2194 \u2200 x : \u03b1, \u2016f x\u2016\u208a \u2264 C", "start": [1017, 1], "end": [1019, 17], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nnnorm_const_le", "code": "theorem nnnorm_const_le (b : \u03b2) : \u2016const \u03b1 b\u2016\u208a \u2264 \u2016b\u2016\u208a", "start": [1022, 1], "end": [1023, 18], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nnnorm_const_eq", "code": "@[simp]\ntheorem nnnorm_const_eq [Nonempty \u03b1] (b : \u03b2) : \u2016const \u03b1 b\u2016\u208a = \u2016b\u2016\u208a", "start": [1026, 1], "end": [1028, 33], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nnnorm_eq_iSup_nnnorm", "code": "theorem nnnorm_eq_iSup_nnnorm : \u2016f\u2016\u208a = \u2a06 x : \u03b1, \u2016f x\u2016\u208a", "start": [1031, 1], "end": [1032, 101], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.abs_diff_coe_le_dist", "code": "theorem abs_diff_coe_le_dist : \u2016f x - g x\u2016 \u2264 dist f g", "start": [1035, 1], "end": [1037, 35], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_le_coe_add_dist", "code": "theorem coe_le_coe_add_dist {f g : \u03b1 \u2192\u1d47 \u211d} : f x \u2264 g x + dist f g", "start": [1040, 1], "end": [1041, 74], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_compContinuous_le", "code": "theorem norm_compContinuous_le [TopologicalSpace \u03b3] (f : \u03b1 \u2192\u1d47 \u03b2) (g : C(\u03b3, \u03b1)) :\n    \u2016f.compContinuous g\u2016 \u2264 \u2016f\u2016", "start": [1044, 1], "end": [1047, 50], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_smul", "code": "@[simp]\ntheorem coe_smul (c : \ud835\udd5c) (f : \u03b1 \u2192\u1d47 \u03b2) : \u21d1(c \u2022 f) = fun x => c \u2022 f x", "start": [1080, 1], "end": [1081, 75], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.smul_apply", "code": "theorem smul_apply (c : \ud835\udd5c) (f : \u03b1 \u2192\u1d47 \u03b2) (x : \u03b1) : (c \u2022 f) x = c \u2022 f x", "start": [1084, 1], "end": [1084, 77], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.module", "code": "instance module : Module \ud835\udd5c (\u03b1 \u2192\u1d47 \u03b2) :=\n  Function.Injective.module _ \u27e8\u27e8_, coe_zero\u27e9, coe_add\u27e9 FunLike.coe_injective coe_smul", "start": [1134, 1], "end": [1135, 86], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.evalClm", "code": "def evalClm (x : \u03b1) : (\u03b1 \u2192\u1d47 \u03b2) \u2192L[\ud835\udd5c] \u03b2 where\n  toFun f := f x\n  map_add' f g := add_apply _ _\n  map_smul' c f := smul_apply _ _ _", "start": [1139, 1], "end": [1143, 36], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.evalClm_apply", "code": "@[simp]\ntheorem evalClm_apply (x : \u03b1) (f : \u03b1 \u2192\u1d47 \u03b2) : evalClm \ud835\udd5c x f = f x", "start": [1146, 1], "end": [1147, 72], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.toContinuousMapLinearMap", "code": "@[simps]\ndef toContinuousMapLinearMap : (\u03b1 \u2192\u1d47 \u03b2) \u2192\u2097[\ud835\udd5c] C(\u03b1, \u03b2) where\n  toFun := toContinuousMap\n  map_smul' _ _ := rfl\n  map_add' _ _ := rfl", "start": [1152, 1], "end": [1157, 22], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.normedSpace", "code": "instance normedSpace [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c \u03b2] : NormedSpace \ud835\udd5c (\u03b1 \u2192\u1d47 \u03b2) :=\n  \u27e8fun c f => by\n    refine' norm_ofNormedAddCommGroup_le _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) _\n    exact fun x =>\n      norm_smul c (f x) \u25b8 mul_le_mul_of_nonneg_left (f.norm_coe_le_norm _) (norm_nonneg _)\u27e9", "start": [1180, 1], "end": [1184, 92], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compLeftContinuousBounded", "code": "protected def _root_.ContinuousLinearMap.compLeftContinuousBounded (g : \u03b2 \u2192L[\ud835\udd5c] \u03b3) :\n    (\u03b1 \u2192\u1d47 \u03b2) \u2192L[\ud835\udd5c] \u03b1 \u2192\u1d47 \u03b3 :=\n  LinearMap.mkContinuous\n    { toFun := fun f =>\n        ofNormedAddCommGroup (g \u2218 f) (g.continuous.comp f.continuous) (\u2016g\u2016 * \u2016f\u2016) fun x =>\n          g.le_op_norm_of_le (f.norm_coe_le_norm x)\n      map_add' := fun f g => by ext; simp\n      map_smul' := fun c f => by ext; simp } \u2016g\u2016 fun f =>\n        norm_ofNormedAddCommGroup_le _ (mul_nonneg (norm_nonneg g) (norm_nonneg f))\n          (fun x => by exact g.le_op_norm_of_le (f.norm_coe_le_norm x))", "start": [1193, 1], "end": [1205, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compLeftContinuousBounded_apply", "code": "@[simp]\ntheorem _root_.ContinuousLinearMap.compLeftContinuousBounded_apply (g : \u03b2 \u2192L[\ud835\udd5c] \u03b3) (f : \u03b1 \u2192\u1d47 \u03b2)\n    (x : \u03b1) : (g.compLeftContinuousBounded \u03b1 f) x = g (f x)", "start": [1208, 1], "end": [1210, 67], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_mul", "code": "@[simp]\ntheorem coe_mul (f g : \u03b1 \u2192\u1d47 R) : \u21d1(f * g) = f * g", "start": [1239, 1], "end": [1240, 57], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.mul_apply", "code": "theorem mul_apply (f g : \u03b1 \u2192\u1d47 R) (x : \u03b1) : (f * g) x = f x * g x", "start": [1243, 1], "end": [1243, 72], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nonUnitalSeminormedRing", "code": "instance nonUnitalSeminormedRing : NonUnitalSeminormedRing (\u03b1 \u2192\u1d47 R) :=\n  { BoundedContinuousFunction.seminormedAddCommGroup with\n    norm_mul := fun _ _ =>\n      norm_ofNormedAddCommGroup_le _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) _\n    left_distrib, right_distrib, zero_mul, mul_zero, mul_assoc }", "start": [1250, 1], "end": [1255, 65], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nonUnitalNormedRing", "code": "instance nonUnitalNormedRing [NonUnitalNormedRing R] : NonUnitalNormedRing (\u03b1 \u2192\u1d47 R) :=\n  { BoundedContinuousFunction.nonUnitalSeminormedRing,\n    BoundedContinuousFunction.normedAddCommGroup with }", "start": [1259, 1], "end": [1261, 56], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_npowRec", "code": "@[simp]\ntheorem coe_npowRec (f : \u03b1 \u2192\u1d47 R) : \u2200 n, \u21d1(npowRec n f) = (\u21d1f) ^ n", "start": [1269, 1], "end": [1272, 65], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.hasNatPow", "code": "instance hasNatPow : Pow (\u03b1 \u2192\u1d47 R) \u2115 where\n  pow f n :=\n    { toContinuousMap := f.toContinuousMap ^ n\n      map_bounded' := by simpa [coe_npowRec] using (npowRec n f).map_bounded' }", "start": [1275, 1], "end": [1278, 80], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_pow", "code": "@[simp]\ntheorem coe_pow (n : \u2115) (f : \u03b1 \u2192\u1d47 R) : \u21d1(f ^ n) = (\u21d1f) ^ n", "start": [1281, 1], "end": [1282, 66], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.pow_apply", "code": "@[simp]\ntheorem pow_apply (n : \u2115) (f : \u03b1 \u2192\u1d47 R) (v : \u03b1) : (f ^ n) v = f v ^ n", "start": [1285, 1], "end": [1286, 76], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_natCast", "code": "@[simp, norm_cast]\ntheorem coe_natCast (n : \u2115) : ((n : \u03b1 \u2192\u1d47 R) : \u03b1 \u2192 R) = n", "start": [1292, 1], "end": [1293, 64], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_intCast", "code": "@[simp, norm_cast]\ntheorem coe_intCast (n : \u2124) : ((n : \u03b1 \u2192\u1d47 R) : \u03b1 \u2192 R) = n", "start": [1299, 1], "end": [1300, 64], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.ring", "code": "instance ring : Ring (\u03b1 \u2192\u1d47 R) :=\n  FunLike.coe_injective.ring _ coe_zero coe_one coe_add coe_mul coe_neg coe_sub\n    (fun _ _ => coe_nsmul _ _) (fun _ _ => coe_zsmul _ _) (fun _ _ => coe_pow _ _) coe_natCast\n    coe_intCast", "start": [1303, 1], "end": [1306, 16], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.commRing", "code": "instance commRing [SeminormedCommRing R] : CommRing (\u03b1 \u2192\u1d47 R) :=\n  { BoundedContinuousFunction.ring with\n    mul_comm := fun _ _ => ext fun _ => mul_comm _ _ }", "start": [1332, 1], "end": [1334, 55], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.C", "code": "def C : \ud835\udd5c \u2192+* \u03b1 \u2192\u1d47 \u03b3 where\n  toFun := fun c : \ud835\udd5c => const \u03b1 ((algebraMap \ud835\udd5c \u03b3) c)\n  map_one' := ext fun _ => (algebraMap \ud835\udd5c \u03b3).map_one\n  map_mul' _ _ := ext fun _ => (algebraMap \ud835\udd5c \u03b3).map_mul _ _\n  map_zero' := ext fun _ => (algebraMap \ud835\udd5c \u03b3).map_zero\n  map_add' _ _ := ext fun _ => (algebraMap \ud835\udd5c \u03b3).map_add _ _", "start": [1366, 1], "end": [1372, 60], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.algebra", "code": "instance algebra : Algebra \ud835\udd5c (\u03b1 \u2192\u1d47 \u03b3) :=\n  { BoundedContinuousFunction.module,\n    BoundedContinuousFunction.ring (\u03b1 := \u03b1) (R := \u03b3) with\n    toRingHom := C\n    commutes' := fun _ _ => ext fun _ => Algebra.commutes' _ _\n    smul_def' := fun _ _ => ext fun _ => Algebra.smul_def' _ _ }", "start": [1377, 1], "end": [1382, 65], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.algebraMap_apply", "code": "@[simp]\ntheorem algebraMap_apply (k : \ud835\udd5c) (a : \u03b1) : algebraMap \ud835\udd5c (\u03b1 \u2192\u1d47 \u03b3) k a = k \u2022 (1 : \u03b3)", "start": [1385, 1], "end": [1388, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.hasSmul'", "code": "instance hasSmul' : SMul (\u03b1 \u2192\u1d47 \ud835\udd5c) (\u03b1 \u2192\u1d47 \u03b2) :=\n  \u27e8fun (f : \u03b1 \u2192\u1d47 \ud835\udd5c) (g : \u03b1 \u2192\u1d47 \u03b2) =>\n    ofNormedAddCommGroup (fun x => f x \u2022 g x) (f.continuous.smul g.continuous) (\u2016f\u2016 * \u2016g\u2016) fun x =>\n      calc\n        \u2016f x \u2022 g x\u2016 \u2264 \u2016f x\u2016 * \u2016g x\u2016 := norm_smul_le _ _\n        _ \u2264 \u2016f\u2016 * \u2016g\u2016 :=\n          mul_le_mul (f.norm_coe_le_norm _) (g.norm_coe_le_norm _) (norm_nonneg _) (norm_nonneg _)\n        \u27e9", "start": [1404, 1], "end": [1411, 10], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.module'", "code": "instance module' : Module (\u03b1 \u2192\u1d47 \ud835\udd5c) (\u03b1 \u2192\u1d47 \u03b2) :=\n  Module.ofCore <|\n    { smul := (\u00b7 \u2022 \u00b7)\n      smul_add := fun _ _ _ => ext fun _ => smul_add _ _ _\n      add_smul := fun _ _ _ => ext fun _ => add_smul _ _ _\n      mul_smul := fun _ _ _ => ext fun _ => mul_smul _ _ _\n      one_smul := fun f => ext fun x => one_smul \ud835\udd5c (f x) }", "start": [1414, 1], "end": [1420, 59], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_smul_le", "code": "theorem norm_smul_le (f : \u03b1 \u2192\u1d47 \ud835\udd5c) (g : \u03b1 \u2192\u1d47 \u03b2) : \u2016f \u2022 g\u2016 \u2264 \u2016f\u2016 * \u2016g\u2016", "start": [1423, 1], "end": [1424, 80], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.NNReal.upper_bound", "code": "theorem NNReal.upper_bound {\u03b1 : Type*} [TopologicalSpace \u03b1] (f : \u03b1 \u2192\u1d47 \u211d\u22650) (x : \u03b1) :\n    f x \u2264 nndist f 0", "start": [1432, 1], "end": [1436, 48], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.starAddMonoid", "code": "instance starAddMonoid : StarAddMonoid (\u03b1 \u2192\u1d47 \u03b2) where\n  star f := f.comp star starNormedAddGroupHom.lipschitz\n  star_involutive f := ext fun x => star_star (f x)\n  star_add f g := ext fun x => star_add (f x) (g x)", "start": [1464, 1], "end": [1467, 52], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coe_star", "code": "@[simp]\ntheorem coe_star (f : \u03b1 \u2192\u1d47 \u03b2) : \u21d1(star f) = star (\u21d1f)", "start": [1469, 1], "end": [1472, 61], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.star_apply", "code": "@[simp]\ntheorem star_apply (f : \u03b1 \u2192\u1d47 \u03b2) (x : \u03b1) : star f x = star (f x)", "start": [1475, 1], "end": [1476, 71], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.partialOrder", "code": "instance partialOrder : PartialOrder (\u03b1 \u2192\u1d47 \u03b2) :=\n  PartialOrder.lift (fun f => f.toFun) (by simp [Injective])", "start": [1521, 1], "end": [1522, 61], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.semilatticeInf", "code": "instance semilatticeInf : SemilatticeInf (\u03b1 \u2192\u1d47 \u03b2) :=\n  { BoundedContinuousFunction.partialOrder with\n    inf := fun f g =>\n      { toFun := fun t => f t \u2293 g t\n        continuous_toFun := f.continuous.inf g.continuous\n        map_bounded' := by\n          obtain \u27e8C\u2081, hf\u27e9 := f.bounded\n          obtain \u27e8C\u2082, hg\u27e9 := g.bounded\n          refine' \u27e8C\u2081 + C\u2082, fun x y => _\u27e9\n          simp_rw [NormedAddCommGroup.dist_eq] at hf hg \u22a2\n          exact (norm_inf_sub_inf_le_add_norm _ _ _ _).trans (add_le_add (hf _ _) (hg _ _)) }\n    inf_le_left := fun f g => ContinuousMap.le_def.mpr fun _ => inf_le_left\n    inf_le_right := fun f g => ContinuousMap.le_def.mpr fun _ => inf_le_right\n    le_inf := fun f g\u2081 g\u2082 w\u2081 w\u2082 =>\n      ContinuousMap.le_def.mpr fun _ =>\n        le_inf (ContinuousMap.le_def.mp w\u2081 _) (ContinuousMap.le_def.mp w\u2082 _) }", "start": [1524, 1], "end": [1540, 79], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.semilatticeSup", "code": "instance semilatticeSup : SemilatticeSup (\u03b1 \u2192\u1d47 \u03b2) :=\n  { BoundedContinuousFunction.partialOrder with\n    sup := fun f g =>\n      { toFun := fun t => f t \u2294 g t\n        continuous_toFun := f.continuous.sup g.continuous\n        map_bounded' := by\n          obtain \u27e8C\u2081, hf\u27e9 := f.bounded\n          obtain \u27e8C\u2082, hg\u27e9 := g.bounded\n          refine' \u27e8C\u2081 + C\u2082, fun x y => _\u27e9\n          simp_rw [NormedAddCommGroup.dist_eq] at hf hg \u22a2\n          exact (norm_sup_sub_sup_le_add_norm _ _ _ _).trans (add_le_add (hf _ _) (hg _ _)) }\n    le_sup_left := fun f g => ContinuousMap.le_def.mpr fun _ => le_sup_left\n    le_sup_right := fun f g => ContinuousMap.le_def.mpr fun _ => le_sup_right\n    sup_le := fun f g\u2081 g\u2082 w\u2081 w\u2082 =>\n      ContinuousMap.le_def.mpr fun _ =>\n        sup_le (ContinuousMap.le_def.mp w\u2081 _) (ContinuousMap.le_def.mp w\u2082 _) }", "start": [1542, 1], "end": [1557, 79], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.lattice", "code": "instance lattice : Lattice (\u03b1 \u2192\u1d47 \u03b2) :=\n  { BoundedContinuousFunction.semilatticeSup, BoundedContinuousFunction.semilatticeInf with }", "start": [1559, 1], "end": [1560, 94], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coeFn_sup", "code": "@[simp]\ntheorem coeFn_sup (f g : \u03b1 \u2192\u1d47 \u03b2) : \u21d1(f \u2294 g) = \u21d1f \u2294 \u21d1g", "start": [1562, 1], "end": [1563, 61], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coeFn_abs", "code": "@[simp]\ntheorem coeFn_abs (f : \u03b1 \u2192\u1d47 \u03b2) : \u21d1|f| = |\u21d1f|", "start": [1566, 1], "end": [1567, 52], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nnrealPart", "code": "def nnrealPart (f : \u03b1 \u2192\u1d47 \u211d) : \u03b1 \u2192\u1d47 \u211d\u22650 :=\n  BoundedContinuousFunction.comp _ (show LipschitzWith 1 Real.toNNReal from lipschitzWith_pos) f", "start": [1592, 1], "end": [1595, 97], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nnrealPart_coeFn_eq", "code": "@[simp]\ntheorem nnrealPart_coeFn_eq (f : \u03b1 \u2192\u1d47 \u211d) : \u21d1f.nnrealPart = Real.toNNReal \u2218 \u21d1f", "start": [1598, 1], "end": [1599, 85], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nnnorm", "code": "def nnnorm (f : \u03b1 \u2192\u1d47 \u211d) : \u03b1 \u2192\u1d47 \u211d\u22650 :=\n  BoundedContinuousFunction.comp _\n    (show LipschitzWith 1 fun x : \u211d => \u2016x\u2016\u208a from lipschitzWith_one_norm) f", "start": [1602, 1], "end": [1606, 75], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.nnnorm_coeFn_eq", "code": "@[simp]\ntheorem nnnorm_coeFn_eq (f : \u03b1 \u2192\u1d47 \u211d) : \u21d1f.nnnorm = NNNorm.nnnorm \u2218 \u21d1f", "start": [1609, 1], "end": [1610, 77], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.self_eq_nnrealPart_sub_nnrealPart_neg", "code": "theorem self_eq_nnrealPart_sub_nnrealPart_neg (f : \u03b1 \u2192\u1d47 \u211d) :\n    \u21d1f = (\u2191) \u2218 f.nnrealPart - (\u2191) \u2218 (-f).nnrealPart", "start": [1613, 1], "end": [1618, 48], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.abs_self_eq_nnrealPart_add_nnrealPart_neg", "code": "theorem abs_self_eq_nnrealPart_add_nnrealPart_neg (f : \u03b1 \u2192\u1d47 \u211d) :\n    abs \u2218 \u21d1f = (\u2191) \u2218 f.nnrealPart + (\u2191) \u2218 (-f).nnrealPart", "start": [1621, 1], "end": [1627, 52], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.add_norm_nonneg", "code": "lemma add_norm_nonneg (f : \u03b1 \u2192\u1d47 \u211d) :\n    0 \u2264 f + const _ \u2016f\u2016 := by\n  intro x\n  dsimp\n  linarith [(abs_le.mp (norm_coe_le_norm f x)).1]", "start": [1636, 1], "end": [1640, 50], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedContinuousFunction.norm_sub_nonneg", "code": "lemma norm_sub_nonneg (f : \u03b1 \u2192\u1d47 \u211d) :\n    0 \u2264 const _ \u2016f\u2016 - f := by\n  intro x\n  dsimp\n  linarith [(abs_le.mp (norm_coe_le_norm f x)).2]", "start": [1642, 1], "end": [1646, 50], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Topology/Algebra/Ring/Ideal.lean", "imports": ["Mathlib/Topology/Algebra/Ring/Basic.lean", "Mathlib/RingTheory/Ideal/Quotient.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ideal.closure", "code": "protected def Ideal.closure (I : Ideal R) : Ideal R :=\n  {\n    AddSubmonoid.topologicalClosure\n      I.toAddSubmonoid with\n    carrier := closure I\n    smul_mem' := fun c _ hx => map_mem_closure (mulLeft_continuous _) hx fun _ => I.mul_mem_left c }", "start": [24, 1], "end": [30, 101], "kind": "commanddeclaration"}, {"full_name": "Ideal.coe_closure", "code": "@[simp]\ntheorem Ideal.coe_closure (I : Ideal R) : (I.closure : Set R) = closure I", "start": [33, 1], "end": [35, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.closure_eq_of_isClosed", "code": "theorem Ideal.closure_eq_of_isClosed (I : Ideal R) (hI : IsClosed (I : Set R)) : I.closure = I", "start": [42, 1], "end": [43, 29], "kind": "commanddeclaration"}, {"full_name": "topologicalRingQuotientTopology", "code": "instance topologicalRingQuotientTopology : TopologicalSpace (R \u29f8 N) :=\n  instTopologicalSpaceQuotient", "start": [54, 1], "end": [55, 31], "kind": "commanddeclaration"}, {"full_name": "QuotientRing.isOpenMap_coe", "code": "theorem QuotientRing.isOpenMap_coe : IsOpenMap (mk N)", "start": [61, 1], "end": [65, 64], "kind": "commanddeclaration"}, {"full_name": "QuotientRing.quotientMap_coe_coe", "code": "theorem QuotientRing.quotientMap_coe_coe : QuotientMap fun p : R \u00d7 R => (mk N p.1, mk N p.2)", "start": [68, 1], "end": [71, 48], "kind": "commanddeclaration"}, {"full_name": "topologicalRing_quotient", "code": "instance topologicalRing_quotient : TopologicalRing (R \u29f8 N) :=\n  TopologicalSemiring.toTopologicalRing\n    { continuous_add :=\n        have cont : Continuous (mk N \u2218 fun p : R \u00d7 R => p.fst + p.snd) :=\n          continuous_quot_mk.comp continuous_add\n        (QuotientMap.continuous_iff (QuotientRing.quotientMap_coe_coe N)).mpr cont\n      continuous_mul :=\n        have cont : Continuous (mk N \u2218 fun p : R \u00d7 R => p.fst * p.snd) :=\n          continuous_quot_mk.comp continuous_mul\n        (QuotientMap.continuous_iff (QuotientRing.quotientMap_coe_coe N)).mpr cont }", "start": [74, 1], "end": [83, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Module/Multilinear.lean", "imports": ["Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/LinearAlgebra/Multilinear/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousMultilinearMap", "code": "structure ContinuousMultilinearMap (R : Type u) {\u03b9 : Type v} (M\u2081 : \u03b9 \u2192 Type w\u2081) (M\u2082 : Type w\u2082)\n  [Semiring R] [\u2200 i, AddCommMonoid (M\u2081 i)] [AddCommMonoid M\u2082] [\u2200 i, Module R (M\u2081 i)] [Module R M\u2082]\n  [\u2200 i, TopologicalSpace (M\u2081 i)] [TopologicalSpace M\u2082] extends MultilinearMap R M\u2081 M\u2082 where\n  cont : Continuous toFun", "start": [46, 1], "end": [53, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.toMultilinearMap_injective", "code": "theorem toMultilinearMap_injective :\n    Function.Injective\n      (ContinuousMultilinearMap.toMultilinearMap :\n        ContinuousMultilinearMap R M\u2081 M\u2082 \u2192 MultilinearMap R M\u2081 M\u2082)", "start": [72, 1], "end": [76, 43], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.continuousMapClass", "code": "instance continuousMapClass : ContinuousMapClass (ContinuousMultilinearMap R M\u2081 M\u2082) (\u2200 i, M\u2081 i) M\u2082\n    where\n  coe f := f.toFun\n  coe_injective' _ _ h := toMultilinearMap_injective <| MultilinearMap.coe_injective h\n  map_continuous := ContinuousMultilinearMap.cont", "start": [79, 1], "end": [83, 50], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.Simps.apply", "code": "def Simps.apply (L\u2081 : ContinuousMultilinearMap R M\u2081 M\u2082) (v : \u2200 i, M\u2081 i) : M\u2082 :=\n  L\u2081 v", "start": [89, 1], "end": [92, 7], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.coe_continuous", "code": "@[continuity]\ntheorem coe_continuous : Continuous (f : (\u2200 i, M\u2081 i) \u2192 M\u2082)", "start": [98, 1], "end": [100, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.coe_coe", "code": "@[simp]\ntheorem coe_coe : (f.toMultilinearMap : (\u2200 i, M\u2081 i) \u2192 M\u2082) = f", "start": [103, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.ext", "code": "@[ext]\ntheorem ext {f f' : ContinuousMultilinearMap R M\u2081 M\u2082} (H : \u2200 x, f x = f' x) : f = f'", "start": [108, 1], "end": [110, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.ext_iff", "code": "theorem ext_iff {f f' : ContinuousMultilinearMap R M\u2081 M\u2082} : f = f' \u2194 \u2200 x, f x = f' x", "start": [113, 1], "end": [114, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.map_add", "code": "@[simp]\ntheorem map_add [DecidableEq \u03b9] (m : \u2200 i, M\u2081 i) (i : \u03b9) (x y : M\u2081 i) :\n    f (update m i (x + y)) = f (update m i x) + f (update m i y)", "start": [117, 1], "end": [120, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.map_smul", "code": "@[simp]\ntheorem map_smul [DecidableEq \u03b9] (m : \u2200 i, M\u2081 i) (i : \u03b9) (c : R) (x : M\u2081 i) :\n    f (update m i (c \u2022 x)) = c \u2022 f (update m i x)", "start": [123, 1], "end": [126, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.map_coord_zero", "code": "theorem map_coord_zero {m : \u2200 i, M\u2081 i} (i : \u03b9) (h : m i = 0) : f m = 0", "start": [129, 1], "end": [130, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.map_zero", "code": "@[simp]\ntheorem map_zero [Nonempty \u03b9] : f 0 = 0", "start": [133, 1], "end": [135, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.zero_apply", "code": "@[simp]\ntheorem zero_apply (m : \u2200 i, M\u2081 i) : (0 : ContinuousMultilinearMap R M\u2081 M\u2082) m = 0", "start": [144, 1], "end": [146, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.toMultilinearMap_zero", "code": "@[simp]\ntheorem toMultilinearMap_zero : (0 : ContinuousMultilinearMap R M\u2081 M\u2082).toMultilinearMap = 0", "start": [149, 1], "end": [151, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.smul_apply", "code": "@[simp]\ntheorem smul_apply (f : ContinuousMultilinearMap A M\u2081 M\u2082) (c : R') (m : \u2200 i, M\u2081 i) :\n    (c \u2022 f) m = c \u2022 f m", "start": [163, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.toMultilinearMap_smul", "code": "@[simp]\ntheorem toMultilinearMap_smul (c : R') (f : ContinuousMultilinearMap A M\u2081 M\u2082) :\n    (c \u2022 f).toMultilinearMap = c \u2022 f.toMultilinearMap", "start": [169, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.add_apply", "code": "@[simp]\ntheorem add_apply (m : \u2200 i, M\u2081 i) : (f + f') m = f m + f' m", "start": [198, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.toMultilinearMap_add", "code": "@[simp]\ntheorem toMultilinearMap_add (f g : ContinuousMultilinearMap R M\u2081 M\u2082) :\n    (f + g).toMultilinearMap = f.toMultilinearMap + g.toMultilinearMap", "start": [203, 1], "end": [206, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.addCommMonoid", "code": "instance addCommMonoid : AddCommMonoid (ContinuousMultilinearMap R M\u2081 M\u2082) :=\n  toMultilinearMap_injective.addCommMonoid _ rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [209, 1], "end": [210, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.applyAddHom", "code": "def applyAddHom (m : \u2200 i, M\u2081 i) : ContinuousMultilinearMap R M\u2081 M\u2082 \u2192+ M\u2082 where\n  toFun f := f m\n  map_zero' := rfl\n  map_add' _ _ := rfl", "start": [213, 1], "end": [217, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.sum_apply", "code": "@[simp]\ntheorem sum_apply {\u03b1 : Type*} (f : \u03b1 \u2192 ContinuousMultilinearMap R M\u2081 M\u2082) (m : \u2200 i, M\u2081 i)\n    {s : Finset \u03b1} : (\u2211 a in s, f a) m = \u2211 a in s, f a m", "start": [220, 1], "end": [223, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.toContinuousLinearMap", "code": "def toContinuousLinearMap [DecidableEq \u03b9] (m : \u2200 i, M\u2081 i) (i : \u03b9) : M\u2081 i \u2192L[R] M\u2082 :=\n  { f.toMultilinearMap.toLinearMap m i with\n    cont := f.cont.comp (continuous_const.update i continuous_id) }", "start": [228, 1], "end": [233, 68], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.prod", "code": "def prod (f : ContinuousMultilinearMap R M\u2081 M\u2082) (g : ContinuousMultilinearMap R M\u2081 M\u2083) :\n    ContinuousMultilinearMap R M\u2081 (M\u2082 \u00d7 M\u2083) :=\n  { f.toMultilinearMap.prod g.toMultilinearMap with cont := f.cont.prod_mk g.cont }", "start": [236, 1], "end": [239, 84], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.prod_apply", "code": "@[simp]\ntheorem prod_apply (f : ContinuousMultilinearMap R M\u2081 M\u2082) (g : ContinuousMultilinearMap R M\u2081 M\u2083)\n    (m : \u2200 i, M\u2081 i) : (f.prod g) m = (f m, g m)", "start": [242, 1], "end": [245, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.pi", "code": "def pi {\u03b9' : Type*} {M' : \u03b9' \u2192 Type*} [\u2200 i, AddCommMonoid (M' i)] [\u2200 i, TopologicalSpace (M' i)]\n    [\u2200 i, Module R (M' i)] (f : \u2200 i, ContinuousMultilinearMap R M\u2081 (M' i)) :\n    ContinuousMultilinearMap R M\u2081 (\u2200 i, M' i) where\n  cont := continuous_pi fun i => (f i).coe_continuous\n  toMultilinearMap := MultilinearMap.pi fun i => (f i).toMultilinearMap", "start": [248, 1], "end": [254, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.coe_pi", "code": "@[simp]\ntheorem coe_pi {\u03b9' : Type*} {M' : \u03b9' \u2192 Type*} [\u2200 i, AddCommMonoid (M' i)]\n    [\u2200 i, TopologicalSpace (M' i)] [\u2200 i, Module R (M' i)]\n    (f : \u2200 i, ContinuousMultilinearMap R M\u2081 (M' i)) : \u21d1(pi f) = fun m j => f j m", "start": [257, 1], "end": [261, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.pi_apply", "code": "theorem pi_apply {\u03b9' : Type*} {M' : \u03b9' \u2192 Type*} [\u2200 i, AddCommMonoid (M' i)]\n    [\u2200 i, TopologicalSpace (M' i)] [\u2200 i, Module R (M' i)]\n    (f : \u2200 i, ContinuousMultilinearMap R M\u2081 (M' i)) (m : \u2200 i, M\u2081 i) (j : \u03b9') : pi f m j = f j m", "start": [264, 1], "end": [267, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.codRestrict", "code": "@[simps! toMultilinearMap apply_coe]\ndef codRestrict (f : ContinuousMultilinearMap R M\u2081 M\u2082) (p : Submodule R M\u2082) (h : \u2200 v, f v \u2208 p) :\n    ContinuousMultilinearMap R M\u2081 p :=\n  \u27e8f.1.codRestrict p h, f.cont.subtype_mk _\u27e9", "start": [270, 1], "end": [274, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.ofSubsingleton", "code": "@[simps! toMultilinearMap apply]\ndef ofSubsingleton [Subsingleton \u03b9] (i' : \u03b9) : ContinuousMultilinearMap R (fun _ : \u03b9 => M\u2082) M\u2082 where\n  toMultilinearMap := MultilinearMap.ofSubsingleton R _ i'\n  cont := continuous_apply _", "start": [283, 1], "end": [288, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.constOfIsEmpty", "code": "@[simps! toMultilinearMap apply]\ndef constOfIsEmpty [IsEmpty \u03b9] (m : M\u2082) : ContinuousMultilinearMap R M\u2081 M\u2082 where\n  toMultilinearMap := MultilinearMap.constOfIsEmpty R _ m\n  cont := continuous_const", "start": [293, 1], "end": [297, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.compContinuousLinearMap", "code": "def compContinuousLinearMap (g : ContinuousMultilinearMap R M\u2081' M\u2084)\n    (f : \u2200 i : \u03b9, M\u2081 i \u2192L[R] M\u2081' i) : ContinuousMultilinearMap R M\u2081 M\u2084 :=\n  { g.toMultilinearMap.compLinearMap fun i => (f i).toLinearMap with\n    cont := g.cont.comp <| continuous_pi fun j => (f j).cont.comp <| continuous_apply _ }", "start": [302, 1], "end": [308, 90], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.compContinuousLinearMap_apply", "code": "@[simp]\ntheorem compContinuousLinearMap_apply (g : ContinuousMultilinearMap R M\u2081' M\u2084)\n    (f : \u2200 i : \u03b9, M\u2081 i \u2192L[R] M\u2081' i) (m : \u2200 i, M\u2081 i) :\n    g.compContinuousLinearMap f m = g fun i => f i <| m i", "start": [311, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compContinuousMultilinearMap", "code": "def _root_.ContinuousLinearMap.compContinuousMultilinearMap (g : M\u2082 \u2192L[R] M\u2083)\n    (f : ContinuousMultilinearMap R M\u2081 M\u2082) : ContinuousMultilinearMap R M\u2081 M\u2083 :=\n  { g.toLinearMap.compMultilinearMap f.toMultilinearMap with cont := g.cont.comp f.cont }", "start": [318, 1], "end": [322, 90], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compContinuousMultilinearMap_coe", "code": "@[simp]\ntheorem _root_.ContinuousLinearMap.compContinuousMultilinearMap_coe (g : M\u2082 \u2192L[R] M\u2083)\n    (f : ContinuousMultilinearMap R M\u2081 M\u2082) :\n    (g.compContinuousMultilinearMap f : (\u2200 i, M\u2081 i) \u2192 M\u2083) =\n      (g : M\u2082 \u2192 M\u2083) \u2218 (f : (\u2200 i, M\u2081 i) \u2192 M\u2082)", "start": [325, 1], "end": [331, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.piEquiv", "code": "@[simps]\ndef piEquiv {\u03b9' : Type*} {M' : \u03b9' \u2192 Type*} [\u2200 i, AddCommMonoid (M' i)]\n    [\u2200 i, TopologicalSpace (M' i)] [\u2200 i, Module R (M' i)] :\n    (\u2200 i, ContinuousMultilinearMap R M\u2081 (M' i)) \u2243 ContinuousMultilinearMap R M\u2081 (\u2200 i, M' i) where\n  toFun := ContinuousMultilinearMap.pi\n  invFun f i := (ContinuousLinearMap.proj i : _ \u2192L[R] M' i).compContinuousMultilinearMap f\n  left_inv f := by\n    ext\n    rfl\n  right_inv f := by\n    ext\n    rfl", "start": [334, 1], "end": [346, 8], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.domDomCongr", "code": "@[simps! toMultilinearMap apply]\nnonrec def domDomCongr {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9')\n    (f : ContinuousMultilinearMap R (fun _ : \u03b9 => M\u2082) M\u2083) :\n    ContinuousMultilinearMap R (fun _ : \u03b9' => M\u2082) M\u2083 where\n  toMultilinearMap := f.domDomCongr e\n  cont := f.cont.comp <| continuous_pi fun _ => continuous_apply _", "start": [349, 1], "end": [356, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.domDomCongrEquiv", "code": "@[simps]\ndef domDomCongrEquiv {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    ContinuousMultilinearMap R (fun _ : \u03b9 => M\u2082) M\u2083 \u2243\n      ContinuousMultilinearMap R (fun _ : \u03b9' => M\u2082) M\u2083 where\n  toFun := domDomCongr e\n  invFun := domDomCongr e.symm\n  left_inv _ := ext fun _ => by simp\n  right_inv _ := ext fun _ => by simp", "start": [361, 1], "end": [371, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.cons_add", "code": "theorem cons_add (f : ContinuousMultilinearMap R M M\u2082) (m : \u2200 i : Fin n, M i.succ) (x y : M 0) :\n    f (cons (x + y) m) = f (cons x m) + f (cons y m)", "start": [376, 1], "end": [381, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.cons_smul", "code": "theorem cons_smul (f : ContinuousMultilinearMap R M M\u2082) (m : \u2200 i : Fin n, M i.succ) (c : R)\n    (x : M 0) : f (cons (c \u2022 x) m) = c \u2022 f (cons x m)", "start": [384, 1], "end": [389, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.map_piecewise_add", "code": "theorem map_piecewise_add [DecidableEq \u03b9] (m m' : \u2200 i, M\u2081 i) (t : Finset \u03b9) :\n    f (t.piecewise (m + m') m') = \u2211 s in t.powerset, f (s.piecewise m m')", "start": [392, 1], "end": [394, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.map_add_univ", "code": "theorem map_add_univ [DecidableEq \u03b9] [Fintype \u03b9] (m m' : \u2200 i, M\u2081 i) :\n    f (m + m') = \u2211 s : Finset \u03b9, f (s.piecewise m m')", "start": [397, 1], "end": [401, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.map_sum_finset", "code": "theorem map_sum_finset [DecidableEq \u03b9] :\n    (f fun i => \u2211 j in A i, g i j) = \u2211 r in piFinset A, f fun i => g i (r i)", "start": [410, 1], "end": [416, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.map_sum", "code": "theorem map_sum [DecidableEq \u03b9] [\u2200 i, Fintype (\u03b1 i)] :\n    (f fun i => \u2211 j, g i j) = \u2211 r : \u2200 i, \u03b1 i, f fun i => g i (r i)", "start": [419, 1], "end": [424, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.restrictScalars", "code": "def restrictScalars (f : ContinuousMultilinearMap A M\u2081 M\u2082) : ContinuousMultilinearMap R M\u2081 M\u2082 where\n  toMultilinearMap := f.toMultilinearMap.restrictScalars R\n  cont := f.cont", "start": [435, 1], "end": [439, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.coe_restrictScalars", "code": "@[simp]\ntheorem coe_restrictScalars (f : ContinuousMultilinearMap A M\u2081 M\u2082) : \u21d1(f.restrictScalars R) = f", "start": [442, 1], "end": [444, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.map_sub", "code": "@[simp]\ntheorem map_sub [DecidableEq \u03b9] (m : \u2200 i, M\u2081 i) (i : \u03b9) (x y : M\u2081 i) :\n    f (update m i (x - y)) = f (update m i x) - f (update m i y)", "start": [456, 1], "end": [459, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.neg_apply", "code": "@[simp]\ntheorem neg_apply (m : \u2200 i, M\u2081 i) : (-f) m = -f m", "start": [469, 1], "end": [471, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.sub_apply", "code": "@[simp]\ntheorem sub_apply (m : \u2200 i, M\u2081 i) : (f - f') m = f m - f' m", "start": [477, 1], "end": [479, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.map_piecewise_smul", "code": "theorem map_piecewise_smul [DecidableEq \u03b9] (c : \u03b9 \u2192 R) (m : \u2200 i, M\u2081 i) (s : Finset \u03b9) :\n    f (s.piecewise (fun i => c i \u2022 m i) m) = (\u220f i in s, c i) \u2022 f m", "start": [496, 1], "end": [498, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.map_smul_univ", "code": "theorem map_smul_univ [Fintype \u03b9] (c : \u03b9 \u2192 R) (m : \u2200 i, M\u2081 i) :\n    (f fun i => c i \u2022 m i) = (\u220f i, c i) \u2022 f m", "start": [501, 1], "end": [505, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.toMultilinearMapLinear", "code": "@[simps]\ndef toMultilinearMapLinear : ContinuousMultilinearMap A M\u2081 M\u2082 \u2192\u2097[R'] MultilinearMap A M\u2081 M\u2082 where\n  toFun := toMultilinearMap\n  map_add' := toMultilinearMap_add\n  map_smul' := toMultilinearMap_smul", "start": [542, 1], "end": [548, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.piLinearEquiv", "code": "@[simps (config := { simpRhs := true })]\ndef piLinearEquiv {\u03b9' : Type*} {M' : \u03b9' \u2192 Type*} [\u2200 i, AddCommMonoid (M' i)]\n    [\u2200 i, TopologicalSpace (M' i)] [\u2200 i, ContinuousAdd (M' i)] [\u2200 i, Module R' (M' i)]\n    [\u2200 i, Module A (M' i)] [\u2200 i, SMulCommClass A R' (M' i)] [\u2200 i, ContinuousConstSMul R' (M' i)] :\n    (\u2200 i, ContinuousMultilinearMap A M\u2081 (M' i)) \u2243\u2097[R'] ContinuousMultilinearMap A M\u2081 (\u2200 i, M' i) :=\n  { piEquiv with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }", "start": [551, 1], "end": [559, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.mkPiAlgebra", "code": "protected def mkPiAlgebra : ContinuousMultilinearMap R (fun _ : \u03b9 => A) A where\n  cont := continuous_finset_prod _ fun _ _ => continuous_apply _\n  toMultilinearMap := MultilinearMap.mkPiAlgebra R \u03b9 A", "start": [569, 1], "end": [575, 55], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.mkPiAlgebra_apply", "code": "@[simp]\ntheorem mkPiAlgebra_apply (m : \u03b9 \u2192 A) : ContinuousMultilinearMap.mkPiAlgebra R \u03b9 A m = \u220f i, m i", "start": [578, 1], "end": [580, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.mkPiAlgebraFin", "code": "protected def mkPiAlgebraFin : A[\u00d7n]\u2192L[R] A where\n  cont := by\n    change Continuous fun m => (List.ofFn m).prod\n    simp_rw [List.ofFn_eq_map]\n    exact continuous_list_prod _ fun i _ => continuous_apply _\n  toMultilinearMap := MultilinearMap.mkPiAlgebraFin R n A", "start": [590, 1], "end": [599, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.mkPiAlgebraFin_apply", "code": "@[simp]\ntheorem mkPiAlgebraFin_apply (m : Fin n \u2192 A) :\n    ContinuousMultilinearMap.mkPiAlgebraFin R n A m = (List.ofFn m).prod", "start": [604, 1], "end": [607, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.smulRight", "code": "@[simps! toMultilinearMap apply]\ndef smulRight : ContinuousMultilinearMap R M\u2081 M\u2082 where\n  toMultilinearMap := f.toMultilinearMap.smulRight z\n  cont := f.cont.smul continuous_const", "start": [618, 1], "end": [623, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.cpow", "code": "noncomputable def cpow (x y : \u2102) : \u2102 :=\n  if x = 0 then if y = 0 then 1 else 0 else exp (log x * y)", "start": [22, 1], "end": [26, 60], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_eq_pow", "code": "@[simp]\ntheorem cpow_eq_pow (x y : \u2102) : cpow x y = x ^ y", "start": [32, 1], "end": [34, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_def", "code": "theorem cpow_def (x y : \u2102) : x ^ y = if x = 0 then if y = 0 then 1 else 0 else exp (log x * y)", "start": [37, 1], "end": [38, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_def_of_ne_zero", "code": "theorem cpow_def_of_ne_zero {x : \u2102} (hx : x \u2260 0) (y : \u2102) : x ^ y = exp (log x * y)", "start": [41, 1], "end": [42, 12], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_zero", "code": "@[simp]\ntheorem cpow_zero (x : \u2102) : x ^ (0 : \u2102) = 1", "start": [45, 1], "end": [46, 66], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_eq_zero_iff", "code": "@[simp]\ntheorem cpow_eq_zero_iff (x y : \u2102) : x ^ y = 0 \u2194 x = 0 \u2227 y \u2260 0", "start": [49, 1], "end": [52, 38], "kind": "commanddeclaration"}, {"full_name": "Complex.zero_cpow", "code": "@[simp]\ntheorem zero_cpow {x : \u2102} (h : x \u2260 0) : (0 : \u2102) ^ x = 0", "start": [55, 1], "end": [56, 81], "kind": "commanddeclaration"}, {"full_name": "Complex.zero_cpow_eq_iff", "code": "theorem zero_cpow_eq_iff {x : \u2102} {a : \u2102} : (0 : \u2102) ^ x = a \u2194 x \u2260 0 \u2227 a = 0 \u2228 x = 0 \u2227 a = 1", "start": [59, 1], "end": [73, 24], "kind": "commanddeclaration"}, {"full_name": "Complex.eq_zero_cpow_iff", "code": "theorem eq_zero_cpow_iff {x : \u2102} {a : \u2102} : a = (0 : \u2102) ^ x \u2194 x \u2260 0 \u2227 a = 0 \u2228 x = 0 \u2227 a = 1", "start": [76, 1], "end": [77, 35], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_one", "code": "@[simp]\ntheorem cpow_one (x : \u2102) : x ^ (1 : \u2102) = x", "start": [80, 1], "end": [83, 92], "kind": "commanddeclaration"}, {"full_name": "Complex.one_cpow", "code": "@[simp]\ntheorem one_cpow (x : \u2102) : (1 : \u2102) ^ x = 1", "start": [86, 1], "end": [89, 39], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_add", "code": "theorem cpow_add {x : \u2102} (y z : \u2102) (hx : x \u2260 0) : x ^ (y + z) = x ^ y * x ^ z", "start": [92, 1], "end": [94, 30], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_mul", "code": "theorem cpow_mul {x y : \u2102} (z : \u2102) (h\u2081 : -\u03c0 < (log x * y).im) (h\u2082 : (log x * y).im \u2264 \u03c0) :\n    x ^ (y * z) = (x ^ y) ^ z", "start": [97, 1], "end": [100, 65], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_neg", "code": "theorem cpow_neg (x y : \u2102) : x ^ (-y) = (x ^ y)\u207b\u00b9", "start": [103, 1], "end": [105, 31], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_sub", "code": "theorem cpow_sub {x : \u2102} (y z : \u2102) (hx : x \u2260 0) : x ^ (y - z) = x ^ y / x ^ z", "start": [108, 1], "end": [109, 65], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_neg_one", "code": "theorem cpow_neg_one (x : \u2102) : x ^ (-1 : \u2102) = x\u207b\u00b9", "start": [112, 1], "end": [112, 81], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_nat_cast", "code": "@[simp, norm_cast]\ntheorem cpow_nat_cast (x : \u2102) : \u2200 n : \u2115, x ^ (n : \u2102) = x ^ n", "start": [115, 1], "end": [122, 60], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_two", "code": "@[simp]\ntheorem cpow_two (x : \u2102) : x ^ (2 : \u2102) = x ^ (2 : \u2115)", "start": [125, 1], "end": [128, 29], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_int_cast", "code": "@[simp, norm_cast]\ntheorem cpow_int_cast (x : \u2102) : \u2200 n : \u2124, x ^ (n : \u2102) = x ^ n", "start": [132, 1], "end": [138, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_nat_inv_pow", "code": "theorem cpow_nat_inv_pow (x : \u2102) {n : \u2115} (hn : n \u2260 0) : (x ^ (n\u207b\u00b9 : \u2102)) ^ n = x", "start": [141, 1], "end": [160, 64], "kind": "commanddeclaration"}, {"full_name": "Complex.mul_cpow_ofReal_nonneg", "code": "theorem mul_cpow_ofReal_nonneg {a b : \u211d} (ha : 0 \u2264 a) (hb : 0 \u2264 b) (r : \u2102) :\n    ((a : \u2102) * (b : \u2102)) ^ r = (a : \u2102) ^ r * (b : \u2102) ^ r", "start": [164, 1], "end": [175, 78], "kind": "commanddeclaration"}, {"full_name": "Complex.inv_cpow_eq_ite", "code": "theorem inv_cpow_eq_ite (x : \u2102) (n : \u2102) :\n    x\u207b\u00b9 ^ n = if x.arg = \u03c0 then conj (x ^ conj n)\u207b\u00b9 else (x ^ n)\u207b\u00b9", "start": [178, 1], "end": [183, 37], "kind": "commanddeclaration"}, {"full_name": "Complex.inv_cpow", "code": "theorem inv_cpow (x : \u2102) (n : \u2102) (hx : x.arg \u2260 \u03c0) : x\u207b\u00b9 ^ n = (x ^ n)\u207b\u00b9", "start": [186, 1], "end": [187, 34], "kind": "commanddeclaration"}, {"full_name": "Complex.inv_cpow_eq_ite'", "code": "theorem inv_cpow_eq_ite' (x : \u2102) (n : \u2102) :\n    (x ^ n)\u207b\u00b9 = if x.arg = \u03c0 then conj (x\u207b\u00b9 ^ conj n) else x\u207b\u00b9 ^ n", "start": [190, 1], "end": [196, 24], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_cpow_eq_ite", "code": "theorem conj_cpow_eq_ite (x : \u2102) (n : \u2102) :\n    conj x ^ n = if x.arg = \u03c0 then x ^ n else conj (x ^ conj n)", "start": [199, 1], "end": [203, 35], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_cpow", "code": "theorem conj_cpow (x : \u2102) (n : \u2102) (hx : x.arg \u2260 \u03c0) : conj x ^ n = conj (x ^ conj n)", "start": [206, 1], "end": [207, 35], "kind": "commanddeclaration"}, {"full_name": "Complex.cpow_conj", "code": "theorem cpow_conj (x : \u2102) (n : \u2102) (hx : x.arg \u2260 \u03c0) : x ^ conj n = conj (conj x ^ n)", "start": [210, 1], "end": [211, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Free.lean", "imports": ["Mathlib/Data/List/Basic.lean", "Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/Control/Applicative.lean", "Mathlib/Logic/Equiv/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Control/Traversable/Basic.lean", "Mathlib/Algebra/Hom/Group/Defs.lean"], "premises": [{"full_name": "FreeAddMagma", "code": "inductive FreeAddMagma (\u03b1 : Type u) : Type u\n  | of : \u03b1 \u2192 FreeAddMagma \u03b1\n  | add : FreeAddMagma \u03b1 \u2192 FreeAddMagma \u03b1 \u2192 FreeAddMagma \u03b1\n  deriving DecidableEq", "start": [33, 1], "end": [37, 23], "kind": "commanddeclaration"}, {"full_name": "FreeMagma", "code": "@[to_additive]\ninductive FreeMagma (\u03b1 : Type u) : Type u\n  | of : \u03b1 \u2192 FreeMagma \u03b1\n  | mul : FreeMagma \u03b1 \u2192 FreeMagma \u03b1 \u2192 FreeMagma \u03b1\n  deriving DecidableEq", "start": [41, 1], "end": [46, 23], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.mul_eq", "code": "@[to_additive (attr := simp)]\ntheorem mul_eq (x y : FreeMagma \u03b1) : mul x y = x * y", "start": [63, 1], "end": [64, 60], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.recOnMul", "code": "@[to_additive (attr := elab_as_elim) \"Recursor for `FreeAddMagma` using `x + y` instead of\n`FreeAddMagma.add x y`.\"]\ndef recOnMul {C : FreeMagma \u03b1 \u2192 Sort l} (x) (ih1 : \u2200 x, C (of x))\n    (ih2 : \u2200 x y, C x \u2192 C y \u2192 C (x * y)) : C x :=\n  FreeMagma.recOn x ih1 ih2", "start": [74, 1], "end": [79, 28], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.hom_ext", "code": "@[to_additive (attr := ext 1100)]\ntheorem hom_ext {\u03b2 : Type v} [Mul \u03b2] {f g : FreeMagma \u03b1 \u2192\u2099* \u03b2} (h : f \u2218 of = g \u2218 of) : f = g", "start": [82, 1], "end": [84, 90], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.liftAux", "code": "def FreeMagma.liftAux {\u03b1 : Type u} {\u03b2 : Type v} [Mul \u03b2] (f : \u03b1 \u2192 \u03b2) : FreeMagma \u03b1 \u2192 \u03b2\n  | FreeMagma.of x => f x\n  | x * y => liftAux f x * liftAux f y", "start": [89, 1], "end": [92, 39], "kind": "commanddeclaration"}, {"full_name": "FreeAddMagma.liftAux", "code": "def FreeAddMagma.liftAux {\u03b1 : Type u} {\u03b2 : Type v} [Add \u03b2] (f : \u03b1 \u2192 \u03b2) : FreeAddMagma \u03b1 \u2192 \u03b2\n  | FreeAddMagma.of x => f x\n  | x + y => liftAux f x + liftAux f y", "start": [95, 1], "end": [99, 39], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.lift", "code": "@[to_additive (attr := simps symm_apply)\n\"The universal property of the free additive magma expressing its adjointness.\"]\ndef lift : (\u03b1 \u2192 \u03b2) \u2243 (FreeMagma \u03b1 \u2192\u2099* \u03b2) where\n  toFun f :=\n  { toFun := liftAux f\n    map_mul' := fun x y \u21a6 rfl }\n  invFun F := F \u2218 of\n  left_inv f := rfl\n  right_inv F := by ext; rfl", "start": [110, 1], "end": [119, 29], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.lift_of", "code": "@[to_additive (attr := simp)]\ntheorem lift_of (x) : lift f (of x) = f x", "start": [122, 1], "end": [123, 49], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.lift_comp_of", "code": "@[to_additive (attr := simp)]\ntheorem lift_comp_of : lift f \u2218 of = f", "start": [126, 1], "end": [127, 46], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.lift_comp_of'", "code": "@[to_additive (attr := simp)]\ntheorem lift_comp_of' (f : FreeMagma \u03b1 \u2192\u2099* \u03b2) : lift (f \u2218 of) = f", "start": [130, 1], "end": [131, 93], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.map", "code": "@[to_additive \"The unique additive magma homomorphism `FreeAddMagma \u03b1 \u2192 FreeAddMagma \u03b2` that sends\neach `of x` to `of (f x)`.\"]\ndef map (f : \u03b1 \u2192 \u03b2) : FreeMagma \u03b1 \u2192\u2099* FreeMagma \u03b2 := lift (of \u2218 f)", "start": [140, 1], "end": [144, 67], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.map_of", "code": "@[to_additive (attr := simp)]\ntheorem map_of (x) : map f (of x) = of (f x)", "start": [147, 1], "end": [148, 52], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.recOnPure", "code": "@[to_additive (attr := elab_as_elim) \"Recursor on `FreeAddMagma` using `pure` instead of `of`.\"]\nprotected def recOnPure {C : FreeMagma \u03b1 \u2192 Sort l} (x) (ih1 : \u2200 x, C (pure x))\n    (ih2 : \u2200 x y, C x \u2192 C y \u2192 C (x * y)) : C x :=\n  FreeMagma.recOnMul x ih1 ih2", "start": [162, 1], "end": [166, 31], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.map_pure", "code": "@[to_additive (attr := simp, nolint simpNF)]\ntheorem map_pure (f : \u03b1 \u2192 \u03b2) (x) : (f <$> pure x : FreeMagma \u03b2) = pure (f x)", "start": [170, 1], "end": [171, 84], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.map_mul'", "code": "@[to_additive (attr := simp)]\ntheorem map_mul' (f : \u03b1 \u2192 \u03b2) (x y : FreeMagma \u03b1) : f <$> (x * y) = f <$> x * f <$> y", "start": [174, 1], "end": [175, 92], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.pure_bind", "code": "@[to_additive (attr := simp, nolint simpNF)]\ntheorem pure_bind (f : \u03b1 \u2192 FreeMagma \u03b2) (x) : pure x >>= f = f x", "start": [179, 1], "end": [180, 72], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.mul_bind", "code": "@[to_additive (attr := simp)]\ntheorem mul_bind (f : \u03b1 \u2192 FreeMagma \u03b2) (x y : FreeMagma \u03b1) : x * y >>= f = (x >>= f) * (y >>= f)", "start": [183, 1], "end": [185, 6], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.pure_seq", "code": "@[to_additive (attr := simp)]\ntheorem pure_seq {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} {x : FreeMagma \u03b1} : pure f <*> x = f <$> x", "start": [188, 1], "end": [189, 94], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.mul_seq", "code": "@[to_additive (attr := simp)]\ntheorem mul_seq {\u03b1 \u03b2 : Type u} {f g : FreeMagma (\u03b1 \u2192 \u03b2)} {x : FreeMagma \u03b1} :\n    f * g <*> x = (f <*> x) * (g <*> x)", "start": [192, 1], "end": [194, 47], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.instLawfulMonad", "code": "@[to_additive]\ninstance instLawfulMonad : LawfulMonad FreeMagma.{u} := LawfulMonad.mk'\n  (pure_bind := fun f x \u21a6 rfl)\n  (bind_assoc := fun x f g \u21a6 FreeMagma.recOnPure x (fun x \u21a6 rfl) fun x y ih1 ih2 \u21a6 by\n    rw [mul_bind, mul_bind, mul_bind, ih1, ih2])\n  (id_map := fun x \u21a6 FreeMagma.recOnPure x (fun _ \u21a6 rfl) fun x y ih1 ih2 \u21a6 by\n    rw [map_mul', ih1, ih2])", "start": [197, 1], "end": [203, 29], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.traverse", "code": "protected def FreeMagma.traverse {m : Type u \u2192 Type u} [Applicative m] {\u03b1 \u03b2 : Type u}\n    (F : \u03b1 \u2192 m \u03b2) : FreeMagma \u03b1 \u2192 m (FreeMagma \u03b2)\n  | FreeMagma.of x => FreeMagma.of <$> F x\n  | x * y => (\u00b7 * \u00b7) <$> x.traverse F <*> y.traverse F", "start": [209, 1], "end": [213, 55], "kind": "commanddeclaration"}, {"full_name": "FreeAddMagma.traverse", "code": "protected def FreeAddMagma.traverse {m : Type u \u2192 Type u} [Applicative m] {\u03b1 \u03b2 : Type u}\n    (F : \u03b1 \u2192 m \u03b2) : FreeAddMagma \u03b1 \u2192 m (FreeAddMagma \u03b2)\n  | FreeAddMagma.of x => FreeAddMagma.of <$> F x\n  | x + y => (\u00b7 + \u00b7) <$> x.traverse F <*> y.traverse F", "start": [216, 1], "end": [220, 55], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.traverse_pure", "code": "@[to_additive (attr := simp)]\ntheorem traverse_pure (x) : traverse F (pure x : FreeMagma \u03b1) = pure <$> F x", "start": [238, 1], "end": [239, 84], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.traverse_pure'", "code": "@[to_additive (attr := simp)]\ntheorem traverse_pure' : traverse F \u2218 pure = fun x \u21a6 (pure <$> F x : m (FreeMagma \u03b2))", "start": [242, 1], "end": [243, 93], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.traverse_mul", "code": "@[to_additive (attr := simp)]\ntheorem traverse_mul (x y : FreeMagma \u03b1) :\n    traverse F (x * y) = (\u00b7 * \u00b7) <$> traverse F x <*> traverse F y", "start": [246, 1], "end": [248, 74], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.traverse_mul'", "code": "@[to_additive (attr := simp)]\ntheorem traverse_mul' :\n    Function.comp (traverse F) \u2218 @Mul.mul (FreeMagma \u03b1) _ = fun x y \u21a6\n      (\u00b7 * \u00b7) <$> traverse F x <*> traverse F y", "start": [251, 1], "end": [254, 55], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.traverse_eq", "code": "@[to_additive (attr := simp)]\ntheorem traverse_eq (x) : FreeMagma.traverse F x = traverse F x", "start": [257, 1], "end": [258, 71], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.mul_map_seq", "code": "@[to_additive (attr := simp, nolint simpNF)]\ntheorem mul_map_seq (x y : FreeMagma \u03b1) :\n    ((\u00b7 * \u00b7) <$> x <*> y : Id (FreeMagma \u03b1)) = (x * y : FreeMagma \u03b1)", "start": [262, 1], "end": [264, 76], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.repr", "code": "protected def FreeMagma.repr {\u03b1 : Type u} [Repr \u03b1] : FreeMagma \u03b1 \u2192 Lean.Format\n  | FreeMagma.of x => repr x\n  | x * y => \"( \" ++ x.repr ++ \" * \" ++ y.repr ++ \" )\"", "start": [293, 1], "end": [296, 55], "kind": "commanddeclaration"}, {"full_name": "FreeAddMagma.repr", "code": "protected def FreeAddMagma.repr {\u03b1 : Type u} [Repr \u03b1] : FreeAddMagma \u03b1 \u2192 Lean.Format\n  | FreeAddMagma.of x => repr x\n  | x + y => \"( \" ++ x.repr ++ \" + \" ++ y.repr ++ \" )\"", "start": [299, 1], "end": [302, 55], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.length", "code": "def FreeMagma.length {\u03b1 : Type u} : FreeMagma \u03b1 \u2192 \u2115\n  | FreeMagma.of _x => 1\n  | x * y => x.length + y.length", "start": [310, 1], "end": [313, 33], "kind": "commanddeclaration"}, {"full_name": "FreeAddMagma.length", "code": "def FreeAddMagma.length {\u03b1 : Type u} : FreeAddMagma \u03b1 \u2192 \u2115\n  | FreeAddMagma.of _x => 1\n  | x + y => x.length + y.length", "start": [316, 1], "end": [319, 33], "kind": "commanddeclaration"}, {"full_name": "AddMagma.AssocRel", "code": "inductive AddMagma.AssocRel (\u03b1 : Type u) [Add \u03b1] : \u03b1 \u2192 \u03b1 \u2192 Prop\n  | intro : \u2200 x y z, AddMagma.AssocRel \u03b1 (x + y + z) (x + (y + z))\n  | left : \u2200 w x y z, AddMagma.AssocRel \u03b1 (w + (x + y + z)) (w + (x + (y + z)))", "start": [324, 1], "end": [327, 80], "kind": "commanddeclaration"}, {"full_name": "Magma.AssocRel", "code": "@[to_additive AddMagma.AssocRel \"Associativity relations for an additive magma.\"]\ninductive Magma.AssocRel (\u03b1 : Type u) [Mul \u03b1] : \u03b1 \u2192 \u03b1 \u2192 Prop\n  | intro : \u2200 x y z, Magma.AssocRel \u03b1 (x * y * z) (x * (y * z))\n  | left : \u2200 w x y z, Magma.AssocRel \u03b1 (w * (x * y * z)) (w * (x * (y * z)))", "start": [330, 1], "end": [334, 77], "kind": "commanddeclaration"}, {"full_name": "Magma.AssocQuotient", "code": "@[to_additive AddMagma.FreeAddSemigroup \"Additive semigroup quotient of an additive magma.\"]\ndef AssocQuotient (\u03b1 : Type u) [Mul \u03b1] : Type u :=\n  Quot <| AssocRel \u03b1", "start": [339, 1], "end": [342, 21], "kind": "commanddeclaration"}, {"full_name": "Magma.AssocQuotient.quot_mk_assoc", "code": "@[to_additive]\ntheorem quot_mk_assoc (x y z : \u03b1) : Quot.mk (AssocRel \u03b1) (x * y * z) = Quot.mk _ (x * (y * z))", "start": [349, 1], "end": [351, 36], "kind": "commanddeclaration"}, {"full_name": "Magma.AssocQuotient.quot_mk_assoc_left", "code": "@[to_additive]\ntheorem quot_mk_assoc_left (x y z w : \u03b1) :\n    Quot.mk (AssocRel \u03b1) (x * (y * z * w)) = Quot.mk _ (x * (y * (z * w)))", "start": [354, 1], "end": [357, 37], "kind": "commanddeclaration"}, {"full_name": "Magma.AssocQuotient.of", "code": "@[to_additive \"Embedding from additive magma to its free additive semigroup.\"]\ndef of : \u03b1 \u2192\u2099* AssocQuotient \u03b1 where toFun := Quot.mk _; map_mul' _x _y := rfl", "start": [374, 1], "end": [376, 79], "kind": "commanddeclaration"}, {"full_name": "Magma.AssocQuotient.induction_on", "code": "@[to_additive (attr := elab_as_elim)]\nprotected theorem induction_on {C : AssocQuotient \u03b1 \u2192 Prop} (x : AssocQuotient \u03b1)\n    (ih : \u2200 x, C (of x)) : C x", "start": [382, 1], "end": [384, 57], "kind": "commanddeclaration"}, {"full_name": "Magma.AssocQuotient.hom_ext", "code": "@[to_additive (attr := ext 1100)]\ntheorem hom_ext {f g : AssocQuotient \u03b1 \u2192\u2099* \u03b2} (h : f.comp of = g.comp of) : f = g", "start": [391, 1], "end": [393, 81], "kind": "commanddeclaration"}, {"full_name": "Magma.AssocQuotient.lift", "code": "@[to_additive (attr := simps symm_apply) \"Lifts an additive magma homomorphism `\u03b1 \u2192 \u03b2` to an\nadditive semigroup homomorphism `AddMagma.AssocQuotient \u03b1 \u2192 \u03b2` given an additive semigroup `\u03b2`.\"]\ndef lift : (\u03b1 \u2192\u2099* \u03b2) \u2243 (AssocQuotient \u03b1 \u2192\u2099* \u03b2) where\n  toFun f :=\n  { toFun := fun x \u21a6\n      Quot.liftOn x f <| by rintro a b (\u27e8c, d, e\u27e9 | \u27e8c, d, e, f\u27e9) <;> simp only [map_mul, mul_assoc]\n    map_mul' := fun x y \u21a6 Quot.induction_on\u2082 x y (map_mul f) }\n  invFun f := f.comp of\n  left_inv f := (FunLike.ext _ _) fun x \u21a6 rfl\n  right_inv f := hom_ext <| (FunLike.ext _ _) fun x \u21a6 rfl", "start": [396, 1], "end": [407, 58], "kind": "commanddeclaration"}, {"full_name": "Magma.AssocQuotient.lift_of", "code": "@[to_additive (attr := simp)]\ntheorem lift_of (x : \u03b1) : lift f (of x) = f x", "start": [410, 1], "end": [411, 53], "kind": "commanddeclaration"}, {"full_name": "Magma.AssocQuotient.lift_comp_of", "code": "@[to_additive (attr := simp)]\ntheorem lift_comp_of : (lift f).comp of = f", "start": [414, 1], "end": [415, 71], "kind": "commanddeclaration"}, {"full_name": "Magma.AssocQuotient.lift_comp_of'", "code": "@[to_additive (attr := simp)]\ntheorem lift_comp_of' (f : AssocQuotient \u03b1 \u2192\u2099* \u03b2) : lift (f.comp of) = f", "start": [418, 1], "end": [419, 100], "kind": "commanddeclaration"}, {"full_name": "Magma.AssocQuotient.map", "code": "@[to_additive \"From an additive magma homomorphism `\u03b1 \u2192 \u03b2` to an additive semigroup homomorphism\n`AddMagma.AssocQuotient \u03b1 \u2192 AddMagma.AssocQuotient \u03b2`.\"]\ndef map : AssocQuotient \u03b1 \u2192\u2099* AssocQuotient \u03b2 := lift (of.comp f)", "start": [426, 1], "end": [430, 66], "kind": "commanddeclaration"}, {"full_name": "Magma.AssocQuotient.map_of", "code": "@[to_additive (attr := simp)]\ntheorem map_of (x) : map f (of x) = of (f x)", "start": [433, 1], "end": [434, 52], "kind": "commanddeclaration"}, {"full_name": "FreeAddSemigroup", "code": "structure FreeAddSemigroup (\u03b1 : Type u) where\n  \n  head : \u03b1\n  \n  tail : List \u03b1", "start": [441, 1], "end": [446, 16], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup", "code": "@[to_additive (attr := ext)]\nstructure FreeSemigroup (\u03b1 : Type u) where\n  \n  head : \u03b1\n  \n  tail : List \u03b1", "start": [450, 1], "end": [456, 16], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.head_mul", "code": "@[to_additive (attr := simp)]\ntheorem head_mul (x y : FreeSemigroup \u03b1) : (x * y).1 = x.1", "start": [470, 1], "end": [471, 66], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.tail_mul", "code": "@[to_additive (attr := simp)]\ntheorem tail_mul (x y : FreeSemigroup \u03b1) : (x * y).2 = x.2 ++ y.1 :: y.2", "start": [474, 1], "end": [475, 80], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.mk_mul_mk", "code": "@[to_additive (attr := simp)]\ntheorem mk_mul_mk (x y : \u03b1) (L1 L2 : List \u03b1) : mk x L1 * mk y L2 = mk x (L1 ++ y :: L2)", "start": [478, 1], "end": [479, 95], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.of", "code": "@[to_additive (attr := simps) \"The embedding `\u03b1 \u2192 FreeAddSemigroup \u03b1`.\"]\ndef of (x : \u03b1) : FreeSemigroup \u03b1 := \u27e8x, []\u27e9", "start": [482, 1], "end": [484, 44], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.length", "code": "@[to_additive \"Length of an element of free additive semigroup\"]\ndef length (x : FreeSemigroup \u03b1) : \u2115 := x.tail.length + 1", "start": [487, 1], "end": [489, 58], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.length_mul", "code": "@[to_additive (attr := simp)]\ntheorem length_mul (x y : FreeSemigroup \u03b1) : (x * y).length = x.length + y.length", "start": [492, 1], "end": [494, 78], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.length_of", "code": "@[to_additive (attr := simp)]\ntheorem length_of (x : \u03b1) : (of x).length = 1", "start": [497, 1], "end": [498, 53], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.recOnMul", "code": "@[to_additive (attr := elab_as_elim) \"Recursor for free additive semigroup using `of` and `+`.\"]\nprotected def recOnMul {C : FreeSemigroup \u03b1 \u2192 Sort l} (x) (ih1 : \u2200 x, C (of x))\n    (ih2 : \u2200 x y, C (of x) \u2192 C y \u2192 C (of x * y)) : C x :=\n      FreeSemigroup.recOn x fun f s \u21a6\n      List.recOn s ih1 (fun hd tl ih f \u21a6 ih2 f \u27e8hd, tl\u27e9 (ih1 f) (ih hd)) f", "start": [504, 1], "end": [509, 75], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.hom_ext", "code": "@[to_additive (attr := ext 1100)]\ntheorem hom_ext {\u03b2 : Type v} [Mul \u03b2] {f g : FreeSemigroup \u03b1 \u2192\u2099* \u03b2} (h : f \u2218 of = g \u2218 of) : f = g", "start": [512, 1], "end": [515, 85], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.lift", "code": "@[to_additive (attr := simps symm_apply) \"Lifts a function `\u03b1 \u2192 \u03b2` to an additive semigroup\nhomomorphism `FreeAddSemigroup \u03b1 \u2192 \u03b2` given an additive semigroup `\u03b2`.\"]\ndef lift : (\u03b1 \u2192 \u03b2) \u2243 (FreeSemigroup \u03b1 \u2192\u2099* \u03b2) where\n  toFun f :=\n    { toFun := fun x \u21a6 x.2.foldl (fun a b \u21a6 a * f b) (f x.1)\n      map_mul' := fun x y \u21a6 by\n        simp only [head_mul, tail_mul, \u2190 List.foldl_map f, List.foldl_append, List.foldl_cons,\n          List.foldl_assoc] }\n  invFun f := f \u2218 of\n  left_inv f := rfl\n  right_inv f := hom_ext rfl", "start": [522, 1], "end": [534, 29], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.lift_of", "code": "@[to_additive (attr := simp)]\ntheorem lift_of (x : \u03b1) : lift f (of x) = f x", "start": [537, 1], "end": [538, 53], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.lift_comp_of", "code": "@[to_additive (attr := simp)]\ntheorem lift_comp_of : lift f \u2218 of = f", "start": [541, 1], "end": [542, 46], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.lift_comp_of'", "code": "@[to_additive (attr := simp)]\ntheorem lift_comp_of' (f : FreeSemigroup \u03b1 \u2192\u2099* \u03b2) : lift (f \u2218 of) = f", "start": [545, 1], "end": [546, 85], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.lift_of_mul", "code": "@[to_additive]\ntheorem lift_of_mul (x y) : lift f (of x * y) = f x * lift f y", "start": [549, 1], "end": [550, 91], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.map", "code": "@[to_additive \"The unique additive semigroup homomorphism that sends `of x` to `of (f x)`.\"]\ndef map : FreeSemigroup \u03b1 \u2192\u2099* FreeSemigroup \u03b2 :=\n  lift <| of \u2218 f", "start": [559, 1], "end": [562, 17], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.map_of", "code": "@[to_additive (attr := simp)]\ntheorem map_of (x) : map f (of x) = of (f x)", "start": [565, 1], "end": [566, 52], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.length_map", "code": "@[to_additive (attr := simp)]\ntheorem length_map (x) : (map f x).length = x.length", "start": [569, 1], "end": [571, 97], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.recOnPure", "code": "@[to_additive (attr := elab_as_elim) \"Recursor that uses `pure` instead of `of`.\"]\ndef recOnPure {C : FreeSemigroup \u03b1 \u2192 Sort l} (x) (ih1 : \u2200 x, C (pure x))\n    (ih2 : \u2200 x y, C (pure x) \u2192 C y \u2192 C (pure x * y)) : C x :=\n  FreeSemigroup.recOnMul x ih1 ih2", "start": [585, 1], "end": [589, 35], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.map_pure", "code": "@[to_additive (attr := simp, nolint simpNF)]\ntheorem map_pure (f : \u03b1 \u2192 \u03b2) (x) : (f <$> pure x : FreeSemigroup \u03b2) = pure (f x)", "start": [593, 1], "end": [594, 88], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.map_mul'", "code": "@[to_additive (attr := simp)]\ntheorem map_mul' (f : \u03b1 \u2192 \u03b2) (x y : FreeSemigroup \u03b1) : f <$> (x * y) = f <$> x * f <$> y", "start": [597, 1], "end": [599, 22], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.pure_bind", "code": "@[to_additive (attr := simp, nolint simpNF)]\ntheorem pure_bind (f : \u03b1 \u2192 FreeSemigroup \u03b2) (x) : pure x >>= f = f x", "start": [603, 1], "end": [604, 76], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.mul_bind", "code": "@[to_additive (attr := simp)]\ntheorem mul_bind (f : \u03b1 \u2192 FreeSemigroup \u03b2) (x y : FreeSemigroup \u03b1) :\n    x * y >>= f = (x >>= f) * (y >>= f)", "start": [607, 1], "end": [609, 64], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.pure_seq", "code": "@[to_additive (attr := simp)]\ntheorem pure_seq {f : \u03b1 \u2192 \u03b2} {x : FreeSemigroup \u03b1} : pure f <*> x = f <$> x", "start": [612, 1], "end": [613, 83], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.mul_seq", "code": "@[to_additive (attr := simp)]\ntheorem mul_seq {f g : FreeSemigroup (\u03b1 \u2192 \u03b2)} {x : FreeSemigroup \u03b1} :\n    f * g <*> x = (f <*> x) * (g <*> x)", "start": [616, 1], "end": [618, 58], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.instLawfulMonad", "code": "@[to_additive]\ninstance instLawfulMonad : LawfulMonad FreeSemigroup.{u} := LawfulMonad.mk'\n  (pure_bind := fun _ _ \u21a6 rfl)\n  (bind_assoc := fun x g f \u21a6\n    recOnPure x (fun x \u21a6 rfl) fun x y ih1 ih2 \u21a6 by rw [mul_bind, mul_bind, mul_bind, ih1, ih2])\n  (id_map := fun x \u21a6 recOnPure x (fun _ \u21a6 rfl) fun x y ih1 ih2 \u21a6 by rw [map_mul', ih1, ih2])", "start": [621, 1], "end": [626, 93], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.traverse", "code": "@[to_additive \"`FreeAddSemigroup` is traversable.\"]\nprotected def traverse {m : Type u \u2192 Type u} [Applicative m] {\u03b1 \u03b2 : Type u}\n    (F : \u03b1 \u2192 m \u03b2) (x : FreeSemigroup \u03b1) : m (FreeSemigroup \u03b2) :=\n  recOnPure x (fun x \u21a6 pure <$> F x) fun _x _y ihx ihy \u21a6 (\u00b7 * \u00b7) <$> ihx <*> ihy", "start": [628, 1], "end": [632, 81], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.traverse_pure", "code": "@[to_additive (attr := simp)]\ntheorem traverse_pure (x) : traverse F (pure x : FreeSemigroup \u03b1) = pure <$> F x", "start": [640, 1], "end": [641, 88], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.traverse_pure'", "code": "@[to_additive (attr := simp)]\ntheorem traverse_pure' : traverse F \u2218 pure = fun x \u21a6 (pure <$> F x : m (FreeSemigroup \u03b2))", "start": [644, 1], "end": [645, 97], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.traverse_mul", "code": "@[to_additive (attr := simp)]\ntheorem traverse_mul (x y : FreeSemigroup \u03b1) :\n    traverse F (x * y) = (\u00b7 * \u00b7) <$> traverse F x <*> traverse F y", "start": [652, 1], "end": [662, 6], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.traverse_mul'", "code": "@[to_additive (attr := simp)]\ntheorem traverse_mul' :\n    Function.comp (traverse F) \u2218 @Mul.mul (FreeSemigroup \u03b1) _ = fun x y \u21a6\n      (\u00b7 * \u00b7) <$> traverse F x <*> traverse F y", "start": [665, 1], "end": [668, 100], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.traverse_eq", "code": "@[to_additive (attr := simp)]\ntheorem traverse_eq (x) : FreeSemigroup.traverse F x = traverse F x", "start": [673, 1], "end": [674, 75], "kind": "commanddeclaration"}, {"full_name": "FreeSemigroup.mul_map_seq", "code": "@[to_additive (attr := simp, nolint simpNF)]\ntheorem mul_map_seq (x y : FreeSemigroup \u03b1) :\n    ((\u00b7 * \u00b7) <$> x <*> y : Id (FreeSemigroup \u03b1)) = (x * y : FreeSemigroup \u03b1)", "start": [678, 1], "end": [680, 84], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.toFreeSemigroup", "code": "@[to_additive \"The canonical additive morphism from `FreeAddMagma \u03b1` to `FreeAddSemigroup \u03b1`.\"]\ndef toFreeSemigroup : FreeMagma \u03b1 \u2192\u2099* FreeSemigroup \u03b1 := FreeMagma.lift FreeSemigroup.of", "start": [712, 1], "end": [714, 89], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.toFreeSemigroup_of", "code": "@[to_additive (attr := simp)]\ntheorem toFreeSemigroup_of (x : \u03b1) : toFreeSemigroup (of x) = FreeSemigroup.of x", "start": [717, 1], "end": [718, 88], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.toFreeSemigroup_comp_of", "code": "@[to_additive (attr := simp)]\ntheorem toFreeSemigroup_comp_of : @toFreeSemigroup \u03b1 \u2218 of = FreeSemigroup.of", "start": [721, 1], "end": [722, 84], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.toFreeSemigroup_comp_map", "code": "@[to_additive]\ntheorem toFreeSemigroup_comp_map (f : \u03b1 \u2192 \u03b2) :\n    toFreeSemigroup.comp (map f) = (FreeSemigroup.map f).comp toFreeSemigroup", "start": [725, 1], "end": [728, 15], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.toFreeSemigroup_map", "code": "@[to_additive]\ntheorem toFreeSemigroup_map (f : \u03b1 \u2192 \u03b2) (x : FreeMagma \u03b1) :\n    toFreeSemigroup (map f x) = FreeSemigroup.map f (toFreeSemigroup x)", "start": [731, 1], "end": [734, 51], "kind": "commanddeclaration"}, {"full_name": "FreeMagma.length_toFreeSemigroup", "code": "@[to_additive (attr := simp)]\ntheorem length_toFreeSemigroup (x : FreeMagma \u03b1) : (toFreeSemigroup x).length = x.length", "start": [737, 1], "end": [740, 56], "kind": "commanddeclaration"}, {"full_name": "FreeMagmaAssocQuotientEquiv", "code": "@[to_additive \"Isomorphism between `AddMagma.AssocQuotient (FreeAddMagma \u03b1)` and\n`FreeAddSemigroup \u03b1`.\"]\ndef FreeMagmaAssocQuotientEquiv (\u03b1 : Type u) :\n    Magma.AssocQuotient (FreeMagma \u03b1) \u2243* FreeSemigroup \u03b1 :=\n      (Magma.AssocQuotient.lift FreeMagma.toFreeSemigroup).toMulEquiv\n      (FreeSemigroup.lift (Magma.AssocQuotient.of \u2218 FreeMagma.of))\n      (by ext; rfl)\n      (by ext1; rfl)", "start": [745, 1], "end": [753, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Adjoin/FG.lean", "imports": ["Mathlib/Data/MvPolynomial/Basic.lean", "Mathlib/RingTheory/PrincipalIdealDomain.lean", "Mathlib/RingTheory/Polynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Algebra.fg_trans", "code": "theorem fg_trans (h1 : (adjoin R s).toSubmodule.FG) (h2 : (adjoin (adjoin R s) t).toSubmodule.FG) :\n    (adjoin R (s \u222a t)).toSubmodule.FG", "start": [40, 1], "end": [80, 50], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.FG", "code": "def FG (S : Subalgebra R A) : Prop :=\n  \u2203 t : Finset A, Algebra.adjoin R \u2191t = S", "start": [91, 1], "end": [94, 42], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.fg_adjoin_finset", "code": "theorem fg_adjoin_finset (s : Finset A) : (Algebra.adjoin R (\u2191s : Set A)).FG", "start": [97, 1], "end": [98, 11], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.fg_def", "code": "theorem fg_def {S : Subalgebra R A} : S.FG \u2194 \u2203 t : Set A, Set.Finite t \u2227 Algebra.adjoin R t = S", "start": [101, 1], "end": [102, 40], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.fg_bot", "code": "theorem fg_bot : (\u22a5 : Subalgebra R A).FG", "start": [105, 1], "end": [106, 51], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.fg_of_fg_toSubmodule", "code": "theorem fg_of_fg_toSubmodule {S : Subalgebra R A} : S.toSubmodule.FG \u2192 S.FG", "start": [109, 1], "end": [116, 21], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.fg_of_noetherian", "code": "theorem fg_of_noetherian [IsNoetherian R A] (S : Subalgebra R A) : S.FG", "start": [119, 1], "end": [120, 76], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.fg_of_submodule_fg", "code": "theorem fg_of_submodule_fg (h : (\u22a4 : Submodule R A).FG) : (\u22a4 : Subalgebra R A).FG", "start": [123, 1], "end": [127, 33], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.FG.prod", "code": "theorem FG.prod {S : Subalgebra R A} {T : Subalgebra R B} (hS : S.FG) (hT : T.FG) :\n    (S.prod T).FG", "start": [130, 1], "end": [138, 48], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.FG.map", "code": "theorem FG.map {S : Subalgebra R A} (f : A \u2192\u2090[R] B) (hs : S.FG) : (S.map f).FG", "start": [145, 1], "end": [147, 66], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.fg_of_fg_map", "code": "theorem fg_of_fg_map (S : Subalgebra R A) (f : A \u2192\u2090[R] B) (hf : Function.Injective f)\n    (hs : (S.map f).FG) : S.FG", "start": [152, 1], "end": [159, 29], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.fg_top", "code": "theorem fg_top (S : Subalgebra R A) : (\u22a4 : Subalgebra R S).FG \u2194 S.FG", "start": [162, 1], "end": [168, 15], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.induction_on_adjoin", "code": "theorem induction_on_adjoin [IsNoetherian R A] (P : Subalgebra R A \u2192 Prop) (base : P \u22a5)\n    (ih : \u2200 (S : Subalgebra R A) (x : A), P S \u2192 P (Algebra.adjoin R (insert x S)))\n    (S : Subalgebra R A) : P S", "start": [171, 1], "end": [180, 59], "kind": "commanddeclaration"}, {"full_name": "AlgHom.isNoetherianRing_range", "code": "instance AlgHom.isNoetherianRing_range (f : A \u2192\u2090[R] B) [IsNoetherianRing A] :\n    IsNoetherianRing f.range :=\n  _root_.isNoetherianRing_range f.toRingHom", "start": [191, 1], "end": [194, 44], "kind": "commanddeclaration"}, {"full_name": "isNoetherianRing_of_fg", "code": "theorem isNoetherianRing_of_fg {S : Subalgebra R A} (HS : S.FG) [IsNoetherianRing R] :\n    IsNoetherianRing S", "start": [205, 1], "end": [208, 87], "kind": "commanddeclaration"}, {"full_name": "is_noetherian_subring_closure", "code": "theorem is_noetherian_subring_closure (s : Set R) (hs : s.Finite) :\n    IsNoetherianRing (Subring.closure s)", "start": [211, 1], "end": [214, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Polynomial/Nilpotent.lean", "imports": ["Mathlib/RingTheory/Polynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.isNilpotent_C_mul_pow_X_of_isNilpotent", "code": "lemma isNilpotent_C_mul_pow_X_of_isNilpotent (n : \u2115) (hnil : IsNilpotent r) :\n    IsNilpotent ((C r) * X ^ n) := by\n  refine' Commute.isNilpotent_mul_left (commute_X_pow _ _).symm _\n  obtain \u27e8m, hm\u27e9 := hnil\n  refine' \u27e8m, _\u27e9\n  rw [\u2190 C_pow, hm, C_0]", "start": [27, 1], "end": [32, 24], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.isNilpotent_pow_X_mul_C_of_isNilpotent", "code": "lemma isNilpotent_pow_X_mul_C_of_isNilpotent (n : \u2115) (hnil : IsNilpotent r) :\n    IsNilpotent (X ^ n * (C r)) := by\n  rw [commute_X_pow]\n  exact isNilpotent_C_mul_pow_X_of_isNilpotent n hnil", "start": [34, 1], "end": [37, 54], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.isNilpotent_monomial_iff", "code": "@[simp] lemma isNilpotent_monomial_iff {n : \u2115} :\n    IsNilpotent (monomial (R := R) n r) \u2194 IsNilpotent r :=\n  exists_congr fun k \u21a6 by simp", "start": [39, 1], "end": [41, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.isNilpotent_C_iff", "code": "@[simp] lemma isNilpotent_C_iff :\n    IsNilpotent (C r) \u2194 IsNilpotent r :=\n  exists_congr fun k \u21a6 by simpa only [\u2190 C_pow] using C_eq_zero", "start": [43, 1], "end": [45, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.isNilpotent_X_mul_iff", "code": "@[simp] lemma isNilpotent_X_mul_iff :\n    IsNilpotent (X * P) \u2194 IsNilpotent P := by\n  refine' \u27e8fun h \u21a6 _, _\u27e9\n  \u00b7 rwa [Commute.isNilpotent_mul_right_iff (commute_X P) (by simp)] at h\n  \u00b7 rintro \u27e8k, hk\u27e9\n    exact \u27e8k, by simp [(commute_X P).mul_pow, hk]\u27e9", "start": [47, 1], "end": [52, 51], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.isNilpotent_mul_X_iff", "code": "@[simp] lemma isNilpotent_mul_X_iff :\n    IsNilpotent (P * X) \u2194 IsNilpotent P := by\n  rw [\u2190 commute_X P]\n  exact isNilpotent_X_mul_iff", "start": [54, 1], "end": [57, 30], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.isNilpotent_iff", "code": "protected lemma isNilpotent_iff :\n    IsNilpotent P \u2194 \u2200 i, IsNilpotent (coeff P i) := by\n  refine' \u27e8P.recOnHorner (by simp) (fun p r hp\u2080 _ hp hpr i \u21a6 _) (fun p _ hnp hpX i \u21a6 _), fun h \u21a6 _\u27e9\n  \u00b7 rw [\u2190 sum_monomial_eq P]\n    exact isNilpotent_sum (fun i _ \u21a6 by simpa only [isNilpotent_monomial_iff] using h i)\n  \u00b7 have hr : IsNilpotent (C r) := by\n      obtain \u27e8k, hk\u27e9 := hpr\n      replace hp : eval 0 p = 0 := by rwa [coeff_zero_eq_aeval_zero] at hp\u2080\n      refine' isNilpotent_C_iff.mpr \u27e8k, _\u27e9\n      simpa [coeff_zero_eq_aeval_zero, hp] using congr_arg (fun q \u21a6 coeff q 0) hk\n    cases' i with i; simpa [hp\u2080] using hr\n    simp only [coeff_add, coeff_C_succ, add_zero]\n    apply hp\n    simpa using Commute.isNilpotent_sub (Commute.all _ _) hpr hr\n  \u00b7 cases' i with i; simp\n    simpa using hnp (isNilpotent_mul_X_iff.mp hpX) i", "start": [65, 1], "end": [80, 53], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.isNilpotent_reflect_iff", "code": "@[simp] lemma isNilpotent_reflect_iff {P : R[X]} {N : \u2115} (hN : P.natDegree \u2264 N):\n    IsNilpotent (reflect N P) \u2194 IsNilpotent P := by\n  simp only [Polynomial.isNilpotent_iff, coeff_reverse]\n  refine' \u27e8fun h i \u21a6 _, fun h i \u21a6 _\u27e9 <;> cases' le_or_lt i N with hi hi\n  \u00b7 simpa [tsub_tsub_cancel_of_le hi] using h (N - i)\n  \u00b7 simp [coeff_eq_zero_of_natDegree_lt $ lt_of_le_of_lt hN hi]\n  \u00b7 simpa [hi, revAt_le] using h (N - i)\n  \u00b7 simpa [revAt_eq_self_of_lt hi] using h i", "start": [82, 1], "end": [89, 45], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.isNilpotent_reverse_iff", "code": "@[simp] lemma isNilpotent_reverse_iff :\n    IsNilpotent P.reverse \u2194 IsNilpotent P :=\n  isNilpotent_reflect_iff (le_refl _)", "start": [91, 1], "end": [93, 38], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.isUnit_of_coeff_isUnit_isNilpotent", "code": "theorem isUnit_of_coeff_isUnit_isNilpotent (hunit : IsUnit (P.coeff 0))\n    (hnil : \u2200 i, i \u2260 0 \u2192 IsNilpotent (P.coeff i)) : IsUnit P", "start": [95, 1], "end": [119, 79], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_isUnit_isNilpotent_of_isUnit", "code": "theorem coeff_isUnit_isNilpotent_of_isUnit (hunit : IsUnit P) :\n    IsUnit (P.coeff 0) \u2227 (\u2200 i, i \u2260 0 \u2192 IsNilpotent (P.coeff i))", "start": [121, 1], "end": [143, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isUnit_iff_coeff_isUnit_isNilpotent", "code": "theorem isUnit_iff_coeff_isUnit_isNilpotent :\n    IsUnit P \u2194 IsUnit (P.coeff 0) \u2227 (\u2200 i, i \u2260 0 \u2192 IsNilpotent (P.coeff i))", "start": [145, 1], "end": [151, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isUnit_C_add_X_mul_iff", "code": "@[simp] lemma isUnit_C_add_X_mul_iff :\n    IsUnit (C r + X * P) \u2194 IsUnit r \u2227 IsNilpotent P := by\n  have : \u2200 i, coeff (C r + X * P) (i + 1) = coeff P i := by simp\n  simp_rw [isUnit_iff_coeff_isUnit_isNilpotent, Nat.forall_ne_zero_iff, this]\n  simp only [coeff_add, coeff_C_zero, mul_coeff_zero, coeff_X_zero, zero_mul, add_zero,\n    and_congr_right_iff, \u2190 Polynomial.isNilpotent_iff]", "start": [153, 1], "end": [158, 55], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.isUnit_iff'", "code": "lemma isUnit_iff' :\n    IsUnit P \u2194 IsUnit (eval 0 P) \u2227 IsNilpotent (P /\u2098 X)  := by\n  suffices : P = C (eval 0 P) + X * (P /\u2098 X)\n  \u00b7 conv_lhs => rw [this]; simp\n  conv_lhs => rw [\u2190 modByMonic_add_div P monic_X]\n  simp [modByMonic_X]", "start": [160, 1], "end": [165, 22], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Polynomial/Laurent.lean", "imports": ["Mathlib/Data/Polynomial/Reverse.lean", "Mathlib/Data/Polynomial/AlgebraMap.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Polynomial/Inductions.lean", "Mathlib/RingTheory/Localization/Basic.lean"], "premises": [{"full_name": "LaurentPolynomial", "code": "abbrev LaurentPolynomial (R : Type*) [Semiring R] :=\n  AddMonoidAlgebra R \u2124", "start": [82, 1], "end": [86, 23], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.ext", "code": "@[ext]\ntheorem LaurentPolynomial.ext [Semiring R] {p q : R[T;T\u207b\u00b9]} (h : \u2200 a, p a = q a) : p = q", "start": [95, 1], "end": [97, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toLaurent", "code": "def Polynomial.toLaurent [Semiring R] : R[X] \u2192+* R[T;T\u207b\u00b9] :=\n  (mapDomainRingHom R Int.ofNatHom).comp (toFinsuppIso R)", "start": [99, 1], "end": [102, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toLaurent_apply", "code": "theorem Polynomial.toLaurent_apply [Semiring R] (p : R[X]) :\n    toLaurent p = p.toFinsupp.mapDomain (\u2191)", "start": [105, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toLaurentAlg", "code": "def Polynomial.toLaurentAlg [CommSemiring R] : R[X] \u2192\u2090[R] R[T;T\u207b\u00b9] := by\n  refine' AlgHom.comp _ (toFinsuppIsoAlg R).toAlgHom\n  exact mapDomainAlgHom R R Int.ofNatHom", "start": [112, 1], "end": [116, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coe_toLaurentAlg", "code": "@[simp] lemma Polynomial.coe_toLaurentAlg [CommSemiring R] :\n    (toLaurentAlg : R[X] \u2192 R[T;T\u207b\u00b9]) = toLaurent :=\n  rfl", "start": [119, 1], "end": [121, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.toLaurentAlg_apply", "code": "theorem Polynomial.toLaurentAlg_apply [CommSemiring R] (f : R[X]) : toLaurentAlg f = toLaurent f", "start": [123, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.single_zero_one_eq_one", "code": "theorem single_zero_one_eq_one : (Finsupp.single 0 1 : R[T;T\u207b\u00b9]) = (1 : R[T;T\u207b\u00b9])", "start": [133, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.C", "code": "def C : R \u2192+* R[T;T\u207b\u00b9] :=\n  singleZeroRingHom", "start": [140, 1], "end": [143, 20], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.algebraMap_apply", "code": "theorem algebraMap_apply {R A : Type*} [CommSemiring R] [Semiring A] [Algebra R A] (r : R) :\n    algebraMap R (LaurentPolynomial A) r = C (algebraMap R A r)", "start": [147, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.C_eq_algebraMap", "code": "theorem C_eq_algebraMap {R : Type*} [CommSemiring R] (r : R) : C r = algebraMap R R[T;T\u207b\u00b9] r", "start": [152, 1], "end": [157, 6], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.single_eq_C", "code": "theorem single_eq_C (r : R) : Finsupp.single 0 r = C r", "start": [161, 1], "end": [161, 62], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.C_apply", "code": "@[simp] lemma C_apply (t : R) (n : \u2124) : C t n = if n = 0 then t else 0 := by\n  rw [\u2190 single_eq_C, Finsupp.single_apply]; aesop", "start": [165, 1], "end": [166, 50], "kind": "mathlibtacticlemma"}, {"full_name": "LaurentPolynomial.T", "code": "def T (n : \u2124) : R[T;T\u207b\u00b9] :=\n  Finsupp.single n 1", "start": [168, 1], "end": [174, 21], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.T_apply", "code": "@[simp] lemma T_apply (m n : \u2124) : (T n : R[T;T\u207b\u00b9]) m = if n = m then 1 else 0 :=\n  Finsupp.single_apply", "start": [178, 1], "end": [179, 23], "kind": "mathlibtacticlemma"}, {"full_name": "LaurentPolynomial.T_zero", "code": "@[simp]\ntheorem T_zero : (T 0 : R[T;T\u207b\u00b9]) = 1", "start": [181, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.T_add", "code": "theorem T_add (m n : \u2124) : (T (m + n) : R[T;T\u207b\u00b9]) = T m * T n", "start": [187, 1], "end": [189, 30], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.T_sub", "code": "theorem T_sub (m n : \u2124) : (T (m - n) : R[T;T\u207b\u00b9]) = T m * T (-n)", "start": [193, 1], "end": [193, 99], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.T_pow", "code": "@[simp]\ntheorem T_pow (m : \u2124) (n : \u2115) : (T m ^ n : R[T;T\u207b\u00b9]) = T (n * m)", "start": [197, 1], "end": [199, 49], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.mul_T_assoc", "code": "@[simp]\ntheorem mul_T_assoc (f : R[T;T\u207b\u00b9]) (m n : \u2124) : f * T m * T n = f * T (m + n)", "start": [203, 1], "end": [206, 28], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.single_eq_C_mul_T", "code": "@[simp]\ntheorem single_eq_C_mul_T (r : R) (n : \u2124) :\n    (Finsupp.single n r : R[T;T\u207b\u00b9]) = (C r * T n : R[T;T\u207b\u00b9])", "start": [210, 1], "end": [214, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toLaurent_C_mul_T", "code": "@[simp]\ntheorem _root_.Polynomial.toLaurent_C_mul_T (n : \u2115) (r : R) :\n    (toLaurent (Polynomial.monomial n r) : R[T;T\u207b\u00b9]) = C r * T n", "start": [220, 1], "end": [224, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toLaurent_C", "code": "@[simp]\ntheorem _root_.Polynomial.toLaurent_C (r : R) : toLaurent (Polynomial.C r) = C r", "start": [228, 1], "end": [231, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toLaurent_comp_C", "code": "@[simp]\ntheorem _root_.Polynomial.toLaurent_comp_C : toLaurent (R := R) \u2218 Polynomial.C = C", "start": [235, 1], "end": [237, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toLaurent_X", "code": "@[simp]\ntheorem _root_.Polynomial.toLaurent_X : (toLaurent Polynomial.X : R[T;T\u207b\u00b9]) = T 1", "start": [239, 1], "end": [242, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toLaurent_one", "code": "theorem _root_.Polynomial.toLaurent_one : (Polynomial.toLaurent : R[X] \u2192 R[T;T\u207b\u00b9]) 1 = 1", "start": [247, 1], "end": [248, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toLaurent_C_mul_eq", "code": "theorem _root_.Polynomial.toLaurent_C_mul_eq (r : R) (f : R[X]) :\n    toLaurent (Polynomial.C r * f) = C r * toLaurent f", "start": [252, 1], "end": [254, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toLaurent_X_pow", "code": "theorem _root_.Polynomial.toLaurent_X_pow (n : \u2115) : toLaurent (X ^ n : R[X]) = T n", "start": [259, 1], "end": [260, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toLaurent_C_mul_X_pow", "code": "theorem _root_.Polynomial.toLaurent_C_mul_X_pow (n : \u2115) (r : R) :\n    toLaurent (Polynomial.C r * X ^ n) = C r * T n", "start": [265, 1], "end": [267, 81], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.invertibleT", "code": "instance invertibleT (n : \u2124) : Invertible (T n : R[T;T\u207b\u00b9]) where\n  invOf := T (-n)\n  invOf_mul_self := by rw [\u2190 T_add, add_left_neg, T_zero]\n  mul_invOf_self := by rw [\u2190 T_add, add_right_neg, T_zero]", "start": [271, 1], "end": [274, 59], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.invOf_T", "code": "@[simp]\ntheorem invOf_T (n : \u2124) : \u215f (T n : R[T;T\u207b\u00b9]) = T (-n)", "start": [278, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.isUnit_T", "code": "theorem isUnit_T (n : \u2124) : IsUnit (T n : R[T;T\u207b\u00b9])", "start": [284, 1], "end": [285, 25], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.induction_on", "code": "@[elab_as_elim]\nprotected theorem induction_on {M : R[T;T\u207b\u00b9] \u2192 Prop} (p : R[T;T\u207b\u00b9]) (h_C : \u2200 a, M (C a))\n    (h_add : \u2200 {p q}, M p \u2192 M q \u2192 M (p + q))\n    (h_C_mul_T : \u2200 (n : \u2115) (a : R), M (C a * T n) \u2192 M (C a * T (n + 1)))\n    (h_C_mul_T_Z : \u2200 (n : \u2115) (a : R), M (C a * T (-n)) \u2192 M (C a * T (-n - 1))) : M p", "start": [289, 1], "end": [315, 43], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.induction_on'", "code": "@[elab_as_elim]\nprotected theorem induction_on' {M : R[T;T\u207b\u00b9] \u2192 Prop} (p : R[T;T\u207b\u00b9])\n    (h_add : \u2200 p q, M p \u2192 M q \u2192 M (p + q)) (h_C_mul_T : \u2200 (n : \u2124) (a : R), M (C a * T n)) :\n    M p", "start": [318, 1], "end": [329, 25], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.commute_T", "code": "theorem commute_T (n : \u2124) (f : R[T;T\u207b\u00b9]) : Commute (T n) f", "start": [332, 1], "end": [336, 22], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.T_mul", "code": "@[simp]\ntheorem T_mul (n : \u2124) (f : R[T;T\u207b\u00b9]) : T n * f = f * T n", "start": [340, 1], "end": [342, 21], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.trunc", "code": "def trunc : R[T;T\u207b\u00b9] \u2192+ R[X] :=\n  (toFinsuppIso R).symm.toAddMonoidHom.comp <| comapDomain.addMonoidHom fun _ _ => Int.ofNat.inj", "start": [346, 1], "end": [350, 97], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.trunc_C_mul_T", "code": "@[simp]\ntheorem trunc_C_mul_T (n : \u2124) (r : R) : trunc (C r * T n) = ite (0 \u2264 n) (monomial n.toNat r) 0", "start": [353, 1], "end": [372, 28], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.leftInverse_trunc_toLaurent", "code": "@[simp]\ntheorem leftInverse_trunc_toLaurent :\n    Function.LeftInverse (trunc : R[T;T\u207b\u00b9] \u2192 R[X]) Polynomial.toLaurent", "start": [376, 1], "end": [384, 15], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trunc_toLaurent", "code": "@[simp]\ntheorem _root_.Polynomial.trunc_toLaurent (f : R[X]) : trunc (toLaurent f) = f", "start": [387, 1], "end": [389, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toLaurent_injective", "code": "theorem _root_.Polynomial.toLaurent_injective :\n    Function.Injective (Polynomial.toLaurent : R[X] \u2192 R[T;T\u207b\u00b9])", "start": [392, 1], "end": [394, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toLaurent_inj", "code": "@[simp]\ntheorem _root_.Polynomial.toLaurent_inj (f g : R[X]) : toLaurent f = toLaurent g \u2194 f = g", "start": [397, 1], "end": [399, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toLaurent_ne_zero", "code": "theorem _root_.Polynomial.toLaurent_ne_zero {f : R[X]} : f \u2260 0 \u2194 toLaurent f \u2260 0", "start": [402, 1], "end": [403, 58], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.exists_T_pow", "code": "theorem exists_T_pow (f : R[T;T\u207b\u00b9]) : \u2203 (n : \u2115) (f' : R[X]), toLaurent f' = f * T n", "start": [406, 1], "end": [416, 25], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.induction_on_mul_T", "code": "@[elab_as_elim]\ntheorem induction_on_mul_T {Q : R[T;T\u207b\u00b9] \u2192 Prop} (f : R[T;T\u207b\u00b9])\n    (Qf : \u2200 {f : R[X]} {n : \u2115}, Q (toLaurent f * T (-n))) : Q f", "start": [420, 1], "end": [427, 11], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.reduce_to_polynomial_of_mul_T", "code": "theorem reduce_to_polynomial_of_mul_T (f : R[T;T\u207b\u00b9]) {Q : R[T;T\u207b\u00b9] \u2192 Prop}\n    (Qf : \u2200 f : R[X], Q (toLaurent f)) (QT : \u2200 f, Q (f * T 1) \u2192 Q f) : Q f", "start": [431, 1], "end": [441, 19], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.support_C_mul_T", "code": "theorem support_C_mul_T (a : R) (n : \u2124) : Finsupp.support (C a * T n) \u2286 {n}", "start": [447, 1], "end": [451, 30], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.support_C_mul_T_of_ne_zero", "code": "theorem support_C_mul_T_of_ne_zero {a : R} (a0 : a \u2260 0) (n : \u2124) :\n    Finsupp.support (C a * T n) = {n}", "start": [455, 1], "end": [458, 36], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.toLaurent_support", "code": "theorem toLaurent_support (f : R[X]) : f.toLaurent.support = f.support.map Nat.castEmbedding", "start": [462, 1], "end": [482, 64], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.degree", "code": "def degree (f : R[T;T\u207b\u00b9]) : WithBot \u2124 :=\n  f.support.max", "start": [489, 1], "end": [493, 16], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.degree_zero", "code": "@[simp]\ntheorem degree_zero : degree (0 : R[T;T\u207b\u00b9]) = \u22a5", "start": [496, 1], "end": [498, 6], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.degree_eq_bot_iff", "code": "@[simp]\ntheorem degree_eq_bot_iff {f : R[T;T\u207b\u00b9]} : f.degree = \u22a5 \u2194 f = 0", "start": [501, 1], "end": [508, 15], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.degree_C_mul_T", "code": "@[simp]\ntheorem degree_C_mul_T (n : \u2124) (a : R) (a0 : a \u2260 0) : degree (C a * T n) = n", "start": [513, 1], "end": [522, 29], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.degree_C_mul_T_ite", "code": "theorem degree_C_mul_T_ite [DecidableEq R] (n : \u2124) (a : R) :\n    degree (C a * T n) = if a = 0 then \u22a5 else \u2191n", "start": [526, 1], "end": [530, 21], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.degree_T", "code": "@[simp]\ntheorem degree_T [Nontrivial R] (n : \u2124) : (T n : R[T;T\u207b\u00b9]).degree = n", "start": [534, 1], "end": [537, 55], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.degree_C", "code": "theorem degree_C {a : R} (a0 : a \u2260 0) : (C a).degree = 0", "start": [541, 1], "end": [543, 30], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.degree_C_ite", "code": "theorem degree_C_ite [DecidableEq R] (a : R) : (C a).degree = if a = 0 then \u22a5 else 0", "start": [547, 1], "end": [548, 93], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.degree_C_mul_T_le", "code": "theorem degree_C_mul_T_le (n : \u2124) (a : R) : degree (C a * T n) \u2264 n", "start": [556, 1], "end": [559, 37], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.degree_T_le", "code": "theorem degree_T_le (n : \u2124) : (T n : R[T;T\u207b\u00b9]).degree \u2264 n", "start": [563, 1], "end": [564, 76], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.degree_C_le", "code": "theorem degree_C_le (a : R) : (C a).degree \u2264 0", "start": [568, 1], "end": [569, 69], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.algebraPolynomial", "code": "instance algebraPolynomial (R : Type*) [CommSemiring R] : Algebra R[X] R[T;T\u207b\u00b9] :=\n  { Polynomial.toLaurent with\n    commutes' := fun f l => by simp [mul_comm]\n    smul_def' := fun f l => rfl }", "start": [589, 1], "end": [592, 34], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.algebraMap_X_pow", "code": "theorem algebraMap_X_pow (n : \u2115) : algebraMap R[X] R[T;T\u207b\u00b9] (X ^ n) = T n", "start": [595, 1], "end": [596, 31], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.algebraMap_eq_toLaurent", "code": "@[simp]\ntheorem algebraMap_eq_toLaurent (f : R[X]) : algebraMap R[X] R[T;T\u207b\u00b9] f = toLaurent f", "start": [600, 1], "end": [602, 6], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.isLocalization", "code": "theorem isLocalization : IsLocalization (Submonoid.closure ({X} : Set R[X])) R[T;T\u207b\u00b9]", "start": [605, 1], "end": [623, 43], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.invert", "code": "def invert : R[T;T\u207b\u00b9] \u2243\u2090[R] R[T;T\u207b\u00b9] := AddMonoidAlgebra.domCongr R R <| AddEquiv.neg _", "start": [632, 1], "end": [633, 88], "kind": "commanddeclaration"}, {"full_name": "LaurentPolynomial.invert_T", "code": "@[simp] lemma invert_T (n : \u2124) : invert (T n : R[T;T\u207b\u00b9]) = T (-n) :=\n  AddMonoidAlgebra.domCongr_single _ _ _ _ _", "start": [635, 1], "end": [636, 45], "kind": "mathlibtacticlemma"}, {"full_name": "LaurentPolynomial.invert_apply", "code": "@[simp] lemma invert_apply (f : R[T;T\u207b\u00b9]) (n : \u2124) : invert f n = f (-n) := rfl", "start": [638, 1], "end": [638, 79], "kind": "mathlibtacticlemma"}, {"full_name": "LaurentPolynomial.invert_comp_C", "code": "@[simp] lemma invert_comp_C : invert \u2218 (@C R _) = C := by ext; simp", "start": [640, 1], "end": [640, 68], "kind": "mathlibtacticlemma"}, {"full_name": "LaurentPolynomial.invert_C", "code": "@[simp] lemma invert_C (t : R) : invert (C t) = C t := by ext; simp", "start": [642, 1], "end": [642, 68], "kind": "mathlibtacticlemma"}, {"full_name": "LaurentPolynomial.involutive_invert", "code": "lemma involutive_invert : Involutive (invert (R := R)) := fun _ \u21a6 by ext; simp", "start": [644, 1], "end": [644, 79], "kind": "mathlibtacticlemma"}, {"full_name": "LaurentPolynomial.invert_symm", "code": "@[simp] lemma invert_symm : (invert (R := R)).symm = invert := rfl", "start": [646, 1], "end": [646, 67], "kind": "mathlibtacticlemma"}, {"full_name": "LaurentPolynomial.toLaurent_reverse", "code": "lemma toLaurent_reverse (p : R[X]) :\n    toLaurent p.reverse = invert (toLaurent p) * (T p.natDegree) := by\n  nontriviality R\n  induction' p using Polynomial.recOnHorner with p t _ _ ih p hp ih\n  \u00b7 simp\n  \u00b7 simp [add_mul, \u2190 ih]\n  \u00b7 simpa [natDegree_mul_X hp]", "start": [648, 1], "end": [654, 31], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Polynomial/Expand.lean", "imports": ["Mathlib/RingTheory/Ideal/LocalRing.lean", "Mathlib/RingTheory/Polynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.expand", "code": "noncomputable def expand : R[X] \u2192\u2090[R] R[X] :=\n  { (eval\u2082RingHom C (X ^ p) : R[X] \u2192+* R[X]) with commutes' := fun _ => eval\u2082_C _ _ }", "start": [35, 1], "end": [37, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coe_expand", "code": "theorem coe_expand : (expand R p : R[X] \u2192 R[X]) = eval\u2082 C (X ^ p)", "start": [40, 1], "end": [41, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_eq_sum", "code": "theorem expand_eq_sum {f : R[X]} : expand R p f = f.sum fun e a => C a * (X ^ p) ^ e", "start": [46, 1], "end": [47, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_C", "code": "@[simp]\ntheorem expand_C (r : R) : expand R p (C r) = C r", "start": [50, 1], "end": [52, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_X", "code": "@[simp]\ntheorem expand_X : expand R p X = X ^ p", "start": [56, 1], "end": [58, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_monomial", "code": "@[simp]\ntheorem expand_monomial (r : R) : expand R p (monomial q r) = monomial (q * p) r", "start": [62, 1], "end": [64, 95], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_expand", "code": "theorem expand_expand (f : R[X]) : expand R p (expand R q f) = expand R (p * q) f", "start": [67, 1], "end": [70, 100], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_mul", "code": "theorem expand_mul (f : R[X]) : expand R (p * q) f = expand R p (expand R q f)", "start": [73, 1], "end": [74, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_zero", "code": "@[simp]\ntheorem expand_zero (f : R[X]) : expand R 0 f = C (eval 1 f)", "start": [77, 1], "end": [78, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_one", "code": "@[simp]\ntheorem expand_one (f : R[X]) : expand R 1 f = f", "start": [81, 1], "end": [85, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_pow", "code": "theorem expand_pow (f : R[X]) : expand R (p ^ q) f = (expand R p)^[q] f", "start": [88, 1], "end": [90, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_expand", "code": "theorem derivative_expand (f : R[X]) : Polynomial.derivative (expand R p f) =\n    expand R p (Polynomial.derivative f) * (p * (X ^ (p - 1) : R[X]))", "start": [93, 1], "end": [95, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_expand", "code": "theorem coeff_expand {p : \u2115} (hp : 0 < p) (f : R[X]) (n : \u2115) :\n    (expand R p f).coeff n = if p \u2223 n then f.coeff (n / p) else 0", "start": [98, 1], "end": [115, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_expand_mul", "code": "@[simp]\ntheorem coeff_expand_mul {p : \u2115} (hp : 0 < p) (f : R[X]) (n : \u2115) :\n    (expand R p f).coeff (n * p) = f.coeff n", "start": [118, 1], "end": [121, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_expand_mul'", "code": "@[simp]\ntheorem coeff_expand_mul' {p : \u2115} (hp : 0 < p) (f : R[X]) (n : \u2115) :\n    (expand R p f).coeff (p * n) = f.coeff n", "start": [124, 1], "end": [126, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_injective", "code": "theorem expand_injective {n : \u2115} (hn : 0 < n) : Function.Injective (expand R n)", "start": [129, 1], "end": [131, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_inj", "code": "theorem expand_inj {p : \u2115} (hp : 0 < p) {f g : R[X]} : expand R p f = expand R p g \u2194 f = g", "start": [134, 1], "end": [135, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_eq_zero", "code": "theorem expand_eq_zero {p : \u2115} (hp : 0 < p) {f : R[X]} : expand R p f = 0 \u2194 f = 0", "start": [138, 1], "end": [139, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_ne_zero", "code": "theorem expand_ne_zero {p : \u2115} (hp : 0 < p) {f : R[X]} : expand R p f \u2260 0 \u2194 f \u2260 0", "start": [142, 1], "end": [143, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_eq_C", "code": "theorem expand_eq_C {p : \u2115} (hp : 0 < p) {f : R[X]} {r : R} : expand R p f = C r \u2194 f = C r", "start": [146, 1], "end": [147, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_expand", "code": "theorem natDegree_expand (p : \u2115) (f : R[X]) : (expand R p f).natDegree = f.natDegree * p", "start": [151, 1], "end": [170, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.expand", "code": "theorem Monic.expand {p : \u2115} {f : R[X]} (hp : 0 < p) (h : f.Monic) : (expand R p f).Monic", "start": [173, 1], "end": [175, 15], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_expand", "code": "theorem map_expand {p : \u2115} {f : R \u2192+* S} {q : R[X]} :\n    map f (expand R p q) = expand S p (map f q)", "start": [178, 1], "end": [184, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_eval", "code": "@[simp]\ntheorem expand_eval (p : \u2115) (P : R[X]) (r : R) : eval r (expand R p P) = eval (r ^ p) P", "start": [187, 1], "end": [190, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_aeval", "code": "@[simp]\ntheorem expand_aeval {A : Type*} [Semiring A] [Algebra R A] (p : \u2115) (P : R[X]) (r : A) :\n    aeval r (expand R p P) = aeval (r ^ p) P", "start": [193, 1], "end": [197, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.contract", "code": "noncomputable def contract (p : \u2115) (f : R[X]) : R[X] :=\n  \u2211 n in range (f.natDegree + 1), monomial n (f.coeff (n * p))", "start": [200, 1], "end": [202, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_contract", "code": "theorem coeff_contract {p : \u2115} (hp : p \u2260 0) (f : R[X]) (n : \u2115) :\n    (contract p f).coeff n = f.coeff (n * p)", "start": [205, 1], "end": [214, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.contract_expand", "code": "theorem contract_expand {f : R[X]} (hp : p \u2260 0) : contract p (expand R p f) = f", "start": [217, 1], "end": [219, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_contract", "code": "theorem expand_contract [NoZeroDivisors R] {f : R[X]} (hf : Polynomial.derivative f = 0)\n    (hp : p \u2260 0) : expand R p (contract p f) = f", "start": [226, 1], "end": [240, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.expand_char", "code": "theorem expand_char (f : R[X]) : map (frobenius R p) (expand R p f) = f ^ p", "start": [245, 1], "end": [250, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_expand_pow_char", "code": "theorem map_expand_pow_char (f : R[X]) (n : \u2115) :\n    map (frobenius R p ^ n) (expand R (p ^ n) f) = f ^ p ^ n", "start": [253, 1], "end": [259, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isLocalRingHom_expand", "code": "theorem isLocalRingHom_expand {p : \u2115} (hp : 0 < p) :\n    IsLocalRingHom (\u2191(expand R p) : R[X] \u2192+* R[X])", "start": [270, 1], "end": [275, 77], "kind": "commanddeclaration"}, {"full_name": "Polynomial.of_irreducible_expand", "code": "theorem of_irreducible_expand {p : \u2115} (hp : p \u2260 0) {f : R[X]} (hf : Irreducible (expand R p f)) :\n    Irreducible f", "start": [280, 1], "end": [283, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.of_irreducible_expand_pow", "code": "theorem of_irreducible_expand_pow {p : \u2115} (hp : p \u2260 0) {f : R[X]} {n : \u2115} :\n    Irreducible (expand R (p ^ n) f) \u2192 Irreducible f", "start": [286, 1], "end": [291, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "Mathlib/RingTheory/PolynomialAlgebra.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "charmatrix", "code": "def charmatrix (M : Matrix n n R) : Matrix n n R[X] :=\n  Matrix.scalar n (X : R[X]) - (C : R \u2192+* R[X]).mapMatrix M", "start": [44, 1], "end": [48, 60], "kind": "commanddeclaration"}, {"full_name": "charmatrix_apply", "code": "theorem charmatrix_apply (M : Matrix n n R) (i j : n) :\n    charmatrix M i j = X * (1 : Matrix n n R[X]) i j - C (M i j)", "start": [51, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "charmatrix_apply_eq", "code": "@[simp]\ntheorem charmatrix_apply_eq (M : Matrix n n R) (i : n) :\n    charmatrix M i i = (X : R[X]) - C (M i i)", "start": [56, 1], "end": [59, 89], "kind": "commanddeclaration"}, {"full_name": "charmatrix_apply_ne", "code": "@[simp]\ntheorem charmatrix_apply_ne (M : Matrix n n R) (i j : n) (h : i \u2260 j) :\n    charmatrix M i j = -C (M i j)", "start": [63, 1], "end": [67, 21], "kind": "commanddeclaration"}, {"full_name": "matPolyEquiv_charmatrix", "code": "theorem matPolyEquiv_charmatrix (M : Matrix n n R) : matPolyEquiv (charmatrix M) = X - C M", "start": [70, 1], "end": [79, 27], "kind": "commanddeclaration"}, {"full_name": "charmatrix_reindex", "code": "theorem charmatrix_reindex {m : Type v} [DecidableEq m] [Fintype m] (e : n \u2243 m) (M : Matrix n n R) :\n    charmatrix (reindex e e M) = reindex e e (charmatrix M)", "start": [82, 1], "end": [86, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.charpoly", "code": "def Matrix.charpoly (M : Matrix n n R) : R[X] :=\n  (charmatrix M).det", "start": [89, 1], "end": [92, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.charpoly_reindex", "code": "theorem Matrix.charpoly_reindex {m : Type v} [DecidableEq m] [Fintype m] (e : n \u2243 m)\n    (M : Matrix n n R) : (reindex e e M).charpoly = M.charpoly", "start": [95, 1], "end": [98, 51], "kind": "commanddeclaration"}, {"full_name": "Matrix.aeval_self_charpoly", "code": "theorem Matrix.aeval_self_charpoly (M : Matrix n n R) : aeval M M.charpoly = 0", "start": [102, 1], "end": [129, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Creates.lean", "imports": ["Mathlib/CategoryTheory/Limits/Preserves/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.LiftableCone", "code": "structure LiftableCone (K : J \u2964 C) (F : C \u2964 D) (c : Cone (K \u22d9 F)) where\n  \n  liftedCone : Cone K\n  \n  validLift : F.mapCone liftedCone \u2245 c", "start": [35, 1], "end": [47, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LiftableCocone", "code": "structure LiftableCocone (K : J \u2964 C) (F : C \u2964 D) (c : Cocone (K \u22d9 F)) where\n  \n  liftedCocone : Cocone K\n  \n  validLift : F.mapCocone liftedCocone \u2245 c", "start": [50, 1], "end": [62, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CreatesLimit", "code": "class CreatesLimit (K : J \u2964 C) (F : C \u2964 D) extends ReflectsLimit K F where\n  \n  lifts : \u2200 c, IsLimit c \u2192 LiftableCone K F c", "start": [65, 1], "end": [75, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CreatesLimitsOfShape", "code": "class CreatesLimitsOfShape (J : Type w) [Category.{w'} J] (F : C \u2964 D) where\n  CreatesLimit : \u2200 {K : J \u2964 C}, CreatesLimit K F := by infer_instance", "start": [78, 1], "end": [82, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CreatesLimitsOfSize", "code": "@[nolint checkUnivs, pp_with_univ]\nclass CreatesLimitsOfSize (F : C \u2964 D) where\n  CreatesLimitsOfShape : \u2200 {J : Type w} [Category.{w'} J], CreatesLimitsOfShape J F := by\n    infer_instance", "start": [86, 1], "end": [90, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CreatesLimits", "code": "abbrev CreatesLimits (F : C \u2964 D) :=\n  CreatesLimitsOfSize.{v\u2082, v\u2082} F", "start": [93, 1], "end": [95, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CreatesColimit", "code": "class CreatesColimit (K : J \u2964 C) (F : C \u2964 D) extends ReflectsColimit K F where\n  \n  lifts : \u2200 c, IsColimit c \u2192 LiftableCocone K F c", "start": [98, 1], "end": [108, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CreatesColimitsOfShape", "code": "class CreatesColimitsOfShape (J : Type w) [Category.{w'} J] (F : C \u2964 D) where\n  CreatesColimit : \u2200 {K : J \u2964 C}, CreatesColimit K F := by infer_instance", "start": [111, 1], "end": [115, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CreatesColimitsOfSize", "code": "@[nolint checkUnivs, pp_with_univ]\nclass CreatesColimitsOfSize (F : C \u2964 D) where\n  CreatesColimitsOfShape : \u2200 {J : Type w} [Category.{w'} J], CreatesColimitsOfShape J F := by\n    infer_instance", "start": [119, 1], "end": [123, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CreatesColimits", "code": "abbrev CreatesColimits (F : C \u2964 D) :=\n  CreatesColimitsOfSize.{v\u2082, v\u2082} F", "start": [126, 1], "end": [128, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.liftLimit", "code": "def liftLimit {K : J \u2964 C} {F : C \u2964 D} [CreatesLimit K F] {c : Cone (K \u22d9 F)} (t : IsLimit c) :\n    Cone K :=\n  (CreatesLimit.lifts c t).liftedCone", "start": [137, 1], "end": [140, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.liftedLimitMapsToOriginal", "code": "def liftedLimitMapsToOriginal {K : J \u2964 C} {F : C \u2964 D} [CreatesLimit K F] {c : Cone (K \u22d9 F)}\n    (t : IsLimit c) : F.mapCone (liftLimit t) \u2245 c :=\n  (CreatesLimit.lifts c t).validLift", "start": [143, 1], "end": [146, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.liftedLimitIsLimit", "code": "def liftedLimitIsLimit {K : J \u2964 C} {F : C \u2964 D} [CreatesLimit K F] {c : Cone (K \u22d9 F)}\n    (t : IsLimit c) : IsLimit (liftLimit t) :=\n  ReflectsLimit.reflects (IsLimit.ofIsoLimit t (liftedLimitMapsToOriginal t).symm)", "start": [149, 1], "end": [152, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hasLimit_of_created", "code": "theorem hasLimit_of_created (K : J \u2964 C) (F : C \u2964 D) [HasLimit (K \u22d9 F)] [CreatesLimit K F] :\n    HasLimit K", "start": [155, 1], "end": [160, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hasLimitsOfShape_of_hasLimitsOfShape_createsLimitsOfShape", "code": "theorem hasLimitsOfShape_of_hasLimitsOfShape_createsLimitsOfShape (F : C \u2964 D) [HasLimitsOfShape J D]\n    [CreatesLimitsOfShape J F] : HasLimitsOfShape J C", "start": [163, 1], "end": [168, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hasLimits_of_hasLimits_createsLimits", "code": "theorem hasLimits_of_hasLimits_createsLimits (F : C \u2964 D) [HasLimitsOfSize.{w, w'} D]\n    [CreatesLimitsOfSize.{w, w'} F] : HasLimitsOfSize.{w, w'} C", "start": [171, 1], "end": [174, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.liftColimit", "code": "def liftColimit {K : J \u2964 C} {F : C \u2964 D} [CreatesColimit K F] {c : Cocone (K \u22d9 F)}\n    (t : IsColimit c) : Cocone K :=\n  (CreatesColimit.lifts c t).liftedCocone", "start": [178, 1], "end": [181, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.liftedColimitMapsToOriginal", "code": "def liftedColimitMapsToOriginal {K : J \u2964 C} {F : C \u2964 D} [CreatesColimit K F] {c : Cocone (K \u22d9 F)}\n    (t : IsColimit c) : F.mapCocone (liftColimit t) \u2245 c :=\n  (CreatesColimit.lifts c t).validLift", "start": [184, 1], "end": [187, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.liftedColimitIsColimit", "code": "def liftedColimitIsColimit {K : J \u2964 C} {F : C \u2964 D} [CreatesColimit K F] {c : Cocone (K \u22d9 F)}\n    (t : IsColimit c) : IsColimit (liftColimit t) :=\n  ReflectsColimit.reflects (IsColimit.ofIsoColimit t (liftedColimitMapsToOriginal t).symm)", "start": [190, 1], "end": [193, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hasColimit_of_created", "code": "theorem hasColimit_of_created (K : J \u2964 C) (F : C \u2964 D) [HasColimit (K \u22d9 F)] [CreatesColimit K F] :\n    HasColimit K", "start": [196, 1], "end": [201, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hasColimitsOfShape_of_hasColimitsOfShape_createsColimitsOfShape", "code": "theorem hasColimitsOfShape_of_hasColimitsOfShape_createsColimitsOfShape (F : C \u2964 D)\n    [HasColimitsOfShape J D] [CreatesColimitsOfShape J F] : HasColimitsOfShape J C", "start": [204, 1], "end": [209, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hasColimits_of_hasColimits_createsColimits", "code": "theorem hasColimits_of_hasColimits_createsColimits (F : C \u2964 D) [HasColimitsOfSize.{w, w'} D]\n    [CreatesColimitsOfSize.{w, w'} F] : HasColimitsOfSize.{w, w'} C", "start": [212, 1], "end": [215, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.reflectsLimitsOfShapeOfCreatesLimitsOfShape", "code": "instance (priority := 10) reflectsLimitsOfShapeOfCreatesLimitsOfShape (F : C \u2964 D)\n    [CreatesLimitsOfShape J F] : ReflectsLimitsOfShape J F where", "start": [218, 1], "end": [219, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.reflectsLimitsOfCreatesLimits", "code": "instance (priority := 10) reflectsLimitsOfCreatesLimits (F : C \u2964 D)\n    [CreatesLimitsOfSize.{w, w'} F] : ReflectsLimitsOfSize.{w, w'} F where", "start": [222, 1], "end": [223, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.reflectsColimitsOfShapeOfCreatesColimitsOfShape", "code": "instance (priority := 10) reflectsColimitsOfShapeOfCreatesColimitsOfShape (F : C \u2964 D)\n    [CreatesColimitsOfShape J F] : ReflectsColimitsOfShape J F where", "start": [226, 1], "end": [227, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.reflectsColimitsOfCreatesColimits", "code": "instance (priority := 10) reflectsColimitsOfCreatesColimits (F : C \u2964 D)\n    [CreatesColimitsOfSize.{w, w'} F] : ReflectsColimitsOfSize.{w, w'} F where", "start": [230, 1], "end": [231, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LiftsToLimit", "code": "structure LiftsToLimit (K : J \u2964 C) (F : C \u2964 D) (c : Cone (K \u22d9 F)) (t : IsLimit c) extends\n  LiftableCone K F c where\n  \n  makesLimit : IsLimit liftedCone", "start": [234, 1], "end": [243, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LiftsToColimit", "code": "structure LiftsToColimit (K : J \u2964 C) (F : C \u2964 D) (c : Cocone (K \u22d9 F)) (t : IsColimit c) extends\n  LiftableCocone K F c where\n  \n  makesColimit : IsColimit liftedCocone", "start": [246, 1], "end": [255, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsLimitOfReflectsIso", "code": "def createsLimitOfReflectsIso {K : J \u2964 C} {F : C \u2964 D} [ReflectsIsomorphisms F]\n    (h : \u2200 c t, LiftsToLimit K F c t) : CreatesLimit K F\n    where\n  lifts c t := (h c t).toLiftableCone\n  toReflectsLimit :=\n    { reflects := fun {d} hd => by\n        let d' : Cone K := (h (F.mapCone d) hd).toLiftableCone.liftedCone\n        let i : F.mapCone d' \u2245 F.mapCone d :=\n          (h (F.mapCone d) hd).toLiftableCone.validLift\n        let hd' : IsLimit d' := (h (F.mapCone d) hd).makesLimit\n        let f : d \u27f6 d' := hd'.liftConeMorphism d\n        have : (Cones.functoriality K F).map f = i.inv :=\n          (hd.ofIsoLimit i.symm).uniq_cone_morphism\n        haveI : IsIso ((Cones.functoriality K F).map f) := by\n          rw [this]\n          infer_instance\n        haveI : IsIso f := isIso_of_reflects_iso f (Cones.functoriality K F)\n        exact IsLimit.ofIsoLimit hd' (asIso f).symm }", "start": [258, 1], "end": [279, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsLimitOfFullyFaithfulOfLift'", "code": "def createsLimitOfFullyFaithfulOfLift' {K : J \u2964 C} {F : C \u2964 D} [Full F] [Faithful F]\n    {l : Cone (K \u22d9 F)} (hl : IsLimit l) (c : Cone K) (i : F.mapCone c \u2245 l) :\n    CreatesLimit K F :=\n  createsLimitOfReflectsIso fun _ t =>\n    { liftedCone := c\n      validLift := i \u226a\u226b IsLimit.uniqueUpToIso hl t\n      makesLimit :=\n        IsLimit.ofFaithful F (IsLimit.ofIsoLimit hl i.symm) _ fun _ => F.image_preimage _ }", "start": [285, 1], "end": [296, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsLimitOfFullyFaithfulOfLift", "code": "def createsLimitOfFullyFaithfulOfLift {K : J \u2964 C} {F : C \u2964 D} [Full F] [Faithful F]\n    [HasLimit (K \u22d9 F)] (c : Cone K) (i : F.mapCone c \u2245 limit.cone (K \u22d9 F)) :\n    CreatesLimit K F :=\n  createsLimitOfFullyFaithfulOfLift' (limit.isLimit _) c i", "start": [302, 1], "end": [308, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsLimitOfFullyFaithfulOfIso'", "code": "def createsLimitOfFullyFaithfulOfIso' {K : J \u2964 C} {F : C \u2964 D} [Full F] [Faithful F]\n    {l : Cone (K \u22d9 F)} (hl : IsLimit l) (X : C) (i : F.obj X \u2245 l.pt) : CreatesLimit K F :=\n  createsLimitOfFullyFaithfulOfLift' hl\n    { pt := X\n      \u03c0 :=\n        { app := fun j => F.preimage (i.hom \u226b l.\u03c0.app j)\n          naturality := fun Y Z f =>\n            F.map_injective <| by\n              dsimp\n              simpa using (l.w f).symm } }\n    (Cones.ext i fun j => by simp only [Functor.image_preimage, Functor.mapCone_\u03c0_app])", "start": [314, 1], "end": [328, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsLimitOfFullyFaithfulOfIso", "code": "def createsLimitOfFullyFaithfulOfIso {K : J \u2964 C} {F : C \u2964 D} [Full F] [Faithful F]\n    [HasLimit (K \u22d9 F)] (X : C) (i : F.obj X \u2245 limit (K \u22d9 F)) : CreatesLimit K F :=\n  createsLimitOfFullyFaithfulOfIso' (limit.isLimit _) X i", "start": [334, 1], "end": [339, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesLimitOfCreatesLimitAndHasLimit", "code": "instance (priority := 100) preservesLimitOfCreatesLimitAndHasLimit (K : J \u2964 C) (F : C \u2964 D)\n    [CreatesLimit K F] [HasLimit (K \u22d9 F)] : PreservesLimit K F where\n  preserves t := IsLimit.ofIsoLimit (limit.isLimit _)\n    ((liftedLimitMapsToOriginal (limit.isLimit _)).symm \u226a\u226b\n      (Cones.functoriality K F).mapIso ((liftedLimitIsLimit (limit.isLimit _)).uniqueUpToIso t))", "start": [343, 1], "end": [348, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesLimitOfShapeOfCreatesLimitsOfShapeAndHasLimitsOfShape", "code": "instance (priority := 100) preservesLimitOfShapeOfCreatesLimitsOfShapeAndHasLimitsOfShape\n    (F : C \u2964 D) [CreatesLimitsOfShape J F] [HasLimitsOfShape J D] : PreservesLimitsOfShape J F where", "start": [352, 1], "end": [354, 101], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesLimitsOfCreatesLimitsAndHasLimits", "code": "instance (priority := 100) preservesLimitsOfCreatesLimitsAndHasLimits (F : C \u2964 D)\n    [CreatesLimitsOfSize.{w, w'} F] [HasLimitsOfSize.{w, w'} D] : PreservesLimitsOfSize.{w, w'} F\n    where", "start": [358, 1], "end": [361, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsColimitOfReflectsIso", "code": "def createsColimitOfReflectsIso {K : J \u2964 C} {F : C \u2964 D} [ReflectsIsomorphisms F]\n    (h : \u2200 c t, LiftsToColimit K F c t) : CreatesColimit K F\n    where\n  lifts c t := (h c t).toLiftableCocone\n  toReflectsColimit :=\n    {\n      reflects := fun {d} hd => by\n        let d' : Cocone K := (h (F.mapCocone d) hd).toLiftableCocone.liftedCocone\n        let i : F.mapCocone d' \u2245 F.mapCocone d :=\n          (h (F.mapCocone d) hd).toLiftableCocone.validLift\n        let hd' : IsColimit d' := (h (F.mapCocone d) hd).makesColimit\n        let f : d' \u27f6 d := hd'.descCoconeMorphism d\n        have : (Cocones.functoriality K F).map f = i.hom :=\n          (hd.ofIsoColimit i.symm).uniq_cocone_morphism\n        haveI : IsIso ((Cocones.functoriality K F).map f) := by\n          rw [this]\n          infer_instance\n        haveI := isIso_of_reflects_iso f (Cocones.functoriality K F)\n        exact IsColimit.ofIsoColimit hd' (asIso f) }", "start": [364, 1], "end": [386, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsColimitOfFullyFaithfulOfLift'", "code": "def createsColimitOfFullyFaithfulOfLift' {K : J \u2964 C} {F : C \u2964 D} [Full F] [Faithful F]\n    {l : Cocone (K \u22d9 F)} (hl : IsColimit l) (c : Cocone K) (i : F.mapCocone c \u2245 l) :\n    CreatesColimit K F :=\n  createsColimitOfReflectsIso fun _ t =>\n    { liftedCocone := c\n      validLift := i \u226a\u226b IsColimit.uniqueUpToIso hl t\n      makesColimit :=\n        IsColimit.ofFaithful F (IsColimit.ofIsoColimit hl i.symm) _ fun _ => F.image_preimage _ }", "start": [392, 1], "end": [403, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsColimitOfFullyFaithfulOfLift", "code": "def createsColimitOfFullyFaithfulOfLift {K : J \u2964 C} {F : C \u2964 D} [Full F] [Faithful F]\n    [HasColimit (K \u22d9 F)] (c : Cocone K) (i : F.mapCocone c \u2245 colimit.cocone (K \u22d9 F)) :\n    CreatesColimit K F :=\n  createsColimitOfFullyFaithfulOfLift' (colimit.isColimit _) c i", "start": [409, 1], "end": [416, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsColimitOfFullyFaithfulOfIso'", "code": "def createsColimitOfFullyFaithfulOfIso' {K : J \u2964 C} {F : C \u2964 D} [Full F] [Faithful F]\n    {l : Cocone (K \u22d9 F)} (hl : IsColimit l) (X : C) (i : F.obj X \u2245 l.pt) : CreatesColimit K F :=\n  createsColimitOfFullyFaithfulOfLift' hl\n    { pt := X\n      \u03b9 :=\n        { app := fun j => F.preimage (l.\u03b9.app j \u226b i.inv)\n          naturality := fun Y Z f =>\n            F.map_injective <| by\n              dsimp\n              simpa [\u2190 cancel_mono i.hom] using l.w f } }\n    (Cocones.ext i fun j => by simp)", "start": [422, 1], "end": [436, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsColimitOfFullyFaithfulOfIso", "code": "def createsColimitOfFullyFaithfulOfIso {K : J \u2964 C} {F : C \u2964 D} [Full F] [Faithful F]\n    [HasColimit (K \u22d9 F)] (X : C) (i : F.obj X \u2245 colimit (K \u22d9 F)) : CreatesColimit K F :=\n  createsColimitOfFullyFaithfulOfIso' (colimit.isColimit _) X i", "start": [442, 1], "end": [448, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesColimitOfCreatesColimitAndHasColimit", "code": "instance (priority := 100) preservesColimitOfCreatesColimitAndHasColimit (K : J \u2964 C) (F : C \u2964 D)\n    [CreatesColimit K F] [HasColimit (K \u22d9 F)] : PreservesColimit K F where\n  preserves t :=\n    IsColimit.ofIsoColimit (colimit.isColimit _)\n      ((liftedColimitMapsToOriginal (colimit.isColimit _)).symm \u226a\u226b\n        (Cocones.functoriality K F).mapIso\n          ((liftedColimitIsColimit (colimit.isColimit _)).uniqueUpToIso t))", "start": [452, 1], "end": [459, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesColimitOfShapeOfCreatesColimitsOfShapeAndHasColimitsOfShape", "code": "instance (priority := 100) preservesColimitOfShapeOfCreatesColimitsOfShapeAndHasColimitsOfShape\n    (F : C \u2964 D) [CreatesColimitsOfShape J F] [HasColimitsOfShape J D] : PreservesColimitsOfShape J F\n    where", "start": [463, 1], "end": [466, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesColimitsOfCreatesColimitsAndHasColimits", "code": "instance (priority := 100) preservesColimitsOfCreatesColimitsAndHasColimits (F : C \u2964 D)\n    [CreatesColimitsOfSize.{w, w'} F] [HasColimitsOfSize.{w, w'} D] :\n    PreservesColimitsOfSize.{w, w'} F where", "start": [470, 1], "end": [473, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsLimitOfIsoDiagram", "code": "def createsLimitOfIsoDiagram {K\u2081 K\u2082 : J \u2964 C} (F : C \u2964 D) (h : K\u2081 \u2245 K\u2082) [CreatesLimit K\u2081 F] :\n    CreatesLimit K\u2082 F :=\n  { reflectsLimitOfIsoDiagram F h with\n    lifts := fun c t =>\n      let t' := (IsLimit.postcomposeInvEquiv (isoWhiskerRight h F : _) c).symm t\n      { liftedCone := (Cones.postcompose h.hom).obj (liftLimit t')\n        validLift :=\n          Functor.mapConePostcompose F \u226a\u226b\n            (Cones.postcompose (isoWhiskerRight h F).hom).mapIso (liftedLimitMapsToOriginal t') \u226a\u226b\n              Cones.ext (Iso.refl _) fun j => by\n                dsimp\n                rw [Category.assoc, \u2190 F.map_comp]\n                simp } }", "start": [476, 1], "end": [489, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsLimitOfNatIso", "code": "def createsLimitOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [CreatesLimit K F] : CreatesLimit K G\n    where\n  lifts c t :=\n    { liftedCone := liftLimit ((IsLimit.postcomposeInvEquiv (isoWhiskerLeft K h : _) c).symm t)\n      validLift := by\n        refine' (IsLimit.mapConeEquiv h _).uniqueUpToIso t\n        apply IsLimit.ofIsoLimit _ (liftedLimitMapsToOriginal _).symm\n        apply (IsLimit.postcomposeInvEquiv _ _).symm t }\n  toReflectsLimit := reflectsLimitOfNatIso _ h", "start": [492, 1], "end": [501, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsLimitsOfShapeOfNatIso", "code": "def createsLimitsOfShapeOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [CreatesLimitsOfShape J F] :\n    CreatesLimitsOfShape J G where CreatesLimit := createsLimitOfNatIso h", "start": [504, 1], "end": [506, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsLimitsOfNatIso", "code": "def createsLimitsOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [CreatesLimitsOfSize.{w, w'} F] :\n    CreatesLimitsOfSize.{w, w'} G where\n  CreatesLimitsOfShape := createsLimitsOfShapeOfNatIso h", "start": [509, 1], "end": [512, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsColimitOfIsoDiagram", "code": "def createsColimitOfIsoDiagram {K\u2081 K\u2082 : J \u2964 C} (F : C \u2964 D) (h : K\u2081 \u2245 K\u2082) [CreatesColimit K\u2081 F] :\n    CreatesColimit K\u2082 F :=\n  { reflectsColimitOfIsoDiagram F h with\n    lifts := fun c t =>\n      let t' := (IsColimit.precomposeHomEquiv (isoWhiskerRight h F : _) c).symm t\n      { liftedCocone := (Cocones.precompose h.inv).obj (liftColimit t')\n        validLift :=\n          Functor.mapCoconePrecompose F \u226a\u226b\n            (Cocones.precompose (isoWhiskerRight h F).inv).mapIso\n                (liftedColimitMapsToOriginal t') \u226a\u226b\n              Cocones.ext (Iso.refl _) fun j => by\n                dsimp\n                rw [\u2190 F.map_comp_assoc]\n                simp } }", "start": [515, 1], "end": [529, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsColimitOfNatIso", "code": "def createsColimitOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [CreatesColimit K F] : CreatesColimit K G\n    where\n  lifts c t :=\n    { liftedCocone := liftColimit ((IsColimit.precomposeHomEquiv (isoWhiskerLeft K h : _) c).symm t)\n      validLift := by\n        refine' (IsColimit.mapCoconeEquiv h _).uniqueUpToIso t\n        apply IsColimit.ofIsoColimit _ (liftedColimitMapsToOriginal _).symm\n        apply (IsColimit.precomposeHomEquiv _ _).symm t }\n  toReflectsColimit := reflectsColimitOfNatIso _ h", "start": [532, 1], "end": [541, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsColimitsOfShapeOfNatIso", "code": "def createsColimitsOfShapeOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [CreatesColimitsOfShape J F] :\n    CreatesColimitsOfShape J G where CreatesColimit := createsColimitOfNatIso h", "start": [544, 1], "end": [546, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.createsColimitsOfNatIso", "code": "def createsColimitsOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [CreatesColimitsOfSize.{w, w'} F] :\n    CreatesColimitsOfSize.{w, w'} G where\n  CreatesColimitsOfShape := createsColimitsOfShapeOfNatIso h", "start": [549, 1], "end": [552, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.liftsToLimitOfCreates", "code": "def liftsToLimitOfCreates (K : J \u2964 C) (F : C \u2964 D) [CreatesLimit K F] (c : Cone (K \u22d9 F))\n    (t : IsLimit c) : LiftsToLimit K F c t\n    where\n  liftedCone := liftLimit t\n  validLift := liftedLimitMapsToOriginal t\n  makesLimit := liftedLimitIsLimit t", "start": [556, 1], "end": [562, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.liftsToColimitOfCreates", "code": "def liftsToColimitOfCreates (K : J \u2964 C) (F : C \u2964 D) [CreatesColimit K F] (c : Cocone (K \u22d9 F))\n    (t : IsColimit c) : LiftsToColimit K F c t\n    where\n  liftedCocone := liftColimit t\n  validLift := liftedColimitMapsToOriginal t\n  makesColimit := liftedColimitIsColimit t", "start": [566, 1], "end": [572, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.idLiftsCone", "code": "def idLiftsCone (c : Cone (K \u22d9 \ud835\udfed C)) : LiftableCone K (\ud835\udfed C) c\n    where\n  liftedCone :=\n    { pt := c.pt\n      \u03c0 := c.\u03c0 \u226b K.rightUnitor.hom }\n  validLift := Cones.ext (Iso.refl _)", "start": [575, 1], "end": [581, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.idCreatesLimits", "code": "instance idCreatesLimits : CreatesLimitsOfSize.{w, w'} (\ud835\udfed C) where\n  CreatesLimitsOfShape :=\n    { CreatesLimit := { lifts := fun c _ => idLiftsCone c } }", "start": [584, 1], "end": [587, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.idLiftsCocone", "code": "def idLiftsCocone (c : Cocone (K \u22d9 \ud835\udfed C)) : LiftableCocone K (\ud835\udfed C) c\n    where\n  liftedCocone :=\n    { pt := c.pt\n      \u03b9 := K.rightUnitor.inv \u226b c.\u03b9 }\n  validLift := Cocones.ext (Iso.refl _)", "start": [590, 1], "end": [596, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.idCreatesColimits", "code": "instance idCreatesColimits : CreatesColimitsOfSize.{w, w'} (\ud835\udfed C) where\n  CreatesColimitsOfShape :=\n    { CreatesColimit := { lifts := fun c _ => idLiftsCocone c } }", "start": [599, 1], "end": [602, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.inhabitedLiftableCone", "code": "instance inhabitedLiftableCone (c : Cone (K \u22d9 \ud835\udfed C)) : Inhabited (LiftableCone K (\ud835\udfed C) c) :=\n  \u27e8idLiftsCone c\u27e9", "start": [605, 1], "end": [607, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.inhabitedLiftableCocone", "code": "instance inhabitedLiftableCocone (c : Cocone (K \u22d9 \ud835\udfed C)) : Inhabited (LiftableCocone K (\ud835\udfed C) c) :=\n  \u27e8idLiftsCocone c\u27e9", "start": [610, 1], "end": [611, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.inhabitedLiftsToLimit", "code": "instance inhabitedLiftsToLimit (K : J \u2964 C) (F : C \u2964 D) [CreatesLimit K F] (c : Cone (K \u22d9 F))\n    (t : IsLimit c) : Inhabited (LiftsToLimit _ _ _ t) :=\n  \u27e8liftsToLimitOfCreates K F c t\u27e9", "start": [614, 1], "end": [617, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.inhabitedLiftsToColimit", "code": "instance inhabitedLiftsToColimit (K : J \u2964 C) (F : C \u2964 D) [CreatesColimit K F] (c : Cocone (K \u22d9 F))\n    (t : IsColimit c) : Inhabited (LiftsToColimit _ _ _ t) :=\n  \u27e8liftsToColimitOfCreates K F c t\u27e9", "start": [620, 1], "end": [622, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.compCreatesLimit", "code": "instance compCreatesLimit [CreatesLimit K F] [CreatesLimit (K \u22d9 F) G] :\n    CreatesLimit K (F \u22d9 G) where\n  lifts c t := by\n    let c' : Cone ((K \u22d9 F) \u22d9 G) := c\n    let t' : IsLimit c' := t\n    exact\n      { liftedCone := liftLimit (liftedLimitIsLimit t')\n        validLift := (Cones.functoriality (K \u22d9 F) G).mapIso\n            (liftedLimitMapsToOriginal (liftedLimitIsLimit t')) \u226a\u226b\n          liftedLimitMapsToOriginal t' }", "start": [631, 1], "end": [640, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.compCreatesLimitsOfShape", "code": "instance compCreatesLimitsOfShape [CreatesLimitsOfShape J F] [CreatesLimitsOfShape J G] :\n    CreatesLimitsOfShape J (F \u22d9 G) where CreatesLimit := inferInstance", "start": [643, 1], "end": [644, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.compCreatesLimits", "code": "instance compCreatesLimits [CreatesLimitsOfSize.{w, w'} F] [CreatesLimitsOfSize.{w, w'} G] :\n    CreatesLimitsOfSize.{w, w'} (F \u22d9 G) where CreatesLimitsOfShape := inferInstance", "start": [647, 1], "end": [648, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.compCreatesColimit", "code": "instance compCreatesColimit [CreatesColimit K F] [CreatesColimit (K \u22d9 F) G] :\n    CreatesColimit K (F \u22d9 G) where\n  lifts c t :=\n    let c' : Cocone ((K \u22d9 F) \u22d9 G) := c\n    let t' : IsColimit c' := t\n    { liftedCocone := liftColimit (liftedColimitIsColimit t')\n      validLift :=\n        (Cocones.functoriality (K \u22d9 F) G).mapIso\n            (liftedColimitMapsToOriginal (liftedColimitIsColimit t')) \u226a\u226b\n          liftedColimitMapsToOriginal t' }", "start": [651, 1], "end": [660, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.compCreatesColimitsOfShape", "code": "instance compCreatesColimitsOfShape [CreatesColimitsOfShape J F] [CreatesColimitsOfShape J G] :\n    CreatesColimitsOfShape J (F \u22d9 G) where CreatesColimit := inferInstance", "start": [663, 1], "end": [664, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.compCreatesColimits", "code": "instance compCreatesColimits [CreatesColimitsOfSize.{w, w'} F] [CreatesColimitsOfSize.{w, w'} G] :\n    CreatesColimitsOfSize.{w, w'} (F \u22d9 G) where CreatesColimitsOfShape := inferInstance", "start": [667, 1], "end": [668, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/WidePullbacks.lean", "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.WalkingCospan", "code": "abbrev WalkingCospan : Type :=\n  WidePullbackShape WalkingPair", "start": [36, 1], "end": [39, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingCospan.left", "code": "@[match_pattern]\nabbrev WalkingCospan.left : WalkingCospan :=\n  some WalkingPair.left", "start": [42, 1], "end": [45, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingCospan.right", "code": "@[match_pattern]\nabbrev WalkingCospan.right : WalkingCospan :=\n  some WalkingPair.right", "start": [48, 1], "end": [51, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingCospan.one", "code": "@[match_pattern]\nabbrev WalkingCospan.one : WalkingCospan :=\n  none", "start": [54, 1], "end": [57, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingSpan", "code": "abbrev WalkingSpan : Type :=\n  WidePushoutShape WalkingPair", "start": [60, 1], "end": [64, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingSpan.left", "code": "@[match_pattern]\nabbrev WalkingSpan.left : WalkingSpan :=\n  some WalkingPair.left", "start": [67, 1], "end": [70, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingSpan.right", "code": "@[match_pattern]\nabbrev WalkingSpan.right : WalkingSpan :=\n  some WalkingPair.right", "start": [73, 1], "end": [76, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingSpan.zero", "code": "@[match_pattern]\nabbrev WalkingSpan.zero : WalkingSpan :=\n  none", "start": [79, 1], "end": [82, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingCospan.Hom", "code": "abbrev Hom : WalkingCospan \u2192 WalkingCospan \u2192 Type :=\n  WidePullbackShape.Hom", "start": [87, 1], "end": [89, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingCospan.Hom.inl", "code": "@[match_pattern]\nabbrev Hom.inl : left \u27f6 one :=\n  WidePullbackShape.Hom.term _", "start": [92, 1], "end": [95, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingCospan.Hom.inr", "code": "@[match_pattern]\nabbrev Hom.inr : right \u27f6 one :=\n  WidePullbackShape.Hom.term _", "start": [98, 1], "end": [101, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingCospan.Hom.id", "code": "@[match_pattern]\nabbrev Hom.id (X : WalkingCospan) : X \u27f6 X :=\n  WidePullbackShape.Hom.id X", "start": [104, 1], "end": [107, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingSpan.Hom", "code": "abbrev Hom : WalkingSpan \u2192 WalkingSpan \u2192 Type :=\n  WidePushoutShape.Hom", "start": [116, 1], "end": [118, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingSpan.Hom.fst", "code": "@[match_pattern]\nabbrev Hom.fst : zero \u27f6 left :=\n  WidePushoutShape.Hom.init _", "start": [121, 1], "end": [124, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingSpan.Hom.snd", "code": "@[match_pattern]\nabbrev Hom.snd : zero \u27f6 right :=\n  WidePushoutShape.Hom.init _", "start": [127, 1], "end": [130, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingSpan.Hom.id", "code": "@[match_pattern]\nabbrev Hom.id (X : WalkingSpan) : X \u27f6 X :=\n  WidePushoutShape.Hom.id X", "start": [133, 1], "end": [136, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingCospan.ext", "code": "def WalkingCospan.ext {F : WalkingCospan \u2964 C} {s t : Cone F} (i : s.pt \u2245 t.pt)\n    (w\u2081 : s.\u03c0.app WalkingCospan.left = i.hom \u226b t.\u03c0.app WalkingCospan.left)\n    (w\u2082 : s.\u03c0.app WalkingCospan.right = i.hom \u226b t.\u03c0.app WalkingCospan.right) : s \u2245 t := by\n  apply Cones.ext i _\n  rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9)\n  \u00b7 have h\u2081 := s.\u03c0.naturality WalkingCospan.Hom.inl\n    dsimp at h\u2081\n    simp only [Category.id_comp] at h\u2081\n    have h\u2082 := t.\u03c0.naturality WalkingCospan.Hom.inl\n    dsimp at h\u2082\n    simp only [Category.id_comp] at h\u2082\n    simp_rw [h\u2082, \u2190 Category.assoc, \u2190 w\u2081, \u2190 h\u2081]\n  \u00b7 exact w\u2081\n  \u00b7 exact w\u2082", "start": [147, 1], "end": [163, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingSpan.ext", "code": "def WalkingSpan.ext {F : WalkingSpan \u2964 C} {s t : Cocone F} (i : s.pt \u2245 t.pt)\n    (w\u2081 : s.\u03b9.app WalkingCospan.left \u226b i.hom = t.\u03b9.app WalkingCospan.left)\n    (w\u2082 : s.\u03b9.app WalkingCospan.right \u226b i.hom = t.\u03b9.app WalkingCospan.right) : s \u2245 t := by\n  apply Cocones.ext i _\n  rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9)\n  \u00b7 have h\u2081 := s.\u03b9.naturality WalkingSpan.Hom.fst\n    dsimp at h\u2081\n    simp only [Category.comp_id] at h\u2081\n    have h\u2082 := t.\u03b9.naturality WalkingSpan.Hom.fst\n    dsimp at h\u2082\n    simp only [Category.comp_id] at h\u2082\n    simp_rw [\u2190 h\u2081, Category.assoc, w\u2081, h\u2082]\n  \u00b7 exact w\u2081\n  \u00b7 exact w\u2082", "start": [166, 1], "end": [182, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospan", "code": "def cospan {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) : WalkingCospan \u2964 C :=\n  WidePullbackShape.wideCospan Z (fun j => WalkingPair.casesOn j X Y) fun j =>\n    WalkingPair.casesOn j f g", "start": [185, 1], "end": [188, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.span", "code": "def span {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) : WalkingSpan \u2964 C :=\n  WidePushoutShape.wideSpan X (fun j => WalkingPair.casesOn j Y Z) fun j =>\n    WalkingPair.casesOn j f g", "start": [191, 1], "end": [194, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospan_left", "code": "@[simp]\ntheorem cospan_left {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) : (cospan f g).obj WalkingCospan.left = X", "start": [197, 1], "end": [199, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.span_left", "code": "@[simp]\ntheorem span_left {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) : (span f g).obj WalkingSpan.left = Y", "start": [202, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospan_right", "code": "@[simp]\ntheorem cospan_right {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (cospan f g).obj WalkingCospan.right = Y", "start": [207, 1], "end": [209, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.span_right", "code": "@[simp]\ntheorem span_right {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) : (span f g).obj WalkingSpan.right = Z", "start": [212, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospan_one", "code": "@[simp]\ntheorem cospan_one {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) : (cospan f g).obj WalkingCospan.one = Z", "start": [217, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.span_zero", "code": "@[simp]\ntheorem span_zero {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) : (span f g).obj WalkingSpan.zero = X", "start": [222, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospan_map_inl", "code": "@[simp]\ntheorem cospan_map_inl {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (cospan f g).map WalkingCospan.Hom.inl = f", "start": [227, 1], "end": [229, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.span_map_fst", "code": "@[simp]\ntheorem span_map_fst {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) : (span f g).map WalkingSpan.Hom.fst = f", "start": [232, 1], "end": [234, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospan_map_inr", "code": "@[simp]\ntheorem cospan_map_inr {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (cospan f g).map WalkingCospan.Hom.inr = g", "start": [237, 1], "end": [239, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.span_map_snd", "code": "@[simp]\ntheorem span_map_snd {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) : (span f g).map WalkingSpan.Hom.snd = g", "start": [242, 1], "end": [244, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospan_map_id", "code": "theorem cospan_map_id {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) (w : WalkingCospan) :\n    (cospan f g).map (WalkingCospan.Hom.id w) = \ud835\udfd9 _", "start": [247, 1], "end": [248, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.span_map_id", "code": "theorem span_map_id {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) (w : WalkingSpan) :\n    (span f g).map (WalkingSpan.Hom.id w) = \ud835\udfd9 _", "start": [251, 1], "end": [252, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.diagramIsoCospan", "code": "@[simps!]\ndef diagramIsoCospan (F : WalkingCospan \u2964 C) : F \u2245 cospan (F.map inl) (F.map inr) :=\n  NatIso.ofComponents\n  (fun j => eqToIso (by rcases j with (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) <;> rfl))\n  (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) f <;> cases f <;> dsimp <;> simp)", "start": [255, 1], "end": [261, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.diagramIsoSpan", "code": "@[simps!]\ndef diagramIsoSpan (F : WalkingSpan \u2964 C) : F \u2245 span (F.map fst) (F.map snd) :=\n  NatIso.ofComponents\n  (fun j => eqToIso (by rcases j with (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) <;> rfl))\n  (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) f <;> cases f <;> dsimp <;> simp)", "start": [264, 1], "end": [270, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanCompIso", "code": "def cospanCompIso (F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    cospan f g \u22d9 F \u2245 cospan (F.map f) (F.map g) :=\n  NatIso.ofComponents (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) <;> exact Iso.refl _)\n    (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) f <;> cases f <;> dsimp <;> simp)", "start": [275, 1], "end": [279, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanCompIso_app_left", "code": "@[simp]\ntheorem cospanCompIso_app_left : (cospanCompIso F f g).app WalkingCospan.left = Iso.refl _", "start": [286, 1], "end": [287, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanCompIso_app_right", "code": "@[simp]\ntheorem cospanCompIso_app_right : (cospanCompIso F f g).app WalkingCospan.right = Iso.refl _", "start": [290, 1], "end": [292, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanCompIso_app_one", "code": "@[simp]\ntheorem cospanCompIso_app_one : (cospanCompIso F f g).app WalkingCospan.one = Iso.refl _", "start": [295, 1], "end": [296, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanCompIso_hom_app_left", "code": "@[simp]\ntheorem cospanCompIso_hom_app_left : (cospanCompIso F f g).hom.app WalkingCospan.left = \ud835\udfd9 _", "start": [299, 1], "end": [301, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanCompIso_hom_app_right", "code": "@[simp]\ntheorem cospanCompIso_hom_app_right : (cospanCompIso F f g).hom.app WalkingCospan.right = \ud835\udfd9 _", "start": [304, 1], "end": [306, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanCompIso_hom_app_one", "code": "@[simp]\ntheorem cospanCompIso_hom_app_one : (cospanCompIso F f g).hom.app WalkingCospan.one = \ud835\udfd9 _", "start": [309, 1], "end": [310, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanCompIso_inv_app_left", "code": "@[simp]\ntheorem cospanCompIso_inv_app_left : (cospanCompIso F f g).inv.app WalkingCospan.left = \ud835\udfd9 _", "start": [313, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanCompIso_inv_app_right", "code": "@[simp]\ntheorem cospanCompIso_inv_app_right : (cospanCompIso F f g).inv.app WalkingCospan.right = \ud835\udfd9 _", "start": [318, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanCompIso_inv_app_one", "code": "@[simp]\ntheorem cospanCompIso_inv_app_one : (cospanCompIso F f g).inv.app WalkingCospan.one = \ud835\udfd9 _", "start": [323, 1], "end": [324, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanCompIso", "code": "def spanCompIso (F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) :\n    span f g \u22d9 F \u2245 span (F.map f) (F.map g) :=\n  NatIso.ofComponents (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) <;> exact Iso.refl _)\n    (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) f <;> cases f <;> dsimp <;> simp)", "start": [329, 1], "end": [333, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanCompIso_app_left", "code": "@[simp]\ntheorem spanCompIso_app_left : (spanCompIso F f g).app WalkingSpan.left = Iso.refl _", "start": [340, 1], "end": [341, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanCompIso_app_right", "code": "@[simp]\ntheorem spanCompIso_app_right : (spanCompIso F f g).app WalkingSpan.right = Iso.refl _", "start": [344, 1], "end": [345, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanCompIso_app_zero", "code": "@[simp]\ntheorem spanCompIso_app_zero : (spanCompIso F f g).app WalkingSpan.zero = Iso.refl _", "start": [348, 1], "end": [349, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanCompIso_hom_app_left", "code": "@[simp]\ntheorem spanCompIso_hom_app_left : (spanCompIso F f g).hom.app WalkingSpan.left = \ud835\udfd9 _", "start": [352, 1], "end": [353, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanCompIso_hom_app_right", "code": "@[simp]\ntheorem spanCompIso_hom_app_right : (spanCompIso F f g).hom.app WalkingSpan.right = \ud835\udfd9 _", "start": [356, 1], "end": [357, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanCompIso_hom_app_zero", "code": "@[simp]\ntheorem spanCompIso_hom_app_zero : (spanCompIso F f g).hom.app WalkingSpan.zero = \ud835\udfd9 _", "start": [360, 1], "end": [361, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanCompIso_inv_app_left", "code": "@[simp]\ntheorem spanCompIso_inv_app_left : (spanCompIso F f g).inv.app WalkingSpan.left = \ud835\udfd9 _", "start": [364, 1], "end": [365, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanCompIso_inv_app_right", "code": "@[simp]\ntheorem spanCompIso_inv_app_right : (spanCompIso F f g).inv.app WalkingSpan.right = \ud835\udfd9 _", "start": [368, 1], "end": [369, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanCompIso_inv_app_zero", "code": "@[simp]\ntheorem spanCompIso_inv_app_zero : (spanCompIso F f g).inv.app WalkingSpan.zero = \ud835\udfd9 _", "start": [372, 1], "end": [373, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanExt", "code": "def cospanExt (wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom) :\n    cospan f g \u2245 cospan f' g' :=\n  NatIso.ofComponents\n    (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9); exacts [iZ, iX, iY])\n    (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) f <;> cases f <;> dsimp <;> simp [wf, wg])", "start": [386, 1], "end": [391, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanExt_app_left", "code": "@[simp]\ntheorem cospanExt_app_left : (cospanExt iX iY iZ wf wg).app WalkingCospan.left = iX", "start": [396, 1], "end": [398, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanExt_app_right", "code": "@[simp]\ntheorem cospanExt_app_right : (cospanExt iX iY iZ wf wg).app WalkingCospan.right = iY", "start": [401, 1], "end": [403, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanExt_app_one", "code": "@[simp]\ntheorem cospanExt_app_one : (cospanExt iX iY iZ wf wg).app WalkingCospan.one = iZ", "start": [406, 1], "end": [408, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanExt_hom_app_left", "code": "@[simp]\ntheorem cospanExt_hom_app_left : (cospanExt iX iY iZ wf wg).hom.app WalkingCospan.left = iX.hom", "start": [411, 1], "end": [413, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanExt_hom_app_right", "code": "@[simp]\ntheorem cospanExt_hom_app_right : (cospanExt iX iY iZ wf wg).hom.app WalkingCospan.right = iY.hom", "start": [416, 1], "end": [418, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanExt_hom_app_one", "code": "@[simp]\ntheorem cospanExt_hom_app_one : (cospanExt iX iY iZ wf wg).hom.app WalkingCospan.one = iZ.hom", "start": [421, 1], "end": [423, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanExt_inv_app_left", "code": "@[simp]\ntheorem cospanExt_inv_app_left : (cospanExt iX iY iZ wf wg).inv.app WalkingCospan.left = iX.inv", "start": [426, 1], "end": [428, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanExt_inv_app_right", "code": "@[simp]\ntheorem cospanExt_inv_app_right : (cospanExt iX iY iZ wf wg).inv.app WalkingCospan.right = iY.inv", "start": [431, 1], "end": [433, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanExt_inv_app_one", "code": "@[simp]\ntheorem cospanExt_inv_app_one : (cospanExt iX iY iZ wf wg).inv.app WalkingCospan.one = iZ.inv", "start": [436, 1], "end": [438, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanExt", "code": "def spanExt (wf : iX.hom \u226b f' = f \u226b iY.hom) (wg : iX.hom \u226b g' = g \u226b iZ.hom) :\n    span f g \u2245 span f' g' :=\n  NatIso.ofComponents (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9); exacts [iX, iY, iZ])\n    (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) f <;> cases f <;> dsimp <;> simp [wf, wg])", "start": [447, 1], "end": [451, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanExt_app_left", "code": "@[simp]\ntheorem spanExt_app_left : (spanExt iX iY iZ wf wg).app WalkingSpan.left = iY", "start": [456, 1], "end": [458, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanExt_app_right", "code": "@[simp]\ntheorem spanExt_app_right : (spanExt iX iY iZ wf wg).app WalkingSpan.right = iZ", "start": [461, 1], "end": [463, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanExt_app_one", "code": "@[simp]\ntheorem spanExt_app_one : (spanExt iX iY iZ wf wg).app WalkingSpan.zero = iX", "start": [466, 1], "end": [468, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanExt_hom_app_left", "code": "@[simp]\ntheorem spanExt_hom_app_left : (spanExt iX iY iZ wf wg).hom.app WalkingSpan.left = iY.hom", "start": [471, 1], "end": [473, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanExt_hom_app_right", "code": "@[simp]\ntheorem spanExt_hom_app_right : (spanExt iX iY iZ wf wg).hom.app WalkingSpan.right = iZ.hom", "start": [476, 1], "end": [478, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanExt_hom_app_zero", "code": "@[simp]\ntheorem spanExt_hom_app_zero : (spanExt iX iY iZ wf wg).hom.app WalkingSpan.zero = iX.hom", "start": [481, 1], "end": [483, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanExt_inv_app_left", "code": "@[simp]\ntheorem spanExt_inv_app_left : (spanExt iX iY iZ wf wg).inv.app WalkingSpan.left = iY.inv", "start": [486, 1], "end": [488, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanExt_inv_app_right", "code": "@[simp]\ntheorem spanExt_inv_app_right : (spanExt iX iY iZ wf wg).inv.app WalkingSpan.right = iZ.inv", "start": [491, 1], "end": [493, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanExt_inv_app_zero", "code": "@[simp]\ntheorem spanExt_inv_app_zero : (spanExt iX iY iZ wf wg).inv.app WalkingSpan.zero = iX.inv", "start": [496, 1], "end": [498, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone", "code": "abbrev PullbackCone (f : X \u27f6 Z) (g : Y \u27f6 Z) :=\n  Cone (cospan f g)", "start": [507, 1], "end": [510, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.fst", "code": "abbrev fst (t : PullbackCone f g) : t.pt \u27f6 X :=\n  t.\u03c0.app WalkingCospan.left", "start": [517, 1], "end": [519, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.snd", "code": "abbrev snd (t : PullbackCone f g) : t.pt \u27f6 Y :=\n  t.\u03c0.app WalkingCospan.right", "start": [522, 1], "end": [524, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.\u03c0_app_left", "code": "@[simp]\ntheorem \u03c0_app_left (c : PullbackCone f g) : c.\u03c0.app WalkingCospan.left = c.fst", "start": [527, 1], "end": [528, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.\u03c0_app_right", "code": "@[simp]\ntheorem \u03c0_app_right (c : PullbackCone f g) : c.\u03c0.app WalkingCospan.right = c.snd", "start": [531, 1], "end": [532, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.condition_one", "code": "@[simp]\ntheorem condition_one (t : PullbackCone f g) : t.\u03c0.app WalkingCospan.one = t.fst \u226b f", "start": [535, 1], "end": [538, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.isLimitAux", "code": "def isLimitAux (t : PullbackCone f g) (lift : \u2200 s : PullbackCone f g, s.pt \u27f6 t.pt)\n    (fac_left : \u2200 s : PullbackCone f g, lift s \u226b t.fst = s.fst)\n    (fac_right : \u2200 s : PullbackCone f g, lift s \u226b t.snd = s.snd)\n    (uniq : \u2200 (s : PullbackCone f g) (m : s.pt \u27f6 t.pt)\n      (_ : \u2200 j : WalkingCospan, m \u226b t.\u03c0.app j = s.\u03c0.app j), m = lift s) : IsLimit t :=\n  { lift\n    fac := fun s j => Option.casesOn j (by\n        rw [\u2190 s.w inl, \u2190 t.w inl, \u2190 Category.assoc]\n        congr\n        exact fac_left s)\n      fun j' => WalkingPair.casesOn j' (fac_left s) (fac_right s)\n    uniq := uniq }", "start": [541, 1], "end": [554, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.isLimitAux'", "code": "def isLimitAux' (t : PullbackCone f g)\n    (create :\n      \u2200 s : PullbackCone f g,\n        { l //\n          l \u226b t.fst = s.fst \u2227\n            l \u226b t.snd = s.snd \u2227 \u2200 {m}, m \u226b t.fst = s.fst \u2192 m \u226b t.snd = s.snd \u2192 m = l }) :\n    Limits.IsLimit t :=\n  PullbackCone.isLimitAux t (fun s => (create s).1) (fun s => (create s).2.1)\n    (fun s => (create s).2.2.1) fun s _ w =>\n    (create s).2.2.2 (w WalkingCospan.left) (w WalkingCospan.right)", "start": [557, 1], "end": [569, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.mk", "code": "@[simps]\ndef mk {W : C} (fst : W \u27f6 X) (snd : W \u27f6 Y) (eq : fst \u226b f = snd \u226b g) : PullbackCone f g where\n  pt := W\n  \u03c0 := { app := fun j => Option.casesOn j (fst \u226b f) fun j' => WalkingPair.casesOn j' fst snd\n         naturality := by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) j <;> cases j <;> dsimp <;> simp [eq] }", "start": [572, 1], "end": [578, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.mk_\u03c0_app_left", "code": "@[simp]\ntheorem mk_\u03c0_app_left {W : C} (fst : W \u27f6 X) (snd : W \u27f6 Y) (eq : fst \u226b f = snd \u226b g) :\n    (mk fst snd eq).\u03c0.app WalkingCospan.left = fst", "start": [581, 1], "end": [583, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.mk_\u03c0_app_right", "code": "@[simp]\ntheorem mk_\u03c0_app_right {W : C} (fst : W \u27f6 X) (snd : W \u27f6 Y) (eq : fst \u226b f = snd \u226b g) :\n    (mk fst snd eq).\u03c0.app WalkingCospan.right = snd", "start": [586, 1], "end": [588, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.mk_\u03c0_app_one", "code": "@[simp]\ntheorem mk_\u03c0_app_one {W : C} (fst : W \u27f6 X) (snd : W \u27f6 Y) (eq : fst \u226b f = snd \u226b g) :\n    (mk fst snd eq).\u03c0.app WalkingCospan.one = fst \u226b f", "start": [591, 1], "end": [593, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.mk_fst", "code": "@[simp]\ntheorem mk_fst {W : C} (fst : W \u27f6 X) (snd : W \u27f6 Y) (eq : fst \u226b f = snd \u226b g) :\n    (mk fst snd eq).fst = fst", "start": [596, 1], "end": [598, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.mk_snd", "code": "@[simp]\ntheorem mk_snd {W : C} (fst : W \u27f6 X) (snd : W \u27f6 Y) (eq : fst \u226b f = snd \u226b g) :\n    (mk fst snd eq).snd = snd", "start": [601, 1], "end": [603, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.condition", "code": "@[reassoc]\ntheorem condition (t : PullbackCone f g) : fst t \u226b f = snd t \u226b g", "start": [606, 1], "end": [608, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.equalizer_ext", "code": "theorem equalizer_ext (t : PullbackCone f g) {W : C} {k l : W \u27f6 t.pt} (h\u2080 : k \u226b fst t = l \u226b fst t)\n    (h\u2081 : k \u226b snd t = l \u226b snd t) : \u2200 j : WalkingCospan, k \u226b t.\u03c0.app j = l \u226b t.\u03c0.app j", "start": [611, 1], "end": [617, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.IsLimit.hom_ext", "code": "theorem IsLimit.hom_ext {t : PullbackCone f g} (ht : IsLimit t) {W : C} {k l : W \u27f6 t.pt}\n    (h\u2080 : k \u226b fst t = l \u226b fst t) (h\u2081 : k \u226b snd t = l \u226b snd t) : k = l", "start": [620, 1], "end": [622, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.mono_snd_of_is_pullback_of_mono", "code": "theorem mono_snd_of_is_pullback_of_mono {t : PullbackCone f g} (ht : IsLimit t) [Mono f] :\n    Mono t.snd", "start": [625, 1], "end": [630, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.mono_fst_of_is_pullback_of_mono", "code": "theorem mono_fst_of_is_pullback_of_mono {t : PullbackCone f g} (ht : IsLimit t) [Mono g] :\n    Mono t.fst", "start": [633, 1], "end": [638, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.ext", "code": "def ext {s t : PullbackCone f g} (i : s.pt \u2245 t.pt) (w\u2081 : s.fst = i.hom \u226b t.fst)\n    (w\u2082 : s.snd = i.hom \u226b t.snd) : s \u2245 t :=\n  WalkingCospan.ext i w\u2081 w\u2082", "start": [641, 1], "end": [645, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.IsLimit.lift", "code": "def IsLimit.lift {t : PullbackCone f g} (ht : IsLimit t) {W : C} (h : W \u27f6 X) (k : W \u27f6 Y)\n    (w : h \u226b f = k \u226b g) : W \u27f6 t.pt :=\n  ht.lift <| PullbackCone.mk _ _ w", "start": [649, 1], "end": [654, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.IsLimit.lift_fst", "code": "@[reassoc (attr := simp)]\nlemma IsLimit.lift_fst {t : PullbackCone f g} (ht : IsLimit t) {W : C} (h : W \u27f6 X) (k : W \u27f6 Y)\n    (w : h \u226b f = k \u226b g) : IsLimit.lift ht h k w \u226b fst t = h := ht.fac _ _", "start": [656, 1], "end": [658, 74], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.PullbackCone.IsLimit.lift_snd", "code": "@[reassoc (attr := simp)]\nlemma IsLimit.lift_snd {t : PullbackCone f g} (ht : IsLimit t) {W : C} (h : W \u27f6 X) (k : W \u27f6 Y)\n    (w : h \u226b f = k \u226b g) : IsLimit.lift ht h k w \u226b snd t = k := ht.fac _ _", "start": [660, 1], "end": [662, 74], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.PullbackCone.IsLimit.lift'", "code": "def IsLimit.lift' {t : PullbackCone f g} (ht : IsLimit t) {W : C} (h : W \u27f6 X) (k : W \u27f6 Y)\n    (w : h \u226b f = k \u226b g) : { l : W \u27f6 t.pt // l \u226b fst t = h \u2227 l \u226b snd t = k } :=\n  \u27e8IsLimit.lift ht h k w, by simp\u27e9", "start": [664, 1], "end": [669, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.IsLimit.mk", "code": "def IsLimit.mk {W : C} {fst : W \u27f6 X} {snd : W \u27f6 Y} (eq : fst \u226b f = snd \u226b g)\n    (lift : \u2200 s : PullbackCone f g, s.pt \u27f6 W)\n    (fac_left : \u2200 s : PullbackCone f g, lift s \u226b fst = s.fst)\n    (fac_right : \u2200 s : PullbackCone f g, lift s \u226b snd = s.snd)\n    (uniq :\n      \u2200 (s : PullbackCone f g) (m : s.pt \u27f6 W) (_ : m \u226b fst = s.fst) (_ : m \u226b snd = s.snd),\n        m = lift s) :\n    IsLimit (mk fst snd eq) :=\n  isLimitAux _ lift fac_left fac_right fun s m w =>\n    uniq s m (w WalkingCospan.left) (w WalkingCospan.right)", "start": [672, 1], "end": [684, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.flipIsLimit", "code": "def flipIsLimit {W : C} {h : W \u27f6 X} {k : W \u27f6 Y} {comm : h \u226b f = k \u226b g}\n    (t : IsLimit (mk _ _ comm.symm)) : IsLimit (mk _ _ comm) :=\n  isLimitAux' _ fun s => by\n    refine'\n      \u27e8(IsLimit.lift' t _ _ s.condition.symm).1, (IsLimit.lift' t _ _ _).2.2,\n        (IsLimit.lift' t _ _ _).2.1, fun m\u2081 m\u2082 => t.hom_ext _\u27e9\n    apply (mk k h _).equalizer_ext\n    \u00b7 rwa [(IsLimit.lift' t _ _ _).2.1]\n    \u00b7 rwa [(IsLimit.lift' t _ _ _).2.2]", "start": [687, 1], "end": [696, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.isLimitMkIdId", "code": "def isLimitMkIdId (f : X \u27f6 Y) [Mono f] : IsLimit (mk (\ud835\udfd9 X) (\ud835\udfd9 X) rfl : PullbackCone f f) :=\n  IsLimit.mk _ (fun s => s.fst) (fun s => Category.comp_id _)\n    (fun s => by rw [\u2190 cancel_mono f, Category.comp_id, s.condition]) fun s m m\u2081 _ => by\n    simpa using m\u2081", "start": [699, 1], "end": [706, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.mono_of_isLimitMkIdId", "code": "theorem mono_of_isLimitMkIdId (f : X \u27f6 Y) (t : IsLimit (mk (\ud835\udfd9 X) (\ud835\udfd9 X) rfl : PullbackCone f f)) :\n    Mono f", "start": [709, 1], "end": [717, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.isLimitOfFactors", "code": "def isLimitOfFactors (f : X \u27f6 Z) (g : Y \u27f6 Z) (h : W \u27f6 Z) [Mono h] (x : X \u27f6 W) (y : Y \u27f6 W)\n    (hxh : x \u226b h = f) (hyh : y \u226b h = g) (s : PullbackCone f g) (hs : IsLimit s) :\n    IsLimit\n      (PullbackCone.mk _ _\n        (show s.fst \u226b x = s.snd \u226b y from\n          (cancel_mono h).1 <| by simp only [Category.assoc, hxh, hyh, s.condition])) :=\n  PullbackCone.isLimitAux' _ fun t =>\n    have : fst t \u226b x \u226b h = snd t \u226b y \u226b h := by  rw [\u2190 Category.assoc, \u2190 Category.assoc]\n      apply congrArg (\u00b7 \u226b h) t.condition\n    \u27e8hs.lift (PullbackCone.mk t.fst t.snd <| by rw [\u2190 hxh, \u2190 hyh, this]),\n      \u27e8hs.fac _ WalkingCospan.left, hs.fac _ WalkingCospan.right, fun hr hr' => by\n        apply PullbackCone.IsLimit.hom_ext hs <;>\n              simp only [PullbackCone.mk_fst, PullbackCone.mk_snd] at hr hr' \u22a2 <;>\n            simp only [hr, hr'] <;>\n          symm\n        exacts [hs.fac _ WalkingCospan.left, hs.fac _ WalkingCospan.right]\u27e9\u27e9", "start": [720, 1], "end": [740, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.isLimitOfCompMono", "code": "def isLimitOfCompMono (f : X \u27f6 W) (g : Y \u27f6 W) (i : W \u27f6 Z) [Mono i] (s : PullbackCone f g)\n    (H : IsLimit s) :\n    IsLimit\n      (PullbackCone.mk _ _\n        (show s.fst \u226b f \u226b i = s.snd \u226b g \u226b i by\n          rw [\u2190 Category.assoc, \u2190 Category.assoc, s.condition])) := by\n  apply PullbackCone.isLimitAux'\n  intro s\n  rcases PullbackCone.IsLimit.lift' H s.fst s.snd\n      ((cancel_mono i).mp (by simpa using s.condition)) with\n    \u27e8l, h\u2081, h\u2082\u27e9\n  refine' \u27e8l, h\u2081, h\u2082, _\u27e9\n  intro m hm\u2081 hm\u2082\n  exact (PullbackCone.IsLimit.hom_ext H (hm\u2081.trans h\u2081.symm) (hm\u2082.trans h\u2082.symm) : _)", "start": [743, 1], "end": [758, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone", "code": "abbrev PushoutCocone (f : X \u27f6 Y) (g : X \u27f6 Z) :=\n  Cocone (span f g)", "start": [763, 1], "end": [766, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.inl", "code": "abbrev inl (t : PushoutCocone f g) : Y \u27f6 t.pt :=\n  t.\u03b9.app WalkingSpan.left", "start": [773, 1], "end": [775, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.inr", "code": "abbrev inr (t : PushoutCocone f g) : Z \u27f6 t.pt :=\n  t.\u03b9.app WalkingSpan.right", "start": [778, 1], "end": [780, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.\u03b9_app_left", "code": "@[simp]\ntheorem \u03b9_app_left (c : PushoutCocone f g) : c.\u03b9.app WalkingSpan.left = c.inl", "start": [783, 1], "end": [784, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.\u03b9_app_right", "code": "@[simp]\ntheorem \u03b9_app_right (c : PushoutCocone f g) : c.\u03b9.app WalkingSpan.right = c.inr", "start": [787, 1], "end": [788, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.condition_zero", "code": "@[simp]\ntheorem condition_zero (t : PushoutCocone f g) : t.\u03b9.app WalkingSpan.zero = f \u226b t.inl", "start": [791, 1], "end": [794, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.isColimitAux", "code": "def isColimitAux (t : PushoutCocone f g) (desc : \u2200 s : PushoutCocone f g, t.pt \u27f6 s.pt)\n    (fac_left : \u2200 s : PushoutCocone f g, t.inl \u226b desc s = s.inl)\n    (fac_right : \u2200 s : PushoutCocone f g, t.inr \u226b desc s = s.inr)\n    (uniq : \u2200 (s : PushoutCocone f g) (m : t.pt \u27f6 s.pt)\n    (_ : \u2200 j : WalkingSpan, t.\u03b9.app j \u226b m = s.\u03b9.app j), m = desc s) : IsColimit t :=\n  { desc\n    fac := fun s j =>\n      Option.casesOn j (by simp [\u2190 s.w fst, \u2190 t.w fst, fac_left s]) fun j' =>\n        WalkingPair.casesOn j' (fac_left s) (fac_right s)\n    uniq := uniq }", "start": [797, 1], "end": [808, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.isColimitAux'", "code": "def isColimitAux' (t : PushoutCocone f g)\n    (create :\n      \u2200 s : PushoutCocone f g,\n        { l //\n          t.inl \u226b l = s.inl \u2227\n            t.inr \u226b l = s.inr \u2227 \u2200 {m}, t.inl \u226b m = s.inl \u2192 t.inr \u226b m = s.inr \u2192 m = l }) :\n    IsColimit t :=\n  isColimitAux t (fun s => (create s).1) (fun s => (create s).2.1) (fun s => (create s).2.2.1)\n    fun s _ w => (create s).2.2.2 (w WalkingCospan.left) (w WalkingCospan.right)", "start": [811, 1], "end": [822, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.mk", "code": "@[simps]\ndef mk {W : C} (inl : Y \u27f6 W) (inr : Z \u27f6 W) (eq : f \u226b inl = g \u226b inr) : PushoutCocone f g where\n  pt := W\n  \u03b9 := { app := fun j => Option.casesOn j (f \u226b inl) fun j' => WalkingPair.casesOn j' inl inr\n         naturality := by\n          rintro (\u27e8\u27e9|\u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9|\u27e8\u27e8\u27e9\u27e9) <;> intro f <;> cases f <;> dsimp <;> aesop }", "start": [825, 1], "end": [832, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.mk_\u03b9_app_left", "code": "@[simp]\ntheorem mk_\u03b9_app_left {W : C} (inl : Y \u27f6 W) (inr : Z \u27f6 W) (eq : f \u226b inl = g \u226b inr) :\n    (mk inl inr eq).\u03b9.app WalkingSpan.left = inl", "start": [835, 1], "end": [837, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.mk_\u03b9_app_right", "code": "@[simp]\ntheorem mk_\u03b9_app_right {W : C} (inl : Y \u27f6 W) (inr : Z \u27f6 W) (eq : f \u226b inl = g \u226b inr) :\n    (mk inl inr eq).\u03b9.app WalkingSpan.right = inr", "start": [840, 1], "end": [842, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.mk_\u03b9_app_zero", "code": "@[simp]\ntheorem mk_\u03b9_app_zero {W : C} (inl : Y \u27f6 W) (inr : Z \u27f6 W) (eq : f \u226b inl = g \u226b inr) :\n    (mk inl inr eq).\u03b9.app WalkingSpan.zero = f \u226b inl", "start": [845, 1], "end": [847, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.mk_inl", "code": "@[simp]\ntheorem mk_inl {W : C} (inl : Y \u27f6 W) (inr : Z \u27f6 W) (eq : f \u226b inl = g \u226b inr) :\n    (mk inl inr eq).inl = inl", "start": [850, 1], "end": [852, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.mk_inr", "code": "@[simp]\ntheorem mk_inr {W : C} (inl : Y \u27f6 W) (inr : Z \u27f6 W) (eq : f \u226b inl = g \u226b inr) :\n    (mk inl inr eq).inr = inr", "start": [855, 1], "end": [857, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.condition", "code": "@[reassoc]\ntheorem condition (t : PushoutCocone f g) : f \u226b inl t = g \u226b inr t", "start": [860, 1], "end": [862, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.coequalizer_ext", "code": "theorem coequalizer_ext (t : PushoutCocone f g) {W : C} {k l : t.pt \u27f6 W}\n    (h\u2080 : inl t \u226b k = inl t \u226b l) (h\u2081 : inr t \u226b k = inr t \u226b l) :\n    \u2200 j : WalkingSpan, t.\u03b9.app j \u226b k = t.\u03b9.app j \u226b l", "start": [865, 1], "end": [872, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.IsColimit.hom_ext", "code": "theorem IsColimit.hom_ext {t : PushoutCocone f g} (ht : IsColimit t) {W : C} {k l : t.pt \u27f6 W}\n    (h\u2080 : inl t \u226b k = inl t \u226b l) (h\u2081 : inr t \u226b k = inr t \u226b l) : k = l", "start": [875, 1], "end": [877, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.IsColimit.desc", "code": "def IsColimit.desc {t : PushoutCocone f g} (ht : IsColimit t) {W : C} (h : Y \u27f6 W) (k : Z \u27f6 W)\n    (w : f \u226b h = g \u226b k) : t.pt \u27f6 W :=\n  ht.desc (PushoutCocone.mk _ _ w)", "start": [881, 1], "end": [886, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.IsColimit.inl_desc", "code": "@[reassoc (attr := simp)]\nlemma IsColimit.inl_desc {t : PushoutCocone f g} (ht : IsColimit t) {W : C} (h : Y \u27f6 W) (k : Z \u27f6 W)\n    (w : f \u226b h = g \u226b k) : inl t \u226b IsColimit.desc ht h k w = h :=\n  ht.fac _ _", "start": [888, 1], "end": [891, 13], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.IsColimit.inr_desc", "code": "@[reassoc (attr := simp)]\nlemma IsColimit.inr_desc {t : PushoutCocone f g} (ht : IsColimit t) {W : C} (h : Y \u27f6 W) (k : Z \u27f6 W)\n    (w : f \u226b h = g \u226b k) : inr t \u226b IsColimit.desc ht h k w = k :=\n  ht.fac _ _", "start": [893, 1], "end": [896, 13], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.IsColimit.desc'", "code": "def IsColimit.desc' {t : PushoutCocone f g} (ht : IsColimit t) {W : C} (h : Y \u27f6 W) (k : Z \u27f6 W)\n    (w : f \u226b h = g \u226b k) : { l : t.pt \u27f6 W // inl t \u226b l = h \u2227 inr t \u226b l = k } :=\n  \u27e8IsColimit.desc ht h k w, by simp\u27e9", "start": [898, 1], "end": [903, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.epi_inr_of_is_pushout_of_epi", "code": "theorem epi_inr_of_is_pushout_of_epi {t : PushoutCocone f g} (ht : IsColimit t) [Epi f] :\n    Epi t.inr", "start": [906, 1], "end": [908, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.epi_inl_of_is_pushout_of_epi", "code": "theorem epi_inl_of_is_pushout_of_epi {t : PushoutCocone f g} (ht : IsColimit t) [Epi g] :\n    Epi t.inl", "start": [911, 1], "end": [913, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.ext", "code": "def ext {s t : PushoutCocone f g} (i : s.pt \u2245 t.pt) (w\u2081 : s.inl \u226b i.hom = t.inl)\n    (w\u2082 : s.inr \u226b i.hom = t.inr) : s \u2245 t :=\n  WalkingSpan.ext i w\u2081 w\u2082", "start": [916, 1], "end": [920, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.IsColimit.mk", "code": "def IsColimit.mk {W : C} {inl : Y \u27f6 W} {inr : Z \u27f6 W} (eq : f \u226b inl = g \u226b inr)\n    (desc : \u2200 s : PushoutCocone f g, W \u27f6 s.pt)\n    (fac_left : \u2200 s : PushoutCocone f g, inl \u226b desc s = s.inl)\n    (fac_right : \u2200 s : PushoutCocone f g, inr \u226b desc s = s.inr)\n    (uniq :\n      \u2200 (s : PushoutCocone f g) (m : W \u27f6 s.pt) (_ : inl \u226b m = s.inl) (_ : inr \u226b m = s.inr),\n        m = desc s) :\n    IsColimit (mk inl inr eq) :=\n  isColimitAux _ desc fac_left fac_right fun s m w =>\n    uniq s m (w WalkingCospan.left) (w WalkingCospan.right)", "start": [923, 1], "end": [935, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.flipIsColimit", "code": "def flipIsColimit {W : C} {h : Y \u27f6 W} {k : Z \u27f6 W} {comm : f \u226b h = g \u226b k}\n    (t : IsColimit (mk _ _ comm.symm)) : IsColimit (mk _ _ comm) :=\n  isColimitAux' _ fun s => by\n    refine'\n      \u27e8(IsColimit.desc' t _ _ s.condition.symm).1, (IsColimit.desc' t _ _ _).2.2,\n        (IsColimit.desc' t _ _ _).2.1, fun m\u2081 m\u2082 => t.hom_ext _\u27e9\n    apply (mk k h _).coequalizer_ext\n    \u00b7 rwa [(IsColimit.desc' t _ _ _).2.1]\n    \u00b7 rwa [(IsColimit.desc' t _ _ _).2.2]", "start": [938, 1], "end": [947, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.isColimitMkIdId", "code": "def isColimitMkIdId (f : X \u27f6 Y) [Epi f] : IsColimit (mk (\ud835\udfd9 Y) (\ud835\udfd9 Y) rfl : PushoutCocone f f) :=\n  IsColimit.mk _ (fun s => s.inl) (fun s => Category.id_comp _)\n    (fun s => by rw [\u2190 cancel_epi f, Category.id_comp, s.condition]) fun s m m\u2081 _ => by\n    simpa using m\u2081", "start": [950, 1], "end": [957, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.epi_of_isColimitMkIdId", "code": "theorem epi_of_isColimitMkIdId (f : X \u27f6 Y)\n    (t : IsColimit (mk (\ud835\udfd9 Y) (\ud835\udfd9 Y) rfl : PushoutCocone f f)) : Epi f", "start": [960, 1], "end": [967, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.isColimitOfFactors", "code": "def isColimitOfFactors (f : X \u27f6 Y) (g : X \u27f6 Z) (h : X \u27f6 W) [Epi h] (x : W \u27f6 Y) (y : W \u27f6 Z)\n    (hhx : h \u226b x = f) (hhy : h \u226b y = g) (s : PushoutCocone f g) (hs : IsColimit s) :\n    have reassoc\u2081 : h \u226b x \u226b inl s = f \u226b inl s := by  rw [\u2190 Category.assoc]; apply congrArg (\u00b7 \u226b inl s) hhx\n    have reassoc\u2082 : h \u226b y \u226b inr s = g \u226b inr s := by\n      rw [\u2190 Category.assoc]; apply congrArg (\u00b7 \u226b inr s) hhy\n    IsColimit (PushoutCocone.mk _ _ (show x \u226b s.inl = y \u226b s.inr from\n          (cancel_epi h).1 <| by rw [reassoc\u2081, reassoc\u2082, s.condition])) :=\n  PushoutCocone.isColimitAux' _ fun t => \u27e8hs.desc (PushoutCocone.mk t.inl t.inr <| by\n    rw [\u2190 hhx, \u2190 hhy, Category.assoc, Category.assoc, t.condition]),\n      \u27e8hs.fac _ WalkingSpan.left, hs.fac _ WalkingSpan.right, fun hr hr' => by\n        apply PushoutCocone.IsColimit.hom_ext hs;\n        \u00b7 simp only [PushoutCocone.mk_inl, PushoutCocone.mk_inr] at hr hr' \u22a2\n          simp only [hr, hr']\n          symm\n          exact hs.fac _ WalkingSpan.left\n        \u00b7 simp only [PushoutCocone.mk_inl, PushoutCocone.mk_inr] at hr hr' \u22a2\n          simp only [hr, hr']\n          symm\n          exact hs.fac _ WalkingSpan.right\u27e9\u27e9", "start": [970, 1], "end": [993, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.isColimitOfEpiComp", "code": "def isColimitOfEpiComp (f : X \u27f6 Y) (g : X \u27f6 Z) (h : W \u27f6 X) [Epi h] (s : PushoutCocone f g)\n    (H : IsColimit s) :\n    IsColimit\n      (PushoutCocone.mk _ _\n        (show (h \u226b f) \u226b s.inl = (h \u226b g) \u226b s.inr by\n          rw [Category.assoc, Category.assoc, s.condition])) := by\n  apply PushoutCocone.isColimitAux'\n  intro s\n  rcases PushoutCocone.IsColimit.desc' H s.inl s.inr\n      ((cancel_epi h).mp (by simpa using s.condition)) with\n    \u27e8l, h\u2081, h\u2082\u27e9\n  refine' \u27e8l, h\u2081, h\u2082, _\u27e9\n  intro m hm\u2081 hm\u2082\n  exact (PushoutCocone.IsColimit.hom_ext H (hm\u2081.trans h\u2081.symm) (hm\u2082.trans h\u2082.symm) : _)", "start": [996, 1], "end": [1011, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.ofPullbackCone", "code": "@[simps]\ndef Cone.ofPullbackCone {F : WalkingCospan \u2964 C} (t : PullbackCone (F.map inl) (F.map inr)) : Cone F\n    where\n  pt := t.pt\n  \u03c0 := t.\u03c0 \u226b (diagramIsoCospan F).inv", "start": [1016, 1], "end": [1027, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.ofPushoutCocone", "code": "@[simps]\ndef Cocone.ofPushoutCocone {F : WalkingSpan \u2964 C} (t : PushoutCocone (F.map fst) (F.map snd)) :\n    Cocone F where\n  pt := t.pt\n  \u03b9 := (diagramIsoSpan F).hom \u226b t.\u03b9", "start": [1030, 1], "end": [1041, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.ofCone", "code": "@[simps]\ndef PullbackCone.ofCone {F : WalkingCospan \u2964 C} (t : Cone F) : PullbackCone (F.map inl) (F.map inr)\n    where\n  pt := t.pt\n  \u03c0 := t.\u03c0 \u226b (diagramIsoCospan F).hom", "start": [1044, 1], "end": [1050, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.isoMk", "code": "@[simps!]\ndef PullbackCone.isoMk {F : WalkingCospan \u2964 C} (t : Cone F) :\n    (Cones.postcompose (diagramIsoCospan.{v} _).hom).obj t \u2245\n      PullbackCone.mk (t.\u03c0.app WalkingCospan.left) (t.\u03c0.app WalkingCospan.right)\n        ((t.\u03c0.naturality inl).symm.trans (t.\u03c0.naturality inr : _)) :=\n  Cones.ext (Iso.refl _) <| by\n    rintro (_ | (_ | _)) <;>\n      \u00b7 dsimp\n        simp", "start": [1053, 1], "end": [1063, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.ofCocone", "code": "@[simps]\ndef PushoutCocone.ofCocone {F : WalkingSpan \u2964 C} (t : Cocone F) :\n    PushoutCocone (F.map fst) (F.map snd) where\n  pt := t.pt\n  \u03b9 := (diagramIsoSpan F).inv \u226b t.\u03b9", "start": [1066, 1], "end": [1072, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.isoMk", "code": "@[simps!]\ndef PushoutCocone.isoMk {F : WalkingSpan \u2964 C} (t : Cocone F) :\n    (Cocones.precompose (diagramIsoSpan.{v} _).inv).obj t \u2245\n      PushoutCocone.mk (t.\u03b9.app WalkingSpan.left) (t.\u03b9.app WalkingSpan.right)\n        ((t.\u03b9.naturality fst).trans (t.\u03b9.naturality snd).symm) :=\n  Cocones.ext (Iso.refl _) <| by\n    rintro (_ | (_ | _)) <;>\n      \u00b7 dsimp\n        simp", "start": [1075, 1], "end": [1085, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasPullback", "code": "abbrev HasPullback {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :=\n  HasLimit (cospan f g)", "start": [1088, 1], "end": [1092, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasPushout", "code": "abbrev HasPushout {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) :=\n  HasColimit (span f g)", "start": [1095, 1], "end": [1099, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback", "code": "abbrev pullback {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) [HasPullback f g] :=\n  limit (cospan f g)", "start": [1102, 1], "end": [1104, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout", "code": "abbrev pushout {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) [HasPushout f g] :=\n  colimit (span f g)", "start": [1107, 1], "end": [1109, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.fst", "code": "abbrev pullback.fst {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] : pullback f g \u27f6 X :=\n  limit.\u03c0 (cospan f g) WalkingCospan.left", "start": [1112, 1], "end": [1114, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.snd", "code": "abbrev pullback.snd {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] : pullback f g \u27f6 Y :=\n  limit.\u03c0 (cospan f g) WalkingCospan.right", "start": [1117, 1], "end": [1119, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.inl", "code": "abbrev pushout.inl {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] : Y \u27f6 pushout f g :=\n  colimit.\u03b9 (span f g) WalkingSpan.left", "start": [1122, 1], "end": [1124, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.inr", "code": "abbrev pushout.inr {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] : Z \u27f6 pushout f g :=\n  colimit.\u03b9 (span f g) WalkingSpan.right", "start": [1127, 1], "end": [1129, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.lift", "code": "abbrev pullback.lift {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] (h : W \u27f6 X) (k : W \u27f6 Y)\n    (w : h \u226b f = k \u226b g) : W \u27f6 pullback f g :=\n  limit.lift _ (PullbackCone.mk h k w)", "start": [1132, 1], "end": [1136, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.desc", "code": "abbrev pushout.desc {W X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] (h : Y \u27f6 W) (k : Z \u27f6 W)\n    (w : f \u226b h = g \u226b k) : pushout f g \u27f6 W :=\n  colimit.desc _ (PushoutCocone.mk h k w)", "start": [1139, 1], "end": [1143, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.fst_colimit_cocone", "code": "@[simp]\ntheorem PullbackCone.fst_colimit_cocone {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)\n    [HasLimit (cospan f g)] : PullbackCone.fst (limit.cone (cospan f g)) = pullback.fst", "start": [1146, 1], "end": [1148, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.snd_colimit_cocone", "code": "@[simp]\ntheorem PullbackCone.snd_colimit_cocone {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)\n    [HasLimit (cospan f g)] : PullbackCone.snd (limit.cone (cospan f g)) = pullback.snd", "start": [1151, 1], "end": [1153, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.inl_colimit_cocone", "code": "theorem PushoutCocone.inl_colimit_cocone {X Y Z : C} (f : Z \u27f6 X) (g : Z \u27f6 Y)\n    [HasColimit (span f g)] : PushoutCocone.inl (colimit.cocone (span f g)) = pushout.inl", "start": [1157, 1], "end": [1158, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.inr_colimit_cocone", "code": "theorem PushoutCocone.inr_colimit_cocone {X Y Z : C} (f : Z \u27f6 X) (g : Z \u27f6 Y)\n    [HasColimit (span f g)] : PushoutCocone.inr (colimit.cocone (span f g)) = pushout.inr", "start": [1162, 1], "end": [1163, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.lift_fst", "code": "@[reassoc]\ntheorem pullback.lift_fst {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] (h : W \u27f6 X)\n    (k : W \u27f6 Y) (w : h \u226b f = k \u226b g) : pullback.lift h k w \u226b pullback.fst = h", "start": [1167, 1], "end": [1170, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.lift_snd", "code": "@[reassoc]\ntheorem pullback.lift_snd {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] (h : W \u27f6 X)\n    (k : W \u27f6 Y) (w : h \u226b f = k \u226b g) : pullback.lift h k w \u226b pullback.snd = k", "start": [1174, 1], "end": [1177, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.inl_desc", "code": "@[reassoc]\ntheorem pushout.inl_desc {W X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] (h : Y \u27f6 W)\n    (k : Z \u27f6 W) (w : f \u226b h = g \u226b k) : pushout.inl \u226b pushout.desc h k w = h", "start": [1181, 1], "end": [1184, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.inr_desc", "code": "@[reassoc]\ntheorem pushout.inr_desc {W X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] (h : Y \u27f6 W)\n    (k : Z \u27f6 W) (w : f \u226b h = g \u226b k) : pushout.inr \u226b pushout.desc h k w = k", "start": [1188, 1], "end": [1191, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.lift'", "code": "def pullback.lift' {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] (h : W \u27f6 X) (k : W \u27f6 Y)\n    (w : h \u226b f = k \u226b g) : { l : W \u27f6 pullback f g // l \u226b pullback.fst = h \u2227 l \u226b pullback.snd = k } :=\n  \u27e8pullback.lift h k w, pullback.lift_fst _ _ _, pullback.lift_snd _ _ _\u27e9", "start": [1194, 1], "end": [1198, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.desc'", "code": "def pullback.desc' {W X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] (h : Y \u27f6 W) (k : Z \u27f6 W)\n    (w : f \u226b h = g \u226b k) : { l : pushout f g \u27f6 W // pushout.inl \u226b l = h \u2227 pushout.inr \u226b l = k } :=\n  \u27e8pushout.desc h k w, pushout.inl_desc _ _ _, pushout.inr_desc _ _ _\u27e9", "start": [1201, 1], "end": [1205, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.condition", "code": "@[reassoc]\ntheorem pullback.condition {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] :\n    (pullback.fst : pullback f g \u27f6 X) \u226b f = pullback.snd \u226b g", "start": [1208, 1], "end": [1211, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.condition", "code": "@[reassoc]\ntheorem pushout.condition {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] :\n    f \u226b (pushout.inl : Y \u27f6 pushout f g) = g \u226b pushout.inr", "start": [1214, 1], "end": [1217, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.map", "code": "abbrev pullback.map {W X Y Z S T : C} (f\u2081 : W \u27f6 S) (f\u2082 : X \u27f6 S) [HasPullback f\u2081 f\u2082] (g\u2081 : Y \u27f6 T)\n    (g\u2082 : Z \u27f6 T) [HasPullback g\u2081 g\u2082] (i\u2081 : W \u27f6 Y) (i\u2082 : X \u27f6 Z) (i\u2083 : S \u27f6 T)\n    (eq\u2081 : f\u2081 \u226b i\u2083 = i\u2081 \u226b g\u2081) (eq\u2082 : f\u2082 \u226b i\u2083 = i\u2082 \u226b g\u2082) : pullback f\u2081 f\u2082 \u27f6 pullback g\u2081 g\u2082 :=\n  pullback.lift (pullback.fst \u226b i\u2081) (pullback.snd \u226b i\u2082)\n    (by simp [\u2190 eq\u2081, \u2190 eq\u2082, pullback.condition_assoc])", "start": [1220, 1], "end": [1233, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.mapDesc", "code": "abbrev pullback.mapDesc {X Y S T : C} (f : X \u27f6 S) (g : Y \u27f6 S) (i : S \u27f6 T) [HasPullback f g]\n    [HasPullback (f \u226b i) (g \u226b i)] : pullback f g \u27f6 pullback (f \u226b i) (g \u226b i) :=\n  pullback.map f g (f \u226b i) (g \u226b i) (\ud835\udfd9 _) (\ud835\udfd9 _) i (Category.id_comp _).symm (Category.id_comp _).symm", "start": [1236, 1], "end": [1239, 101], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.map", "code": "abbrev pushout.map {W X Y Z S T : C} (f\u2081 : S \u27f6 W) (f\u2082 : S \u27f6 X) [HasPushout f\u2081 f\u2082] (g\u2081 : T \u27f6 Y)\n    (g\u2082 : T \u27f6 Z) [HasPushout g\u2081 g\u2082] (i\u2081 : W \u27f6 Y) (i\u2082 : X \u27f6 Z) (i\u2083 : S \u27f6 T) (eq\u2081 : f\u2081 \u226b i\u2081 = i\u2083 \u226b g\u2081)\n    (eq\u2082 : f\u2082 \u226b i\u2082 = i\u2083 \u226b g\u2082) : pushout f\u2081 f\u2082 \u27f6 pushout g\u2081 g\u2082 :=\n  pushout.desc (i\u2081 \u226b pushout.inl) (i\u2082 \u226b pushout.inr)\n    (by\n      simp only [\u2190 Category.assoc, eq\u2081, eq\u2082]\n      simp [pushout.condition])", "start": [1242, 1], "end": [1257, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.mapLift", "code": "abbrev pushout.mapLift {X Y S T : C} (f : T \u27f6 X) (g : T \u27f6 Y) (i : S \u27f6 T) [HasPushout f g]\n    [HasPushout (i \u226b f) (i \u226b g)] : pushout (i \u226b f) (i \u226b g) \u27f6 pushout f g :=\n  pushout.map (i \u226b f) (i \u226b g) f g (\ud835\udfd9 _) (\ud835\udfd9 _) i (Category.comp_id _) (Category.comp_id _)", "start": [1260, 1], "end": [1263, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.hom_ext", "code": "@[ext 1100]\ntheorem pullback.hom_ext {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] {W : C}\n    {k l : W \u27f6 pullback f g} (h\u2080 : k \u226b pullback.fst = l \u226b pullback.fst)\n    (h\u2081 : k \u226b pullback.snd = l \u226b pullback.snd) : k = l", "start": [1266, 1], "end": [1272, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackIsPullback", "code": "def pullbackIsPullback {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) [HasPullback f g] :\n    IsLimit (PullbackCone.mk (pullback.fst : pullback f g \u27f6 _) pullback.snd pullback.condition) :=\n  PullbackCone.IsLimit.mk _ (fun s => pullback.lift s.fst s.snd s.condition) (by simp) (by simp)\n    (by aesop_cat)", "start": [1275, 1], "end": [1279, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.fst_of_mono", "code": "instance pullback.fst_of_mono {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] [Mono g] :\n    Mono (pullback.fst : pullback f g \u27f6 X) :=\n  PullbackCone.mono_fst_of_is_pullback_of_mono (limit.isLimit _)", "start": [1282, 1], "end": [1285, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.snd_of_mono", "code": "instance pullback.snd_of_mono {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] [Mono f] :\n    Mono (pullback.snd : pullback f g \u27f6 Y) :=\n  PullbackCone.mono_snd_of_is_pullback_of_mono (limit.isLimit _)", "start": [1288, 1], "end": [1291, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.mono_pullback_to_prod", "code": "instance mono_pullback_to_prod {C : Type*} [Category C] {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)\n    [HasPullback f g] [HasBinaryProduct X Y] :\n    Mono (prod.lift pullback.fst pullback.snd : pullback f g \u27f6 _) :=\n  \u27e8fun {W} i\u2081 i\u2082 h => by\n    ext\n    \u00b7 simpa using congrArg (fun f => f \u226b prod.fst) h\n    \u00b7 simpa using congrArg (fun f => f \u226b prod.snd) h\u27e9", "start": [1294, 1], "end": [1301, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.hom_ext", "code": "@[ext 1100]\ntheorem pushout.hom_ext {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] {W : C}\n    {k l : pushout f g \u27f6 W} (h\u2080 : pushout.inl \u226b k = pushout.inl \u226b l)\n    (h\u2081 : pushout.inr \u226b k = pushout.inr \u226b l) : k = l", "start": [1304, 1], "end": [1310, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutIsPushout", "code": "def pushoutIsPushout {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) [HasPushout f g] :\n    IsColimit (PushoutCocone.mk (pushout.inl : _ \u27f6 pushout f g) pushout.inr pushout.condition) :=\n  PushoutCocone.IsColimit.mk _ (fun s => pushout.desc s.inl s.inr s.condition) (by simp) (by simp)\n    (by aesop_cat)", "start": [1313, 1], "end": [1317, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.inl_of_epi", "code": "instance pushout.inl_of_epi {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] [Epi g] :\n    Epi (pushout.inl : Y \u27f6 pushout f g) :=\n  PushoutCocone.epi_inl_of_is_pushout_of_epi (colimit.isColimit _)", "start": [1320, 1], "end": [1323, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.inr_of_epi", "code": "instance pushout.inr_of_epi {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] [Epi f] :\n    Epi (pushout.inr : Z \u27f6 pushout f g) :=\n  PushoutCocone.epi_inr_of_is_pushout_of_epi (colimit.isColimit _)", "start": [1326, 1], "end": [1329, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.epi_coprod_to_pushout", "code": "instance epi_coprod_to_pushout {C : Type*} [Category C] {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)\n    [HasPushout f g] [HasBinaryCoproduct Y Z] :\n    Epi (coprod.desc pushout.inl pushout.inr : _ \u27f6 pushout f g) :=\n  \u27e8fun {W} i\u2081 i\u2082 h => by\n    ext\n    \u00b7 simpa using congrArg (fun f => coprod.inl \u226b f) h\n    \u00b7 simpa using congrArg (fun f => coprod.inr \u226b f) h\u27e9", "start": [1332, 1], "end": [1339, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.map_isIso", "code": "instance pullback.map_isIso {W X Y Z S T : C} (f\u2081 : W \u27f6 S) (f\u2082 : X \u27f6 S) [HasPullback f\u2081 f\u2082]\n    (g\u2081 : Y \u27f6 T) (g\u2082 : Z \u27f6 T) [HasPullback g\u2081 g\u2082] (i\u2081 : W \u27f6 Y) (i\u2082 : X \u27f6 Z) (i\u2083 : S \u27f6 T)\n    (eq\u2081 : f\u2081 \u226b i\u2083 = i\u2081 \u226b g\u2081) (eq\u2082 : f\u2082 \u226b i\u2083 = i\u2082 \u226b g\u2082) [IsIso i\u2081] [IsIso i\u2082] [IsIso i\u2083] :\n    IsIso (pullback.map f\u2081 f\u2082 g\u2081 g\u2082 i\u2081 i\u2082 i\u2083 eq\u2081 eq\u2082) := by\n  refine' \u27e8\u27e8pullback.map _ _ _ _ (inv i\u2081) (inv i\u2082) (inv i\u2083) _ _, _, _\u27e9\u27e9\n  \u00b7 rw [IsIso.comp_inv_eq, Category.assoc, eq\u2081, IsIso.inv_hom_id_assoc]\n  \u00b7 rw [IsIso.comp_inv_eq, Category.assoc, eq\u2082, IsIso.inv_hom_id_assoc]\n  \u00b7 aesop_cat\n  \u00b7 aesop_cat", "start": [1342, 1], "end": [1350, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.congrHom", "code": "@[simps! hom]\ndef pullback.congrHom {X Y Z : C} {f\u2081 f\u2082 : X \u27f6 Z} {g\u2081 g\u2082 : Y \u27f6 Z} (h\u2081 : f\u2081 = f\u2082) (h\u2082 : g\u2081 = g\u2082)\n    [HasPullback f\u2081 g\u2081] [HasPullback f\u2082 g\u2082] : pullback f\u2081 g\u2081 \u2245 pullback f\u2082 g\u2082 :=\n  asIso <| pullback.map _ _ _ _ (\ud835\udfd9 _) (\ud835\udfd9 _) (\ud835\udfd9 _) (by simp [h\u2081]) (by simp [h\u2082])", "start": [1353, 1], "end": [1358, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.congrHom_inv", "code": "@[simp]\ntheorem pullback.congrHom_inv {X Y Z : C} {f\u2081 f\u2082 : X \u27f6 Z} {g\u2081 g\u2082 : Y \u27f6 Z} (h\u2081 : f\u2081 = f\u2082)\n    (h\u2082 : g\u2081 = g\u2082) [HasPullback f\u2081 g\u2081] [HasPullback f\u2082 g\u2082] :\n    (pullback.congrHom h\u2081 h\u2082).inv =\n      pullback.map _ _ _ _ (\ud835\udfd9 _) (\ud835\udfd9 _) (\ud835\udfd9 _) (by simp [h\u2081]) (by simp [h\u2082])", "start": [1361, 1], "end": [1374, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.map_isIso", "code": "instance pushout.map_isIso {W X Y Z S T : C} (f\u2081 : S \u27f6 W) (f\u2082 : S \u27f6 X) [HasPushout f\u2081 f\u2082]\n    (g\u2081 : T \u27f6 Y) (g\u2082 : T \u27f6 Z) [HasPushout g\u2081 g\u2082] (i\u2081 : W \u27f6 Y) (i\u2082 : X \u27f6 Z) (i\u2083 : S \u27f6 T)\n    (eq\u2081 : f\u2081 \u226b i\u2081 = i\u2083 \u226b g\u2081) (eq\u2082 : f\u2082 \u226b i\u2082 = i\u2083 \u226b g\u2082) [IsIso i\u2081] [IsIso i\u2082] [IsIso i\u2083] :\n    IsIso (pushout.map f\u2081 f\u2082 g\u2081 g\u2082 i\u2081 i\u2082 i\u2083 eq\u2081 eq\u2082) := by\n  refine' \u27e8\u27e8pushout.map _ _ _ _ (inv i\u2081) (inv i\u2082) (inv i\u2083) _ _, _, _\u27e9\u27e9\n  \u00b7 rw [IsIso.comp_inv_eq, Category.assoc, eq\u2081, IsIso.inv_hom_id_assoc]\n  \u00b7 rw [IsIso.comp_inv_eq, Category.assoc, eq\u2082, IsIso.inv_hom_id_assoc]\n  \u00b7 aesop_cat\n  \u00b7 aesop_cat", "start": [1377, 1], "end": [1385, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback.mapDesc_comp", "code": "theorem pullback.mapDesc_comp {X Y S T S' : C} (f : X \u27f6 T) (g : Y \u27f6 T) (i : T \u27f6 S) (i' : S \u27f6 S')\n    [HasPullback f g] [HasPullback (f \u226b i) (g \u226b i)] [HasPullback (f \u226b i \u226b i') (g \u226b i \u226b i')]\n    [HasPullback ((f \u226b i) \u226b i') ((g \u226b i) \u226b i')] :\n    pullback.mapDesc f g (i \u226b i') = pullback.mapDesc f g i \u226b pullback.mapDesc _ _ i' \u226b\n    (pullback.congrHom (Category.assoc _ _ _) (Category.assoc _ _ _)).hom", "start": [1388, 1], "end": [1393, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.congrHom", "code": "@[simps! hom]\ndef pushout.congrHom {X Y Z : C} {f\u2081 f\u2082 : X \u27f6 Y} {g\u2081 g\u2082 : X \u27f6 Z} (h\u2081 : f\u2081 = f\u2082) (h\u2082 : g\u2081 = g\u2082)\n    [HasPushout f\u2081 g\u2081] [HasPushout f\u2082 g\u2082] : pushout f\u2081 g\u2081 \u2245 pushout f\u2082 g\u2082 :=\n  asIso <| pushout.map _ _ _ _ (\ud835\udfd9 _) (\ud835\udfd9 _) (\ud835\udfd9 _) (by simp [h\u2081]) (by simp [h\u2082])", "start": [1396, 1], "end": [1401, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.congrHom_inv", "code": "@[simp]\ntheorem pushout.congrHom_inv {X Y Z : C} {f\u2081 f\u2082 : X \u27f6 Y} {g\u2081 g\u2082 : X \u27f6 Z} (h\u2081 : f\u2081 = f\u2082)\n    (h\u2082 : g\u2081 = g\u2082) [HasPushout f\u2081 g\u2081] [HasPushout f\u2082 g\u2082] :\n    (pushout.congrHom h\u2081 h\u2082).inv =\n      pushout.map _ _ _ _ (\ud835\udfd9 _) (\ud835\udfd9 _) (\ud835\udfd9 _) (by simp [h\u2081]) (by simp [h\u2082])", "start": [1404, 1], "end": [1417, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout.mapLift_comp", "code": "theorem pushout.mapLift_comp {X Y S T S' : C} (f : T \u27f6 X) (g : T \u27f6 Y) (i : S \u27f6 T) (i' : S' \u27f6 S)\n    [HasPushout f g] [HasPushout (i \u226b f) (i \u226b g)] [HasPushout (i' \u226b i \u226b f) (i' \u226b i \u226b g)]\n    [HasPushout ((i' \u226b i) \u226b f) ((i' \u226b i) \u226b g)] :\n    pushout.mapLift f g (i' \u226b i) =\n      (pushout.congrHom (Category.assoc _ _ _) (Category.assoc _ _ _)).hom \u226b\n        pushout.mapLift _ _ i' \u226b pushout.mapLift f g i", "start": [1420, 1], "end": [1426, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackComparison", "code": "def pullbackComparison (f : X \u27f6 Z) (g : Y \u27f6 Z) [HasPullback f g] [HasPullback (G.map f) (G.map g)] :\n    G.obj (pullback f g) \u27f6 pullback (G.map f) (G.map g) :=\n  pullback.lift (G.map pullback.fst) (G.map pullback.snd)\n    (by simp only [\u2190 G.map_comp, pullback.condition])", "start": [1433, 1], "end": [1440, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackComparison_comp_fst", "code": "@[reassoc (attr := simp)]\ntheorem pullbackComparison_comp_fst (f : X \u27f6 Z) (g : Y \u27f6 Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] :\n    pullbackComparison G f g \u226b pullback.fst = G.map pullback.fst", "start": [1443, 1], "end": [1447, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackComparison_comp_snd", "code": "@[reassoc (attr := simp)]\ntheorem pullbackComparison_comp_snd (f : X \u27f6 Z) (g : Y \u27f6 Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] :\n    pullbackComparison G f g \u226b pullback.snd = G.map pullback.snd", "start": [1450, 1], "end": [1454, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.map_lift_pullbackComparison", "code": "@[reassoc (attr := simp)]\ntheorem map_lift_pullbackComparison (f : X \u27f6 Z) (g : Y \u27f6 Z) [HasPullback f g]\n    [HasPullback (G.map f) (G.map g)] {W : C} {h : W \u27f6 X} {k : W \u27f6 Y} (w : h \u226b f = k \u226b g) :\n    G.map (pullback.lift _ _ w) \u226b pullbackComparison G f g =\n      pullback.lift (G.map h) (G.map k) (by simp only [\u2190 G.map_comp, w])", "start": [1457, 1], "end": [1462, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutComparison", "code": "def pushoutComparison (f : X \u27f6 Y) (g : X \u27f6 Z) [HasPushout f g] [HasPushout (G.map f) (G.map g)] :\n    pushout (G.map f) (G.map g) \u27f6 G.obj (pushout f g) :=\n  pushout.desc (G.map pushout.inl) (G.map pushout.inr)\n    (by simp only [\u2190 G.map_comp, pushout.condition])", "start": [1465, 1], "end": [1472, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inl_comp_pushoutComparison", "code": "@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutComparison (f : X \u27f6 Y) (g : X \u27f6 Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] : pushout.inl \u226b pushoutComparison G f g = G.map pushout.inl", "start": [1475, 1], "end": [1478, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inr_comp_pushoutComparison", "code": "@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutComparison (f : X \u27f6 Y) (g : X \u27f6 Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] : pushout.inr \u226b pushoutComparison G f g = G.map pushout.inr", "start": [1481, 1], "end": [1484, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutComparison_map_desc", "code": "@[reassoc (attr := simp)]\ntheorem pushoutComparison_map_desc (f : X \u27f6 Y) (g : X \u27f6 Z) [HasPushout f g]\n    [HasPushout (G.map f) (G.map g)] {W : C} {h : Y \u27f6 W} {k : Z \u27f6 W} (w : f \u226b h = g \u226b k) :\n    pushoutComparison G f g \u226b G.map (pushout.desc _ _ w) =\n      pushout.desc (G.map h) (G.map k) (by simp only [\u2190 G.map_comp, w])", "start": [1487, 1], "end": [1492, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPullback_symmetry", "code": "theorem hasPullback_symmetry [HasPullback f g] : HasPullback g f", "start": [1503, 1], "end": [1506, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackSymmetry", "code": "def pullbackSymmetry [HasPullback f g] : pullback f g \u2245 pullback g f :=\n  IsLimit.conePointUniqueUpToIso\n    (PullbackCone.flipIsLimit (pullbackIsPullback f g) :\n      IsLimit (PullbackCone.mk _ _ pullback.condition.symm))\n    (limit.isLimit _)", "start": [1511, 1], "end": [1516, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackSymmetry_hom_comp_fst", "code": "@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_hom_comp_fst [HasPullback f g] :\n    (pullbackSymmetry f g).hom \u226b pullback.fst = pullback.snd", "start": [1519, 1], "end": [1521, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackSymmetry_hom_comp_snd", "code": "@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_hom_comp_snd [HasPullback f g] :\n    (pullbackSymmetry f g).hom \u226b pullback.snd = pullback.fst", "start": [1524, 1], "end": [1526, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackSymmetry_inv_comp_fst", "code": "@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_inv_comp_fst [HasPullback f g] :\n    (pullbackSymmetry f g).inv \u226b pullback.fst = pullback.snd", "start": [1529, 1], "end": [1531, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackSymmetry_inv_comp_snd", "code": "@[reassoc (attr := simp)]\ntheorem pullbackSymmetry_inv_comp_snd [HasPullback f g] :\n    (pullbackSymmetry f g).inv \u226b pullback.snd = pullback.fst", "start": [1534, 1], "end": [1536, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPushout_symmetry", "code": "theorem hasPushout_symmetry [HasPushout f g] : HasPushout g f", "start": [1547, 1], "end": [1550, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutSymmetry", "code": "def pushoutSymmetry [HasPushout f g] : pushout f g \u2245 pushout g f :=\n  IsColimit.coconePointUniqueUpToIso\n    (PushoutCocone.flipIsColimit (pushoutIsPushout f g) :\n      IsColimit (PushoutCocone.mk _ _ pushout.condition.symm))\n    (colimit.isColimit _)", "start": [1555, 1], "end": [1560, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inl_comp_pushoutSymmetry_hom", "code": "@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutSymmetry_hom [HasPushout f g] :\n    pushout.inl \u226b (pushoutSymmetry f g).hom = pushout.inr", "start": [1563, 1], "end": [1567, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inr_comp_pushoutSymmetry_hom", "code": "@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutSymmetry_hom [HasPushout f g] :\n    pushout.inr \u226b (pushoutSymmetry f g).hom = pushout.inl", "start": [1570, 1], "end": [1574, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inl_comp_pushoutSymmetry_inv", "code": "@[reassoc (attr := simp)]\ntheorem inl_comp_pushoutSymmetry_inv [HasPushout f g] :\n    pushout.inl \u226b (pushoutSymmetry f g).inv = pushout.inr", "start": [1577, 1], "end": [1579, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inr_comp_pushoutSymmetry_inv", "code": "@[reassoc (attr := simp)]\ntheorem inr_comp_pushoutSymmetry_inv [HasPushout f g] :\n    pushout.inr \u226b (pushoutSymmetry f g).inv = pushout.inl", "start": [1582, 1], "end": [1584, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackIsPullbackOfCompMono", "code": "noncomputable def pullbackIsPullbackOfCompMono (f : X \u27f6 W) (g : Y \u27f6 W) (i : W \u27f6 Z) [Mono i]\n    [HasPullback f g] : IsLimit (PullbackCone.mk pullback.fst pullback.snd\n      (show pullback.fst \u226b f \u226b i = pullback.snd \u226b g \u226b i from by simp only [\u2190 Category.assoc]; rw [cancel_mono]; apply pullback.condition)) :=\n  PullbackCone.isLimitOfCompMono f g i _ (limit.isLimit (cospan f g))", "start": [1593, 1], "end": [1598, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPullback_of_comp_mono", "code": "instance hasPullback_of_comp_mono (f : X \u27f6 W) (g : Y \u27f6 W) (i : W \u27f6 Z) [Mono i] [HasPullback f g] :\n    HasPullback (f \u226b i) (g \u226b i) :=\n  \u27e8\u27e8\u27e8_, pullbackIsPullbackOfCompMono f g i\u27e9\u27e9\u27e9", "start": [1601, 1], "end": [1603, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfLeftIso", "code": "def pullbackConeOfLeftIso : PullbackCone f g :=\n  PullbackCone.mk (g \u226b inv f) (\ud835\udfd9 _) <| by simp", "start": [1608, 1], "end": [1610, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfLeftIso_x", "code": "@[simp]\ntheorem pullbackConeOfLeftIso_x : (pullbackConeOfLeftIso f g).pt = Y", "start": [1613, 1], "end": [1614, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfLeftIso_fst", "code": "@[simp]\ntheorem pullbackConeOfLeftIso_fst : (pullbackConeOfLeftIso f g).fst = g \u226b inv f", "start": [1618, 1], "end": [1619, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfLeftIso_snd", "code": "@[simp]\ntheorem pullbackConeOfLeftIso_snd : (pullbackConeOfLeftIso f g).snd = \ud835\udfd9 _", "start": [1622, 1], "end": [1623, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfLeftIso_\u03c0_app_none", "code": "theorem pullbackConeOfLeftIso_\u03c0_app_none : (pullbackConeOfLeftIso f g).\u03c0.app none = g", "start": [1627, 1], "end": [1627, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfLeftIso_\u03c0_app_left", "code": "@[simp]\ntheorem pullbackConeOfLeftIso_\u03c0_app_left : (pullbackConeOfLeftIso f g).\u03c0.app left = g \u226b inv f", "start": [1630, 1], "end": [1632, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfLeftIso_\u03c0_app_right", "code": "@[simp]\ntheorem pullbackConeOfLeftIso_\u03c0_app_right : (pullbackConeOfLeftIso f g).\u03c0.app right = \ud835\udfd9 _", "start": [1635, 1], "end": [1636, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfLeftIsoIsLimit", "code": "def pullbackConeOfLeftIsoIsLimit : IsLimit (pullbackConeOfLeftIso f g) :=\n  PullbackCone.isLimitAux' _ fun s => \u27e8s.snd, by simp [\u2190 s.condition_assoc]\u27e9", "start": [1639, 1], "end": [1641, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPullback_of_left_iso", "code": "theorem hasPullback_of_left_iso : HasPullback f g", "start": [1644, 1], "end": [1645, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback_snd_iso_of_left_iso", "code": "instance pullback_snd_iso_of_left_iso : IsIso (pullback.snd : pullback f g \u27f6 _) := by\n  refine' \u27e8\u27e8pullback.lift (g \u226b inv f) (\ud835\udfd9 _) (by simp), _, by simp\u27e9\u27e9\n  ext\n  \u00b7 simp [\u2190 pullback.condition_assoc]\n  \u00b7 simp [pullback.condition_assoc]", "start": [1650, 1], "end": [1654, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPullback_of_right_factors_mono", "code": "instance hasPullback_of_right_factors_mono (f : X \u27f6 Z) : HasPullback i (f \u226b i) := by\n  conv =>\n    congr\n    rw [\u2190 Category.id_comp i]\n  infer_instance", "start": [1659, 1], "end": [1663, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback_snd_iso_of_right_factors_mono", "code": "instance pullback_snd_iso_of_right_factors_mono (f : X \u27f6 Z) :\n    IsIso (pullback.snd : pullback i (f \u226b i) \u27f6 _) := by\n  convert (congrArg IsIso (show _ \u226b pullback.snd = _ from\n    limit.isoLimitCone_hom_\u03c0 \u27e8_, pullbackIsPullbackOfCompMono (\ud835\udfd9 _) f i\u27e9 WalkingCospan.right)).mp\n    inferInstance;\n  \u00b7 exact (Category.id_comp _).symm\n  \u00b7 exact (Category.id_comp _).symm", "start": [1666, 1], "end": [1672, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfRightIso", "code": "def pullbackConeOfRightIso : PullbackCone f g :=\n  PullbackCone.mk (\ud835\udfd9 _) (f \u226b inv g) <| by simp", "start": [1683, 1], "end": [1685, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfRightIso_x", "code": "@[simp]\ntheorem pullbackConeOfRightIso_x : (pullbackConeOfRightIso f g).pt = X", "start": [1688, 1], "end": [1689, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfRightIso_fst", "code": "@[simp]\ntheorem pullbackConeOfRightIso_fst : (pullbackConeOfRightIso f g).fst = \ud835\udfd9 _", "start": [1693, 1], "end": [1694, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfRightIso_snd", "code": "@[simp]\ntheorem pullbackConeOfRightIso_snd : (pullbackConeOfRightIso f g).snd = f \u226b inv g", "start": [1697, 1], "end": [1698, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfRightIso_\u03c0_app_none", "code": "theorem pullbackConeOfRightIso_\u03c0_app_none : (pullbackConeOfRightIso f g).\u03c0.app none = f", "start": [1702, 1], "end": [1702, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfRightIso_\u03c0_app_left", "code": "@[simp]\ntheorem pullbackConeOfRightIso_\u03c0_app_left : (pullbackConeOfRightIso f g).\u03c0.app left = \ud835\udfd9 _", "start": [1705, 1], "end": [1707, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfRightIso_\u03c0_app_right", "code": "@[simp]\ntheorem pullbackConeOfRightIso_\u03c0_app_right : (pullbackConeOfRightIso f g).\u03c0.app right = f \u226b inv g", "start": [1710, 1], "end": [1712, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackConeOfRightIsoIsLimit", "code": "def pullbackConeOfRightIsoIsLimit : IsLimit (pullbackConeOfRightIso f g) :=\n  PullbackCone.isLimitAux' _ fun s => \u27e8s.fst, by simp [s.condition_assoc]\u27e9", "start": [1715, 1], "end": [1717, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPullback_of_right_iso", "code": "theorem hasPullback_of_right_iso : HasPullback f g", "start": [1720, 1], "end": [1721, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback_snd_iso_of_right_iso", "code": "instance pullback_snd_iso_of_right_iso : IsIso (pullback.fst : pullback f g \u27f6 _) := by\n  refine' \u27e8\u27e8pullback.lift (\ud835\udfd9 _) (f \u226b inv g) (by simp), _, by simp\u27e9\u27e9\n  ext\n  \u00b7 simp\n  \u00b7 simp [pullback.condition_assoc]", "start": [1726, 1], "end": [1730, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPullback_of_left_factors_mono", "code": "instance hasPullback_of_left_factors_mono (f : X \u27f6 Z) : HasPullback (f \u226b i) i := by\n  conv =>\n    congr\n    case g => rw [\u2190 Category.id_comp i]\n  infer_instance", "start": [1735, 1], "end": [1739, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback_snd_iso_of_left_factors_mono", "code": "instance pullback_snd_iso_of_left_factors_mono (f : X \u27f6 Z) :\n    IsIso (pullback.fst : pullback (f \u226b i) i \u27f6 _) := by\n  convert (congrArg IsIso (show _ \u226b pullback.fst = _ from\n    limit.isoLimitCone_hom_\u03c0 \u27e8_, pullbackIsPullbackOfCompMono f (\ud835\udfd9 _) i\u27e9 WalkingCospan.left)).mp\n    inferInstance;\n  \u00b7 exact (Category.id_comp _).symm\n  \u00b7 exact (Category.id_comp _).symm", "start": [1742, 1], "end": [1748, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutIsPushoutOfEpiComp", "code": "noncomputable def pushoutIsPushoutOfEpiComp (f : X \u27f6 Y) (g : X \u27f6 Z) (h : W \u27f6 X) [Epi h]\n    [HasPushout f g] : IsColimit (PushoutCocone.mk pushout.inl pushout.inr\n    (show (h \u226b f) \u226b pushout.inl = (h \u226b g) \u226b pushout.inr from by\n    simp only [Category.assoc]; rw [cancel_epi]; exact pushout.condition)) :=\n  PushoutCocone.isColimitOfEpiComp f g h _ (colimit.isColimit (span f g))", "start": [1757, 1], "end": [1762, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPushout_of_epi_comp", "code": "instance hasPushout_of_epi_comp (f : X \u27f6 Y) (g : X \u27f6 Z) (h : W \u27f6 X) [Epi h] [HasPushout f g] :\n    HasPushout (h \u226b f) (h \u226b g) :=\n  \u27e8\u27e8\u27e8_, pushoutIsPushoutOfEpiComp f g h\u27e9\u27e9\u27e9", "start": [1765, 1], "end": [1767, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfLeftIso", "code": "def pushoutCoconeOfLeftIso : PushoutCocone f g :=\n  PushoutCocone.mk (inv f \u226b g) (\ud835\udfd9 _) <| by simp", "start": [1772, 1], "end": [1774, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfLeftIso_x", "code": "@[simp]\ntheorem pushoutCoconeOfLeftIso_x : (pushoutCoconeOfLeftIso f g).pt = Z", "start": [1777, 1], "end": [1778, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfLeftIso_inl", "code": "@[simp]\ntheorem pushoutCoconeOfLeftIso_inl : (pushoutCoconeOfLeftIso f g).inl = inv f \u226b g", "start": [1782, 1], "end": [1783, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfLeftIso_inr", "code": "@[simp]\ntheorem pushoutCoconeOfLeftIso_inr : (pushoutCoconeOfLeftIso f g).inr = \ud835\udfd9 _", "start": [1786, 1], "end": [1787, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfLeftIso_\u03b9_app_none", "code": "theorem pushoutCoconeOfLeftIso_\u03b9_app_none : (pushoutCoconeOfLeftIso f g).\u03b9.app none = g", "start": [1791, 1], "end": [1792, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfLeftIso_\u03b9_app_left", "code": "@[simp]\ntheorem pushoutCoconeOfLeftIso_\u03b9_app_left : (pushoutCoconeOfLeftIso f g).\u03b9.app left = inv f \u226b g", "start": [1795, 1], "end": [1797, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfLeftIso_\u03b9_app_right", "code": "@[simp]\ntheorem pushoutCoconeOfLeftIso_\u03b9_app_right : (pushoutCoconeOfLeftIso f g).\u03b9.app right = \ud835\udfd9 _", "start": [1800, 1], "end": [1801, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfLeftIsoIsLimit", "code": "def pushoutCoconeOfLeftIsoIsLimit : IsColimit (pushoutCoconeOfLeftIso f g) :=\n  PushoutCocone.isColimitAux' _ fun s => \u27e8s.inr, by simp [\u2190 s.condition]\u27e9", "start": [1804, 1], "end": [1806, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPushout_of_left_iso", "code": "theorem hasPushout_of_left_iso : HasPushout f g", "start": [1809, 1], "end": [1810, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout_inr_iso_of_left_iso", "code": "instance pushout_inr_iso_of_left_iso : IsIso (pushout.inr : _ \u27f6 pushout f g) := by\n  refine' \u27e8\u27e8pushout.desc (inv f \u226b g) (\ud835\udfd9 _) (by simp), by simp, _\u27e9\u27e9\n  ext\n  \u00b7 simp [\u2190 pushout.condition]\n  \u00b7 simp [pushout.condition_assoc]", "start": [1815, 1], "end": [1819, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPushout_of_right_factors_epi", "code": "instance hasPushout_of_right_factors_epi (f : X \u27f6 Y) : HasPushout h (h \u226b f) := by\n  conv =>\n    congr\n    rw [\u2190 Category.comp_id h]\n  infer_instance", "start": [1824, 1], "end": [1828, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout_inr_iso_of_right_factors_epi", "code": "instance pushout_inr_iso_of_right_factors_epi (f : X \u27f6 Y) :\n    IsIso (pushout.inr : _ \u27f6 pushout h (h \u226b f)) := by\n  convert (congrArg IsIso (show pushout.inr \u226b _ = _ from colimit.isoColimitCocone_\u03b9_inv\n    \u27e8_, pushoutIsPushoutOfEpiComp (\ud835\udfd9 _) f h\u27e9 WalkingSpan.right)).mp\n    inferInstance\n  \u00b7 apply (Category.comp_id _).symm\n  \u00b7 apply (Category.comp_id _).symm", "start": [1831, 1], "end": [1837, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfRightIso", "code": "def pushoutCoconeOfRightIso : PushoutCocone f g :=\n  PushoutCocone.mk (\ud835\udfd9 _) (inv g \u226b f) <| by simp", "start": [1848, 1], "end": [1850, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfRightIso_x", "code": "@[simp]\ntheorem pushoutCoconeOfRightIso_x : (pushoutCoconeOfRightIso f g).pt = Y", "start": [1853, 1], "end": [1854, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfRightIso_inl", "code": "@[simp]\ntheorem pushoutCoconeOfRightIso_inl : (pushoutCoconeOfRightIso f g).inl = \ud835\udfd9 _", "start": [1858, 1], "end": [1859, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfRightIso_inr", "code": "@[simp]\ntheorem pushoutCoconeOfRightIso_inr : (pushoutCoconeOfRightIso f g).inr = inv g \u226b f", "start": [1862, 1], "end": [1863, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfRightIso_\u03b9_app_none", "code": "theorem pushoutCoconeOfRightIso_\u03b9_app_none : (pushoutCoconeOfRightIso f g).\u03b9.app none = f", "start": [1867, 1], "end": [1868, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfRightIso_\u03b9_app_left", "code": "@[simp]\ntheorem pushoutCoconeOfRightIso_\u03b9_app_left : (pushoutCoconeOfRightIso f g).\u03b9.app left = \ud835\udfd9 _", "start": [1871, 1], "end": [1872, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfRightIso_\u03b9_app_right", "code": "@[simp]\ntheorem pushoutCoconeOfRightIso_\u03b9_app_right :\n    (pushoutCoconeOfRightIso f g).\u03b9.app right = inv g \u226b f", "start": [1875, 1], "end": [1877, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutCoconeOfRightIsoIsLimit", "code": "def pushoutCoconeOfRightIsoIsLimit : IsColimit (pushoutCoconeOfRightIso f g) :=\n  PushoutCocone.isColimitAux' _ fun s => \u27e8s.inl, by simp [\u2190 s.condition]\u27e9", "start": [1880, 1], "end": [1882, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPushout_of_right_iso", "code": "theorem hasPushout_of_right_iso : HasPushout f g", "start": [1885, 1], "end": [1886, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout_inl_iso_of_right_iso", "code": "instance pushout_inl_iso_of_right_iso : IsIso (pushout.inl : _ \u27f6 pushout f g) := by\n  refine' \u27e8\u27e8pushout.desc (\ud835\udfd9 _) (inv g \u226b f) (by simp), by simp, _\u27e9\u27e9\n  ext\n  \u00b7 simp [\u2190 pushout.condition]\n  \u00b7 simp [pushout.condition]", "start": [1891, 1], "end": [1895, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPushout_of_left_factors_epi", "code": "instance hasPushout_of_left_factors_epi (f : X \u27f6 Y) : HasPushout (h \u226b f) h := by\n  conv =>\n    congr\n    case g => rw [\u2190 Category.comp_id h]\n  infer_instance", "start": [1900, 1], "end": [1904, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushout_inl_iso_of_left_factors_epi", "code": "instance pushout_inl_iso_of_left_factors_epi (f : X \u27f6 Y) :\n    IsIso (pushout.inl : _ \u27f6 pushout (h \u226b f) h) := by\n  convert (congrArg IsIso (show pushout.inl \u226b _ = _ from colimit.isoColimitCocone_\u03b9_inv\n    \u27e8_, pushoutIsPushoutOfEpiComp f (\ud835\udfd9 _) h\u27e9 WalkingSpan.left)).mp\n        inferInstance;\n  \u00b7 exact (Category.comp_id _).symm\n  \u00b7 exact (Category.comp_id _).symm", "start": [1907, 1], "end": [1913, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.has_kernel_pair_of_mono", "code": "instance has_kernel_pair_of_mono [Mono f] : HasPullback f f :=\n  \u27e8\u27e8\u27e8_, PullbackCone.isLimitMkIdId f\u27e9\u27e9\u27e9", "start": [1924, 1], "end": [1925, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.fst_eq_snd_of_mono_eq", "code": "theorem fst_eq_snd_of_mono_eq [Mono f] : (pullback.fst : pullback f f \u27f6 _) = pullback.snd", "start": [1928, 1], "end": [1930, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackSymmetry_hom_of_mono_eq", "code": "@[simp]\ntheorem pullbackSymmetry_hom_of_mono_eq [Mono f] : (pullbackSymmetry f f).hom = \ud835\udfd9 _", "start": [1933, 1], "end": [1935, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.fst_iso_of_mono_eq", "code": "instance fst_iso_of_mono_eq [Mono f] : IsIso (pullback.fst : pullback f f \u27f6 _) := by\n  refine' \u27e8\u27e8pullback.lift (\ud835\udfd9 _) (\ud835\udfd9 _) (by simp), _, by simp\u27e9\u27e9\n  ext\n  \u00b7 simp\n  \u00b7 simp [fst_eq_snd_of_mono_eq]", "start": [1938, 1], "end": [1942, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.snd_iso_of_mono_eq", "code": "instance snd_iso_of_mono_eq [Mono f] : IsIso (pullback.snd : pullback f f \u27f6 _) := by\n  rw [\u2190 fst_eq_snd_of_mono_eq]\n  infer_instance", "start": [1945, 1], "end": [1947, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.has_cokernel_pair_of_epi", "code": "instance has_cokernel_pair_of_epi [Epi f] : HasPushout f f :=\n  \u27e8\u27e8\u27e8_, PushoutCocone.isColimitMkIdId f\u27e9\u27e9\u27e9", "start": [1958, 1], "end": [1959, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inl_eq_inr_of_epi_eq", "code": "theorem inl_eq_inr_of_epi_eq [Epi f] : (pushout.inl : _ \u27f6 pushout f f) = pushout.inr", "start": [1962, 1], "end": [1964, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullback_symmetry_hom_of_epi_eq", "code": "@[simp]\ntheorem pullback_symmetry_hom_of_epi_eq [Epi f] : (pushoutSymmetry f f).hom = \ud835\udfd9 _", "start": [1967, 1], "end": [1969, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inl_iso_of_epi_eq", "code": "instance inl_iso_of_epi_eq [Epi f] : IsIso (pushout.inl : _ \u27f6 pushout f f) := by\n  refine' \u27e8\u27e8pushout.desc (\ud835\udfd9 _) (\ud835\udfd9 _) (by simp), by simp, _\u27e9\u27e9\n  apply pushout.hom_ext\n  \u00b7 simp\n  \u00b7 simp [inl_eq_inr_of_epi_eq]", "start": [1972, 1], "end": [1976, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inr_iso_of_epi_eq", "code": "instance inr_iso_of_epi_eq [Epi f] : IsIso (pushout.inr : _ \u27f6 pushout f f) := by\n  rw [\u2190 inl_eq_inr_of_epi_eq]\n  infer_instance", "start": [1979, 1], "end": [1981, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.bigSquareIsPullback", "code": "def bigSquareIsPullback (H : IsLimit (PullbackCone.mk _ _ h\u2082))\n    (H' : IsLimit (PullbackCone.mk _ _ h\u2081)) :\n    IsLimit\n      (PullbackCone.mk _ _\n        (show i\u2081 \u226b g\u2081 \u226b g\u2082 = (f\u2081 \u226b f\u2082) \u226b i\u2083 by\n          rw [\u2190 Category.assoc, h\u2081, Category.assoc, h\u2082, Category.assoc])) := by\n  fapply PullbackCone.isLimitAux'\n  intro s\n  have : (s.fst \u226b g\u2081) \u226b g\u2082 = s.snd \u226b i\u2083 := by rw [\u2190 s.condition, Category.assoc]\n  rcases PullbackCone.IsLimit.lift' H (s.fst \u226b g\u2081) s.snd this with \u27e8l\u2081, hl\u2081, hl\u2081'\u27e9\n  rcases PullbackCone.IsLimit.lift' H' s.fst l\u2081 hl\u2081.symm with \u27e8l\u2082, hl\u2082, hl\u2082'\u27e9\n  use l\u2082\n  use hl\u2082\n  use\n    show l\u2082 \u226b f\u2081 \u226b f\u2082 = s.snd by\n      rw [\u2190 hl\u2081', \u2190 hl\u2082', Category.assoc]\n      rfl\n  intro m hm\u2081 hm\u2082\n  apply PullbackCone.IsLimit.hom_ext H'\n  \u00b7 erw [hm\u2081, hl\u2082]\n  \u00b7 apply PullbackCone.IsLimit.hom_ext H\n    \u00b7 erw [Category.assoc, \u2190 h\u2081, \u2190 Category.assoc, hm\u2081, \u2190 hl\u2082, Category.assoc, Category.assoc, h\u2081]\n      rfl\n    \u00b7 erw [Category.assoc, hm\u2082, \u2190 hl\u2081', \u2190 hl\u2082']", "start": [1994, 1], "end": [2027, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.bigSquareIsPushout", "code": "def bigSquareIsPushout (H : IsColimit (PushoutCocone.mk _ _ h\u2082))\n    (H' : IsColimit (PushoutCocone.mk _ _ h\u2081)) :\n    IsColimit\n      (PushoutCocone.mk _ _\n        (show i\u2081 \u226b g\u2081 \u226b g\u2082 = (f\u2081 \u226b f\u2082) \u226b i\u2083 by\n          rw [\u2190 Category.assoc, h\u2081, Category.assoc, h\u2082, Category.assoc])) := by\n  fapply PushoutCocone.isColimitAux'\n  intro s\n  have : i\u2081 \u226b s.inl = f\u2081 \u226b f\u2082 \u226b s.inr := by rw [s.condition, Category.assoc]\n  rcases PushoutCocone.IsColimit.desc' H' s.inl (f\u2082 \u226b s.inr) this with \u27e8l\u2081, hl\u2081, hl\u2081'\u27e9\n  rcases PushoutCocone.IsColimit.desc' H l\u2081 s.inr hl\u2081' with \u27e8l\u2082, hl\u2082, hl\u2082'\u27e9\n  use l\u2082\n  use\n    show (g\u2081 \u226b g\u2082) \u226b l\u2082 = s.inl by\n      rw [\u2190 hl\u2081, \u2190 hl\u2082, Category.assoc]\n      rfl\n  use hl\u2082'\n  intro m hm\u2081 hm\u2082\n  apply PushoutCocone.IsColimit.hom_ext H\n  \u00b7 apply PushoutCocone.IsColimit.hom_ext H'\n    \u00b7 erw [\u2190 Category.assoc, hm\u2081, hl\u2082, hl\u2081]\n    \u00b7 erw [\u2190 Category.assoc, h\u2082, Category.assoc, hm\u2082, \u2190 hl\u2082', \u2190 Category.assoc, \u2190 Category.assoc, \u2190\n        h\u2082]\n      rfl\n  \u00b7 erw [hm\u2082, hl\u2082']", "start": [2030, 1], "end": [2064, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.leftSquareIsPullback", "code": "def leftSquareIsPullback (H : IsLimit (PullbackCone.mk _ _ h\u2082))\n    (H' :\n      IsLimit\n        (PullbackCone.mk _ _\n          (show i\u2081 \u226b g\u2081 \u226b g\u2082 = (f\u2081 \u226b f\u2082) \u226b i\u2083 by\n            rw [\u2190 Category.assoc, h\u2081, Category.assoc, h\u2082, Category.assoc]))) :\n    IsLimit (PullbackCone.mk _ _ h\u2081) := by\n  fapply PullbackCone.isLimitAux'\n  intro s\n  have : s.fst \u226b g\u2081 \u226b g\u2082 = (s.snd \u226b f\u2082) \u226b i\u2083 := by\n    rw [\u2190 Category.assoc, s.condition, Category.assoc, Category.assoc, h\u2082]\n  rcases PullbackCone.IsLimit.lift' H' s.fst (s.snd \u226b f\u2082) this with \u27e8l\u2081, hl\u2081, hl\u2081'\u27e9\n  use l\u2081\n  use hl\u2081\n  constructor\n  \u00b7 apply PullbackCone.IsLimit.hom_ext H\n    \u00b7 erw [Category.assoc, \u2190 h\u2081, \u2190 Category.assoc, hl\u2081, s.condition]\n      rfl\n    \u00b7 erw [Category.assoc, hl\u2081']\n      rfl\n  \u00b7 intro m hm\u2081 hm\u2082\n    apply PullbackCone.IsLimit.hom_ext H'\n    \u00b7 erw [hm\u2081, hl\u2081]\n    \u00b7 erw [hl\u2081', \u2190 hm\u2082]\n      exact (Category.assoc _ _ _).symm", "start": [2067, 1], "end": [2101, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.rightSquareIsPushout", "code": "def rightSquareIsPushout (H : IsColimit (PushoutCocone.mk _ _ h\u2081))\n    (H' :\n      IsColimit\n        (PushoutCocone.mk _ _\n          (show i\u2081 \u226b g\u2081 \u226b g\u2082 = (f\u2081 \u226b f\u2082) \u226b i\u2083 by\n            rw [\u2190 Category.assoc, h\u2081, Category.assoc, h\u2082, Category.assoc]))) :\n    IsColimit (PushoutCocone.mk _ _ h\u2082) := by\n  fapply PushoutCocone.isColimitAux'\n  intro s\n  have : i\u2081 \u226b g\u2081 \u226b s.inl = (f\u2081 \u226b f\u2082) \u226b s.inr := by\n    rw [Category.assoc, \u2190 s.condition, \u2190 Category.assoc, \u2190 Category.assoc, h\u2081]\n  rcases PushoutCocone.IsColimit.desc' H' (g\u2081 \u226b s.inl) s.inr this with \u27e8l\u2081, hl\u2081, hl\u2081'\u27e9\n  dsimp at *\n  use l\u2081\n  refine' \u27e8_, _, _\u27e9\n  \u00b7 apply PushoutCocone.IsColimit.hom_ext H\n    \u00b7 erw [\u2190 Category.assoc, hl\u2081]\n      rfl\n    \u00b7 erw [\u2190 Category.assoc, h\u2082, Category.assoc, hl\u2081', s.condition]\n  \u00b7 exact hl\u2081'\n  \u00b7 intro m hm\u2081 hm\u2082\n    apply PushoutCocone.IsColimit.hom_ext H'\n    \u00b7 erw [hl\u2081, Category.assoc, hm\u2081]\n    \u00b7 erw [hm\u2082, hl\u2081']", "start": [2104, 1], "end": [2137, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackRightPullbackFstIso", "code": "noncomputable def pullbackRightPullbackFstIso :\n    pullback f' (pullback.fst : pullback f g \u27f6 _) \u2245 pullback (f' \u226b f) g := by\n  let this :=\n    bigSquareIsPullback (pullback.snd : pullback f' (pullback.fst : pullback f g \u27f6 _) \u27f6 _)\n      pullback.snd f' f pullback.fst pullback.fst g pullback.condition pullback.condition\n      (pullbackIsPullback _ _) (pullbackIsPullback _ _)\n  exact (this.conePointUniqueUpToIso (pullbackIsPullback _ _) : _)", "start": [2150, 1], "end": [2157, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackRightPullbackFstIso_hom_fst", "code": "@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_hom_fst :\n    (pullbackRightPullbackFstIso f g f').hom \u226b pullback.fst = pullback.fst", "start": [2160, 1], "end": [2163, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackRightPullbackFstIso_hom_snd", "code": "@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_hom_snd :\n    (pullbackRightPullbackFstIso f g f').hom \u226b pullback.snd = pullback.snd \u226b pullback.snd", "start": [2166, 1], "end": [2169, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackRightPullbackFstIso_inv_fst", "code": "@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_inv_fst :\n    (pullbackRightPullbackFstIso f g f').inv \u226b pullback.fst = pullback.fst", "start": [2172, 1], "end": [2175, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackRightPullbackFstIso_inv_snd_snd", "code": "@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_inv_snd_snd :\n    (pullbackRightPullbackFstIso f g f').inv \u226b pullback.snd \u226b pullback.snd = pullback.snd", "start": [2178, 1], "end": [2181, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackRightPullbackFstIso_inv_snd_fst", "code": "@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_inv_snd_fst :\n    (pullbackRightPullbackFstIso f g f').inv \u226b pullback.snd \u226b pullback.fst = pullback.fst \u226b f'", "start": [2184, 1], "end": [2188, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutLeftPushoutInrIso", "code": "noncomputable def pushoutLeftPushoutInrIso :\n    pushout (pushout.inr : _ \u27f6 pushout f g) g' \u2245 pushout f (g \u226b g') :=\n  ((bigSquareIsPushout g g' _ _ f _ _ pushout.condition pushout.condition (pushoutIsPushout _ _)\n          (pushoutIsPushout _ _)).coconePointUniqueUpToIso\n      (pushoutIsPushout _ _) :\n    _)", "start": [2201, 1], "end": [2207, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inl_pushoutLeftPushoutInrIso_inv", "code": "@[reassoc (attr := simp)]\ntheorem inl_pushoutLeftPushoutInrIso_inv :\n    pushout.inl \u226b (pushoutLeftPushoutInrIso f g g').inv = pushout.inl \u226b pushout.inl", "start": [2210, 1], "end": [2216, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inr_pushoutLeftPushoutInrIso_hom", "code": "@[reassoc (attr := simp)]\ntheorem inr_pushoutLeftPushoutInrIso_hom :\n    pushout.inr \u226b (pushoutLeftPushoutInrIso f g g').hom = pushout.inr", "start": [2219, 1], "end": [2225, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inr_pushoutLeftPushoutInrIso_inv", "code": "@[reassoc (attr := simp)]\ntheorem inr_pushoutLeftPushoutInrIso_inv :\n    pushout.inr \u226b (pushoutLeftPushoutInrIso f g g').inv = pushout.inr", "start": [2228, 1], "end": [2231, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inl_inl_pushoutLeftPushoutInrIso_hom", "code": "@[reassoc (attr := simp)]\ntheorem inl_inl_pushoutLeftPushoutInrIso_hom :\n    pushout.inl \u226b pushout.inl \u226b (pushoutLeftPushoutInrIso f g g').hom = pushout.inl", "start": [2234, 1], "end": [2237, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inr_inl_pushoutLeftPushoutInrIso_hom", "code": "@[reassoc (attr := simp)]\ntheorem inr_inl_pushoutLeftPushoutInrIso_hom :\n    pushout.inr \u226b pushout.inl \u226b (pushoutLeftPushoutInrIso f g g').hom = g' \u226b pushout.inr", "start": [2240, 1], "end": [2244, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackPullbackLeftIsPullback", "code": "def pullbackPullbackLeftIsPullback [HasPullback (g\u2082 \u226b f\u2083) f\u2084] : IsLimit (PullbackCone.mk l\u2081 l\u2082\n    (show l\u2081 \u226b g\u2082 = l\u2082 \u226b g\u2083 from (pullback.lift_fst _ _ _).symm)) := by\n  apply leftSquareIsPullback\n  exact pullbackIsPullback f\u2083 f\u2084\n  convert pullbackIsPullback (g\u2082 \u226b f\u2083) f\u2084\n  rw [pullback.lift_snd]", "start": [2324, 1], "end": [2330, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackAssocIsPullback", "code": "def pullbackAssocIsPullback [HasPullback (g\u2082 \u226b f\u2083) f\u2084] :\n    IsLimit\n      (PullbackCone.mk (l\u2081 \u226b g\u2081) l\u2082\n        (show (l\u2081 \u226b g\u2081) \u226b f\u2081 = l\u2082 \u226b g\u2083 \u226b f\u2082 by\n          rw [pullback.lift_fst_assoc, Category.assoc, Category.assoc, pullback.condition])) := by\n  apply PullbackCone.flipIsLimit\n  apply bigSquareIsPullback\n  \u00b7 apply PullbackCone.flipIsLimit\n    exact pullbackIsPullback f\u2081 f\u2082\n  \u00b7 apply PullbackCone.flipIsLimit\n    apply pullbackPullbackLeftIsPullback\n  \u00b7 exact pullback.lift_fst _ _ _\n  \u00b7 exact pullback.condition.symm", "start": [2333, 1], "end": [2346, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPullback_assoc", "code": "theorem hasPullback_assoc [HasPullback (g\u2082 \u226b f\u2083) f\u2084] : HasPullback f\u2081 (g\u2083 \u226b f\u2082)", "start": [2349, 1], "end": [2350, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackPullbackRightIsPullback", "code": "def pullbackPullbackRightIsPullback [HasPullback f\u2081 (g\u2083 \u226b f\u2082)] :\n    IsLimit (PullbackCone.mk l\u2081' l\u2082' (show l\u2081' \u226b g\u2082 = l\u2082' \u226b g\u2083 from pullback.lift_snd _ _ _)) := by\n  apply PullbackCone.flipIsLimit\n  apply leftSquareIsPullback\n  \u00b7 apply PullbackCone.flipIsLimit\n    exact pullbackIsPullback f\u2081 f\u2082\n  \u00b7 apply PullbackCone.flipIsLimit\n    convert pullbackIsPullback f\u2081 (g\u2083 \u226b f\u2082)\n    rw [pullback.lift_fst]\n  \u00b7 exact pullback.condition.symm", "start": [2353, 1], "end": [2363, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackAssocSymmIsPullback", "code": "def pullbackAssocSymmIsPullback [HasPullback f\u2081 (g\u2083 \u226b f\u2082)] :\n    IsLimit\n      (PullbackCone.mk l\u2081' (l\u2082' \u226b g\u2084)\n        (show l\u2081' \u226b g\u2082 \u226b f\u2083 = (l\u2082' \u226b g\u2084) \u226b f\u2084 by\n          rw [pullback.lift_snd_assoc, Category.assoc, Category.assoc, pullback.condition])) := by\n  apply bigSquareIsPullback\n  exact pullbackIsPullback f\u2083 f\u2084\n  apply pullbackPullbackRightIsPullback", "start": [2366, 1], "end": [2374, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPullback_assoc_symm", "code": "theorem hasPullback_assoc_symm [HasPullback f\u2081 (g\u2083 \u226b f\u2082)] : HasPullback (g\u2082 \u226b f\u2083) f\u2084", "start": [2377, 1], "end": [2378, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackAssoc", "code": "noncomputable def pullbackAssoc [HasPullback ((pullback.snd : Z\u2081 \u27f6 X\u2082) \u226b f\u2083) f\u2084]\n    [HasPullback f\u2081 ((pullback.fst : Z\u2082 \u27f6 X\u2082) \u226b f\u2082)] :\n    pullback (pullback.snd \u226b f\u2083 : pullback f\u2081 f\u2082 \u27f6 _) f\u2084 \u2245\n      pullback f\u2081 (pullback.fst \u226b f\u2082 : pullback f\u2083 f\u2084 \u27f6 _) :=\n  (pullbackPullbackLeftIsPullback f\u2081 f\u2082 f\u2083 f\u2084).conePointUniqueUpToIso\n    (pullbackPullbackRightIsPullback f\u2081 f\u2082 f\u2083 f\u2084)", "start": [2385, 1], "end": [2391, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackAssoc_inv_fst_fst", "code": "@[reassoc (attr := simp)]\ntheorem pullbackAssoc_inv_fst_fst [HasPullback ((pullback.snd : Z\u2081 \u27f6 X\u2082) \u226b f\u2083) f\u2084]\n    [HasPullback f\u2081 ((pullback.fst : Z\u2082 \u27f6 X\u2082) \u226b f\u2082)]:\n    (pullbackAssoc f\u2081 f\u2082 f\u2083 f\u2084).inv \u226b pullback.fst \u226b pullback.fst = pullback.fst", "start": [2394, 1], "end": [2402, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackAssoc_hom_fst", "code": "@[reassoc (attr := simp)]\ntheorem pullbackAssoc_hom_fst [HasPullback ((pullback.snd : Z\u2081 \u27f6 X\u2082) \u226b f\u2083) f\u2084]\n    [HasPullback f\u2081 ((pullback.fst : Z\u2082 \u27f6 X\u2082) \u226b f\u2082)] :\n    (pullbackAssoc f\u2081 f\u2082 f\u2083 f\u2084).hom \u226b pullback.fst = pullback.fst \u226b pullback.fst", "start": [2405, 1], "end": [2409, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackAssoc_hom_snd_fst", "code": "@[reassoc (attr := simp)]\ntheorem pullbackAssoc_hom_snd_fst [HasPullback ((pullback.snd : Z\u2081 \u27f6 X\u2082) \u226b f\u2083) f\u2084]\n    [HasPullback f\u2081 ((pullback.fst : Z\u2082 \u27f6 X\u2082) \u226b f\u2082)] : (pullbackAssoc f\u2081 f\u2082 f\u2083 f\u2084).hom \u226b\n    pullback.snd \u226b pullback.fst = pullback.fst \u226b pullback.snd", "start": [2412, 1], "end": [2420, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackAssoc_hom_snd_snd", "code": "@[reassoc (attr := simp)]\ntheorem pullbackAssoc_hom_snd_snd [HasPullback ((pullback.snd : Z\u2081 \u27f6 X\u2082) \u226b f\u2083) f\u2084]\n    [HasPullback f\u2081 ((pullback.fst : Z\u2082 \u27f6 X\u2082) \u226b f\u2082)] :\n    (pullbackAssoc f\u2081 f\u2082 f\u2083 f\u2084).hom \u226b pullback.snd \u226b pullback.snd = pullback.snd", "start": [2423, 1], "end": [2431, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackAssoc_inv_fst_snd", "code": "@[reassoc (attr := simp)]\ntheorem pullbackAssoc_inv_fst_snd [HasPullback ((pullback.snd : Z\u2081 \u27f6 X\u2082) \u226b f\u2083) f\u2084]\n    [HasPullback f\u2081 ((pullback.fst : Z\u2082 \u27f6 X\u2082) \u226b f\u2082)] :\n    (pullbackAssoc f\u2081 f\u2082 f\u2083 f\u2084).inv \u226b pullback.fst \u226b pullback.snd = pullback.snd \u226b pullback.fst", "start": [2434, 1], "end": [2438, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackAssoc_inv_snd", "code": "@[reassoc (attr := simp)]\ntheorem pullbackAssoc_inv_snd [HasPullback ((pullback.snd : Z\u2081 \u27f6 X\u2082) \u226b f\u2083) f\u2084]\n    [HasPullback f\u2081 ((pullback.fst : Z\u2082 \u27f6 X\u2082) \u226b f\u2082)] :\n    (pullbackAssoc f\u2081 f\u2082 f\u2083 f\u2084).inv \u226b pullback.snd = pullback.snd \u226b pullback.snd", "start": [2441, 1], "end": [2445, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutPushoutLeftIsPushout", "code": "def pushoutPushoutLeftIsPushout [HasPushout (g\u2083 \u226b f\u2082) g\u2084] :\n    IsColimit\n      (PushoutCocone.mk l\u2081' l\u2082' (show f\u2082 \u226b l\u2081' = f\u2083 \u226b l\u2082' from (pushout.inl_desc _ _ _).symm)) := by\n  apply PushoutCocone.flipIsColimit\n  apply rightSquareIsPushout\n  \u00b7 apply PushoutCocone.flipIsColimit\n    exact pushoutIsPushout _ _\n  \u00b7 apply PushoutCocone.flipIsColimit\n    convert pushoutIsPushout (g\u2083 \u226b f\u2082) g\u2084\n    exact pushout.inr_desc _ _ _\n  \u00b7 exact pushout.condition.symm", "start": [2524, 1], "end": [2535, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutAssocIsPushout", "code": "def pushoutAssocIsPushout [HasPushout (g\u2083 \u226b f\u2082) g\u2084] :\n    IsColimit\n      (PushoutCocone.mk (f\u2081 \u226b l\u2081') l\u2082'\n        (show g\u2081 \u226b f\u2081 \u226b l\u2081' = (g\u2082 \u226b f\u2083) \u226b l\u2082' by\n          rw [Category.assoc, pushout.inl_desc, pushout.condition_assoc])) := by\n  apply bigSquareIsPushout\n  \u00b7 apply pushoutPushoutLeftIsPushout\n  \u00b7 exact pushoutIsPushout _ _", "start": [2538, 1], "end": [2546, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPushout_assoc", "code": "theorem hasPushout_assoc [HasPushout (g\u2083 \u226b f\u2082) g\u2084] : HasPushout g\u2081 (g\u2082 \u226b f\u2083)", "start": [2549, 1], "end": [2550, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutPushoutRightIsPushout", "code": "def pushoutPushoutRightIsPushout [HasPushout g\u2081 (g\u2082 \u226b f\u2083)] :\n    IsColimit (PushoutCocone.mk l\u2081 l\u2082 (show f\u2082 \u226b l\u2081 = f\u2083 \u226b l\u2082 from pushout.inr_desc _ _ _)) := by\n  apply rightSquareIsPushout\n  \u00b7 exact pushoutIsPushout _ _\n  \u00b7 convert pushoutIsPushout g\u2081 (g\u2082 \u226b f\u2083)\n    rw [pushout.inl_desc]", "start": [2553, 1], "end": [2559, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutAssocSymmIsPushout", "code": "def pushoutAssocSymmIsPushout [HasPushout g\u2081 (g\u2082 \u226b f\u2083)] :\n    IsColimit\n      (PushoutCocone.mk l\u2081 (f\u2084 \u226b l\u2082)\n        (show (g\u2083 \u226b f\u2082) \u226b l\u2081 = g\u2084 \u226b f\u2084 \u226b l\u2082 by\n          rw [Category.assoc, pushout.inr_desc, pushout.condition_assoc])) := by\n  apply PushoutCocone.flipIsColimit\n  apply bigSquareIsPushout\n  \u00b7 apply PushoutCocone.flipIsColimit\n    apply pushoutPushoutRightIsPushout\n  \u00b7 apply PushoutCocone.flipIsColimit\n    exact pushoutIsPushout _ _\n  \u00b7 exact pushout.condition.symm\n  \u00b7 exact (pushout.inr_desc _ _ _).symm", "start": [2562, 1], "end": [2575, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPushout_assoc_symm", "code": "theorem hasPushout_assoc_symm [HasPushout g\u2081 (g\u2082 \u226b f\u2083)] : HasPushout (g\u2083 \u226b f\u2082) g\u2084", "start": [2578, 1], "end": [2579, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutAssoc", "code": "noncomputable def pushoutAssoc [HasPushout (g\u2083 \u226b (pushout.inr : X\u2082 \u27f6 Y\u2081)) g\u2084]\n    [HasPushout g\u2081 (g\u2082 \u226b (pushout.inl : X\u2082 \u27f6 Y\u2082))]:\n    pushout (g\u2083 \u226b pushout.inr : _ \u27f6 pushout g\u2081 g\u2082) g\u2084 \u2245\n      pushout g\u2081 (g\u2082 \u226b pushout.inl : _ \u27f6 pushout g\u2083 g\u2084) :=\n  (pushoutPushoutLeftIsPushout g\u2081 g\u2082 g\u2083 g\u2084).coconePointUniqueUpToIso\n    (pushoutPushoutRightIsPushout g\u2081 g\u2082 g\u2083 g\u2084)", "start": [2585, 1], "end": [2591, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inl_inl_pushoutAssoc_hom", "code": "@[reassoc (attr := simp)]\ntheorem inl_inl_pushoutAssoc_hom [HasPushout (g\u2083 \u226b (pushout.inr : X\u2082 \u27f6 Y\u2081)) g\u2084]\n    [HasPushout g\u2081 (g\u2082 \u226b (pushout.inl : X\u2082 \u27f6 Y\u2082))] :\n    pushout.inl \u226b pushout.inl \u226b (pushoutAssoc g\u2081 g\u2082 g\u2083 g\u2084).hom = pushout.inl", "start": [2594, 1], "end": [2603, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inr_inl_pushoutAssoc_hom", "code": "@[reassoc (attr := simp)]\ntheorem inr_inl_pushoutAssoc_hom [HasPushout (g\u2083 \u226b (pushout.inr : X\u2082 \u27f6 Y\u2081)) g\u2084]\n    [HasPushout g\u2081 (g\u2082 \u226b (pushout.inl : X\u2082 \u27f6 Y\u2082))] :\n    pushout.inr \u226b pushout.inl \u226b (pushoutAssoc g\u2081 g\u2082 g\u2083 g\u2084).hom = pushout.inl \u226b pushout.inr", "start": [2606, 1], "end": [2615, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inr_inr_pushoutAssoc_inv", "code": "@[reassoc (attr := simp)]\ntheorem inr_inr_pushoutAssoc_inv [HasPushout (g\u2083 \u226b (pushout.inr : X\u2082 \u27f6 Y\u2081)) g\u2084]\n    [HasPushout g\u2081 (g\u2082 \u226b (pushout.inl : X\u2082 \u27f6 Y\u2082))] :\n    pushout.inr \u226b pushout.inr \u226b (pushoutAssoc g\u2081 g\u2082 g\u2083 g\u2084).inv = pushout.inr", "start": [2618, 1], "end": [2627, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inl_pushoutAssoc_inv", "code": "@[reassoc (attr := simp)]\ntheorem inl_pushoutAssoc_inv [HasPushout (g\u2083 \u226b (pushout.inr : X\u2082 \u27f6 Y\u2081)) g\u2084]\n    [HasPushout g\u2081 (g\u2082 \u226b (pushout.inl : X\u2082 \u27f6 Y\u2082))] :\n    pushout.inl \u226b (pushoutAssoc g\u2081 g\u2082 g\u2083 g\u2084).inv = pushout.inl \u226b pushout.inl", "start": [2630, 1], "end": [2634, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inl_inr_pushoutAssoc_inv", "code": "@[reassoc (attr := simp)]\ntheorem inl_inr_pushoutAssoc_inv [HasPushout (g\u2083 \u226b (pushout.inr : X\u2082 \u27f6 Y\u2081)) g\u2084]\n    [HasPushout g\u2081 (g\u2082 \u226b (pushout.inl : X\u2082 \u27f6 Y\u2082))] :\n    pushout.inl \u226b pushout.inr \u226b (pushoutAssoc g\u2081 g\u2082 g\u2083 g\u2084).inv = pushout.inr \u226b pushout.inl", "start": [2637, 1], "end": [2641, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inr_pushoutAssoc_hom", "code": "@[reassoc (attr := simp)]\ntheorem inr_pushoutAssoc_hom [HasPushout (g\u2083 \u226b (pushout.inr : X\u2082 \u27f6 Y\u2081)) g\u2084]\n    [HasPushout g\u2081 (g\u2082 \u226b (pushout.inl : X\u2082 \u27f6 Y\u2082))] :\n    pushout.inr \u226b (pushoutAssoc g\u2081 g\u2082 g\u2083 g\u2084).hom = pushout.inr \u226b pushout.inr", "start": [2644, 1], "end": [2648, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasPullbacks", "code": "abbrev HasPullbacks :=\n  HasLimitsOfShape WalkingCospan C", "start": [2655, 1], "end": [2660, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasPushouts", "code": "abbrev HasPushouts :=\n  HasColimitsOfShape WalkingSpan C", "start": [2663, 1], "end": [2665, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPullbacks_of_hasLimit_cospan", "code": "theorem hasPullbacks_of_hasLimit_cospan\n    [\u2200 {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z}, HasLimit (cospan f g)] : HasPullbacks C", "start": [2668, 1], "end": [2671, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPushouts_of_hasColimit_span", "code": "theorem hasPushouts_of_hasColimit_span\n    [\u2200 {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z}, HasColimit (span f g)] : HasPushouts C", "start": [2674, 1], "end": [2677, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingSpanOpEquiv", "code": "@[simps!]\ndef walkingSpanOpEquiv : WalkingSpan\u1d52\u1d56 \u224c WalkingCospan :=\n  widePushoutShapeOpEquiv _", "start": [2680, 1], "end": [2683, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingCospanOpEquiv", "code": "@[simps!]\ndef walkingCospanOpEquiv : WalkingCospan\u1d52\u1d56 \u224c WalkingSpan :=\n  widePullbackShapeOpEquiv _", "start": [2686, 1], "end": [2689, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks", "code": "instance (priority := 100) hasPullbacks_of_hasWidePullbacks (D : Type u) [h : Category.{v} D]\n    [h' : HasWidePullbacks.{w} D] : HasPullbacks.{v,u} D := by\n  haveI I := @hasWidePullbacks_shrink.{0, w} D h h'\n  infer_instance", "start": [2693, 1], "end": [2697, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPushouts_of_hasWidePushouts", "code": "instance (priority := 100) hasPushouts_of_hasWidePushouts (D : Type u) [h : Category.{v} D]\n    [h' : HasWidePushouts.{w} D] : HasPushouts.{v,u} D := by\n  haveI I := @hasWidePushouts_shrink.{0, w} D h h'\n  infer_instance", "start": [2701, 1], "end": [2705, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.baseChange", "code": "@[simps! (config := { simpRhs := true}) obj_left obj_hom map_left]\ndef baseChange [HasPullbacks C] {X Y : C} (f : X \u27f6 Y) : Over Y \u2964 Over X where\n  obj g := Over.mk (pullback.snd : pullback g.hom f \u27f6 _)\n  map i := Over.homMk (pullback.map _ _ _ _ i.left (\ud835\udfd9 _) (\ud835\udfd9 _) (by simp) (by simp))\n  map_id Z := by\n    apply Over.OverMorphism.ext; apply pullback.hom_ext\n    \u00b7 dsimp; simp\n    \u00b7 dsimp; simp\n  map_comp f g := by\n    apply Over.OverMorphism.ext; apply pullback.hom_ext\n    \u00b7 dsimp; simp\n    \u00b7 dsimp; simp", "start": [2710, 1], "end": [2723, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Sets/Closeds.lean", "imports": ["Mathlib/Topology/Sets/Opens.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopologicalSpace.Closeds", "code": "structure Closeds (\u03b1 : Type*) [TopologicalSpace \u03b1] where\n  carrier : Set \u03b1\n  closed' : IsClosed carrier", "start": [32, 1], "end": [35, 29], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.closed", "code": "theorem closed (s : Closeds \u03b1) : IsClosed (s : Set \u03b1)", "start": [47, 1], "end": [48, 12], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.Simps.coe", "code": "def Simps.coe (s : Closeds \u03b1) : Set \u03b1 := s", "start": [51, 1], "end": [52, 43], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.ext", "code": "@[ext]\nprotected theorem ext {s t : Closeds \u03b1} (h : (s : Set \u03b1) = t) : s = t", "start": [56, 1], "end": [58, 17], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.coe_mk", "code": "@[simp]\ntheorem coe_mk (s : Set \u03b1) (h) : (mk s h : Set \u03b1) = s", "start": [61, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.closure", "code": "protected def closure (s : Set \u03b1) : Closeds \u03b1 :=\n  \u27e8closure s, isClosed_closure\u27e9", "start": [66, 1], "end": [68, 32], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.gc", "code": "theorem gc : GaloisConnection Closeds.closure ((\u2191) : Closeds \u03b1 \u2192 Set \u03b1)", "start": [71, 1], "end": [72, 62], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.gi", "code": "def gi : GaloisInsertion (@Closeds.closure \u03b1 _) (\u2191) where\n  choice s hs := \u27e8s, closure_eq_iff_isClosed.1 <| hs.antisymm subset_closure\u27e9\n  gc := gc\n  le_l_u _ := subset_closure\n  choice_eq _s hs := SetLike.coe_injective <| subset_closure.antisymm hs", "start": [75, 1], "end": [80, 73], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.coe_sup", "code": "@[simp, norm_cast]\ntheorem coe_sup (s t : Closeds \u03b1) : (\u2191(s \u2294 t) : Set \u03b1) = \u2191s \u222a \u2191t", "start": [107, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf (s t : Closeds \u03b1) : (\u2191(s \u2293 t) : Set \u03b1) = \u2191s \u2229 \u2191t", "start": [112, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.coe_top", "code": "@[simp, norm_cast]\ntheorem coe_top : (\u2191(\u22a4 : Closeds \u03b1) : Set \u03b1) = univ", "start": [117, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.coe_eq_univ", "code": "@[simp, norm_cast] theorem coe_eq_univ {s : Closeds \u03b1} : (s : Set \u03b1) = univ \u2194 s = \u22a4", "start": [122, 1], "end": [124, 36], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.coe_bot", "code": "@[simp, norm_cast]\ntheorem coe_bot : (\u2191(\u22a5 : Closeds \u03b1) : Set \u03b1) = \u2205", "start": [126, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.coe_eq_empty", "code": "@[simp, norm_cast] theorem coe_eq_empty {s : Closeds \u03b1} : (s : Set \u03b1) = \u2205 \u2194 s = \u22a5", "start": [131, 1], "end": [133, 36], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.coe_nonempty", "code": "theorem coe_nonempty {s : Closeds \u03b1} : (s : Set \u03b1).Nonempty \u2194 s \u2260 \u22a5", "start": [135, 1], "end": [136, 47], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.coe_sInf", "code": "@[simp, norm_cast]\ntheorem coe_sInf {S : Set (Closeds \u03b1)} : (\u2191(sInf S) : Set \u03b1) = \u22c2 i \u2208 S, \u2191i", "start": [138, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.coe_finset_sup", "code": "@[simp, norm_cast]\ntheorem coe_finset_sup (f : \u03b9 \u2192 Closeds \u03b1) (s : Finset \u03b9) :\n    (\u2191(s.sup f) : Set \u03b1) = s.sup ((\u2191) \u2218 f)", "start": [143, 1], "end": [146, 81], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.coe_finset_inf", "code": "@[simp, norm_cast]\ntheorem coe_finset_inf (f : \u03b9 \u2192 Closeds \u03b1) (s : Finset \u03b9) :\n    (\u2191(s.inf f) : Set \u03b1) = s.inf ((\u2191) \u2218 f)", "start": [149, 1], "end": [152, 81], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.mem_sInf", "code": "@[simp]\ntheorem mem_sInf {S : Set (Closeds \u03b1)} {x : \u03b1} : x \u2208 sInf S \u2194 \u2200 s \u2208 S, x \u2208 s", "start": [157, 1], "end": [158, 92], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.mem_iInf", "code": "@[simp]\ntheorem mem_iInf {\u03b9} {x : \u03b1} {s : \u03b9 \u2192 Closeds \u03b1} : x \u2208 iInf s \u2194 \u2200 i, x \u2208 s i", "start": [161, 1], "end": [162, 95], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.coe_iInf", "code": "@[simp, norm_cast]\ntheorem coe_iInf {\u03b9} (s : \u03b9 \u2192 Closeds \u03b1) : ((\u2a05 i, s i : Closeds \u03b1) : Set \u03b1) = \u22c2 i, s i", "start": [165, 1], "end": [167, 12], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.iInf_def", "code": "theorem iInf_def {\u03b9} (s : \u03b9 \u2192 Closeds \u03b1) :\n    \u2a05 i, s i = \u27e8\u22c2 i, s i, isClosed_iInter fun i => (s i).2\u27e9", "start": [170, 1], "end": [171, 77], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.iInf_mk", "code": "@[simp]\ntheorem iInf_mk {\u03b9} (s : \u03b9 \u2192 Set \u03b1) (h : \u2200 i, IsClosed (s i)) :\n    (\u2a05 i, \u27e8s i, h i\u27e9 : Closeds \u03b1) = \u27e8\u22c2 i, s i, isClosed_iInter h\u27e9", "start": [174, 1], "end": [177, 13], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.singleton", "code": "@[simps]\ndef singleton [T1Space \u03b1] (x : \u03b1) : Closeds \u03b1 :=\n  \u27e8{x}, isClosed_singleton\u27e9", "start": [186, 1], "end": [189, 28], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.compl", "code": "@[simps]\ndef Closeds.compl (s : Closeds \u03b1) : Opens \u03b1 :=\n  \u27e8s\u1d9c, s.2.isOpen_compl\u27e9", "start": [194, 1], "end": [197, 25], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.compl", "code": "@[simps]\ndef Opens.compl (s : Opens \u03b1) : Closeds \u03b1 :=\n  \u27e8s\u1d9c, s.2.isClosed_compl\u27e9", "start": [200, 1], "end": [203, 27], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.compl_compl", "code": "nonrec theorem Closeds.compl_compl (s : Closeds \u03b1) : s.compl.compl = s", "start": [206, 1], "end": [207, 40], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.compl_compl", "code": "nonrec theorem Opens.compl_compl (s : Opens \u03b1) : s.compl.compl = s", "start": [210, 1], "end": [211, 38], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.compl_bijective", "code": "theorem Closeds.compl_bijective : Function.Bijective (@Closeds.compl \u03b1 _)", "start": [214, 1], "end": [215, 95], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.compl_bijective", "code": "theorem Opens.compl_bijective : Function.Bijective (@Opens.compl \u03b1 _)", "start": [218, 1], "end": [219, 97], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.complOrderIso", "code": "@[simps]\ndef Closeds.complOrderIso : Closeds \u03b1 \u2243o (Opens \u03b1)\u1d52\u1d48 where\n  toFun := OrderDual.toDual \u2218 Closeds.compl\n  invFun := Opens.compl \u2218 OrderDual.ofDual\n  left_inv s := by simp [Closeds.compl_compl]\n  right_inv s := by simp [Opens.compl_compl]\n  map_rel_iff' := (@OrderDual.toDual_le_toDual (Opens \u03b1)).trans compl_subset_compl", "start": [224, 1], "end": [232, 83], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.complOrderIso", "code": "@[simps]\ndef Opens.complOrderIso : Opens \u03b1 \u2243o (Closeds \u03b1)\u1d52\u1d48 where\n  toFun := OrderDual.toDual \u2218 Opens.compl\n  invFun := Closeds.compl \u2218 OrderDual.ofDual\n  left_inv s := by simp [Opens.compl_compl]\n  right_inv s := by simp [Closeds.compl_compl]\n  map_rel_iff' := (@OrderDual.toDual_le_toDual (Closeds \u03b1)).trans compl_subset_compl", "start": [235, 1], "end": [243, 85], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Closeds.isAtom_iff", "code": "theorem Closeds.isAtom_iff [T1Space \u03b1] {s : Closeds \u03b1} :\n    IsAtom s \u2194 \u2203 x, s = Closeds.singleton x", "start": [248, 1], "end": [259, 86], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.isCoatom_iff", "code": "theorem Opens.isCoatom_iff [T1Space \u03b1] {s : Opens \u03b1} :\n    IsCoatom s \u2194 \u2203 x, s = (Closeds.singleton x).compl", "start": [262, 1], "end": [269, 46], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Clopens", "code": "structure Clopens (\u03b1 : Type*) [TopologicalSpace \u03b1] where\n  carrier : Set \u03b1\n  clopen' : IsClopen carrier", "start": [275, 1], "end": [278, 29], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Clopens.clopen", "code": "theorem clopen (s : Clopens \u03b1) : IsClopen (s : Set \u03b1)", "start": [287, 1], "end": [288, 12], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Clopens.Simps.coe", "code": "def Simps.coe (s : Clopens \u03b1) : Set \u03b1 := s", "start": [291, 1], "end": [292, 43], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Clopens.toOpens", "code": "@[simps]\ndef toOpens (s : Clopens \u03b1) : Opens \u03b1 :=\n  \u27e8s, s.clopen.isOpen\u27e9", "start": [296, 1], "end": [299, 23], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Clopens.ext", "code": "@[ext]\nprotected theorem ext {s t : Clopens \u03b1} (h : (s : Set \u03b1) = t) : s = t", "start": [302, 1], "end": [304, 17], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Clopens.coe_mk", "code": "@[simp]\ntheorem coe_mk (s : Set \u03b1) (h) : (mk s h : Set \u03b1) = s", "start": [307, 1], "end": [309, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Clopens.coe_sup", "code": "@[simp] theorem coe_sup (s t : Clopens \u03b1) : (\u2191(s \u2294 t) : Set \u03b1) = \u2191s \u222a \u2191t", "start": [323, 1], "end": [323, 80], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Clopens.coe_inf", "code": "@[simp] theorem coe_inf (s t : Clopens \u03b1) : (\u2191(s \u2293 t) : Set \u03b1) = \u2191s \u2229 \u2191t", "start": [326, 1], "end": [326, 80], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Clopens.coe_top", "code": "@[simp] theorem coe_top : (\u2191(\u22a4 : Clopens \u03b1) : Set \u03b1) = univ", "start": [329, 1], "end": [329, 67], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Clopens.coe_bot", "code": "@[simp] theorem coe_bot : (\u2191(\u22a5 : Clopens \u03b1) : Set \u03b1) = \u2205", "start": [332, 1], "end": [332, 64], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Clopens.coe_sdiff", "code": "@[simp] theorem coe_sdiff (s t : Clopens \u03b1) : (\u2191(s \\ t) : Set \u03b1) = \u2191s \\ \u2191t", "start": [335, 1], "end": [335, 82], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Clopens.coe_compl", "code": "@[simp] theorem coe_compl (s : Clopens \u03b1) : (\u2191s\u1d9c : Set \u03b1) = (\u2191s)\u1d9c", "start": [338, 1], "end": [338, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean", "imports": ["Mathlib/Analysis/Asymptotics/Theta.lean", "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "Mathlib/Analysis/Normed/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Asymptotics.IsEquivalent", "code": "def IsEquivalent (l : Filter \u03b1) (u v : \u03b1 \u2192 \u03b2) :=\n  (u - v) =o[l] v", "start": [71, 1], "end": [74, 18], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.isLittleO", "code": "theorem IsEquivalent.isLittleO (h : u ~[l] v) : (u - v) =o[l] v", "start": [81, 1], "end": [81, 69], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.isBigO", "code": "nonrec theorem IsEquivalent.isBigO (h : u ~[l] v) : u =O[l] v", "start": [84, 1], "end": [85, 59], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.isBigO_symm", "code": "theorem IsEquivalent.isBigO_symm (h : u ~[l] v) : v =O[l] u", "start": [89, 1], "end": [91, 7], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.isTheta", "code": "theorem IsEquivalent.isTheta (h : u ~[l] v) : u =\u0398[l] v", "start": [95, 1], "end": [96, 28], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.isTheta_symm", "code": "theorem IsEquivalent.isTheta_symm (h : u ~[l] v) : v =\u0398[l] u", "start": [98, 1], "end": [99, 28], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.refl", "code": "@[refl]\ntheorem IsEquivalent.refl : u ~[l] u", "start": [101, 1], "end": [104, 27], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.symm", "code": "@[symm]\ntheorem IsEquivalent.symm (h : u ~[l] v) : v ~[l] u", "start": [107, 1], "end": [109, 48], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.trans", "code": "@[trans]\ntheorem IsEquivalent.trans {l : Filter \u03b1} {u v w : \u03b1 \u2192 \u03b2} (huv : u ~[l] v) (hvw : v ~[l] w) :\n    u ~[l] w", "start": [112, 1], "end": [115, 65], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.congr_left", "code": "theorem IsEquivalent.congr_left {u v w : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} (huv : u ~[l] v) (huw : u =\u1da0[l] w) :\n    w ~[l] v", "start": [118, 1], "end": [120, 71], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.congr_right", "code": "theorem IsEquivalent.congr_right {u v w : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} (huv : u ~[l] v) (hvw : v =\u1da0[l] w) :\n    u ~[l] w", "start": [123, 1], "end": [125, 33], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isEquivalent_zero_iff_eventually_zero", "code": "theorem isEquivalent_zero_iff_eventually_zero : u ~[l] 0 \u2194 u =\u1da0[l] 0", "start": [128, 1], "end": [130, 33], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isEquivalent_zero_iff_isBigO_zero", "code": "theorem isEquivalent_zero_iff_isBigO_zero : u ~[l] 0 \u2194 u =O[l] (0 : \u03b1 \u2192 \u03b2)", "start": [133, 1], "end": [136, 73], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isEquivalent_const_iff_tendsto", "code": "theorem isEquivalent_const_iff_tendsto {c : \u03b2} (h : c \u2260 0) :\n    u ~[l] const _ c \u2194 Tendsto u l (\ud835\udcdd c)", "start": [140, 1], "end": [148, 27], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.tendsto_const", "code": "theorem IsEquivalent.tendsto_const {c : \u03b2} (hu : u ~[l] const _ c) : Tendsto u l (\ud835\udcdd c)", "start": [151, 1], "end": [154, 51], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.tendsto_nhds", "code": "theorem IsEquivalent.tendsto_nhds {c : \u03b2} (huv : u ~[l] v) (hu : Tendsto u l (\ud835\udcdd c)) :\n    Tendsto v l (\ud835\udcdd c)", "start": [157, 1], "end": [164, 28], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.tendsto_nhds_iff", "code": "theorem IsEquivalent.tendsto_nhds_iff {c : \u03b2} (huv : u ~[l] v) :\n    Tendsto u l (\ud835\udcdd c) \u2194 Tendsto v l (\ud835\udcdd c)", "start": [167, 1], "end": [169, 44], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.add_isLittleO", "code": "theorem IsEquivalent.add_isLittleO (huv : u ~[l] v) (hwv : w =o[l] v) : u + w ~[l] v", "start": [172, 1], "end": [173, 66], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.sub_isLittleO", "code": "theorem IsEquivalent.sub_isLittleO (huv : u ~[l] v) (hwv : w =o[l] v) : u - w ~[l] v", "start": [176, 1], "end": [177, 67], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.add_isEquivalent", "code": "theorem IsLittleO.add_isEquivalent (hu : u =o[l] w) (hv : v ~[l] w) : u + v ~[l] w", "start": [180, 1], "end": [181, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.isEquivalent", "code": "theorem IsLittleO.isEquivalent (huv : (u - v) =o[l] v) : u ~[l] v", "start": [184, 1], "end": [184, 73], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.neg", "code": "theorem IsEquivalent.neg (huv : u ~[l] v) : (fun x \u21a6 -u x) ~[l] fun x \u21a6 -v x", "start": [187, 1], "end": [190, 24], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isEquivalent_iff_exists_eq_mul", "code": "theorem isEquivalent_iff_exists_eq_mul :\n    u ~[l] v \u2194 \u2203 (\u03c6 : \u03b1 \u2192 \u03b2) (_ : Tendsto \u03c6 l (\ud835\udcdd 1)), u =\u1da0[l] \u03c6 * v", "start": [201, 1], "end": [210, 58], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.exists_eq_mul", "code": "theorem IsEquivalent.exists_eq_mul (huv : u ~[l] v) :\n    \u2203 (\u03c6 : \u03b1 \u2192 \u03b2) (_ : Tendsto \u03c6 l (\ud835\udcdd 1)), u =\u1da0[l] \u03c6 * v", "start": [213, 1], "end": [215, 40], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isEquivalent_of_tendsto_one", "code": "theorem isEquivalent_of_tendsto_one (hz : \u2200\u1da0 x in l, v x = 0 \u2192 u x = 0)\n    (huv : Tendsto (u / v) l (\ud835\udcdd 1)) : u ~[l] v", "start": [218, 1], "end": [221, 77], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isEquivalent_of_tendsto_one'", "code": "theorem isEquivalent_of_tendsto_one' (hz : \u2200 x, v x = 0 \u2192 u x = 0) (huv : Tendsto (u / v) l (\ud835\udcdd 1)) :\n    u ~[l] v", "start": [224, 1], "end": [226, 60], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isEquivalent_iff_tendsto_one", "code": "theorem isEquivalent_iff_tendsto_one (hz : \u2200\u1da0 x in l, v x \u2260 0) :\n    u ~[l] v \u2194 Tendsto (u / v) l (\ud835\udcdd 1)", "start": [229, 1], "end": [240, 79], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.smul", "code": "theorem IsEquivalent.smul {\u03b1 E \ud835\udd5c : Type*} [NormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n    {a b : \u03b1 \u2192 \ud835\udd5c} {u v : \u03b1 \u2192 E} {l : Filter \u03b1} (hab : a ~[l] b) (huv : u ~[l] v) :\n    (fun x \u21a6 a x \u2022 u x) ~[l] fun x \u21a6 b x \u2022 v x", "start": [247, 1], "end": [281, 29], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.mul", "code": "theorem IsEquivalent.mul (htu : t ~[l] u) (hvw : v ~[l] w) : t * v ~[l] u * w", "start": [290, 1], "end": [291, 15], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.inv", "code": "theorem IsEquivalent.inv (huv : u ~[l] v) : (fun x \u21a6 (u x)\u207b\u00b9) ~[l] fun x \u21a6 (v x)\u207b\u00b9", "start": [294, 1], "end": [300, 18], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.div", "code": "theorem IsEquivalent.div (htu : t ~[l] u) (hvw : v ~[l] w) :\n    (fun x \u21a6 t x / v x) ~[l] fun x \u21a6 u x / w x", "start": [303, 1], "end": [305, 52], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.tendsto_atTop", "code": "theorem IsEquivalent.tendsto_atTop [OrderTopology \u03b2] (huv : u ~[l] v) (hu : Tendsto u l atTop) :\n    Tendsto v l atTop", "start": [314, 1], "end": [317, 69], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.tendsto_atTop_iff", "code": "theorem IsEquivalent.tendsto_atTop_iff [OrderTopology \u03b2] (huv : u ~[l] v) :\n    Tendsto u l atTop \u2194 Tendsto v l atTop", "start": [320, 1], "end": [322, 46], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.tendsto_atBot", "code": "theorem IsEquivalent.tendsto_atBot [OrderTopology \u03b2] (huv : u ~[l] v) (hu : Tendsto u l atBot) :\n    Tendsto v l atBot", "start": [325, 1], "end": [329, 7], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.tendsto_atBot_iff", "code": "theorem IsEquivalent.tendsto_atBot_iff [OrderTopology \u03b2] (huv : u ~[l] v) :\n    Tendsto u l atBot \u2194 Tendsto v l atBot", "start": [332, 1], "end": [334, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.isEquivalent", "code": "theorem Filter.EventuallyEq.isEquivalent {u v : \u03b1 \u2192 \u03b2} (h : u =\u1da0[l] v) : u ~[l] v", "start": [347, 1], "end": [348, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.trans_isEquivalent", "code": "@[trans]\ntheorem Filter.EventuallyEq.trans_isEquivalent {f g\u2081 g\u2082 : \u03b1 \u2192 \u03b2} (h : f =\u1da0[l] g\u2081)\n    (h\u2082 : g\u2081 ~[l] g\u2082) : f ~[l] g\u2082", "start": [351, 1], "end": [354, 26], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transIsEquivalentIsEquivalent", "code": "instance transIsEquivalentIsEquivalent :\n    @Trans (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2) (IsEquivalent l) (IsEquivalent l) (IsEquivalent l) where\n  trans := IsEquivalent.trans", "start": [358, 1], "end": [360, 30], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transEventuallyEqIsEquivalent", "code": "instance transEventuallyEqIsEquivalent :\n    @Trans (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2) (EventuallyEq l) (IsEquivalent l) (IsEquivalent l) where\n  trans := EventuallyEq.trans_isEquivalent", "start": [362, 1], "end": [364, 43], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.trans_eventuallyEq", "code": "@[trans]\ntheorem IsEquivalent.trans_eventuallyEq {f g\u2081 g\u2082 : \u03b1 \u2192 \u03b2} (h : f ~[l] g\u2081)\n    (h\u2082 : g\u2081 =\u1da0[l] g\u2082) : f ~[l] g\u2082", "start": [366, 1], "end": [369, 26], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transIsEquivalentEventuallyEq", "code": "instance transIsEquivalentEventuallyEq :\n    @Trans (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2) (IsEquivalent l) (EventuallyEq l) (IsEquivalent l) where\n  trans := IsEquivalent.trans_eventuallyEq", "start": [371, 1], "end": [373, 43], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.trans_isBigO", "code": "@[trans]\ntheorem IsEquivalent.trans_isBigO {f g\u2081 : \u03b1 \u2192 \u03b2} {g\u2082 : \u03b1 \u2192 \u03b2\u2082} (h : f ~[l] g\u2081) (h\u2082 : g\u2081 =O[l] g\u2082) :\n    f =O[l] g\u2082", "start": [375, 1], "end": [378, 27], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transIsEquivalentIsBigO", "code": "instance transIsEquivalentIsBigO :\n    @Trans (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2\u2082) (IsEquivalent l) (IsBigO l) (IsBigO l) where\n  trans := IsEquivalent.trans_isBigO", "start": [380, 1], "end": [382, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.trans_isEquivalent", "code": "@[trans]\ntheorem IsBigO.trans_isEquivalent {f : \u03b1 \u2192 \u03b2\u2082} {g\u2081 g\u2082 : \u03b1 \u2192 \u03b2} (h : f =O[l] g\u2081) (h\u2082 : g\u2081 ~[l] g\u2082) :\n    f =O[l] g\u2082", "start": [384, 1], "end": [387, 27], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transIsBigOIsEquivalent", "code": "instance transIsBigOIsEquivalent :\n    @Trans (\u03b1 \u2192 \u03b2\u2082) (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2) (IsBigO l) (IsEquivalent l) (IsBigO l) where\n  trans := IsBigO.trans_isEquivalent", "start": [389, 1], "end": [391, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.trans_isLittleO", "code": "@[trans]\ntheorem IsEquivalent.trans_isLittleO {f g\u2081 : \u03b1 \u2192 \u03b2} {g\u2082 : \u03b1 \u2192 \u03b2\u2082} (h : f ~[l] g\u2081)\n    (h\u2082 : g\u2081 =o[l] g\u2082) : f =o[l] g\u2082", "start": [393, 1], "end": [396, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transIsEquivalentIsLittleO", "code": "instance transIsEquivalentIsLittleO :\n    @Trans (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2\u2082) (IsEquivalent l) (IsLittleO l) (IsLittleO l) where\n  trans := IsEquivalent.trans_isLittleO", "start": [398, 1], "end": [400, 40], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.trans_isEquivalent", "code": "@[trans]\ntheorem IsLittleO.trans_isEquivalent {f : \u03b1 \u2192 \u03b2\u2082} {g\u2081 g\u2082 : \u03b1 \u2192 \u03b2} (h : f =o[l] g\u2081)\n    (h\u2082 : g\u2081 ~[l] g\u2082) : f =o[l] g\u2082", "start": [402, 1], "end": [405, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transIsLittleOIsEquivalent", "code": "instance transIsLittleOIsEquivalent :\n    @Trans (\u03b1 \u2192 \u03b2\u2082) (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2) (IsLittleO l) (IsEquivalent l) (IsLittleO l) where\n  trans := IsLittleO.trans_isEquivalent", "start": [407, 1], "end": [409, 40], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsEquivalent.trans_isTheta", "code": "@[trans]\ntheorem IsEquivalent.trans_isTheta {f g\u2081 : \u03b1 \u2192 \u03b2} {g\u2082 : \u03b1 \u2192 \u03b2\u2082} (h : f ~[l] g\u2081)\n    (h\u2082 : g\u2081 =\u0398[l] g\u2082) : f =\u0398[l] g\u2082", "start": [411, 1], "end": [414, 29], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transIsEquivalentIsTheta", "code": "instance transIsEquivalentIsTheta :\n    @Trans (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2\u2082) (IsEquivalent l) (IsTheta l) (IsTheta l) where\n  trans := IsEquivalent.trans_isTheta", "start": [416, 1], "end": [418, 38], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.trans_isEquivalent", "code": "@[trans]\ntheorem IsTheta.trans_isEquivalent {f : \u03b1 \u2192 \u03b2\u2082} {g\u2081 g\u2082 : \u03b1 \u2192 \u03b2} (h : f =\u0398[l] g\u2081)\n    (h\u2082 : g\u2081 ~[l] g\u2082) : f =\u0398[l] g\u2082", "start": [420, 1], "end": [423, 29], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transIsThetaIsEquivalent", "code": "instance transIsThetaIsEquivalent :\n    @Trans (\u03b1 \u2192 \u03b2\u2082) (\u03b1 \u2192 \u03b2) (\u03b1 \u2192 \u03b2) (IsTheta l) (IsEquivalent l) (IsTheta l) where\n  trans := IsTheta.trans_isEquivalent", "start": [425, 1], "end": [427, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Module/FiniteDimension.lean", "imports": ["Mathlib/Topology/Algebra/Module/Determinant.lean", "Mathlib/Topology/Algebra/Module/Simple.lean", "Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean"], "premises": [{"full_name": "unique_topology_of_t2", "code": "theorem unique_topology_of_t2 {t : TopologicalSpace \ud835\udd5c} (h\u2081 : @TopologicalAddGroup \ud835\udd5c t _)\n    (h\u2082 : @ContinuousSMul \ud835\udd5c \ud835\udd5c _ hnorm.toUniformSpace.toTopologicalSpace t) (h\u2083 : @T2Space \ud835\udd5c t) :\n    t = hnorm.toUniformSpace.toTopologicalSpace", "start": [74, 1], "end": [126, 43], "kind": "commanddeclaration"}, {"full_name": "LinearMap.continuous_of_isClosed_ker", "code": "theorem LinearMap.continuous_of_isClosed_ker (l : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c)\n    (hl : IsClosed (LinearMap.ker l : Set E)) :\n    Continuous l", "start": [129, 1], "end": [173, 35], "kind": "commanddeclaration"}, {"full_name": "LinearMap.continuous_iff_isClosed_ker", "code": "theorem LinearMap.continuous_iff_isClosed_ker (l : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c) :\n    Continuous l \u2194 IsClosed (LinearMap.ker l : Set E)", "start": [176, 1], "end": [180, 73], "kind": "commanddeclaration"}, {"full_name": "LinearMap.continuous_of_nonzero_on_open", "code": "theorem LinearMap.continuous_of_nonzero_on_open (l : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c) (s : Set E) (hs\u2081 : IsOpen s)\n    (hs\u2082 : s.Nonempty) (hs\u2083 : \u2200 x \u2208 s, l x \u2260 0) : Continuous l", "start": [183, 1], "end": [192, 34], "kind": "commanddeclaration"}, {"full_name": "continuous_equivFun_basis_aux", "code": "private theorem continuous_equivFun_basis_aux [ht2 : T2Space E] {\u03b9 : Type v} [Fintype \u03b9]\n    (\u03be : Basis \u03b9 \ud835\udd5c E) : Continuous \u03be.equivFun", "start": [197, 1], "end": [243, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.continuous_of_finiteDimensional", "code": "theorem LinearMap.continuous_of_finiteDimensional [T2Space E] [FiniteDimensional \ud835\udd5c E]\n    (f : E \u2192\u2097[\ud835\udd5c] F') : Continuous f", "start": [245, 1], "end": [261, 49], "kind": "commanddeclaration"}, {"full_name": "LinearMap.continuousLinearMapClassOfFiniteDimensional", "code": "instance LinearMap.continuousLinearMapClassOfFiniteDimensional [T2Space E] [FiniteDimensional \ud835\udd5c E] :\n    ContinuousLinearMapClass (E \u2192\u2097[\ud835\udd5c] F') \ud835\udd5c E F' :=\n  { LinearMap.semilinearMapClass with map_continuous := fun f => f.continuous_of_finiteDimensional }", "start": [264, 1], "end": [266, 101], "kind": "commanddeclaration"}, {"full_name": "continuous_equivFun_basis", "code": "theorem continuous_equivFun_basis [T2Space E] {\u03b9 : Type*} [Fintype \u03b9] (\u03be : Basis \u03b9 \ud835\udd5c E) :\n    Continuous \u03be.equivFun", "start": [269, 1], "end": [277, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toContinuousLinearMap", "code": "def toContinuousLinearMap : (E \u2192\u2097[\ud835\udd5c] F') \u2243\u2097[\ud835\udd5c] E \u2192L[\ud835\udd5c] F' where\n  toFun f := \u27e8f, f.continuous_of_finiteDimensional\u27e9\n  invFun := (\u2191)\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  left_inv _ := rfl\n  right_inv _ := ContinuousLinearMap.coe_injective rfl", "start": [284, 1], "end": [291, 55], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_toContinuousLinearMap'", "code": "@[simp]\ntheorem coe_toContinuousLinearMap' (f : E \u2192\u2097[\ud835\udd5c] F') : \u21d1(LinearMap.toContinuousLinearMap f) = f", "start": [294, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_toContinuousLinearMap", "code": "@[simp]\ntheorem coe_toContinuousLinearMap (f : E \u2192\u2097[\ud835\udd5c] F') :\n    ((LinearMap.toContinuousLinearMap f) : E \u2192\u2097[\ud835\udd5c] F') = f", "start": [299, 1], "end": [302, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_toContinuousLinearMap_symm", "code": "@[simp]\ntheorem coe_toContinuousLinearMap_symm :\n    \u21d1(toContinuousLinearMap : (E \u2192\u2097[\ud835\udd5c] F') \u2243\u2097[\ud835\udd5c] E \u2192L[\ud835\udd5c] F').symm =\n      ((\u2191) : (E \u2192L[\ud835\udd5c] F') \u2192 E \u2192\u2097[\ud835\udd5c] F')", "start": [305, 1], "end": [309, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.det_toContinuousLinearMap", "code": "@[simp]\ntheorem det_toContinuousLinearMap (f : E \u2192\u2097[\ud835\udd5c] E) :\n    (LinearMap.toContinuousLinearMap f).det = LinearMap.det f", "start": [312, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_toContinuousLinearMap", "code": "@[simp]\ntheorem ker_toContinuousLinearMap (f : E \u2192\u2097[\ud835\udd5c] F') :\n    ker (LinearMap.toContinuousLinearMap f) = ker f", "start": [318, 1], "end": [321, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_toContinuousLinearMap", "code": "@[simp]\ntheorem range_toContinuousLinearMap (f : E \u2192\u2097[\ud835\udd5c] F') :\n    range (LinearMap.toContinuousLinearMap f) = range f", "start": [324, 1], "end": [327, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.isOpenMap_of_finiteDimensional", "code": "theorem isOpenMap_of_finiteDimensional (f : F \u2192\u2097[\ud835\udd5c] E) (hf : Function.Surjective f) :\n    IsOpenMap f", "start": [330, 1], "end": [340, 81], "kind": "commanddeclaration"}, {"full_name": "LinearMap.canLiftContinuousLinearMap", "code": "instance canLiftContinuousLinearMap : CanLift (E \u2192\u2097[\ud835\udd5c] F) (E \u2192L[\ud835\udd5c] F) (\u2191) fun _ => True :=\n  \u27e8fun f _ => \u27e8LinearMap.toContinuousLinearMap f, rfl\u27e9\u27e9", "start": [343, 1], "end": [344, 56], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toContinuousLinearEquiv", "code": "def toContinuousLinearEquiv (e : E \u2243\u2097[\ud835\udd5c] F) : E \u2243L[\ud835\udd5c] F :=\n  { e with\n    continuous_toFun := e.toLinearMap.continuous_of_finiteDimensional\n    continuous_invFun :=\n      haveI : FiniteDimensional \ud835\udd5c F := e.finiteDimensional\n      e.symm.toLinearMap.continuous_of_finiteDimensional }", "start": [355, 1], "end": [362, 59], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_toContinuousLinearEquiv", "code": "@[simp]\ntheorem coe_toContinuousLinearEquiv (e : E \u2243\u2097[\ud835\udd5c] F) : (e.toContinuousLinearEquiv : E \u2192\u2097[\ud835\udd5c] F) = e", "start": [365, 1], "end": [367, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_toContinuousLinearEquiv'", "code": "@[simp]\ntheorem coe_toContinuousLinearEquiv' (e : E \u2243\u2097[\ud835\udd5c] F) : (e.toContinuousLinearEquiv : E \u2192 F) = e", "start": [370, 1], "end": [372, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_toContinuousLinearEquiv_symm", "code": "@[simp]\ntheorem coe_toContinuousLinearEquiv_symm (e : E \u2243\u2097[\ud835\udd5c] F) :\n    (e.toContinuousLinearEquiv.symm : F \u2192\u2097[\ud835\udd5c] E) = e.symm", "start": [375, 1], "end": [378, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_toContinuousLinearEquiv_symm'", "code": "@[simp]\ntheorem coe_toContinuousLinearEquiv_symm' (e : E \u2243\u2097[\ud835\udd5c] F) :\n    (e.toContinuousLinearEquiv.symm : F \u2192 E) = e.symm", "start": [381, 1], "end": [384, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toLinearEquiv_toContinuousLinearEquiv", "code": "@[simp]\ntheorem toLinearEquiv_toContinuousLinearEquiv (e : E \u2243\u2097[\ud835\udd5c] F) :\n    e.toContinuousLinearEquiv.toLinearEquiv = e", "start": [387, 1], "end": [391, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toLinearEquiv_toContinuousLinearEquiv_symm", "code": "theorem toLinearEquiv_toContinuousLinearEquiv_symm (e : E \u2243\u2097[\ud835\udd5c] F) :\n    e.toContinuousLinearEquiv.symm.toLinearEquiv = e.symm", "start": [395, 1], "end": [398, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.canLiftContinuousLinearEquiv", "code": "instance canLiftContinuousLinearEquiv :\n    CanLift (E \u2243\u2097[\ud835\udd5c] F) (E \u2243L[\ud835\udd5c] F) ContinuousLinearEquiv.toLinearEquiv fun _ => True :=\n  \u27e8fun f _ => \u27e8_, f.toLinearEquiv_toContinuousLinearEquiv\u27e9\u27e9", "start": [401, 1], "end": [403, 60], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.nonempty_continuousLinearEquiv_of_finrank_eq", "code": "theorem FiniteDimensional.nonempty_continuousLinearEquiv_of_finrank_eq\n    (cond : finrank \ud835\udd5c E = finrank \ud835\udd5c F) : Nonempty (E \u2243L[\ud835\udd5c] F)", "start": [410, 1], "end": [414, 84], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.nonempty_continuousLinearEquiv_iff_finrank_eq", "code": "theorem FiniteDimensional.nonempty_continuousLinearEquiv_iff_finrank_eq :\n    Nonempty (E \u2243L[\ud835\udd5c] F) \u2194 finrank \ud835\udd5c E = finrank \ud835\udd5c F", "start": [417, 1], "end": [422, 70], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.ofFinrankEq", "code": "def ContinuousLinearEquiv.ofFinrankEq (cond : finrank \ud835\udd5c E = finrank \ud835\udd5c F) : E \u2243L[\ud835\udd5c] F :=\n  (LinearEquiv.ofFinrankEq E F cond).toContinuousLinearEquiv", "start": [425, 1], "end": [428, 61], "kind": "commanddeclaration"}, {"full_name": "Basis.constrL", "code": "def constrL (v : Basis \u03b9 \ud835\udd5c E) (f : \u03b9 \u2192 F) : E \u2192L[\ud835\udd5c] F :=\n  haveI : FiniteDimensional \ud835\udd5c E := FiniteDimensional.of_fintype_basis v\n  LinearMap.toContinuousLinearMap (v.constr \ud835\udd5c f)", "start": [439, 1], "end": [442, 49], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_constrL", "code": "@[simp] theorem coe_constrL (v : Basis \u03b9 \ud835\udd5c E) (f : \u03b9 \u2192 F) : (v.constrL f : E \u2192\u2097[\ud835\udd5c] F) = v.constr \ud835\udd5c f", "start": [445, 1], "end": [447, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.equivFunL", "code": "def equivFunL (v : Basis \u03b9 \ud835\udd5c E) : E \u2243L[\ud835\udd5c] \u03b9 \u2192 \ud835\udd5c :=\n  { v.equivFun with\n    continuous_toFun :=\n      haveI : FiniteDimensional \ud835\udd5c E := FiniteDimensional.of_fintype_basis v\n      v.equivFun.toLinearMap.continuous_of_finiteDimensional\n    continuous_invFun := by\n      change Continuous v.equivFun.symm.toFun\n      exact v.equivFun.symm.toLinearMap.continuous_of_finiteDimensional }", "start": [450, 1], "end": [459, 74], "kind": "commanddeclaration"}, {"full_name": "Basis.constrL_apply", "code": "@[simp]\ntheorem constrL_apply (v : Basis \u03b9 \ud835\udd5c E) (f : \u03b9 \u2192 F) (e : E) :\n    v.constrL f e = \u2211 i, v.equivFun e i \u2022 f i", "start": [462, 1], "end": [465, 31], "kind": "commanddeclaration"}, {"full_name": "Basis.constrL_basis", "code": "@[simp 1100]\ntheorem constrL_basis (v : Basis \u03b9 \ud835\udd5c E) (f : \u03b9 \u2192 F) (i : \u03b9) : v.constrL f (v i) = f i", "start": [468, 1], "end": [470, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toContinuousLinearEquivOfDetNeZero", "code": "def toContinuousLinearEquivOfDetNeZero (f : E \u2192L[\ud835\udd5c] E) (hf : f.det \u2260 0) : E \u2243L[\ud835\udd5c] E :=\n  ((f : E \u2192\u2097[\ud835\udd5c] E).equivOfDetNeZero hf).toContinuousLinearEquiv", "start": [479, 1], "end": [482, 64], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero", "code": "@[simp]\ntheorem coe_toContinuousLinearEquivOfDetNeZero (f : E \u2192L[\ud835\udd5c] E) (hf : f.det \u2260 0) :\n    (f.toContinuousLinearEquivOfDetNeZero hf : E \u2192L[\ud835\udd5c] E) = f", "start": [485, 1], "end": [489, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toContinuousLinearEquivOfDetNeZero_apply", "code": "@[simp]\ntheorem toContinuousLinearEquivOfDetNeZero_apply (f : E \u2192L[\ud835\udd5c] E) (hf : f.det \u2260 0) (x : E) :\n    f.toContinuousLinearEquivOfDetNeZero hf x = f x", "start": [492, 1], "end": [495, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin_finTwoProd_toContinuousLinearMap", "code": "theorem _root_.Matrix.toLin_finTwoProd_toContinuousLinearMap (a b c d : \ud835\udd5c) :\n    LinearMap.toContinuousLinearMap\n      (Matrix.toLin (Basis.finTwoProd \ud835\udd5c) (Basis.finTwoProd \ud835\udd5c) !![a, b; c, d]) =\n      (a \u2022 ContinuousLinearMap.fst \ud835\udd5c \ud835\udd5c \ud835\udd5c + b \u2022 ContinuousLinearMap.snd \ud835\udd5c \ud835\udd5c \ud835\udd5c).prod\n        (c \u2022 ContinuousLinearMap.fst \ud835\udd5c \ud835\udd5c \ud835\udd5c + d \u2022 ContinuousLinearMap.snd \ud835\udd5c \ud835\udd5c \ud835\udd5c)", "start": [498, 1], "end": [503, 67], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.complete", "code": "theorem FiniteDimensional.complete : CompleteSpace E", "start": [516, 1], "end": [519, 57], "kind": "commanddeclaration"}, {"full_name": "Submodule.complete_of_finiteDimensional", "code": "theorem Submodule.complete_of_finiteDimensional (s : Submodule \ud835\udd5c E) [FiniteDimensional \ud835\udd5c s] :\n    IsComplete (s : Set E)", "start": [524, 1], "end": [528, 70], "kind": "commanddeclaration"}, {"full_name": "Submodule.closed_of_finiteDimensional", "code": "theorem Submodule.closed_of_finiteDimensional (s : Submodule \ud835\udd5c E) [FiniteDimensional \ud835\udd5c s] :\n    IsClosed (s : Set E)", "start": [539, 1], "end": [545, 43], "kind": "commanddeclaration"}, {"full_name": "LinearMap.closedEmbedding_of_injective", "code": "theorem LinearMap.closedEmbedding_of_injective [FiniteDimensional \ud835\udd5c E] {f : E \u2192\u2097[\ud835\udd5c] F}\n    (hf : LinearMap.ker f = \u22a5) : ClosedEmbedding f", "start": [548, 1], "end": [555, 80], "kind": "commanddeclaration"}, {"full_name": "closedEmbedding_smul_left", "code": "theorem closedEmbedding_smul_left {c : E} (hc : c \u2260 0) : ClosedEmbedding fun x : \ud835\udd5c => x \u2022 c", "start": [558, 1], "end": [559, 80], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_smul_left", "code": "theorem isClosedMap_smul_left (c : E) : IsClosedMap fun x : \ud835\udd5c => x \u2022 c", "start": [563, 1], "end": [567, 53], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.exists_right_inverse_of_surjective", "code": "theorem ContinuousLinearMap.exists_right_inverse_of_surjective [FiniteDimensional \ud835\udd5c F]\n    (f : E \u2192L[\ud835\udd5c] F) (hf : LinearMap.range f = \u22a4) :\n    \u2203 g : F \u2192L[\ud835\udd5c] E, f.comp g = ContinuousLinearMap.id \ud835\udd5c F", "start": [570, 1], "end": [574, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Instances/Matrix.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Trace.lean", "Mathlib/Topology/Algebra/Star.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "Mathlib/Topology/Algebra/Ring/Basic.lean", "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean"], "premises": [{"full_name": "continuous_matrix", "code": "@[continuity]\ntheorem continuous_matrix [TopologicalSpace \u03b1] {f : \u03b1 \u2192 Matrix m n R}\n    (h : \u2200 i j, Continuous fun a => f a i j) : Continuous f", "start": [67, 1], "end": [72, 54], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_elem", "code": "theorem Continuous.matrix_elem {A : X \u2192 Matrix m n R} (hA : Continuous A) (i : m) (j : n) :\n    Continuous fun x => A x i j", "start": [75, 1], "end": [77, 39], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_map", "code": "@[continuity]\ntheorem Continuous.matrix_map [TopologicalSpace S] {A : X \u2192 Matrix m n S} {f : S \u2192 R}\n    (hA : Continuous A) (hf : Continuous f) : Continuous fun x => (A x).map f", "start": [80, 1], "end": [83, 61], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_transpose", "code": "@[continuity]\ntheorem Continuous.matrix_transpose {A : X \u2192 Matrix m n R} (hA : Continuous A) :\n    Continuous fun x => (A x)\u1d40", "start": [86, 1], "end": [89, 50], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_conjTranspose", "code": "theorem Continuous.matrix_conjTranspose [Star R] [ContinuousStar R] {A : X \u2192 Matrix m n R}\n    (hA : Continuous A) : Continuous fun x => (A x)\u1d34", "start": [92, 1], "end": [94, 49], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_col", "code": "@[continuity]\ntheorem Continuous.matrix_col {A : X \u2192 n \u2192 R} (hA : Continuous A) : Continuous fun x => col (A x)", "start": [100, 1], "end": [102, 60], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_row", "code": "@[continuity]\ntheorem Continuous.matrix_row {A : X \u2192 n \u2192 R} (hA : Continuous A) : Continuous fun x => row (A x)", "start": [105, 1], "end": [107, 60], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_diagonal", "code": "@[continuity]\ntheorem Continuous.matrix_diagonal [Zero R] [DecidableEq n] {A : X \u2192 n \u2192 R} (hA : Continuous A) :\n    Continuous fun x => diagonal (A x)", "start": [110, 1], "end": [113, 89], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_dotProduct", "code": "@[continuity]\ntheorem Continuous.matrix_dotProduct [Fintype n] [Mul R] [AddCommMonoid R] [ContinuousAdd R]\n    [ContinuousMul R] {A : X \u2192 n \u2192 R} {B : X \u2192 n \u2192 R} (hA : Continuous A) (hB : Continuous B) :\n    Continuous fun x => dotProduct (A x) (B x)", "start": [116, 1], "end": [121, 70], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_mul", "code": "@[continuity]\ntheorem Continuous.matrix_mul [Fintype n] [Mul R] [AddCommMonoid R] [ContinuousAdd R]\n    [ContinuousMul R] {A : X \u2192 Matrix m n R} {B : X \u2192 Matrix n p R} (hA : Continuous A)\n    (hB : Continuous B) : Continuous fun x => A x * B x", "start": [124, 1], "end": [130, 85], "kind": "commanddeclaration"}, {"full_name": "Matrix.topologicalRing", "code": "instance Matrix.topologicalRing [Fintype n] [NonUnitalNonAssocRing R] [TopologicalRing R] :\n    TopologicalRing (Matrix n n R) where", "start": [140, 1], "end": [141, 41], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_vecMulVec", "code": "@[continuity]\ntheorem Continuous.matrix_vecMulVec [Mul R] [ContinuousMul R] {A : X \u2192 m \u2192 R} {B : X \u2192 n \u2192 R}\n    (hA : Continuous A) (hB : Continuous B) : Continuous fun x => vecMulVec (A x) (B x)", "start": [144, 1], "end": [147, 97], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_mulVec", "code": "@[continuity]\ntheorem Continuous.matrix_mulVec [NonUnitalNonAssocSemiring R] [ContinuousAdd R] [ContinuousMul R]\n    [Fintype n] {A : X \u2192 Matrix m n R} {B : X \u2192 n \u2192 R} (hA : Continuous A) (hB : Continuous B) :\n    Continuous fun x => (A x).mulVec (B x)", "start": [150, 1], "end": [154, 77], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_vecMul", "code": "@[continuity]\ntheorem Continuous.matrix_vecMul [NonUnitalNonAssocSemiring R] [ContinuousAdd R] [ContinuousMul R]\n    [Fintype m] {A : X \u2192 m \u2192 R} {B : X \u2192 Matrix m n R} (hA : Continuous A) (hB : Continuous B) :\n    Continuous fun x => vecMul (A x) (B x)", "start": [157, 1], "end": [161, 93], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_submatrix", "code": "@[continuity]\ntheorem Continuous.matrix_submatrix {A : X \u2192 Matrix l n R} (hA : Continuous A) (e\u2081 : m \u2192 l)\n    (e\u2082 : p \u2192 n) : Continuous fun x => (A x).submatrix e\u2081 e\u2082", "start": [164, 1], "end": [167, 52], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_reindex", "code": "@[continuity]\ntheorem Continuous.matrix_reindex {A : X \u2192 Matrix l n R} (hA : Continuous A) (e\u2081 : l \u2243 m)\n    (e\u2082 : n \u2243 p) : Continuous fun x => reindex e\u2081 e\u2082 (A x)", "start": [170, 1], "end": [173, 26], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_diag", "code": "@[continuity]\ntheorem Continuous.matrix_diag {A : X \u2192 Matrix n n R} (hA : Continuous A) :\n    Continuous fun x => Matrix.diag (A x)", "start": [176, 1], "end": [179, 44], "kind": "commanddeclaration"}, {"full_name": "continuous_matrix_diag", "code": "theorem continuous_matrix_diag : Continuous (Matrix.diag : Matrix n n R \u2192 n \u2192 R)", "start": [183, 1], "end": [184, 87], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_trace", "code": "@[continuity]\ntheorem Continuous.matrix_trace [Fintype n] [AddCommMonoid R] [ContinuousAdd R]\n    {A : X \u2192 Matrix n n R} (hA : Continuous A) : Continuous fun x => trace (A x)", "start": [187, 1], "end": [190, 56], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_det", "code": "@[continuity]\ntheorem Continuous.matrix_det [Fintype n] [DecidableEq n] [CommRing R] [TopologicalRing R]\n    {A : X \u2192 Matrix n n R} (hA : Continuous A) : Continuous fun x => (A x).det", "start": [193, 1], "end": [198, 65], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_updateColumn", "code": "@[continuity]\ntheorem Continuous.matrix_updateColumn [DecidableEq n] (i : n) {A : X \u2192 Matrix m n R}\n    {B : X \u2192 m \u2192 R} (hA : Continuous A) (hB : Continuous B) :\n    Continuous fun x => (A x).updateColumn i (B x)", "start": [201, 1], "end": [207, 77], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_updateRow", "code": "@[continuity]\ntheorem Continuous.matrix_updateRow [DecidableEq m] (i : m) {A : X \u2192 Matrix m n R} {B : X \u2192 n \u2192 R}\n    (hA : Continuous A) (hB : Continuous B) : Continuous fun x => (A x).updateRow i (B x)", "start": [210, 1], "end": [213, 17], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_cramer", "code": "@[continuity]\ntheorem Continuous.matrix_cramer [Fintype n] [DecidableEq n] [CommRing R] [TopologicalRing R]\n    {A : X \u2192 Matrix n n R} {B : X \u2192 n \u2192 R} (hA : Continuous A) (hB : Continuous B) :\n    Continuous fun x => cramer (A x) (B x)", "start": [216, 1], "end": [220, 66], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_adjugate", "code": "@[continuity]\ntheorem Continuous.matrix_adjugate [Fintype n] [DecidableEq n] [CommRing R] [TopologicalRing R]\n    {A : X \u2192 Matrix n n R} (hA : Continuous A) : Continuous fun x => (A x).adjugate", "start": [223, 1], "end": [227, 76], "kind": "commanddeclaration"}, {"full_name": "continuousAt_matrix_inv", "code": "theorem continuousAt_matrix_inv [Fintype n] [DecidableEq n] [CommRing R] [TopologicalRing R]\n    (A : Matrix n n R) (h : ContinuousAt Ring.inverse A.det) : ContinuousAt Inv.inv A", "start": [230, 1], "end": [234, 97], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_fromBlocks", "code": "@[continuity]\ntheorem Continuous.matrix_fromBlocks {A : X \u2192 Matrix n l R} {B : X \u2192 Matrix n m R}\n    {C : X \u2192 Matrix p l R} {D : X \u2192 Matrix p m R} (hA : Continuous A) (hB : Continuous B)\n    (hC : Continuous C) (hD : Continuous D) :\n    Continuous fun x => Matrix.fromBlocks (A x) (B x) (C x) (D x)", "start": [240, 1], "end": [246, 83], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_blockDiagonal", "code": "@[continuity]\ntheorem Continuous.matrix_blockDiagonal [Zero R] [DecidableEq p] {A : X \u2192 p \u2192 Matrix m n R}\n    (hA : Continuous A) : Continuous fun x => blockDiagonal (A x)", "start": [249, 1], "end": [253, 83], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_blockDiag", "code": "@[continuity]\ntheorem Continuous.matrix_blockDiag {A : X \u2192 Matrix (m \u00d7 p) (n \u00d7 p) R} (hA : Continuous A) :\n    Continuous fun x => blockDiag (A x)", "start": [256, 1], "end": [259, 76], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_blockDiagonal'", "code": "@[continuity]\ntheorem Continuous.matrix_blockDiagonal' [Zero R] [DecidableEq l]\n    {A : X \u2192 \u2200 i, Matrix (m' i) (n' i) R} (hA : Continuous A) :\n    Continuous fun x => blockDiagonal' (A x)", "start": [262, 1], "end": [271, 29], "kind": "commanddeclaration"}, {"full_name": "Continuous.matrix_blockDiag'", "code": "@[continuity]\ntheorem Continuous.matrix_blockDiag' {A : X \u2192 Matrix (\u03a3i, m' i) (\u03a3i, n' i) R} (hA : Continuous A) :\n    Continuous fun x => blockDiag' (A x)", "start": [274, 1], "end": [277, 76], "kind": "commanddeclaration"}, {"full_name": "HasSum.matrix_transpose", "code": "theorem HasSum.matrix_transpose {f : X \u2192 Matrix m n R} {a : Matrix m n R} (hf : HasSum f a) :\n    HasSum (fun x => (f x)\u1d40) a\u1d40", "start": [291, 1], "end": [293, 79], "kind": "commanddeclaration"}, {"full_name": "Summable.matrix_transpose", "code": "theorem Summable.matrix_transpose {f : X \u2192 Matrix m n R} (hf : Summable f) :\n    Summable fun x => (f x)\u1d40", "start": [296, 1], "end": [298, 38], "kind": "commanddeclaration"}, {"full_name": "summable_matrix_transpose", "code": "@[simp]\ntheorem summable_matrix_transpose {f : X \u2192 Matrix m n R} :\n    (Summable fun x => (f x)\u1d40) \u2194 Summable f", "start": [301, 1], "end": [305, 66], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_tsum", "code": "theorem Matrix.transpose_tsum [T2Space R] {f : X \u2192 Matrix m n R} : (\u2211' x, f x)\u1d40 = \u2211' x, (f x)\u1d40", "start": [308, 1], "end": [312, 91], "kind": "commanddeclaration"}, {"full_name": "HasSum.matrix_conjTranspose", "code": "theorem HasSum.matrix_conjTranspose [StarAddMonoid R] [ContinuousStar R] {f : X \u2192 Matrix m n R}\n    {a : Matrix m n R} (hf : HasSum f a) : HasSum (fun x => (f x)\u1d34) a\u1d34", "start": [315, 1], "end": [317, 87], "kind": "commanddeclaration"}, {"full_name": "Summable.matrix_conjTranspose", "code": "theorem Summable.matrix_conjTranspose [StarAddMonoid R] [ContinuousStar R] {f : X \u2192 Matrix m n R}\n    (hf : Summable f) : Summable fun x => (f x)\u1d34", "start": [320, 1], "end": [322, 42], "kind": "commanddeclaration"}, {"full_name": "summable_matrix_conjTranspose", "code": "@[simp]\ntheorem summable_matrix_conjTranspose [StarAddMonoid R] [ContinuousStar R] {f : X \u2192 Matrix m n R} :\n    (Summable fun x => (f x)\u1d34) \u2194 Summable f", "start": [325, 1], "end": [329, 74], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_tsum", "code": "theorem Matrix.conjTranspose_tsum [StarAddMonoid R] [ContinuousStar R] [T2Space R]\n    {f : X \u2192 Matrix m n R} : (\u2211' x, f x)\u1d34 = \u2211' x, (f x)\u1d34", "start": [332, 1], "end": [337, 95], "kind": "commanddeclaration"}, {"full_name": "HasSum.matrix_diagonal", "code": "theorem HasSum.matrix_diagonal [DecidableEq n] {f : X \u2192 n \u2192 R} {a : n \u2192 R} (hf : HasSum f a) :\n    HasSum (fun x => diagonal (f x)) (diagonal a)", "start": [340, 1], "end": [342, 66], "kind": "commanddeclaration"}, {"full_name": "Summable.matrix_diagonal", "code": "theorem Summable.matrix_diagonal [DecidableEq n] {f : X \u2192 n \u2192 R} (hf : Summable f) :\n    Summable fun x => diagonal (f x)", "start": [345, 1], "end": [347, 37], "kind": "commanddeclaration"}, {"full_name": "summable_matrix_diagonal", "code": "@[simp]\ntheorem summable_matrix_diagonal [DecidableEq n] {f : X \u2192 n \u2192 R} :\n    (Summable fun x => diagonal (f x)) \u2194 Summable f", "start": [350, 1], "end": [354, 82], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_tsum", "code": "theorem Matrix.diagonal_tsum [DecidableEq n] [T2Space R] {f : X \u2192 n \u2192 R} :\n    diagonal (\u2211' x, f x) = \u2211' x, diagonal (f x)", "start": [357, 1], "end": [363, 24], "kind": "commanddeclaration"}, {"full_name": "HasSum.matrix_diag", "code": "theorem HasSum.matrix_diag {f : X \u2192 Matrix n n R} {a : Matrix n n R} (hf : HasSum f a) :\n    HasSum (fun x => diag (f x)) (diag a)", "start": [366, 1], "end": [368, 55], "kind": "commanddeclaration"}, {"full_name": "Summable.matrix_diag", "code": "theorem Summable.matrix_diag {f : X \u2192 Matrix n n R} (hf : Summable f) :\n    Summable fun x => diag (f x)", "start": [371, 1], "end": [373, 33], "kind": "commanddeclaration"}, {"full_name": "HasSum.matrix_blockDiagonal", "code": "theorem HasSum.matrix_blockDiagonal [DecidableEq p] {f : X \u2192 p \u2192 Matrix m n R}\n    {a : p \u2192 Matrix m n R} (hf : HasSum f a) :\n    HasSum (fun x => blockDiagonal (f x)) (blockDiagonal a)", "start": [378, 1], "end": [381, 80], "kind": "commanddeclaration"}, {"full_name": "Summable.matrix_blockDiagonal", "code": "theorem Summable.matrix_blockDiagonal [DecidableEq p] {f : X \u2192 p \u2192 Matrix m n R} (hf : Summable f) :\n    Summable fun x => blockDiagonal (f x)", "start": [384, 1], "end": [386, 42], "kind": "commanddeclaration"}, {"full_name": "summable_matrix_blockDiagonal", "code": "theorem summable_matrix_blockDiagonal [DecidableEq p] {f : X \u2192 p \u2192 Matrix m n R} :\n    (Summable fun x => blockDiagonal (f x)) \u2194 Summable f", "start": [389, 1], "end": [393, 70], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_tsum", "code": "theorem Matrix.blockDiagonal_tsum [DecidableEq p] [T2Space R] {f : X \u2192 p \u2192 Matrix m n R} :\n    blockDiagonal (\u2211' x, f x) = \u2211' x, blockDiagonal (f x)", "start": [396, 1], "end": [402, 29], "kind": "commanddeclaration"}, {"full_name": "HasSum.matrix_blockDiag", "code": "theorem HasSum.matrix_blockDiag {f : X \u2192 Matrix (m \u00d7 p) (n \u00d7 p) R} {a : Matrix (m \u00d7 p) (n \u00d7 p) R}\n    (hf : HasSum f a) : HasSum (fun x => blockDiag (f x)) (blockDiag a)", "start": [405, 1], "end": [407, 92], "kind": "commanddeclaration"}, {"full_name": "Summable.matrix_blockDiag", "code": "theorem Summable.matrix_blockDiag {f : X \u2192 Matrix (m \u00d7 p) (n \u00d7 p) R} (hf : Summable f) :\n    Summable fun x => blockDiag (f x)", "start": [410, 1], "end": [412, 38], "kind": "commanddeclaration"}, {"full_name": "HasSum.matrix_blockDiagonal'", "code": "theorem HasSum.matrix_blockDiagonal' [DecidableEq l] {f : X \u2192 \u2200 i, Matrix (m' i) (n' i) R}\n    {a : \u2200 i, Matrix (m' i) (n' i) R} (hf : HasSum f a) :\n    HasSum (fun x => blockDiagonal' (f x)) (blockDiagonal' a)", "start": [415, 1], "end": [418, 82], "kind": "commanddeclaration"}, {"full_name": "Summable.matrix_blockDiagonal'", "code": "theorem Summable.matrix_blockDiagonal' [DecidableEq l] {f : X \u2192 \u2200 i, Matrix (m' i) (n' i) R}\n    (hf : Summable f) : Summable fun x => blockDiagonal' (f x)", "start": [421, 1], "end": [423, 43], "kind": "commanddeclaration"}, {"full_name": "summable_matrix_blockDiagonal'", "code": "theorem summable_matrix_blockDiagonal' [DecidableEq l] {f : X \u2192 \u2200 i, Matrix (m' i) (n' i) R} :\n    (Summable fun x => blockDiagonal' (f x)) \u2194 Summable f", "start": [426, 1], "end": [430, 73], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_tsum", "code": "theorem Matrix.blockDiagonal'_tsum [DecidableEq l] [T2Space R]\n    {f : X \u2192 \u2200 i, Matrix (m' i) (n' i) R} :\n    blockDiagonal' (\u2211' x, f x) = \u2211' x, blockDiagonal' (f x)", "start": [433, 1], "end": [440, 30], "kind": "commanddeclaration"}, {"full_name": "HasSum.matrix_blockDiag'", "code": "theorem HasSum.matrix_blockDiag' {f : X \u2192 Matrix (\u03a3i, m' i) (\u03a3i, n' i) R}\n    {a : Matrix (\u03a3i, m' i) (\u03a3i, n' i) R} (hf : HasSum f a) :\n    HasSum (fun x => blockDiag' (f x)) (blockDiag' a)", "start": [443, 1], "end": [446, 74], "kind": "commanddeclaration"}, {"full_name": "Summable.matrix_blockDiag'", "code": "theorem Summable.matrix_blockDiag' {f : X \u2192 Matrix (\u03a3i, m' i) (\u03a3i, n' i) R} (hf : Summable f) :\n    Summable fun x => blockDiag' (f x)", "start": [449, 1], "end": [451, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/RieszLemma.lean", "imports": ["Mathlib/Analysis/NormedSpace/Basic.lean", "Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "Mathlib/Analysis/Seminorm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "riesz_lemma", "code": "theorem riesz_lemma {F : Subspace \ud835\udd5c E} (hFc : IsClosed (F : Set E)) (hF : \u2203 x : E, x \u2209 F) {r : \u211d}\n    (hr : r < 1) : \u2203 x\u2080 : E, x\u2080 \u2209 F \u2227 \u2200 y \u2208 F, r * \u2016x\u2080\u2016 \u2264 \u2016x\u2080 - y\u2016", "start": [37, 1], "end": [72, 56], "kind": "commanddeclaration"}, {"full_name": "riesz_lemma_of_norm_lt", "code": "theorem riesz_lemma_of_norm_lt {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016) {R : \u211d} (hR : \u2016c\u2016 < R) {F : Subspace \ud835\udd5c E}\n    (hFc : IsClosed (F : Set E)) (hF : \u2203 x : E, x \u2209 F) :\n    \u2203 x\u2080 : E, \u2016x\u2080\u2016 \u2264 R \u2227 \u2200 y \u2208 F, 1 \u2264 \u2016x\u2080 - y\u2016", "start": [75, 1], "end": [107, 57], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_infDist_compl_subset_closure", "code": "theorem Metric.closedBall_infDist_compl_subset_closure {x : F} {s : Set F} (hx : x \u2208 s) :\n    closedBall x (infDist x s\u1d9c) \u2286 closure s", "start": [110, 1], "end": [116, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/AffineIsometry.lean", "imports": ["Mathlib/Tactic/FailIfNoProgress.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/AffineSpace/Restrict.lean", "Mathlib/Analysis/NormedSpace/Basic.lean", "Mathlib/Algebra/CharP/Invertible.lean", "Mathlib/Analysis/Normed/Group/AddTorsor.lean", "Mathlib/Analysis/NormedSpace/LinearIsometry.lean"], "premises": [{"full_name": "AffineIsometry", "code": "structure AffineIsometry extends P \u2192\u1d43[\ud835\udd5c] P\u2082 where\n  norm_map : \u2200 x : V, \u2016linear x\u2016 = \u2016x\u2016", "start": [48, 1], "end": [51, 39], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.linearIsometry", "code": "protected def linearIsometry : V \u2192\u2097\u1d62[\ud835\udd5c] V\u2082 :=\n  { f.linear with norm_map' := f.norm_map }", "start": [63, 1], "end": [65, 44], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.linear_eq_linearIsometry", "code": "@[simp]\ntheorem linear_eq_linearIsometry : f.linear = f.linearIsometry.toLinearMap", "start": [68, 1], "end": [71, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.coe_toAffineMap", "code": "@[simp]\ntheorem coe_toAffineMap : \u21d1f.toAffineMap = f", "start": [78, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.toAffineMap_injective", "code": "theorem toAffineMap_injective : Injective (toAffineMap : (P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082) \u2192 P \u2192\u1d43[\ud835\udd5c] P\u2082)", "start": [83, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.coeFn_injective", "code": "theorem coeFn_injective : @Injective (P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082) (P \u2192 P\u2082) (\u2191)", "start": [88, 1], "end": [89, 55], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.ext", "code": "@[ext]\ntheorem ext {f g : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082} (h : \u2200 x, f x = g x) : f = g", "start": [92, 1], "end": [94, 30], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.toAffineIsometry", "code": "def toAffineIsometry : V \u2192\u1d43\u2071[\ud835\udd5c] V\u2082 :=\n  { f.toLinearMap.toAffineMap with norm_map := f.norm_map }", "start": [103, 1], "end": [105, 60], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.coe_toAffineIsometry", "code": "@[simp]\ntheorem coe_toAffineIsometry : \u21d1(f.toAffineIsometry : V \u2192\u1d43\u2071[\ud835\udd5c] V\u2082) = f", "start": [108, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.toAffineIsometry_linearIsometry", "code": "@[simp]\ntheorem toAffineIsometry_linearIsometry : f.toAffineIsometry.linearIsometry = f", "start": [113, 1], "end": [116, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.toAffineIsometry_toAffineMap", "code": "@[simp]\ntheorem toAffineIsometry_toAffineMap : f.toAffineIsometry.toAffineMap = f.toLinearMap.toAffineMap", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.map_vadd", "code": "@[simp]\ntheorem map_vadd (p : P) (v : V) : f (v +\u1d65 p) = f.linearIsometry v +\u1d65 f p", "start": [131, 1], "end": [133, 29], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.map_vsub", "code": "@[simp]\ntheorem map_vsub (p1 p2 : P) : f.linearIsometry (p1 -\u1d65 p2) = f p1 -\u1d65 f p2", "start": [136, 1], "end": [138, 37], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.dist_map", "code": "@[simp]\ntheorem dist_map (x y : P) : dist (f x) (f y) = dist x y", "start": [141, 1], "end": [143, 88], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.nndist_map", "code": "@[simp]\ntheorem nndist_map (x y : P) : nndist (f x) (f y) = nndist x y", "start": [147, 1], "end": [148, 100], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.edist_map", "code": "@[simp]\ntheorem edist_map (x y : P) : edist (f x) (f y) = edist x y", "start": [152, 1], "end": [153, 96], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.isometry", "code": "protected theorem isometry : Isometry f", "start": [156, 1], "end": [157, 14], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.injective", "code": "protected theorem injective : Injective f\u2081", "start": [160, 1], "end": [161, 24], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.map_eq_iff", "code": "@[simp]\ntheorem map_eq_iff {x y : P\u2081} : f\u2081 x = f\u2081 y \u2194 x = y", "start": [164, 1], "end": [166, 22], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.map_ne", "code": "theorem map_ne {x y : P\u2081} (h : x \u2260 y) : f\u2081 x \u2260 f\u2081 y", "start": [169, 1], "end": [170, 20], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.lipschitz", "code": "protected theorem lipschitz : LipschitzWith 1 f", "start": [173, 1], "end": [174, 23], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.antilipschitz", "code": "protected theorem antilipschitz : AntilipschitzWith 1 f", "start": [177, 1], "end": [178, 27], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.continuous", "code": "@[continuity]\nprotected theorem continuous : Continuous f", "start": [181, 1], "end": [183, 24], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.ediam_image", "code": "theorem ediam_image (s : Set P) : EMetric.diam (f '' s) = EMetric.diam s", "start": [186, 1], "end": [187, 27], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.ediam_range", "code": "theorem ediam_range : EMetric.diam (range f) = EMetric.diam (univ : Set P)", "start": [190, 1], "end": [191, 25], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.diam_image", "code": "theorem diam_image (s : Set P) : Metric.diam (f '' s) = Metric.diam s", "start": [194, 1], "end": [195, 26], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.diam_range", "code": "theorem diam_range : Metric.diam (range f) = Metric.diam (univ : Set P)", "start": [198, 1], "end": [199, 24], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.comp_continuous_iff", "code": "@[simp]\ntheorem comp_continuous_iff {\u03b1 : Type*} [TopologicalSpace \u03b1] {g : \u03b1 \u2192 P} :\n    Continuous (f \u2218 g) \u2194 Continuous g", "start": [202, 1], "end": [205, 33], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.id", "code": "def id : P \u2192\u1d43\u2071[\ud835\udd5c] P :=\n  \u27e8AffineMap.id \ud835\udd5c P, fun _ => rfl\u27e9", "start": [208, 1], "end": [210, 35], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(id : P \u2192\u1d43\u2071[\ud835\udd5c] P) = _root_.id", "start": [213, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.id_apply", "code": "@[simp]\ntheorem id_apply (x : P) : (AffineIsometry.id : P \u2192\u1d43\u2071[\ud835\udd5c] P) x = x", "start": [218, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.id_toAffineMap", "code": "@[simp]\ntheorem id_toAffineMap : (id.toAffineMap : P \u2192\u1d43[\ud835\udd5c] P) = AffineMap.id \ud835\udd5c P", "start": [223, 1], "end": [225, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.comp", "code": "def comp (g : P\u2082 \u2192\u1d43\u2071[\ud835\udd5c] P\u2083) (f : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082) : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2083 :=\n  \u27e8g.toAffineMap.comp f.toAffineMap, fun _ => (g.norm_map _).trans (f.norm_map _)\u27e9", "start": [231, 1], "end": [233, 83], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.coe_comp", "code": "@[simp]\ntheorem coe_comp (g : P\u2082 \u2192\u1d43\u2071[\ud835\udd5c] P\u2083) (f : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082) : \u21d1(g.comp f) = g \u2218 f", "start": [236, 1], "end": [238, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.id_comp", "code": "@[simp]\ntheorem id_comp : (id : P\u2082 \u2192\u1d43\u2071[\ud835\udd5c] P\u2082).comp f = f", "start": [241, 1], "end": [243, 19], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.comp_id", "code": "@[simp]\ntheorem comp_id : f.comp id = f", "start": [246, 1], "end": [248, 19], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.comp_assoc", "code": "theorem comp_assoc (f : P\u2083 \u2192\u1d43\u2071[\ud835\udd5c] P\u2084) (g : P\u2082 \u2192\u1d43\u2071[\ud835\udd5c] P\u2083) (h : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [251, 1], "end": [253, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.coe_one", "code": "@[simp]\ntheorem coe_one : \u21d1(1 : P \u2192\u1d43\u2071[\ud835\udd5c] P) = _root_.id", "start": [263, 1], "end": [265, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.coe_mul", "code": "@[simp]\ntheorem coe_mul (f g : P \u2192\u1d43\u2071[\ud835\udd5c] P) : \u21d1(f * g) = f \u2218 g", "start": [268, 1], "end": [270, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.subtype\u2090\u1d62", "code": "def subtype\u2090\u1d62 (s : AffineSubspace \ud835\udd5c P) [Nonempty s] : s \u2192\u1d43\u2071[\ud835\udd5c] P :=\n  { s.subtype with norm_map := s.direction.subtype\u2097\u1d62.norm_map }", "start": [277, 1], "end": [279, 64], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.subtype\u2090\u1d62_linear", "code": "theorem subtype\u2090\u1d62_linear (s : AffineSubspace \ud835\udd5c P) [Nonempty s] :\n    s.subtype\u2090\u1d62.linear = s.direction.subtype", "start": [282, 1], "end": [284, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.subtype\u2090\u1d62_linearIsometry", "code": "@[simp]\ntheorem subtype\u2090\u1d62_linearIsometry (s : AffineSubspace \ud835\udd5c P) [Nonempty s] :\n    s.subtype\u2090\u1d62.linearIsometry = s.direction.subtype\u2097\u1d62", "start": [287, 1], "end": [290, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.coe_subtype\u2090\u1d62", "code": "@[simp]\ntheorem coe_subtype\u2090\u1d62 (s : AffineSubspace \ud835\udd5c P) [Nonempty s] : \u21d1s.subtype\u2090\u1d62 = s.subtype", "start": [293, 1], "end": [295, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.subtype\u2090\u1d62_toAffineMap", "code": "@[simp]\ntheorem subtype\u2090\u1d62_toAffineMap (s : AffineSubspace \ud835\udd5c P) [Nonempty s] :\n    s.subtype\u2090\u1d62.toAffineMap = s.subtype", "start": [298, 1], "end": [301, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv", "code": "structure AffineIsometryEquiv extends P \u2243\u1d43[\ud835\udd5c] P\u2082 where\n  norm_map : \u2200 x, \u2016linear x\u2016 = \u2016x\u2016", "start": [308, 1], "end": [310, 35], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.linearIsometryEquiv", "code": "protected def linearIsometryEquiv : V \u2243\u2097\u1d62[\ud835\udd5c] V\u2082 :=\n  { e.linear with norm_map' := e.norm_map }", "start": [322, 1], "end": [324, 44], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.linear_eq_linear_isometry", "code": "@[simp]\ntheorem linear_eq_linear_isometry : e.linear = e.linearIsometryEquiv.toLinearEquiv", "start": [327, 1], "end": [330, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_mk", "code": "@[simp]\ntheorem coe_mk (e : P \u2243\u1d43[\ud835\udd5c] P\u2082) (he : \u2200 x, \u2016e.linear x\u2016 = \u2016x\u2016) : \u21d1(mk e he) = e", "start": [344, 1], "end": [346, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_toAffineEquiv", "code": "@[simp]\ntheorem coe_toAffineEquiv (e : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082) : \u21d1e.toAffineEquiv = e", "start": [349, 1], "end": [351, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.toAffineEquiv_injective", "code": "theorem toAffineEquiv_injective : Injective (toAffineEquiv : (P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082) \u2192 P \u2243\u1d43[\ud835\udd5c] P\u2082)", "start": [354, 1], "end": [355, 31], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.ext", "code": "@[ext]\ntheorem ext {e e' : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082} (h : \u2200 x, e x = e' x) : e = e'", "start": [358, 1], "end": [360, 47], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.toAffineIsometry", "code": "def toAffineIsometry : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082 :=\n  \u27e8e.1.toAffineMap, e.2\u27e9", "start": [363, 1], "end": [365, 25], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_toAffineIsometry", "code": "@[simp]\ntheorem coe_toAffineIsometry : \u21d1e.toAffineIsometry = e", "start": [368, 1], "end": [370, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.mk'", "code": "def mk' (e : P\u2081 \u2192 P\u2082) (e' : V\u2081 \u2243\u2097\u1d62[\ud835\udd5c] V\u2082) (p : P\u2081) (h : \u2200 p' : P\u2081, e p' = e' (p' -\u1d65 p) +\u1d65 e p) :\n    P\u2081 \u2243\u1d43\u2071[\ud835\udd5c] P\u2082 :=\n  { AffineEquiv.mk' e e'.toLinearEquiv p h with norm_map := e'.norm_map }", "start": [373, 1], "end": [379, 74], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_mk'", "code": "@[simp]\ntheorem coe_mk' (e : P\u2081 \u2192 P\u2082) (e' : V\u2081 \u2243\u2097\u1d62[\ud835\udd5c] V\u2082) (p h) : \u21d1(mk' e e' p h) = e", "start": [382, 1], "end": [384, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.linearIsometryEquiv_mk'", "code": "@[simp]\ntheorem linearIsometryEquiv_mk' (e : P\u2081 \u2192 P\u2082) (e' : V\u2081 \u2243\u2097\u1d62[\ud835\udd5c] V\u2082) (p h) :\n    (mk' e e' p h).linearIsometryEquiv = e'", "start": [387, 1], "end": [391, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toAffineIsometryEquiv", "code": "def toAffineIsometryEquiv : V \u2243\u1d43\u2071[\ud835\udd5c] V\u2082 :=\n  { e.toLinearEquiv.toAffineEquiv with norm_map := e.norm_map }", "start": [400, 1], "end": [402, 64], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_toAffineIsometryEquiv", "code": "@[simp]\ntheorem coe_toAffineIsometryEquiv : \u21d1(e.toAffineIsometryEquiv : V \u2243\u1d43\u2071[\ud835\udd5c] V\u2082) = e", "start": [405, 1], "end": [407, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toAffineIsometryEquiv_linearIsometryEquiv", "code": "@[simp]\ntheorem toAffineIsometryEquiv_linearIsometryEquiv :\n    e.toAffineIsometryEquiv.linearIsometryEquiv = e", "start": [410, 1], "end": [414, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toAffineIsometryEquiv_toAffineEquiv", "code": "@[simp]\ntheorem toAffineIsometryEquiv_toAffineEquiv :\n    e.toAffineIsometryEquiv.toAffineEquiv = e.toLinearEquiv.toAffineEquiv", "start": [418, 1], "end": [421, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toAffineIsometryEquiv_toAffineIsometry", "code": "@[simp]\ntheorem toAffineIsometryEquiv_toAffineIsometry :\n    e.toAffineIsometryEquiv.toAffineIsometry = e.toLinearIsometry.toAffineIsometry", "start": [425, 1], "end": [428, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.isometry", "code": "protected theorem isometry : Isometry e", "start": [437, 1], "end": [438, 30], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.toIsometryEquiv", "code": "def toIsometryEquiv : P \u2243\u1d62 P\u2082 :=\n  \u27e8e.toAffineEquiv.toEquiv, e.isometry\u27e9", "start": [441, 1], "end": [443, 40], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_toIsometryEquiv", "code": "@[simp]\ntheorem coe_toIsometryEquiv : \u21d1e.toIsometryEquiv = e", "start": [446, 1], "end": [448, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.range_eq_univ", "code": "theorem range_eq_univ (e : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082) : Set.range e = Set.univ", "start": [451, 1], "end": [453, 38], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.toHomeomorph", "code": "def toHomeomorph : P \u2243\u209c P\u2082 :=\n  e.toIsometryEquiv.toHomeomorph", "start": [456, 1], "end": [458, 33], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_toHomeomorph", "code": "@[simp]\ntheorem coe_toHomeomorph : \u21d1e.toHomeomorph = e", "start": [461, 1], "end": [463, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.continuous", "code": "protected theorem continuous : Continuous e", "start": [466, 1], "end": [467, 24], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.continuousAt", "code": "protected theorem continuousAt {x} : ContinuousAt e x", "start": [470, 1], "end": [471, 28], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.continuousOn", "code": "protected theorem continuousOn {s} : ContinuousOn e s", "start": [474, 1], "end": [475, 28], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.continuousWithinAt", "code": "protected theorem continuousWithinAt {s x} : ContinuousWithinAt e s x", "start": [478, 1], "end": [479, 34], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.refl", "code": "def refl : P \u2243\u1d43\u2071[\ud835\udd5c] P :=\n  \u27e8AffineEquiv.refl \ud835\udd5c P, fun _ => rfl\u27e9", "start": [484, 1], "end": [486, 39], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_refl", "code": "@[simp]\ntheorem coe_refl : \u21d1(refl \ud835\udd5c P) = id", "start": [494, 1], "end": [496, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.toAffineEquiv_refl", "code": "@[simp]\ntheorem toAffineEquiv_refl : (refl \ud835\udd5c P).toAffineEquiv = AffineEquiv.refl \ud835\udd5c P", "start": [499, 1], "end": [501, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.toIsometryEquiv_refl", "code": "@[simp]\ntheorem toIsometryEquiv_refl : (refl \ud835\udd5c P).toIsometryEquiv = IsometryEquiv.refl P", "start": [504, 1], "end": [506, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.toHomeomorph_refl", "code": "@[simp]\ntheorem toHomeomorph_refl : (refl \ud835\udd5c P).toHomeomorph = Homeomorph.refl P", "start": [509, 1], "end": [511, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.symm", "code": "def symm : P\u2082 \u2243\u1d43\u2071[\ud835\udd5c] P :=\n  { e.toAffineEquiv.symm with norm_map := e.linearIsometryEquiv.symm.norm_map }", "start": [514, 1], "end": [516, 80], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (x : P\u2082) : e (e.symm x) = x", "start": [519, 1], "end": [521, 37], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (x : P) : e.symm (e x) = x", "start": [524, 1], "end": [526, 37], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.symm_symm", "code": "@[simp]\ntheorem symm_symm : e.symm.symm = e", "start": [529, 1], "end": [531, 19], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.toAffineEquiv_symm", "code": "@[simp]\ntheorem toAffineEquiv_symm : e.toAffineEquiv.symm = e.symm.toAffineEquiv", "start": [534, 1], "end": [536, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.toIsometryEquiv_symm", "code": "@[simp]\ntheorem toIsometryEquiv_symm : e.toIsometryEquiv.symm = e.symm.toIsometryEquiv", "start": [539, 1], "end": [541, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.toHomeomorph_symm", "code": "@[simp]\ntheorem toHomeomorph_symm : e.toHomeomorph.symm = e.symm.toHomeomorph", "start": [544, 1], "end": [546, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.trans", "code": "def trans (e' : P\u2082 \u2243\u1d43\u2071[\ud835\udd5c] P\u2083) : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2083 :=\n  \u27e8e.toAffineEquiv.trans e'.toAffineEquiv, fun _ => (e'.norm_map _).trans (e.norm_map _)\u27e9", "start": [549, 1], "end": [551, 90], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_trans", "code": "@[simp]\ntheorem coe_trans (e\u2081 : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082) (e\u2082 : P\u2082 \u2243\u1d43\u2071[\ud835\udd5c] P\u2083) : \u21d1(e\u2081.trans e\u2082) = e\u2082 \u2218 e\u2081", "start": [554, 1], "end": [556, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.trans_refl", "code": "@[simp]\ntheorem trans_refl : e.trans (refl \ud835\udd5c P\u2082) = e", "start": [559, 1], "end": [561, 19], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.refl_trans", "code": "@[simp]\ntheorem refl_trans : (refl \ud835\udd5c P).trans e = e", "start": [564, 1], "end": [566, 19], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.self_trans_symm", "code": "@[simp]\ntheorem self_trans_symm : e.trans e.symm = refl \ud835\udd5c P", "start": [569, 1], "end": [571, 25], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.symm_trans_self", "code": "@[simp]\ntheorem symm_trans_self : e.symm.trans e = refl \ud835\udd5c P\u2082", "start": [574, 1], "end": [576, 25], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_symm_trans", "code": "@[simp]\ntheorem coe_symm_trans (e\u2081 : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082) (e\u2082 : P\u2082 \u2243\u1d43\u2071[\ud835\udd5c] P\u2083) :\n    \u21d1(e\u2081.trans e\u2082).symm = e\u2081.symm \u2218 e\u2082.symm", "start": [579, 1], "end": [582, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.trans_assoc", "code": "theorem trans_assoc (ePP\u2082 : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082) (eP\u2082G : P\u2082 \u2243\u1d43\u2071[\ud835\udd5c] P\u2083) (eGG' : P\u2083 \u2243\u1d43\u2071[\ud835\udd5c] P\u2084) :\n    ePP\u2082.trans (eP\u2082G.trans eGG') = (ePP\u2082.trans eP\u2082G).trans eGG'", "start": [585, 1], "end": [587, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_one", "code": "@[simp]\ntheorem coe_one : \u21d1(1 : P \u2243\u1d43\u2071[\ud835\udd5c] P) = id", "start": [600, 1], "end": [602, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_mul", "code": "@[simp]\ntheorem coe_mul (e e' : P \u2243\u1d43\u2071[\ud835\udd5c] P) : \u21d1(e * e') = e \u2218 e'", "start": [605, 1], "end": [607, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_inv", "code": "@[simp]\ntheorem coe_inv (e : P \u2243\u1d43\u2071[\ud835\udd5c] P) : \u21d1e\u207b\u00b9 = e.symm", "start": [610, 1], "end": [612, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.map_vadd", "code": "@[simp]\ntheorem map_vadd (p : P) (v : V) : e (v +\u1d65 p) = e.linearIsometryEquiv v +\u1d65 e p", "start": [615, 1], "end": [617, 34], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.map_vsub", "code": "@[simp]\ntheorem map_vsub (p1 p2 : P) : e.linearIsometryEquiv (p1 -\u1d65 p2) = e p1 -\u1d65 e p2", "start": [620, 1], "end": [622, 36], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.dist_map", "code": "@[simp]\ntheorem dist_map (x y : P) : dist (e x) (e y) = dist x y", "start": [625, 1], "end": [627, 34], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.edist_map", "code": "@[simp]\ntheorem edist_map (x y : P) : edist (e x) (e y) = edist x y", "start": [630, 1], "end": [632, 35], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.bijective", "code": "protected theorem bijective : Bijective e", "start": [635, 1], "end": [636, 16], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.injective", "code": "protected theorem injective : Injective e", "start": [639, 1], "end": [640, 16], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.surjective", "code": "protected theorem surjective : Surjective e", "start": [643, 1], "end": [644, 17], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.map_eq_iff", "code": "theorem map_eq_iff {x y : P} : e x = e y \u2194 x = y", "start": [648, 1], "end": [649, 21], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.map_ne", "code": "theorem map_ne {x y : P} (h : x \u2260 y) : e x \u2260 e y", "start": [652, 1], "end": [653, 19], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.lipschitz", "code": "protected theorem lipschitz : LipschitzWith 1 e", "start": [656, 1], "end": [657, 23], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.antilipschitz", "code": "protected theorem antilipschitz : AntilipschitzWith 1 e", "start": [660, 1], "end": [661, 27], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.ediam_image", "code": "@[simp]\ntheorem ediam_image (s : Set P) : EMetric.diam (e '' s) = EMetric.diam s", "start": [664, 1], "end": [666, 27], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.diam_image", "code": "@[simp]\ntheorem diam_image (s : Set P) : Metric.diam (e '' s) = Metric.diam s", "start": [669, 1], "end": [671, 26], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.comp_continuousOn_iff", "code": "@[simp]\ntheorem comp_continuousOn_iff {f : \u03b1 \u2192 P} {s : Set \u03b1} : ContinuousOn (e \u2218 f) s \u2194 ContinuousOn f s", "start": [676, 1], "end": [678, 35], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.comp_continuous_iff", "code": "@[simp]\ntheorem comp_continuous_iff {f : \u03b1 \u2192 P} : Continuous (e \u2218 f) \u2194 Continuous f", "start": [681, 1], "end": [683, 33], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.vaddConst", "code": "def vaddConst (p : P) : V \u2243\u1d43\u2071[\ud835\udd5c] P :=\n  { AffineEquiv.vaddConst \ud835\udd5c p with norm_map := fun _ => rfl }", "start": [690, 1], "end": [692, 62], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_vaddConst", "code": "@[simp]\ntheorem coe_vaddConst (p : P) : \u21d1(vaddConst \ud835\udd5c p) = fun v => v +\u1d65 p", "start": [697, 1], "end": [699, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_vaddConst'", "code": "@[simp]\ntheorem coe_vaddConst' (p : P) : \u2191(AffineEquiv.vaddConst \ud835\udd5c p) = fun v => v +\u1d65 p", "start": [702, 1], "end": [704, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_vaddConst_symm", "code": "@[simp]\ntheorem coe_vaddConst_symm (p : P) : \u21d1(vaddConst \ud835\udd5c p).symm = fun p' => p' -\u1d65 p", "start": [706, 1], "end": [708, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.vaddConst_toAffineEquiv", "code": "@[simp]\ntheorem vaddConst_toAffineEquiv (p : P) :\n    (vaddConst \ud835\udd5c p).toAffineEquiv = AffineEquiv.vaddConst \ud835\udd5c p", "start": [711, 1], "end": [714, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.constVSub", "code": "def constVSub (p : P) : P \u2243\u1d43\u2071[\ud835\udd5c] V :=\n  { AffineEquiv.constVSub \ud835\udd5c p with norm_map := norm_neg }", "start": [719, 1], "end": [721, 58], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_constVSub", "code": "@[simp]\ntheorem coe_constVSub (p : P) : \u21d1(constVSub \ud835\udd5c p) = (\u00b7 -\u1d65 \u00b7) p", "start": [726, 1], "end": [728, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.symm_constVSub", "code": "@[simp]\ntheorem symm_constVSub (p : P) :\n    (constVSub \ud835\udd5c p).symm =\n      (LinearIsometryEquiv.neg \ud835\udd5c).toAffineIsometryEquiv.trans (vaddConst \ud835\udd5c p)", "start": [731, 1], "end": [736, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.constVAdd", "code": "def constVAdd (v : V) : P \u2243\u1d43\u2071[\ud835\udd5c] P :=\n  { AffineEquiv.constVAdd \ud835\udd5c P v with norm_map := fun _ => rfl }", "start": [741, 1], "end": [744, 64], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.coe_constVAdd", "code": "@[simp]\ntheorem coe_constVAdd (v : V) : \u21d1(constVAdd \ud835\udd5c P v : P \u2243\u1d43\u2071[\ud835\udd5c] P) = (\u00b7 +\u1d65 \u00b7) v", "start": [749, 1], "end": [751, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.constVAdd_zero", "code": "@[simp]\ntheorem constVAdd_zero : constVAdd \ud835\udd5c P (0 : V) = refl \ud835\udd5c P", "start": [754, 1], "end": [756, 21], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.vadd_vsub", "code": "theorem vadd_vsub {f : P \u2192 P\u2082} (hf : Isometry f) {p : P} {g : V \u2192 V\u2082}\n    (hg : \u2200 v, g v = f (v +\u1d65 p) -\u1d65 f p) : Isometry g", "start": [759, 1], "end": [764, 18], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.pointReflection", "code": "def pointReflection (x : P) : P \u2243\u1d43\u2071[\ud835\udd5c] P :=\n  (constVSub \ud835\udd5c x).trans (vaddConst \ud835\udd5c x)", "start": [769, 1], "end": [771, 40], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.pointReflection_apply", "code": "theorem pointReflection_apply (x y : P) : (pointReflection \ud835\udd5c x) y = x -\u1d65 y +\u1d65 x", "start": [776, 1], "end": [777, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.pointReflection_toAffineEquiv", "code": "@[simp]\ntheorem pointReflection_toAffineEquiv (x : P) :\n    (pointReflection \ud835\udd5c x).toAffineEquiv = AffineEquiv.pointReflection \ud835\udd5c x", "start": [780, 1], "end": [783, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.pointReflection_self", "code": "@[simp]\ntheorem pointReflection_self (x : P) : pointReflection \ud835\udd5c x x = x", "start": [786, 1], "end": [788, 39], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.pointReflection_involutive", "code": "theorem pointReflection_involutive (x : P) : Function.Involutive (pointReflection \ud835\udd5c x)", "start": [791, 1], "end": [792, 37], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.pointReflection_symm", "code": "@[simp]\ntheorem pointReflection_symm (x : P) : (pointReflection \ud835\udd5c x).symm = pointReflection \ud835\udd5c x", "start": [795, 1], "end": [797, 66], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.dist_pointReflection_fixed", "code": "@[simp]\ntheorem dist_pointReflection_fixed (x y : P) : dist (pointReflection \ud835\udd5c x y) x = dist y x", "start": [800, 1], "end": [802, 66], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.dist_pointReflection_self'", "code": "theorem dist_pointReflection_self' (x y : P) : dist (pointReflection \ud835\udd5c x y) y = \u2016bit0 (x -\u1d65 y)\u2016", "start": [806, 1], "end": [807, 76], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.dist_pointReflection_self", "code": "theorem dist_pointReflection_self (x y : P) :\n    dist (pointReflection \ud835\udd5c x y) y = \u2016(2 : \ud835\udd5c)\u2016 * dist x y", "start": [811, 1], "end": [813, 92], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.pointReflection_fixed_iff", "code": "theorem pointReflection_fixed_iff [Invertible (2 : \ud835\udd5c)] {x y : P} :\n    pointReflection \ud835\udd5c x y = y \u2194 y = x", "start": [816, 1], "end": [818, 52], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.dist_pointReflection_self_real", "code": "theorem dist_pointReflection_self_real (x y : P) : dist (pointReflection \u211d x y) y = 2 * dist x y", "start": [823, 1], "end": [824, 51], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.pointReflection_midpoint_left", "code": "@[simp]\ntheorem pointReflection_midpoint_left (x y : P) : pointReflection \u211d (midpoint \u211d x y) x = y", "start": [827, 1], "end": [829, 48], "kind": "commanddeclaration"}, {"full_name": "AffineIsometryEquiv.pointReflection_midpoint_right", "code": "@[simp]\ntheorem pointReflection_midpoint_right (x y : P) : pointReflection \u211d (midpoint \u211d x y) y = x", "start": [832, 1], "end": [834, 49], "kind": "commanddeclaration"}, {"full_name": "AffineMap.continuous_linear_iff", "code": "theorem AffineMap.continuous_linear_iff {f : P \u2192\u1d43[\ud835\udd5c] P\u2082} : Continuous f.linear \u2194 Continuous f", "start": [841, 1], "end": [854, 78], "kind": "commanddeclaration"}, {"full_name": "AffineMap.isOpenMap_linear_iff", "code": "theorem AffineMap.isOpenMap_linear_iff {f : P \u2192\u1d43[\ud835\udd5c] P\u2082} : IsOpenMap f.linear \u2194 IsOpenMap f", "start": [857, 1], "end": [870, 76], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.equivMapOfInjective", "code": "@[simps]\nnoncomputable def equivMapOfInjective (E : AffineSubspace \ud835\udd5c P\u2081) [Nonempty E] (\u03c6 : P\u2081 \u2192\u1d43[\ud835\udd5c] P\u2082)\n    (h\u03c6 : Function.Injective \u03c6) : E \u2243\u1d43[\ud835\udd5c] E.map \u03c6 :=\n  { Equiv.Set.image _ (E : Set P\u2081) h\u03c6 with\n    linear :=\n      (E.direction.equivMapOfInjective \u03c6.linear (\u03c6.linear_injective_iff.mpr h\u03c6)).trans\n        (LinearEquiv.ofEq _ _ (AffineSubspace.map_direction _ _).symm)\n    map_vadd' := fun p v => Subtype.ext <| \u03c6.map_vadd p v }", "start": [877, 1], "end": [887, 60], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.isometryEquivMap", "code": "noncomputable def isometryEquivMap (\u03c6 : P\u2081 \u2192\u1d43\u2071[\ud835\udd5c] P\u2082) (E : AffineSubspace \ud835\udd5c P\u2081) [Nonempty E] :\n    E \u2243\u1d43\u2071[\ud835\udd5c] E.map \u03c6.toAffineMap :=\n  \u27e8E.equivMapOfInjective \u03c6.toAffineMap \u03c6.injective, fun _ => \u03c6.norm_map _\u27e9", "start": [890, 1], "end": [898, 75], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.isometryEquivMap.apply_symm_apply", "code": "@[simp]\ntheorem isometryEquivMap.apply_symm_apply {E : AffineSubspace \ud835\udd5c P\u2081} [Nonempty E] {\u03c6 : P\u2081 \u2192\u1d43\u2071[\ud835\udd5c] P\u2082}\n    (x : E.map \u03c6.toAffineMap) : \u03c6 ((E.isometryEquivMap \u03c6).symm x) = x", "start": [901, 1], "end": [904, 69], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.isometryEquivMap.coe_apply", "code": "@[simp]\ntheorem isometryEquivMap.coe_apply (\u03c6 : P\u2081 \u2192\u1d43\u2071[\ud835\udd5c] P\u2082) (E : AffineSubspace \ud835\udd5c P\u2081) [Nonempty E]\n    (g : E) : \u2191(E.isometryEquivMap \u03c6 g) = \u03c6 g", "start": [907, 1], "end": [910, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.isometryEquivMap.toAffineMap_eq", "code": "@[simp]\ntheorem isometryEquivMap.toAffineMap_eq (\u03c6 : P\u2081 \u2192\u1d43\u2071[\ud835\udd5c] P\u2082) (E : AffineSubspace \ud835\udd5c P\u2081) [Nonempty E] :\n    (E.isometryEquivMap \u03c6).toAffineMap = E.equivMapOfInjective \u03c6.toAffineMap \u03c6.injective", "start": [913, 1], "end": [916, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "imports": ["Mathlib/MeasureTheory/Measure/Count.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/MeasureTheory/Measure/MutuallySingular.lean", "Mathlib/Dynamics/Ergodic/MeasurePreserving.lean", "Mathlib/MeasureTheory/Function/SimpleFunc.lean"], "premises": [{"full_name": "MeasureTheory.lintegral", "code": "irreducible_def lintegral {_ : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) (f : \u03b1 \u2192 \u211d\u22650\u221e) : \u211d\u22650\u221e :=\n  \u2a06 (g : \u03b1 \u2192\u209b \u211d\u22650\u221e) (_ : \u21d1g \u2264 f), g.lintegral \u03bc", "start": [59, 1], "end": [61, 48], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "MeasureTheory.SimpleFunc.lintegral_eq_lintegral", "code": "theorem SimpleFunc.lintegral_eq_lintegral {m : MeasurableSpace \u03b1} (f : \u03b1 \u2192\u209b \u211d\u22650\u221e) (\u03bc : Measure \u03b1) :\n    \u222b\u207b a, f a \u2202\u03bc = f.lintegral \u03bc", "start": [80, 1], "end": [84, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_mono'", "code": "@[mono]\ntheorem lintegral_mono' {m : MeasurableSpace \u03b1} \u2983\u03bc \u03bd : Measure \u03b1\u2984 (h\u03bc\u03bd : \u03bc \u2264 \u03bd) \u2983f g : \u03b1 \u2192 \u211d\u22650\u221e\u2984\n    (hfg : f \u2264 g) : \u222b\u207b a, f a \u2202\u03bc \u2264 \u222b\u207b a, g a \u2202\u03bd", "start": [87, 1], "end": [91, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_mono_fn'", "code": "@[gcongr] theorem lintegral_mono_fn' \u2983f g : \u03b1 \u2192 \u211d\u22650\u221e\u2984 (hfg : \u2200 x, f x \u2264 g x) (h2 : \u03bc \u2264 \u03bd) :\n    lintegral \u03bc f \u2264 lintegral \u03bd g", "start": [95, 1], "end": [97, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_mono", "code": "theorem lintegral_mono \u2983f g : \u03b1 \u2192 \u211d\u22650\u221e\u2984 (hfg : f \u2264 g) : \u222b\u207b a, f a \u2202\u03bc \u2264 \u222b\u207b a, g a \u2202\u03bc", "start": [99, 1], "end": [100, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_mono_fn", "code": "@[gcongr] theorem lintegral_mono_fn \u2983f g : \u03b1 \u2192 \u211d\u22650\u221e\u2984 (hfg : \u2200 x, f x \u2264 g x) :\n    lintegral \u03bc f \u2264 lintegral \u03bc g", "start": [104, 1], "end": [106, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_mono_nnreal", "code": "theorem lintegral_mono_nnreal {f g : \u03b1 \u2192 \u211d\u22650} (h : f \u2264 g) : \u222b\u207b a, f a \u2202\u03bc \u2264 \u222b\u207b a, g a \u2202\u03bc", "start": [108, 1], "end": [109, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.iSup_lintegral_measurable_le_eq_lintegral", "code": "theorem iSup_lintegral_measurable_le_eq_lintegral (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u2a06 (g : \u03b1 \u2192 \u211d\u22650\u221e) (_ : Measurable g) (_ : g \u2264 f), \u222b\u207b a, g a \u2202\u03bc = \u222b\u207b a, f a \u2202\u03bc", "start": [112, 1], "end": [118, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_mono_set", "code": "theorem lintegral_mono_set {_ : MeasurableSpace \u03b1} \u2983\u03bc : Measure \u03b1\u2984 {s t : Set \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hst : s \u2286 t) : \u222b\u207b x in s, f x \u2202\u03bc \u2264 \u222b\u207b x in t, f x \u2202\u03bc", "start": [121, 1], "end": [123, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_mono_set'", "code": "theorem lintegral_mono_set' {_ : MeasurableSpace \u03b1} \u2983\u03bc : Measure \u03b1\u2984 {s t : Set \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hst : s \u2264\u1d50[\u03bc] t) : \u222b\u207b x in s, f x \u2202\u03bc \u2264 \u222b\u207b x in t, f x \u2202\u03bc", "start": [126, 1], "end": [128, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.monotone_lintegral", "code": "theorem monotone_lintegral {_ : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) : Monotone (lintegral \u03bc)", "start": [131, 1], "end": [132, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_const", "code": "@[simp]\ntheorem lintegral_const (c : \u211d\u22650\u221e) : \u222b\u207b _, c \u2202\u03bc = c * \u03bc univ", "start": [135, 1], "end": [138, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_zero", "code": "theorem lintegral_zero : \u222b\u207b _ : \u03b1, 0 \u2202\u03bc = 0", "start": [141, 1], "end": [141, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_zero_fun", "code": "theorem lintegral_zero_fun : lintegral \u03bc (0 : \u03b1 \u2192 \u211d\u22650\u221e) = 0", "start": [144, 1], "end": [145, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_one", "code": "theorem lintegral_one : \u222b\u207b _, (1 : \u211d\u22650\u221e) \u2202\u03bc = \u03bc univ", "start": [149, 1], "end": [149, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_const", "code": "theorem set_lintegral_const (s : Set \u03b1) (c : \u211d\u22650\u221e) : \u222b\u207b _ in s, c \u2202\u03bc = c * \u03bc s", "start": [152, 1], "end": [153, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_one", "code": "theorem set_lintegral_one (s) : \u222b\u207b _ in s, 1 \u2202\u03bc = \u03bc s", "start": [156, 1], "end": [156, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_const_lt_top", "code": "theorem set_lintegral_const_lt_top [IsFiniteMeasure \u03bc] (s : Set \u03b1) {c : \u211d\u22650\u221e} (hc : c \u2260 \u221e) :\n    \u222b\u207b _ in s, c \u2202\u03bc < \u221e", "start": [159, 1], "end": [162, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_const_lt_top", "code": "theorem lintegral_const_lt_top [IsFiniteMeasure \u03bc] {c : \u211d\u22650\u221e} (hc : c \u2260 \u221e) : \u222b\u207b _, c \u2202\u03bc < \u221e", "start": [165, 1], "end": [166, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_measurable_le_lintegral_eq", "code": "theorem exists_measurable_le_lintegral_eq (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u2203 g : \u03b1 \u2192 \u211d\u22650\u221e, Measurable g \u2227 g \u2264 f \u2227 \u222b\u207b a, f a \u2202\u03bc = \u222b\u207b a, g a \u2202\u03bc", "start": [173, 1], "end": [189, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_eq_nnreal", "code": "theorem lintegral_eq_nnreal {m : MeasurableSpace \u03b1} (f : \u03b1 \u2192 \u211d\u22650\u221e) (\u03bc : Measure \u03b1) :\n    \u222b\u207b a, f a \u2202\u03bc =\n      \u2a06 (\u03c6 : \u03b1 \u2192\u209b \u211d\u22650) (_ : \u2200 x, \u2191(\u03c6 x) \u2264 f x), (\u03c6.map ((\u2191) : \u211d\u22650 \u2192 \u211d\u22650\u221e)).lintegral \u03bc", "start": [194, 1], "end": [219, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_simpleFunc_forall_lintegral_sub_lt_of_pos", "code": "theorem exists_simpleFunc_forall_lintegral_sub_lt_of_pos {f : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u222b\u207b x, f x \u2202\u03bc \u2260 \u221e)\n    {\u03b5 : \u211d\u22650\u221e} (h\u03b5 : \u03b5 \u2260 0) :\n    \u2203 \u03c6 : \u03b1 \u2192\u209b \u211d\u22650,\n      (\u2200 x, \u2191(\u03c6 x) \u2264 f x) \u2227\n        \u2200 \u03c8 : \u03b1 \u2192\u209b \u211d\u22650, (\u2200 x, \u2191(\u03c8 x) \u2264 f x) \u2192 (map (\u2191) (\u03c8 - \u03c6)).lintegral \u03bc < \u03b5", "start": [222, 1], "end": [238, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.iSup_lintegral_le", "code": "theorem iSup_lintegral_le {\u03b9 : Sort*} (f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u2a06 i, \u222b\u207b a, f i a \u2202\u03bc \u2264 \u222b\u207b a, \u2a06 i, f i a \u2202\u03bc", "start": [241, 1], "end": [244, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.iSup\u2082_lintegral_le", "code": "theorem iSup\u2082_lintegral_le {\u03b9 : Sort*} {\u03b9' : \u03b9 \u2192 Sort*} (f : \u2200 i, \u03b9' i \u2192 \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u2a06 (i) (j), \u222b\u207b a, f i j a \u2202\u03bc \u2264 \u222b\u207b a, \u2a06 (i) (j), f i j a \u2202\u03bc", "start": [247, 1], "end": [250, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.le_iInf_lintegral", "code": "theorem le_iInf_lintegral {\u03b9 : Sort*} (f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a, \u2a05 i, f i a \u2202\u03bc \u2264 \u2a05 i, \u222b\u207b a, f i a \u2202\u03bc", "start": [253, 1], "end": [256, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.le_iInf\u2082_lintegral", "code": "theorem le_iInf\u2082_lintegral {\u03b9 : Sort*} {\u03b9' : \u03b9 \u2192 Sort*} (f : \u2200 i, \u03b9' i \u2192 \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a, \u2a05 (i) (h : \u03b9' i), f i h a \u2202\u03bc \u2264 \u2a05 (i) (h : \u03b9' i), \u222b\u207b a, f i h a \u2202\u03bc", "start": [259, 1], "end": [262, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_mono_ae", "code": "theorem lintegral_mono_ae {f g : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200\u1d50 a \u2202\u03bc, f a \u2264 g a) :\n    \u222b\u207b a, f a \u2202\u03bc \u2264 \u222b\u207b a, g a \u2202\u03bc", "start": [265, 1], "end": [279, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_mono_ae", "code": "theorem set_lintegral_mono_ae {s : Set \u03b1} {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) (hg : Measurable g)\n    (hfg : \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 f x \u2264 g x) : \u222b\u207b x in s, f x \u2202\u03bc \u2264 \u222b\u207b x in s, g x \u2202\u03bc", "start": [282, 1], "end": [284, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_mono", "code": "theorem set_lintegral_mono {s : Set \u03b1} {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) (hg : Measurable g)\n    (hfg : \u2200 x \u2208 s, f x \u2264 g x) : \u222b\u207b x in s, f x \u2202\u03bc \u2264 \u222b\u207b x in s, g x \u2202\u03bc", "start": [287, 1], "end": [289, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_mono_ae'", "code": "theorem set_lintegral_mono_ae' {s : Set \u03b1} {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hs : MeasurableSet s)\n    (hfg : \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 f x \u2264 g x) : \u222b\u207b x in s, f x \u2202\u03bc \u2264 \u222b\u207b x in s, g x \u2202\u03bc", "start": [292, 1], "end": [294, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_mono'", "code": "theorem set_lintegral_mono' {s : Set \u03b1} {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hs : MeasurableSet s)\n    (hfg : \u2200 x \u2208 s, f x \u2264 g x) : \u222b\u207b x in s, f x \u2202\u03bc \u2264 \u222b\u207b x in s, g x \u2202\u03bc", "start": [296, 1], "end": [298, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_le_lintegral", "code": "theorem set_lintegral_le_lintegral (s : Set \u03b1) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b x in s, f x \u2202\u03bc \u2264 \u222b\u207b x, f x \u2202\u03bc", "start": [300, 1], "end": [302, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_congr_ae", "code": "theorem lintegral_congr_ae {f g : \u03b1 \u2192 \u211d\u22650\u221e} (h : f =\u1d50[\u03bc] g) : \u222b\u207b a, f a \u2202\u03bc = \u222b\u207b a, g a \u2202\u03bc", "start": [304, 1], "end": [305, 75], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_congr", "code": "theorem lintegral_congr {f g : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200 a, f a = g a) : \u222b\u207b a, f a \u2202\u03bc = \u222b\u207b a, g a \u2202\u03bc", "start": [308, 1], "end": [309, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_congr", "code": "theorem set_lintegral_congr {f : \u03b1 \u2192 \u211d\u22650\u221e} {s t : Set \u03b1} (h : s =\u1d50[\u03bc] t) :\n    \u222b\u207b x in s, f x \u2202\u03bc = \u222b\u207b x in t, f x \u2202\u03bc", "start": [312, 1], "end": [313, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_congr_fun", "code": "theorem set_lintegral_congr_fun {f g : \u03b1 \u2192 \u211d\u22650\u221e} {s : Set \u03b1} (hs : MeasurableSet s)\n    (hfg : \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 f x = g x) : \u222b\u207b x in s, f x \u2202\u03bc = \u222b\u207b x in s, g x \u2202\u03bc", "start": [316, 1], "end": [320, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_ofReal_le_lintegral_nnnorm", "code": "theorem lintegral_ofReal_le_lintegral_nnnorm (f : \u03b1 \u2192 \u211d) :\n    \u222b\u207b x, ENNReal.ofReal (f x) \u2202\u03bc \u2264 \u222b\u207b x, \u2016f x\u2016\u208a \u2202\u03bc", "start": [323, 1], "end": [328, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_nnnorm_eq_of_ae_nonneg", "code": "theorem lintegral_nnnorm_eq_of_ae_nonneg {f : \u03b1 \u2192 \u211d} (h_nonneg : 0 \u2264\u1d50[\u03bc] f) :\n    \u222b\u207b x, \u2016f x\u2016\u208a \u2202\u03bc = \u222b\u207b x, ENNReal.ofReal (f x) \u2202\u03bc", "start": [331, 1], "end": [335, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_nnnorm_eq_of_nonneg", "code": "theorem lintegral_nnnorm_eq_of_nonneg {f : \u03b1 \u2192 \u211d} (h_nonneg : 0 \u2264 f) :\n    \u222b\u207b x, \u2016f x\u2016\u208a \u2202\u03bc = \u222b\u207b x, ENNReal.ofReal (f x) \u2202\u03bc", "start": [338, 1], "end": [340, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_iSup", "code": "theorem lintegral_iSup {f : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200 n, Measurable (f n)) (h_mono : Monotone f) :\n    \u222b\u207b a, \u2a06 n, f n a \u2202\u03bc = \u2a06 n, \u222b\u207b a, f n a \u2202\u03bc", "start": [343, 1], "end": [411, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_iSup'", "code": "theorem lintegral_iSup' {f : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200 n, AEMeasurable (f n) \u03bc)\n    (h_mono : \u2200\u1d50 x \u2202\u03bc, Monotone fun n => f n x) : \u222b\u207b a, \u2a06 n, f n a \u2202\u03bc = \u2a06 n, \u222b\u207b a, f n a \u2202\u03bc", "start": [414, 1], "end": [431, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_tendsto_of_tendsto_of_monotone", "code": "theorem lintegral_tendsto_of_tendsto_of_monotone {f : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} {F : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : \u2200 n, AEMeasurable (f n) \u03bc) (h_mono : \u2200\u1d50 x \u2202\u03bc, Monotone fun n => f n x)\n    (h_tendsto : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd <| F x)) :\n    Tendsto (fun n => \u222b\u207b x, f n x \u2202\u03bc) atTop (\ud835\udcdd <| \u222b\u207b x, F x \u2202\u03bc)", "start": [434, 1], "end": [448, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_eq_iSup_eapprox_lintegral", "code": "theorem lintegral_eq_iSup_eapprox_lintegral {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    \u222b\u207b a, f a \u2202\u03bc = \u2a06 n, (eapprox f n).lintegral \u03bc", "start": [451, 1], "end": [462, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_pos_set_lintegral_lt_of_measure_lt", "code": "theorem exists_pos_set_lintegral_lt_of_measure_lt {f : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u222b\u207b x, f x \u2202\u03bc \u2260 \u221e) {\u03b5 : \u211d\u22650\u221e}\n    (h\u03b5 : \u03b5 \u2260 0) : \u2203 \u03b4 > 0, \u2200 s, \u03bc s < \u03b4 \u2192 \u222b\u207b x in s, f x \u2202\u03bc < \u03b5", "start": [465, 1], "end": [494, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_set_lintegral_zero", "code": "theorem tendsto_set_lintegral_zero {\u03b9} {f : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u222b\u207b x, f x \u2202\u03bc \u2260 \u221e) {l : Filter \u03b9}\n    {s : \u03b9 \u2192 Set \u03b1} (hl : Tendsto (\u03bc \u2218 s) l (\ud835\udcdd 0)) :\n    Tendsto (fun i => \u222b\u207b x in s i, f x \u2202\u03bc) l (\ud835\udcdd 0)", "start": [497, 1], "end": [506, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.le_lintegral_add", "code": "theorem le_lintegral_add (f g : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a, f a \u2202\u03bc + \u222b\u207b a, g a \u2202\u03bc \u2264 \u222b\u207b a, f a + g a \u2202\u03bc", "start": [509, 1], "end": [516, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_add_aux", "code": "theorem lintegral_add_aux {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) (hg : Measurable g) :\n    \u222b\u207b a, f a + g a \u2202\u03bc = \u222b\u207b a, f a \u2202\u03bc + \u222b\u207b a, g a \u2202\u03bc", "start": [520, 1], "end": [547, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_add_left", "code": "@[simp]\ntheorem lintegral_add_left {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) (g : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a, f a + g a \u2202\u03bc = \u222b\u207b a, f a \u2202\u03bc + \u222b\u207b a, g a \u2202\u03bc", "start": [550, 1], "end": [563, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_add_left'", "code": "theorem lintegral_add_left' {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) (g : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a, f a + g a \u2202\u03bc = \u222b\u207b a, f a \u2202\u03bc + \u222b\u207b a, g a \u2202\u03bc", "start": [566, 1], "end": [569, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_add_right'", "code": "theorem lintegral_add_right' (f : \u03b1 \u2192 \u211d\u22650\u221e) {g : \u03b1 \u2192 \u211d\u22650\u221e} (hg : AEMeasurable g \u03bc) :\n    \u222b\u207b a, f a + g a \u2202\u03bc = \u222b\u207b a, f a \u2202\u03bc + \u222b\u207b a, g a \u2202\u03bc", "start": [572, 1], "end": [574, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_add_right", "code": "@[simp]\ntheorem lintegral_add_right (f : \u03b1 \u2192 \u211d\u22650\u221e) {g : \u03b1 \u2192 \u211d\u22650\u221e} (hg : Measurable g) :\n    \u222b\u207b a, f a + g a \u2202\u03bc = \u222b\u207b a, f a \u2202\u03bc + \u222b\u207b a, g a \u2202\u03bc", "start": [577, 1], "end": [583, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_smul_measure", "code": "@[simp]\ntheorem lintegral_smul_measure (c : \u211d\u22650\u221e) (f : \u03b1 \u2192 \u211d\u22650\u221e) : \u222b\u207b a, f a \u2202c \u2022 \u03bc = c * \u222b\u207b a, f a \u2202\u03bc", "start": [586, 1], "end": [588, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_smul_measure", "code": "lemma set_lintegral_smul_measure (c : \u211d\u22650\u221e) (f : \u03b1 \u2192 \u211d\u22650\u221e) (s : Set \u03b1) :\n    \u222b\u207b a in s, f a \u2202(c \u2022 \u03bc) = c * \u222b\u207b a in s, f a \u2202\u03bc := by\n  rw [Measure.restrict_smul, lintegral_smul_measure]", "start": [591, 1], "end": [593, 53], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.lintegral_sum_measure", "code": "@[simp]\ntheorem lintegral_sum_measure {m : MeasurableSpace \u03b1} {\u03b9} (f : \u03b1 \u2192 \u211d\u22650\u221e) (\u03bc : \u03b9 \u2192 Measure \u03b1) :\n    \u222b\u207b a, f a \u2202Measure.sum \u03bc = \u2211' i, \u222b\u207b a, f a \u2202\u03bc i", "start": [595, 1], "end": [610, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.hasSum_lintegral_measure", "code": "theorem hasSum_lintegral_measure {\u03b9} {_ : MeasurableSpace \u03b1} (f : \u03b1 \u2192 \u211d\u22650\u221e) (\u03bc : \u03b9 \u2192 Measure \u03b1) :\n    HasSum (fun i => \u222b\u207b a, f a \u2202\u03bc i) (\u222b\u207b a, f a \u2202Measure.sum \u03bc)", "start": [613, 1], "end": [615, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_add_measure", "code": "@[simp]\ntheorem lintegral_add_measure {m : MeasurableSpace \u03b1} (f : \u03b1 \u2192 \u211d\u22650\u221e) (\u03bc \u03bd : Measure \u03b1) :\n    \u222b\u207b a, f a \u2202(\u03bc + \u03bd) = \u222b\u207b a, f a \u2202\u03bc + \u222b\u207b a, f a \u2202\u03bd", "start": [618, 1], "end": [621, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_finset_sum_measure", "code": "@[simp]\ntheorem lintegral_finset_sum_measure {\u03b9} {m : MeasurableSpace \u03b1} (s : Finset \u03b9) (f : \u03b1 \u2192 \u211d\u22650\u221e)\n    (\u03bc : \u03b9 \u2192 Measure \u03b1) : \u222b\u207b a, f a \u2202(\u2211 i in s, \u03bc i) = \u2211 i in s, \u222b\u207b a, f a \u2202\u03bc i", "start": [624, 1], "end": [628, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_zero_measure", "code": "@[simp]\ntheorem lintegral_zero_measure {m : MeasurableSpace \u03b1} (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    (\u222b\u207b a, f a \u2202(0 : Measure \u03b1)) = 0", "start": [631, 1], "end": [634, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_of_isEmpty", "code": "@[simp]\ntheorem lintegral_of_isEmpty {\u03b1} [MeasurableSpace \u03b1] [IsEmpty \u03b1] (\u03bc : Measure \u03b1) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b x, f x \u2202\u03bc = 0", "start": [637, 1], "end": [639, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_empty", "code": "theorem set_lintegral_empty (f : \u03b1 \u2192 \u211d\u22650\u221e) : \u222b\u207b x in \u2205, f x \u2202\u03bc = 0", "start": [641, 1], "end": [642, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_univ", "code": "theorem set_lintegral_univ (f : \u03b1 \u2192 \u211d\u22650\u221e) : \u222b\u207b x in univ, f x \u2202\u03bc = \u222b\u207b x, f x \u2202\u03bc", "start": [645, 1], "end": [646, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_measure_zero", "code": "theorem set_lintegral_measure_zero (s : Set \u03b1) (f : \u03b1 \u2192 \u211d\u22650\u221e) (hs' : \u03bc s = 0) :\n    \u222b\u207b x in s, f x \u2202\u03bc = 0", "start": [649, 1], "end": [652, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_finset_sum'", "code": "theorem lintegral_finset_sum' (s : Finset \u03b2) {f : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : \u2200 b \u2208 s, AEMeasurable (f b) \u03bc) :\n    \u222b\u207b a, \u2211 b in s, f b a \u2202\u03bc = \u2211 b in s, \u222b\u207b a, f b a \u2202\u03bc", "start": [655, 1], "end": [662, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_finset_sum", "code": "theorem lintegral_finset_sum (s : Finset \u03b2) {f : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200 b \u2208 s, Measurable (f b)) :\n    \u222b\u207b a, \u2211 b in s, f b a \u2202\u03bc = \u2211 b in s, \u222b\u207b a, f b a \u2202\u03bc", "start": [665, 1], "end": [667, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_const_mul", "code": "@[simp]\ntheorem lintegral_const_mul (r : \u211d\u22650\u221e) {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    \u222b\u207b a, r * f a \u2202\u03bc = r * \u222b\u207b a, f a \u2202\u03bc", "start": [670, 1], "end": [688, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_const_mul''", "code": "theorem lintegral_const_mul'' (r : \u211d\u22650\u221e) {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) :\n    \u222b\u207b a, r * f a \u2202\u03bc = r * \u222b\u207b a, f a \u2202\u03bc", "start": [691, 1], "end": [696, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_const_mul_le", "code": "theorem lintegral_const_mul_le (r : \u211d\u22650\u221e) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    (r * \u222b\u207b a, f a \u2202\u03bc) \u2264 \u222b\u207b a, r * f a \u2202\u03bc", "start": [699, 1], "end": [708, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_const_mul'", "code": "theorem lintegral_const_mul' (r : \u211d\u22650\u221e) (f : \u03b1 \u2192 \u211d\u22650\u221e) (hr : r \u2260 \u221e) :\n    \u222b\u207b a, r * f a \u2202\u03bc = r * \u222b\u207b a, f a \u2202\u03bc", "start": [711, 1], "end": [722, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_mul_const", "code": "theorem lintegral_mul_const (r : \u211d\u22650\u221e) {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    \u222b\u207b a, f a * r \u2202\u03bc = (\u222b\u207b a, f a \u2202\u03bc) * r", "start": [725, 1], "end": [726, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_mul_const''", "code": "theorem lintegral_mul_const'' (r : \u211d\u22650\u221e) {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) :\n    \u222b\u207b a, f a * r \u2202\u03bc = (\u222b\u207b a, f a \u2202\u03bc) * r", "start": [729, 1], "end": [730, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_mul_const_le", "code": "theorem lintegral_mul_const_le (r : \u211d\u22650\u221e) (f : \u03b1 \u2192 \u211d\u22650\u221e) : (\u222b\u207b a, f a \u2202\u03bc) * r \u2264 \u222b\u207b a, f a * r \u2202\u03bc", "start": [733, 1], "end": [734, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_mul_const'", "code": "theorem lintegral_mul_const' (r : \u211d\u22650\u221e) (f : \u03b1 \u2192 \u211d\u22650\u221e) (hr : r \u2260 \u221e) :\n    \u222b\u207b a, f a * r \u2202\u03bc = (\u222b\u207b a, f a \u2202\u03bc) * r", "start": [737, 1], "end": [738, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_lintegral_mul", "code": "theorem lintegral_lintegral_mul {\u03b2} [MeasurableSpace \u03b2] {\u03bd : Measure \u03b2} {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    {g : \u03b2 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bd) :\n    \u222b\u207b x, \u222b\u207b y, f x * g y \u2202\u03bd \u2202\u03bc = (\u222b\u207b x, f x \u2202\u03bc) * \u222b\u207b y, g y \u2202\u03bd", "start": [743, 1], "end": [746, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_rw\u2081", "code": "theorem lintegral_rw\u2081 {f f' : \u03b1 \u2192 \u03b2} (h : f =\u1d50[\u03bc] f') (g : \u03b2 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a, g (f a) \u2202\u03bc = \u222b\u207b a, g (f' a) \u2202\u03bc", "start": [750, 1], "end": [752, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_rw\u2082", "code": "theorem lintegral_rw\u2082 {f\u2081 f\u2081' : \u03b1 \u2192 \u03b2} {f\u2082 f\u2082' : \u03b1 \u2192 \u03b3} (h\u2081 : f\u2081 =\u1d50[\u03bc] f\u2081') (h\u2082 : f\u2082 =\u1d50[\u03bc] f\u2082')\n    (g : \u03b2 \u2192 \u03b3 \u2192 \u211d\u22650\u221e) : \u222b\u207b a, g (f\u2081 a) (f\u2082 a) \u2202\u03bc = \u222b\u207b a, g (f\u2081' a) (f\u2082' a) \u2202\u03bc", "start": [756, 1], "end": [758, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_indicator", "code": "@[simp]\ntheorem lintegral_indicator (f : \u03b1 \u2192 \u211d\u22650\u221e) {s : Set \u03b1} (hs : MeasurableSet s) :\n    \u222b\u207b a, s.indicator f a \u2202\u03bc = \u222b\u207b a in s, f a \u2202\u03bc", "start": [761, 1], "end": [773, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_indicator\u2080", "code": "theorem lintegral_indicator\u2080 (f : \u03b1 \u2192 \u211d\u22650\u221e) {s : Set \u03b1} (hs : NullMeasurableSet s \u03bc) :\n    \u222b\u207b a, s.indicator f a \u2202\u03bc = \u222b\u207b a in s, f a \u2202\u03bc", "start": [776, 1], "end": [780, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_indicator_const\u2080", "code": "theorem lintegral_indicator_const\u2080 {s : Set \u03b1} (hs : NullMeasurableSet s \u03bc) (c : \u211d\u22650\u221e) :\n    \u222b\u207b a, s.indicator (fun _ => c) a \u2202\u03bc = c * \u03bc s", "start": [783, 1], "end": [785, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_indicator_const", "code": "theorem lintegral_indicator_const {s : Set \u03b1} (hs : MeasurableSet s) (c : \u211d\u22650\u221e) :\n    \u222b\u207b a, s.indicator (fun _ => c) a \u2202\u03bc = c * \u03bc s", "start": [787, 1], "end": [789, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_eq_const", "code": "theorem set_lintegral_eq_const {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) (r : \u211d\u22650\u221e) :\n    \u222b\u207b x in { x | f x = r }, f x \u2202\u03bc = r * \u03bc { x | f x = r }", "start": [792, 1], "end": [797, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_indicator_one", "code": "@[simp]\ntheorem lintegral_indicator_one (hs : MeasurableSet s) : \u222b\u207b a, s.indicator 1 a \u2202\u03bc = \u03bc s", "start": [800, 1], "end": [802, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_add_mul_meas_add_le_le_lintegral", "code": "theorem lintegral_add_mul_meas_add_le_le_lintegral {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hle : f \u2264\u1d50[\u03bc] g)\n    (hg : AEMeasurable g \u03bc) (\u03b5 : \u211d\u22650\u221e) :\n    \u222b\u207b a, f a \u2202\u03bc + \u03b5 * \u03bc { x | f x + \u03b5 \u2264 g x } \u2264 \u222b\u207b a, g a \u2202\u03bc", "start": [805, 1], "end": [822, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mul_meas_ge_le_lintegral\u2080", "code": "theorem mul_meas_ge_le_lintegral\u2080 {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) (\u03b5 : \u211d\u22650\u221e) :\n    \u03b5 * \u03bc { x | \u03b5 \u2264 f x } \u2264 \u222b\u207b a, f a \u2202\u03bc", "start": [825, 1], "end": [829, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mul_meas_ge_le_lintegral", "code": "theorem mul_meas_ge_le_lintegral {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) (\u03b5 : \u211d\u22650\u221e) :\n    \u03b5 * \u03bc { x | \u03b5 \u2264 f x } \u2264 \u222b\u207b a, f a \u2202\u03bc", "start": [832, 1], "end": [836, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_eq_top_of_measure_eq_top_ne_zero", "code": "theorem lintegral_eq_top_of_measure_eq_top_ne_zero {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc)\n    (h\u03bcf : \u03bc {x | f x = \u221e} \u2260 0) : \u222b\u207b x, f x \u2202\u03bc = \u221e", "start": [839, 1], "end": [844, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.setLintegral_eq_top_of_measure_eq_top_ne_zero", "code": "theorem setLintegral_eq_top_of_measure_eq_top_ne_zero (hf : AEMeasurable f (\u03bc.restrict s))\n    (h\u03bcf : \u03bc ({x \u2208 s | f x = \u221e}) \u2260 0) : \u222b\u207b x in s, f x \u2202\u03bc = \u221e", "start": [847, 1], "end": [850, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_eq_top_of_lintegral_ne_top", "code": "theorem measure_eq_top_of_lintegral_ne_top (hf : AEMeasurable f \u03bc) (h\u03bcf : \u222b\u207b x, f x \u2202\u03bc \u2260 \u221e) :\n    \u03bc {x | f x = \u221e} = 0", "start": [853, 1], "end": [855, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_eq_top_of_setLintegral_ne_top", "code": "theorem measure_eq_top_of_setLintegral_ne_top (hf : AEMeasurable f (\u03bc.restrict s))\n    (h\u03bcf : \u222b\u207b x in s, f x \u2202\u03bc \u2260 \u221e) : \u03bc ({x \u2208 s | f x = \u221e}) = 0", "start": [858, 1], "end": [860, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.meas_ge_le_lintegral_div", "code": "theorem meas_ge_le_lintegral_div {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) {\u03b5 : \u211d\u22650\u221e} (h\u03b5 : \u03b5 \u2260 0)\n    (h\u03b5' : \u03b5 \u2260 \u221e) : \u03bc { x | \u03b5 \u2264 f x } \u2264 (\u222b\u207b a, f a \u2202\u03bc) / \u03b5", "start": [863, 1], "end": [868, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_of_ae_le_of_lintegral_le", "code": "theorem ae_eq_of_ae_le_of_lintegral_le {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hfg : f \u2264\u1d50[\u03bc] g) (hf : \u222b\u207b x, f x \u2202\u03bc \u2260 \u221e)\n    (hg : AEMeasurable g \u03bc) (hgf : \u222b\u207b x, g x \u2202\u03bc \u2264 \u222b\u207b x, f x \u2202\u03bc) : f =\u1d50[\u03bc] g", "start": [871, 1], "end": [884, 84], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_eq_zero_iff'", "code": "@[simp]\ntheorem lintegral_eq_zero_iff' {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) :\n    \u222b\u207b a, f a \u2202\u03bc = 0 \u2194 f =\u1d50[\u03bc] 0", "start": [887, 1], "end": [894, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_eq_zero_iff", "code": "@[simp]\ntheorem lintegral_eq_zero_iff {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) : \u222b\u207b a, f a \u2202\u03bc = 0 \u2194 f =\u1d50[\u03bc] 0", "start": [897, 1], "end": [899, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_pos_iff_support", "code": "theorem lintegral_pos_iff_support {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    (0 < \u222b\u207b a, f a \u2202\u03bc) \u2194 0 < \u03bc (Function.support f)", "start": [902, 1], "end": [904, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_iSup_ae", "code": "theorem lintegral_iSup_ae {f : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200 n, Measurable (f n))\n    (h_mono : \u2200 n, \u2200\u1d50 a \u2202\u03bc, f n a \u2264 f n.succ a) : \u222b\u207b a, \u2a06 n, f n a \u2202\u03bc = \u2a06 n, \u222b\u207b a, f n a \u2202\u03bc", "start": [907, 1], "end": [923, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_sub'", "code": "theorem lintegral_sub' {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hg : AEMeasurable g \u03bc) (hg_fin : \u222b\u207b a, g a \u2202\u03bc \u2260 \u221e)\n    (h_le : g \u2264\u1d50[\u03bc] f) : \u222b\u207b a, f a - g a \u2202\u03bc = \u222b\u207b a, f a \u2202\u03bc - \u222b\u207b a, g a \u2202\u03bc", "start": [926, 1], "end": [930, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_sub", "code": "theorem lintegral_sub {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hg : Measurable g) (hg_fin : \u222b\u207b a, g a \u2202\u03bc \u2260 \u221e)\n    (h_le : g \u2264\u1d50[\u03bc] f) : \u222b\u207b a, f a - g a \u2202\u03bc = \u222b\u207b a, f a \u2202\u03bc - \u222b\u207b a, g a \u2202\u03bc", "start": [933, 1], "end": [935, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_sub_le'", "code": "theorem lintegral_sub_le' (f g : \u03b1 \u2192 \u211d\u22650\u221e) (hf : AEMeasurable f \u03bc) :\n    (\u222b\u207b x, g x \u2202\u03bc - \u222b\u207b x, f x \u2202\u03bc) \u2264 \u222b\u207b x, g x - f x \u2202\u03bc", "start": [938, 1], "end": [945, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_sub_le", "code": "theorem lintegral_sub_le (f g : \u03b1 \u2192 \u211d\u22650\u221e) (hf : Measurable f) :\n    (\u222b\u207b x, g x \u2202\u03bc - \u222b\u207b x, f x \u2202\u03bc) \u2264 \u222b\u207b x, g x - f x \u2202\u03bc", "start": [948, 1], "end": [950, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_strict_mono_of_ae_le_of_frequently_ae_lt", "code": "theorem lintegral_strict_mono_of_ae_le_of_frequently_ae_lt {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hg : AEMeasurable g \u03bc)\n    (hfi : \u222b\u207b x, f x \u2202\u03bc \u2260 \u221e) (h_le : f \u2264\u1d50[\u03bc] g) (h : \u2203\u1d50 x \u2202\u03bc, f x \u2260 g x) :\n    \u222b\u207b x, f x \u2202\u03bc < \u222b\u207b x, g x \u2202\u03bc", "start": [953, 1], "end": [958, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_strict_mono_of_ae_le_of_ae_lt_on", "code": "theorem lintegral_strict_mono_of_ae_le_of_ae_lt_on {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hg : AEMeasurable g \u03bc)\n    (hfi : \u222b\u207b x, f x \u2202\u03bc \u2260 \u221e) (h_le : f \u2264\u1d50[\u03bc] g) {s : Set \u03b1} (h\u03bcs : \u03bc s \u2260 0)\n    (h : \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 f x < g x) : \u222b\u207b x, f x \u2202\u03bc < \u222b\u207b x, g x \u2202\u03bc", "start": [961, 1], "end": [965, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_strict_mono", "code": "theorem lintegral_strict_mono {f g : \u03b1 \u2192 \u211d\u22650\u221e} (h\u03bc : \u03bc \u2260 0) (hg : AEMeasurable g \u03bc)\n    (hfi : \u222b\u207b x, f x \u2202\u03bc \u2260 \u221e) (h : \u2200\u1d50 x \u2202\u03bc, f x < g x) : \u222b\u207b x, f x \u2202\u03bc < \u222b\u207b x, g x \u2202\u03bc", "start": [968, 1], "end": [972, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_strict_mono", "code": "theorem set_lintegral_strict_mono {f g : \u03b1 \u2192 \u211d\u22650\u221e} {s : Set \u03b1} (hsm : MeasurableSet s)\n    (hs : \u03bc s \u2260 0) (hg : Measurable g) (hfi : \u222b\u207b x in s, f x \u2202\u03bc \u2260 \u221e)\n    (h : \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 f x < g x) : \u222b\u207b x in s, f x \u2202\u03bc < \u222b\u207b x in s, g x \u2202\u03bc", "start": [975, 1], "end": [978, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_iInf_ae", "code": "theorem lintegral_iInf_ae {f : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (h_meas : \u2200 n, Measurable (f n))\n    (h_mono : \u2200 n : \u2115, f n.succ \u2264\u1d50[\u03bc] f n) (h_fin : \u222b\u207b a, f 0 a \u2202\u03bc \u2260 \u221e) :\n    \u222b\u207b a, \u2a05 n, f n a \u2202\u03bc = \u2a05 n, \u222b\u207b a, f n a \u2202\u03bc", "start": [981, 1], "end": [1010, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_iInf", "code": "theorem lintegral_iInf {f : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (h_meas : \u2200 n, Measurable (f n)) (h_anti : Antitone f)\n    (h_fin : \u222b\u207b a, f 0 a \u2202\u03bc \u2260 \u221e) : \u222b\u207b a, \u2a05 n, f n a \u2202\u03bc = \u2a05 n, \u222b\u207b a, f n a \u2202\u03bc", "start": [1013, 1], "end": [1016, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_liminf_le'", "code": "theorem lintegral_liminf_le' {f : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (h_meas : \u2200 n, AEMeasurable (f n) \u03bc) :\n    \u222b\u207b a, liminf (fun n => f n a) atTop \u2202\u03bc \u2264 liminf (fun n => \u222b\u207b a, f n a \u2202\u03bc) atTop", "start": [1019, 1], "end": [1029, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_liminf_le", "code": "theorem lintegral_liminf_le {f : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (h_meas : \u2200 n, Measurable (f n)) :\n    \u222b\u207b a, liminf (fun n => f n a) atTop \u2202\u03bc \u2264 liminf (fun n => \u222b\u207b a, f n a \u2202\u03bc) atTop", "start": [1032, 1], "end": [1035, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.limsup_lintegral_le", "code": "theorem limsup_lintegral_le {f : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} {g : \u03b1 \u2192 \u211d\u22650\u221e} (hf_meas : \u2200 n, Measurable (f n))\n    (h_bound : \u2200 n, f n \u2264\u1d50[\u03bc] g) (h_fin : \u222b\u207b a, g a \u2202\u03bc \u2260 \u221e) :\n    limsup (fun n => \u222b\u207b a, f n a \u2202\u03bc) atTop \u2264 \u222b\u207b a, limsup (fun n => f n a) atTop \u2202\u03bc", "start": [1038, 1], "end": [1054, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_lintegral_of_dominated_convergence", "code": "theorem tendsto_lintegral_of_dominated_convergence {F : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (bound : \u03b1 \u2192 \u211d\u22650\u221e) (hF_meas : \u2200 n, Measurable (F n)) (h_bound : \u2200 n, F n \u2264\u1d50[\u03bc] bound)\n    (h_fin : \u222b\u207b a, bound a \u2202\u03bc \u2260 \u221e) (h_lim : \u2200\u1d50 a \u2202\u03bc, Tendsto (fun n => F n a) atTop (\ud835\udcdd (f a))) :\n    Tendsto (fun n => \u222b\u207b a, F n a \u2202\u03bc) atTop (\ud835\udcdd (\u222b\u207b a, f a \u2202\u03bc))", "start": [1057, 1], "end": [1072, 8], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_lintegral_of_dominated_convergence'", "code": "theorem tendsto_lintegral_of_dominated_convergence' {F : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (bound : \u03b1 \u2192 \u211d\u22650\u221e) (hF_meas : \u2200 n, AEMeasurable (F n) \u03bc) (h_bound : \u2200 n, F n \u2264\u1d50[\u03bc] bound)\n    (h_fin : \u222b\u207b a, bound a \u2202\u03bc \u2260 \u221e) (h_lim : \u2200\u1d50 a \u2202\u03bc, Tendsto (fun n => F n a) atTop (\ud835\udcdd (f a))) :\n    Tendsto (fun n => \u222b\u207b a, F n a \u2202\u03bc) atTop (\ud835\udcdd (\u222b\u207b a, f a \u2202\u03bc))", "start": [1075, 1], "end": [1093, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_lintegral_filter_of_dominated_convergence", "code": "theorem tendsto_lintegral_filter_of_dominated_convergence {\u03b9} {l : Filter \u03b9}\n    [l.IsCountablyGenerated] {F : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} {f : \u03b1 \u2192 \u211d\u22650\u221e} (bound : \u03b1 \u2192 \u211d\u22650\u221e)\n    (hF_meas : \u2200\u1da0 n in l, Measurable (F n)) (h_bound : \u2200\u1da0 n in l, \u2200\u1d50 a \u2202\u03bc, F n a \u2264 bound a)\n    (h_fin : \u222b\u207b a, bound a \u2202\u03bc \u2260 \u221e) (h_lim : \u2200\u1d50 a \u2202\u03bc, Tendsto (fun n => F n a) l (\ud835\udcdd (f a))) :\n    Tendsto (fun n => \u222b\u207b a, F n a \u2202\u03bc) l (\ud835\udcdd <| \u222b\u207b a, f a \u2202\u03bc)", "start": [1096, 1], "end": [1124, 15], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_iSup_directed_of_measurable", "code": "theorem lintegral_iSup_directed_of_measurable [Countable \u03b2] {f : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : \u2200 b, Measurable (f b)) (h_directed : Directed (\u00b7 \u2264 \u00b7) f) :\n    \u222b\u207b a, \u2a06 b, f b a \u2202\u03bc = \u2a06 b, \u222b\u207b a, f b a \u2202\u03bc", "start": [1131, 1], "end": [1150, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_iSup_directed", "code": "theorem lintegral_iSup_directed [Countable \u03b2] {f : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200 b, AEMeasurable (f b) \u03bc)\n    (h_directed : Directed (\u00b7 \u2264 \u00b7) f) : \u222b\u207b a, \u2a06 b, f b a \u2202\u03bc = \u2a06 b, \u222b\u207b a, f b a \u2202\u03bc", "start": [1153, 1], "end": [1179, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_tsum", "code": "theorem lintegral_tsum [Countable \u03b2] {f : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200 i, AEMeasurable (f i) \u03bc) :\n    \u222b\u207b a, \u2211' i, f i a \u2202\u03bc = \u2211' i, \u222b\u207b a, f i a \u2202\u03bc", "start": [1184, 1], "end": [1195, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_iUnion\u2080", "code": "theorem lintegral_iUnion\u2080 [Countable \u03b2] {s : \u03b2 \u2192 Set \u03b1} (hm : \u2200 i, NullMeasurableSet (s i) \u03bc)\n    (hd : Pairwise (AEDisjoint \u03bc on s)) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a in \u22c3 i, s i, f a \u2202\u03bc = \u2211' i, \u222b\u207b a in s i, f a \u2202\u03bc", "start": [1200, 1], "end": [1203, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_iUnion", "code": "theorem lintegral_iUnion [Countable \u03b2] {s : \u03b2 \u2192 Set \u03b1} (hm : \u2200 i, MeasurableSet (s i))\n    (hd : Pairwise (Disjoint on s)) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a in \u22c3 i, s i, f a \u2202\u03bc = \u2211' i, \u222b\u207b a in s i, f a \u2202\u03bc", "start": [1206, 1], "end": [1209, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_biUnion\u2080", "code": "theorem lintegral_biUnion\u2080 {t : Set \u03b2} {s : \u03b2 \u2192 Set \u03b1} (ht : t.Countable)\n    (hm : \u2200 i \u2208 t, NullMeasurableSet (s i) \u03bc) (hd : t.Pairwise (AEDisjoint \u03bc on s)) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a in \u22c3 i \u2208 t, s i, f a \u2202\u03bc = \u2211' i : t, \u222b\u207b a in s i, f a \u2202\u03bc", "start": [1212, 1], "end": [1216, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_biUnion", "code": "theorem lintegral_biUnion {t : Set \u03b2} {s : \u03b2 \u2192 Set \u03b1} (ht : t.Countable)\n    (hm : \u2200 i \u2208 t, MeasurableSet (s i)) (hd : t.PairwiseDisjoint s) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a in \u22c3 i \u2208 t, s i, f a \u2202\u03bc = \u2211' i : t, \u222b\u207b a in s i, f a \u2202\u03bc", "start": [1219, 1], "end": [1222, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_biUnion_finset\u2080", "code": "theorem lintegral_biUnion_finset\u2080 {s : Finset \u03b2} {t : \u03b2 \u2192 Set \u03b1}\n    (hd : Set.Pairwise (\u2191s) (AEDisjoint \u03bc on t)) (hm : \u2200 b \u2208 s, NullMeasurableSet (t b) \u03bc)\n    (f : \u03b1 \u2192 \u211d\u22650\u221e) : \u222b\u207b a in \u22c3 b \u2208 s, t b, f a \u2202\u03bc = \u2211 b in s, \u222b\u207b a in t b, f a \u2202\u03bc", "start": [1225, 1], "end": [1228, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_biUnion_finset", "code": "theorem lintegral_biUnion_finset {s : Finset \u03b2} {t : \u03b2 \u2192 Set \u03b1} (hd : Set.PairwiseDisjoint (\u2191s) t)\n    (hm : \u2200 b \u2208 s, MeasurableSet (t b)) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a in \u22c3 b \u2208 s, t b, f a \u2202\u03bc = \u2211 b in s, \u222b\u207b a in t b, f a \u2202\u03bc", "start": [1231, 1], "end": [1234, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_iUnion_le", "code": "theorem lintegral_iUnion_le [Countable \u03b2] (s : \u03b2 \u2192 Set \u03b1) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a in \u22c3 i, s i, f a \u2202\u03bc \u2264 \u2211' i, \u222b\u207b a in s i, f a \u2202\u03bc", "start": [1237, 1], "end": [1240, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_union", "code": "theorem lintegral_union {f : \u03b1 \u2192 \u211d\u22650\u221e} {A B : Set \u03b1} (hB : MeasurableSet B) (hAB : Disjoint A B) :\n    \u222b\u207b a in A \u222a B, f a \u2202\u03bc = \u222b\u207b a in A, f a \u2202\u03bc + \u222b\u207b a in B, f a \u2202\u03bc", "start": [1243, 1], "end": [1245, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_union_le", "code": "theorem lintegral_union_le (f : \u03b1 \u2192 \u211d\u22650\u221e) (s t : Set \u03b1) :\n    \u222b\u207b a in s \u222a t, f a \u2202\u03bc \u2264 \u222b\u207b a in s, f a \u2202\u03bc + \u222b\u207b a in t, f a \u2202\u03bc", "start": [1248, 1], "end": [1251, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_inter_add_diff", "code": "theorem lintegral_inter_add_diff {B : Set \u03b1} (f : \u03b1 \u2192 \u211d\u22650\u221e) (A : Set \u03b1) (hB : MeasurableSet B) :\n    \u222b\u207b x in A \u2229 B, f x \u2202\u03bc + \u222b\u207b x in A \\ B, f x \u2202\u03bc = \u222b\u207b x in A, f x \u2202\u03bc", "start": [1253, 1], "end": [1255, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_add_compl", "code": "theorem lintegral_add_compl (f : \u03b1 \u2192 \u211d\u22650\u221e) {A : Set \u03b1} (hA : MeasurableSet A) :\n    \u222b\u207b x in A, f x \u2202\u03bc + \u222b\u207b x in A\u1d9c, f x \u2202\u03bc = \u222b\u207b x, f x \u2202\u03bc", "start": [1258, 1], "end": [1260, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_max", "code": "theorem lintegral_max {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) (hg : Measurable g) :\n    \u222b\u207b x, max (f x) (g x) \u2202\u03bc =\n      \u222b\u207b x in { x | f x \u2264 g x }, g x \u2202\u03bc + \u222b\u207b x in { x | g x < f x }, f x \u2202\u03bc", "start": [1263, 1], "end": [1271, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_max", "code": "theorem set_lintegral_max {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) (hg : Measurable g) (s : Set \u03b1) :\n    \u222b\u207b x in s, max (f x) (g x) \u2202\u03bc =\n      \u222b\u207b x in s \u2229 { x | f x \u2264 g x }, g x \u2202\u03bc + \u222b\u207b x in s \u2229 { x | g x < f x }, f x \u2202\u03bc", "start": [1274, 1], "end": [1278, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_map", "code": "theorem lintegral_map {m\u03b2 : MeasurableSpace \u03b2} {f : \u03b2 \u2192 \u211d\u22650\u221e} {g : \u03b1 \u2192 \u03b2} (hf : Measurable f)\n    (hg : Measurable g) : \u222b\u207b a, f a \u2202map g \u03bc = \u222b\u207b a, f (g a) \u2202\u03bc", "start": [1281, 1], "end": [1286, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_map'", "code": "theorem lintegral_map' {m\u03b2 : MeasurableSpace \u03b2} {f : \u03b2 \u2192 \u211d\u22650\u221e} {g : \u03b1 \u2192 \u03b2}\n    (hf : AEMeasurable f (Measure.map g \u03bc)) (hg : AEMeasurable g \u03bc) :\n    \u222b\u207b a, f a \u2202Measure.map g \u03bc = \u222b\u207b a, f (g a) \u2202\u03bc", "start": [1289, 1], "end": [1300, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_map_le", "code": "theorem lintegral_map_le {m\u03b2 : MeasurableSpace \u03b2} (f : \u03b2 \u2192 \u211d\u22650\u221e) {g : \u03b1 \u2192 \u03b2} (hg : Measurable g) :\n    (\u222b\u207b a, f a \u2202Measure.map g \u03bc) \u2264 \u222b\u207b a, f (g a) \u2202\u03bc", "start": [1303, 1], "end": [1308, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_comp", "code": "theorem lintegral_comp [MeasurableSpace \u03b2] {f : \u03b2 \u2192 \u211d\u22650\u221e} {g : \u03b1 \u2192 \u03b2} (hf : Measurable f)\n    (hg : Measurable g) : lintegral \u03bc (f \u2218 g) = \u222b\u207b a, f a \u2202map g \u03bc", "start": [1311, 1], "end": [1313, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_map", "code": "theorem set_lintegral_map [MeasurableSpace \u03b2] {f : \u03b2 \u2192 \u211d\u22650\u221e} {g : \u03b1 \u2192 \u03b2} {s : Set \u03b2}\n    (hs : MeasurableSet s) (hf : Measurable f) (hg : Measurable g) :\n    \u222b\u207b y in s, f y \u2202map g \u03bc = \u222b\u207b x in g \u207b\u00b9' s, f (g x) \u2202\u03bc", "start": [1316, 1], "end": [1319, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_indicator_const_comp", "code": "theorem lintegral_indicator_const_comp {m\u03b2 : MeasurableSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}\n    (hf : Measurable f) (hs : MeasurableSet s) (c : \u211d\u22650\u221e) :\n    \u222b\u207b a, s.indicator (fun _ => c) (f a) \u2202\u03bc = c * \u03bc (f \u207b\u00b9' s)", "start": [1322, 1], "end": [1326, 29], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.lintegral_map", "code": "theorem _root_.MeasurableEmbedding.lintegral_map [MeasurableSpace \u03b2] {g : \u03b1 \u2192 \u03b2}\n    (hg : MeasurableEmbedding g) (f : \u03b2 \u2192 \u211d\u22650\u221e) : \u222b\u207b a, f a \u2202map g \u03bc = \u222b\u207b a, f (g a) \u2202\u03bc", "start": [1329, 1], "end": [1342, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_map_equiv", "code": "theorem lintegral_map_equiv [MeasurableSpace \u03b2] (f : \u03b2 \u2192 \u211d\u22650\u221e) (g : \u03b1 \u2243\u1d50 \u03b2) :\n    \u222b\u207b a, f a \u2202map g \u03bc = \u222b\u207b a, f (g a) \u2202\u03bc", "start": [1345, 1], "end": [1350, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.lintegral_map_equiv", "code": "protected theorem MeasurePreserving.lintegral_map_equiv [MeasurableSpace \u03b2] {\u03bd : Measure \u03b2}\n    (f : \u03b2 \u2192 \u211d\u22650\u221e) (g : \u03b1 \u2243\u1d50 \u03b2) (hg : MeasurePreserving g \u03bc \u03bd) :\n    \u222b\u207b a, f a \u2202\u03bd = \u222b\u207b a, f (g a) \u2202\u03bc", "start": [1353, 1], "end": [1356, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.lintegral_comp", "code": "theorem MeasurePreserving.lintegral_comp {mb : MeasurableSpace \u03b2} {\u03bd : Measure \u03b2} {g : \u03b1 \u2192 \u03b2}\n    (hg : MeasurePreserving g \u03bc \u03bd) {f : \u03b2 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    \u222b\u207b a, f (g a) \u2202\u03bc = \u222b\u207b b, f b \u2202\u03bd", "start": [1358, 1], "end": [1360, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.lintegral_comp_emb", "code": "theorem MeasurePreserving.lintegral_comp_emb {mb : MeasurableSpace \u03b2} {\u03bd : Measure \u03b2} {g : \u03b1 \u2192 \u03b2}\n    (hg : MeasurePreserving g \u03bc \u03bd) (hge : MeasurableEmbedding g) (f : \u03b2 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a, f (g a) \u2202\u03bc = \u222b\u207b b, f b \u2202\u03bd", "start": [1363, 1], "end": [1365, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.set_lintegral_comp_preimage", "code": "theorem MeasurePreserving.set_lintegral_comp_preimage {mb : MeasurableSpace \u03b2} {\u03bd : Measure \u03b2}\n    {g : \u03b1 \u2192 \u03b2} (hg : MeasurePreserving g \u03bc \u03bd) {s : Set \u03b2} (hs : MeasurableSet s) {f : \u03b2 \u2192 \u211d\u22650\u221e}\n    (hf : Measurable f) : \u222b\u207b a in g \u207b\u00b9' s, f (g a) \u2202\u03bc = \u222b\u207b b in s, f b \u2202\u03bd", "start": [1368, 1], "end": [1371, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.set_lintegral_comp_preimage_emb", "code": "theorem MeasurePreserving.set_lintegral_comp_preimage_emb {mb : MeasurableSpace \u03b2} {\u03bd : Measure \u03b2}\n    {g : \u03b1 \u2192 \u03b2} (hg : MeasurePreserving g \u03bc \u03bd) (hge : MeasurableEmbedding g) (f : \u03b2 \u2192 \u211d\u22650\u221e)\n    (s : Set \u03b2) : \u222b\u207b a in g \u207b\u00b9' s, f (g a) \u2202\u03bc = \u222b\u207b b in s, f b \u2202\u03bd", "start": [1374, 1], "end": [1377, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.set_lintegral_comp_emb", "code": "theorem MeasurePreserving.set_lintegral_comp_emb {mb : MeasurableSpace \u03b2} {\u03bd : Measure \u03b2}\n    {g : \u03b1 \u2192 \u03b2} (hg : MeasurePreserving g \u03bc \u03bd) (hge : MeasurableEmbedding g) (f : \u03b2 \u2192 \u211d\u22650\u221e)\n    (s : Set \u03b1) : \u222b\u207b a in s, f (g a) \u2202\u03bc = \u222b\u207b b in g '' s, f b \u2202\u03bd", "start": [1380, 1], "end": [1383, 83], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.Top.measurableSingletonClass", "code": "instance (priority := 10) _root_.MeasurableSpace.Top.measurableSingletonClass {\u03b1 : Type*} :\n    @MeasurableSingletonClass \u03b1 (\u22a4 : MeasurableSpace \u03b1) :=\n  @MeasurableSingletonClass.mk \u03b1 (\u22a4 : MeasurableSpace \u03b1) <|\n    fun _ => MeasurableSpace.measurableSet_top", "start": [1388, 1], "end": [1391, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_dirac'", "code": "theorem lintegral_dirac' (a : \u03b1) {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) : \u222b\u207b a, f a \u2202dirac a = f a", "start": [1396, 1], "end": [1397, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_dirac", "code": "theorem lintegral_dirac [MeasurableSingletonClass \u03b1] (a : \u03b1) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a, f a \u2202dirac a = f a", "start": [1400, 1], "end": [1401, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_dirac'", "code": "theorem set_lintegral_dirac' {a : \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) {s : Set \u03b1}\n    (hs : MeasurableSet s) [Decidable (a \u2208 s)] :\n    \u222b\u207b x in s, f x \u2202Measure.dirac a = if a \u2208 s then f a else 0", "start": [1404, 1], "end": [1410, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_dirac", "code": "theorem set_lintegral_dirac {a : \u03b1} (f : \u03b1 \u2192 \u211d\u22650\u221e) (s : Set \u03b1) [MeasurableSingletonClass \u03b1]\n    [Decidable (a \u2208 s)] : \u222b\u207b x in s, f x \u2202Measure.dirac a = if a \u2208 s then f a else 0", "start": [1413, 1], "end": [1418, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_count'", "code": "theorem lintegral_count' {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) : \u222b\u207b a, f a \u2202count = \u2211' a, f a", "start": [1421, 1], "end": [1424, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_count", "code": "theorem lintegral_count [MeasurableSingletonClass \u03b1] (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a, f a \u2202count = \u2211' a, f a", "start": [1427, 1], "end": [1431, 44], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_const_eq", "code": "theorem _root_.ENNReal.tsum_const_eq [MeasurableSingletonClass \u03b1] (c : \u211d\u22650\u221e) :\n    \u2211' _ : \u03b1, c = c * Measure.count (univ : Set \u03b1)", "start": [1434, 1], "end": [1435, 97], "kind": "commanddeclaration"}, {"full_name": "ENNReal.count_const_le_le_of_tsum_le", "code": "theorem _root_.ENNReal.count_const_le_le_of_tsum_le [MeasurableSingletonClass \u03b1] {a : \u03b1 \u2192 \u211d\u22650\u221e}\n    (a_mble : Measurable a) {c : \u211d\u22650\u221e} (tsum_le_c : \u2211' i, a i \u2264 c) {\u03b5 : \u211d\u22650\u221e} (\u03b5_ne_zero : \u03b5 \u2260 0)\n    (\u03b5_ne_top : \u03b5 \u2260 \u221e) : Measure.count { i : \u03b1 | \u03b5 \u2264 a i } \u2264 c / \u03b5", "start": [1438, 1], "end": [1444, 44], "kind": "commanddeclaration"}, {"full_name": "NNReal.count_const_le_le_of_tsum_le", "code": "theorem _root_.NNReal.count_const_le_le_of_tsum_le [MeasurableSingletonClass \u03b1] {a : \u03b1 \u2192 \u211d\u22650}\n    (a_mble : Measurable a) (a_summable : Summable a) {c : \u211d\u22650} (tsum_le_c : \u2211' i, a i \u2264 c)\n    {\u03b5 : \u211d\u22650} (\u03b5_ne_zero : \u03b5 \u2260 0) : Measure.count { i : \u03b1 | \u03b5 \u2264 a i } \u2264 c / \u03b5", "start": [1447, 1], "end": [1459, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_countable'", "code": "theorem lintegral_countable' [Countable \u03b1] [MeasurableSingletonClass \u03b1] (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a, f a \u2202\u03bc = \u2211' a, f a * \u03bc {a}", "start": [1471, 1], "end": [1475, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_singleton'", "code": "theorem lintegral_singleton' {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) (a : \u03b1) :\n    \u222b\u207b x in {a}, f x \u2202\u03bc = f a * \u03bc {a}", "start": [1478, 1], "end": [1480, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_singleton", "code": "theorem lintegral_singleton [MeasurableSingletonClass \u03b1] (f : \u03b1 \u2192 \u211d\u22650\u221e) (a : \u03b1) :\n    \u222b\u207b x in {a}, f x \u2202\u03bc = f a * \u03bc {a}", "start": [1483, 1], "end": [1485, 84], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_countable", "code": "theorem lintegral_countable [MeasurableSingletonClass \u03b1] (f : \u03b1 \u2192 \u211d\u22650\u221e) {s : Set \u03b1}\n    (hs : s.Countable) : \u222b\u207b a in s, f a \u2202\u03bc = \u2211' a : s, f a * \u03bc {(a : \u03b1)}", "start": [1488, 1], "end": [1494, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_insert", "code": "theorem lintegral_insert [MeasurableSingletonClass \u03b1] {a : \u03b1} {s : Set \u03b1} (h : a \u2209 s)\n    (f : \u03b1 \u2192 \u211d\u22650\u221e) : \u222b\u207b x in insert a s, f x \u2202\u03bc = f a * \u03bc {a} + \u222b\u207b x in s, f x \u2202\u03bc", "start": [1497, 1], "end": [1501, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_finset", "code": "theorem lintegral_finset [MeasurableSingletonClass \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b x in s, f x \u2202\u03bc = \u2211 x in s, f x * \u03bc {x}", "start": [1504, 1], "end": [1506, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_fintype", "code": "theorem lintegral_fintype [MeasurableSingletonClass \u03b1] [Fintype \u03b1] (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b x, f x \u2202\u03bc = \u2211 x, f x * \u03bc {x}", "start": [1509, 1], "end": [1511, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_unique", "code": "theorem lintegral_unique [Unique \u03b1] (f : \u03b1 \u2192 \u211d\u22650\u221e) : \u222b\u207b x, f x \u2202\u03bc = f default * \u03bc univ", "start": [1514, 1], "end": [1517, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_lt_top", "code": "theorem ae_lt_top {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) (h2f : \u222b\u207b x, f x \u2202\u03bc \u2260 \u221e) :\n    \u2200\u1d50 x \u2202\u03bc, f x < \u221e", "start": [1522, 1], "end": [1532, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_lt_top'", "code": "theorem ae_lt_top' {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) (h2f : \u222b\u207b x, f x \u2202\u03bc \u2260 \u221e) :\n    \u2200\u1d50 x \u2202\u03bc, f x < \u221e", "start": [1535, 1], "end": [1538, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_lt_top_of_bddAbove", "code": "theorem set_lintegral_lt_top_of_bddAbove {s : Set \u03b1} (hs : \u03bc s \u2260 \u221e) {f : \u03b1 \u2192 \u211d\u22650}\n    (hf : Measurable f) (hbdd : BddAbove (f '' s)) : \u222b\u207b x in s, f x \u2202\u03bc < \u221e", "start": [1541, 1], "end": [1550, 14], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_lt_top_of_isCompact", "code": "theorem set_lintegral_lt_top_of_isCompact [TopologicalSpace \u03b1] [OpensMeasurableSpace \u03b1] {s : Set \u03b1}\n    (hs : \u03bc s \u2260 \u221e) (hsc : IsCompact s) {f : \u03b1 \u2192 \u211d\u22650} (hf : Continuous f) :\n    \u222b\u207b x in s, f x \u2202\u03bc < \u221e", "start": [1553, 1], "end": [1556, 76], "kind": "commanddeclaration"}, {"full_name": "IsFiniteMeasure.lintegral_lt_top_of_bounded_to_ennreal", "code": "theorem _root_.IsFiniteMeasure.lintegral_lt_top_of_bounded_to_ennreal {\u03b1 : Type*}\n    [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) [\u03bc_fin : IsFiniteMeasure \u03bc] {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (f_bdd : \u2203 c : \u211d\u22650, \u2200 x, f x \u2264 c) : \u222b\u207b x, f x \u2202\u03bc < \u221e", "start": [1559, 1], "end": [1565, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_pos_lintegral_lt_of_sigmaFinite", "code": "theorem exists_pos_lintegral_lt_of_sigmaFinite (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] {\u03b5 : \u211d\u22650\u221e}\n    (\u03b50 : \u03b5 \u2260 0) : \u2203 g : \u03b1 \u2192 \u211d\u22650, (\u2200 x, 0 < g x) \u2227 Measurable g \u2227 \u222b\u207b x, g x \u2202\u03bc < \u03b5", "start": [1574, 1], "end": [1591, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_trim", "code": "theorem lintegral_trim {\u03bc : Measure \u03b1} (hm : m \u2264 m0) {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable[m] f) :\n    \u222b\u207b a, f a \u2202\u03bc.trim hm = \u222b\u207b a, f a \u2202\u03bc", "start": [1594, 1], "end": [1612, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_trim_ae", "code": "theorem lintegral_trim_ae {\u03bc : Measure \u03b1} (hm : m \u2264 m0) {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f (\u03bc.trim hm)) : \u222b\u207b a, f a \u2202\u03bc.trim hm = \u222b\u207b a, f a \u2202\u03bc", "start": [1615, 1], "end": [1618, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.univ_le_of_forall_fin_meas_le", "code": "theorem univ_le_of_forall_fin_meas_le {\u03bc : Measure \u03b1} (hm : m \u2264 m0) [SigmaFinite (\u03bc.trim hm)]\n    (C : \u211d\u22650\u221e) {f : Set \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200 s, MeasurableSet[m] s \u2192 \u03bc s \u2260 \u221e \u2192 f s \u2264 C)\n    (h_F_lim :\n      \u2200 S : \u2115 \u2192 Set \u03b1, (\u2200 n, MeasurableSet[m] (S n)) \u2192 Monotone S \u2192 f (\u22c3 n, S n) \u2264 \u2a06 n, f (S n)) :\n    f univ \u2264 C", "start": [1625, 1], "end": [1636, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_le_of_forall_fin_meas_le_of_measurable", "code": "theorem lintegral_le_of_forall_fin_meas_le_of_measurable {\u03bc : Measure \u03b1} (hm : m \u2264 m0)\n    [SigmaFinite (\u03bc.trim hm)] (C : \u211d\u22650\u221e) {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf_meas : Measurable f)\n    (hf : \u2200 s, MeasurableSet[m] s \u2192 \u03bc s \u2260 \u221e \u2192 \u222b\u207b x in s, f x \u2202\u03bc \u2264 C) : \u222b\u207b x, f x \u2202\u03bc \u2264 C", "start": [1639, 1], "end": [1677, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_le_of_forall_fin_meas_le'", "code": "theorem lintegral_le_of_forall_fin_meas_le' {\u03bc : Measure \u03b1} (hm : m \u2264 m0) [SigmaFinite (\u03bc.trim hm)]\n    (C : \u211d\u22650\u221e) {f : _ \u2192 \u211d\u22650\u221e} (hf_meas : AEMeasurable f \u03bc)\n    (hf : \u2200 s, MeasurableSet[m] s \u2192 \u03bc s \u2260 \u221e \u2192 \u222b\u207b x in s, f x \u2202\u03bc \u2264 C) : \u222b\u207b x, f x \u2202\u03bc \u2264 C", "start": [1680, 1], "end": [1693, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_le_of_forall_fin_meas_le", "code": "theorem lintegral_le_of_forall_fin_meas_le [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} [SigmaFinite \u03bc]\n    (C : \u211d\u22650\u221e) {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf_meas : AEMeasurable f \u03bc)\n    (hf : \u2200 s, MeasurableSet s \u2192 \u03bc s \u2260 \u221e \u2192 \u222b\u207b x in s, f x \u2202\u03bc \u2264 C) : \u222b\u207b x, f x \u2202\u03bc \u2264 C", "start": [1696, 1], "end": [1702, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.exists_lt_lintegral_simpleFunc_of_lt_lintegral", "code": "theorem SimpleFunc.exists_lt_lintegral_simpleFunc_of_lt_lintegral {m : MeasurableSpace \u03b1}\n    {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] {f : \u03b1 \u2192\u209b \u211d\u22650} {L : \u211d\u22650\u221e} (hL : L < \u222b\u207b x, f x \u2202\u03bc) :\n    \u2203 g : \u03b1 \u2192\u209b \u211d\u22650, (\u2200 x, g x \u2264 f x) \u2227 \u222b\u207b x, g x \u2202\u03bc < \u221e \u2227 L < \u222b\u207b x, g x \u2202\u03bc", "start": [1705, 1], "end": [1757, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_lt_lintegral_simpleFunc_of_lt_lintegral", "code": "theorem exists_lt_lintegral_simpleFunc_of_lt_lintegral {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    [SigmaFinite \u03bc] {f : \u03b1 \u2192 \u211d\u22650} {L : \u211d\u22650\u221e} (hL : L < \u222b\u207b x, f x \u2202\u03bc) :\n    \u2203 g : \u03b1 \u2192\u209b \u211d\u22650, (\u2200 x, g x \u2264 f x) \u2227 \u222b\u207b x, g x \u2202\u03bc < \u221e \u2227 L < \u222b\u207b x, g x \u2202\u03bc", "start": [1760, 1], "end": [1770, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_measure_of_ae_tendsto_indicator", "code": "lemma tendsto_measure_of_ae_tendsto_indicator {\u03bc : Measure \u03b1} (A_mble : MeasurableSet A)\n    (As_mble : \u2200 i, MeasurableSet (As i)) {B : Set \u03b1} (B_mble : MeasurableSet B)\n    (B_finmeas : \u03bc B \u2260 \u221e) (As_le_B : \u2200\u1da0 i in L, As i \u2286 B)\n    (h_lim : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun i \u21a6 (As i).indicator (1 : \u03b1 \u2192 \u211d\u22650\u221e) x)\n      L (\ud835\udcdd (A.indicator 1 x))) :\n    Tendsto (fun i \u21a6 \u03bc (As i)) L (\ud835\udcdd (\u03bc A)) := by\n  simp_rw [\u2190 MeasureTheory.lintegral_indicator_one A_mble,\n           \u2190 MeasureTheory.lintegral_indicator_one (As_mble _)]\n  refine tendsto_lintegral_filter_of_dominated_convergence (B.indicator (1 : \u03b1 \u2192 \u211d\u22650\u221e))\n          (eventually_of_forall ?_) ?_ ?_ h_lim\n  \u00b7 exact fun i \u21a6 Measurable.indicator measurable_const (As_mble i)\n  \u00b7 filter_upwards [As_le_B] with i hi\n    exact eventually_of_forall (fun x \u21a6 indicator_le_indicator_of_subset hi (by simp) x)\n  \u00b7 rwa [\u2190 lintegral_indicator_one B_mble] at B_finmeas", "start": [1780, 1], "end": [1796, 56], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.tendsto_measure_of_ae_tendsto_indicator_of_isFiniteMeasure", "code": "lemma tendsto_measure_of_ae_tendsto_indicator_of_isFiniteMeasure [IsCountablyGenerated L]\n    {\u03bc : Measure \u03b1} [IsFiniteMeasure \u03bc] (A_mble : MeasurableSet A)\n    (As_mble : \u2200 i, MeasurableSet (As i))\n    (h_lim : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun i \u21a6 (As i).indicator (1 : \u03b1 \u2192 \u211d\u22650\u221e) x)\n      L (\ud835\udcdd (A.indicator 1 x))) :\n    Tendsto (fun i \u21a6 \u03bc (As i)) L (\ud835\udcdd (\u03bc A)) :=\n  tendsto_measure_of_ae_tendsto_indicator L A_mble As_mble MeasurableSet.univ\n    (measure_ne_top \u03bc univ) (eventually_of_forall (fun i \u21a6 subset_univ (As i))) h_lim", "start": [1798, 1], "end": [1808, 86], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Topology/MetricSpace/Metrizable.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Bounded.lean", "Mathlib/Topology/UrysohnsLemma.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/SpecificLimits/Basic.lean", "Mathlib/Topology/UniformSpace/Cauchy.lean"], "premises": [{"full_name": "TopologicalSpace.PseudoMetrizableSpace", "code": "class PseudoMetrizableSpace (X : Type*) [t : TopologicalSpace X] : Prop where\n  exists_pseudo_metric : \u2203 m : PseudoMetricSpace X, m.toUniformSpace.toTopologicalSpace = t", "start": [35, 1], "end": [39, 92], "kind": "commanddeclaration"}, {"full_name": "PseudoMetricSpace.toPseudoMetrizableSpace", "code": "instance (priority := 100) _root_.PseudoMetricSpace.toPseudoMetrizableSpace {X : Type*}\n    [m : PseudoMetricSpace X] : PseudoMetrizableSpace X :=\n  \u27e8\u27e8m, rfl\u27e9\u27e9", "start": [42, 1], "end": [44, 13], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.pseudoMetrizableSpacePseudoMetric", "code": "noncomputable def pseudoMetrizableSpacePseudoMetric (X : Type*) [TopologicalSpace X]\n    [h : PseudoMetrizableSpace X] : PseudoMetricSpace X :=\n  h.exists_pseudo_metric.choose.replaceTopology h.exists_pseudo_metric.choose_spec.symm", "start": [47, 1], "end": [50, 88], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.pseudoMetrizableSpace_prod", "code": "instance pseudoMetrizableSpace_prod [PseudoMetrizableSpace X] [PseudoMetrizableSpace Y] :\n    PseudoMetrizableSpace (X \u00d7 Y) :=\n  letI : PseudoMetricSpace X := pseudoMetrizableSpacePseudoMetric X\n  letI : PseudoMetricSpace Y := pseudoMetrizableSpacePseudoMetric Y\n  inferInstance", "start": [53, 1], "end": [57, 16], "kind": "commanddeclaration"}, {"full_name": "Inducing.pseudoMetrizableSpace", "code": "theorem _root_.Inducing.pseudoMetrizableSpace [PseudoMetrizableSpace Y] {f : X \u2192 Y}\n    (hf : Inducing f) : PseudoMetrizableSpace X", "start": [60, 1], "end": [65, 37], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PseudoMetrizableSpace.firstCountableTopology", "code": "instance (priority := 100) PseudoMetrizableSpace.firstCountableTopology\n    [h : PseudoMetrizableSpace X] : TopologicalSpace.FirstCountableTopology X := by\n  rcases h with \u27e8_, hm\u27e9\n  rw [\u2190 hm]\n  exact @UniformSpace.firstCountableTopology X PseudoMetricSpace.toUniformSpace\n    EMetric.instIsCountablyGeneratedUniformity", "start": [68, 1], "end": [74, 47], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PseudoMetrizableSpace.subtype", "code": "instance PseudoMetrizableSpace.subtype [PseudoMetrizableSpace X] (s : Set X) :\n    PseudoMetrizableSpace s :=\n  inducing_subtype_val.pseudoMetrizableSpace", "start": [77, 1], "end": [79, 45], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.pseudoMetrizableSpace_pi", "code": "instance pseudoMetrizableSpace_pi [\u2200 i, PseudoMetrizableSpace (\u03c0 i)] :\n    PseudoMetrizableSpace (\u2200 i, \u03c0 i) := by\n  cases nonempty_fintype \u03b9\n  letI := fun i => pseudoMetrizableSpacePseudoMetric (\u03c0 i)\n  infer_instance", "start": [82, 1], "end": [86, 17], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.MetrizableSpace", "code": "class MetrizableSpace (X : Type*) [t : TopologicalSpace X] : Prop where\n  exists_metric : \u2203 m : MetricSpace X, m.toUniformSpace.toTopologicalSpace = t", "start": [89, 1], "end": [93, 79], "kind": "commanddeclaration"}, {"full_name": "MetricSpace.toMetrizableSpace", "code": "instance (priority := 100) _root_.MetricSpace.toMetrizableSpace {X : Type*} [m : MetricSpace X] :\n    MetrizableSpace X :=\n  \u27e8\u27e8m, rfl\u27e9\u27e9", "start": [96, 1], "end": [98, 13], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.MetrizableSpace.toPseudoMetrizableSpace", "code": "instance (priority := 100) MetrizableSpace.toPseudoMetrizableSpace [h : MetrizableSpace X] :\n    PseudoMetrizableSpace X :=\n  let \u27e8m, hm\u27e9 := h.1\n  \u27e8\u27e8m.toPseudoMetricSpace, hm\u27e9\u27e9", "start": [101, 1], "end": [104, 32], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.metrizableSpaceMetric", "code": "noncomputable def metrizableSpaceMetric (X : Type*) [TopologicalSpace X] [h : MetrizableSpace X] :\n    MetricSpace X :=\n  h.exists_metric.choose.replaceTopology h.exists_metric.choose_spec.symm", "start": [107, 1], "end": [110, 74], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.t2Space_of_metrizableSpace", "code": "instance (priority := 100) t2Space_of_metrizableSpace [MetrizableSpace X] : T2Space X :=\n  letI : MetricSpace X := metrizableSpaceMetric X\n  inferInstance", "start": [113, 1], "end": [115, 16], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.metrizableSpace_prod", "code": "instance metrizableSpace_prod [MetrizableSpace X] [MetrizableSpace Y] : MetrizableSpace (X \u00d7 Y) :=\n  letI : MetricSpace X := metrizableSpaceMetric X\n  letI : MetricSpace Y := metrizableSpaceMetric Y\n  inferInstance", "start": [118, 1], "end": [121, 16], "kind": "commanddeclaration"}, {"full_name": "Embedding.metrizableSpace", "code": "theorem _root_.Embedding.metrizableSpace [MetrizableSpace Y] {f : X \u2192 Y} (hf : Embedding f) :\n    MetrizableSpace X", "start": [124, 1], "end": [129, 33], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.MetrizableSpace.subtype", "code": "instance MetrizableSpace.subtype [MetrizableSpace X] (s : Set X) : MetrizableSpace s :=\n  embedding_subtype_val.metrizableSpace", "start": [132, 1], "end": [133, 40], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.metrizableSpace_pi", "code": "instance metrizableSpace_pi [\u2200 i, MetrizableSpace (\u03c0 i)] : MetrizableSpace (\u2200 i, \u03c0 i) := by\n  cases nonempty_fintype \u03b9\n  letI := fun i => metrizableSpaceMetric (\u03c0 i)\n  infer_instance", "start": [136, 1], "end": [139, 17], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsSeparable.secondCountableTopology", "code": "theorem IsSeparable.secondCountableTopology [PseudoMetrizableSpace X] {s : Set X}\n    (hs : IsSeparable s) : SecondCountableTopology s", "start": [142, 1], "end": [146, 52], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.exists_embedding_l_infty", "code": "theorem exists_embedding_l_infty : \u2203 f : X \u2192 \u2115 \u2192\u1d47 \u211d, Embedding f", "start": [151, 1], "end": [231, 97], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.metrizableSpace_of_t3_second_countable", "code": "theorem metrizableSpace_of_t3_second_countable : MetrizableSpace X", "start": [234, 1], "end": [239, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Units.lean", "imports": ["Mathlib/Analysis/SpecificLimits/Normed.lean", "Mathlib/Topology/Algebra/Ring/Ideal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Units.oneSub", "code": "@[simps val]\ndef oneSub (t : R) (h : \u2016t\u2016 < 1) : R\u02e3 where\n  val := 1 - t\n  inv := \u2211' n : \u2115, t ^ n\n  val_inv := mul_neg_geom_series t h\n  inv_val := geom_series_mul_neg t h", "start": [40, 1], "end": [47, 37], "kind": "commanddeclaration"}, {"full_name": "Units.add", "code": "@[simps! val]\ndef add (x : R\u02e3) (t : R) (h : \u2016t\u2016 < \u2016(\u2191x\u207b\u00b9 : R)\u2016\u207b\u00b9) : R\u02e3 :=\n  Units.copy (x * Units.oneSub (-((x\u207b\u00b9).1 * t)) (by\n      nontriviality R using zero_lt_one\n      have hpos : 0 < \u2016(\u2191x\u207b\u00b9 : R)\u2016 := Units.norm_pos x\u207b\u00b9\n      calc\n        \u2016-(\u2191x\u207b\u00b9 * t)\u2016 = \u2016\u2191x\u207b\u00b9 * t\u2016 := by rw [norm_neg]\n        _ \u2264 \u2016(\u2191x\u207b\u00b9 : R)\u2016 * \u2016t\u2016 := norm_mul_le (x\u207b\u00b9).1 _\n        _ < \u2016(\u2191x\u207b\u00b9 : R)\u2016 * \u2016(\u2191x\u207b\u00b9 : R)\u2016\u207b\u00b9 := by nlinarith only [h, hpos]\n        _ = 1 := mul_inv_cancel (ne_of_gt hpos)))\n    (x + t) (by simp [mul_add]) _ rfl", "start": [51, 1], "end": [64, 38], "kind": "commanddeclaration"}, {"full_name": "Units.ofNearby", "code": "@[simps! val]\ndef ofNearby (x : R\u02e3) (y : R) (h : \u2016y - x\u2016 < \u2016(\u2191x\u207b\u00b9 : R)\u2016\u207b\u00b9) : R\u02e3 :=\n  (x.add (y - x : R) h).copy y (by simp) _ rfl", "start": [68, 1], "end": [72, 47], "kind": "commanddeclaration"}, {"full_name": "Units.isOpen", "code": "protected theorem isOpen : IsOpen { x : R | IsUnit x }", "start": [76, 1], "end": [83, 33], "kind": "commanddeclaration"}, {"full_name": "Units.nhds", "code": "protected theorem nhds (x : R\u02e3) : { x : R | IsUnit x } \u2208 \ud835\udcdd (x : R)", "start": [86, 1], "end": [87, 40], "kind": "commanddeclaration"}, {"full_name": "nonunits.subset_compl_ball", "code": "theorem subset_compl_ball : nonunits R \u2286 (Metric.ball (1 : R) 1)\u1d9c", "start": [94, 1], "end": [97, 87], "kind": "commanddeclaration"}, {"full_name": "nonunits.isClosed", "code": "protected theorem isClosed : IsClosed (nonunits R)", "start": [101, 1], "end": [102, 30], "kind": "commanddeclaration"}, {"full_name": "NormedRing.inverse_one_sub", "code": "theorem inverse_one_sub (t : R) (h : \u2016t\u2016 < 1) : inverse (1 - t) = \u2191(Units.oneSub t h)\u207b\u00b9", "start": [113, 1], "end": [114, 59], "kind": "commanddeclaration"}, {"full_name": "NormedRing.inverse_add", "code": "theorem inverse_add (x : R\u02e3) :\n    \u2200\u1da0 t in \ud835\udcdd 0, inverse ((x : R) + t) = inverse (1 + \u2191x\u207b\u00b9 * t) * \u2191x\u207b\u00b9", "start": [117, 1], "end": [126, 54], "kind": "commanddeclaration"}, {"full_name": "NormedRing.inverse_one_sub_nth_order'", "code": "theorem inverse_one_sub_nth_order' (n : \u2115) {t : R} (ht : \u2016t\u2016 < 1) :\n    inverse ((1 : R) - t) = (\u2211 i in range n, t ^ i) + t ^ n * inverse (1 - t)", "start": [129, 1], "end": [135, 87], "kind": "commanddeclaration"}, {"full_name": "NormedRing.inverse_one_sub_nth_order", "code": "theorem inverse_one_sub_nth_order (n : \u2115) :\n    \u2200\u1da0 t in \ud835\udcdd 0, inverse ((1 : R) - t) = (\u2211 i in range n, t ^ i) + t ^ n * inverse (1 - t)", "start": [137, 1], "end": [140, 29], "kind": "commanddeclaration"}, {"full_name": "NormedRing.inverse_add_nth_order", "code": "theorem inverse_add_nth_order (x : R\u02e3) (n : \u2115) :\n    \u2200\u1da0 t in \ud835\udcdd 0, inverse ((x : R) + t) =\n      (\u2211 i in range n, (-\u2191x\u207b\u00b9 * t) ^ i) * \u2191x\u207b\u00b9 + (-\u2191x\u207b\u00b9 * t) ^ n * inverse (x + t)", "start": [144, 1], "end": [156, 10], "kind": "commanddeclaration"}, {"full_name": "NormedRing.inverse_one_sub_norm", "code": "theorem inverse_one_sub_norm : (fun t : R => inverse (1 - t)) =O[\ud835\udcdd 0] (fun _t => 1 : R \u2192 \u211d)", "start": [159, 1], "end": [174, 11], "kind": "commanddeclaration"}, {"full_name": "NormedRing.inverse_add_norm", "code": "theorem inverse_add_norm (x : R\u02e3) : (fun t : R => inverse (\u2191x + t)) =O[\ud835\udcdd 0] fun _t => (1 : \u211d)", "start": [177, 1], "end": [183, 91], "kind": "commanddeclaration"}, {"full_name": "NormedRing.inverse_add_norm_diff_nth_order", "code": "theorem inverse_add_norm_diff_nth_order (x : R\u02e3) (n : \u2115) :\n    (fun t : R => inverse (\u2191x + t) - (\u2211 i in range n, (-\u2191x\u207b\u00b9 * t) ^ i) * \u2191x\u207b\u00b9) =O[\ud835\udcdd (0 : R)]\n      fun t => \u2016t\u2016 ^ n", "start": [186, 1], "end": [196, 62], "kind": "commanddeclaration"}, {"full_name": "NormedRing.inverse_add_norm_diff_first_order", "code": "theorem inverse_add_norm_diff_first_order (x : R\u02e3) :\n    (fun t : R => inverse (\u2191x + t) - \u2191x\u207b\u00b9) =O[\ud835\udcdd 0] fun t => \u2016t\u2016", "start": [199, 1], "end": [202, 50], "kind": "commanddeclaration"}, {"full_name": "NormedRing.inverse_add_norm_diff_second_order", "code": "theorem inverse_add_norm_diff_second_order (x : R\u02e3) :\n    (fun t : R => inverse (\u2191x + t) - \u2191x\u207b\u00b9 + \u2191x\u207b\u00b9 * t * \u2191x\u207b\u00b9) =O[\ud835\udcdd 0] fun t => \u2016t\u2016 ^ 2", "start": [205, 1], "end": [210, 40], "kind": "commanddeclaration"}, {"full_name": "NormedRing.inverse_continuousAt", "code": "theorem inverse_continuousAt (x : R\u02e3) : ContinuousAt inverse (x : R)", "start": [213, 1], "end": [221, 74], "kind": "commanddeclaration"}, {"full_name": "Units.openEmbedding_val", "code": "theorem openEmbedding_val : OpenEmbedding (val : R\u02e3 \u2192 R) where", "start": [230, 1], "end": [235, 29], "kind": "commanddeclaration"}, {"full_name": "Units.isOpenMap_val", "code": "theorem isOpenMap_val : IsOpenMap (val : R\u02e3 \u2192 R)", "start": [238, 1], "end": [241, 30], "kind": "commanddeclaration"}, {"full_name": "Ideal.eq_top_of_norm_lt_one", "code": "theorem eq_top_of_norm_lt_one (I : Ideal R) {x : R} (hxI : x \u2208 I) (hx : \u20161 - x\u2016 < 1) : I = \u22a4", "start": [248, 1], "end": [251, 100], "kind": "commanddeclaration"}, {"full_name": "Ideal.closure_ne_top", "code": "theorem closure_ne_top (I : Ideal R) (hI : I \u2260 \u22a4) : I.closure \u2260 \u22a4", "start": [254, 1], "end": [257, 85], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsMaximal.closure_eq", "code": "theorem IsMaximal.closure_eq {I : Ideal R} (hI : I.IsMaximal) : I.closure = I", "start": [260, 1], "end": [262, 65], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsMaximal.isClosed", "code": "instance IsMaximal.isClosed {I : Ideal R} [hI : I.IsMaximal] : IsClosed (I : Set R) :=\n  isClosed_of_closure_subset <| Eq.subset <| congr_arg ((\u2191) : Ideal R \u2192 Set R) hI.closure_eq", "start": [265, 1], "end": [267, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Multilinear.lean", "imports": ["Mathlib/Topology/Algebra/Module/Multilinear.lean", "Mathlib/Analysis/NormedSpace/OperatorNorm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MultilinearMap.bound_of_shell", "code": "theorem bound_of_shell {\u03b5 : \u03b9 \u2192 \u211d} {C : \u211d} (h\u03b5 : \u2200 i, 0 < \u03b5 i) {c : \u03b9 \u2192 \ud835\udd5c} (hc : \u2200 i, 1 < \u2016c i\u2016)\n    (hf : \u2200 m : \u2200 i, E i, (\u2200 i, \u03b5 i / \u2016c i\u2016 \u2264 \u2016m i\u2016) \u2192 (\u2200 i, \u2016m i\u2016 < \u03b5 i) \u2192 \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016)\n    (m : \u2200 i, E i) : \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016", "start": [109, 1], "end": [120, 42], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.exists_bound_of_continuous", "code": "theorem exists_bound_of_continuous (hf : Continuous f) :\n    \u2203 C : \u211d, 0 < C \u2227 \u2200 m, \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016", "start": [123, 1], "end": [142, 84], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.norm_image_sub_le_of_bound'", "code": "theorem norm_image_sub_le_of_bound' [DecidableEq \u03b9] {C : \u211d} (hC : 0 \u2264 C)\n    (H : \u2200 m, \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016) (m\u2081 m\u2082 : \u2200 i, E i) :\n    \u2016f m\u2081 - f m\u2082\u2016 \u2264 C * \u2211 i, \u220f j, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "start": [145, 1], "end": [193, 7], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.norm_image_sub_le_of_bound", "code": "theorem norm_image_sub_le_of_bound {C : \u211d} (hC : 0 \u2264 C) (H : \u2200 m, \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016)\n    (m\u2081 m\u2082 : \u2200 i, E i) :\n    \u2016f m\u2081 - f m\u2082\u2016 \u2264 C * Fintype.card \u03b9 * max \u2016m\u2081\u2016 \u2016m\u2082\u2016 ^ (Fintype.card \u03b9 - 1) * \u2016m\u2081 - m\u2082\u2016", "start": [196, 1], "end": [230, 11], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.continuous_of_bound", "code": "theorem continuous_of_bound (C : \u211d) (H : \u2200 m, \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016) : Continuous f", "start": [233, 1], "end": [252, 86], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkContinuous", "code": "def mkContinuous (C : \u211d) (H : \u2200 m, \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016) : ContinuousMultilinearMap \ud835\udd5c E G :=\n  { f with cont := f.continuous_of_bound C H }", "start": [255, 1], "end": [258, 47], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.coe_mkContinuous", "code": "@[simp]\ntheorem coe_mkContinuous (C : \u211d) (H : \u2200 m, \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016) : \u21d1(f.mkContinuous C H) = f", "start": [261, 1], "end": [263, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.restr_norm_le", "code": "theorem restr_norm_le {k n : \u2115} (f : (MultilinearMap \ud835\udd5c (fun _ : Fin n => G) G' : _))\n    (s : Finset (Fin n)) (hk : s.card = k) (z : G) {C : \u211d} (H : \u2200 m, \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016)\n    (v : Fin k \u2192 G) : \u2016f.restr s hk z v\u2016 \u2264 C * \u2016z\u2016 ^ (n - k) * \u220f i, \u2016v i\u2016", "start": [266, 1], "end": [277, 14], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.bound", "code": "theorem bound : \u2203 C : \u211d, 0 < C \u2227 \u2200 m, \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016", "start": [295, 1], "end": [296, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.opNorm", "code": "def opNorm :=\n  sInf { c | 0 \u2264 (c : \u211d) \u2227 \u2200 m, \u2016f m\u2016 \u2264 c * \u220f i, \u2016m i\u2016 }", "start": [301, 1], "end": [303, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.hasOpNorm", "code": "instance hasOpNorm : Norm (ContinuousMultilinearMap \ud835\udd5c E G) :=\n  \u27e8opNorm\u27e9", "start": [306, 1], "end": [307, 11], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.hasOpNorm'", "code": "instance hasOpNorm' : Norm (ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9 => G) G') :=\n  ContinuousMultilinearMap.hasOpNorm", "start": [310, 1], "end": [313, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_def", "code": "theorem norm_def : \u2016f\u2016 = sInf { c | 0 \u2264 (c : \u211d) \u2227 \u2200 m, \u2016f m\u2016 \u2264 c * \u220f i, \u2016m i\u2016 }", "start": [316, 1], "end": [317, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.bounds_nonempty", "code": "theorem bounds_nonempty {f : ContinuousMultilinearMap \ud835\udd5c E G} :\n    \u2203 c, c \u2208 { c | 0 \u2264 c \u2227 \u2200 m, \u2016f m\u2016 \u2264 c * \u220f i, \u2016m i\u2016 }", "start": [322, 1], "end": [325, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.bounds_bddBelow", "code": "theorem bounds_bddBelow {f : ContinuousMultilinearMap \ud835\udd5c E G} :\n    BddBelow { c | 0 \u2264 c \u2227 \u2200 m, \u2016f m\u2016 \u2264 c * \u220f i, \u2016m i\u2016 }", "start": [328, 1], "end": [330, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.isLeast_op_norm", "code": "theorem isLeast_op_norm : IsLeast {c : \u211d | 0 \u2264 c \u2227 \u2200 m, \u2016f m\u2016 \u2264 c * \u220f i, \u2016m i\u2016} \u2016f\u2016", "start": [333, 1], "end": [337, 71], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.op_norm_nonneg", "code": "theorem op_norm_nonneg : 0 \u2264 \u2016f\u2016", "start": [339, 1], "end": [340, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.le_op_norm", "code": "theorem le_op_norm : \u2016f m\u2016 \u2264 \u2016f\u2016 * \u220f i, \u2016m i\u2016", "start": [343, 1], "end": [345, 73], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.le_mul_prod_of_le_op_norm_of_le", "code": "theorem le_mul_prod_of_le_op_norm_of_le {C : \u211d} {b : \u03b9 \u2192 \u211d} (hC : \u2016f\u2016 \u2264 C) (hm : \u2200 i, \u2016m i\u2016 \u2264 b i) :\n    \u2016f m\u2016 \u2264 C * \u220f i, b i", "start": [350, 1], "end": [353, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.le_op_norm_mul_prod_of_le", "code": "theorem le_op_norm_mul_prod_of_le {b : \u03b9 \u2192 \u211d} (hm : \u2200 i, \u2016m i\u2016 \u2264 b i) : \u2016f m\u2016 \u2264 \u2016f\u2016 * \u220f i, b i", "start": [357, 1], "end": [358, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.le_op_norm_mul_pow_card_of_le", "code": "theorem le_op_norm_mul_pow_card_of_le {b : \u211d} (hm : \u2016m\u2016 \u2264 b) :\n    \u2016f m\u2016 \u2264 \u2016f\u2016 * b ^ Fintype.card \u03b9", "start": [361, 1], "end": [363, 100], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.le_op_norm_mul_pow_of_le", "code": "theorem le_op_norm_mul_pow_of_le {Ei : Fin n \u2192 Type*} [\u2200 i, NormedAddCommGroup (Ei i)]\n    [\u2200 i, NormedSpace \ud835\udd5c (Ei i)] (f : ContinuousMultilinearMap \ud835\udd5c Ei G) {m : \u2200 i, Ei i} {b : \u211d}\n    (hm : \u2016m\u2016 \u2264 b) : \u2016f m\u2016 \u2264 \u2016f\u2016 * b ^ n", "start": [366, 1], "end": [369, 73], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.le_of_op_norm_le", "code": "theorem le_of_op_norm_le {C : \u211d} (h : \u2016f\u2016 \u2264 C) : \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016", "start": [374, 1], "end": [375, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.ratio_le_op_norm", "code": "theorem ratio_le_op_norm : (\u2016f m\u2016 / \u220f i, \u2016m i\u2016) \u2264 \u2016f\u2016", "start": [380, 1], "end": [382, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.unit_le_op_norm", "code": "theorem unit_le_op_norm (h : \u2016m\u2016 \u2264 1) : \u2016f m\u2016 \u2264 \u2016f\u2016", "start": [385, 1], "end": [387, 55], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.op_norm_le_bound", "code": "theorem op_norm_le_bound {M : \u211d} (hMp : 0 \u2264 M) (hM : \u2200 m, \u2016f m\u2016 \u2264 M * \u220f i, \u2016m i\u2016) : \u2016f\u2016 \u2264 M", "start": [390, 1], "end": [392, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.op_norm_le_iff", "code": "theorem op_norm_le_iff {C : \u211d} (hC : 0 \u2264 C) : \u2016f\u2016 \u2264 C \u2194 \u2200 m, \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016", "start": [395, 1], "end": [396, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.op_norm_add_le", "code": "theorem op_norm_add_le : \u2016f + g\u2016 \u2264 \u2016f\u2016 + \u2016g\u2016", "start": [398, 1], "end": [402, 62], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.op_norm_zero", "code": "theorem op_norm_zero : \u2016(0 : ContinuousMultilinearMap \ud835\udd5c E G)\u2016 = 0", "start": [405, 1], "end": [406, 77], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.op_norm_zero_iff", "code": "theorem op_norm_zero_iff : \u2016f\u2016 = 0 \u2194 f = 0", "start": [409, 1], "end": [411, 74], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.op_norm_smul_le", "code": "theorem op_norm_smul_le (c : \ud835\udd5c') : \u2016c \u2022 f\u2016 \u2264 \u2016c\u2016 * \u2016f\u2016", "start": [418, 1], "end": [421, 69], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.op_norm_neg", "code": "theorem op_norm_neg : \u2016-f\u2016 = \u2016f\u2016", "start": [424, 1], "end": [428, 7], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.normedAddCommGroup", "code": "instance normedAddCommGroup : NormedAddCommGroup (ContinuousMultilinearMap \ud835\udd5c E G) :=\n  AddGroupNorm.toNormedAddCommGroup\n    { toFun := norm\n      map_zero' := op_norm_zero\n      neg' := op_norm_neg\n      add_le' := op_norm_add_le\n      eq_zero_of_map_eq_zero' := fun f => f.op_norm_zero_iff.1 }", "start": [431, 1], "end": [439, 65], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.normedAddCommGroup'", "code": "instance normedAddCommGroup' :\n    NormedAddCommGroup (ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9 => G) G') :=\n  ContinuousMultilinearMap.normedAddCommGroup", "start": [442, 1], "end": [446, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.normedSpace", "code": "instance normedSpace : NormedSpace \ud835\udd5c' (ContinuousMultilinearMap \ud835\udd5c E G) :=\n  \u27e8fun c f => f.op_norm_smul_le c\u27e9", "start": [449, 1], "end": [450, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.normedSpace'", "code": "instance normedSpace' : NormedSpace \ud835\udd5c' (ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9 => G') G) :=\n  ContinuousMultilinearMap.normedSpace", "start": [453, 1], "end": [456, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.le_op_nnnorm", "code": "theorem le_op_nnnorm : \u2016f m\u2016\u208a \u2264 \u2016f\u2016\u208a * \u220f i, \u2016m i\u2016\u208a", "start": [459, 1], "end": [464, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.le_of_op_nnnorm_le", "code": "theorem le_of_op_nnnorm_le {C : \u211d\u22650} (h : \u2016f\u2016\u208a \u2264 C) : \u2016f m\u2016\u208a \u2264 C * \u220f i, \u2016m i\u2016\u208a", "start": [467, 1], "end": [468, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.op_nnnorm_le_iff", "code": "theorem op_nnnorm_le_iff {C : \u211d\u22650} : \u2016f\u2016\u208a \u2264 C \u2194 \u2200 m, \u2016f m\u2016\u208a \u2264 C * \u220f i, \u2016m i\u2016\u208a", "start": [471, 1], "end": [472, 89], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.isLeast_op_nnnorm", "code": "theorem isLeast_op_nnnorm : IsLeast {C : \u211d\u22650 | \u2200 m, \u2016f m\u2016\u208a \u2264 C * \u220f i, \u2016m i\u2016\u208a} \u2016f\u2016\u208a", "start": [474, 1], "end": [475, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.op_nnnorm_prod", "code": "theorem op_nnnorm_prod (f : ContinuousMultilinearMap \ud835\udd5c E G) (g : ContinuousMultilinearMap \ud835\udd5c E G') :\n    \u2016f.prod g\u2016\u208a = max \u2016f\u2016\u208a \u2016g\u2016\u208a", "start": [477, 1], "end": [479, 87], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.op_norm_prod", "code": "theorem op_norm_prod (f : ContinuousMultilinearMap \ud835\udd5c E G) (g : ContinuousMultilinearMap \ud835\udd5c E G') :\n    \u2016f.prod g\u2016 = max \u2016f\u2016 \u2016g\u2016", "start": [481, 1], "end": [483, 47], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.op_nnnorm_pi", "code": "theorem op_nnnorm_pi\n    {\u03b9' : Type v'} [Fintype \u03b9'] {E' : \u03b9' \u2192 Type wE'} [\u2200 i', NormedAddCommGroup (E' i')]\n    [\u2200 i', NormedSpace \ud835\udd5c (E' i')] (f : \u2200 i', ContinuousMultilinearMap \ud835\udd5c E (E' i')) :\n    \u2016pi f\u2016\u208a = \u2016f\u2016\u208a", "start": [486, 1], "end": [490, 94], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.op_norm_pi", "code": "theorem op_norm_pi {\u03b9' : Type v'} [Fintype \u03b9'] {E' : \u03b9' \u2192 Type wE'}\n    [\u2200 i', NormedAddCommGroup (E' i')]\n    [\u2200 i', NormedSpace \ud835\udd5c (E' i')] (f : \u2200 i', ContinuousMultilinearMap \ud835\udd5c E (E' i')) :\n    \u2016pi f\u2016 = \u2016f\u2016", "start": [492, 1], "end": [496, 43], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_ofSubsingleton_le", "code": "theorem norm_ofSubsingleton_le [Subsingleton \u03b9] (i' : \u03b9) : \u2016ofSubsingleton \ud835\udd5c G i'\u2016 \u2264 1", "start": [503, 1], "end": [505, 71], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_ofSubsingleton", "code": "@[simp]\ntheorem norm_ofSubsingleton [Subsingleton \u03b9] [Nontrivial G] (i' : \u03b9) :\n    \u2016ofSubsingleton \ud835\udd5c G i'\u2016 = 1", "start": [508, 1], "end": [515, 82], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.nnnorm_ofSubsingleton_le", "code": "theorem nnnorm_ofSubsingleton_le [Subsingleton \u03b9] (i' : \u03b9) : \u2016ofSubsingleton \ud835\udd5c G i'\u2016\u208a \u2264 1", "start": [518, 1], "end": [519, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.nnnorm_ofSubsingleton", "code": "@[simp]\ntheorem nnnorm_ofSubsingleton [Subsingleton \u03b9] [Nontrivial G] (i' : \u03b9) :\n    \u2016ofSubsingleton \ud835\udd5c G i'\u2016\u208a = 1", "start": [522, 1], "end": [525, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_constOfIsEmpty", "code": "@[simp]\ntheorem norm_constOfIsEmpty [IsEmpty \u03b9] (x : G) : \u2016constOfIsEmpty \ud835\udd5c E x\u2016 = \u2016x\u2016", "start": [530, 1], "end": [535, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.nnnorm_constOfIsEmpty", "code": "@[simp]\ntheorem nnnorm_constOfIsEmpty [IsEmpty \u03b9] (x : G) : \u2016constOfIsEmpty \ud835\udd5c E x\u2016\u208a = \u2016x\u2016\u208a", "start": [538, 1], "end": [540, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.prodL", "code": "def prodL :\n    ContinuousMultilinearMap \ud835\udd5c E G \u00d7 ContinuousMultilinearMap \ud835\udd5c E G' \u2243\u2097\u1d62[\ud835\udd5c]\n      ContinuousMultilinearMap \ud835\udd5c E (G \u00d7 G') where\n  toFun f := f.1.prod f.2\n  invFun f :=\n    ((ContinuousLinearMap.fst \ud835\udd5c G G').compContinuousMultilinearMap f,\n      (ContinuousLinearMap.snd \ud835\udd5c G G').compContinuousMultilinearMap f)\n  map_add' f g := rfl\n  map_smul' c f := rfl\n  left_inv f := by ext <;> rfl\n  right_inv f := by ext <;> rfl\n  norm_map' f := op_norm_prod f.1 f.2", "start": [549, 1], "end": [561, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.pi\u2097\u1d62", "code": "def pi\u2097\u1d62 {\u03b9' : Type v'} [Fintype \u03b9'] {E' : \u03b9' \u2192 Type wE'} [\u2200 i', NormedAddCommGroup (E' i')]\n    [\u2200 i', NormedSpace \ud835\udd5c (E' i')] :\n    @LinearIsometryEquiv \ud835\udd5c \ud835\udd5c _ _ (RingHom.id \ud835\udd5c) _ _ _ (\u2200 i', ContinuousMultilinearMap \ud835\udd5c E (E' i'))\n      (ContinuousMultilinearMap \ud835\udd5c E (\u2200 i, E' i)) _ _ (@Pi.module \u03b9' _ \ud835\udd5c _ _ fun _ => inferInstance)\n      _ where\n  toLinearEquiv :=\n    { piEquiv with\n      map_add' := fun _ _ => rfl\n      map_smul' := fun _ _ => rfl }\n  norm_map' := op_norm_pi", "start": [565, 1], "end": [577, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_restrictScalars", "code": "@[simp]\ntheorem norm_restrictScalars : \u2016f.restrictScalars \ud835\udd5c'\u2016 = \u2016f\u2016", "start": [592, 1], "end": [593, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.restrictScalars\u2097\u1d62", "code": "def restrictScalars\u2097\u1d62 : ContinuousMultilinearMap \ud835\udd5c E G \u2192\u2097\u1d62[\ud835\udd5c'] ContinuousMultilinearMap \ud835\udd5c' E G where\n  toFun := restrictScalars \ud835\udd5c'\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  norm_map' _ := rfl", "start": [598, 1], "end": [603, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.restrictScalarsLinear", "code": "def restrictScalarsLinear : ContinuousMultilinearMap \ud835\udd5c E G \u2192L[\ud835\udd5c'] ContinuousMultilinearMap \ud835\udd5c' E G :=\n  (restrictScalars\u2097\u1d62 \ud835\udd5c').toContinuousLinearMap", "start": [606, 1], "end": [608, 47], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.continuous_restrictScalars", "code": "theorem continuous_restrictScalars :\n    Continuous\n      (restrictScalars \ud835\udd5c' : ContinuousMultilinearMap \ud835\udd5c E G \u2192 ContinuousMultilinearMap \ud835\udd5c' E G)", "start": [613, 1], "end": [616, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_image_sub_le'", "code": "theorem norm_image_sub_le' [DecidableEq \u03b9] (m\u2081 m\u2082 : \u2200 i, E i) :\n    \u2016f m\u2081 - f m\u2082\u2016 \u2264 \u2016f\u2016 * \u2211 i, \u220f j, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "start": [621, 1], "end": [628, 82], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_image_sub_le", "code": "theorem norm_image_sub_le (m\u2081 m\u2082 : \u2200 i, E i) :\n    \u2016f m\u2081 - f m\u2082\u2016 \u2264 \u2016f\u2016 * Fintype.card \u03b9 * max \u2016m\u2081\u2016 \u2016m\u2082\u2016 ^ (Fintype.card \u03b9 - 1) * \u2016m\u2081 - m\u2082\u2016", "start": [631, 1], "end": [636, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.continuous_eval", "code": "theorem continuous_eval : Continuous fun p :\n    ContinuousMultilinearMap \ud835\udd5c E G \u00d7 \u2200 i, E i => p.1 p.2", "start": [639, 1], "end": [667, 11], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.continuous_eval_left", "code": "theorem continuous_eval_left (m : \u2200 i, E i) :\n    Continuous fun p : ContinuousMultilinearMap \ud835\udd5c E G => p m", "start": [670, 1], "end": [672, 64], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.hasSum_eval", "code": "theorem hasSum_eval {\u03b1 : Type*} {p : \u03b1 \u2192 ContinuousMultilinearMap \ud835\udd5c E G}\n    {q : ContinuousMultilinearMap \ud835\udd5c E G} (h : HasSum p q) (m : \u2200 i, E i) :\n    HasSum (fun a => p a m) (q m)", "start": [675, 1], "end": [681, 7], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.tsum_eval", "code": "theorem tsum_eval {\u03b1 : Type*} {p : \u03b1 \u2192 ContinuousMultilinearMap \ud835\udd5c E G} (hp : Summable p)\n    (m : \u2200 i, E i) : (\u2211' a, p a) m = \u2211' a, p a m", "start": [684, 1], "end": [686, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.completeSpace", "code": "instance completeSpace [CompleteSpace G] : CompleteSpace (ContinuousMultilinearMap \ud835\udd5c E G) := by\n  have nonneg : \u2200 v : \u2200 i, E i, 0 \u2264 \u220f i, \u2016v i\u2016 := fun v =>\n    Finset.prod_nonneg fun i _ => norm_nonneg _\n  refine' Metric.complete_of_cauchySeq_tendsto fun f hf => _\n  rcases cauchySeq_iff_le_tendsto_0.1 hf with \u27e8b, b0, b_bound, b_lim\u27e9\n  have cau : \u2200 v, CauchySeq fun n => f n v := by\n    intro v\n    apply cauchySeq_iff_le_tendsto_0.2 \u27e8fun n => b n * \u220f i, \u2016v i\u2016, _, _, _\u27e9\n    \u00b7 intro\n      exact mul_nonneg (b0 _) (nonneg v)\n    \u00b7 intro n m N hn hm\n      rw [dist_eq_norm]\n      apply le_trans ((f n - f m).le_op_norm v) _\n      exact mul_le_mul_of_nonneg_right (b_bound n m N hn hm) (nonneg v)\n    \u00b7 simpa using b_lim.mul tendsto_const_nhds\n  choose F hF using fun v => cauchySeq_tendsto_of_complete (cau v)\n  let Fmult : MultilinearMap \ud835\udd5c E G :=\n    { toFun := F\n      map_add' := fun v i x y => by\n        skip\n        have A := hF (Function.update v i (x + y))\n        have B := (hF (Function.update v i x)).add (hF (Function.update v i y))\n        simp at A B\n        exact tendsto_nhds_unique A B\n      map_smul' := fun v i c x => by\n        skip\n        have A := hF (Function.update v i (c \u2022 x))\n        have B := Filter.Tendsto.smul (@tendsto_const_nhds _ \u2115 _ c _) (hF (Function.update v i x))\n        simp at A B\n        exact tendsto_nhds_unique A B }\n  have Fnorm : \u2200 v, \u2016F v\u2016 \u2264 (b 0 + \u2016f 0\u2016) * \u220f i, \u2016v i\u2016 := by\n    intro v\n    have A : \u2200 n, \u2016f n v\u2016 \u2264 (b 0 + \u2016f 0\u2016) * \u220f i, \u2016v i\u2016 := by\n      intro n\n      apply le_trans ((f n).le_op_norm _) _\n      apply mul_le_mul_of_nonneg_right _ (nonneg v)\n      calc\n        \u2016f n\u2016 = \u2016f n - f 0 + f 0\u2016 := by\n          congr 1\n          abel\n        _ \u2264 \u2016f n - f 0\u2016 + \u2016f 0\u2016 := (norm_add_le _ _)\n        _ \u2264 b 0 + \u2016f 0\u2016 := by\n          apply add_le_add_right\n          simpa [dist_eq_norm] using b_bound n 0 0 (zero_le _) (zero_le _)\n    exact le_of_tendsto (hF v).norm (eventually_of_forall A)\n  let Fcont := Fmult.mkContinuous _ Fnorm\n  use Fcont\n  have : \u2200 n, \u2016f n - Fcont\u2016 \u2264 b n := by\n    intro n\n    apply op_norm_le_bound _ (b0 n) fun v => ?_\n    have A : \u2200\u1da0 m in atTop, \u2016(f n - f m) v\u2016 \u2264 b n * \u220f i, \u2016v i\u2016 := by\n      refine' eventually_atTop.2 \u27e8n, fun m hm => _\u27e9\n      apply le_trans ((f n - f m).le_op_norm _) _\n      exact mul_le_mul_of_nonneg_right (b_bound n m n le_rfl hm) (nonneg v)\n    have B : Tendsto (fun m => \u2016(f n - f m) v\u2016) atTop (\ud835\udcdd \u2016(f n - Fcont) v\u2016) :=\n      Tendsto.norm (tendsto_const_nhds.sub (hF v))\n    exact le_of_tendsto B A\n  erw [tendsto_iff_norm_sub_tendsto_zero]\n  exact squeeze_zero (fun n => norm_nonneg _) this b_lim", "start": [691, 1], "end": [764, 57], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkContinuous_norm_le", "code": "theorem MultilinearMap.mkContinuous_norm_le (f : MultilinearMap \ud835\udd5c E G) {C : \u211d} (hC : 0 \u2264 C)\n    (H : \u2200 m, \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016) : \u2016f.mkContinuous C H\u2016 \u2264 C", "start": [767, 1], "end": [772, 62], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkContinuous_norm_le'", "code": "theorem MultilinearMap.mkContinuous_norm_le' (f : MultilinearMap \ud835\udd5c E G) {C : \u211d}\n    (H : \u2200 m, \u2016f m\u2016 \u2264 C * \u220f i, \u2016m i\u2016) : \u2016f.mkContinuous C H\u2016 \u2264 max C 0", "start": [775, 1], "end": [782, 90], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.restr", "code": "def restr {k n : \u2115} (f : (G[\u00d7n]\u2192L[\ud835\udd5c] G' : _)) (s : Finset (Fin n)) (hk : s.card = k) (z : G) :\n    G[\u00d7k]\u2192L[\ud835\udd5c] G' :=\n  (f.toMultilinearMap.restr s hk z).mkContinuous (\u2016f\u2016 * \u2016z\u2016 ^ (n - k)) fun _ =>\n    MultilinearMap.restr_norm_le _ _ _ _ f.le_op_norm _", "start": [787, 1], "end": [795, 56], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_restr", "code": "theorem norm_restr {k n : \u2115} (f : G[\u00d7n]\u2192L[\ud835\udd5c] G') (s : Finset (Fin n)) (hk : s.card = k) (z : G) :\n    \u2016f.restr s hk z\u2016 \u2264 \u2016f\u2016 * \u2016z\u2016 ^ (n - k)", "start": [798, 1], "end": [801, 66], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_mkPiAlgebra_le", "code": "@[simp]\ntheorem norm_mkPiAlgebra_le [Nonempty \u03b9] : \u2016ContinuousMultilinearMap.mkPiAlgebra \ud835\udd5c \u03b9 A\u2016 \u2264 1", "start": [808, 1], "end": [814, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_mkPiAlgebra_of_empty", "code": "theorem norm_mkPiAlgebra_of_empty [IsEmpty \u03b9] :\n    \u2016ContinuousMultilinearMap.mkPiAlgebra \ud835\udd5c \u03b9 A\u2016 = \u2016(1 : A)\u2016", "start": [817, 1], "end": [825, 49], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_mkPiAlgebra", "code": "@[simp]\ntheorem norm_mkPiAlgebra [NormOneClass A] : \u2016ContinuousMultilinearMap.mkPiAlgebra \ud835\udd5c \u03b9 A\u2016 = 1", "start": [828, 1], "end": [834, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_mkPiAlgebraFin_succ_le", "code": "theorem norm_mkPiAlgebraFin_succ_le : \u2016ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c n.succ A\u2016 \u2264 1", "start": [843, 1], "end": [853, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_mkPiAlgebraFin_le_of_pos", "code": "theorem norm_mkPiAlgebraFin_le_of_pos (hn : 0 < n) :\n    \u2016ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c n A\u2016 \u2264 1", "start": [856, 1], "end": [859, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_mkPiAlgebraFin_zero", "code": "theorem norm_mkPiAlgebraFin_zero : \u2016ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c 0 A\u2016 = \u2016(1 : A)\u2016", "start": [862, 1], "end": [869, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_mkPiAlgebraFin", "code": "@[simp]\ntheorem norm_mkPiAlgebraFin [NormOneClass A] :\n    \u2016ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c n A\u2016 = 1", "start": [872, 1], "end": [881, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.mkPiField", "code": "protected def mkPiField (z : G) : ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9 => \ud835\udd5c) G :=\n  MultilinearMap.mkContinuous (MultilinearMap.mkPiRing \ud835\udd5c \u03b9 z) \u2016z\u2016 fun m => by\n    simp only [MultilinearMap.mkPiRing_apply, norm_smul, norm_prod, mul_comm]\n    rfl", "start": [888, 1], "end": [893, 8], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.mkPiField_apply", "code": "@[simp]\ntheorem mkPiField_apply (z : G) (m : \u03b9 \u2192 \ud835\udd5c) :\n    (ContinuousMultilinearMap.mkPiField \ud835\udd5c \u03b9 z : (\u03b9 \u2192 \ud835\udd5c) \u2192 G) m = (\u220f i, m i) \u2022 z", "start": [898, 1], "end": [901, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.mkPiField_apply_one_eq_self", "code": "theorem mkPiField_apply_one_eq_self (f : ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9 => \ud835\udd5c) G) :\n    ContinuousMultilinearMap.mkPiField \ud835\udd5c \u03b9 (f fun _ => 1) = f", "start": [904, 1], "end": [906, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_mkPiField", "code": "@[simp]\ntheorem norm_mkPiField (z : G) : \u2016ContinuousMultilinearMap.mkPiField \ud835\udd5c \u03b9 z\u2016 = \u2016z\u2016", "start": [909, 1], "end": [912, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.mkPiField_eq_iff", "code": "theorem mkPiField_eq_iff {z\u2081 z\u2082 : G} :\n    ContinuousMultilinearMap.mkPiField \ud835\udd5c \u03b9 z\u2081 = ContinuousMultilinearMap.mkPiField \ud835\udd5c \u03b9 z\u2082 \u2194\n      z\u2081 = z\u2082", "start": [915, 1], "end": [919, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.mkPiField_zero", "code": "theorem mkPiField_zero : ContinuousMultilinearMap.mkPiField \ud835\udd5c \u03b9 (0 : G) = 0", "start": [922, 1], "end": [923, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.mkPiField_eq_zero_iff", "code": "theorem mkPiField_eq_zero_iff (z : G) : ContinuousMultilinearMap.mkPiField \ud835\udd5c \u03b9 z = 0 \u2194 z = 0", "start": [926, 1], "end": [927, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.piFieldEquiv", "code": "protected def piFieldEquiv : G \u2243\u2097\u1d62[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9 => \ud835\udd5c) G where\n  toFun z := ContinuousMultilinearMap.mkPiField \ud835\udd5c \u03b9 z\n  invFun f := f fun i => 1\n  map_add' z z' := by\n    ext m\n    simp [smul_add]\n  map_smul' c z := by\n    ext m\n    simp [smul_smul, mul_comm]\n  left_inv z := by simp\n  right_inv f := f.mkPiField_apply_one_eq_self\n  norm_map' := norm_mkPiField", "start": [932, 1], "end": [947, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_compContinuousMultilinearMap_le", "code": "theorem norm_compContinuousMultilinearMap_le (g : G \u2192L[\ud835\udd5c] G') (f : ContinuousMultilinearMap \ud835\udd5c E G) :\n    \u2016g.compContinuousMultilinearMap f\u2016 \u2264 \u2016g\u2016 * \u2016f\u2016", "start": [954, 1], "end": [959, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compContinuousMultilinearMapL", "code": "def compContinuousMultilinearMapL :\n    (G \u2192L[\ud835\udd5c] G') \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c E G \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c E G' :=\n  LinearMap.mkContinuous\u2082\n    (LinearMap.mk\u2082 \ud835\udd5c compContinuousMultilinearMap (fun f\u2081 f\u2082 g => rfl) (fun c f g => rfl)\n      (fun f g\u2081 g\u2082 => by\n        ext1\n        apply f.map_add)\n      fun c f g => by\n      ext1\n      simp)\n    1 fun f g => by\n    rw [one_mul]\n    exact f.norm_compContinuousMultilinearMap_le g", "start": [966, 1], "end": [979, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.compContinuousMultilinearMapL", "code": "nonrec\ndef _root_.ContinuousLinearEquiv.compContinuousMultilinearMapL (g : G \u2243L[\ud835\udd5c] G') :\n    ContinuousMultilinearMap \ud835\udd5c E G \u2243L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c E G' :=\n  { compContinuousMultilinearMapL \ud835\udd5c E G G'\n      g.toContinuousLinearMap with\n    invFun := compContinuousMultilinearMapL \ud835\udd5c E G' G g.symm.toContinuousLinearMap\n    left_inv := by\n      intro f\n      ext1 m\n      simp [compContinuousMultilinearMapL]\n    right_inv := by\n      intro f\n      ext1 m\n      simp [compContinuousMultilinearMapL]\n    continuous_toFun := (compContinuousMultilinearMapL \ud835\udd5c E G G' g.toContinuousLinearMap).continuous\n    continuous_invFun :=\n      (compContinuousMultilinearMapL \ud835\udd5c E G' G g.symm.toContinuousLinearMap).continuous }", "start": [984, 1], "end": [1002, 89], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.compContinuousMultilinearMapL_symm", "code": "@[simp]\ntheorem _root_.ContinuousLinearEquiv.compContinuousMultilinearMapL_symm (g : G \u2243L[\ud835\udd5c] G') :\n    (g.compContinuousMultilinearMapL E).symm = g.symm.compContinuousMultilinearMapL E", "start": [1005, 1], "end": [1008, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.compContinuousMultilinearMapL_apply", "code": "@[simp]\ntheorem _root_.ContinuousLinearEquiv.compContinuousMultilinearMapL_apply (g : G \u2243L[\ud835\udd5c] G')\n    (f : ContinuousMultilinearMap \ud835\udd5c E G) :\n    g.compContinuousMultilinearMapL E f = (g : G \u2192L[\ud835\udd5c] G').compContinuousMultilinearMap f", "start": [1013, 1], "end": [1017, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.flipMultilinear", "code": "@[simps! apply_apply]\ndef flipMultilinear (f : G \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c E G') :\n    ContinuousMultilinearMap \ud835\udd5c E (G \u2192L[\ud835\udd5c] G') :=\n  MultilinearMap.mkContinuous\n    { toFun := fun m =>\n        LinearMap.mkContinuous\n          { toFun := fun x => f x m\n            map_add' := fun x y => by simp only [map_add, ContinuousMultilinearMap.add_apply]\n            map_smul' := fun c x => by\n              simp only [ContinuousMultilinearMap.smul_apply, map_smul, RingHom.id_apply] }\n          (\u2016f\u2016 * \u220f i, \u2016m i\u2016) fun x => by\n          rw [mul_right_comm]\n          exact (f x).le_of_op_norm_le _ (f.le_op_norm x)\n      map_add' := fun m i x y => by\n        ext1\n        simp only [add_apply, ContinuousMultilinearMap.map_add, LinearMap.coe_mk,\n          LinearMap.mkContinuous_apply, AddHom.coe_mk]\n      map_smul' := fun m i c x => by\n        ext1\n        simp only [coe_smul', ContinuousMultilinearMap.map_smul, LinearMap.coe_mk,\n          LinearMap.mkContinuous_apply, Pi.smul_apply, AddHom.coe_mk] }\n    \u2016f\u2016 fun m => by\n      dsimp only [MultilinearMap.coe_mk]\n      refine LinearMap.mkContinuous_norm_le _\n        (mul_nonneg (norm_nonneg f) (prod_nonneg fun i _ => norm_nonneg (m i))) _", "start": [1020, 1], "end": [1046, 82], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.norm_compContinuousMultilinearMap", "code": "theorem LinearIsometry.norm_compContinuousMultilinearMap (g : G \u2192\u2097\u1d62[\ud835\udd5c] G')\n    (f : ContinuousMultilinearMap \ud835\udd5c E G) :\n    \u2016g.toContinuousLinearMap.compContinuousMultilinearMap f\u2016 = \u2016f\u2016", "start": [1052, 1], "end": [1057, 60], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkContinuousLinear", "code": "def mkContinuousLinear (f : G \u2192\u2097[\ud835\udd5c] MultilinearMap \ud835\udd5c E G') (C : \u211d)\n    (H : \u2200 x m, \u2016f x m\u2016 \u2264 C * \u2016x\u2016 * \u220f i, \u2016m i\u2016) : G \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c E G' :=\n  LinearMap.mkContinuous\n    { toFun := fun x => (f x).mkContinuous (C * \u2016x\u2016) <| H x\n      map_add' := fun x y => by\n        ext1\n        simp only [_root_.map_add]\n        rfl\n      map_smul' := fun c x => by\n        ext1\n        simp only [SMulHomClass.map_smul]\n        rfl }\n    (max C 0) fun x => by\n      rw [LinearMap.coe_mk, AddHom.coe_mk] exact ((f x).mkContinuous_norm_le' _).trans_eq <| by\n        rw [max_mul_of_nonneg _ _ (norm_nonneg x), zero_mul]", "start": [1064, 1], "end": [1087, 61], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkContinuousLinear_norm_le'", "code": "theorem mkContinuousLinear_norm_le' (f : G \u2192\u2097[\ud835\udd5c] MultilinearMap \ud835\udd5c E G') (C : \u211d)\n    (H : \u2200 x m, \u2016f x m\u2016 \u2264 C * \u2016x\u2016 * \u220f i, \u2016m i\u2016) : \u2016mkContinuousLinear f C H\u2016 \u2264 max C 0", "start": [1090, 1], "end": [1093, 62], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkContinuousLinear_norm_le", "code": "theorem mkContinuousLinear_norm_le (f : G \u2192\u2097[\ud835\udd5c] MultilinearMap \ud835\udd5c E G') {C : \u211d} (hC : 0 \u2264 C)\n    (H : \u2200 x m, \u2016f x m\u2016 \u2264 C * \u2016x\u2016 * \u220f i, \u2016m i\u2016) : \u2016mkContinuousLinear f C H\u2016 \u2264 C", "start": [1096, 1], "end": [1098, 64], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkContinuousMultilinear", "code": "def mkContinuousMultilinear (f : MultilinearMap \ud835\udd5c E (MultilinearMap \ud835\udd5c E' G)) (C : \u211d)\n    (H : \u2200 m\u2081 m\u2082, \u2016f m\u2081 m\u2082\u2016 \u2264 (C * \u220f i, \u2016m\u2081 i\u2016) * \u220f i, \u2016m\u2082 i\u2016) :\n    ContinuousMultilinearMap \ud835\udd5c E (ContinuousMultilinearMap \ud835\udd5c E' G) :=\n  mkContinuous\n    { toFun := fun m => mkContinuous (f m) (C * \u220f i, \u2016m i\u2016) <| H m\n      map_add' := fun m i x y => by\n        ext1\n        simp\n      map_smul' := fun m i c x => by\n        ext1\n        simp }\n    (max C 0) fun m => by\n      simp only [coe_mk]\n      refine ((f m).mkContinuous_norm_le' _).trans_eq ?_\n      rw [max_mul_of_nonneg, zero_mul]\n      exact prod_nonneg fun _ _ => norm_nonneg _", "start": [1101, 1], "end": [1119, 49], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkContinuousMultilinear_apply", "code": "@[simp]\ntheorem mkContinuousMultilinear_apply (f : MultilinearMap \ud835\udd5c E (MultilinearMap \ud835\udd5c E' G)) {C : \u211d}\n    (H : \u2200 m\u2081 m\u2082, \u2016f m\u2081 m\u2082\u2016 \u2264 (C * \u220f i, \u2016m\u2081 i\u2016) * \u220f i, \u2016m\u2082 i\u2016) (m : \u2200 i, E i) :\n    \u21d1(mkContinuousMultilinear f C H m) = f m", "start": [1122, 1], "end": [1126, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkContinuousMultilinear_norm_le'", "code": "theorem mkContinuousMultilinear_norm_le' (f : MultilinearMap \ud835\udd5c E (MultilinearMap \ud835\udd5c E' G)) (C : \u211d)\n    (H : \u2200 m\u2081 m\u2082, \u2016f m\u2081 m\u2082\u2016 \u2264 (C * \u220f i, \u2016m\u2081 i\u2016) * \u220f i, \u2016m\u2082 i\u2016) :\n    \u2016mkContinuousMultilinear f C H\u2016 \u2264 max C 0", "start": [1129, 1], "end": [1133, 52], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkContinuousMultilinear_norm_le", "code": "theorem mkContinuousMultilinear_norm_le (f : MultilinearMap \ud835\udd5c E (MultilinearMap \ud835\udd5c E' G)) {C : \u211d}\n    (hC : 0 \u2264 C) (H : \u2200 m\u2081 m\u2082, \u2016f m\u2081 m\u2082\u2016 \u2264 (C * \u220f i, \u2016m\u2081 i\u2016) * \u220f i, \u2016m\u2082 i\u2016) :\n    \u2016mkContinuousMultilinear f C H\u2016 \u2264 C", "start": [1136, 1], "end": [1139, 69], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_compContinuousLinearMap_le", "code": "theorem norm_compContinuousLinearMap_le (g : ContinuousMultilinearMap \ud835\udd5c E\u2081 G)\n    (f : \u2200 i, E i \u2192L[\ud835\udd5c] E\u2081 i) : \u2016g.compContinuousLinearMap f\u2016 \u2264 \u2016g\u2016 * \u220f i, \u2016f i\u2016", "start": [1148, 1], "end": [1157, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_compContinuous_linearIsometry_le", "code": "theorem norm_compContinuous_linearIsometry_le (g : ContinuousMultilinearMap \ud835\udd5c E\u2081 G)\n    (f : \u2200 i, E i \u2192\u2097\u1d62[\ud835\udd5c] E\u2081 i) :\n    \u2016g.compContinuousLinearMap fun i => (f i).toContinuousLinearMap\u2016 \u2264 \u2016g\u2016", "start": [1160, 1], "end": [1166, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_compContinuous_linearIsometryEquiv", "code": "theorem norm_compContinuous_linearIsometryEquiv (g : ContinuousMultilinearMap \ud835\udd5c E\u2081 G)\n    (f : \u2200 i, E i \u2243\u2097\u1d62[\ud835\udd5c] E\u2081 i) :\n    \u2016g.compContinuousLinearMap fun i => (f i : E i \u2192L[\ud835\udd5c] E\u2081 i)\u2016 = \u2016g\u2016", "start": [1169, 1], "end": [1181, 43], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.compContinuousLinearMapL", "code": "def compContinuousLinearMapL (f : \u2200 i, E i \u2192L[\ud835\udd5c] E\u2081 i) :\n    ContinuousMultilinearMap \ud835\udd5c E\u2081 G \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c E G :=\n  LinearMap.mkContinuous\n    { toFun := fun g => g.compContinuousLinearMap f\n      map_add' := fun _ _ => rfl\n      map_smul' := fun _ _ => rfl } (\u220f i, \u2016f i\u2016) fun _ =>\n    (norm_compContinuousLinearMap_le _ _).trans_eq (mul_comm _ _)", "start": [1184, 1], "end": [1195, 66], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.compContinuousLinearMapL_apply", "code": "@[simp]\ntheorem compContinuousLinearMapL_apply (g : ContinuousMultilinearMap \ud835\udd5c E\u2081 G)\n    (f : \u2200 i, E i \u2192L[\ud835\udd5c] E\u2081 i) : compContinuousLinearMapL f g = g.compContinuousLinearMap f", "start": [1198, 1], "end": [1201, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_compContinuousLinearMapL_le", "code": "theorem norm_compContinuousLinearMapL_le (f : \u2200 i, E i \u2192L[\ud835\udd5c] E\u2081 i) :\n    \u2016@compContinuousLinearMapL \ud835\udd5c \u03b9 E E\u2081 G _ _ _ _ _ _ _ _ f\u2016 \u2264 \u220f i, \u2016f i\u2016", "start": [1204, 1], "end": [1206, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.compContinuousLinearMapEquivL", "code": "def compContinuousLinearMapEquivL (f : \u2200 i, E i \u2243L[\ud835\udd5c] E\u2081 i) :\n    ContinuousMultilinearMap \ud835\udd5c E\u2081 G \u2243L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c E G :=\n  { compContinuousLinearMapL fun i => (f i : E i \u2192L[\ud835\udd5c] E\u2081 i) with\n    invFun := compContinuousLinearMapL fun i => ((f i).symm : E\u2081 i \u2192L[\ud835\udd5c] E i)\n    continuous_toFun := (compContinuousLinearMapL fun i => (f i : E i \u2192L[\ud835\udd5c] E\u2081 i)).continuous\n    continuous_invFun :=\n      (compContinuousLinearMapL fun i => ((f i).symm : E\u2081 i \u2192L[\ud835\udd5c] E i)).continuous\n    left_inv := by\n      intro g\n      ext1 m\n      simp only [LinearMap.toFun_eq_coe, ContinuousLinearMap.coe_coe,\n        compContinuousLinearMapL_apply, compContinuousLinearMap_apply,\n        ContinuousLinearEquiv.coe_coe, ContinuousLinearEquiv.apply_symm_apply]\n    right_inv := by\n      intro g\n      ext1 m\n      simp only [compContinuousLinearMapL_apply, LinearMap.toFun_eq_coe,\n        ContinuousLinearMap.coe_coe, compContinuousLinearMap_apply,\n        ContinuousLinearEquiv.coe_coe, ContinuousLinearEquiv.symm_apply_apply] }", "start": [1211, 1], "end": [1231, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.compContinuousLinearMapEquivL_symm", "code": "@[simp]\ntheorem compContinuousLinearMapEquivL_symm (f : \u2200 i, E i \u2243L[\ud835\udd5c] E\u2081 i) :\n    (compContinuousLinearMapEquivL G f).symm =\n      compContinuousLinearMapEquivL G fun i : \u03b9 => (f i).symm", "start": [1234, 1], "end": [1238, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.compContinuousLinearMapEquivL_apply", "code": "@[simp]\ntheorem compContinuousLinearMapEquivL_apply (g : ContinuousMultilinearMap \ud835\udd5c E\u2081 G)\n    (f : \u2200 i, E i \u2243L[\ud835\udd5c] E\u2081 i) :\n    compContinuousLinearMapEquivL G f g =\n      g.compContinuousLinearMap fun i => (f i : E i \u2192L[\ud835\udd5c] E\u2081 i)", "start": [1243, 1], "end": [1248, 6], "kind": "commanddeclaration"}, {"full_name": "continuousConstSMul", "code": "instance continuousConstSMul : ContinuousConstSMul R (ContinuousMultilinearMap \ud835\udd5c E G) :=\n  \u27e8fun c =>\n    (ContinuousLinearMap.compContinuousMultilinearMapL \ud835\udd5c _ G G (c \u2022 ContinuousLinearMap.id \ud835\udd5c G)).2\u27e9", "start": [1257, 1], "end": [1259, 100], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_map_tail_le", "code": "theorem ContinuousLinearMap.norm_map_tail_le\n    (f : Ei 0 \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei i.succ) G) (m : \u2200 i, Ei i) :\n    \u2016f (m 0) (tail m)\u2016 \u2264 \u2016f\u2016 * \u220f i, \u2016m i\u2016", "start": [1281, 1], "end": [1291, 10], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_map_init_le", "code": "theorem ContinuousMultilinearMap.norm_map_init_le\n    (f : ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei <| castSucc i) (Ei (last n) \u2192L[\ud835\udd5c] G))\n    (m : \u2200 i, Ei i) : \u2016f (init m) (m (last n))\u2016 \u2264 \u2016f\u2016 * \u220f i, \u2016m i\u2016", "start": [1294, 1], "end": [1304, 10], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_map_cons_le", "code": "theorem ContinuousMultilinearMap.norm_map_cons_le (f : ContinuousMultilinearMap \ud835\udd5c Ei G) (x : Ei 0)\n    (m : \u2200 i : Fin n, Ei i.succ) : \u2016f (cons x m)\u2016 \u2264 \u2016f\u2016 * \u2016x\u2016 * \u220f i, \u2016m i\u2016", "start": [1307, 1], "end": [1313, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_map_snoc_le", "code": "theorem ContinuousMultilinearMap.norm_map_snoc_le (f : ContinuousMultilinearMap \ud835\udd5c Ei G)\n    (m : \u2200 i : Fin n, Ei <| castSucc i) (x : Ei (last n)) :\n    \u2016f (snoc m x)\u2016 \u2264 (\u2016f\u2016 * \u220f i, \u2016m i\u2016) * \u2016x\u2016", "start": [1316, 1], "end": [1323, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.uncurryLeft", "code": "def ContinuousLinearMap.uncurryLeft\n    (f : Ei 0 \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei i.succ) G) :\n    ContinuousMultilinearMap \ud835\udd5c Ei G :=\n  (@LinearMap.uncurryLeft \ud835\udd5c n Ei G _ _ _ _ _\n      (ContinuousMultilinearMap.toMultilinearMapLinear.comp f.toLinearMap)).mkContinuous\n    \u2016f\u2016 fun m => by exact ContinuousLinearMap.norm_map_tail_le f m", "start": [1329, 1], "end": [1337, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.uncurryLeft_apply", "code": "@[simp]\ntheorem ContinuousLinearMap.uncurryLeft_apply\n    (f : Ei 0 \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei i.succ) G) (m : \u2200 i, Ei i) :\n    f.uncurryLeft m = f (m 0) (tail m)", "start": [1340, 1], "end": [1344, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curryLeft", "code": "def ContinuousMultilinearMap.curryLeft (f : ContinuousMultilinearMap \ud835\udd5c Ei G) :\n    Ei 0 \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei i.succ) G :=\n  LinearMap.mkContinuous\n    { toFun := fun x =>\n        (f.toMultilinearMap.curryLeft x).mkContinuous (\u2016f\u2016 * \u2016x\u2016) (f.norm_map_cons_le x)\n      map_add' := fun x y => by\n        ext m\n        exact f.cons_add m x y\n      map_smul' := fun c x => by\n        ext m\n        exact\n          f.cons_smul m c x }\u2016f\u2016 fun x => by\n      rw [LinearMap.coe_mk, AddHom.coe_mk]\n      exact MultilinearMap.mkContinuous_norm_le _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) _", "start": [1347, 1], "end": [1366, 97], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curryLeft_apply", "code": "@[simp]\ntheorem ContinuousMultilinearMap.curryLeft_apply (f : ContinuousMultilinearMap \ud835\udd5c Ei G) (x : Ei 0)\n    (m : \u2200 i : Fin n, Ei i.succ) : f.curryLeft x m = f (cons x m)", "start": [1369, 1], "end": [1372, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.curry_uncurryLeft", "code": "@[simp]\ntheorem ContinuousLinearMap.curry_uncurryLeft\n    (f : Ei 0 \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei i.succ) G) :\n    f.uncurryLeft.curryLeft = f", "start": [1375, 1], "end": [1382, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.uncurry_curryLeft", "code": "@[simp]\ntheorem ContinuousMultilinearMap.uncurry_curryLeft (f : ContinuousMultilinearMap \ud835\udd5c Ei G) :\n    f.curryLeft.uncurryLeft = f", "start": [1385, 1], "end": [1388, 94], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryLeftEquiv", "code": "def continuousMultilinearCurryLeftEquiv :\n    (Ei 0 \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei i.succ) G) \u2243\u2097\u1d62[\ud835\udd5c]\n      ContinuousMultilinearMap \ud835\udd5c Ei G :=\n  LinearIsometryEquiv.ofBounds\n    { toFun := ContinuousLinearMap.uncurryLeft\n      map_add' := fun f\u2081 f\u2082 => by\n        ext m\n        rfl\n      map_smul' := fun c f => by\n        ext m\n        rfl\n      invFun := ContinuousMultilinearMap.curryLeft\n      left_inv := ContinuousLinearMap.curry_uncurryLeft\n      right_inv := ContinuousMultilinearMap.uncurry_curryLeft } (fun f => by\n        simp only [LinearEquiv.coe_mk]\n        exact MultilinearMap.mkContinuous_norm_le _ (norm_nonneg f) _) fun f => by\n          simp only [LinearEquiv.coe_symm_mk]\n          exact LinearMap.mkContinuous_norm_le _ (norm_nonneg f) _", "start": [1393, 1], "end": [1418, 67], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryLeftEquiv_apply", "code": "@[simp]\ntheorem continuousMultilinearCurryLeftEquiv_apply\n    (f : Ei 0 \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei i.succ) G) (v : \u2200 i, Ei i) :\n    continuousMultilinearCurryLeftEquiv \ud835\udd5c Ei G f v = f (v 0) (tail v)", "start": [1423, 1], "end": [1427, 6], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryLeftEquiv_symm_apply", "code": "@[simp]\ntheorem continuousMultilinearCurryLeftEquiv_symm_apply (f : ContinuousMultilinearMap \ud835\udd5c Ei G)\n    (x : Ei 0) (v : \u2200 i : Fin n, Ei i.succ) :\n    (continuousMultilinearCurryLeftEquiv \ud835\udd5c Ei G).symm f x v = f (cons x v)", "start": [1430, 1], "end": [1434, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curryLeft_norm", "code": "@[simp]\ntheorem ContinuousMultilinearMap.curryLeft_norm (f : ContinuousMultilinearMap \ud835\udd5c Ei G) :\n    \u2016f.curryLeft\u2016 = \u2016f\u2016", "start": [1437, 1], "end": [1440, 63], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.uncurryLeft_norm", "code": "@[simp]\ntheorem ContinuousLinearMap.uncurryLeft_norm\n    (f : Ei 0 \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei i.succ) G) :\n    \u2016f.uncurryLeft\u2016 = \u2016f\u2016", "start": [1443, 1], "end": [1447, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.uncurryRight", "code": "def ContinuousMultilinearMap.uncurryRight\n    (f : ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei <| castSucc i) (Ei (last n) \u2192L[\ud835\udd5c] G)) :\n    ContinuousMultilinearMap \ud835\udd5c Ei G :=\n  let f' : MultilinearMap \ud835\udd5c (fun i : Fin n => Ei <| castSucc i) (Ei (last n) \u2192\u2097[\ud835\udd5c] G) :=\n    { toFun := fun m => (f m).toLinearMap\n      map_add' := fun m i x y => by simp\n      map_smul' := fun m i c x => by simp }\n  (@MultilinearMap.uncurryRight \ud835\udd5c n Ei G _ _ _ _ _ f').mkContinuous \u2016f\u2016 fun m =>\n    f.norm_map_init_le m", "start": [1453, 1], "end": [1464, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.uncurryRight_apply", "code": "@[simp]\ntheorem ContinuousMultilinearMap.uncurryRight_apply\n    (f : ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei <| castSucc i) (Ei (last n) \u2192L[\ud835\udd5c] G))\n    (m : \u2200 i, Ei i) : f.uncurryRight m = f (init m) (m (last n))", "start": [1467, 1], "end": [1471, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curryRight", "code": "def ContinuousMultilinearMap.curryRight (f : ContinuousMultilinearMap \ud835\udd5c Ei G) :\n    ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei <| castSucc i) (Ei (last n) \u2192L[\ud835\udd5c] G) :=\n  let f' : MultilinearMap \ud835\udd5c (fun i : Fin n => Ei <| castSucc i) (Ei (last n) \u2192L[\ud835\udd5c] G) :=\n    { toFun := fun m =>\n        (f.toMultilinearMap.curryRight m).mkContinuous (\u2016f\u2016 * \u220f i, \u2016m i\u2016) fun x =>\n          f.norm_map_snoc_le m x\n      map_add' := fun m i x y => by\n        simp\n        rfl\n      map_smul' := fun m i c x => by\n        simp\n        rfl }\n  f'.mkContinuous \u2016f\u2016 fun m => by\n    simp only [MultilinearMap.coe_mk]\n    exact LinearMap.mkContinuous_norm_le _\n      (mul_nonneg (norm_nonneg _) (prod_nonneg fun _ _ => norm_nonneg _)) _", "start": [1474, 1], "end": [1492, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curryRight_apply", "code": "@[simp]\ntheorem ContinuousMultilinearMap.curryRight_apply (f : ContinuousMultilinearMap \ud835\udd5c Ei G)\n    (m : \u2200 i : Fin n, Ei <| castSucc i) (x : Ei (last n)) : f.curryRight m x = f (snoc m x)", "start": [1495, 1], "end": [1498, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curry_uncurryRight", "code": "@[simp]\ntheorem ContinuousMultilinearMap.curry_uncurryRight\n    (f : ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei <| castSucc i) (Ei (last n) \u2192L[\ud835\udd5c] G)) :\n    f.uncurryRight.curryRight = f", "start": [1501, 1], "end": [1508, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.uncurry_curryRight", "code": "@[simp]\ntheorem ContinuousMultilinearMap.uncurry_curryRight (f : ContinuousMultilinearMap \ud835\udd5c Ei G) :\n    f.curryRight.uncurryRight = f", "start": [1511, 1], "end": [1515, 7], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryRightEquiv", "code": "def continuousMultilinearCurryRightEquiv :\n    ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei <| castSucc i) (Ei (last n) \u2192L[\ud835\udd5c] G) \u2243\u2097\u1d62[\ud835\udd5c]\n      ContinuousMultilinearMap \ud835\udd5c Ei G :=\n  LinearIsometryEquiv.ofBounds\n    { toFun := ContinuousMultilinearMap.uncurryRight\n      map_add' := fun f\u2081 f\u2082 => by\n        ext m\n        rfl\n      map_smul' := fun c f => by\n        ext m\n        rfl\n      invFun := ContinuousMultilinearMap.curryRight\n      left_inv := ContinuousMultilinearMap.curry_uncurryRight\n      right_inv := ContinuousMultilinearMap.uncurry_curryRight } (fun f => by\n        simp only [uncurryRight, LinearEquiv.coe_mk]\n        exact MultilinearMap.mkContinuous_norm_le _ (norm_nonneg f) _) fun f => by\n          simp only [curryRight, LinearEquiv.coe_symm_mk]\n          exact MultilinearMap.mkContinuous_norm_le _ (norm_nonneg f) _", "start": [1520, 1], "end": [1547, 72], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryRightEquiv'", "code": "def continuousMultilinearCurryRightEquiv' : (G[\u00d7n]\u2192L[\ud835\udd5c] G \u2192L[\ud835\udd5c] G') \u2243\u2097\u1d62[\ud835\udd5c] G[\u00d7n.succ]\u2192L[\ud835\udd5c] G' :=\n  continuousMultilinearCurryRightEquiv \ud835\udd5c (fun _ => G) G'", "start": [1552, 1], "end": [1562, 57], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryRightEquiv_apply", "code": "@[simp]\ntheorem continuousMultilinearCurryRightEquiv_apply\n    (f : ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei <| castSucc i) (Ei (last n) \u2192L[\ud835\udd5c] G))\n    (v : \u2200 i, Ei i) : (continuousMultilinearCurryRightEquiv \ud835\udd5c Ei G) f v = f (init v) (v (last n))", "start": [1567, 1], "end": [1571, 6], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryRightEquiv_symm_apply", "code": "@[simp]\ntheorem continuousMultilinearCurryRightEquiv_symm_apply (f : ContinuousMultilinearMap \ud835\udd5c Ei G)\n    (v : \u2200 i : Fin n, Ei <| castSucc i) (x : Ei (last n)) :\n    (continuousMultilinearCurryRightEquiv \ud835\udd5c Ei G).symm f v x = f (snoc v x)", "start": [1574, 1], "end": [1578, 6], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryRightEquiv_apply'", "code": "@[simp]\ntheorem continuousMultilinearCurryRightEquiv_apply' (f : G[\u00d7n]\u2192L[\ud835\udd5c] G \u2192L[\ud835\udd5c] G')\n    (v : Fin (n + 1) \u2192 G) :\n    continuousMultilinearCurryRightEquiv' \ud835\udd5c n G G' f v = f (init v) (v (last n))", "start": [1581, 1], "end": [1585, 6], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryRightEquiv_symm_apply'", "code": "@[simp]\ntheorem continuousMultilinearCurryRightEquiv_symm_apply' (f : G[\u00d7n.succ]\u2192L[\ud835\udd5c] G')\n    (v : Fin n \u2192 G) (x : G) :\n    (continuousMultilinearCurryRightEquiv' \ud835\udd5c n G G').symm f v x = f (snoc v x)", "start": [1588, 1], "end": [1592, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curryRight_norm", "code": "@[simp]\ntheorem ContinuousMultilinearMap.curryRight_norm (f : ContinuousMultilinearMap \ud835\udd5c Ei G) :\n    \u2016f.curryRight\u2016 = \u2016f\u2016", "start": [1595, 1], "end": [1598, 64], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.uncurryRight_norm", "code": "@[simp]\ntheorem ContinuousMultilinearMap.uncurryRight_norm\n    (f : ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei <| castSucc i) (Ei (last n) \u2192L[\ud835\udd5c] G)) :\n    \u2016f.uncurryRight\u2016 = \u2016f\u2016", "start": [1601, 1], "end": [1605, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.uncurry0", "code": "def ContinuousMultilinearMap.uncurry0 (f : ContinuousMultilinearMap \ud835\udd5c (fun _ : Fin 0 => G) G') :\n    G' :=\n  f 0", "start": [1620, 1], "end": [1623, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curry0", "code": "def ContinuousMultilinearMap.curry0 (x : G') : G[\u00d70]\u2192L[\ud835\udd5c] G' :=\n  ContinuousMultilinearMap.constOfIsEmpty \ud835\udd5c _ x", "start": [1628, 1], "end": [1631, 48], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curry0_apply", "code": "@[simp]\ntheorem ContinuousMultilinearMap.curry0_apply (x : G') (m : Fin 0 \u2192 G) :\n    ContinuousMultilinearMap.curry0 \ud835\udd5c G x m = x", "start": [1636, 1], "end": [1639, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.uncurry0_apply", "code": "@[simp]\ntheorem ContinuousMultilinearMap.uncurry0_apply (f : G[\u00d70]\u2192L[\ud835\udd5c] G') : f.uncurry0 = f 0", "start": [1644, 1], "end": [1646, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.apply_zero_curry0", "code": "@[simp]\ntheorem ContinuousMultilinearMap.apply_zero_curry0 (f : G[\u00d70]\u2192L[\ud835\udd5c] G') {x : Fin 0 \u2192 G} :\n    ContinuousMultilinearMap.curry0 \ud835\udd5c G (f x) = f", "start": [1649, 1], "end": [1653, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.uncurry0_curry0", "code": "theorem ContinuousMultilinearMap.uncurry0_curry0 (f : G[\u00d70]\u2192L[\ud835\udd5c] G') :\n    ContinuousMultilinearMap.curry0 \ud835\udd5c G f.uncurry0 = f", "start": [1656, 1], "end": [1657, 66], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curry0_uncurry0", "code": "theorem ContinuousMultilinearMap.curry0_uncurry0 (x : G') :\n    (ContinuousMultilinearMap.curry0 \ud835\udd5c G x).uncurry0 = x", "start": [1662, 1], "end": [1664, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curry0_norm", "code": "@[simp]\ntheorem ContinuousMultilinearMap.curry0_norm (x : G') :\n    \u2016ContinuousMultilinearMap.curry0 \ud835\udd5c G x\u2016 = \u2016x\u2016", "start": [1667, 1], "end": [1670, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.fin0_apply_norm", "code": "@[simp]\ntheorem ContinuousMultilinearMap.fin0_apply_norm (f : G[\u00d70]\u2192L[\ud835\udd5c] G') {x : Fin 0 \u2192 G} :\n    \u2016f x\u2016 = \u2016f\u2016", "start": [1675, 1], "end": [1683, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.uncurry0_norm", "code": "theorem ContinuousMultilinearMap.uncurry0_norm (f : G[\u00d70]\u2192L[\ud835\udd5c] G') : \u2016f.uncurry0\u2016 = \u2016f\u2016", "start": [1686, 1], "end": [1686, 99], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryFin0", "code": "def continuousMultilinearCurryFin0 : (G[\u00d70]\u2192L[\ud835\udd5c] G') \u2243\u2097\u1d62[\ud835\udd5c] G' where\n  toFun f := ContinuousMultilinearMap.uncurry0 f\n  invFun f := ContinuousMultilinearMap.curry0 \ud835\udd5c G f\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  left_inv := ContinuousMultilinearMap.uncurry0_curry0\n  right_inv := ContinuousMultilinearMap.curry0_uncurry0 \ud835\udd5c G\n  norm_map' := ContinuousMultilinearMap.uncurry0_norm", "start": [1691, 1], "end": [1703, 54], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryFin0_apply", "code": "@[simp]\ntheorem continuousMultilinearCurryFin0_apply (f : G[\u00d70]\u2192L[\ud835\udd5c] G') :\n    continuousMultilinearCurryFin0 \ud835\udd5c G G' f = f 0", "start": [1708, 1], "end": [1711, 6], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryFin0_symm_apply", "code": "@[simp]\ntheorem continuousMultilinearCurryFin0_symm_apply (x : G') (v : Fin 0 \u2192 G) :\n    (continuousMultilinearCurryFin0 \ud835\udd5c G G').symm x v = x", "start": [1714, 1], "end": [1717, 6], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryFin1", "code": "def continuousMultilinearCurryFin1 : (G[\u00d71]\u2192L[\ud835\udd5c] G') \u2243\u2097\u1d62[\ud835\udd5c] G \u2192L[\ud835\udd5c] G' :=\n  (continuousMultilinearCurryRightEquiv \ud835\udd5c (fun _ : Fin 1 => G) G').symm.trans\n    (continuousMultilinearCurryFin0 \ud835\udd5c G (G \u2192L[\ud835\udd5c] G'))", "start": [1727, 1], "end": [1731, 54], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryFin1_apply", "code": "@[simp]\ntheorem continuousMultilinearCurryFin1_apply (f : G[\u00d71]\u2192L[\ud835\udd5c] G') (x : G) :\n    continuousMultilinearCurryFin1 \ud835\udd5c G G' f x = f (Fin.snoc 0 x)", "start": [1736, 1], "end": [1739, 6], "kind": "commanddeclaration"}, {"full_name": "continuousMultilinearCurryFin1_symm_apply", "code": "@[simp]\ntheorem continuousMultilinearCurryFin1_symm_apply (f : G \u2192L[\ud835\udd5c] G') (v : Fin 1 \u2192 G) :\n    (continuousMultilinearCurryFin1 \ud835\udd5c G G').symm f v = f (v 0)", "start": [1742, 1], "end": [1745, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.norm_domDomCongr", "code": "@[simp]\ntheorem norm_domDomCongr (\u03c3 : \u03b9 \u2243 \u03b9') (f : ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9 => G) G') :\n    \u2016domDomCongr \u03c3 f\u2016 = \u2016f\u2016", "start": [1752, 1], "end": [1757, 74], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.domDomCongr\u2097\u1d62", "code": "def domDomCongr\u2097\u1d62 (\u03c3 : \u03b9 \u2243 \u03b9') :\n    ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9 => G) G' \u2243\u2097\u1d62[\ud835\udd5c]\n      ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9' => G) G' :=\n  { domDomCongrEquiv \u03c3 with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl\n    norm_map' := norm_domDomCongr \ud835\udd5c G G' \u03c3 }", "start": [1760, 1], "end": [1768, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.currySum", "code": "def currySum (f : ContinuousMultilinearMap \ud835\udd5c (fun _ : Sum \u03b9 \u03b9' => G) G') :\n    ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9 => G) (ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9' => G) G') :=\n  MultilinearMap.mkContinuousMultilinear (MultilinearMap.currySum f.toMultilinearMap) \u2016f\u2016\n    fun m m' => by simpa [Fintype.prod_sum_type, mul_assoc] using f.le_op_norm (Sum.elim m m')", "start": [1775, 1], "end": [1781, 95], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.currySum_apply", "code": "@[simp]\ntheorem currySum_apply (f : ContinuousMultilinearMap \ud835\udd5c (fun _ : Sum \u03b9 \u03b9' => G) G') (m : \u03b9 \u2192 G)\n    (m' : \u03b9' \u2192 G) : f.currySum m m' = f (Sum.elim m m')", "start": [1784, 1], "end": [1787, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.uncurrySum", "code": "def uncurrySum (f : ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9 => G)\n    (ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9' => G) G')) :\n    ContinuousMultilinearMap \ud835\udd5c (fun _ : Sum \u03b9 \u03b9' => G) G' :=\n  MultilinearMap.mkContinuous\n    (toMultilinearMapLinear.compMultilinearMap f.toMultilinearMap).uncurrySum \u2016f\u2016 fun m => by\n    simpa [Fintype.prod_sum_type, mul_assoc] using\n      (f (m \u2218 Sum.inl)).le_of_op_norm_le (m \u2218 Sum.inr) (f.le_op_norm _)", "start": [1790, 1], "end": [1799, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.uncurrySum_apply", "code": "@[simp]\ntheorem uncurrySum_apply (f : ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9 => G)\n    (ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9' => G) G'))\n    (m : Sum \u03b9 \u03b9' \u2192 G) : f.uncurrySum m = f (m \u2218 Sum.inl) (m \u2218 Sum.inr)", "start": [1802, 1], "end": [1806, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.currySumEquiv", "code": "def currySumEquiv : ContinuousMultilinearMap \ud835\udd5c (fun _ : Sum \u03b9 \u03b9' => G) G' \u2243\u2097\u1d62[\ud835\udd5c]\n    ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9 => G) (ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9' => G) G') :=\n  LinearIsometryEquiv.ofBounds\n    { toFun := currySum\n      invFun := uncurrySum\n      map_add' := fun f g => by\n        ext\n        rfl\n      map_smul' := fun c f => by\n        ext\n        rfl\n      left_inv := fun f => by\n        ext m\n        exact congr_arg f (Sum.elim_comp_inl_inr m)\n      right_inv := fun f => by\n        ext m\u2081 m\u2082\n        rfl }\n    (fun f => MultilinearMap.mkContinuousMultilinear_norm_le _ (norm_nonneg f) _) fun f => by\n      simp only [LinearEquiv.coe_symm_mk]\n      exact MultilinearMap.mkContinuous_norm_le _ (norm_nonneg f) _", "start": [1811, 1], "end": [1837, 68], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curryFinFinset", "code": "def curryFinFinset {k l n : \u2115} {s : Finset (Fin n)} (hk : s.card = k) (hl : s\u1d9c.card = l) :\n    (G[\u00d7n]\u2192L[\ud835\udd5c] G') \u2243\u2097\u1d62[\ud835\udd5c] G[\u00d7k]\u2192L[\ud835\udd5c] G[\u00d7l]\u2192L[\ud835\udd5c] G' :=\n  (domDomCongr\u2097\u1d62 \ud835\udd5c G G' (finSumEquivOfFinset hk hl).symm).trans\n    (currySumEquiv \ud835\udd5c (Fin k) (Fin l) G G')", "start": [1846, 1], "end": [1853, 43], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curryFinFinset_apply", "code": "@[simp]\ntheorem curryFinFinset_apply (hk : s.card = k) (hl : s\u1d9c.card = l) (f : G[\u00d7n]\u2192L[\ud835\udd5c] G')\n    (mk : Fin k \u2192 G) (ml : Fin l \u2192 G) : curryFinFinset \ud835\udd5c G G' hk hl f mk ml =\n      f fun i => Sum.elim mk ml ((finSumEquivOfFinset hk hl).symm i)", "start": [1858, 1], "end": [1862, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curryFinFinset_symm_apply", "code": "@[simp]\ntheorem curryFinFinset_symm_apply (hk : s.card = k) (hl : s\u1d9c.card = l)\n    (f : G[\u00d7k]\u2192L[\ud835\udd5c] G[\u00d7l]\u2192L[\ud835\udd5c] G') (m : Fin n \u2192 G) : (curryFinFinset \ud835\udd5c G G' hk hl).symm f m =\n      f (fun i => m <| finSumEquivOfFinset hk hl (Sum.inl i)) fun i =>\n        m <| finSumEquivOfFinset hk hl (Sum.inr i)", "start": [1865, 1], "end": [1870, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curryFinFinset_symm_apply_piecewise_const", "code": "theorem curryFinFinset_symm_apply_piecewise_const (hk : s.card = k) (hl : s\u1d9c.card = l)\n    (f : G[\u00d7k]\u2192L[\ud835\udd5c] G[\u00d7l]\u2192L[\ud835\udd5c] G') (x y : G) :\n    (curryFinFinset \ud835\udd5c G G' hk hl).symm f (s.piecewise (fun _ => x) fun _ => y) =\n      f (fun _ => x) fun _ => y", "start": [1874, 1], "end": [1878, 71], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curryFinFinset_symm_apply_const", "code": "@[simp]\ntheorem curryFinFinset_symm_apply_const (hk : s.card = k) (hl : s\u1d9c.card = l)\n    (f : G[\u00d7k]\u2192L[\ud835\udd5c] G[\u00d7l]\u2192L[\ud835\udd5c] G') (x : G) :\n    ((curryFinFinset \ud835\udd5c G G' hk hl).symm f fun _ => x) = f (fun _ => x) fun _ => x", "start": [1881, 1], "end": [1885, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.curryFinFinset_apply_const", "code": "theorem curryFinFinset_apply_const (hk : s.card = k) (hl : s\u1d9c.card = l) (f : G[\u00d7n]\u2192L[\ud835\udd5c] G')\n    (x y : G) : (curryFinFinset \ud835\udd5c G G' hk hl f (fun _ => x) fun _ => y) =\n      f (s.piecewise (fun _ => x) fun _ => y)", "start": [1889, 1], "end": [1894, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "imports": ["lake-packages/Qq/Qq.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.rpow", "code": "noncomputable def rpow (x y : \u211d) :=\n  ((x : \u2102) ^ (y : \u2102)).re", "start": [30, 1], "end": [35, 25], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_eq_pow", "code": "@[simp]\ntheorem rpow_eq_pow (x y : \u211d) : rpow x y = x ^ y", "start": [40, 1], "end": [41, 56], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_def", "code": "theorem rpow_def (x y : \u211d) : x ^ y = ((x : \u2102) ^ (y : \u2102)).re", "start": [44, 1], "end": [44, 67], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_def_of_nonneg", "code": "theorem rpow_def_of_nonneg {x : \u211d} (hx : 0 \u2264 x) (y : \u211d) :\n    x ^ y = if x = 0 then if y = 0 then 1 else 0 else exp (log x * y)", "start": [47, 1], "end": [51, 84], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_def_of_pos", "code": "theorem rpow_def_of_pos {x : \u211d} (hx : 0 < x) (y : \u211d) : x ^ y = exp (log x * y)", "start": [54, 1], "end": [55, 62], "kind": "commanddeclaration"}, {"full_name": "Real.exp_mul", "code": "theorem exp_mul (x y : \u211d) : exp (x * y) = exp x ^ y", "start": [58, 1], "end": [58, 100], "kind": "commanddeclaration"}, {"full_name": "Real.exp_one_rpow", "code": "@[simp]\ntheorem exp_one_rpow (x : \u211d) : exp 1 ^ x = exp x", "start": [61, 1], "end": [62, 79], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_eq_zero_iff_of_nonneg", "code": "theorem rpow_eq_zero_iff_of_nonneg {x y : \u211d} (hx : 0 \u2264 x) : x ^ y = 0 \u2194 x = 0 \u2227 y \u2260 0", "start": [65, 1], "end": [67, 38], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_def_of_neg", "code": "theorem rpow_def_of_neg {x : \u211d} (hx : x < 0) (y : \u211d) : x ^ y = exp (log x * y) * cos (y * \u03c0)", "start": [72, 1], "end": [84, 22], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_def_of_nonpos", "code": "theorem rpow_def_of_nonpos {x : \u211d} (hx : x \u2264 0) (y : \u211d) :\n    x ^ y = if x = 0 then if y = 0 then 1 else 0 else exp (log x * y) * cos (y * \u03c0)", "start": [87, 1], "end": [89, 89], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_pos_of_pos", "code": "theorem rpow_pos_of_pos {x : \u211d} (hx : 0 < x) (y : \u211d) : 0 < x ^ y", "start": [92, 1], "end": [93, 41], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_zero", "code": "@[simp]\ntheorem rpow_zero (x : \u211d) : x ^ (0 : \u211d) = 1", "start": [96, 1], "end": [97, 66], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_zero_pos", "code": "theorem rpow_zero_pos (x : \u211d) : 0 < x ^ (0 : \u211d)", "start": [100, 1], "end": [100, 59], "kind": "commanddeclaration"}, {"full_name": "Real.zero_rpow", "code": "@[simp]\ntheorem zero_rpow {x : \u211d} (h : x \u2260 0) : (0 : \u211d) ^ x = 0", "start": [102, 1], "end": [103, 81], "kind": "commanddeclaration"}, {"full_name": "Real.zero_rpow_eq_iff", "code": "theorem zero_rpow_eq_iff {x : \u211d} {a : \u211d} : 0 ^ x = a \u2194 x \u2260 0 \u2227 a = 0 \u2228 x = 0 \u2227 a = 1", "start": [106, 1], "end": [118, 24], "kind": "commanddeclaration"}, {"full_name": "Real.eq_zero_rpow_iff", "code": "theorem eq_zero_rpow_iff {x : \u211d} {a : \u211d} : a = 0 ^ x \u2194 x \u2260 0 \u2227 a = 0 \u2228 x = 0 \u2227 a = 1", "start": [121, 1], "end": [122, 35], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_one", "code": "@[simp]\ntheorem rpow_one (x : \u211d) : x ^ (1 : \u211d) = x", "start": [125, 1], "end": [126, 65], "kind": "commanddeclaration"}, {"full_name": "Real.one_rpow", "code": "@[simp]\ntheorem one_rpow (x : \u211d) : (1 : \u211d) ^ x = 1", "start": [129, 1], "end": [130, 65], "kind": "commanddeclaration"}, {"full_name": "Real.zero_rpow_le_one", "code": "theorem zero_rpow_le_one (x : \u211d) : (0 : \u211d) ^ x \u2264 1", "start": [133, 1], "end": [134, 47], "kind": "commanddeclaration"}, {"full_name": "Real.zero_rpow_nonneg", "code": "theorem zero_rpow_nonneg (x : \u211d) : 0 \u2264 (0 : \u211d) ^ x", "start": [137, 1], "end": [138, 47], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_nonneg_of_nonneg", "code": "theorem rpow_nonneg_of_nonneg {x : \u211d} (hx : 0 \u2264 x) (y : \u211d) : 0 \u2264 x ^ y", "start": [141, 1], "end": [143, 59], "kind": "commanddeclaration"}, {"full_name": "Real.abs_rpow_of_nonneg", "code": "theorem abs_rpow_of_nonneg {x y : \u211d} (hx_nonneg : 0 \u2264 x) : |x ^ y| = |x| ^ y", "start": [146, 1], "end": [148, 64], "kind": "commanddeclaration"}, {"full_name": "Real.abs_rpow_le_abs_rpow", "code": "theorem abs_rpow_le_abs_rpow (x y : \u211d) : |x ^ y| \u2264 |x| ^ y", "start": [151, 1], "end": [156, 67], "kind": "commanddeclaration"}, {"full_name": "Real.abs_rpow_le_exp_log_mul", "code": "theorem abs_rpow_le_exp_log_mul (x y : \u211d) : |x ^ y| \u2264 exp (log x * y)", "start": [159, 1], "end": [163, 49], "kind": "commanddeclaration"}, {"full_name": "Real.norm_rpow_of_nonneg", "code": "theorem norm_rpow_of_nonneg {x y : \u211d} (hx_nonneg : 0 \u2264 x) : \u2016x ^ y\u2016 = \u2016x\u2016 ^ y", "start": [166, 1], "end": [168, 37], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_add", "code": "theorem rpow_add (hx : 0 < x) (y z : \u211d) : x ^ (y + z) = x ^ y * x ^ z", "start": [173, 1], "end": [174, 51], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_add'", "code": "theorem rpow_add' (hx : 0 \u2264 x) (h : y + z \u2260 0) : x ^ (y + z) = x ^ y * x ^ z", "start": [177, 1], "end": [182, 27], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_add_of_nonneg", "code": "theorem rpow_add_of_nonneg (hx : 0 \u2264 x) (hy : 0 \u2264 y) (hz : 0 \u2264 z) :\n    x ^ (y + z) = x ^ y * x ^ z", "start": [185, 1], "end": [189, 66], "kind": "commanddeclaration"}, {"full_name": "Real.le_rpow_add", "code": "theorem le_rpow_add {x : \u211d} (hx : 0 \u2264 x) (y z : \u211d) : x ^ y * x ^ z \u2264 x ^ (y + z)", "start": [192, 1], "end": [205, 24], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_sum_of_pos", "code": "theorem rpow_sum_of_pos {\u03b9 : Type*} {a : \u211d} (ha : 0 < a) (f : \u03b9 \u2192 \u211d) (s : Finset \u03b9) :\n    (a ^ \u2211 x in s, f x) = \u220f x in s, a ^ f x", "start": [208, 1], "end": [210, 93], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_sum_of_nonneg", "code": "theorem rpow_sum_of_nonneg {\u03b9 : Type*} {a : \u211d} (ha : 0 \u2264 a) {s : Finset \u03b9} {f : \u03b9 \u2192 \u211d}\n    (h : \u2200 x \u2208 s, 0 \u2264 f x) : (a ^ \u2211 x in s, f x) = \u220f x in s, a ^ f x", "start": [213, 1], "end": [218, 84], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_neg", "code": "theorem rpow_neg {x : \u211d} (hx : 0 \u2264 x) (y : \u211d) : x ^ (-y) = (x ^ y)\u207b\u00b9", "start": [221, 1], "end": [222, 70], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_sub", "code": "theorem rpow_sub {x : \u211d} (hx : 0 < x) (y z : \u211d) : x ^ (y - z) = x ^ y / x ^ z", "start": [225, 1], "end": [226, 82], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_sub'", "code": "theorem rpow_sub' {x : \u211d} (hx : 0 \u2264 x) {y z : \u211d} (h : y - z \u2260 0) : x ^ (y - z) = x ^ y / x ^ z", "start": [229, 1], "end": [231, 58], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_cpow", "code": "theorem ofReal_cpow {x : \u211d} (hx : 0 \u2264 x) (y : \u211d) : ((x ^ y : \u211d) : \u2102) = (x : \u2102) ^ (y : \u2102)", "start": [243, 1], "end": [245, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_cpow_of_nonpos", "code": "theorem ofReal_cpow_of_nonpos {x : \u211d} (hx : x \u2264 0) (y : \u2102) :\n    (x : \u2102) ^ y = (-x : \u2102) ^ y * exp (\u03c0 * I * y)", "start": [248, 1], "end": [255, 77], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_cpow_of_ne_zero", "code": "theorem abs_cpow_of_ne_zero {z : \u2102} (hz : z \u2260 0) (w : \u2102) :\n    abs (z ^ w) = abs z ^ w.re / Real.exp (arg z * im w)", "start": [258, 1], "end": [261, 39], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_cpow_of_imp", "code": "theorem abs_cpow_of_imp {z w : \u2102} (h : z = 0 \u2192 w.re = 0 \u2192 w = 0) :\n    abs (z ^ w) = abs z ^ w.re / Real.exp (arg z * im w)", "start": [264, 1], "end": [270, 31], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_cpow_le", "code": "theorem abs_cpow_le (z w : \u2102) : abs (z ^ w) \u2264 abs z ^ w.re / Real.exp (arg z * im w)", "start": [273, 1], "end": [277, 77], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_cpow_real", "code": "@[simp]\ntheorem abs_cpow_real (x : \u2102) (y : \u211d) : abs (x ^ (y : \u2102)) = Complex.abs x ^ y", "start": [280, 1], "end": [283, 34], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_cpow_inv_nat", "code": "@[simp]\ntheorem abs_cpow_inv_nat (x : \u2102) (n : \u2115) : abs (x ^ (n\u207b\u00b9 : \u2102)) = Complex.abs x ^ (n\u207b\u00b9 : \u211d)", "start": [286, 1], "end": [288, 46], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_cpow_eq_rpow_re_of_pos", "code": "theorem abs_cpow_eq_rpow_re_of_pos {x : \u211d} (hx : 0 < x) (y : \u2102) : abs (x ^ y) = x ^ y.re", "start": [291, 1], "end": [293, 59], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_cpow_eq_rpow_re_of_nonneg", "code": "theorem abs_cpow_eq_rpow_re_of_nonneg {x : \u211d} (hx : 0 \u2264 x) {y : \u2102} (hy : re y \u2260 0) :\n    abs (x ^ y) = x ^ re y", "start": [296, 1], "end": [301, 43], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_mul", "code": "theorem rpow_mul {x : \u211d} (hx : 0 \u2264 x) (y z : \u211d) : x ^ (y * z) = (x ^ y) ^ z", "start": [317, 1], "end": [321, 44], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_add_int", "code": "theorem rpow_add_int {x : \u211d} (hx : x \u2260 0) (y : \u211d) (n : \u2124) : x ^ (y + n) = x ^ y * x ^ n", "start": [324, 1], "end": [327, 93], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_add_nat", "code": "theorem rpow_add_nat {x : \u211d} (hx : x \u2260 0) (y : \u211d) (n : \u2115) : x ^ (y + n) = x ^ y * x ^ n", "start": [330, 1], "end": [331, 37], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_sub_int", "code": "theorem rpow_sub_int {x : \u211d} (hx : x \u2260 0) (y : \u211d) (n : \u2115) : x ^ (y - n) = x ^ y / x ^ n", "start": [334, 1], "end": [335, 40], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_sub_nat", "code": "theorem rpow_sub_nat {x : \u211d} (hx : x \u2260 0) (y : \u211d) (n : \u2115) : x ^ (y - n) = x ^ y / x ^ n", "start": [338, 1], "end": [339, 37], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_add_one", "code": "theorem rpow_add_one {x : \u211d} (hx : x \u2260 0) (y : \u211d) : x ^ (y + 1) = x ^ y * x", "start": [342, 1], "end": [343, 34], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_sub_one", "code": "theorem rpow_sub_one {x : \u211d} (hx : x \u2260 0) (y : \u211d) : x ^ (y - 1) = x ^ y / x", "start": [346, 1], "end": [347, 34], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_int_cast", "code": "@[simp, norm_cast]\ntheorem rpow_int_cast (x : \u211d) (n : \u2124) : x ^ (n : \u211d) = x ^ n", "start": [350, 1], "end": [353, 23], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_nat_cast", "code": "@[simp, norm_cast]\ntheorem rpow_nat_cast (x : \u211d) (n : \u2115) : x ^ (n : \u211d) = x ^ n", "start": [356, 1], "end": [358, 35], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_two", "code": "@[simp]\ntheorem rpow_two (x : \u211d) : x ^ (2 : \u211d) = x ^ 2", "start": [361, 1], "end": [364, 29], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_neg_one", "code": "theorem rpow_neg_one (x : \u211d) : x ^ (-1 : \u211d) = x\u207b\u00b9", "start": [367, 1], "end": [369, 48], "kind": "commanddeclaration"}, {"full_name": "Real.mul_rpow", "code": "theorem mul_rpow {x y z : \u211d} (h : 0 \u2264 x) (h\u2081 : 0 \u2264 y) : (x * y) ^ z = x ^ z * y ^ z", "start": [372, 1], "end": [390, 26], "kind": "commanddeclaration"}, {"full_name": "Real.inv_rpow", "code": "theorem inv_rpow (hx : 0 \u2264 x) (y : \u211d) : x\u207b\u00b9 ^ y = (x ^ y)\u207b\u00b9", "start": [393, 1], "end": [394, 54], "kind": "commanddeclaration"}, {"full_name": "Real.div_rpow", "code": "theorem div_rpow (hx : 0 \u2264 x) (hy : 0 \u2264 y) (z : \u211d) : (x / y) ^ z = x ^ z / y ^ z", "start": [397, 1], "end": [398, 73], "kind": "commanddeclaration"}, {"full_name": "Real.log_rpow", "code": "theorem log_rpow {x : \u211d} (hx : 0 < x) (y : \u211d) : log (x ^ y) = y * log x", "start": [401, 1], "end": [403, 99], "kind": "commanddeclaration"}, {"full_name": "Real.mul_log_eq_log_iff", "code": "theorem mul_log_eq_log_iff {x y z : \u211d} (hx : 0 < x) (hz : 0 < z) :\n    y * log x = log z \u2194 x ^ y = z", "start": [406, 1], "end": [409, 35], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_lt_rpow", "code": "@[gcongr]\ntheorem rpow_lt_rpow (hx : 0 \u2264 x) (hxy : x < y) (hz : 0 < z) : x ^ z < y ^ z", "start": [419, 1], "end": [425, 57], "kind": "commanddeclaration"}, {"full_name": "Real.strictMonoOn_rpow_Ici_of_exponent_pos", "code": "theorem strictMonoOn_rpow_Ici_of_exponent_pos {r : \u211d} (hr : 0 < r) :\n    StrictMonoOn (fun (x : \u211d) => x ^ r) (Set.Ici 0)", "start": [428, 1], "end": [430, 45], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_le_rpow", "code": "@[gcongr]\ntheorem rpow_le_rpow {x y z : \u211d} (h : 0 \u2264 x) (h\u2081 : x \u2264 y) (h\u2082 : 0 \u2264 z) : x ^ z \u2264 y ^ z", "start": [432, 1], "end": [436, 42], "kind": "commanddeclaration"}, {"full_name": "Real.monotoneOn_rpow_Ici_of_exponent_nonneg", "code": "theorem monotoneOn_rpow_Ici_of_exponent_nonneg {r : \u211d} (hr : 0 \u2264 r) :\n    MonotoneOn (fun (x : \u211d) => x ^ r) (Set.Ici 0)", "start": [439, 1], "end": [441, 45], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_lt_rpow_iff", "code": "theorem rpow_lt_rpow_iff (hx : 0 \u2264 x) (hy : 0 \u2264 y) (hz : 0 < z) : x ^ z < y ^ z \u2194 x < y", "start": [443, 1], "end": [444, 99], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_le_rpow_iff", "code": "theorem rpow_le_rpow_iff (hx : 0 \u2264 x) (hy : 0 \u2264 y) (hz : 0 < z) : x ^ z \u2264 y ^ z \u2194 x \u2264 y", "start": [447, 1], "end": [448, 57], "kind": "commanddeclaration"}, {"full_name": "Real.le_rpow_inv_iff_of_neg", "code": "theorem le_rpow_inv_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) :\n    x \u2264 y ^ z\u207b\u00b9 \u2194 y \u2264 x ^ z", "start": [451, 1], "end": [459, 7], "kind": "commanddeclaration"}, {"full_name": "Real.lt_rpow_inv_iff_of_neg", "code": "theorem lt_rpow_inv_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) :\n    x < y ^ z\u207b\u00b9 \u2194 y < x ^ z", "start": [462, 1], "end": [470, 7], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_inv_lt_iff_of_neg", "code": "theorem rpow_inv_lt_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) :\n    x ^ z\u207b\u00b9 < y \u2194 y ^ z < x", "start": [473, 1], "end": [476, 69], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_inv_le_iff_of_neg", "code": "theorem rpow_inv_le_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) :\n    x ^ z\u207b\u00b9 \u2264 y \u2194 y ^ z \u2264 x", "start": [479, 1], "end": [482, 67], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_lt_rpow_of_exponent_lt", "code": "theorem rpow_lt_rpow_of_exponent_lt (hx : 1 < x) (hyz : y < z) : x ^ y < x ^ z", "start": [485, 1], "end": [487, 65], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_le_rpow_of_exponent_le", "code": "@[gcongr]\ntheorem rpow_le_rpow_of_exponent_le (hx : 1 \u2264 x) (hyz : y \u2264 z) : x ^ y \u2264 x ^ z", "start": [490, 1], "end": [493, 71], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_lt_rpow_of_exponent_neg", "code": "theorem rpow_lt_rpow_of_exponent_neg {x y z : \u211d} (hy : 0 < y) (hxy : y < x) (hz : z < 0) :\n    x ^ z < y ^ z", "start": [496, 1], "end": [501, 67], "kind": "commanddeclaration"}, {"full_name": "Real.strictAntiOn_rpow_Ioi_of_exponent_neg", "code": "theorem strictAntiOn_rpow_Ioi_of_exponent_neg {r : \u211d} (hr : r < 0) :\n    StrictAntiOn (fun (x:\u211d) => x ^ r) (Set.Ioi 0)", "start": [503, 1], "end": [505, 61], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_le_rpow_of_exponent_nonpos", "code": "theorem rpow_le_rpow_of_exponent_nonpos {x y : \u211d} (hy : 0 < y) (hxy : y \u2264 x) (hz : z \u2264 0) :\n    x ^ z \u2264 y ^ z", "start": [507, 1], "end": [516, 19], "kind": "commanddeclaration"}, {"full_name": "Real.antitoneOn_rpow_Ioi_of_exponent_nonpos", "code": "theorem antitoneOn_rpow_Ioi_of_exponent_nonpos {r : \u211d} (hr : r \u2264 0) :\n    AntitoneOn (fun (x:\u211d) => x ^ r) (Set.Ioi 0)", "start": [518, 1], "end": [520, 64], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_le_rpow_left_iff", "code": "@[simp]\ntheorem rpow_le_rpow_left_iff (hx : 1 < x) : x ^ y \u2264 x ^ z \u2194 y \u2264 z", "start": [522, 1], "end": [526, 51], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_lt_rpow_left_iff", "code": "@[simp]\ntheorem rpow_lt_rpow_left_iff (hx : 1 < x) : x ^ y < x ^ z \u2194 y < z", "start": [529, 1], "end": [531, 62], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_lt_rpow_of_exponent_gt", "code": "theorem rpow_lt_rpow_of_exponent_gt (hx0 : 0 < x) (hx1 : x < 1) (hyz : z < y) : x ^ y < x ^ z", "start": [534, 1], "end": [536, 70], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_le_rpow_of_exponent_ge", "code": "theorem rpow_le_rpow_of_exponent_ge (hx0 : 0 < x) (hx1 : x \u2264 1) (hyz : z \u2264 y) : x ^ y \u2264 x ^ z", "start": [539, 1], "end": [541, 87], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_le_rpow_left_iff_of_base_lt_one", "code": "@[simp]\ntheorem rpow_le_rpow_left_iff_of_base_lt_one (hx0 : 0 < x) (hx1 : x < 1) :\n    x ^ y \u2264 x ^ z \u2194 z \u2264 y", "start": [544, 1], "end": [548, 47], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_lt_rpow_left_iff_of_base_lt_one", "code": "@[simp]\ntheorem rpow_lt_rpow_left_iff_of_base_lt_one (hx0 : 0 < x) (hx1 : x < 1) : x ^ y < x ^ z \u2194 z < y", "start": [551, 1], "end": [553, 85], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_lt_one", "code": "theorem rpow_lt_one {x z : \u211d} (hx1 : 0 \u2264 x) (hx2 : x < 1) (hz : 0 < z) : x ^ z < 1", "start": [556, 1], "end": [558, 32], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_le_one", "code": "theorem rpow_le_one {x z : \u211d} (hx1 : 0 \u2264 x) (hx2 : x \u2264 1) (hz : 0 \u2264 z) : x ^ z \u2264 1", "start": [561, 1], "end": [563, 32], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_lt_one_of_one_lt_of_neg", "code": "theorem rpow_lt_one_of_one_lt_of_neg {x z : \u211d} (hx : 1 < x) (hz : z < 0) : x ^ z < 1", "start": [566, 1], "end": [568, 27], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_le_one_of_one_le_of_nonpos", "code": "theorem rpow_le_one_of_one_le_of_nonpos {x z : \u211d} (hx : 1 \u2264 x) (hz : z \u2264 0) : x ^ z \u2264 1", "start": [571, 1], "end": [573, 27], "kind": "commanddeclaration"}, {"full_name": "Real.one_lt_rpow", "code": "theorem one_lt_rpow {x z : \u211d} (hx : 1 < x) (hz : 0 < z) : 1 < x ^ z", "start": [576, 1], "end": [578, 39], "kind": "commanddeclaration"}, {"full_name": "Real.one_le_rpow", "code": "theorem one_le_rpow {x z : \u211d} (hx : 1 \u2264 x) (hz : 0 \u2264 z) : 1 \u2264 x ^ z", "start": [581, 1], "end": [583, 39], "kind": "commanddeclaration"}, {"full_name": "Real.one_lt_rpow_of_pos_of_lt_one_of_neg", "code": "theorem one_lt_rpow_of_pos_of_lt_one_of_neg (hx1 : 0 < x) (hx2 : x < 1) (hz : z < 0) :\n    1 < x ^ z", "start": [586, 1], "end": [589, 27], "kind": "commanddeclaration"}, {"full_name": "Real.one_le_rpow_of_pos_of_le_one_of_nonpos", "code": "theorem one_le_rpow_of_pos_of_le_one_of_nonpos (hx1 : 0 < x) (hx2 : x \u2264 1) (hz : z \u2264 0) :\n    1 \u2264 x ^ z", "start": [592, 1], "end": [595, 27], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_lt_one_iff_of_pos", "code": "theorem rpow_lt_one_iff_of_pos (hx : 0 < x) : x ^ y < 1 \u2194 1 < x \u2227 y < 0 \u2228 x < 1 \u2227 0 < y", "start": [598, 1], "end": [599, 87], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_lt_one_iff", "code": "theorem rpow_lt_one_iff (hx : 0 \u2264 x) :\n    x ^ y < 1 \u2194 x = 0 \u2227 y \u2260 0 \u2228 1 < x \u2227 y < 0 \u2228 x < 1 \u2227 0 < y", "start": [602, 1], "end": [606, 49], "kind": "commanddeclaration"}, {"full_name": "Real.one_lt_rpow_iff_of_pos", "code": "theorem one_lt_rpow_iff_of_pos (hx : 0 < x) : 1 < x ^ y \u2194 1 < x \u2227 0 < y \u2228 x < 1 \u2227 y < 0", "start": [609, 1], "end": [610, 87], "kind": "commanddeclaration"}, {"full_name": "Real.one_lt_rpow_iff", "code": "theorem one_lt_rpow_iff (hx : 0 \u2264 x) : 1 < x ^ y \u2194 1 < x \u2227 0 < y \u2228 0 < x \u2227 x < 1 \u2227 y < 0", "start": [613, 1], "end": [616, 41], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_le_rpow_of_exponent_ge'", "code": "theorem rpow_le_rpow_of_exponent_ge' (hx0 : 0 \u2264 x) (hx1 : x \u2264 1) (hz : 0 \u2264 z) (hyz : z \u2264 y) :\n    x ^ y \u2264 x ^ z", "start": [619, 1], "end": [625, 51], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_left_injOn", "code": "theorem rpow_left_injOn {x : \u211d} (hx : x \u2260 0) : InjOn (fun y : \u211d => y ^ x) { y : \u211d | 0 \u2264 y }", "start": [628, 1], "end": [630, 93], "kind": "commanddeclaration"}, {"full_name": "Real.le_rpow_iff_log_le", "code": "theorem le_rpow_iff_log_le (hx : 0 < x) (hy : 0 < y) : x \u2264 y ^ z \u2194 Real.log x \u2264 z * Real.log y", "start": [633, 1], "end": [634, 74], "kind": "commanddeclaration"}, {"full_name": "Real.le_rpow_of_log_le", "code": "theorem le_rpow_of_log_le (hx : 0 \u2264 x) (hy : 0 < y) (h : Real.log x \u2264 z * Real.log y) :\n    x \u2264 y ^ z", "start": [637, 1], "end": [641, 39], "kind": "commanddeclaration"}, {"full_name": "Real.lt_rpow_iff_log_lt", "code": "theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z \u2194 Real.log x < z * Real.log y", "start": [644, 1], "end": [645, 78], "kind": "commanddeclaration"}, {"full_name": "Real.lt_rpow_of_log_lt", "code": "theorem lt_rpow_of_log_lt (hx : 0 \u2264 x) (hy : 0 < y) (h : Real.log x < z * Real.log y) :\n    x < y ^ z", "start": [648, 1], "end": [652, 34], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_le_one_iff_of_pos", "code": "theorem rpow_le_one_iff_of_pos (hx : 0 < x) : x ^ y \u2264 1 \u2194 1 \u2264 x \u2227 y \u2264 0 \u2228 x \u2264 1 \u2227 0 \u2264 y", "start": [655, 1], "end": [656, 96], "kind": "commanddeclaration"}, {"full_name": "Real.abs_log_mul_self_rpow_lt", "code": "theorem abs_log_mul_self_rpow_lt (x t : \u211d) (h1 : 0 < x) (h2 : x \u2264 1) (ht : 0 < t) :\n    |log x * x ^ t| < 1 / t", "start": [659, 1], "end": [664, 73], "kind": "commanddeclaration"}, {"full_name": "Real.pow_nat_rpow_nat_inv", "code": "theorem pow_nat_rpow_nat_inv {x : \u211d} (hx : 0 \u2264 x) {n : \u2115} (hn : n \u2260 0) :\n    (x ^ n) ^ (n\u207b\u00b9 : \u211d) = x", "start": [667, 1], "end": [670, 68], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_nat_inv_pow_nat", "code": "theorem rpow_nat_inv_pow_nat {x : \u211d} (hx : 0 \u2264 x) {n : \u2115} (hn : n \u2260 0) :\n    (x ^ (n\u207b\u00b9 : \u211d)) ^ n = x", "start": [673, 1], "end": [676, 68], "kind": "commanddeclaration"}, {"full_name": "Real.strictMono_rpow_of_base_gt_one", "code": "lemma strictMono_rpow_of_base_gt_one {b : \u211d} (hb : 1 < b) :\n    StrictMono (rpow b) := by\n  show StrictMono (fun (x:\u211d) => b ^ x)\n  simp_rw [Real.rpow_def_of_pos (zero_lt_one.trans hb)]\n  exact exp_strictMono.comp <| StrictMono.const_mul strictMono_id <| Real.log_pos hb", "start": [679, 1], "end": [683, 85], "kind": "mathlibtacticlemma"}, {"full_name": "Real.monotone_rpow_of_base_ge_one", "code": "lemma monotone_rpow_of_base_ge_one {b : \u211d} (hb : 1 \u2264 b) :\n    Monotone (rpow b) := by\n  rcases lt_or_eq_of_le hb with hb | rfl\n  case inl => exact (strictMono_rpow_of_base_gt_one hb).monotone\n  case inr => intro _ _ _; simp", "start": [685, 1], "end": [689, 32], "kind": "mathlibtacticlemma"}, {"full_name": "Real.strictAnti_rpow_of_base_lt_one", "code": "lemma strictAnti_rpow_of_base_lt_one {b : \u211d} (hb\u2080 : 0 < b) (hb\u2081 : b < 1) :\n    StrictAnti (rpow b) := by\n  show StrictAnti (fun (x:\u211d) => b ^ x)\n  simp_rw [Real.rpow_def_of_pos hb\u2080]\n  exact exp_strictMono.comp_strictAnti <| StrictMono.const_mul_of_neg strictMono_id\n      <| Real.log_neg hb\u2080 hb\u2081", "start": [691, 1], "end": [696, 30], "kind": "mathlibtacticlemma"}, {"full_name": "Real.antitone_rpow_of_base_le_one", "code": "lemma antitone_rpow_of_base_le_one {b : \u211d} (hb\u2080 : 0 < b) (hb\u2081 : b \u2264 1) :\n    Antitone (rpow b) := by\n  rcases lt_or_eq_of_le hb\u2081 with hb\u2081 | rfl\n  case inl => exact (strictAnti_rpow_of_base_lt_one hb\u2080 hb\u2081).antitone\n  case inr => intro _ _ _; simp", "start": [698, 1], "end": [702, 32], "kind": "mathlibtacticlemma"}, {"full_name": "Real.sqrt_eq_rpow", "code": "theorem sqrt_eq_rpow (x : \u211d) : sqrt x = x ^ (1 / (2 : \u211d))", "start": [717, 1], "end": [723, 88], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_div_two_eq_sqrt", "code": "theorem rpow_div_two_eq_sqrt {x : \u211d} (r : \u211d) (hx : 0 \u2264 x) : x ^ (r / 2) = sqrt x ^ r", "start": [726, 1], "end": [729, 7], "kind": "commanddeclaration"}, {"full_name": "Real.exists_rat_pow_btwn_rat_aux", "code": "theorem exists_rat_pow_btwn_rat_aux (hn : n \u2260 0) (x y : \u211d) (h : x < y) (hy : 0 < y) :\n    \u2203 q : \u211a, 0 < q \u2227 x < (q : \u211d) ^ n \u2227 (q : \u211d) ^ n < y", "start": [738, 1], "end": [750, 26], "kind": "commanddeclaration"}, {"full_name": "Real.exists_rat_pow_btwn_rat", "code": "theorem exists_rat_pow_btwn_rat (hn : n \u2260 0) {x y : \u211a} (h : x < y) (hy : 0 < y) :\n    \u2203 q : \u211a, 0 < q \u2227 x < q ^ n \u2227 q ^ n < y", "start": [753, 1], "end": [755, 67], "kind": "commanddeclaration"}, {"full_name": "Real.exists_rat_pow_btwn", "code": "theorem exists_rat_pow_btwn {\u03b1 : Type*} [LinearOrderedField \u03b1] [Archimedean \u03b1] (hn : n \u2260 0)\n    {x y : \u03b1} (h : x < y) (hy : 0 < y) : \u2203 q : \u211a, 0 < q \u2227 x < (q : \u03b1) ^ n \u2227 (q : \u03b1) ^ n < y", "start": [758, 1], "end": [766, 99], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalRpowZero", "code": "@[positivity (_ : \u211d) ^ (0 : \u211d), Pow.pow (_ : \u211d) (0 : \u211d), Real.rpow (_ : \u211d) (0 : \u211d)]\ndef evalRpowZero : Mathlib.Meta.Positivity.PositivityExt where eval {_ _} _ _ e := do\n  let .app (.app (f : Q(\u211d \u2192 \u211d \u2192 \u211d)) (a : Q(\u211d))) (_ : Q(\u211d)) \u2190 withReducible (whnf e)\n    | throwError \"not Real.rpow\"\n  guard <|\u2190 withDefault <| withNewMCtxDepth <| isDefEq f q(Real.rpow)\n  pure (.positive (q(Real.rpow_zero_pos $a) : Expr))", "start": [831, 1], "end": [838, 53], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalRpow", "code": "@[positivity (_ : \u211d) ^ (_ : \u211d), Pow.pow (_ : \u211d) (_ : \u211d), Real.rpow (_ : \u211d) (_ : \u211d)]\ndef evalRpow : Mathlib.Meta.Positivity.PositivityExt where eval {_ _} z\u03b1 p\u03b1 e := do\n  let .app (.app (f : Q(\u211d \u2192 \u211d \u2192 \u211d)) (a : Q(\u211d))) (b : Q(\u211d)) \u2190 withReducible (whnf e)\n    | throwError \"not Real.rpow\"\n  guard <|\u2190 withDefault <| withNewMCtxDepth <| isDefEq f q(Real.rpow)\n  let ra \u2190 core z\u03b1 p\u03b1 a\n  match ra with\n  | .positive pa =>\n      have pa' : Q(0 < $a) := pa\n      pure (.positive (q(Real.rpow_pos_of_pos $pa' $b) : Expr))\n  | .nonnegative pa =>\n      have pa' : Q(0 \u2264 $a) := pa\n      pure (.nonnegative (q(Real.rpow_nonneg_of_nonneg $pa' $b) : Expr))\n  | _ => pure .none", "start": [840, 1], "end": [855, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Slope.lean", "imports": ["Mathlib/Tactic/Linarith.lean", "Mathlib/Analysis/Convex/Function.lean", "Mathlib/Tactic/FieldSimp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ConvexOn.slope_mono_adjacent", "code": "theorem ConvexOn.slope_mono_adjacent (hf : ConvexOn \ud835\udd5c s f) {x y z : \ud835\udd5c} (hx : x \u2208 s) (hz : z \u2208 s)\n    (hxy : x < y) (hyz : y < z) : (f y - f x) / (y - x) \u2264 (f z - f y) / (z - y)", "start": [24, 1], "end": [45, 14], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.slope_anti_adjacent", "code": "theorem ConcaveOn.slope_anti_adjacent (hf : ConcaveOn \ud835\udd5c s f) {x y z : \ud835\udd5c} (hx : x \u2208 s) (hz : z \u2208 s)\n    (hxy : x < y) (hyz : y < z) : (f z - f y) / (z - y) \u2264 (f y - f x) / (y - x)", "start": [48, 1], "end": [54, 13], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.slope_strict_mono_adjacent", "code": "theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn \ud835\udd5c s f) {x y z : \ud835\udd5c}\n    (hx : x \u2208 s) (hz : z \u2208 s) (hxy : x < y) (hyz : y < z) :\n    (f y - f x) / (y - x) < (f z - f y) / (z - y)", "start": [57, 1], "end": [80, 14], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.slope_anti_adjacent", "code": "theorem StrictConcaveOn.slope_anti_adjacent (hf : StrictConcaveOn \ud835\udd5c s f) {x y z : \ud835\udd5c} (hx : x \u2208 s)\n    (hz : z \u2208 s) (hxy : x < y) (hyz : y < z) : (f z - f y) / (z - y) < (f y - f x) / (y - x)", "start": [83, 1], "end": [90, 13], "kind": "commanddeclaration"}, {"full_name": "convexOn_of_slope_mono_adjacent", "code": "theorem convexOn_of_slope_mono_adjacent (hs : Convex \ud835\udd5c s)\n    (hf :\n      \u2200 {x y z : \ud835\udd5c},\n        x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f y - f x) / (y - x) \u2264 (f z - f y) / (z - y)) :\n    ConvexOn \ud835\udd5c s f", "start": [93, 1], "end": [121, 38], "kind": "commanddeclaration"}, {"full_name": "concaveOn_of_slope_anti_adjacent", "code": "theorem concaveOn_of_slope_anti_adjacent (hs : Convex \ud835\udd5c s)\n    (hf :\n      \u2200 {x y z : \ud835\udd5c},\n        x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f z - f y) / (z - y) \u2264 (f y - f x) / (y - x)) :\n    ConcaveOn \ud835\udd5c s f", "start": [124, 1], "end": [135, 25], "kind": "commanddeclaration"}, {"full_name": "strictConvexOn_of_slope_strict_mono_adjacent", "code": "theorem strictConvexOn_of_slope_strict_mono_adjacent (hs : Convex \ud835\udd5c s)\n    (hf :\n      \u2200 {x y z : \ud835\udd5c},\n        x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f y - f x) / (y - x) < (f z - f y) / (z - y)) :\n    StrictConvexOn \ud835\udd5c s f", "start": [138, 1], "end": [166, 38], "kind": "commanddeclaration"}, {"full_name": "strictConcaveOn_of_slope_strict_anti_adjacent", "code": "theorem strictConcaveOn_of_slope_strict_anti_adjacent (hs : Convex \ud835\udd5c s)\n    (hf :\n      \u2200 {x y z : \ud835\udd5c},\n        x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f z - f y) / (z - y) < (f y - f x) / (y - x)) :\n    StrictConcaveOn \ud835\udd5c s f", "start": [169, 1], "end": [181, 25], "kind": "commanddeclaration"}, {"full_name": "convexOn_iff_slope_mono_adjacent", "code": "theorem convexOn_iff_slope_mono_adjacent :\n    ConvexOn \ud835\udd5c s f \u2194\n      Convex \ud835\udd5c s \u2227 \u2200 \u2983x y z : \ud835\udd5c\u2984,\n          x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f y - f x) / (y - x) \u2264 (f z - f y) / (z - y)", "start": [184, 1], "end": [191, 73], "kind": "commanddeclaration"}, {"full_name": "concaveOn_iff_slope_anti_adjacent", "code": "theorem concaveOn_iff_slope_anti_adjacent :\n    ConcaveOn \ud835\udd5c s f \u2194\n      Convex \ud835\udd5c s \u2227\n        \u2200 \u2983x y z : \ud835\udd5c\u2984,\n          x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f z - f y) / (z - y) \u2264 (f y - f x) / (y - x)", "start": [194, 1], "end": [202, 74], "kind": "commanddeclaration"}, {"full_name": "strictConvexOn_iff_slope_strict_mono_adjacent", "code": "theorem strictConvexOn_iff_slope_strict_mono_adjacent :\n    StrictConvexOn \ud835\udd5c s f \u2194\n      Convex \ud835\udd5c s \u2227\n        \u2200 \u2983x y z : \ud835\udd5c\u2984,\n          x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f y - f x) / (y - x) < (f z - f y) / (z - y)", "start": [205, 1], "end": [214, 86], "kind": "commanddeclaration"}, {"full_name": "strictConcaveOn_iff_slope_strict_anti_adjacent", "code": "theorem strictConcaveOn_iff_slope_strict_anti_adjacent :\n    StrictConcaveOn \ud835\udd5c s f \u2194\n      Convex \ud835\udd5c s \u2227\n        \u2200 \u2983x y z : \ud835\udd5c\u2984,\n          x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f z - f y) / (z - y) < (f y - f x) / (y - x)", "start": [217, 1], "end": [226, 87], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.secant_mono_aux1", "code": "theorem ConvexOn.secant_mono_aux1 (hf : ConvexOn \ud835\udd5c s f) {x y z : \ud835\udd5c} (hx : x \u2208 s) (hz : z \u2208 s)\n    (hxy : x < y) (hyz : y < z) : (z - x) * f y \u2264 (z - y) * f x + (y - x) * f z", "start": [229, 1], "end": [247, 15], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.secant_mono_aux2", "code": "theorem ConvexOn.secant_mono_aux2 (hf : ConvexOn \ud835\udd5c s f) {x y z : \ud835\udd5c} (hx : x \u2208 s) (hz : z \u2208 s)\n    (hxy : x < y) (hyz : y < z) : (f y - f x) / (y - x) \u2264 (f z - f x) / (z - x)", "start": [250, 1], "end": [255, 52], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.secant_mono_aux3", "code": "theorem ConvexOn.secant_mono_aux3 (hf : ConvexOn \ud835\udd5c s f) {x y z : \ud835\udd5c} (hx : x \u2208 s) (hz : z \u2208 s)\n    (hxy : x < y) (hyz : y < z) : (f z - f x) / (z - x) \u2264 (f z - f y) / (z - y)", "start": [258, 1], "end": [263, 52], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.secant_mono", "code": "theorem ConvexOn.secant_mono (hf : ConvexOn \ud835\udd5c s f) {a x y : \ud835\udd5c} (ha : a \u2208 s) (hx : x \u2208 s)\n    (hy : y \u2208 s) (hxa : x \u2260 a) (hya : y \u2260 a) (hxy : x \u2264 y) :\n    (f x - f a) / (x - a) \u2264 (f y - f a) / (y - a)", "start": [266, 1], "end": [276, 44], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.secant_strict_mono_aux1", "code": "theorem StrictConvexOn.secant_strict_mono_aux1 (hf : StrictConvexOn \ud835\udd5c s f) {x y z : \ud835\udd5c} (hx : x \u2208 s)\n    (hz : z \u2208 s) (hxy : x < y) (hyz : y < z) : (z - x) * f y < (z - y) * f x + (y - x) * f z", "start": [279, 1], "end": [297, 15], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.secant_strict_mono_aux2", "code": "theorem StrictConvexOn.secant_strict_mono_aux2 (hf : StrictConvexOn \ud835\udd5c s f) {x y z : \ud835\udd5c} (hx : x \u2208 s)\n    (hz : z \u2208 s) (hxy : x < y) (hyz : y < z) : (f y - f x) / (y - x) < (f z - f x) / (z - x)", "start": [300, 1], "end": [305, 59], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.secant_strict_mono_aux3", "code": "theorem StrictConvexOn.secant_strict_mono_aux3 (hf : StrictConvexOn \ud835\udd5c s f) {x y z : \ud835\udd5c} (hx : x \u2208 s)\n    (hz : z \u2208 s) (hxy : x < y) (hyz : y < z) : (f z - f x) / (z - x) < (f z - f y) / (z - y)", "start": [308, 1], "end": [313, 59], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.secant_strict_mono", "code": "theorem StrictConvexOn.secant_strict_mono (hf : StrictConvexOn \ud835\udd5c s f) {a x y : \ud835\udd5c} (ha : a \u2208 s)\n    (hx : x \u2208 s) (hy : y \u2208 s) (hxa : x \u2260 a) (hya : y \u2260 a) (hxy : x < y) :\n    (f x - f a) / (x - a) < (f y - f a) / (y - a)", "start": [316, 1], "end": [325, 51], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.secant_strict_mono", "code": "theorem StrictConcaveOn.secant_strict_mono (hf : StrictConcaveOn \ud835\udd5c s f) {a x y : \ud835\udd5c} (ha : a \u2208 s)\n    (hx : x \u2208 s) (hy : y \u2208 s) (hxa : x \u2260 a) (hya : y \u2260 a) (hxy : x < y) :\n    (f y - f a) / (y - a) < (f x - f a) / (x - a)", "start": [328, 1], "end": [334, 46], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.strict_mono_of_lt", "code": "theorem ConvexOn.strict_mono_of_lt (hf : ConvexOn \ud835\udd5c s f) {x y : \ud835\udd5c} (hx : x \u2208 s) (hxy : x < y)\n    (hxy' : f x < f y) : StrictMonoOn f (s \u2229 Set.Ici y)", "start": [337, 1], "end": [354, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/FreeAlgebra.lean", "imports": ["Mathlib/RingTheory/Adjoin/Basic.lean", "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "Mathlib/Algebra/Free.lean", "Mathlib/Algebra/Algebra/Tower.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/MonoidAlgebra/Basic.lean"], "premises": [{"full_name": "FreeAlgebra.Pre", "code": "inductive Pre\n  | of : X \u2192 Pre\n  | of_scalar : R \u2192 Pre\n  | add : Pre \u2192 Pre \u2192 Pre\n  | mul : Pre \u2192 Pre \u2192 Pre", "start": [60, 1], "end": [66, 26], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.Pre.hasCoeGenerator", "code": "def hasCoeGenerator : Coe X (Pre R X) := \u27e8of\u27e9", "start": [74, 1], "end": [75, 46], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.Pre.hasCoeSemiring", "code": "def hasCoeSemiring : Coe R (Pre R X) := \u27e8of_scalar\u27e9", "start": [78, 1], "end": [79, 52], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.Pre.hasMul", "code": "def hasMul : Mul (Pre R X) := \u27e8mul\u27e9", "start": [82, 1], "end": [83, 36], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.Pre.hasAdd", "code": "def hasAdd : Add (Pre R X) := \u27e8add\u27e9", "start": [86, 1], "end": [87, 36], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.Pre.hasZero", "code": "def hasZero : Zero (Pre R X) := \u27e8of_scalar 0\u27e9", "start": [90, 1], "end": [91, 46], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.Pre.hasOne", "code": "def hasOne : One (Pre R X) := \u27e8of_scalar 1\u27e9", "start": [94, 1], "end": [95, 44], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.Pre.hasSmul", "code": "def hasSmul : SMul R (Pre R X) := \u27e8fun r m \u21a6 mul (of_scalar r) m\u27e9", "start": [98, 1], "end": [101, 66], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.liftFun", "code": "def liftFun {A : Type*} [Semiring A] [Algebra R A] (f : X \u2192 A) :\n    Pre R X \u2192 A\n  | .of t => f t\n  | .add a b => liftFun f a + liftFun f b\n  | .mul a b => liftFun f a * liftFun f b\n  | .of_scalar c => algebraMap _ _ c", "start": [109, 1], "end": [118, 37], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.Rel", "code": "inductive Rel : Pre R X \u2192 Pre R X \u2192 Prop\n  | add_scalar {r s : R} : Rel (\u2191(r + s)) (\u2191r + \u2191s)\n  | mul_scalar {r s : R} : Rel (\u2191(r * s)) (\u2191r * \u2191s)\n  | central_scalar {r : R} {a : Pre R X} : Rel (r * a) (a * r)\n\n  | add_assoc {a b c : Pre R X} : Rel (a + b + c) (a + (b + c))\n  | add_comm {a b : Pre R X} : Rel (a + b) (b + a)\n  | zero_add {a : Pre R X} : Rel (0 + a) a\n\n  | mul_assoc {a b c : Pre R X} : Rel (a * b * c) (a * (b * c))\n  | one_mul {a : Pre R X} : Rel (1 * a) a\n  | mul_one {a : Pre R X} : Rel (a * 1) a\n\n  | left_distrib {a b c : Pre R X} : Rel (a * (b + c)) (a * b + a * c)\n  | right_distrib {a b c : Pre R X} :\n      Rel ((a + b) * c) (a * c + b * c)\n\n  | zero_mul {a : Pre R X} : Rel (0 * a) 0\n  | mul_zero {a : Pre R X} : Rel (a * 0) 0\n\n  | add_compat_left {a b c : Pre R X} : Rel a b \u2192 Rel (a + c) (b + c)\n  | add_compat_right {a b c : Pre R X} : Rel a b \u2192 Rel (c + a) (c + b)\n  | mul_compat_left {a b c : Pre R X} : Rel a b \u2192 Rel (a * c) (b * c)\n  | mul_compat_right {a b c : Pre R X} : Rel a b \u2192 Rel (c * a) (c * b)", "start": [121, 1], "end": [153, 71], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra", "code": "def FreeAlgebra :=\n  Quot (FreeAlgebra.Rel R X)", "start": [158, 1], "end": [161, 29], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.instSMul", "code": "instance instSMul {A} [CommSemiring A] [Algebra R A] : SMul R (FreeAlgebra A X) where\n  smul r := Quot.map (HMul.hMul (algebraMap R A r : Pre A X)) fun _ _ \u21a6 Rel.mul_compat_right", "start": [171, 1], "end": [172, 93], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.instZero", "code": "instance instZero : Zero (FreeAlgebra R X) where zero := Quot.mk _ 0", "start": [174, 1], "end": [174, 69], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.instOne", "code": "instance instOne : One (FreeAlgebra R X) where one := Quot.mk _ 1", "start": [176, 1], "end": [176, 66], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.instAdd", "code": "instance instAdd : Add (FreeAlgebra R X) where\n  add := Quot.map\u2082 HAdd.hAdd (fun _ _ _ \u21a6 Rel.add_compat_right) fun _ _ _ \u21a6 Rel.add_compat_left", "start": [178, 1], "end": [179, 96], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.instMul", "code": "instance instMul : Mul (FreeAlgebra R X) where\n  mul := Quot.map\u2082 HMul.hMul (fun _ _ _ \u21a6 Rel.mul_compat_right) fun _ _ _ \u21a6 Rel.mul_compat_left", "start": [181, 1], "end": [182, 96], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.mk_mul", "code": "private theorem mk_mul (x y : Pre R X) :\n    Quot.mk (Rel R X) (x * y) = (HMul.hMul (self := instHMul (\u03b1 := FreeAlgebra R X))\n    (Quot.mk (Rel R X) x) (Quot.mk (Rel R X) y))", "start": [185, 1], "end": [188, 6], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.instMonoidWithZero", "code": "instance instMonoidWithZero : MonoidWithZero (FreeAlgebra R X) where\n  mul_assoc := by\n    rintro \u27e8\u27e9 \u27e8\u27e9 \u27e8\u27e9\n    exact Quot.sound Rel.mul_assoc\n  one := Quot.mk _ 1\n  one_mul := by\n    rintro \u27e8\u27e9\n    exact Quot.sound Rel.one_mul\n  mul_one := by\n    rintro \u27e8\u27e9\n    exact Quot.sound Rel.mul_one\n  zero_mul := by\n    rintro \u27e8\u27e9\n    exact Quot.sound Rel.zero_mul\n  mul_zero := by\n    rintro \u27e8\u27e9\n    exact Quot.sound Rel.mul_zero", "start": [193, 1], "end": [209, 34], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.instDistrib", "code": "instance instDistrib : Distrib (FreeAlgebra R X) where\n  left_distrib := by\n    rintro \u27e8\u27e9 \u27e8\u27e9 \u27e8\u27e9\n    exact Quot.sound Rel.left_distrib\n  right_distrib := by\n    rintro \u27e8\u27e9 \u27e8\u27e9 \u27e8\u27e9\n    exact Quot.sound Rel.right_distrib", "start": [211, 1], "end": [217, 39], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.instAddCommMonoid", "code": "instance instAddCommMonoid : AddCommMonoid (FreeAlgebra R X) where\n  add_assoc := by\n    rintro \u27e8\u27e9 \u27e8\u27e9 \u27e8\u27e9\n    exact Quot.sound Rel.add_assoc\n  zero_add := by\n    rintro \u27e8\u27e9\n    exact Quot.sound Rel.zero_add\n  add_zero := by\n    rintro \u27e8\u27e9\n    change Quot.mk _ _ = _\n    rw [Quot.sound Rel.add_comm, Quot.sound Rel.zero_add]\n  add_comm := by\n    rintro \u27e8\u27e9 \u27e8\u27e9\n    exact Quot.sound Rel.add_comm\n  nsmul := (\u00b7 \u2022 \u00b7)\n  nsmul_zero := by\n    rintro \u27e8\u27e9\n    change Quot.mk _ (_ * _) = _\n    rw [map_zero]\n    exact Quot.sound Rel.zero_mul\n  nsmul_succ n := by\n    rintro \u27e8a\u27e9\n    dsimp only [HSMul.hSMul, instSMul, Quot.map]\n    rw [map_add, map_one, add_comm, mk_mul, mk_mul, \u2190one_add_mul (_ : FreeAlgebra R X)]\n    congr 1\n    exact Quot.sound Rel.add_scalar", "start": [219, 1], "end": [244, 36], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.instAlgebra", "code": "instance instAlgebra {A} [CommSemiring A] [Algebra R A] : Algebra R (FreeAlgebra A X) where\n  toRingHom := ({\n      toFun := fun r => Quot.mk _ r\n      map_one' := rfl\n      map_mul' := fun _ _ => Quot.sound Rel.mul_scalar\n      map_zero' := rfl\n      map_add' := fun _ _ => Quot.sound Rel.add_scalar } : A \u2192+* FreeAlgebra A X).comp\n      (algebraMap R A)\n  commutes' _ := by\n    rintro \u27e8\u27e9\n    exact Quot.sound Rel.central_scalar\n  smul_def' _ _ := rfl", "start": [257, 1], "end": [268, 23], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.\u03b9", "code": "irreducible_def \u03b9 : X \u2192 FreeAlgebra R X := fun m \u21a6 Quot.mk _ m", "start": [298, 1], "end": [300, 63], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "FreeAlgebra.quot_mk_eq_\u03b9", "code": "@[simp]\ntheorem quot_mk_eq_\u03b9 (m : X) : Quot.mk (FreeAlgebra.Rel R X) m = \u03b9 R m", "start": [303, 1], "end": [304, 88], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.liftAux", "code": "private def liftAux (f : X \u2192 A) : FreeAlgebra R X \u2192\u2090[R] A where\n  toFun a :=\n    Quot.liftOn a (liftFun _ _ f) fun a b h \u21a6 by\n      induction' h\n      \u00b7 exact (algebraMap R A).map_add _ _\n      \u00b7 exact (algebraMap R A).map_mul _ _\n      \u00b7 apply Algebra.commutes\n      \u00b7 change _ + _ + _ = _ + (_ + _)\n        rw [add_assoc]\n      \u00b7 change _ + _ = _ + _\n        rw [add_comm]\n      \u00b7 change algebraMap _ _ _ + liftFun R X f _ = liftFun R X f _\n        simp\n      \u00b7 change _ * _ * _ = _ * (_ * _)\n        rw [mul_assoc]\n      \u00b7 change algebraMap _ _ _ * liftFun R X f _ = liftFun R X f _\n        simp\n      \u00b7 change liftFun R X f _ * algebraMap _ _ _ = liftFun R X f _\n        simp\n      \u00b7 change _ * (_ + _) = _ * _ + _ * _\n        rw [left_distrib]\n      \u00b7 change (_ + _) * _ = _ * _ + _ * _\n        rw [right_distrib]\n      \u00b7 change algebraMap _ _ _ * _ = algebraMap _ _ _\n        simp\n      \u00b7 change _ * algebraMap _ _ _ = algebraMap _ _ _\n        simp\n      repeat\n        change liftFun R X f _ + liftFun R X f _ = _\n        simp only [*]\n        rfl\n      repeat\n        change liftFun R X f _ * liftFun R X f _ = _\n        simp only [*]\n        rfl\n  map_one' := by\n    change algebraMap _ _ _ = _\n    simp\n  map_mul' := by\n    rintro \u27e8\u27e9 \u27e8\u27e9\n    rfl\n  map_zero' := by\n    dsimp\n    change algebraMap _ _ _ = _\n    simp\n  map_add' := by\n    rintro \u27e8\u27e9 \u27e8\u27e9\n    rfl\n  commutes' := by tauto", "start": [309, 1], "end": [358, 24], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.lift", "code": "@[irreducible]\ndef lift : (X \u2192 A) \u2243 (FreeAlgebra R X \u2192\u2090[R] A) :=\n  { toFun := liftAux R\n    invFun := fun F \u21a6 F \u2218 \u03b9 R\n    left_inv := fun f \u21a6 by\n      ext\n      simp only [Function.comp_apply, \u03b9_def]\n      rfl\n    right_inv := fun F \u21a6 by\n      ext t\n      rcases t with \u27e8x\u27e9\n      induction x\n      case of =>\n        change ((F : FreeAlgebra R X \u2192 A) \u2218 \u03b9 R) _ = _\n        simp only [Function.comp_apply, \u03b9_def]\n      case of_scalar x =>\n        change algebraMap _ _ x = F (algebraMap _ _ x)\n        rw [AlgHom.commutes F _]\n      case add a b ha hb =>\n        let fa : FreeAlgebra R X := Quot.mk (Rel R X) a\n        let fb : FreeAlgebra R X := Quot.mk (Rel R X) b\n        change liftAux R (F \u2218 \u03b9 R) (fa + fb) = F (fa + fb)\n        rw [AlgHom.map_add, AlgHom.map_add, ha, hb]\n      case mul a b ha hb =>\n        let fa : FreeAlgebra R X := Quot.mk (Rel R X) a\n        let fb : FreeAlgebra R X := Quot.mk (Rel R X) b\n        change liftAux R (F \u2218 \u03b9 R) (fa * fb) = F (fa * fb)\n        rw [AlgHom.map_mul, AlgHom.map_mul, ha, hb] }", "start": [361, 1], "end": [393, 54], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.liftAux_eq", "code": "@[simp]\ntheorem liftAux_eq (f : X \u2192 A) : liftAux R f = lift R f", "start": [396, 1], "end": [399, 6], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.lift_symm_apply", "code": "@[simp]\ntheorem lift_symm_apply (F : FreeAlgebra R X \u2192\u2090[R] A) : (lift R).symm F = F \u2218 \u03b9 R", "start": [402, 1], "end": [405, 6], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.\u03b9_comp_lift", "code": "@[simp]\ntheorem \u03b9_comp_lift (f : X \u2192 A) : (lift R f : FreeAlgebra R X \u2192 A) \u2218 \u03b9 R = f", "start": [410, 1], "end": [414, 6], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.lift_\u03b9_apply", "code": "@[simp]\ntheorem lift_\u03b9_apply (f : X \u2192 A) (x) : lift R f (\u03b9 R x) = f x", "start": [417, 1], "end": [420, 6], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.lift_unique", "code": "@[simp]\ntheorem lift_unique (f : X \u2192 A) (g : FreeAlgebra R X \u2192\u2090[R] A) :\n    (g : FreeAlgebra R X \u2192 A) \u2218 \u03b9 R = f \u2194 g = lift R f", "start": [423, 1], "end": [427, 6], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.lift_comp_\u03b9", "code": "@[simp]\ntheorem lift_comp_\u03b9 (g : FreeAlgebra R X \u2192\u2090[R] A) :\n    lift R ((g : FreeAlgebra R X \u2192 A) \u2218 \u03b9 R) = g", "start": [439, 1], "end": [443, 36], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.hom_ext", "code": "@[ext high]\ntheorem hom_ext {f g : FreeAlgebra R X \u2192\u2090[R] A}\n    (w : (f : FreeAlgebra R X \u2192 A) \u2218 \u03b9 R = (g : FreeAlgebra R X \u2192 A) \u2218 \u03b9 R) : f = g", "start": [446, 1], "end": [451, 34], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.equivMonoidAlgebraFreeMonoid", "code": "noncomputable def equivMonoidAlgebraFreeMonoid :\n    FreeAlgebra R X \u2243\u2090[R] MonoidAlgebra R (FreeMonoid X) :=\n  AlgEquiv.ofAlgHom (lift R fun x \u21a6 (MonoidAlgebra.of R (FreeMonoid X)) (FreeMonoid.of x))\n    ((MonoidAlgebra.lift R (FreeMonoid X) (FreeAlgebra R X)) (FreeMonoid.lift (\u03b9 R)))\n    (by\n      apply MonoidAlgebra.algHom_ext; intro x\n      refine FreeMonoid.recOn x ?_ ?_\n      \u00b7 simp\n        rfl\n      \u00b7 intro x y ih\n        simp at ih\n        simp [ih])\n    (by\n      ext\n      simp)", "start": [454, 1], "end": [473, 12], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.algebraMapInv", "code": "def algebraMapInv : FreeAlgebra R X \u2192\u2090[R] R :=\n  lift R (0 : X \u2192 R)", "start": [481, 1], "end": [483, 21], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.algebraMap_leftInverse", "code": "theorem algebraMap_leftInverse :\n    Function.LeftInverse algebraMapInv (algebraMap R <| FreeAlgebra R X)", "start": [486, 1], "end": [488, 23], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.algebraMap_inj", "code": "@[simp]\ntheorem algebraMap_inj (x y : R) :\n    algebraMap R (FreeAlgebra R X) x = algebraMap R (FreeAlgebra R X) y \u2194 x = y", "start": [491, 1], "end": [494, 42], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.algebraMap_eq_zero_iff", "code": "@[simp]\ntheorem algebraMap_eq_zero_iff (x : R) : algebraMap R (FreeAlgebra R X) x = 0 \u2194 x = 0", "start": [497, 1], "end": [499, 68], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.algebraMap_eq_one_iff", "code": "@[simp]\ntheorem algebraMap_eq_one_iff (x : R) : algebraMap R (FreeAlgebra R X) x = 1 \u2194 x = 1", "start": [502, 1], "end": [504, 67], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.\u03b9_injective", "code": "theorem \u03b9_injective [Nontrivial R] : Function.Injective (\u03b9 R : X \u2192 FreeAlgebra R X)", "start": [508, 1], "end": [516, 44], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.\u03b9_inj", "code": "@[simp]\ntheorem \u03b9_inj [Nontrivial R] (x y : X) : \u03b9 R x = \u03b9 R y \u2194 x = y", "start": [519, 1], "end": [521, 21], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.\u03b9_ne_algebraMap", "code": "@[simp]\ntheorem \u03b9_ne_algebraMap [Nontrivial R] (x : X) (r : R) : \u03b9 R x \u2260 algebraMap R _ r", "start": [524, 1], "end": [532, 41], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.\u03b9_ne_zero", "code": "@[simp]\ntheorem \u03b9_ne_zero [Nontrivial R] (x : X) : \u03b9 R x \u2260 0", "start": [535, 1], "end": [537, 22], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.\u03b9_ne_one", "code": "@[simp]\ntheorem \u03b9_ne_one [Nontrivial R] (x : X) : \u03b9 R x \u2260 1", "start": [540, 1], "end": [542, 22], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.induction", "code": "@[elab_as_elim]\ntheorem induction {C : FreeAlgebra R X \u2192 Prop}\n    (h_grade0 : \u2200 r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : \u2200 x, C (\u03b9 R x))\n    (h_mul : \u2200 a b, C a \u2192 C b \u2192 C (a * b)) (h_add : \u2200 a b, C a \u2192 C b \u2192 C (a + b))\n    (a : FreeAlgebra R X) : C a", "start": [553, 1], "end": [579, 16], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.adjoin_range_\u03b9", "code": "@[simp]\ntheorem adjoin_range_\u03b9 : Algebra.adjoin R (Set.range (\u03b9 R : X \u2192 FreeAlgebra R X)) = \u22a4", "start": [582, 1], "end": [590, 69], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_range_eq_range_freeAlgebra_lift", "code": "theorem _root_.Algebra.adjoin_range_eq_range_freeAlgebra_lift (f : X \u2192 A) :\n    Algebra.adjoin R (Set.range f) = (FreeAlgebra.lift R f).range", "start": [594, 1], "end": [598, 27], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_eq_range_freeAlgebra_lift", "code": "theorem _root_.Algebra.adjoin_eq_range_freeAlgebra_lift (s : Set A) :\n    Algebra.adjoin R s = (FreeAlgebra.lift R ((\u2191) : s \u2192 A)).range", "start": [600, 1], "end": [603, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Adjoin/Tower.lean", "imports": ["Mathlib/RingTheory/Adjoin/FG.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Algebra.adjoin_restrictScalars", "code": "theorem adjoin_restrictScalars (C D E : Type*) [CommSemiring C] [CommSemiring D] [CommSemiring E]\n    [Algebra C D] [Algebra C E] [Algebra D E] [IsScalarTower C D E] (S : Set E) :\n    (Algebra.adjoin D S).restrictScalars C =\n      (Algebra.adjoin ((\u22a4 : Subalgebra C D).map (IsScalarTower.toAlgHom C D E)) S).restrictScalars\n        C", "start": [30, 1], "end": [46, 30], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_res_eq_adjoin_res", "code": "theorem adjoin_res_eq_adjoin_res (C D E F : Type*) [CommSemiring C] [CommSemiring D]\n    [CommSemiring E] [CommSemiring F] [Algebra C D] [Algebra C E] [Algebra C F] [Algebra D F]\n    [Algebra E F] [IsScalarTower C D F] [IsScalarTower C E F] {S : Set D} {T : Set E}\n    (hS : Algebra.adjoin C S = \u22a4) (hT : Algebra.adjoin C T = \u22a4) :\n    (Algebra.adjoin E (algebraMap D F '' S)).restrictScalars C =\n      (Algebra.adjoin D (algebraMap E F '' T)).restrictScalars C", "start": [49, 1], "end": [58, 51], "kind": "commanddeclaration"}, {"full_name": "Algebra.fg_trans'", "code": "theorem Algebra.fg_trans' {R S A : Type*} [CommSemiring R] [CommSemiring S] [Semiring A]\n    [Algebra R S] [Algebra S A] [Algebra R A] [IsScalarTower R S A] (hRS : (\u22a4 : Subalgebra R S).FG)\n    (hSA : (\u22a4 : Subalgebra S A).FG) : (\u22a4 : Subalgebra R A).FG", "start": [67, 1], "end": [74, 99], "kind": "commanddeclaration"}, {"full_name": "exists_subalgebra_of_fg", "code": "theorem exists_subalgebra_of_fg (hAC : (\u22a4 : Subalgebra A C).FG) (hBC : (\u22a4 : Submodule B C).FG) :\n    \u2203 B\u2080 : Subalgebra A B, B\u2080.FG \u2227 (\u22a4 : Submodule B\u2080 C).FG", "start": [93, 1], "end": [136, 58], "kind": "commanddeclaration"}, {"full_name": "fg_of_fg_of_fg", "code": "theorem fg_of_fg_of_fg [IsNoetherianRing A] (hAC : (\u22a4 : Subalgebra A C).FG)\n    (hBC : (\u22a4 : Submodule B C).FG) (hBCi : Function.Injective (algebraMap B C)) :\n    (\u22a4 : Subalgebra A B).FG", "start": [147, 1], "end": [161, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "Mathlib/Data/Polynomial/Expand.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Polynomial/Laurent.lean", "Mathlib/RingTheory/Polynomial/Nilpotent.lean"], "premises": [{"full_name": "charmatrix_apply_natDegree", "code": "theorem charmatrix_apply_natDegree [Nontrivial R] (i j : n) :\n    (charmatrix M i j).natDegree = ite (i = j) 1 0", "start": [51, 1], "end": [53, 84], "kind": "commanddeclaration"}, {"full_name": "charmatrix_apply_natDegree_le", "code": "theorem charmatrix_apply_natDegree_le (i j : n) :\n    (charmatrix M i j).natDegree \u2264 ite (i = j) 1 0", "start": [56, 1], "end": [58, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.charpoly_sub_diagonal_degree_lt", "code": "theorem charpoly_sub_diagonal_degree_lt :\n    (M.charpoly - \u220f i : n, (X - C (M i i))).degree < \u2191(Fintype.card n - 1)", "start": [65, 1], "end": [82, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.charpoly_coeff_eq_prod_coeff_of_le", "code": "theorem charpoly_coeff_eq_prod_coeff_of_le {k : \u2115} (h : Fintype.card n - 1 \u2264 k) :\n    M.charpoly.coeff k = (\u220f i : n, (X - C (M i i))).coeff k", "start": [85, 1], "end": [90, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_of_card_zero", "code": "theorem det_of_card_zero (h : Fintype.card n = 0) (M : Matrix n n R) : M.det = 1", "start": [93, 1], "end": [97, 17], "kind": "commanddeclaration"}, {"full_name": "Matrix.charpoly_degree_eq_dim", "code": "theorem charpoly_degree_eq_dim [Nontrivial R] (M : Matrix n n R) :\n    M.charpoly.degree = Fintype.card n", "start": [100, 1], "end": [123, 10], "kind": "commanddeclaration"}, {"full_name": "Matrix.charpoly_natDegree_eq_dim", "code": "@[simp] theorem charpoly_natDegree_eq_dim [Nontrivial R] (M : Matrix n n R) :\n    M.charpoly.natDegree = Fintype.card n", "start": [126, 1], "end": [128, 60], "kind": "commanddeclaration"}, {"full_name": "Matrix.charpoly_monic", "code": "theorem charpoly_monic (M : Matrix n n R) : M.charpoly.Monic", "start": [131, 1], "end": [149, 10], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_eq_neg_charpoly_coeff", "code": "theorem trace_eq_neg_charpoly_coeff [Nonempty n] (M : Matrix n n R) :\n    trace M = -M.charpoly.coeff (Fintype.card n - 1)", "start": [152, 1], "end": [157, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.matPolyEquiv_eval", "code": "theorem matPolyEquiv_eval (M : Matrix n n R[X]) (r : R) (i j : n) :\n    (matPolyEquiv M).eval ((scalar n) r) i j = (M i j).eval r", "start": [161, 1], "end": [180, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.eval_det", "code": "theorem eval_det (M : Matrix n n R[X]) (r : R) :\n    Polynomial.eval r M.det = (Polynomial.eval (scalar n r) (matPolyEquiv M)).det", "start": [183, 1], "end": [190, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_sign_charpoly_coeff", "code": "theorem det_eq_sign_charpoly_coeff (M : Matrix n n R) :\n    M.det = (-1) ^ Fintype.card n * M.charpoly.coeff 0", "start": [193, 1], "end": [196, 7], "kind": "commanddeclaration"}, {"full_name": "matPolyEquiv_eq_x_pow_sub_c", "code": "theorem matPolyEquiv_eq_x_pow_sub_c {K : Type*} (k : \u2115) [Field K] (M : Matrix n n K) :\n    matPolyEquiv ((expand K k : K[X] \u2192+* K[X]).mapMatrix (charmatrix (M ^ k))) =\n      X ^ k - C (M ^ k)", "start": [203, 1], "end": [219, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.aeval_eq_aeval_mod_charpoly", "code": "theorem aeval_eq_aeval_mod_charpoly (M : Matrix n n R) (p : R[X]) :\n    aeval M p = aeval M (p %\u2098 M.charpoly)", "start": [225, 1], "end": [229, 81], "kind": "commanddeclaration"}, {"full_name": "Matrix.pow_eq_aeval_mod_charpoly", "code": "theorem pow_eq_aeval_mod_charpoly (M : Matrix n n R) (k : \u2115) :\n    M ^ k = aeval M (X ^ k %\u2098 M.charpoly)", "start": [232, 1], "end": [236, 101], "kind": "commanddeclaration"}, {"full_name": "coeff_charpoly_mem_ideal_pow", "code": "theorem coeff_charpoly_mem_ideal_pow {I : Ideal R} (h : \u2200 i j, M i j \u2208 I) (k : \u2115) :\n    M.charpoly.coeff k \u2208 I ^ (Fintype.card n - k)", "start": [243, 1], "end": [259, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.charpolyRev", "code": "def charpolyRev (M : Matrix n n R) : R[X] := det (1 - (X : R[X]) \u2022 M.map C)", "start": [271, 1], "end": [276, 76], "kind": "commanddeclaration"}, {"full_name": "Matrix.reverse_charpoly", "code": "lemma reverse_charpoly (M : Matrix n n R) :\n    M.charpoly.reverse = M.charpolyRev := by\n  nontriviality R\n  let t : R[T;T\u207b\u00b9] := T 1\n  let t_inv : R[T;T\u207b\u00b9] := T (-1)\n  let p : R[T;T\u207b\u00b9] := det (scalar n t - M.map LaurentPolynomial.C)\n  let q : R[T;T\u207b\u00b9] := det (1 - scalar n t * M.map LaurentPolynomial.C)\n  have ht : t_inv * t = 1 := by rw [\u2190 T_add, add_left_neg, T_zero]\n  have hp : toLaurentAlg M.charpoly = p := by\n    simp [charpoly, charmatrix, AlgHom.map_det, map_sub, map_smul']\n  have hq : toLaurentAlg M.charpolyRev = q := by\n    simp [charpolyRev, AlgHom.map_det, map_sub, map_smul']\n  suffices : t_inv ^ Fintype.card n * p = invert q\n  \u00b7 apply toLaurent_injective\n    rwa [toLaurent_reverse, \u2190 coe_toLaurentAlg, hp, hq, \u2190 involutive_invert.injective.eq_iff,\n      invert.map_mul, involutive_invert p, charpoly_natDegree_eq_dim,\n      \u2190 mul_one (Fintype.card n : \u2124), \u2190 T_pow, invert.map_pow, invert_T, mul_comm]\n  rw [\u2190 det_smul, smul_sub, coe_scalar, \u2190 smul_assoc, smul_eq_mul, ht, one_smul, invert.map_det]\n  simp [map_smul']", "start": [278, 1], "end": [296, 19], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.eval_charpolyRev", "code": "@[simp] lemma eval_charpolyRev :\n    eval 0 M.charpolyRev = 1 := by\n  rw [charpolyRev, \u2190 coe_evalRingHom, RingHom.map_det, \u2190 det_one (R := R) (n := n)]\n  have : (1 - (X : R[X]) \u2022 M.map C).map (eval 0) = 1 := by\n    ext i j; cases' eq_or_ne i j with hij hij <;> simp [hij]\n  congr", "start": [298, 1], "end": [303, 8], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.coeff_charpolyRev_eq_neg_trace", "code": "@[simp] lemma coeff_charpolyRev_eq_neg_trace (M : Matrix n n R) :\n    coeff M.charpolyRev 1 = - trace M := by\n  nontriviality R\n  cases isEmpty_or_nonempty n\n  \u00b7 simp [charpolyRev, coeff_one]\n  \u00b7 simp [trace_eq_neg_charpoly_coeff M, \u2190 M.reverse_charpoly, nextCoeff]", "start": [305, 1], "end": [310, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.isUnit_charpolyRev_of_isNilpotent", "code": "lemma isUnit_charpolyRev_of_isNilpotent (hM : IsNilpotent M) :\n    IsUnit M.charpolyRev := by\n  obtain \u27e8k, hk\u27e9 := hM\n  replace hk : 1 - (X : R[X]) \u2022 M.map C \u2223 1 := by\n    convert one_sub_dvd_one_sub_pow ((X : R[X]) \u2022 M.map C) k\n    rw [\u2190 C.mapMatrix_apply, smul_pow, \u2190 map_pow, hk, map_zero, smul_zero, sub_zero]\n  apply isUnit_of_dvd_one\n  rw [\u2190 det_one (R := R[X]) (n := n)]\n  exact map_dvd detMonoidHom hk", "start": [312, 1], "end": [320, 32], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.isNilpotent_trace_of_isNilpotent", "code": "lemma isNilpotent_trace_of_isNilpotent (hM : IsNilpotent M) :\n    IsNilpotent (trace M) := by\n  cases isEmpty_or_nonempty n\n  \u00b7 simp\n  suffices IsNilpotent (coeff (charpolyRev M) 1) by simpa using this\n  exact (isUnit_iff_coeff_isUnit_isNilpotent.mp (isUnit_charpolyRev_of_isNilpotent hM)).2\n    _ one_ne_zero", "start": [322, 1], "end": [328, 18], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.isNilpotent_charpoly_sub_pow_of_isNilpotent", "code": "lemma isNilpotent_charpoly_sub_pow_of_isNilpotent (hM : IsNilpotent M) :\n    IsNilpotent (M.charpoly - X ^ (Fintype.card n)) := by\n  nontriviality R\n  let p : R[X] := M.charpolyRev\n  have hp : p - 1 = X * (p /\u2098 X) := by\n    conv_lhs => rw [\u2190 modByMonic_add_div p monic_X]\n    simp [modByMonic_X]\n  have : IsNilpotent (p /\u2098 X) :=\n    (Polynomial.isUnit_iff'.mp (isUnit_charpolyRev_of_isNilpotent hM)).2\n  have aux : (M.charpoly - X ^ (Fintype.card n)).natDegree \u2264 M.charpoly.natDegree :=\n    le_trans (natDegree_sub_le _ _) (by simp)\n  rw [\u2190 isNilpotent_reflect_iff aux, reflect_sub, \u2190 reverse, M.reverse_charpoly]\n  simpa [hp]", "start": [330, 1], "end": [342, 13], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean", "imports": ["Mathlib/CategoryTheory/EpiMono.lean", "Mathlib/CategoryTheory/Limits/HasLimits.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.WalkingParallelPair", "code": "inductive WalkingParallelPair : Type\n  | zero\n  | one\n  deriving DecidableEq, Inhabited", "start": [60, 1], "end": [64, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingParallelPairHom", "code": "inductive WalkingParallelPairHom : WalkingParallelPair \u2192 WalkingParallelPair \u2192 Type\n  | left : WalkingParallelPairHom zero one\n  | right : WalkingParallelPairHom zero one\n  | id (X : WalkingParallelPair) : WalkingParallelPairHom X X\n  deriving DecidableEq", "start": [69, 1], "end": [74, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingParallelPairHom.comp", "code": "def WalkingParallelPairHom.comp :\n    \u2200 { X Y Z : WalkingParallelPair } (_ : WalkingParallelPairHom X Y)\n      (_ : WalkingParallelPairHom Y Z), WalkingParallelPairHom X Z\n  | _, _, _, id _, h => h\n  | _, _, _, left, id one => left\n  | _, _, _, right, id one => right", "start": [86, 1], "end": [93, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingParallelPairHom.id_comp", "code": "theorem WalkingParallelPairHom.id_comp\n    {X Y : WalkingParallelPair} (g : WalkingParallelPairHom X Y) : comp (id X) g = g", "start": [97, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingParallelPairHom.comp_id", "code": "theorem WalkingParallelPairHom.comp_id\n    {X Y : WalkingParallelPair} (f : WalkingParallelPairHom X Y) : comp f (id Y) = f", "start": [101, 1], "end": [103, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingParallelPairHom.assoc", "code": "theorem WalkingParallelPairHom.assoc {X Y Z W : WalkingParallelPair}\n    (f : WalkingParallelPairHom X Y) (g: WalkingParallelPairHom Y Z)\n    (h : WalkingParallelPairHom Z W) : comp (comp f g) h = comp f (comp g h)", "start": [105, 1], "end": [108, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingParallelPairHomCategory", "code": "instance walkingParallelPairHomCategory : SmallCategory WalkingParallelPair where\n  Hom := WalkingParallelPairHom\n  id := id\n  comp := comp\n  comp_id := comp_id\n  id_comp := id_comp\n  assoc := assoc", "start": [110, 1], "end": [116, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingParallelPairHom_id", "code": "@[simp]\ntheorem walkingParallelPairHom_id (X : WalkingParallelPair) : WalkingParallelPairHom.id X = \ud835\udfd9 X", "start": [119, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingParallelPairHom.id.sizeOf_spec'", "code": "@[simp]\ntheorem WalkingParallelPairHom.id.sizeOf_spec' (X : WalkingParallelPair) :\n    (WalkingParallelPairHom._sizeOf_inst X X).sizeOf (\ud835\udfd9 X) = 1 + sizeOf X", "start": [125, 1], "end": [127, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingParallelPairOp", "code": "def walkingParallelPairOp : WalkingParallelPair \u2964 WalkingParallelPair\u1d52\u1d56 where\n  obj x := op <| by cases x; exacts [one, zero]\n  map f := by\n    cases f <;> apply Quiver.Hom.op\n    exacts [left, right, WalkingParallelPairHom.id _]\n  map_comp := by rintro _ _ _ (_|_|_) g <;> cases g <;> rfl", "start": [129, 1], "end": [137, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingParallelPairOp_zero", "code": "@[simp]\ntheorem walkingParallelPairOp_zero : walkingParallelPairOp.obj zero = op one", "start": [140, 1], "end": [141, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingParallelPairOp_one", "code": "@[simp]\ntheorem walkingParallelPairOp_one : walkingParallelPairOp.obj one = op zero", "start": [144, 1], "end": [145, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingParallelPairOp_left", "code": "@[simp]\ntheorem walkingParallelPairOp_left :\n    walkingParallelPairOp.map left = @Quiver.Hom.op _ _ zero one left", "start": [148, 1], "end": [150, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingParallelPairOp_right", "code": "@[simp]\ntheorem walkingParallelPairOp_right :\n    walkingParallelPairOp.map right = @Quiver.Hom.op _ _ zero one right", "start": [153, 1], "end": [155, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingParallelPairOpEquiv", "code": "@[simps functor inverse]\ndef walkingParallelPairOpEquiv : WalkingParallelPair \u224c WalkingParallelPair\u1d52\u1d56 where\n  functor := walkingParallelPairOp\n  inverse := walkingParallelPairOp.leftOp\n  unitIso :=\n    NatIso.ofComponents (fun j => eqToIso (by cases j <;> rfl))\n      (by rintro _ _ (_ | _ | _) <;> simp)\n  counitIso :=\n    NatIso.ofComponents (fun j => eqToIso (by\n            induction' j with X\n            cases X <;> rfl))\n      (fun {i} {j} f => by\n      induction' i with i\n      induction' j with j\n      let g := f.unop\n      have : f = g.op := rfl\n      rw [this]\n      cases i <;> cases j <;> cases g <;> rfl)\n  functor_unitIso_comp := fun j => by cases j <;> rfl", "start": [158, 1], "end": [180, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingParallelPairOpEquiv_unitIso_zero", "code": "@[simp]\ntheorem walkingParallelPairOpEquiv_unitIso_zero :\n    walkingParallelPairOpEquiv.unitIso.app zero = Iso.refl zero", "start": [183, 1], "end": [185, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingParallelPairOpEquiv_unitIso_one", "code": "@[simp]\ntheorem walkingParallelPairOpEquiv_unitIso_one :\n    walkingParallelPairOpEquiv.unitIso.app one = Iso.refl one", "start": [188, 1], "end": [190, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingParallelPairOpEquiv_counitIso_zero", "code": "@[simp]\ntheorem walkingParallelPairOpEquiv_counitIso_zero :\n    walkingParallelPairOpEquiv.counitIso.app (op zero) = Iso.refl (op zero)", "start": [193, 1], "end": [195, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingParallelPairOpEquiv_counitIso_one", "code": "@[simp]\ntheorem walkingParallelPairOpEquiv_counitIso_one :\n    walkingParallelPairOpEquiv.counitIso.app (op one) = Iso.refl (op one)", "start": [198, 1], "end": [201, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelPair", "code": "def parallelPair (f g : X \u27f6 Y) : WalkingParallelPair \u2964 C where\n  obj x :=\n    match x with\n    | zero => X\n    | one => Y\n  map h :=\n    match h with\n    | WalkingParallelPairHom.id _ => \ud835\udfd9 _\n    | left => f\n    | right => g\n  map_comp := by\n    rintro _ _ _ \u27e8\u27e9 g <;> cases g <;> {dsimp; simp}", "start": [208, 1], "end": [222, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelPair_obj_zero", "code": "@[simp]\ntheorem parallelPair_obj_zero (f g : X \u27f6 Y) : (parallelPair f g).obj zero = X", "start": [225, 1], "end": [226, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelPair_obj_one", "code": "@[simp]\ntheorem parallelPair_obj_one (f g : X \u27f6 Y) : (parallelPair f g).obj one = Y", "start": [229, 1], "end": [230, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelPair_map_left", "code": "@[simp]\ntheorem parallelPair_map_left (f g : X \u27f6 Y) : (parallelPair f g).map left = f", "start": [233, 1], "end": [234, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelPair_map_right", "code": "@[simp]\ntheorem parallelPair_map_right (f g : X \u27f6 Y) : (parallelPair f g).map right = g", "start": [237, 1], "end": [238, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelPair_functor_obj", "code": "@[simp]\ntheorem parallelPair_functor_obj {F : WalkingParallelPair \u2964 C} (j : WalkingParallelPair) :\n    (parallelPair (F.map left) (F.map right)).obj j = F.obj j", "start": [241, 1], "end": [243, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.diagramIsoParallelPair", "code": "@[simps!]\ndef diagramIsoParallelPair (F : WalkingParallelPair \u2964 C) :\n    F \u2245 parallelPair (F.map left) (F.map right) :=\n  NatIso.ofComponents (fun j => eqToIso <| by cases j <;> rfl) (by rintro _ _ (_|_|_) <;> simp)", "start": [246, 1], "end": [251, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelPairHom", "code": "def parallelPairHom {X' Y' : C} (f g : X \u27f6 Y) (f' g' : X' \u27f6 Y') (p : X \u27f6 X') (q : Y \u27f6 Y')\n    (wf : f \u226b q = p \u226b f') (wg : g \u226b q = p \u226b g') : parallelPair f g \u27f6 parallelPair f' g'\n    where\n  app j :=\n    match j with\n    | zero => p\n    | one => q\n  naturality := by\n    rintro _ _ \u27e8\u27e9 <;> {dsimp; simp [wf,wg]}", "start": [254, 1], "end": [263, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelPairHom_app_zero", "code": "@[simp]\ntheorem parallelPairHom_app_zero {X' Y' : C} (f g : X \u27f6 Y) (f' g' : X' \u27f6 Y') (p : X \u27f6 X')\n    (q : Y \u27f6 Y') (wf : f \u226b q = p \u226b f') (wg : g \u226b q = p \u226b g') :\n    (parallelPairHom f g f' g' p q wf wg).app zero = p", "start": [266, 1], "end": [270, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelPairHom_app_one", "code": "@[simp]\ntheorem parallelPairHom_app_one {X' Y' : C} (f g : X \u27f6 Y) (f' g' : X' \u27f6 Y') (p : X \u27f6 X')\n    (q : Y \u27f6 Y') (wf : f \u226b q = p \u226b f') (wg : g \u226b q = p \u226b g') :\n    (parallelPairHom f g f' g' p q wf wg).app one = q", "start": [273, 1], "end": [277, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelPair.ext", "code": "@[simps!]\ndef parallelPair.ext {F G : WalkingParallelPair \u2964 C} (zero : F.obj zero \u2245 G.obj zero)\n    (one : F.obj one \u2245 G.obj one) (left : F.map left \u226b one.hom = zero.hom \u226b G.map left)\n    (right : F.map right \u226b one.hom = zero.hom \u226b G.map right) : F \u2245 G :=\n  NatIso.ofComponents\n    (by\n      rintro \u27e8j\u27e9\n      exacts [zero, one])\n    (by rintro _ _ \u27e8_\u27e9 <;> simp [left, right])", "start": [280, 1], "end": [290, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelPair.eqOfHomEq", "code": "@[simps!]\ndef parallelPair.eqOfHomEq {f g f' g' : X \u27f6 Y} (hf : f = f') (hg : g = g') :\n    parallelPair f g \u2245 parallelPair f' g' :=\n  parallelPair.ext (Iso.refl _) (Iso.refl _) (by simp [hf]) (by simp [hg])", "start": [293, 1], "end": [298, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork", "code": "abbrev Fork (f g : X \u27f6 Y) :=\n  Cone (parallelPair f g)", "start": [301, 1], "end": [303, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork", "code": "abbrev Cofork (f g : X \u27f6 Y) :=\n  Cocone (parallelPair f g)", "start": [306, 1], "end": [308, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.\u03b9", "code": "def Fork.\u03b9 (t : Fork f g) :=\n  t.\u03c0.app zero", "start": [313, 1], "end": [318, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.app_zero_eq_\u03b9", "code": "@[simp]\ntheorem Fork.app_zero_eq_\u03b9 (t : Fork f g) : t.\u03c0.app zero = t.\u03b9", "start": [321, 1], "end": [323, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.\u03c0", "code": "def Cofork.\u03c0 (t : Cofork f g) :=\n  t.\u03b9.app one", "start": [326, 1], "end": [330, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.app_one_eq_\u03c0", "code": "@[simp]\ntheorem Cofork.app_one_eq_\u03c0 (t : Cofork f g) : t.\u03b9.app one = t.\u03c0", "start": [333, 1], "end": [335, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.app_one_eq_\u03b9_comp_left", "code": "@[simp]\ntheorem Fork.app_one_eq_\u03b9_comp_left (s : Fork f g) : s.\u03c0.app one = s.\u03b9 \u226b f", "start": [338, 1], "end": [340, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.app_one_eq_\u03b9_comp_right", "code": "@[reassoc]\ntheorem Fork.app_one_eq_\u03b9_comp_right (s : Fork f g) : s.\u03c0.app one = s.\u03b9 \u226b g", "start": [343, 1], "end": [345, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.app_zero_eq_comp_\u03c0_left", "code": "@[simp]\ntheorem Cofork.app_zero_eq_comp_\u03c0_left (s : Cofork f g) : s.\u03b9.app zero = f \u226b s.\u03c0", "start": [348, 1], "end": [350, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.app_zero_eq_comp_\u03c0_right", "code": "@[reassoc]\ntheorem Cofork.app_zero_eq_comp_\u03c0_right (s : Cofork f g) : s.\u03b9.app zero = g \u226b s.\u03c0", "start": [353, 1], "end": [355, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.of\u03b9", "code": "@[simps]\ndef Fork.of\u03b9 {P : C} (\u03b9 : P \u27f6 X) (w : \u03b9 \u226b f = \u03b9 \u226b g) : Fork f g where\n  pt := P\n  \u03c0 :=\n    { app := fun X => by cases X; exact \u03b9; exact \u03b9 \u226b f\n      naturality := fun {X} {Y} f =>\n        by cases X <;> cases Y <;> cases f <;> dsimp <;> simp; assumption }", "start": [358, 1], "end": [366, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.of\u03c0", "code": "@[simps]\ndef Cofork.of\u03c0 {P : C} (\u03c0 : Y \u27f6 P) (w : f \u226b \u03c0 = g \u226b \u03c0) : Cofork f g where\n  pt := P\n  \u03b9 :=\n    { app := fun X => WalkingParallelPair.casesOn X (f \u226b \u03c0) \u03c0\n      naturality := fun i j f => by cases f <;> dsimp <;> simp [w] }", "start": [369, 1], "end": [376, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.\u03b9_of\u03b9", "code": "@[simp]\ntheorem Fork.\u03b9_of\u03b9 {P : C} (\u03b9 : P \u27f6 X) (w : \u03b9 \u226b f = \u03b9 \u226b g) : (Fork.of\u03b9 \u03b9 w).\u03b9 = \u03b9", "start": [380, 1], "end": [382, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.\u03c0_of\u03c0", "code": "@[simp]\ntheorem Cofork.\u03c0_of\u03c0 {P : C} (\u03c0 : Y \u27f6 P) (w : f \u226b \u03c0 = g \u226b \u03c0) : (Cofork.of\u03c0 \u03c0 w).\u03c0 = \u03c0", "start": [385, 1], "end": [387, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.condition", "code": "@[reassoc (attr := simp)]\ntheorem Fork.condition (t : Fork f g) : t.\u03b9 \u226b f = t.\u03b9 \u226b g", "start": [390, 1], "end": [392, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.condition", "code": "@[reassoc (attr := simp)]\ntheorem Cofork.condition (t : Cofork f g) : f \u226b t.\u03c0 = g \u226b t.\u03c0", "start": [395, 1], "end": [397, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.equalizer_ext", "code": "theorem Fork.equalizer_ext (s : Fork f g) {W : C} {k l : W \u27f6 s.pt} (h : k \u226b s.\u03b9 = l \u226b s.\u03b9) :\n    \u2200 j : WalkingParallelPair, k \u226b s.\u03c0.app j = l \u226b s.\u03c0.app j", "start": [400, 1], "end": [408, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.coequalizer_ext", "code": "theorem Cofork.coequalizer_ext (s : Cofork f g) {W : C} {k l : s.pt \u27f6 W}\n    (h : Cofork.\u03c0 s \u226b k = Cofork.\u03c0 s \u226b l) : \u2200 j : WalkingParallelPair, s.\u03b9.app j \u226b k = s.\u03b9.app j \u226b l", "start": [411, 1], "end": [416, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.IsLimit.hom_ext", "code": "theorem Fork.IsLimit.hom_ext {s : Fork f g} (hs : IsLimit s) {W : C} {k l : W \u27f6 s.pt}\n    (h : k \u226b Fork.\u03b9 s = l \u226b Fork.\u03b9 s) : k = l", "start": [419, 1], "end": [421, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.IsColimit.hom_ext", "code": "theorem Cofork.IsColimit.hom_ext {s : Cofork f g} (hs : IsColimit s) {W : C} {k l : s.pt \u27f6 W}\n    (h : Cofork.\u03c0 s \u226b k = Cofork.\u03c0 s \u226b l) : k = l", "start": [424, 1], "end": [426, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.IsLimit.lift_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem Fork.IsLimit.lift_\u03b9 {s t : Fork f g} (hs : IsLimit s) : hs.lift t \u226b s.\u03b9 = t.\u03b9", "start": [429, 1], "end": [431, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.IsColimit.\u03c0_desc", "code": "@[reassoc (attr := simp)]\ntheorem Cofork.IsColimit.\u03c0_desc {s t : Cofork f g} (hs : IsColimit s) : s.\u03c0 \u226b hs.desc t = t.\u03c0", "start": [434, 1], "end": [436, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.IsLimit.lift", "code": "def Fork.IsLimit.lift {s : Fork f g} (hs : IsLimit s) {W : C} (k : W \u27f6 X) (h : k \u226b f = k \u226b g) :\n    W \u27f6 s.pt :=\n  hs.lift (Fork.of\u03b9 _ h)", "start": [440, 1], "end": [444, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.IsLimit.lift_\u03b9'", "code": "@[reassoc (attr := simp)]\nlemma Fork.IsLimit.lift_\u03b9' {s : Fork f g} (hs : IsLimit s) {W : C} (k : W \u27f6 X) (h : k \u226b f = k \u226b g) :\n    Fork.IsLimit.lift hs k h \u226b Fork.\u03b9 s = k :=\n    hs.fac _ _", "start": [446, 1], "end": [449, 15], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Fork.IsLimit.lift'", "code": "def Fork.IsLimit.lift' {s : Fork f g} (hs : IsLimit s) {W : C} (k : W \u27f6 X) (h : k \u226b f = k \u226b g) :\n    { l : W \u27f6 s.pt // l \u226b Fork.\u03b9 s = k } :=\n  \u27e8Fork.IsLimit.lift hs k h, by simp\u27e9", "start": [451, 1], "end": [455, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.IsColimit.desc", "code": "def Cofork.IsColimit.desc {s : Cofork f g} (hs : IsColimit s) {W : C} (k : Y \u27f6 W)\n    (h : f \u226b k = g \u226b k) : s.pt \u27f6 W :=\n  hs.desc (Cofork.of\u03c0 _ h)", "start": [459, 1], "end": [463, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.IsColimit.\u03c0_desc'", "code": "@[reassoc (attr := simp)]\nlemma Cofork.IsColimit.\u03c0_desc' {s : Cofork f g} (hs : IsColimit s) {W : C} (k : Y \u27f6 W)\n    (h : f \u226b k = g \u226b k) : Cofork.\u03c0 s \u226b Cofork.IsColimit.desc hs k h = k :=\n  hs.fac _ _", "start": [465, 1], "end": [468, 13], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Cofork.IsColimit.desc'", "code": "def Cofork.IsColimit.desc' {s : Cofork f g} (hs : IsColimit s) {W : C} (k : Y \u27f6 W)\n    (h : f \u226b k = g \u226b k) : { l : s.pt \u27f6 W // Cofork.\u03c0 s \u226b l = k } :=\n  \u27e8Cofork.IsColimit.desc hs k h, by simp\u27e9", "start": [470, 1], "end": [474, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.IsLimit.existsUnique", "code": "theorem Fork.IsLimit.existsUnique {s : Fork f g} (hs : IsLimit s) {W : C} (k : W \u27f6 X)\n    (h : k \u226b f = k \u226b g) : \u2203! l : W \u27f6 s.pt, l \u226b Fork.\u03b9 s = k", "start": [477, 1], "end": [480, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.IsColimit.existsUnique", "code": "theorem Cofork.IsColimit.existsUnique {s : Cofork f g} (hs : IsColimit s) {W : C} (k : Y \u27f6 W)\n    (h : f \u226b k = g \u226b k) : \u2203! d : s.pt \u27f6 W, Cofork.\u03c0 s \u226b d = k", "start": [483, 1], "end": [486, 101], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.IsLimit.mk", "code": "@[simps]\ndef Fork.IsLimit.mk (t : Fork f g) (lift : \u2200 s : Fork f g, s.pt \u27f6 t.pt)\n    (fac : \u2200 s : Fork f g, lift s \u226b Fork.\u03b9 t = Fork.\u03b9 s)\n    (uniq : \u2200 (s : Fork f g) (m : s.pt \u27f6 t.pt) (_ : m \u226b t.\u03b9 = s.\u03b9), m = lift s) : IsLimit t :=\n  { lift\n    fac := fun s j =>\n      WalkingParallelPair.casesOn j (fac s) <| by\n        erw [\u2190 s.w left, \u2190 t.w left, \u2190 Category.assoc, fac]; rfl\n    uniq := fun s m j => by aesop}", "start": [489, 1], "end": [499, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.IsLimit.mk'", "code": "def Fork.IsLimit.mk' {X Y : C} {f g : X \u27f6 Y} (t : Fork f g)\n    (create : \u2200 s : Fork f g, { l // l \u226b t.\u03b9 = s.\u03b9 \u2227 \u2200 {m}, m \u226b t.\u03b9 = s.\u03b9 \u2192 m = l }) : IsLimit t :=\n  Fork.IsLimit.mk t (fun s => (create s).1) (fun s => (create s).2.1) fun s _ w => (create s).2.2 w", "start": [502, 1], "end": [507, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.IsColimit.mk", "code": "def Cofork.IsColimit.mk (t : Cofork f g) (desc : \u2200 s : Cofork f g, t.pt \u27f6 s.pt)\n    (fac : \u2200 s : Cofork f g, Cofork.\u03c0 t \u226b desc s = Cofork.\u03c0 s)\n    (uniq : \u2200 (s : Cofork f g) (m : t.pt \u27f6 s.pt) (_ : t.\u03c0 \u226b m = s.\u03c0), m = desc s) : IsColimit t :=\n  { desc\n    fac := fun s j =>\n      WalkingParallelPair.casesOn j (by erw [\u2190 s.w left, \u2190 t.w left, Category.assoc, fac]; rfl)\n        (fac s)\n    uniq := by aesop }", "start": [510, 1], "end": [519, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.IsColimit.mk'", "code": "def Cofork.IsColimit.mk' {X Y : C} {f g : X \u27f6 Y} (t : Cofork f g)\n    (create : \u2200 s : Cofork f g, { l : t.pt \u27f6 s.pt // t.\u03c0 \u226b l = s.\u03c0\n                                    \u2227 \u2200 {m}, t.\u03c0 \u226b m = s.\u03c0 \u2192 m = l }) : IsColimit t :=\n  Cofork.IsColimit.mk t (fun s => (create s).1) (fun s => (create s).2.1) fun s _ w =>\n    (create s).2.2 w", "start": [522, 1], "end": [529, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.IsLimit.ofExistsUnique", "code": "noncomputable def Fork.IsLimit.ofExistsUnique {t : Fork f g}\n    (hs : \u2200 s : Fork f g, \u2203! l : s.pt \u27f6 t.pt, l \u226b Fork.\u03b9 t = Fork.\u03b9 s) : IsLimit t := by\n  choose d hd hd' using hs\n  exact Fork.IsLimit.mk _ d hd fun s m hm => hd' _ _ hm", "start": [532, 1], "end": [536, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.IsColimit.ofExistsUnique", "code": "noncomputable def Cofork.IsColimit.ofExistsUnique {t : Cofork f g}\n    (hs : \u2200 s : Cofork f g, \u2203! d : t.pt \u27f6 s.pt, Cofork.\u03c0 t \u226b d = Cofork.\u03c0 s) : IsColimit t := by\n  choose d hd hd' using hs\n  exact Cofork.IsColimit.mk _ d hd fun s m hm => hd' _ _ hm", "start": [539, 1], "end": [543, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.IsLimit.homIso", "code": "@[simps]\ndef Fork.IsLimit.homIso {X Y : C} {f g : X \u27f6 Y} {t : Fork f g} (ht : IsLimit t) (Z : C) :\n    (Z \u27f6 t.pt) \u2243 { h : Z \u27f6 X // h \u226b f = h \u226b g } where\n  toFun k := \u27e8k \u226b t.\u03b9, by simp only [Category.assoc, t.condition]\u27e9\n  invFun h := (Fork.IsLimit.lift' ht _ h.prop).1\n  left_inv k := Fork.IsLimit.hom_ext ht (Fork.IsLimit.lift' _ _ _).prop\n  right_inv h := Subtype.ext (Fork.IsLimit.lift' ht _ _).prop", "start": [546, 1], "end": [558, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.IsLimit.homIso_natural", "code": "theorem Fork.IsLimit.homIso_natural {X Y : C} {f g : X \u27f6 Y} {t : Fork f g} (ht : IsLimit t)\n    {Z Z' : C} (q : Z' \u27f6 Z) (k : Z \u27f6 t.pt) :\n    (Fork.IsLimit.homIso ht _ (q \u226b k) : Z' \u27f6 X) = q \u226b (Fork.IsLimit.homIso ht _ k : Z \u27f6 X)", "start": [561, 1], "end": [565, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.IsColimit.homIso", "code": "@[simps]\ndef Cofork.IsColimit.homIso {X Y : C} {f g : X \u27f6 Y} {t : Cofork f g} (ht : IsColimit t) (Z : C) :\n    (t.pt \u27f6 Z) \u2243 { h : Y \u27f6 Z // f \u226b h = g \u226b h } where\n  toFun k := \u27e8t.\u03c0 \u226b k, by simp only [\u2190 Category.assoc, t.condition]\u27e9\n  invFun h := (Cofork.IsColimit.desc' ht _ h.prop).1\n  left_inv k := Cofork.IsColimit.hom_ext ht (Cofork.IsColimit.desc' _ _ _).prop\n  right_inv h := Subtype.ext (Cofork.IsColimit.desc' ht _ _).prop", "start": [568, 1], "end": [579, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.IsColimit.homIso_natural", "code": "theorem Cofork.IsColimit.homIso_natural {X Y : C} {f g : X \u27f6 Y} {t : Cofork f g} {Z Z' : C}\n    (q : Z \u27f6 Z') (ht : IsColimit t) (k : t.pt \u27f6 Z) :\n    (Cofork.IsColimit.homIso ht _ (k \u226b q) : Y \u27f6 Z') =\n      (Cofork.IsColimit.homIso ht _ k : Y \u27f6 Z) \u226b q", "start": [582, 1], "end": [587, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.ofFork", "code": "def Cone.ofFork {F : WalkingParallelPair \u2964 C} (t : Fork (F.map left) (F.map right)) : Cone F\n    where\n  pt := t.pt\n  \u03c0 :=\n    { app := fun X => t.\u03c0.app X \u226b eqToHom (by aesop)\n      naturality := by rintro _ _ (_|_|_) <;> {dsimp; simp [t.condition]}}", "start": [590, 1], "end": [602, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.ofCofork", "code": "def Cocone.ofCofork {F : WalkingParallelPair \u2964 C} (t : Cofork (F.map left) (F.map right)) : Cocone F\n    where\n  pt := t.pt\n  \u03b9 :=\n    { app := fun X => eqToHom (by aesop) \u226b t.\u03b9.app X\n      naturality := by rintro _ _ (_|_|_) <;> {dsimp; simp [t.condition]}}", "start": [605, 1], "end": [618, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.ofFork_\u03c0", "code": "@[simp]\ntheorem Cone.ofFork_\u03c0 {F : WalkingParallelPair \u2964 C} (t : Fork (F.map left) (F.map right)) (j) :\n    (Cone.ofFork t).\u03c0.app j = t.\u03c0.app j \u226b eqToHom (by aesop)", "start": [621, 1], "end": [623, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.ofCofork_\u03b9", "code": "@[simp]\ntheorem Cocone.ofCofork_\u03b9 {F : WalkingParallelPair \u2964 C} (t : Cofork (F.map left) (F.map right))\n    (j) : (Cocone.ofCofork t).\u03b9.app j = eqToHom (by aesop) \u226b t.\u03b9.app j", "start": [626, 1], "end": [628, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.ofCone", "code": "def Fork.ofCone {F : WalkingParallelPair \u2964 C} (t : Cone F) : Fork (F.map left) (F.map right)\n    where\n  pt := t.pt\n  \u03c0 := { app := fun X => t.\u03c0.app X \u226b eqToHom (by aesop)\n         naturality := by rintro _ _ (_|_|_) <;> {dsimp; simp}}", "start": [631, 1], "end": [638, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.ofCocone", "code": "def Cofork.ofCocone {F : WalkingParallelPair \u2964 C} (t : Cocone F) : Cofork (F.map left) (F.map right)\n    where\n  pt := t.pt\n  \u03b9 := { app := fun X => eqToHom (by aesop) \u226b t.\u03b9.app X\n         naturality := by rintro _ _ (_|_|_) <;> {dsimp; simp}}", "start": [641, 1], "end": [648, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.ofCone_\u03c0", "code": "@[simp]\ntheorem Fork.ofCone_\u03c0 {F : WalkingParallelPair \u2964 C} (t : Cone F) (j) :\n    (Fork.ofCone t).\u03c0.app j = t.\u03c0.app j \u226b eqToHom (by aesop)", "start": [651, 1], "end": [653, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.ofCocone_\u03b9", "code": "@[simp]\ntheorem Cofork.ofCocone_\u03b9 {F : WalkingParallelPair \u2964 C} (t : Cocone F) (j) :\n    (Cofork.ofCocone t).\u03b9.app j = eqToHom (by aesop) \u226b t.\u03b9.app j", "start": [656, 1], "end": [658, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.\u03b9_postcompose", "code": "@[simp]\ntheorem Fork.\u03b9_postcompose {f' g' : X \u27f6 Y} {\u03b1 : parallelPair f g \u27f6 parallelPair f' g'}\n    {c : Fork f g} : Fork.\u03b9 ((Cones.postcompose \u03b1).obj c) = c.\u03b9 \u226b \u03b1.app _", "start": [661, 1], "end": [664, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.\u03c0_precompose", "code": "@[simp]\ntheorem Cofork.\u03c0_precompose {f' g' : X \u27f6 Y} {\u03b1 : parallelPair f g \u27f6 parallelPair f' g'}\n    {c : Cofork f' g'} : Cofork.\u03c0 ((Cocones.precompose \u03b1).obj c) = \u03b1.app _ \u226b c.\u03c0", "start": [667, 1], "end": [670, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.mkHom", "code": "@[simps]\ndef Fork.mkHom {s t : Fork f g} (k : s.pt \u27f6 t.pt) (w : k \u226b t.\u03b9 = s.\u03b9) : s \u27f6 t where\n  hom := k\n  w := by\n    rintro \u27e8_ | _\u27e9\n    \u00b7 exact w\n    \u00b7 simp only [Fork.app_one_eq_\u03b9_comp_left,\u2190 Category.assoc]\n      congr", "start": [673, 1], "end": [682, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.ext", "code": "@[simps]\ndef Fork.ext {s t : Fork f g} (i : s.pt \u2245 t.pt) (w : i.hom \u226b t.\u03b9 = s.\u03b9 := by aesop_cat) :\n    s \u2245 t where\n  hom := Fork.mkHom i.hom w\n  inv := Fork.mkHom i.inv (by rw [\u2190 w, Iso.inv_hom_id_assoc])", "start": [685, 1], "end": [693, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.isoForkOf\u03b9", "code": "def Fork.isoForkOf\u03b9 (c : Fork f g) : c \u2245 Fork.of\u03b9 c.\u03b9 c.condition :=\n  Fork.ext (by simp only [Fork.of\u03b9_pt, Functor.const_obj_obj]; rfl) (by simp)", "start": [696, 1], "end": [698, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.mkHom", "code": "@[simps]\ndef Cofork.mkHom {s t : Cofork f g} (k : s.pt \u27f6 t.pt) (w : s.\u03c0 \u226b k = t.\u03c0) : s \u27f6 t where\n  hom := k\n  w := by\n    rintro \u27e8_ | _\u27e9\n    \u00b7 simp [Cofork.app_zero_eq_comp_\u03c0_left, w]\n    \u00b7 exact w", "start": [701, 1], "end": [709, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.hom_comp_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem Fork.hom_comp_\u03b9 {s t : Fork f g} (f : s \u27f6 t) : f.hom \u226b t.\u03b9 = s.\u03b9", "start": [712, 1], "end": [714, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fork.\u03c0_comp_hom", "code": "@[reassoc (attr := simp)]\ntheorem Fork.\u03c0_comp_hom {s t : Cofork f g} (f : s \u27f6 t) : s.\u03c0 \u226b f.hom = t.\u03c0", "start": [717, 1], "end": [719, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.ext", "code": "@[simps]\ndef Cofork.ext {s t : Cofork f g} (i : s.pt \u2245 t.pt) (w : s.\u03c0 \u226b i.hom = t.\u03c0 := by aesop_cat) :\n    s \u2245 t where\n  hom := Cofork.mkHom i.hom w\n  inv := Cofork.mkHom i.inv (by rw [Iso.comp_inv_eq, w])", "start": [722, 1], "end": [730, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofork.isoCoforkOf\u03c0", "code": "def Cofork.isoCoforkOf\u03c0 (c : Cofork f g) : c \u2245 Cofork.of\u03c0 c.\u03c0 c.condition :=\n  Cofork.ext (by simp only [Cofork.of\u03c0_pt, Functor.const_obj_obj]; rfl) (by dsimp; simp)", "start": [733, 1], "end": [735, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasEqualizer", "code": "abbrev HasEqualizer :=\n  HasLimit (parallelPair f g)", "start": [742, 1], "end": [746, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer", "code": "noncomputable abbrev equalizer : C :=\n  limit (parallelPair f g)", "start": [751, 1], "end": [754, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.\u03b9", "code": "noncomputable abbrev equalizer.\u03b9 : equalizer f g \u27f6 X :=\n  limit.\u03c0 (parallelPair f g) zero", "start": [757, 1], "end": [760, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.fork", "code": "noncomputable abbrev equalizer.fork : Fork f g :=\n  limit.cone (parallelPair f g)", "start": [763, 1], "end": [765, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.fork_\u03b9", "code": "@[simp]\ntheorem equalizer.fork_\u03b9 : (equalizer.fork f g).\u03b9 = equalizer.\u03b9 f g", "start": [768, 1], "end": [770, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.fork_\u03c0_app_zero", "code": "@[simp]\ntheorem equalizer.fork_\u03c0_app_zero : (equalizer.fork f g).\u03c0.app zero = equalizer.\u03b9 f g", "start": [773, 1], "end": [775, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.condition", "code": "@[reassoc]\ntheorem equalizer.condition : equalizer.\u03b9 f g \u226b f = equalizer.\u03b9 f g \u226b g", "start": [778, 1], "end": [780, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizerIsEqualizer", "code": "noncomputable def equalizerIsEqualizer : IsLimit (Fork.of\u03b9 (equalizer.\u03b9 f g)\n    (equalizer.condition f g)) :=\n  IsLimit.ofIsoLimit (limit.isLimit _) (Fork.ext (Iso.refl _) (by aesop))", "start": [783, 1], "end": [786, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.lift", "code": "noncomputable abbrev equalizer.lift {W : C} (k : W \u27f6 X) (h : k \u226b f = k \u226b g) : W \u27f6 equalizer f g :=\n  limit.lift (parallelPair f g) (Fork.of\u03b9 k h)", "start": [791, 1], "end": [794, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.lift_\u03b9", "code": "@[reassoc]\ntheorem equalizer.lift_\u03b9 {W : C} (k : W \u27f6 X) (h : k \u226b f = k \u226b g) :\n    equalizer.lift k h \u226b equalizer.\u03b9 f g = k", "start": [798, 1], "end": [801, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.lift'", "code": "noncomputable def equalizer.lift' {W : C} (k : W \u27f6 X) (h : k \u226b f = k \u226b g) :\n    { l : W \u27f6 equalizer f g // l \u226b equalizer.\u03b9 f g = k } :=\n  \u27e8equalizer.lift k h, equalizer.lift_\u03b9 _ _\u27e9", "start": [804, 1], "end": [808, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.hom_ext", "code": "@[ext]\ntheorem equalizer.hom_ext {W : C} {k l : W \u27f6 equalizer f g}\n    (h : k \u226b equalizer.\u03b9 f g = l \u226b equalizer.\u03b9 f g) : k = l", "start": [811, 1], "end": [815, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.existsUnique", "code": "theorem equalizer.existsUnique {W : C} (k : W \u27f6 X) (h : k \u226b f = k \u226b g) :\n    \u2203! l : W \u27f6 equalizer f g, l \u226b equalizer.\u03b9 f g = k", "start": [818, 1], "end": [820, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.\u03b9_mono", "code": "instance equalizer.\u03b9_mono : Mono (equalizer.\u03b9 f g) where\n  right_cancellation _ _ w := equalizer.hom_ext w", "start": [823, 1], "end": [825, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.mono_of_isLimit_fork", "code": "theorem mono_of_isLimit_fork {c : Fork f g} (i : IsLimit c) : Mono (Fork.\u03b9 c)", "start": [834, 1], "end": [836, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.idFork", "code": "def idFork (h : f = g) : Fork f g :=\n  Fork.of\u03b9 (\ud835\udfd9 X) <| h \u25b8 rfl", "start": [845, 1], "end": [847, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitIdFork", "code": "def isLimitIdFork (h : f = g) : IsLimit (idFork h) :=\n  Fork.IsLimit.mk _ (fun s => Fork.\u03b9 s) (fun s => Category.comp_id _) fun s m h => by\n    convert h\n    exact (Category.comp_id _).symm", "start": [850, 1], "end": [854, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_eq", "code": "theorem isIso_limit_cone_parallelPair_of_eq (h\u2080 : f = g) {c : Fork f g} (h : IsLimit c) :\n    IsIso c.\u03b9", "start": [857, 1], "end": [860, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.\u03b9_of_eq", "code": "theorem equalizer.\u03b9_of_eq [HasEqualizer f g] (h : f = g) : IsIso (equalizer.\u03b9 f g)", "start": [863, 1], "end": [865, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_self", "code": "theorem isIso_limit_cone_parallelPair_of_self {c : Fork f f} (h : IsLimit c) : IsIso c.\u03b9", "start": [868, 1], "end": [870, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_epi", "code": "theorem isIso_limit_cone_parallelPair_of_epi {c : Fork f g} (h : IsLimit c) [Epi c.\u03b9] : IsIso c.\u03b9", "start": [873, 1], "end": [875, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.eq_of_epi_fork_\u03b9", "code": "theorem eq_of_epi_fork_\u03b9 (t : Fork f g) [Epi (Fork.\u03b9 t)] : f = g", "start": [878, 1], "end": [880, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.eq_of_epi_equalizer", "code": "theorem eq_of_epi_equalizer [HasEqualizer f g] [Epi (equalizer.\u03b9 f g)] : f = g", "start": [883, 1], "end": [885, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasEqualizer_of_self", "code": "instance hasEqualizer_of_self : HasEqualizer f f :=\n  HasLimit.mk\n    { cone := idFork rfl\n      isLimit := isLimitIdFork rfl }", "start": [890, 1], "end": [893, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.\u03b9_of_self", "code": "instance equalizer.\u03b9_of_self : IsIso (equalizer.\u03b9 f f) :=\n  equalizer.\u03b9_of_eq rfl", "start": [896, 1], "end": [898, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.isoSourceOfSelf", "code": "noncomputable def equalizer.isoSourceOfSelf : equalizer f f \u2245 X :=\n  asIso (equalizer.\u03b9 f f)", "start": [901, 1], "end": [903, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.isoSourceOfSelf_hom", "code": "@[simp]\ntheorem equalizer.isoSourceOfSelf_hom : (equalizer.isoSourceOfSelf f).hom = equalizer.\u03b9 f f", "start": [906, 1], "end": [908, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer.isoSourceOfSelf_inv", "code": "@[simp]\ntheorem equalizer.isoSourceOfSelf_inv :\n    (equalizer.isoSourceOfSelf f).inv = equalizer.lift (\ud835\udfd9 X) (by simp)", "start": [911, 1], "end": [915, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasCoequalizer", "code": "abbrev HasCoequalizer :=\n  HasColimit (parallelPair f g)", "start": [920, 1], "end": [924, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer", "code": "noncomputable abbrev coequalizer : C :=\n  colimit (parallelPair f g)", "start": [929, 1], "end": [932, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.\u03c0", "code": "noncomputable abbrev coequalizer.\u03c0 : Y \u27f6 coequalizer f g :=\n  colimit.\u03b9 (parallelPair f g) one", "start": [935, 1], "end": [938, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.cofork", "code": "noncomputable abbrev coequalizer.cofork : Cofork f g :=\n  colimit.cocone (parallelPair f g)", "start": [941, 1], "end": [944, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.cofork_\u03c0", "code": "@[simp]\ntheorem coequalizer.cofork_\u03c0 : (coequalizer.cofork f g).\u03c0 = coequalizer.\u03c0 f g", "start": [947, 1], "end": [949, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.cofork_\u03b9_app_one", "code": "theorem coequalizer.cofork_\u03b9_app_one : (coequalizer.cofork f g).\u03b9.app one = coequalizer.\u03c0 f g", "start": [953, 1], "end": [954, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.condition", "code": "@[reassoc]\ntheorem coequalizer.condition : f \u226b coequalizer.\u03c0 f g = g \u226b coequalizer.\u03c0 f g", "start": [957, 1], "end": [959, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizerIsCoequalizer", "code": "noncomputable def coequalizerIsCoequalizer :\n    IsColimit (Cofork.of\u03c0 (coequalizer.\u03c0 f g) (coequalizer.condition f g)) :=\n  IsColimit.ofIsoColimit (colimit.isColimit _) (Cofork.ext (Iso.refl _) (by aesop))", "start": [962, 1], "end": [965, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.desc", "code": "noncomputable abbrev coequalizer.desc {W : C} (k : Y \u27f6 W) (h : f \u226b k = g \u226b k) :\n    coequalizer f g \u27f6 W :=\n  colimit.desc (parallelPair f g) (Cofork.of\u03c0 k h)", "start": [970, 1], "end": [974, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.\u03c0_desc", "code": "@[reassoc]\ntheorem coequalizer.\u03c0_desc {W : C} (k : Y \u27f6 W) (h : f \u226b k = g \u226b k) :\n    coequalizer.\u03c0 f g \u226b coequalizer.desc k h = k", "start": [978, 1], "end": [981, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.\u03c0_colimMap_desc", "code": "theorem coequalizer.\u03c0_colimMap_desc {X' Y' Z : C} (f' g' : X' \u27f6 Y') [HasCoequalizer f' g']\n    (p : X \u27f6 X') (q : Y \u27f6 Y') (wf : f \u226b q = p \u226b f') (wg : g \u226b q = p \u226b g') (h : Y' \u27f6 Z)\n    (wh : f' \u226b h = g' \u226b h) :\n    coequalizer.\u03c0 f g \u226b colimMap (parallelPairHom f g f' g' p q wf wg) \u226b coequalizer.desc h wh =\n      q \u226b h", "start": [984, 1], "end": [989, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.desc'", "code": "noncomputable def coequalizer.desc' {W : C} (k : Y \u27f6 W) (h : f \u226b k = g \u226b k) :\n    { l : coequalizer f g \u27f6 W // coequalizer.\u03c0 f g \u226b l = k } :=\n  \u27e8coequalizer.desc k h, coequalizer.\u03c0_desc _ _\u27e9", "start": [992, 1], "end": [996, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.hom_ext", "code": "@[ext]\ntheorem coequalizer.hom_ext {W : C} {k l : coequalizer f g \u27f6 W}\n    (h : coequalizer.\u03c0 f g \u226b k = coequalizer.\u03c0 f g \u226b l) : k = l", "start": [999, 1], "end": [1004, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.existsUnique", "code": "theorem coequalizer.existsUnique {W : C} (k : Y \u27f6 W) (h : f \u226b k = g \u226b k) :\n    \u2203! d : coequalizer f g \u27f6 W, coequalizer.\u03c0 f g \u226b d = k", "start": [1007, 1], "end": [1009, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.\u03c0_epi", "code": "instance coequalizer.\u03c0_epi : Epi (coequalizer.\u03c0 f g) where\n  left_cancellation _ _ w := coequalizer.hom_ext w", "start": [1012, 1], "end": [1014, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.epi_of_isColimit_cofork", "code": "theorem epi_of_isColimit_cofork {c : Cofork f g} (i : IsColimit c) : Epi c.\u03c0", "start": [1023, 1], "end": [1025, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.idCofork", "code": "def idCofork (h : f = g) : Cofork f g :=\n  Cofork.of\u03c0 (\ud835\udfd9 Y) <| h \u25b8 rfl", "start": [1034, 1], "end": [1036, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitIdCofork", "code": "def isColimitIdCofork (h : f = g) : IsColimit (idCofork h) :=\n  Cofork.IsColimit.mk _ (fun s => Cofork.\u03c0 s) (fun s => Category.id_comp _) fun s m h => by\n    convert h\n    exact (Category.id_comp _).symm", "start": [1039, 1], "end": [1043, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_colimit_cocone_parallelPair_of_eq", "code": "theorem isIso_colimit_cocone_parallelPair_of_eq (h\u2080 : f = g) {c : Cofork f g} (h : IsColimit c) :\n    IsIso c.\u03c0", "start": [1046, 1], "end": [1049, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.\u03c0_of_eq", "code": "theorem coequalizer.\u03c0_of_eq [HasCoequalizer f g] (h : f = g) : IsIso (coequalizer.\u03c0 f g)", "start": [1052, 1], "end": [1054, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_colimit_cocone_parallelPair_of_self", "code": "theorem isIso_colimit_cocone_parallelPair_of_self {c : Cofork f f} (h : IsColimit c) : IsIso c.\u03c0", "start": [1057, 1], "end": [1059, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_limit_cocone_parallelPair_of_epi", "code": "theorem isIso_limit_cocone_parallelPair_of_epi {c : Cofork f g} (h : IsColimit c) [Mono c.\u03c0] :\n    IsIso c.\u03c0", "start": [1062, 1], "end": [1065, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.eq_of_mono_cofork_\u03c0", "code": "theorem eq_of_mono_cofork_\u03c0 (t : Cofork f g) [Mono (Cofork.\u03c0 t)] : f = g", "start": [1068, 1], "end": [1070, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.eq_of_mono_coequalizer", "code": "theorem eq_of_mono_coequalizer [HasCoequalizer f g] [Mono (coequalizer.\u03c0 f g)] : f = g", "start": [1073, 1], "end": [1075, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoequalizer_of_self", "code": "instance hasCoequalizer_of_self : HasCoequalizer f f :=\n  HasColimit.mk\n    { cocone := idCofork rfl\n      isColimit := isColimitIdCofork rfl }", "start": [1080, 1], "end": [1083, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.\u03c0_of_self", "code": "instance coequalizer.\u03c0_of_self : IsIso (coequalizer.\u03c0 f f) :=\n  coequalizer.\u03c0_of_eq rfl", "start": [1086, 1], "end": [1088, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.isoTargetOfSelf", "code": "noncomputable def coequalizer.isoTargetOfSelf : coequalizer f f \u2245 Y :=\n  (asIso (coequalizer.\u03c0 f f)).symm", "start": [1091, 1], "end": [1093, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.isoTargetOfSelf_hom", "code": "@[simp]\ntheorem coequalizer.isoTargetOfSelf_hom :\n    (coequalizer.isoTargetOfSelf f).hom = coequalizer.desc (\ud835\udfd9 Y) (by simp)", "start": [1096, 1], "end": [1100, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer.isoTargetOfSelf_inv", "code": "@[simp]\ntheorem coequalizer.isoTargetOfSelf_inv : (coequalizer.isoTargetOfSelf f).inv = coequalizer.\u03c0 f f", "start": [1103, 1], "end": [1105, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizerComparison", "code": "noncomputable def equalizerComparison [HasEqualizer f g] [HasEqualizer (G.map f) (G.map g)] :\n    G.obj (equalizer f g) \u27f6 equalizer (G.map f) (G.map g) :=\n  equalizer.lift (G.map (equalizer.\u03b9 _ _))\n    (by simp only [\u2190 G.map_comp]; rw[equalizer.condition])", "start": [1112, 1], "end": [1119, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizerComparison_comp_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem equalizerComparison_comp_\u03c0 [HasEqualizer f g] [HasEqualizer (G.map f) (G.map g)] :\n    equalizerComparison f g G \u226b equalizer.\u03b9 (G.map f) (G.map g) = G.map (equalizer.\u03b9 f g)", "start": [1122, 1], "end": [1125, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.map_lift_equalizerComparison", "code": "@[reassoc (attr := simp)]\ntheorem map_lift_equalizerComparison [HasEqualizer f g] [HasEqualizer (G.map f) (G.map g)] {Z : C}\n    {h : Z \u27f6 X} (w : h \u226b f = h \u226b g) :\n    G.map (equalizer.lift h w) \u226b equalizerComparison f g G =\n      equalizer.lift (G.map h) (by simp only [\u2190 G.map_comp, w])", "start": [1128, 1], "end": [1134, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizerComparison", "code": "noncomputable def coequalizerComparison [HasCoequalizer f g] [HasCoequalizer (G.map f) (G.map g)] :\n    coequalizer (G.map f) (G.map g) \u27f6 G.obj (coequalizer f g) :=\n  coequalizer.desc (G.map (coequalizer.\u03c0 _ _))\n    (by simp only [\u2190 G.map_comp]; rw [coequalizer.condition])", "start": [1137, 1], "end": [1141, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.\u03b9_comp_coequalizerComparison", "code": "@[reassoc (attr := simp)]\ntheorem \u03b9_comp_coequalizerComparison [HasCoequalizer f g] [HasCoequalizer (G.map f) (G.map g)] :\n    coequalizer.\u03c0 _ _ \u226b coequalizerComparison f g G = G.map (coequalizer.\u03c0 _ _)", "start": [1144, 1], "end": [1147, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizerComparison_map_desc", "code": "@[reassoc (attr := simp)]\ntheorem coequalizerComparison_map_desc [HasCoequalizer f g] [HasCoequalizer (G.map f) (G.map g)]\n    {Z : C} {h : Y \u27f6 Z} (w : f \u226b h = g \u226b h) :\n    coequalizerComparison f g G \u226b G.map (coequalizer.desc h w) =\n      coequalizer.desc (G.map h) (by simp only [\u2190 G.map_comp, w])", "start": [1150, 1], "end": [1156, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasEqualizers", "code": "abbrev HasEqualizers :=\n  HasLimitsOfShape WalkingParallelPair C", "start": [1163, 1], "end": [1165, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasCoequalizers", "code": "abbrev HasCoequalizers :=\n  HasColimitsOfShape WalkingParallelPair C", "start": [1168, 1], "end": [1170, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasEqualizers_of_hasLimit_parallelPair", "code": "theorem hasEqualizers_of_hasLimit_parallelPair\n    [\u2200 {X Y : C} {f g : X \u27f6 Y}, HasLimit (parallelPair f g)] : HasEqualizers C", "start": [1173, 1], "end": [1176, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoequalizers_of_hasColimit_parallelPair", "code": "theorem hasCoequalizers_of_hasColimit_parallelPair\n    [\u2200 {X Y : C} {f g : X \u27f6 Y}, HasColimit (parallelPair f g)] : HasCoequalizers C", "start": [1179, 1], "end": [1182, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coneOfIsSplitMono", "code": "@[simps!]\nnoncomputable def coneOfIsSplitMono : Fork (\ud835\udfd9 Y) (retraction f \u226b f) :=\n  Fork.of\u03b9 f (by simp)", "start": [1190, 1], "end": [1196, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coneOfIsSplitMono_\u03b9", "code": "@[simp]\ntheorem coneOfIsSplitMono_\u03b9 : (coneOfIsSplitMono f).\u03b9 = f", "start": [1199, 1], "end": [1201, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isSplitMonoEqualizes", "code": "noncomputable def isSplitMonoEqualizes {X Y : C} (f : X \u27f6 Y) [IsSplitMono f] :\n    IsLimit (coneOfIsSplitMono f) :=\n  Fork.IsLimit.mk' _ fun s =>\n    \u27e8s.\u03b9 \u226b retraction f, by\n      dsimp\n      rw [Category.assoc, \u2190 s.condition]\n      apply Category.comp_id, fun hm => by simp [\u2190 hm]\u27e9", "start": [1204, 1], "end": [1212, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.splitMonoOfEqualizer", "code": "def splitMonoOfEqualizer {X Y : C} {f : X \u27f6 Y} {r : Y \u27f6 X} (hr : f \u226b r \u226b f = f)\n    (h : IsLimit (Fork.of\u03b9 f (hr.trans (Category.comp_id _).symm : f \u226b r \u226b f = f \u226b \ud835\udfd9 Y))) :\n    SplitMono f where\n  retraction := r\n  id := Fork.IsLimit.hom_ext h ((Category.assoc _ _ _).trans <| hr.trans (Category.id_comp _).symm)", "start": [1217, 1], "end": [1223, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isEqualizerCompMono", "code": "def isEqualizerCompMono {c : Fork f g} (i : IsLimit c) {Z : C} (h : Y \u27f6 Z) [hm : Mono h] :\n    have : Fork.\u03b9 c \u226b f \u226b h = Fork.\u03b9 c \u226b g \u226b h := by\n      simp only [\u2190Category.assoc]\n      exact congrArg (\u00b7 \u226b h) c.condition;\n    IsLimit (Fork.of\u03b9 c.\u03b9 (by simp [this]) : Fork (f \u226b h) (g \u226b h)) :=\n  Fork.IsLimit.mk' _ fun s =>\n    let s' : Fork f g := Fork.of\u03b9 s.\u03b9 (by apply hm.right_cancellation; simp [s.condition])\n    let l := Fork.IsLimit.lift' i s'.\u03b9 s'.condition\n    \u27e8l.1, l.2, fun hm => by\n      apply Fork.IsLimit.hom_ext i; rw [Fork.\u03b9_of\u03b9] at hm; rw [hm]; exact l.2.symm\u27e9", "start": [1228, 1], "end": [1238, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasEqualizer_comp_mono", "code": "@[instance]\ntheorem hasEqualizer_comp_mono [HasEqualizer f g] {Z : C} (h : Y \u27f6 Z) [Mono h] :\n    HasEqualizer (f \u226b h) (g \u226b h)", "start": [1243, 1], "end": [1247, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.splitMonoOfIdempotentOfIsLimitFork", "code": "@[simps]\ndef splitMonoOfIdempotentOfIsLimitFork {X : C} {f : X \u27f6 X} (hf : f \u226b f = f) {c : Fork (\ud835\udfd9 X) f}\n    (i : IsLimit c) : SplitMono c.\u03b9 where\n  retraction := i.lift (Fork.of\u03b9 f (by simp [hf]))\n  id := by\n    letI := mono_of_isLimit_fork i\n    rw [\u2190 cancel_mono_id c.\u03b9, Category.assoc, Fork.IsLimit.lift_\u03b9, Fork.\u03b9_of\u03b9, \u2190 c.condition]\n    exact Category.comp_id c.\u03b9", "start": [1250, 1], "end": [1258, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.splitMonoOfIdempotentEqualizer", "code": "noncomputable def splitMonoOfIdempotentEqualizer {X : C} {f : X \u27f6 X} (hf : f \u226b f = f)\n    [HasEqualizer (\ud835\udfd9 X) f] : SplitMono (equalizer.\u03b9 (\ud835\udfd9 X) f) :=\n  splitMonoOfIdempotentOfIsLimitFork _ hf (limit.isLimit _)", "start": [1261, 1], "end": [1264, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coconeOfIsSplitEpi", "code": "@[simps!]\nnoncomputable def coconeOfIsSplitEpi : Cofork (\ud835\udfd9 X) (f \u226b section_ f) :=\n  Cofork.of\u03c0 f (by simp)", "start": [1272, 1], "end": [1278, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coconeOfIsSplitEpi_\u03c0", "code": "@[simp]\ntheorem coconeOfIsSplitEpi_\u03c0 : (coconeOfIsSplitEpi f).\u03c0 = f", "start": [1281, 1], "end": [1283, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isSplitEpiCoequalizes", "code": "noncomputable def isSplitEpiCoequalizes {X Y : C} (f : X \u27f6 Y) [IsSplitEpi f] :\n    IsColimit (coconeOfIsSplitEpi f) :=\n  Cofork.IsColimit.mk' _ fun s =>\n    \u27e8section_ f \u226b s.\u03c0, by\n      dsimp\n      rw [\u2190 Category.assoc, \u2190 s.condition, Category.id_comp], fun hm => by simp [\u2190 hm]\u27e9", "start": [1286, 1], "end": [1293, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.splitEpiOfCoequalizer", "code": "def splitEpiOfCoequalizer {X Y : C} {f : X \u27f6 Y} {s : Y \u27f6 X} (hs : f \u226b s \u226b f = f)\n    (h :\n      IsColimit\n        (Cofork.of\u03c0 f\n          ((Category.assoc _ _ _).trans <| hs.trans (Category.id_comp f).symm :\n            (f \u226b s) \u226b f = \ud835\udfd9 X \u226b f))) :\n    SplitEpi f where\n  section_ := s\n  id := Cofork.IsColimit.hom_ext h (hs.trans (Category.comp_id _).symm)", "start": [1298, 1], "end": [1308, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isCoequalizerEpiComp", "code": "def isCoequalizerEpiComp {c : Cofork f g} (i : IsColimit c) {W : C} (h : W \u27f6 X) [hm : Epi h] :\n    have : (h \u226b f) \u226b Cofork.\u03c0 c = (h \u226b g) \u226b Cofork.\u03c0 c := by\n      simp only [Category.assoc]\n      exact congrArg (h \u226b \u00b7) c.condition\n    IsColimit (Cofork.of\u03c0 c.\u03c0 (this) : Cofork (h \u226b f) (h \u226b g)) :=\n  Cofork.IsColimit.mk' _ fun s =>\n    let s' : Cofork f g :=\n      Cofork.of\u03c0 s.\u03c0 (by apply hm.left_cancellation; simp_rw [\u2190 Category.assoc, s.condition])\n    let l := Cofork.IsColimit.desc' i s'.\u03c0 s'.condition\n    \u27e8l.1, l.2, fun hm => by\n      apply Cofork.IsColimit.hom_ext i; rw [Cofork.\u03c0_of\u03c0] at hm; rw [hm]; exact l.2.symm\u27e9", "start": [1313, 1], "end": [1325, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoequalizer_epi_comp", "code": "theorem hasCoequalizer_epi_comp [HasCoequalizer f g] {W : C} (h : W \u27f6 X) [Epi h] :\n    HasCoequalizer (h \u226b f) (h \u226b g)", "start": [1328, 1], "end": [1331, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.splitEpiOfIdempotentOfIsColimitCofork", "code": "@[simps]\ndef splitEpiOfIdempotentOfIsColimitCofork {X : C} {f : X \u27f6 X} (hf : f \u226b f = f) {c : Cofork (\ud835\udfd9 X) f}\n    (i : IsColimit c) : SplitEpi c.\u03c0 where\n  section_ := i.desc (Cofork.of\u03c0 f (by simp [hf]))\n  id := by\n    letI := epi_of_isColimit_cofork i\n    rw [\u2190 cancel_epi_id c.\u03c0, \u2190 Category.assoc, Cofork.IsColimit.\u03c0_desc, Cofork.\u03c0_of\u03c0, \u2190\n      c.condition]\n    exact Category.id_comp _", "start": [1336, 1], "end": [1345, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.splitEpiOfIdempotentCoequalizer", "code": "noncomputable def splitEpiOfIdempotentCoequalizer {X : C} {f : X \u27f6 X} (hf : f \u226b f = f)\n    [HasCoequalizer (\ud835\udfd9 X) f] : SplitEpi (coequalizer.\u03c0 (\ud835\udfd9 X) f) :=\n  splitEpiOfIdempotentOfIsColimitCofork _ hf (colimit.isColimit _)", "start": [1348, 1], "end": [1351, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Adjunction/Limits.lean", "imports": ["Mathlib/CategoryTheory/Limits/Creates.lean", "Mathlib/CategoryTheory/Adjunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Adjunction.functorialityRightAdjoint", "code": "def functorialityRightAdjoint : Cocone (K \u22d9 F) \u2964 Cocone K :=\n  Cocones.functoriality _ G \u22d9\n    Cocones.precompose (K.rightUnitor.inv \u226b whiskerLeft K adj.unit \u226b (associator _ _ _).inv)", "start": [53, 1], "end": [59, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.functorialityUnit", "code": "@[simps]\ndef functorialityUnit :\n    \ud835\udfed (Cocone K) \u27f6 Cocones.functoriality _ F \u22d9 functorialityRightAdjoint adj K where\n  app c := { hom := adj.unit.app c.pt }", "start": [64, 1], "end": [71, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.functorialityCounit", "code": "@[simps]\ndef functorialityCounit :\n    functorialityRightAdjoint adj K \u22d9 Cocones.functoriality _ F \u27f6 \ud835\udfed (Cocone (K \u22d9 F)) where\n  app c := { hom := adj.counit.app c.pt }", "start": [74, 1], "end": [81, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.functorialityIsLeftAdjoint", "code": "def functorialityIsLeftAdjoint : IsLeftAdjoint (Cocones.functoriality K F) where\n  right := functorialityRightAdjoint adj K\n  adj := mkOfUnitCounit\n    { unit := functorialityUnit adj K\n      counit := functorialityCounit adj K }", "start": [84, 1], "end": [89, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.leftAdjointPreservesColimits", "code": "def leftAdjointPreservesColimits : PreservesColimitsOfSize.{v, u} F where\n  preservesColimitsOfShape :=\n    { preservesColimit :=\n        { preserves := fun hc =>\n            IsColimit.isoUniqueCoconeMorphism.inv fun _ =>\n              @Equiv.unique _ _ (IsColimit.isoUniqueCoconeMorphism.hom hc _)\n                ((adj.functorialityIsLeftAdjoint _).adj.homEquiv _ _) } }", "start": [92, 1], "end": [102, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.isEquivalencePreservesColimits", "code": "instance (priority := 100) isEquivalencePreservesColimits (E : C \u2964 D) [IsEquivalence E] :\n    PreservesColimitsOfSize.{v, u} E :=\n  leftAdjointPreservesColimits E.adjunction", "start": [106, 1], "end": [108, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.isEquivalenceReflectsColimits", "code": "instance (priority := 100) isEquivalenceReflectsColimits (E : D \u2964 C) [IsEquivalence E] :\n    ReflectsColimitsOfSize.{v, u} E where\n  reflectsColimitsOfShape :=\n    { reflectsColimit :=\n        { reflects := fun t =>\n          (isColimitOfPreserves E.inv t).mapCoconeEquiv E.asEquivalence.unitIso.symm } }", "start": [112, 1], "end": [117, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.isEquivalenceCreatesColimits", "code": "instance (priority := 100) isEquivalenceCreatesColimits (H : D \u2964 C) [IsEquivalence H] :\n    CreatesColimitsOfSize.{v, u} H where\n  CreatesColimitsOfShape :=\n    { CreatesColimit :=\n        { lifts := fun c _ =>\n            { liftedCocone := mapCoconeInv H c\n              validLift := mapCoconeMapCoconeInv H c } } }", "start": [121, 1], "end": [127, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.hasColimit_comp_equivalence", "code": "theorem hasColimit_comp_equivalence (E : C \u2964 D) [IsEquivalence E] [HasColimit K] :\n    HasColimit (K \u22d9 E)", "start": [135, 1], "end": [139, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.hasColimit_of_comp_equivalence", "code": "theorem hasColimit_of_comp_equivalence (E : C \u2964 D) [IsEquivalence E] [HasColimit (K \u22d9 E)] :\n    HasColimit K", "start": [142, 1], "end": [146, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.hasColimitsOfShape_of_equivalence", "code": "theorem hasColimitsOfShape_of_equivalence (E : C \u2964 D) [IsEquivalence E] [HasColimitsOfShape J D] :\n    HasColimitsOfShape J C", "start": [149, 1], "end": [152, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.has_colimits_of_equivalence", "code": "theorem has_colimits_of_equivalence (E : C \u2964 D) [IsEquivalence E] [HasColimitsOfSize.{v, u} D] :\n    HasColimitsOfSize.{v, u} C", "start": [155, 1], "end": [158, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.functorialityLeftAdjoint", "code": "def functorialityLeftAdjoint : Cone (K \u22d9 G) \u2964 Cone K :=\n  Cones.functoriality _ F \u22d9\n    Cones.postcompose ((associator _ _ _).hom \u226b whiskerLeft K adj.counit \u226b K.rightUnitor.hom)", "start": [167, 1], "end": [173, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.functorialityUnit'", "code": "@[simps]\ndef functorialityUnit' :\n    \ud835\udfed (Cone (K \u22d9 G)) \u27f6 functorialityLeftAdjoint adj K \u22d9 Cones.functoriality _ G where\n  app c := { hom := adj.unit.app c.pt }", "start": [178, 1], "end": [185, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.functorialityCounit'", "code": "@[simps]\ndef functorialityCounit' :\n    Cones.functoriality _ G \u22d9 functorialityLeftAdjoint adj K \u27f6 \ud835\udfed (Cone K) where\n  app c := { hom := adj.counit.app c.pt }", "start": [188, 1], "end": [195, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.functorialityIsRightAdjoint", "code": "def functorialityIsRightAdjoint : IsRightAdjoint (Cones.functoriality K G) where\n  left := functorialityLeftAdjoint adj K\n  adj := mkOfUnitCounit\n    { unit := functorialityUnit' adj K\n      counit := functorialityCounit' adj K }", "start": [198, 1], "end": [203, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.rightAdjointPreservesLimits", "code": "def rightAdjointPreservesLimits : PreservesLimitsOfSize.{v, u} G where\n  preservesLimitsOfShape :=\n    { preservesLimit :=\n        { preserves := fun hc =>\n            IsLimit.isoUniqueConeMorphism.inv fun _ =>\n              @Equiv.unique _ _ (IsLimit.isoUniqueConeMorphism.hom hc _)\n                ((adj.functorialityIsRightAdjoint _).adj.homEquiv _ _).symm } }", "start": [206, 1], "end": [216, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.isEquivalencePreservesLimits", "code": "instance (priority := 100) isEquivalencePreservesLimits (E : D \u2964 C) [IsEquivalence E] :\n    PreservesLimitsOfSize.{v, u} E :=\n  rightAdjointPreservesLimits E.inv.adjunction", "start": [220, 1], "end": [222, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.isEquivalenceReflectsLimits", "code": "instance (priority := 100) isEquivalenceReflectsLimits (E : D \u2964 C) [IsEquivalence E] :\n    ReflectsLimitsOfSize.{v, u} E where\n  reflectsLimitsOfShape :=\n    { reflectsLimit :=\n        { reflects := fun t =>\n            (isLimitOfPreserves E.inv t).mapConeEquiv E.asEquivalence.unitIso.symm } }", "start": [226, 1], "end": [231, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.isEquivalenceCreatesLimits", "code": "instance (priority := 100) isEquivalenceCreatesLimits (H : D \u2964 C) [IsEquivalence H] :\n    CreatesLimitsOfSize.{v, u} H where\n  CreatesLimitsOfShape :=\n    { CreatesLimit :=\n        { lifts := fun c _ =>\n            { liftedCone := mapConeInv H c\n              validLift := mapConeMapConeInv H c } } }", "start": [235, 1], "end": [241, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.hasLimit_comp_equivalence", "code": "theorem hasLimit_comp_equivalence (E : D \u2964 C) [IsEquivalence E] [HasLimit K] : HasLimit (K \u22d9 E)", "start": [248, 1], "end": [251, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.hasLimit_of_comp_equivalence", "code": "theorem hasLimit_of_comp_equivalence (E : D \u2964 C) [IsEquivalence E] [HasLimit (K \u22d9 E)] :\n    HasLimit K", "start": [254, 1], "end": [258, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.hasLimitsOfShape_of_equivalence", "code": "theorem hasLimitsOfShape_of_equivalence (E : D \u2964 C) [IsEquivalence E] [HasLimitsOfShape J C] :\n    HasLimitsOfShape J D", "start": [261, 1], "end": [264, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.has_limits_of_equivalence", "code": "theorem has_limits_of_equivalence (E : D \u2964 C) [IsEquivalence E] [HasLimitsOfSize.{v, u} C] :\n    HasLimitsOfSize.{v, u} D", "start": [267, 1], "end": [270, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.coconesIsoComponentHom", "code": "@[simp]\ndef coconesIsoComponentHom {J : Type u} [Category.{v} J] {K : J \u2964 C} (Y : D)\n    (t : ((cocones J D).obj (op (K \u22d9 F))).obj Y) : (G \u22d9 (cocones J C).obj (op K)).obj Y where\n  app j := (adj.homEquiv (K.obj j) Y) (t.app j)\n  naturality j j' f := by\n    erw [\u2190 adj.homEquiv_naturality_left, t.naturality]\n    dsimp\n    simp", "start": [275, 1], "end": [283, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.coconesIsoComponentInv", "code": "@[simp]\ndef coconesIsoComponentInv {J : Type u} [Category.{v} J] {K : J \u2964 C} (Y : D)\n    (t : (G \u22d9 (cocones J C).obj (op K)).obj Y) : ((cocones J D).obj (op (K \u22d9 F))).obj Y where\n  app j := (adj.homEquiv (K.obj j) Y).symm (t.app j)\n  naturality j j' f := by\n    erw [\u2190 adj.homEquiv_naturality_left_symm, \u2190 adj.homEquiv_naturality_right_symm, t.naturality]\n    dsimp; simp", "start": [286, 1], "end": [293, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.conesIsoComponentHom", "code": "@[simp]\ndef conesIsoComponentHom {J : Type u} [Category.{v} J] {K : J \u2964 D} (X : C\u1d52\u1d56)\n    (t : (Functor.op F \u22d9 (cones J D).obj K).obj X) : ((cones J C).obj (K \u22d9 G)).obj X where\n  app j := (adj.homEquiv (unop X) (K.obj j)) (t.app j)\n  naturality j j' f := by\n    erw [\u2190 adj.homEquiv_naturality_right, \u2190 t.naturality, Category.id_comp, Category.id_comp]\n    rfl", "start": [296, 1], "end": [303, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.conesIsoComponentInv", "code": "@[simp]\ndef conesIsoComponentInv {J : Type u} [Category.{v} J] {K : J \u2964 D} (X : C\u1d52\u1d56)\n    (t : ((cones J C).obj (K \u22d9 G)).obj X) : (Functor.op F \u22d9 (cones J D).obj K).obj X where\n  app j := (adj.homEquiv (unop X) (K.obj j)).symm (t.app j)\n  naturality j j' f := by\n    erw [\u2190 adj.homEquiv_naturality_right_symm, \u2190 t.naturality, Category.id_comp, Category.id_comp]", "start": [306, 1], "end": [312, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.coconesIso", "code": "def coconesIso {J : Type u} [Category.{v} J] {K : J \u2964 C} :\n    (cocones J D).obj (op (K \u22d9 F)) \u2245 G \u22d9 (cocones J C).obj (op K) :=\n  NatIso.ofComponents fun Y =>\n    { hom := coconesIsoComponentHom adj Y\n      inv := coconesIsoComponentInv adj Y }", "start": [321, 1], "end": [330, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.conesIso", "code": "def conesIso {J : Type u} [Category.{v} J] {K : J \u2964 D} :\n    F.op \u22d9 (cones J D).obj K \u2245 (cones J C).obj (K \u22d9 G) :=\n  NatIso.ofComponents fun X =>\n    { hom := conesIsoComponentHom adj X\n      inv := conesIsoComponentInv adj X }", "start": [334, 1], "end": [343, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Endomorphism.lean", "imports": ["Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/CategoryTheory/Groupoid.lean", "Mathlib/Algebra/Group/Units.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Opposites.lean", "Mathlib/GroupTheory/GroupAction/Defs.lean"], "premises": [{"full_name": "CategoryTheory.End", "code": "def End {C : Type u} [CategoryStruct.{v} C] (X : C) := X \u27f6 X", "start": [28, 1], "end": [30, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.End.one", "code": "protected instance one : One (End X) := \u27e8\ud835\udfd9 X\u27e9", "start": [39, 1], "end": [39, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.End.inhabited", "code": "protected instance inhabited : Inhabited (End X) := \u27e8\ud835\udfd9 X\u27e9", "start": [42, 1], "end": [42, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.End.mul", "code": "protected instance mul : Mul (End X) := \u27e8fun x y => y \u226b x\u27e9", "start": [45, 1], "end": [47, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.End.of", "code": "def of (f : X \u27f6 X) : End X := f", "start": [52, 1], "end": [53, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.End.asHom", "code": "def asHom (f : End X) : X \u27f6 X := f", "start": [56, 1], "end": [58, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.End.one_def", "code": "@[simp] theorem one_def : (1 : End X) = \ud835\udfd9 X", "start": [61, 1], "end": [62, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.End.mul_def", "code": "@[simp] theorem mul_def (xs ys : End X) : xs * ys = ys \u226b xs", "start": [65, 1], "end": [66, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.End.monoid", "code": "instance monoid {C : Type u} [Category.{v} C] {X : C} : Monoid (End X) where\n  mul_one := Category.id_comp\n  one_mul := Category.comp_id\n  mul_assoc := fun x y z => (Category.assoc z y x).symm", "start": [71, 1], "end": [75, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.End.mulActionRight", "code": "instance mulActionRight {X Y : C} : MulAction (End Y) (X \u27f6 Y) where\n  smul r f := f \u226b r\n  one_smul := Category.comp_id\n  mul_smul _ _ _ := Eq.symm <| Category.assoc _ _ _", "start": [84, 1], "end": [87, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.End.mulActionLeft", "code": "instance mulActionLeft {X : C\u1d52\u1d56} {Y : C} : MulAction (End X) (unop X \u27f6 Y) where\n  smul r f := r.unop \u226b f\n  one_smul := Category.id_comp\n  mul_smul _ _ _ := Category.assoc _ _ _", "start": [90, 1], "end": [93, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.End.smul_right", "code": "theorem smul_right {X Y : C} {r : End Y} {f : X \u27f6 Y} : r \u2022 f = f \u226b r", "start": [96, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.End.smul_left", "code": "theorem smul_left {X : C\u1d52\u1d56} {Y : C} {r : End X} {f : unop X \u27f6 Y} : r \u2022 f = r.unop \u226b f", "start": [100, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.End.group", "code": "instance group {C : Type u} [Groupoid.{v} C] (X : C) : Group (End X) where\n  mul_left_inv := Groupoid.comp_inv\n  inv := Groupoid.inv", "start": [106, 1], "end": [109, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isUnit_iff_isIso", "code": "theorem isUnit_iff_isIso {C : Type u} [Category.{v} C] {X : C} (f : End X) :\n    IsUnit (f : End X) \u2194 IsIso f", "start": [114, 1], "end": [117, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Aut", "code": "def Aut (X : C) := X \u2245 X", "start": [122, 1], "end": [127, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Aut.ext", "code": "@[ext]\nlemma ext {X : C} {\u03c6\u2081 \u03c6\u2082 : Aut X} (h : \u03c6\u2081.hom = \u03c6\u2082.hom) : \u03c6\u2081 = \u03c6\u2082 :=\n  Iso.ext h", "start": [134, 1], "end": [136, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Aut.inhabited", "code": "protected instance inhabited : Inhabited (Aut X) := \u27e8Iso.refl X\u27e9", "start": [138, 1], "end": [138, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Aut.Aut_mul_def", "code": "theorem Aut_mul_def (f g : Aut X) : f * g = g.trans f", "start": [151, 1], "end": [151, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Aut.Aut_inv_def", "code": "theorem Aut_inv_def (f : Aut X) : f\u207b\u00b9 = f.symm", "start": [155, 1], "end": [155, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Aut.unitsEndEquivAut", "code": "def unitsEndEquivAut : (End X)\u02e3 \u2243* Aut X where\n  toFun f := \u27e8f.1, f.2, f.4, f.3\u27e9\n  invFun f := \u27e8f.1, f.2, f.4, f.3\u27e9\n  left_inv := fun \u27e8f\u2081, f\u2082, f\u2083, f\u2084\u27e9 => rfl\n  right_inv := fun \u27e8f\u2081, f\u2082, f\u2083, f\u2084\u27e9 => rfl\n  map_mul' f g := by cases f; cases g; rfl", "start": [159, 1], "end": [167, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Aut.autMulEquivOfIso", "code": "def autMulEquivOfIso {X Y : C} (h : X \u2245 Y) : Aut X \u2243* Aut Y where\n  toFun x := \u27e8h.inv \u226b x.hom \u226b h.hom, h.inv \u226b x.inv \u226b h.hom, _, _\u27e9\n  invFun y := \u27e8h.hom \u226b y.hom \u226b h.inv, h.hom \u226b y.inv \u226b h.inv, _, _\u27e9\n  left_inv _ := by aesop_cat\n  right_inv _ := by aesop_cat\n  map_mul' := by simp [Aut_mul_def]", "start": [171, 1], "end": [177, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapEnd", "code": "@[simps]\ndef mapEnd : End X \u2192* End (f.obj X) where\n  toFun := f.map\n  map_mul' x y := f.map_comp y x\n  map_one' := f.map_id X", "start": [187, 1], "end": [192, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapAut", "code": "def mapAut : Aut X \u2192* Aut (f.obj X) where\n  toFun := f.mapIso\n  map_mul' x y := f.mapIso_trans y x\n  map_one' := f.mapIso_refl X", "start": [195, 1], "end": [199, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Pullbacks.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "Mathlib/CategoryTheory/Limits/Preserves/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.isLimitMapConePullbackConeEquiv", "code": "def isLimitMapConePullbackConeEquiv :\n    IsLimit (mapCone G (PullbackCone.mk h k comm)) \u2243\n      IsLimit\n        (PullbackCone.mk (G.map h) (G.map k) (by simp only [\u2190 G.map_comp, comm]) :\n          PullbackCone (G.map f) (G.map g)) :=\n  (IsLimit.postcomposeHomEquiv (diagramIsoCospan.{v\u2082} _) _).symm.trans <|\n    IsLimit.equivIsoLimit <|\n      Cones.ext (Iso.refl _) <| by\n        rintro (_ | _ | _) <;> dsimp <;> simp only [comp_id, id_comp, G.map_comp]", "start": [48, 1], "end": [58, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitPullbackConeMapOfIsLimit", "code": "def isLimitPullbackConeMapOfIsLimit [PreservesLimit (cospan f g) G]\n    (l : IsLimit (PullbackCone.mk h k comm)) :\n    have : G.map h \u226b G.map f = G.map k \u226b G.map g := by rw [\u2190G.map_comp,\u2190G.map_comp,comm]\n    IsLimit (PullbackCone.mk (G.map h) (G.map k) this) :=\n  isLimitMapConePullbackConeEquiv G comm (PreservesLimit.preserves l)", "start": [61, 1], "end": [66, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitOfIsLimitPullbackConeMap", "code": "def isLimitOfIsLimitPullbackConeMap [ReflectsLimit (cospan f g) G]\n    (l : IsLimit (PullbackCone.mk (G.map h) (G.map k) (show G.map h \u226b G.map f = G.map k \u226b G.map g\n    from by simp only [\u2190G.map_comp,comm]))) : IsLimit (PullbackCone.mk h k comm) :=\n  ReflectsLimit.reflects ((isLimitMapConePullbackConeEquiv G comm).symm l)", "start": [69, 1], "end": [73, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitOfHasPullbackOfPreservesLimit", "code": "def isLimitOfHasPullbackOfPreservesLimit [i : HasPullback f g] :\n    have : G.map pullback.fst \u226b G.map f = G.map pullback.snd \u226b G.map g := by\n      simp only [\u2190G.map_comp, pullback.condition];\n    IsLimit (PullbackCone.mk (G.map (@pullback.fst _ _ _ _ _ f g i)) (G.map pullback.snd) this) :=\n  isLimitPullbackConeMapOfIsLimit G _ (pullbackIsPullback f g)", "start": [78, 1], "end": [84, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesPullbackSymmetry", "code": "def preservesPullbackSymmetry : PreservesLimit (cospan g f) G where\n  preserves {c} hc := by\n    apply (IsLimit.postcomposeHomEquiv (diagramIsoCospan.{v\u2082} _) _).toFun\n    apply IsLimit.ofIsoLimit _ (PullbackCone.isoMk _).symm\n    apply PullbackCone.flipIsLimit\n    apply (isLimitMapConePullbackConeEquiv _ _).toFun\n    \u00b7 refine @PreservesLimit.preserves _ _ _ _ _ _ _ _ ?_ _ ?_\n      \u00b7 dsimp\n        infer_instance\n      apply PullbackCone.flipIsLimit\n      apply IsLimit.ofIsoLimit _ (PullbackCone.isoMk _)\n      exact (IsLimit.postcomposeHomEquiv (diagramIsoCospan.{v\u2081} _) _).invFun hc\n    \u00b7 exact\n        (c.\u03c0.naturality WalkingCospan.Hom.inr).symm.trans\n          (c.\u03c0.naturality WalkingCospan.Hom.inl : _)", "start": [87, 1], "end": [102, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPullback_of_preservesPullback", "code": "theorem hasPullback_of_preservesPullback [HasPullback f g] : HasPullback (G.map f) (G.map g)", "start": [105, 1], "end": [106, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesPullback.iso", "code": "def PreservesPullback.iso : G.obj (pullback f g) \u2245 pullback (G.map f) (G.map g) :=\n  IsLimit.conePointUniqueUpToIso (isLimitOfHasPullbackOfPreservesLimit G f g) (limit.isLimit _)", "start": [111, 1], "end": [114, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesPullback.iso_hom_fst", "code": "@[reassoc]\ntheorem PreservesPullback.iso_hom_fst :\n    (PreservesPullback.iso G f g).hom \u226b pullback.fst = G.map pullback.fst", "start": [117, 1], "end": [120, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesPullback.iso_hom_snd", "code": "@[reassoc]\ntheorem PreservesPullback.iso_hom_snd :\n    (PreservesPullback.iso G f g).hom \u226b pullback.snd = G.map pullback.snd", "start": [123, 1], "end": [126, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesPullback.iso_inv_fst", "code": "@[reassoc (attr := simp)]\ntheorem PreservesPullback.iso_inv_fst :\n    (PreservesPullback.iso G f g).inv \u226b G.map pullback.fst = pullback.fst", "start": [129, 1], "end": [132, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesPullback.iso_inv_snd", "code": "@[reassoc (attr := simp)]\ntheorem PreservesPullback.iso_inv_snd :\n    (PreservesPullback.iso G f g).inv \u226b G.map pullback.snd = pullback.snd", "start": [135, 1], "end": [138, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitMapCoconePushoutCoconeEquiv", "code": "def isColimitMapCoconePushoutCoconeEquiv :\n    IsColimit (mapCocone G (PushoutCocone.mk h k comm)) \u2243\n      IsColimit\n        (PushoutCocone.mk (G.map h) (G.map k) (by simp only [\u2190 G.map_comp, comm]) :\n          PushoutCocone (G.map f) (G.map g)) :=\n  (IsColimit.precomposeHomEquiv (diagramIsoSpan.{v\u2082} _).symm _).symm.trans <|\n    IsColimit.equivIsoColimit <|\n      Cocones.ext (Iso.refl _) <| by\n        rintro (_ | _ | _) <;> dsimp <;>\n          simp only [Category.comp_id, Category.id_comp, \u2190 G.map_comp]", "start": [153, 1], "end": [164, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitPushoutCoconeMapOfIsColimit", "code": "def isColimitPushoutCoconeMapOfIsColimit [PreservesColimit (span f g) G]\n    (l : IsColimit (PushoutCocone.mk h k comm)) :\n    IsColimit (PushoutCocone.mk (G.map h) (G.map k) (show G.map f \u226b G.map h = G.map g \u226b G.map k\n      from by simp only [\u2190G.map_comp,comm] )) :=\n  isColimitMapCoconePushoutCoconeEquiv G comm (PreservesColimit.preserves l)", "start": [167, 1], "end": [172, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitOfIsColimitPushoutCoconeMap", "code": "def isColimitOfIsColimitPushoutCoconeMap [ReflectsColimit (span f g) G]\n    (l : IsColimit (PushoutCocone.mk (G.map h) (G.map k) (show G.map f \u226b G.map h =\n      G.map g \u226b G.map k from by simp only [\u2190G.map_comp,comm]))) :\n    IsColimit (PushoutCocone.mk h k comm) :=\n  ReflectsColimit.reflects ((isColimitMapCoconePushoutCoconeEquiv G comm).symm l)", "start": [175, 1], "end": [180, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitOfHasPushoutOfPreservesColimit", "code": "def isColimitOfHasPushoutOfPreservesColimit [i : HasPushout f g] :\n    IsColimit (PushoutCocone.mk (G.map pushout.inl) (G.map (@pushout.inr _ _ _ _ _ f g i))\n    (show G.map f \u226b G.map pushout.inl = G.map g \u226b G.map pushout.inr from by\n      simp only [\u2190 G.map_comp, pushout.condition])) :=\n  isColimitPushoutCoconeMapOfIsColimit G _ (pushoutIsPushout f g)", "start": [185, 1], "end": [191, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesPushoutSymmetry", "code": "def preservesPushoutSymmetry : PreservesColimit (span g f) G where\n  preserves {c} hc := by\n    apply (IsColimit.precomposeHomEquiv (diagramIsoSpan.{v\u2082} _).symm _).toFun\n    apply IsColimit.ofIsoColimit _ (PushoutCocone.isoMk _).symm\n    apply PushoutCocone.flipIsColimit\n    apply (isColimitMapCoconePushoutCoconeEquiv _ _).toFun\n    \u00b7 refine @PreservesColimit.preserves _ _ _ _ _ _ _ _ ?_ _ ?_ \u00b7 dsimp\n        infer_instance\n      apply PushoutCocone.flipIsColimit\n      apply IsColimit.ofIsoColimit _ (PushoutCocone.isoMk _)\n      exact (IsColimit.precomposeHomEquiv (diagramIsoSpan.{v\u2081} _) _).invFun hc\n    \u00b7 exact (c.\u03b9.naturality WalkingSpan.Hom.snd).trans (c.\u03b9.naturality WalkingSpan.Hom.fst).symm", "start": [194, 1], "end": [207, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPushout_of_preservesPushout", "code": "theorem hasPushout_of_preservesPushout [HasPushout f g] : HasPushout (G.map f) (G.map g)", "start": [210, 1], "end": [211, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesPushout.iso", "code": "def PreservesPushout.iso : pushout (G.map f) (G.map g) \u2245 G.obj (pushout f g) :=\n  IsColimit.coconePointUniqueUpToIso (colimit.isColimit _)\n    (isColimitOfHasPushoutOfPreservesColimit G f g)", "start": [216, 1], "end": [220, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesPushout.inl_iso_hom", "code": "@[reassoc]\ntheorem PreservesPushout.inl_iso_hom :\n    pushout.inl \u226b (PreservesPushout.iso G f g).hom = G.map pushout.inl", "start": [223, 1], "end": [227, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesPushout.inr_iso_hom", "code": "@[reassoc]\ntheorem PreservesPushout.inr_iso_hom :\n    pushout.inr \u226b (PreservesPushout.iso G f g).hom = G.map pushout.inr", "start": [230, 1], "end": [234, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesPushout.inl_iso_inv", "code": "@[reassoc (attr := simp)]\ntheorem PreservesPushout.inl_iso_inv :\n    G.map pushout.inl \u226b (PreservesPushout.iso G f g).inv = pushout.inl", "start": [237, 1], "end": [240, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesPushout.inr_iso_inv", "code": "@[reassoc (attr := simp)]\ntheorem PreservesPushout.inr_iso_inv :\n    G.map pushout.inr \u226b (PreservesPushout.iso G f g).inv = pushout.inr", "start": [243, 1], "end": [246, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesPullback.ofIsoComparison", "code": "def PreservesPullback.ofIsoComparison [i : IsIso (pullbackComparison G f g)] :\n    PreservesLimit (cospan f g) G := by\n  apply preservesLimitOfPreservesLimitCone (pullbackIsPullback f g)\n  apply (isLimitMapConePullbackConeEquiv _ _).symm _\n  refine @IsLimit.ofPointIso _ _ _ _ _ _ _ (limit.isLimit (cospan (G.map f) (G.map g))) ?_\n  apply i", "start": [265, 1], "end": [272, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesPullback.iso_hom", "code": "@[simp]\ntheorem PreservesPullback.iso_hom : (PreservesPullback.iso G f g).hom = pullbackComparison G f g", "start": [277, 1], "end": [279, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesPushout.ofIsoComparison", "code": "def PreservesPushout.ofIsoComparison [i : IsIso (pushoutComparison G f g)] :\n    PreservesColimit (span f g) G := by\n  apply preservesColimitOfPreservesColimitCocone (pushoutIsPushout f g)\n  apply (isColimitMapCoconePushoutCoconeEquiv _ _).symm _\n  refine @IsColimit.ofPointIso _ _ _ _ _ _ _ (colimit.isColimit (span (G.map f) (G.map g))) ?_\n  apply i", "start": [294, 1], "end": [302, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesPushout.iso_hom", "code": "@[simp]\ntheorem PreservesPushout.iso_hom : (PreservesPushout.iso G f g).hom = pushoutComparison G f g", "start": [307, 1], "end": [309, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/NoetherianSpace.lean", "imports": ["Mathlib/Topology/Sets/Closeds.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopologicalSpace.NoetherianSpace", "code": "@[mk_iff noetherianSpace_iff]\nclass NoetherianSpace : Prop where\n  wellFounded_opens : WellFounded ((\u00b7 > \u00b7) : Opens \u03b1 \u2192 Opens \u03b1 \u2192 Prop)", "start": [47, 1], "end": [50, 71], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.noetherianSpace_iff_opens", "code": "theorem noetherianSpace_iff_opens : NoetherianSpace \u03b1 \u2194 \u2200 s : Opens \u03b1, IsCompact (s : Set \u03b1)", "start": [53, 1], "end": [56, 49], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NoetherianSpace.compactSpace", "code": "instance (priority := 100) NoetherianSpace.compactSpace [h : NoetherianSpace \u03b1] : CompactSpace \u03b1 :=\n  \u27e8(noetherianSpace_iff_opens \u03b1).mp h \u22a4\u27e9", "start": [59, 1], "end": [60, 41], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NoetherianSpace.isCompact", "code": "protected theorem NoetherianSpace.isCompact [NoetherianSpace \u03b1] (s : Set \u03b1) : IsCompact s", "start": [65, 1], "end": [70, 25], "kind": "commanddeclaration"}, {"full_name": "Inducing.noetherianSpace", "code": "protected theorem _root_.Inducing.noetherianSpace [NoetherianSpace \u03b1] {i : \u03b2 \u2192 \u03b1}\n    (hi : Inducing i) : NoetherianSpace \u03b2", "start": [74, 1], "end": [76, 92], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NoetherianSpace.set", "code": "instance NoetherianSpace.set [NoetherianSpace \u03b1] (s : Set \u03b1) : NoetherianSpace s :=\n  inducing_subtype_val.noetherianSpace", "start": [79, 1], "end": [81, 39], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.noetherianSpace_TFAE", "code": "theorem noetherianSpace_TFAE :\n    TFAE [NoetherianSpace \u03b1,\n      WellFounded fun s t : Closeds \u03b1 => s < t,\n      \u2200 s : Set \u03b1, IsCompact s,\n      \u2200 s : Opens \u03b1, IsCompact (s : Set \u03b1)]", "start": [87, 1], "end": [101, 14], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.noetherianSpace_iff_isCompact", "code": "theorem noetherianSpace_iff_isCompact : NoetherianSpace \u03b1 \u2194 \u2200 s : Set \u03b1, IsCompact s", "start": [106, 1], "end": [107, 35], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NoetherianSpace.wellFounded_closeds", "code": "theorem NoetherianSpace.wellFounded_closeds [NoetherianSpace \u03b1] :\n    WellFounded fun s t : Closeds \u03b1 => s < t", "start": [109, 1], "end": [111, 48], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.noetherianSpace_of_surjective", "code": "theorem noetherianSpace_of_surjective [NoetherianSpace \u03b1] (f : \u03b1 \u2192 \u03b2) (hf : Continuous f)\n    (hf' : Function.Surjective f) : NoetherianSpace \u03b2", "start": [122, 1], "end": [125, 43], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.noetherianSpace_iff_of_homeomorph", "code": "theorem noetherianSpace_iff_of_homeomorph (f : \u03b1 \u2243\u209c \u03b2) : NoetherianSpace \u03b1 \u2194 NoetherianSpace \u03b2", "start": [128, 1], "end": [130, 87], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NoetherianSpace.range", "code": "theorem NoetherianSpace.range [NoetherianSpace \u03b1] (f : \u03b1 \u2192 \u03b2) (hf : Continuous f) :\n    NoetherianSpace (Set.range f)", "start": [133, 1], "end": [136, 30], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.noetherianSpace_set_iff", "code": "theorem noetherianSpace_set_iff (s : Set \u03b1) :\n    NoetherianSpace s \u2194 \u2200 t, t \u2286 s \u2192 IsCompact t", "start": [139, 1], "end": [142, 32], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.noetherian_univ_iff", "code": "@[simp]\ntheorem noetherian_univ_iff : NoetherianSpace (Set.univ : Set \u03b1) \u2194 NoetherianSpace \u03b1", "start": [145, 1], "end": [147, 60], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NoetherianSpace.iUnion", "code": "theorem NoetherianSpace.iUnion {\u03b9 : Type*} (f : \u03b9 \u2192 Set \u03b1) [Finite \u03b9]\n    [hf : \u2200 i, NoetherianSpace (f i)] : NoetherianSpace (\u22c3 i, f i)", "start": [150, 1], "end": [155, 70], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NoetherianSpace.discrete", "code": "theorem NoetherianSpace.discrete [NoetherianSpace \u03b1] [T2Space \u03b1] : DiscreteTopology \u03b1", "start": [159, 1], "end": [160, 91], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NoetherianSpace.finite", "code": "theorem NoetherianSpace.finite [NoetherianSpace \u03b1] [T2Space \u03b1] : Finite \u03b1", "start": [165, 1], "end": [167, 80], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Finite.to_noetherianSpace", "code": "instance (priority := 100) Finite.to_noetherianSpace [Finite \u03b1] : NoetherianSpace \u03b1 :=\n  \u27e8Finite.wellFounded_of_trans_of_irrefl _\u27e9", "start": [170, 1], "end": [171, 44], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NoetherianSpace.exists_finite_set_closeds_irreducible", "code": "theorem NoetherianSpace.exists_finite_set_closeds_irreducible [NoetherianSpace \u03b1] (s : Closeds \u03b1) :\n    \u2203 S : Set (Closeds \u03b1), S.Finite \u2227 (\u2200 t \u2208 S, IsIrreducible (t : Set \u03b1)) \u2227 s = sSup S", "start": [174, 1], "end": [191, 64], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NoetherianSpace.exists_finite_set_isClosed_irreducible", "code": "theorem NoetherianSpace.exists_finite_set_isClosed_irreducible [NoetherianSpace \u03b1]\n    {s : Set \u03b1} (hs : IsClosed s) : \u2203 S : Set (Set \u03b1), S.Finite \u2227\n      (\u2200 t \u2208 S, IsClosed t) \u2227 (\u2200 t \u2208 S, IsIrreducible t) \u2227 s = \u22c3\u2080 S", "start": [193, 1], "end": [201, 57], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NoetherianSpace.exists_finset_irreducible", "code": "theorem NoetherianSpace.exists_finset_irreducible [NoetherianSpace \u03b1] (s : Closeds \u03b1) :\n    \u2203 S : Finset (Closeds \u03b1), (\u2200 k : S, IsIrreducible (k : Set \u03b1)) \u2227 s = S.sup id", "start": [203, 1], "end": [207, 66], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NoetherianSpace.finite_irreducibleComponents", "code": "theorem NoetherianSpace.finite_irreducibleComponents [NoetherianSpace \u03b1] :\n    (irreducibleComponents \u03b1).Finite", "start": [210, 1], "end": [218, 42], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NoetherianSpace.exists_open_ne_empty_le_irreducibleComponent", "code": "theorem NoetherianSpace.exists_open_ne_empty_le_irreducibleComponent [NoetherianSpace \u03b1]\n    (Z : Set \u03b1) (H : Z \u2208 irreducibleComponents \u03b1) :\n    \u2203 o : Set \u03b1, IsOpen o \u2227 o \u2260 \u2205 \u2227 o \u2264 Z", "start": [221, 1], "end": [264, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/FiniteDimension.lean", "imports": ["Mathlib/Analysis/NormedSpace/AffineIsometry.lean", "Mathlib/Analysis/NormedSpace/OperatorNorm.lean", "Mathlib/Analysis/NormedSpace/RieszLemma.lean", "Mathlib/Topology/Instances/Matrix.lean", "Mathlib/Topology/Algebra/Module/FiniteDimension.lean", "Mathlib/Topology/Algebra/InfiniteSum/Module.lean", "Mathlib/Analysis/NormedSpace/AddTorsor.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean"], "premises": [{"full_name": "LinearIsometry.toLinearIsometryEquiv", "code": "def toLinearIsometryEquiv (li : E\u2081 \u2192\u2097\u1d62[R\u2081] F) (h : finrank R\u2081 E\u2081 = finrank R\u2081 F) :\n    E\u2081 \u2243\u2097\u1d62[R\u2081] F where\n  toLinearEquiv := li.toLinearMap.linearEquivOfInjective li.injective h\n  norm_map' := li.norm_map'", "start": [66, 1], "end": [71, 28], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.coe_toLinearIsometryEquiv", "code": "@[simp]\ntheorem coe_toLinearIsometryEquiv (li : E\u2081 \u2192\u2097\u1d62[R\u2081] F) (h : finrank R\u2081 E\u2081 = finrank R\u2081 F) :\n    (li.toLinearIsometryEquiv h : E\u2081 \u2192 F) = li", "start": [74, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.toLinearIsometryEquiv_apply", "code": "@[simp]\ntheorem toLinearIsometryEquiv_apply (li : E\u2081 \u2192\u2097\u1d62[R\u2081] F) (h : finrank R\u2081 E\u2081 = finrank R\u2081 F)\n    (x : E\u2081) : (li.toLinearIsometryEquiv h) x = li x", "start": [80, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.toAffineIsometryEquiv", "code": "def toAffineIsometryEquiv [Inhabited P\u2081] (li : P\u2081 \u2192\u1d43\u2071[\ud835\udd5c] P\u2082) (h : finrank \ud835\udd5c V\u2081 = finrank \ud835\udd5c V\u2082) :\n    P\u2081 \u2243\u1d43\u2071[\ud835\udd5c] P\u2082 :=\n  AffineIsometryEquiv.mk' li (li.linearIsometry.toLinearIsometryEquiv h)\n    (Inhabited.default (\u03b1 := P\u2081)) fun p => by simp", "start": [98, 1], "end": [103, 51], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.coe_toAffineIsometryEquiv", "code": "@[simp]\ntheorem coe_toAffineIsometryEquiv [Inhabited P\u2081] (li : P\u2081 \u2192\u1d43\u2071[\ud835\udd5c] P\u2082)\n    (h : finrank \ud835\udd5c V\u2081 = finrank \ud835\udd5c V\u2082) : (li.toAffineIsometryEquiv h : P\u2081 \u2192 P\u2082) = li", "start": [106, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.toAffineIsometryEquiv_apply", "code": "@[simp]\ntheorem toAffineIsometryEquiv_apply [Inhabited P\u2081] (li : P\u2081 \u2192\u1d43\u2071[\ud835\udd5c] P\u2082)\n    (h : finrank \ud835\udd5c V\u2081 = finrank \ud835\udd5c V\u2082) (x : P\u2081) : (li.toAffineIsometryEquiv h) x = li x", "start": [112, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.continuous_of_finiteDimensional", "code": "theorem AffineMap.continuous_of_finiteDimensional (f : PE \u2192\u1d43[\ud835\udd5c] PF) : Continuous f", "start": [132, 1], "end": [133, 77], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.continuous_of_finiteDimensional", "code": "theorem AffineEquiv.continuous_of_finiteDimensional (f : PE \u2243\u1d43[\ud835\udd5c] PF) : Continuous f", "start": [136, 1], "end": [137, 48], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.toHomeomorphOfFiniteDimensional", "code": "def AffineEquiv.toHomeomorphOfFiniteDimensional (f : PE \u2243\u1d43[\ud835\udd5c] PF) : PE \u2243\u209c PF where\n  toEquiv := f.toEquiv\n  continuous_toFun := f.continuous_of_finiteDimensional\n  continuous_invFun :=\n    haveI : FiniteDimensional \ud835\udd5c F := f.linear.finiteDimensional\n    f.symm.continuous_of_finiteDimensional", "start": [140, 1], "end": [146, 43], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_toHomeomorphOfFiniteDimensional", "code": "@[simp]\ntheorem AffineEquiv.coe_toHomeomorphOfFiniteDimensional (f : PE \u2243\u1d43[\ud835\udd5c] PF) :\n    \u21d1f.toHomeomorphOfFiniteDimensional = f", "start": [149, 1], "end": [152, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_toHomeomorphOfFiniteDimensional_symm", "code": "@[simp]\ntheorem AffineEquiv.coe_toHomeomorphOfFiniteDimensional_symm (f : PE \u2243\u1d43[\ud835\udd5c] PF) :\n    \u21d1f.toHomeomorphOfFiniteDimensional.symm = f.symm", "start": [155, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.continuous_det", "code": "theorem ContinuousLinearMap.continuous_det : Continuous fun f : E \u2192L[\ud835\udd5c] E => f.det", "start": [163, 1], "end": [176, 87], "kind": "commanddeclaration"}, {"full_name": "lipschitzExtensionConstant", "code": "irreducible_def lipschitzExtensionConstant (E' : Type*) [NormedAddCommGroup E'] [NormedSpace \u211d E']\n  [FiniteDimensional \u211d E'] : \u211d\u22650 :=\n  let A := (Basis.ofVectorSpace \u211d E').equivFun.toContinuousLinearEquiv\n  max (\u2016A.symm.toContinuousLinearMap\u2016\u208a * \u2016A.toContinuousLinearMap\u2016\u208a) 1", "start": [179, 1], "end": [186, 71], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "lipschitzExtensionConstant_pos", "code": "theorem lipschitzExtensionConstant_pos (E' : Type*) [NormedAddCommGroup E'] [NormedSpace \u211d E']\n    [FiniteDimensional \u211d E'] : 0 < lipschitzExtensionConstant E'", "start": [189, 1], "end": [192, 48], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.extend_finite_dimension", "code": "theorem LipschitzOnWith.extend_finite_dimension {\u03b1 : Type*} [PseudoMetricSpace \u03b1] {E' : Type*}\n    [NormedAddCommGroup E'] [NormedSpace \u211d E'] [FiniteDimensional \u211d E'] {s : Set \u03b1} {f : \u03b1 \u2192 E'}\n    {K : \u211d\u22650} (hf : LipschitzOnWith K f s) :\n    \u2203 g : \u03b1 \u2192 E', LipschitzWith (lipschitzExtensionConstant E' * K) g \u2227 EqOn f g s", "start": [195, 1], "end": [220, 52], "kind": "commanddeclaration"}, {"full_name": "LinearMap.exists_antilipschitzWith", "code": "theorem LinearMap.exists_antilipschitzWith [FiniteDimensional \ud835\udd5c E] (f : E \u2192\u2097[\ud835\udd5c] F)\n    (hf : LinearMap.ker f = \u22a5) : \u2203 K > 0, AntilipschitzWith K f", "start": [223, 1], "end": [229, 50], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.eventually", "code": "protected theorem LinearIndependent.eventually {\u03b9} [Finite \u03b9] {f : \u03b9 \u2192 E}\n    (hf : LinearIndependent \ud835\udd5c f) : \u2200\u1da0 g in \ud835\udcdd f, LinearIndependent \ud835\udd5c g", "start": [232, 1], "end": [254, 34], "kind": "commanddeclaration"}, {"full_name": "isOpen_setOf_linearIndependent", "code": "theorem isOpen_setOf_linearIndependent {\u03b9 : Type*} [Finite \u03b9] :\n    IsOpen { f : \u03b9 \u2192 E | LinearIndependent \ud835\udd5c f }", "start": [257, 1], "end": [259, 62], "kind": "commanddeclaration"}, {"full_name": "isOpen_setOf_nat_le_rank", "code": "theorem isOpen_setOf_nat_le_rank (n : \u2115) :\n    IsOpen { f : E \u2192L[\ud835\udd5c] F | \u2191n \u2264 (f : E \u2192\u2097[\ud835\udd5c] F).rank }", "start": [262, 1], "end": [268, 53], "kind": "commanddeclaration"}, {"full_name": "Basis.op_nnnorm_le", "code": "theorem Basis.op_nnnorm_le {\u03b9 : Type*} [Fintype \u03b9] (v : Basis \u03b9 \ud835\udd5c E) {u : E \u2192L[\ud835\udd5c] F} (M : \u211d\u22650)\n    (hu : \u2200 i, \u2016u (v i)\u2016\u208a \u2264 M) : \u2016u\u2016\u208a \u2264 Fintype.card \u03b9 \u2022 \u2016v.equivFunL.toContinuousLinearMap\u2016\u208a * M", "start": [271, 1], "end": [287, 92], "kind": "commanddeclaration"}, {"full_name": "Basis.op_norm_le", "code": "theorem Basis.op_norm_le {\u03b9 : Type*} [Fintype \u03b9] (v : Basis \u03b9 \ud835\udd5c E) {u : E \u2192L[\ud835\udd5c] F} {M : \u211d}\n    (hM : 0 \u2264 M) (hu : \u2200 i, \u2016u (v i)\u2016 \u2264 M) :\n    \u2016u\u2016 \u2264 Fintype.card \u03b9 \u2022 \u2016v.equivFunL.toContinuousLinearMap\u2016 * M", "start": [290, 1], "end": [293, 64], "kind": "commanddeclaration"}, {"full_name": "Basis.exists_op_nnnorm_le", "code": "theorem Basis.exists_op_nnnorm_le {\u03b9 : Type*} [Finite \u03b9] (v : Basis \u03b9 \ud835\udd5c E) :\n    \u2203 C > (0 : \u211d\u22650), \u2200 {u : E \u2192L[\ud835\udd5c] F} (M : \u211d\u22650), (\u2200 i, \u2016u (v i)\u2016\u208a \u2264 M) \u2192 \u2016u\u2016\u208a \u2264 C * M", "start": [296, 1], "end": [303, 95], "kind": "commanddeclaration"}, {"full_name": "Basis.exists_op_norm_le", "code": "theorem Basis.exists_op_norm_le {\u03b9 : Type*} [Finite \u03b9] (v : Basis \u03b9 \ud835\udd5c E) :\n    \u2203 C > (0 : \u211d), \u2200 {u : E \u2192L[\ud835\udd5c] F} {M : \u211d}, 0 \u2264 M \u2192 (\u2200 i, \u2016u (v i)\u2016 \u2264 M) \u2192 \u2016u\u2016 \u2264 C * M", "start": [306, 1], "end": [313, 26], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.closed_of_finiteDimensional", "code": "theorem AffineSubspace.closed_of_finiteDimensional {P : Type*} [MetricSpace P]\n    [NormedAddTorsor E P] (s : AffineSubspace \ud835\udd5c P) [FiniteDimensional \ud835\udd5c s.direction] :\n    IsClosed (s : Set P)", "start": [362, 1], "end": [365, 70], "kind": "commanddeclaration"}, {"full_name": "exists_norm_le_le_norm_sub_of_finset", "code": "theorem exists_norm_le_le_norm_sub_of_finset {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016) {R : \u211d} (hR : \u2016c\u2016 < R)\n    (h : \u00acFiniteDimensional \ud835\udd5c E) (s : Finset E) : \u2203 x : E, \u2016x\u2016 \u2264 R \u2227 \u2200 y \u2208 s, 1 \u2264 \u2016y - x\u2016", "start": [370, 1], "end": [392, 62], "kind": "commanddeclaration"}, {"full_name": "exists_seq_norm_le_one_le_norm_sub'", "code": "theorem exists_seq_norm_le_one_le_norm_sub' {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016) {R : \u211d} (hR : \u2016c\u2016 < R)\n    (h : \u00acFiniteDimensional \ud835\udd5c E) :\n    \u2203 f : \u2115 \u2192 E, (\u2200 n, \u2016f n\u2016 \u2264 R) \u2227 \u2200 m n, m \u2260 n \u2192 1 \u2264 \u2016f m - f n\u2016", "start": [395, 1], "end": [409, 55], "kind": "commanddeclaration"}, {"full_name": "exists_seq_norm_le_one_le_norm_sub", "code": "theorem exists_seq_norm_le_one_le_norm_sub (h : \u00acFiniteDimensional \ud835\udd5c E) :\n    \u2203 (R : \u211d) (f : \u2115 \u2192 E), 1 < R \u2227 (\u2200 n, \u2016f n\u2016 \u2264 R) \u2227 \u2200 m n, m \u2260 n \u2192 1 \u2264 \u2016f m - f n\u2016", "start": [412, 1], "end": [417, 45], "kind": "commanddeclaration"}, {"full_name": "finiteDimensional_of_isCompact_closedBall\u2080", "code": "theorem finiteDimensional_of_isCompact_closedBall\u2080 {r : \u211d} (rpos : 0 < r)\n    (h : IsCompact (Metric.closedBall (0 : E) r)) : FiniteDimensional \ud835\udd5c E", "start": [422, 1], "end": [453, 42], "kind": "commanddeclaration"}, {"full_name": "finiteDimensional_of_isCompact_closedBall", "code": "theorem finiteDimensional_of_isCompact_closedBall {r : \u211d} (rpos : 0 < r) {c : E}\n    (h : IsCompact (Metric.closedBall c r)) : FiniteDimensional \ud835\udd5c E", "start": [456, 1], "end": [462, 27], "kind": "commanddeclaration"}, {"full_name": "finiteDimensional_of_locallyCompactSpace", "code": "theorem finiteDimensional_of_locallyCompactSpace [LocallyCompactSpace E] :\n    FiniteDimensional \ud835\udd5c E", "start": [465, 1], "end": [469, 61], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.eq_one_or_finiteDimensional", "code": "@[to_additive\n      \"If a function has compact support, then either the function is trivial or the space is\n      finite-dimensional.\"]\ntheorem HasCompactMulSupport.eq_one_or_finiteDimensional {X : Type*} [TopologicalSpace X] [One X]\n    [T2Space X] {f : E \u2192 X} (hf : HasCompactMulSupport f) (h'f : Continuous f) :\n    f = 1 \u2228 FiniteDimensional \ud835\udd5c E", "start": [471, 1], "end": [492, 62], "kind": "commanddeclaration"}, {"full_name": "properSpace_of_locallyCompactSpace", "code": "lemma properSpace_of_locallyCompactSpace (\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c]\n    {E : Type*} [SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n    [LocallyCompactSpace E] : ProperSpace E := by\n  rcases exists_isCompact_closedBall (0 : E) with \u27e8r, rpos, hr\u27e9\n  rcases NormedField.exists_one_lt_norm \ud835\udd5c with \u27e8c, hc\u27e9\n  have M : \u2200 n (x : E), IsCompact (closedBall x (\u2016c\u2016^n * r)) := by\n    intro n x\n    let f : E \u2192 E := fun y \u21a6 c^n \u2022 y + x\n    have Cf : Continuous f := (continuous_id.const_smul _).add continuous_const\n    have A : closedBall x (\u2016c\u2016^n * r) \u2286 f '' (closedBall 0 r) := by\n      rintro y hy\n      refine \u27e8(c^n)\u207b\u00b9 \u2022 (y - x), ?_, ?_\u27e9\n      \u00b7 simpa [dist_eq_norm, norm_smul, inv_mul_le_iff (pow_pos (zero_lt_one.trans hc) _)] using hy\n      \u00b7 have : c^n \u2260 0 := pow_ne_zero _ (norm_pos_iff.1 (zero_lt_one.trans hc))\n        simp [smul_smul, mul_inv_cancel this]\n    exact (hr.image Cf).of_isClosed_subset isClosed_ball A\n  refine \u27e8fun x s \u21a6 ?_\u27e9\n  have L : \u2200\u1da0 n in (atTop : Filter \u2115), s \u2264 \u2016c\u2016^n * r := by\n    have : Tendsto (fun n \u21a6 \u2016c\u2016^n * r) atTop atTop :=\n      Tendsto.atTop_mul_const rpos (tendsto_pow_atTop_atTop_of_one_lt hc)\n    exact Tendsto.eventually_ge_atTop this s\n  rcases L.exists with \u27e8n, hn\u27e9\n  exact (M n x).of_isClosed_subset isClosed_ball (closedBall_subset_closedBall hn)", "start": [496, 1], "end": [519, 83], "kind": "mathlibtacticlemma"}, {"full_name": "properSpace_of_locallyCompact_module", "code": "lemma properSpace_of_locallyCompact_module [Nontrivial E] [LocallyCompactSpace E] :\n    ProperSpace \ud835\udd5c := by\n  have : LocallyCompactSpace \ud835\udd5c := by\n    obtain \u27e8v, hv\u27e9 : \u2203 v : E, v \u2260 0 := exists_ne 0\n    let L : \ud835\udd5c \u2192 E := fun t \u21a6 t \u2022 v\n    have : ClosedEmbedding L := closedEmbedding_smul_left hv\n    apply ClosedEmbedding.locallyCompactSpace this\n  exact properSpace_of_locallyCompactSpace \ud835\udd5c", "start": [522, 1], "end": [529, 45], "kind": "mathlibtacticlemma"}, {"full_name": "ContinuousLinearEquiv.piRing", "code": "def ContinuousLinearEquiv.piRing (\u03b9 : Type*) [Fintype \u03b9] [DecidableEq \u03b9] :\n    ((\u03b9 \u2192 \ud835\udd5c) \u2192L[\ud835\udd5c] E) \u2243L[\ud835\udd5c] \u03b9 \u2192 E :=\n  { LinearMap.toContinuousLinearMap.symm.trans (LinearEquiv.piRing \ud835\udd5c E \u03b9 \ud835\udd5c) with\n    continuous_toFun := by\n      refine' continuous_pi fun i => _\n      exact (ContinuousLinearMap.apply \ud835\udd5c E (Pi.single i 1)).continuous\n    continuous_invFun := by\n      simp_rw [LinearEquiv.invFun_eq_symm, LinearEquiv.trans_symm, LinearEquiv.symm_symm]\n      refine AddMonoidHomClass.continuous_of_bound\n        (LinearMap.toContinuousLinearMap.toLinearMap.comp\n            (LinearEquiv.piRing \ud835\udd5c E \u03b9 \ud835\udd5c).symm.toLinearMap)\n        (Fintype.card \u03b9 : \u211d) fun g => ?_\n      rw [\u2190 nsmul_eq_mul]\n      refine op_norm_le_bound _ (nsmul_nonneg (norm_nonneg g) (Fintype.card \u03b9)) fun t => ?_\n      simp_rw [LinearMap.coe_comp, LinearEquiv.coe_toLinearMap, Function.comp_apply,\n        LinearMap.coe_toContinuousLinearMap', LinearEquiv.piRing_symm_apply]\n      apply le_trans (norm_sum_le _ _)\n      rw [smul_mul_assoc]\n      refine' Finset.sum_le_card_nsmul _ _ _ fun i _ => _\n      rw [norm_smul, mul_comm]\n      gcongr <;> apply norm_le_pi_norm }", "start": [535, 1], "end": [559, 41], "kind": "commanddeclaration"}, {"full_name": "continuousOn_clm_apply", "code": "theorem continuousOn_clm_apply {X : Type*} [TopologicalSpace X] [FiniteDimensional \ud835\udd5c E]\n    {f : X \u2192 E \u2192L[\ud835\udd5c] F} {s : Set X} : ContinuousOn f s \u2194 \u2200 y, ContinuousOn (fun x => f x y) s", "start": [562, 1], "end": [572, 80], "kind": "commanddeclaration"}, {"full_name": "continuous_clm_apply", "code": "theorem continuous_clm_apply {X : Type*} [TopologicalSpace X] [FiniteDimensional \ud835\udd5c E]\n    {f : X \u2192 E \u2192L[\ud835\udd5c] F} : Continuous f \u2194 \u2200 y, Continuous (f \u00b7 y)", "start": [575, 1], "end": [577, 69], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.proper", "code": "theorem FiniteDimensional.proper [FiniteDimensional \ud835\udd5c E] : ProperSpace E", "start": [587, 1], "end": [594, 77], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.proper_real", "code": "instance (priority := 900) FiniteDimensional.proper_real (E : Type u) [NormedAddCommGroup E]\n    [NormedSpace \u211d E] [FiniteDimensional \u211d E] : ProperSpace E :=\n  FiniteDimensional.proper \u211d E", "start": [601, 1], "end": [603, 31], "kind": "commanddeclaration"}, {"full_name": "exists_mem_frontier_infDist_compl_eq_dist", "code": "theorem exists_mem_frontier_infDist_compl_eq_dist {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace \u211d E] [FiniteDimensional \u211d E] {x : E} {s : Set E} (hx : x \u2208 s) (hs : s \u2260 univ) :\n    \u2203 y \u2208 frontier s, Metric.infDist x s\u1d9c = dist x y", "start": [616, 1], "end": [627, 18], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_mem_frontier_infDist_compl_eq_dist", "code": "nonrec theorem IsCompact.exists_mem_frontier_infDist_compl_eq_dist {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace \u211d E] [Nontrivial E] {x : E} {K : Set E} (hK : IsCompact K)\n    (hx : x \u2208 K) :\n    \u2203 y \u2208 frontier K, Metric.infDist x K\u1d9c = dist x y", "start": [630, 1], "end": [648, 61], "kind": "commanddeclaration"}, {"full_name": "summable_norm_iff", "code": "theorem summable_norm_iff {\u03b1 E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [FiniteDimensional \u211d E] {f : \u03b1 \u2192 E} : (Summable fun x => \u2016f x\u2016) \u2194 Summable f", "start": [651, 1], "end": [675, 53], "kind": "commanddeclaration"}, {"full_name": "summable_of_isBigO'", "code": "theorem summable_of_isBigO' {\u03b9 E F : Type*} [NormedAddCommGroup E] [CompleteSpace E]\n    [NormedAddCommGroup F] [NormedSpace \u211d F] [FiniteDimensional \u211d F] {f : \u03b9 \u2192 E} {g : \u03b9 \u2192 F}\n    (hg : Summable g) (h : f =O[cofinite] g) : Summable f", "start": [678, 1], "end": [681, 61], "kind": "commanddeclaration"}, {"full_name": "summable_of_isBigO_nat'", "code": "theorem summable_of_isBigO_nat' {E F : Type*} [NormedAddCommGroup E] [CompleteSpace E]\n    [NormedAddCommGroup F] [NormedSpace \u211d F] [FiniteDimensional \u211d F] {f : \u2115 \u2192 E} {g : \u2115 \u2192 F}\n    (hg : Summable g) (h : f =O[atTop] g) : Summable f", "start": [685, 1], "end": [688, 65], "kind": "commanddeclaration"}, {"full_name": "summable_of_isEquivalent", "code": "theorem summable_of_isEquivalent {\u03b9 E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [FiniteDimensional \u211d E] {f : \u03b9 \u2192 E} {g : \u03b9 \u2192 E} (hg : Summable g) (h : f ~[cofinite] g) :\n    Summable f", "start": [692, 1], "end": [695, 59], "kind": "commanddeclaration"}, {"full_name": "summable_of_isEquivalent_nat", "code": "theorem summable_of_isEquivalent_nat {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [FiniteDimensional \u211d E] {f : \u2115 \u2192 E} {g : \u2115 \u2192 E} (hg : Summable g) (h : f ~[atTop] g) :\n    Summable f", "start": [698, 1], "end": [701, 63], "kind": "commanddeclaration"}, {"full_name": "IsEquivalent.summable_iff", "code": "theorem IsEquivalent.summable_iff {\u03b9 E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [FiniteDimensional \u211d E] {f : \u03b9 \u2192 E} {g : \u03b9 \u2192 E} (h : f ~[cofinite] g) :\n    Summable f \u2194 Summable g", "start": [704, 1], "end": [707, 90], "kind": "commanddeclaration"}, {"full_name": "IsEquivalent.summable_iff_nat", "code": "theorem IsEquivalent.summable_iff_nat {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [FiniteDimensional \u211d E] {f : \u2115 \u2192 E} {g : \u2115 \u2192 E} (h : f ~[atTop] g) : Summable f \u2194 Summable g", "start": [710, 1], "end": [712, 98], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/SimpleFuncDense.lean", "imports": ["Mathlib/MeasureTheory/Function/SimpleFunc.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.SimpleFunc.nearestPtInd", "code": "noncomputable def nearestPtInd (e : \u2115 \u2192 \u03b1) : \u2115 \u2192 \u03b1 \u2192\u209b \u2115\n  | 0 => const \u03b1 0\n  | N + 1 =>\n    piecewise (\u22c2 k \u2264 N, { x | edist (e (N + 1)) x < edist (e k) x })\n      (MeasurableSet.iInter fun _ =>\n        MeasurableSet.iInter fun _ =>\n          measurableSet_lt measurable_edist_right measurable_edist_right)\n      (const \u03b1 <| N + 1) (nearestPtInd e N)", "start": [56, 1], "end": [66, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.nearestPt", "code": "noncomputable def nearestPt (e : \u2115 \u2192 \u03b1) (N : \u2115) : \u03b1 \u2192\u209b \u03b1 :=\n  (nearestPtInd e N).map e", "start": [69, 1], "end": [73, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.nearestPtInd_zero", "code": "@[simp]\ntheorem nearestPtInd_zero (e : \u2115 \u2192 \u03b1) : nearestPtInd e 0 = const \u03b1 0", "start": [76, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.nearestPt_zero", "code": "@[simp]\ntheorem nearestPt_zero (e : \u2115 \u2192 \u03b1) : nearestPt e 0 = const \u03b1 (e 0)", "start": [81, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.nearestPtInd_succ", "code": "theorem nearestPtInd_succ (e : \u2115 \u2192 \u03b1) (N : \u2115) (x : \u03b1) :\n    nearestPtInd e (N + 1) x =\n      if \u2200 k \u2264 N, edist (e (N + 1)) x < edist (e k) x then N + 1 else nearestPtInd e N x", "start": [86, 1], "end": [91, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.nearestPtInd_le", "code": "theorem nearestPtInd_le (e : \u2115 \u2192 \u03b1) (N : \u2115) (x : \u03b1) : nearestPtInd e N x \u2264 N", "start": [94, 1], "end": [98, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.edist_nearestPt_le", "code": "theorem edist_nearestPt_le (e : \u2115 \u2192 \u03b1) (x : \u03b1) {k N : \u2115} (hk : k \u2264 N) :\n    edist (nearestPt e N x) x \u2264 edist (e k) x", "start": [101, 1], "end": [112, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.tendsto_nearestPt", "code": "theorem tendsto_nearestPt {e : \u2115 \u2192 \u03b1} {x : \u03b1} (hx : x \u2208 closure (range e)) :\n    Tendsto (fun N => nearestPt e N x) atTop (\ud835\udcdd x)", "start": [115, 1], "end": [120, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.approxOn", "code": "noncomputable def approxOn (f : \u03b2 \u2192 \u03b1) (hf : Measurable f) (s : Set \u03b1) (y\u2080 : \u03b1) (h\u2080 : y\u2080 \u2208 s)\n    [SeparableSpace s] (n : \u2115) : \u03b2 \u2192\u209b \u03b1 :=\n  haveI : Nonempty s := \u27e8\u27e8y\u2080, h\u2080\u27e9\u27e9\n  comp (nearestPt (fun k => Nat.casesOn k y\u2080 ((\u2191) \u2218 denseSeq s) : \u2115 \u2192 \u03b1) n) f hf", "start": [125, 1], "end": [130, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.approxOn_zero", "code": "@[simp]\ntheorem approxOn_zero {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} {y\u2080 : \u03b1} (h\u2080 : y\u2080 \u2208 s)\n    [SeparableSpace s] (x : \u03b2) : approxOn f hf s y\u2080 h\u2080 0 x = y\u2080", "start": [133, 1], "end": [136, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.approxOn_mem", "code": "theorem approxOn_mem {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} {y\u2080 : \u03b1} (h\u2080 : y\u2080 \u2208 s)\n    [SeparableSpace s] (n : \u2115) (x : \u03b2) : approxOn f hf s y\u2080 h\u2080 n x \u2208 s", "start": [139, 1], "end": [144, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.approxOn_comp", "code": "@[simp, nolint simpNF] theorem approxOn_comp {\u03b3 : Type*} [MeasurableSpace \u03b3] {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {g : \u03b3 \u2192 \u03b2}\n    (hg : Measurable g) {s : Set \u03b1} {y\u2080 : \u03b1} (h\u2080 : y\u2080 \u2208 s) [SeparableSpace s] (n : \u2115) :\n    approxOn (f \u2218 g) (hf.comp hg) s y\u2080 h\u2080 n = (approxOn f hf s y\u2080 h\u2080 n).comp g hg", "start": [147, 1], "end": [151, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.tendsto_approxOn", "code": "theorem tendsto_approxOn {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} {y\u2080 : \u03b1} (h\u2080 : y\u2080 \u2208 s)\n    [SeparableSpace s] {x : \u03b2} (hx : f x \u2208 closure s) :\n    Tendsto (fun n => approxOn f hf s y\u2080 h\u2080 n x) atTop (\ud835\udcdd <| f x)", "start": [154, 1], "end": [164, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.edist_approxOn_mono", "code": "theorem edist_approxOn_mono {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} {y\u2080 : \u03b1} (h\u2080 : y\u2080 \u2208 s)\n    [SeparableSpace s] (x : \u03b2) {m n : \u2115} (h : m \u2264 n) :\n    edist (approxOn f hf s y\u2080 h\u2080 n x) (f x) \u2264 edist (approxOn f hf s y\u2080 h\u2080 m x) (f x)", "start": [167, 1], "end": [171, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.edist_approxOn_le", "code": "theorem edist_approxOn_le {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} {y\u2080 : \u03b1} (h\u2080 : y\u2080 \u2208 s)\n    [SeparableSpace s] (x : \u03b2) (n : \u2115) : edist (approxOn f hf s y\u2080 h\u2080 n x) (f x) \u2264 edist y\u2080 (f x)", "start": [174, 1], "end": [176, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.edist_approxOn_y0_le", "code": "theorem edist_approxOn_y0_le {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} {y\u2080 : \u03b1} (h\u2080 : y\u2080 \u2208 s)\n    [SeparableSpace s] (x : \u03b2) (n : \u2115) :\n    edist y\u2080 (approxOn f hf s y\u2080 h\u2080 n x) \u2264 edist y\u2080 (f x) + edist y\u2080 (f x)", "start": [179, 1], "end": [186, 91], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/WithDensity.lean", "imports": ["Mathlib/MeasureTheory/Integral/Lebesgue.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.Measure.withDensity", "code": "noncomputable\ndef Measure.withDensity {m : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) (f : \u03b1 \u2192 \u211d\u22650\u221e) : Measure \u03b1 :=\n  Measure.ofMeasurable (fun s _ => \u222b\u207b a in s, f a \u2202\u03bc) (by simp) fun s hs hd =>\n    lintegral_iUnion hs hd _", "start": [30, 1], "end": [35, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_apply", "code": "@[simp]\ntheorem withDensity_apply (f : \u03b1 \u2192 \u211d\u22650\u221e) {s : Set \u03b1} (hs : MeasurableSet s) :\n    \u03bc.withDensity f s = \u222b\u207b a in s, f a \u2202\u03bc", "start": [38, 1], "end": [41, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_zero_left", "code": "@[simp]\nlemma withDensity_zero_left (f : \u03b1 \u2192 \u211d\u22650\u221e) : (0 : Measure \u03b1).withDensity f = 0 := by\n  ext s hs\n  rw [withDensity_apply _ hs]\n  simp", "start": [44, 1], "end": [48, 7], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.withDensity_congr_ae", "code": "theorem withDensity_congr_ae {f g : \u03b1 \u2192 \u211d\u22650\u221e} (h : f =\u1d50[\u03bc] g) :\n    \u03bc.withDensity f = \u03bc.withDensity g", "start": [50, 1], "end": [54, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_mono", "code": "lemma withDensity_mono {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hfg : f \u2264\u1d50[\u03bc] g) :\n    \u03bc.withDensity f \u2264 \u03bc.withDensity g := by\n  intro s hs\n  rw [withDensity_apply _ hs, withDensity_apply _ hs]\n  refine set_lintegral_mono_ae' hs ?_\n  filter_upwards [hfg] with x h_le using fun _ \u21a6 h_le", "start": [57, 1], "end": [62, 54], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.withDensity_add_left", "code": "theorem withDensity_add_left {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) (g : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u03bc.withDensity (f + g) = \u03bc.withDensity f + \u03bc.withDensity g", "start": [64, 1], "end": [69, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_add_right", "code": "theorem withDensity_add_right (f : \u03b1 \u2192 \u211d\u22650\u221e) {g : \u03b1 \u2192 \u211d\u22650\u221e} (hg : Measurable g) :\n    \u03bc.withDensity (f + g) = \u03bc.withDensity f + \u03bc.withDensity g", "start": [72, 1], "end": [74, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_add_measure", "code": "theorem withDensity_add_measure {m : MeasurableSpace \u03b1} (\u03bc \u03bd : Measure \u03b1) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    (\u03bc + \u03bd).withDensity f = \u03bc.withDensity f + \u03bd.withDensity f", "start": [77, 1], "end": [80, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_sum", "code": "theorem withDensity_sum {\u03b9 : Type*} {m : MeasurableSpace \u03b1} (\u03bc : \u03b9 \u2192 Measure \u03b1) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    (sum \u03bc).withDensity f = sum fun n => (\u03bc n).withDensity f", "start": [83, 1], "end": [86, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_smul", "code": "theorem withDensity_smul (r : \u211d\u22650\u221e) {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    \u03bc.withDensity (r \u2022 f) = r \u2022 \u03bc.withDensity f", "start": [89, 1], "end": [94, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_smul'", "code": "theorem withDensity_smul' (r : \u211d\u22650\u221e) (f : \u03b1 \u2192 \u211d\u22650\u221e) (hr : r \u2260 \u221e) :\n    \u03bc.withDensity (r \u2022 f) = r \u2022 \u03bc.withDensity f", "start": [97, 1], "end": [102, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_smul_measure", "code": "theorem withDensity_smul_measure (r : \u211d\u22650\u221e) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    (r \u2022 \u03bc).withDensity f = r \u2022 \u03bc.withDensity f", "start": [105, 1], "end": [109, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.isFiniteMeasure_withDensity", "code": "theorem isFiniteMeasure_withDensity {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u222b\u207b a, f a \u2202\u03bc \u2260 \u221e) :\n    IsFiniteMeasure (\u03bc.withDensity f)", "start": [111, 1], "end": [114, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_absolutelyContinuous", "code": "theorem withDensity_absolutelyContinuous {m : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u03bc.withDensity f \u226a \u03bc", "start": [117, 1], "end": [121, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_zero", "code": "@[simp]\ntheorem withDensity_zero : \u03bc.withDensity 0 = 0", "start": [124, 1], "end": [127, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_one", "code": "@[simp]\ntheorem withDensity_one : \u03bc.withDensity 1 = \u03bc", "start": [130, 1], "end": [133, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_const", "code": "@[simp]\ntheorem withDensity_const (c : \u211d\u22650\u221e) : \u03bc.withDensity (fun _ \u21a6 c) = c \u2022 \u03bc", "start": [136, 1], "end": [139, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_tsum", "code": "theorem withDensity_tsum {f : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200 i, Measurable (f i)) :\n    \u03bc.withDensity (\u2211' n, f n) = sum fun n => \u03bc.withDensity (f n)", "start": [141, 1], "end": [147, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_indicator", "code": "theorem withDensity_indicator {s : Set \u03b1} (hs : MeasurableSet s) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u03bc.withDensity (s.indicator f) = (\u03bc.restrict s).withDensity f", "start": [150, 1], "end": [154, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_indicator_one", "code": "theorem withDensity_indicator_one {s : Set \u03b1} (hs : MeasurableSet s) :\n    \u03bc.withDensity (s.indicator 1) = \u03bc.restrict s", "start": [157, 1], "end": [159, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_ofReal_mutuallySingular", "code": "theorem withDensity_ofReal_mutuallySingular {f : \u03b1 \u2192 \u211d} (hf : Measurable f) :\n    (\u03bc.withDensity fun x => ENNReal.ofReal <| f x) \u27c2\u2098\n      \u03bc.withDensity fun x => ENNReal.ofReal <| -f x", "start": [162, 1], "end": [173, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.restrict_withDensity", "code": "theorem restrict_withDensity {s : Set \u03b1} (hs : MeasurableSet s) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    (\u03bc.withDensity f).restrict s = (\u03bc.restrict s).withDensity f", "start": [176, 1], "end": [180, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_eq_zero", "code": "theorem withDensity_eq_zero {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) (h : \u03bc.withDensity f = 0) :\n    f =\u1d50[\u03bc] 0", "start": [183, 1], "end": [186, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_apply_eq_zero", "code": "theorem withDensity_apply_eq_zero {f : \u03b1 \u2192 \u211d\u22650\u221e} {s : Set \u03b1} (hf : Measurable f) :\n    \u03bc.withDensity f s = 0 \u2194 \u03bc ({ x | f x \u2260 0 } \u2229 s) = 0", "start": [189, 1], "end": [220, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_withDensity_iff", "code": "theorem ae_withDensity_iff {p : \u03b1 \u2192 Prop} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    (\u2200\u1d50 x \u2202\u03bc.withDensity f, p x) \u2194 \u2200\u1d50 x \u2202\u03bc, f x \u2260 0 \u2192 p x", "start": [223, 1], "end": [228, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_withDensity_iff_ae_restrict", "code": "theorem ae_withDensity_iff_ae_restrict {p : \u03b1 \u2192 Prop} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    (\u2200\u1d50 x \u2202\u03bc.withDensity f, p x) \u2194 \u2200\u1d50 x \u2202\u03bc.restrict { x | f x \u2260 0 }, p x", "start": [231, 1], "end": [235, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.aemeasurable_withDensity_ennreal_iff", "code": "theorem aemeasurable_withDensity_ennreal_iff {f : \u03b1 \u2192 \u211d\u22650} (hf : Measurable f) {g : \u03b1 \u2192 \u211d\u22650\u221e} :\n    AEMeasurable g (\u03bc.withDensity fun x => (f x : \u211d\u22650\u221e)) \u2194\n      AEMeasurable (fun x => (f x : \u211d\u22650\u221e) * g x) \u03bc", "start": [238, 1], "end": [261, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_withDensity_eq_lintegral_mul", "code": "theorem lintegral_withDensity_eq_lintegral_mul (\u03bc : Measure \u03b1) {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (h_mf : Measurable f) :\n    \u2200 {g : \u03b1 \u2192 \u211d\u22650\u221e}, Measurable g \u2192 \u222b\u207b a, g a \u2202\u03bc.withDensity f = \u222b\u207b a, (f * g) a \u2202\u03bc", "start": [266, 1], "end": [285, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_withDensity_eq_set_lintegral_mul", "code": "theorem set_lintegral_withDensity_eq_set_lintegral_mul (\u03bc : Measure \u03b1) {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : Measurable f) (hg : Measurable g) {s : Set \u03b1} (hs : MeasurableSet s) :\n    \u222b\u207b x in s, g x \u2202\u03bc.withDensity f = \u222b\u207b x in s, (f * g) x \u2202\u03bc", "start": [288, 1], "end": [291, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_withDensity_eq_lintegral_mul\u2080'", "code": "theorem lintegral_withDensity_eq_lintegral_mul\u2080' {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) {g : \u03b1 \u2192 \u211d\u22650\u221e} (hg : AEMeasurable g (\u03bc.withDensity f)) :\n    \u222b\u207b a, g a \u2202\u03bc.withDensity f = \u222b\u207b a, (f * g) a \u2202\u03bc", "start": [294, 1], "end": [327, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_withDensity_eq_lintegral_mul\u2080", "code": "theorem lintegral_withDensity_eq_lintegral_mul\u2080 {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) {g : \u03b1 \u2192 \u211d\u22650\u221e} (hg : AEMeasurable g \u03bc) :\n    \u222b\u207b a, g a \u2202\u03bc.withDensity f = \u222b\u207b a, (f * g) a \u2202\u03bc", "start": [330, 1], "end": [333, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_withDensity_le_lintegral_mul", "code": "theorem lintegral_withDensity_le_lintegral_mul (\u03bc : Measure \u03b1) {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (f_meas : Measurable f) (g : \u03b1 \u2192 \u211d\u22650\u221e) : (\u222b\u207b a, g a \u2202\u03bc.withDensity f) \u2264 \u222b\u207b a, (f * g) a \u2202\u03bc", "start": [336, 1], "end": [342, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_withDensity_eq_lintegral_mul_non_measurable", "code": "theorem lintegral_withDensity_eq_lintegral_mul_non_measurable (\u03bc : Measure \u03b1) {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (f_meas : Measurable f) (hf : \u2200\u1d50 x \u2202\u03bc, f x < \u221e) (g : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a, g a \u2202\u03bc.withDensity f = \u222b\u207b a, (f * g) a \u2202\u03bc", "start": [345, 1], "end": [368, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_withDensity_eq_set_lintegral_mul_non_measurable", "code": "theorem set_lintegral_withDensity_eq_set_lintegral_mul_non_measurable (\u03bc : Measure \u03b1) {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (f_meas : Measurable f) (g : \u03b1 \u2192 \u211d\u22650\u221e) {s : Set \u03b1} (hs : MeasurableSet s)\n    (hf : \u2200\u1d50 x \u2202\u03bc.restrict s, f x < \u221e) :\n    \u222b\u207b a in s, g a \u2202\u03bc.withDensity f = \u222b\u207b a in s, (f * g) a \u2202\u03bc", "start": [371, 1], "end": [375, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_withDensity_eq_lintegral_mul_non_measurable\u2080", "code": "theorem lintegral_withDensity_eq_lintegral_mul_non_measurable\u2080 (\u03bc : Measure \u03b1) {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) (h'f : \u2200\u1d50 x \u2202\u03bc, f x < \u221e) (g : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a, g a \u2202\u03bc.withDensity f = \u222b\u207b a, (f * g) a \u2202\u03bc", "start": [378, 1], "end": [394, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_lintegral_withDensity_eq_set_lintegral_mul_non_measurable\u2080", "code": "theorem set_lintegral_withDensity_eq_set_lintegral_mul_non_measurable\u2080 (\u03bc : Measure \u03b1)\n    {f : \u03b1 \u2192 \u211d\u22650\u221e} {s : Set \u03b1} (hf : AEMeasurable f (\u03bc.restrict s)) (g : \u03b1 \u2192 \u211d\u22650\u221e)\n    (hs : MeasurableSet s) (h'f : \u2200\u1d50 x \u2202\u03bc.restrict s, f x < \u221e) :\n    \u222b\u207b a in s, g a \u2202\u03bc.withDensity f = \u222b\u207b a in s, (f * g) a \u2202\u03bc", "start": [397, 1], "end": [401, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_mul\u2080", "code": "theorem withDensity_mul\u2080 {\u03bc : Measure \u03b1} {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    \u03bc.withDensity (f * g) = (\u03bc.withDensity f).withDensity g", "start": [404, 1], "end": [409, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_mul", "code": "theorem withDensity_mul (\u03bc : Measure \u03b1) {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable f) (hg : Measurable g) :\n    \u03bc.withDensity (f * g) = (\u03bc.withDensity f).withDensity g", "start": [411, 1], "end": [413, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.withDensity_inv_same_le", "code": "lemma withDensity_inv_same_le {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) :\n    (\u03bc.withDensity f).withDensity f\u207b\u00b9 \u2264 \u03bc := by\n  change (\u03bc.withDensity f).withDensity (fun x \u21a6 (f x)\u207b\u00b9) \u2264 \u03bc\n  rw [\u2190 withDensity_mul\u2080 hf hf.inv]\n  suffices (f * fun x \u21a6 (f x)\u207b\u00b9) \u2264\u1d50[\u03bc] 1 by\n    refine (withDensity_mono this).trans ?_\n    rw [withDensity_one]\n  refine ae_of_all _ (fun x \u21a6 ?_)\n  simp only [Pi.mul_apply, Pi.one_apply]\n  by_cases hx_top : f x = \u221e\n  \u00b7 simp only [hx_top, ENNReal.inv_top, mul_zero, zero_le]\n  by_cases hx_zero : f x = 0\n  \u00b7 simp only [hx_zero, ENNReal.inv_zero, zero_mul, zero_le]\n  rw [ENNReal.mul_inv_cancel hx_zero hx_top]", "start": [416, 1], "end": [429, 45], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.withDensity_inv_same\u2080", "code": "lemma withDensity_inv_same\u2080 {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) (hf_ne_zero : \u2200\u1d50 x \u2202\u03bc, f x \u2260 0) (hf_ne_top : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    (\u03bc.withDensity f).withDensity (fun x \u21a6 (f x)\u207b\u00b9) = \u03bc := by\n  rw [\u2190 withDensity_mul\u2080 hf hf.inv]\n  suffices (f * fun x \u21a6 (f x)\u207b\u00b9) =\u1d50[\u03bc] 1 by\n    rw [withDensity_congr_ae this, withDensity_one]\n  filter_upwards [hf_ne_zero, hf_ne_top] with x hf_ne_zero hf_ne_top\n  simp only [Pi.mul_apply]\n  rw [ENNReal.mul_inv_cancel hf_ne_zero hf_ne_top, Pi.one_apply]", "start": [431, 1], "end": [439, 65], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.withDensity_inv_same", "code": "lemma withDensity_inv_same {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : Measurable f) (hf_ne_zero : \u2200\u1d50 x \u2202\u03bc, f x \u2260 0) (hf_ne_top : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    (\u03bc.withDensity f).withDensity (fun x \u21a6 (f x)\u207b\u00b9) = \u03bc :=\n  withDensity_inv_same\u2080 hf.aemeasurable hf_ne_zero hf_ne_top", "start": [441, 1], "end": [444, 61], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.withDensity_absolutelyContinuous'", "code": "lemma withDensity_absolutelyContinuous' {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) (hf_ne_zero : \u2200\u1d50 x \u2202\u03bc, f x \u2260 0) (hf_ne_top : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    \u03bc \u226a \u03bc.withDensity f := by\n  suffices (\u03bc.withDensity f).withDensity (fun x \u21a6 (f x)\u207b\u00b9) \u226a \u03bc.withDensity f by\n    rwa [withDensity_inv_same\u2080 hf hf_ne_zero hf_ne_top] at this\n  exact withDensity_absolutelyContinuous _ _", "start": [446, 1], "end": [453, 45], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.exists_absolutelyContinuous_isFiniteMeasure", "code": "theorem exists_absolutelyContinuous_isFiniteMeasure {m : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1)\n    [SigmaFinite \u03bc] : \u2203 \u03bd : Measure \u03b1, IsFiniteMeasure \u03bd \u2227 \u03bc \u226a \u03bd", "start": [455, 1], "end": [469, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.IsLocallyFiniteMeasure.withDensity_coe", "code": "lemma IsLocallyFiniteMeasure.withDensity_coe {f : \u03b1 \u2192 \u211d\u22650} (hf : Continuous f) :\n    IsLocallyFiniteMeasure (\u03bc.withDensity fun x \u21a6 f x) := by\n  refine \u27e8fun x \u21a6 ?_\u27e9\n  rcases (\u03bc.finiteAt_nhds x).exists_mem_basis ((nhds_basis_opens' x).restrict_subset\n    (eventually_le_of_tendsto_lt (lt_add_one _) (hf.tendsto x))) with \u27e8U, \u27e8\u27e8hUx, hUo\u27e9, hUf\u27e9, h\u03bcU\u27e9\n  refine \u27e8U, hUx, ?_\u27e9\n  rw [withDensity_apply _ hUo.measurableSet]\n  exact set_lintegral_lt_top_of_bddAbove h\u03bcU.ne hf.measurable \u27e8f x + 1, ball_image_iff.2 hUf\u27e9", "start": [474, 1], "end": [481, 94], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.IsLocallyFiniteMeasure.withDensity_ofReal", "code": "lemma IsLocallyFiniteMeasure.withDensity_ofReal {f : \u03b1 \u2192 \u211d} (hf : Continuous f) :\n    IsLocallyFiniteMeasure (\u03bc.withDensity fun x \u21a6 .ofReal (f x)) :=\n  .withDensity_coe <| continuous_real_toNNReal.comp hf", "start": [483, 1], "end": [485, 55], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean", "imports": ["Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "Mathlib/Topology/MetricSpace/Metrizable.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "measurable_of_tendsto_ennreal'", "code": "theorem measurable_of_tendsto_ennreal' {\u03b9} {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} {g : \u03b1 \u2192 \u211d\u22650\u221e} (u : Filter \u03b9)\n    [NeBot u] [IsCountablyGenerated u] (hf : \u2200 i, Measurable (f i)) (lim : Tendsto f u (\ud835\udcdd g)) :\n    Measurable g", "start": [28, 1], "end": [39, 44], "kind": "commanddeclaration"}, {"full_name": "measurable_of_tendsto_ennreal", "code": "theorem measurable_of_tendsto_ennreal {f : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} {g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200 i, Measurable (f i))\n    (lim : Tendsto f atTop (\ud835\udcdd g)) : Measurable g", "start": [42, 1], "end": [45, 46], "kind": "commanddeclaration"}, {"full_name": "measurable_of_tendsto_nnreal'", "code": "theorem measurable_of_tendsto_nnreal' {\u03b9} {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650} {g : \u03b1 \u2192 \u211d\u22650} (u : Filter \u03b9) [NeBot u]\n    [IsCountablyGenerated u] (hf : \u2200 i, Measurable (f i)) (lim : Tendsto f u (\ud835\udcdd g)) :\n    Measurable g", "start": [48, 1], "end": [55, 69], "kind": "commanddeclaration"}, {"full_name": "measurable_of_tendsto_nnreal", "code": "theorem measurable_of_tendsto_nnreal {f : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650} {g : \u03b1 \u2192 \u211d\u22650} (hf : \u2200 i, Measurable (f i))\n    (lim : Tendsto f atTop (\ud835\udcdd g)) : Measurable g", "start": [58, 1], "end": [61, 45], "kind": "commanddeclaration"}, {"full_name": "measurable_of_tendsto_metrizable'", "code": "theorem measurable_of_tendsto_metrizable' {\u03b9} {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b2} (u : Filter \u03b9) [NeBot u]\n    [IsCountablyGenerated u] (hf : \u2200 i, Measurable (f i)) (lim : Tendsto f u (\ud835\udcdd g)) :\n    Measurable g", "start": [64, 1], "end": [82, 41], "kind": "commanddeclaration"}, {"full_name": "measurable_of_tendsto_metrizable", "code": "theorem measurable_of_tendsto_metrizable {f : \u2115 \u2192 \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b2} (hf : \u2200 i, Measurable (f i))\n    (lim : Tendsto f atTop (\ud835\udcdd g)) : Measurable g", "start": [85, 1], "end": [89, 49], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_of_tendsto_metrizable_ae", "code": "theorem aemeasurable_of_tendsto_metrizable_ae {\u03b9} {\u03bc : Measure \u03b1} {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b2}\n    (u : Filter \u03b9) [hu : NeBot u] [IsCountablyGenerated u] (hf : \u2200 n, AEMeasurable (f n) \u03bc)\n    (h_tendsto : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) u (\ud835\udcdd (g x))) : AEMeasurable g \u03bc", "start": [92, 1], "end": [113, 62], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_of_tendsto_metrizable_ae'", "code": "theorem aemeasurable_of_tendsto_metrizable_ae' {\u03bc : Measure \u03b1} {f : \u2115 \u2192 \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 n, AEMeasurable (f n) \u03bc)\n    (h_ae_tendsto : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (g x))) : AEMeasurable g \u03bc", "start": [116, 1], "end": [119, 62], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_of_unif_approx", "code": "theorem aemeasurable_of_unif_approx {\u03b2} [MeasurableSpace \u03b2] [PseudoMetricSpace \u03b2] [BorelSpace \u03b2]\n    {\u03bc : Measure \u03b1} {g : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 \u03b5 > (0 : \u211d), \u2203 f : \u03b1 \u2192 \u03b2, AEMeasurable f \u03bc \u2227 \u2200\u1d50 x \u2202\u03bc, dist (f x) (g x) \u2264 \u03b5) :\n    AEMeasurable g \u03bc", "start": [122, 1], "end": [136, 72], "kind": "commanddeclaration"}, {"full_name": "measurable_of_tendsto_metrizable_ae", "code": "theorem measurable_of_tendsto_metrizable_ae {\u03bc : Measure \u03b1} [\u03bc.IsComplete] {f : \u2115 \u2192 \u03b1 \u2192 \u03b2}\n    {g : \u03b1 \u2192 \u03b2} (hf : \u2200 n, Measurable (f n))\n    (h_ae_tendsto : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (g x))) : Measurable g", "start": [139, 1], "end": [143, 89], "kind": "commanddeclaration"}, {"full_name": "measurable_limit_of_tendsto_metrizable_ae", "code": "theorem measurable_limit_of_tendsto_metrizable_ae {\u03b9} [Countable \u03b9] [Nonempty \u03b9] {\u03bc : Measure \u03b1}\n    {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {L : Filter \u03b9} [L.IsCountablyGenerated] (hf : \u2200 n, AEMeasurable (f n) \u03bc)\n    (h_ae_tendsto : \u2200\u1d50 x \u2202\u03bc, \u2203 l : \u03b2, Tendsto (fun n => f n x) L (\ud835\udcdd l)) :\n    \u2203 (f_lim : \u03b1 \u2192 \u03b2) (hf_lim_meas : Measurable f_lim),\n      \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) L (\ud835\udcdd (f_lim x))", "start": [146, 1], "end": [172, 50], "kind": "commanddeclaration"}, {"full_name": "measurableSet_of_tendsto_indicator", "code": "lemma measurableSet_of_tendsto_indicator [NeBot L] (As_mble : \u2200 i, MeasurableSet (As i))\n    (h_lim : Tendsto (fun i \u21a6 (As i).indicator (1 : \u03b1 \u2192 \u211d\u22650\u221e)) L (\ud835\udcdd (A.indicator 1))) :\n    MeasurableSet A := by\n  simp_rw [\u2190 measurable_indicator_const_iff (1 : \u211d\u22650\u221e)] at As_mble \u22a2\n  exact measurable_of_tendsto_ennreal' L As_mble h_lim", "start": [182, 1], "end": [188, 55], "kind": "mathlibtacticlemma"}, {"full_name": "nullMeasurableSet_of_tendsto_indicator", "code": "lemma nullMeasurableSet_of_tendsto_indicator [NeBot L] {\u03bc : Measure \u03b1}\n    (As_mble : \u2200 i, NullMeasurableSet (As i) \u03bc)\n    (h_lim : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun i \u21a6 (As i).indicator (1 : \u03b1 \u2192 \u211d\u22650\u221e) x)\n      L (\ud835\udcdd (A.indicator 1 x))) :\n    NullMeasurableSet A \u03bc := by\n  simp_rw [\u2190 aemeasurable_indicator_const_iff (1 : \u211d\u22650\u221e)] at As_mble \u22a2\n  exact aemeasurable_of_tendsto_metrizable_ae L As_mble h_lim", "start": [190, 1], "end": [198, 62], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Analysis/NormedSpace/BoundedLinearMaps.lean", "imports": ["Mathlib/Analysis/NormedSpace/Multilinear.lean", "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "Mathlib/Analysis/NormedSpace/Units.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsBoundedLinearMap", "code": "structure IsBoundedLinearMap (\ud835\udd5c : Type*) [NormedField \ud835\udd5c] {E : Type*} [NormedAddCommGroup E]\n  [NormedSpace \ud835\udd5c E] {F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F] (f : E \u2192 F) extends\n  IsLinearMap \ud835\udd5c f : Prop where\n  bound : \u2203 M, 0 < M \u2227 \u2200 x : E, \u2016f x\u2016 \u2264 M * \u2016x\u2016", "start": [66, 1], "end": [71, 48], "kind": "commanddeclaration"}, {"full_name": "IsLinearMap.with_bound", "code": "theorem IsLinearMap.with_bound {f : E \u2192 F} (hf : IsLinearMap \ud835\udd5c f) (M : \u211d)\n    (h : \u2200 x : E, \u2016f x\u2016 \u2264 M * \u2016x\u2016) : IsBoundedLinearMap \ud835\udd5c f", "start": [74, 1], "end": [81, 56], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isBoundedLinearMap", "code": "theorem ContinuousLinearMap.isBoundedLinearMap (f : E \u2192L[\ud835\udd5c] F) : IsBoundedLinearMap \ud835\udd5c f", "start": [84, 1], "end": [86, 51], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.toLinearMap", "code": "def toLinearMap (f : E \u2192 F) (h : IsBoundedLinearMap \ud835\udd5c f) : E \u2192\u2097[\ud835\udd5c] F :=\n  IsLinearMap.mk' _ h.toIsLinearMap", "start": [91, 1], "end": [93, 36], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.toContinuousLinearMap", "code": "def toContinuousLinearMap {f : E \u2192 F} (hf : IsBoundedLinearMap \ud835\udd5c f) : E \u2192L[\ud835\udd5c] F :=\n  { toLinearMap f hf with\n    cont :=\n      let \u27e8C, _, hC\u27e9 := hf.bound\n      AddMonoidHomClass.continuous_of_bound (toLinearMap f hf) C hC }", "start": [96, 1], "end": [101, 70], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.zero", "code": "theorem zero : IsBoundedLinearMap \ud835\udd5c fun _ : E => (0 : F)", "start": [104, 1], "end": [105, 61], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.id", "code": "theorem id : IsBoundedLinearMap \ud835\udd5c fun x : E => x", "start": [108, 1], "end": [109, 58], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.fst", "code": "theorem fst : IsBoundedLinearMap \ud835\udd5c fun x : E \u00d7 F => x.1", "start": [112, 1], "end": [115, 24], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.snd", "code": "theorem snd : IsBoundedLinearMap \ud835\udd5c fun x : E \u00d7 F => x.2", "start": [118, 1], "end": [121, 25], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.smul", "code": "theorem smul (c : \ud835\udd5c) (hf : IsBoundedLinearMap \ud835\udd5c f) : IsBoundedLinearMap \ud835\udd5c (c \u2022 f)", "start": [126, 1], "end": [132, 50], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.neg", "code": "theorem neg (hf : IsBoundedLinearMap \ud835\udd5c f) : IsBoundedLinearMap \ud835\udd5c fun e => -f e", "start": [136, 1], "end": [138, 21], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.add", "code": "theorem add (hf : IsBoundedLinearMap \ud835\udd5c f) (hg : IsBoundedLinearMap \ud835\udd5c g) :\n    IsBoundedLinearMap \ud835\udd5c fun e => f e + g e", "start": [141, 1], "end": [148, 45], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.sub", "code": "theorem sub (hf : IsBoundedLinearMap \ud835\udd5c f) (hg : IsBoundedLinearMap \ud835\udd5c g) :\n    IsBoundedLinearMap \ud835\udd5c fun e => f e - g e", "start": [152, 1], "end": [153, 95], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.comp", "code": "theorem comp {g : F \u2192 G} (hg : IsBoundedLinearMap \ud835\udd5c g) (hf : IsBoundedLinearMap \ud835\udd5c f) :\n    IsBoundedLinearMap \ud835\udd5c (g \u2218 f)", "start": [156, 1], "end": [158, 78], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.tendsto", "code": "protected theorem tendsto (x : E) (hf : IsBoundedLinearMap \ud835\udd5c f) : Tendsto f (\ud835\udcdd x) (\ud835\udcdd (f x))", "start": [161, 1], "end": [171, 56], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.continuous", "code": "theorem continuous (hf : IsBoundedLinearMap \ud835\udd5c f) : Continuous f", "start": [174, 1], "end": [175, 54], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.lim_zero_bounded_linear_map", "code": "theorem lim_zero_bounded_linear_map (hf : IsBoundedLinearMap \ud835\udd5c f) : Tendsto f (\ud835\udcdd 0) (\ud835\udcdd 0)", "start": [178, 1], "end": [179, 72], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.isBigO_id", "code": "theorem isBigO_id {f : E \u2192 F} (h : IsBoundedLinearMap \ud835\udd5c f) (l : Filter E) : f =O[l] fun x => x", "start": [186, 1], "end": [188, 63], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.isBigO_comp", "code": "theorem isBigO_comp {E : Type*} {g : F \u2192 G} (hg : IsBoundedLinearMap \ud835\udd5c g) {f : E \u2192 F}\n    (l : Filter E) : (fun x' => g (f x')) =O[l] f", "start": [192, 1], "end": [194, 39], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.isBigO_sub", "code": "theorem isBigO_sub {f : E \u2192 F} (h : IsBoundedLinearMap \ud835\udd5c f) (l : Filter E) (x : E) :\n    (fun x' => f (x' - x)) =O[l] fun x' => x' - x", "start": [198, 1], "end": [200, 18], "kind": "commanddeclaration"}, {"full_name": "isBoundedLinearMap_prod_multilinear", "code": "theorem isBoundedLinearMap_prod_multilinear {E : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (E i)]\n    [\u2200 i, NormedSpace \ud835\udd5c (E i)] :\n    IsBoundedLinearMap \ud835\udd5c fun p : ContinuousMultilinearMap \ud835\udd5c E F \u00d7 ContinuousMultilinearMap \ud835\udd5c E G =>\n      p.1.prod p.2", "start": [212, 1], "end": [234, 62], "kind": "commanddeclaration"}, {"full_name": "isBoundedLinearMap_continuousMultilinearMap_comp_linear", "code": "theorem isBoundedLinearMap_continuousMultilinearMap_comp_linear (g : G \u2192L[\ud835\udd5c] E) :\n    IsBoundedLinearMap \ud835\udd5c fun f : ContinuousMultilinearMap \ud835\udd5c (fun _ : \u03b9 => E) F =>\n      f.compContinuousLinearMap fun _ => g", "start": [237, 1], "end": [257, 11], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_add\u2082", "code": "theorem map_add\u2082 (f : M \u2192SL[\u03c1\u2081\u2082] F \u2192SL[\u03c3\u2081\u2082] G') (x x' : M) (y : F) :\n    f (x + x') y = f x y + f x' y", "start": [293, 1], "end": [294, 66], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_zero\u2082", "code": "theorem map_zero\u2082 (f : M \u2192SL[\u03c1\u2081\u2082] F \u2192SL[\u03c3\u2081\u2082] G') (y : F) : f 0 y = 0", "start": [297, 1], "end": [298, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_smul\u209b\u2097\u2082", "code": "theorem map_smul\u209b\u2097\u2082 (f : M \u2192SL[\u03c1\u2081\u2082] F \u2192SL[\u03c3\u2081\u2082] G') (c : R) (x : M) (y : F) :\n    f (c \u2022 x) y = \u03c1\u2081\u2082 c \u2022 f x y", "start": [301, 1], "end": [302, 68], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_sub\u2082", "code": "theorem map_sub\u2082 (f : M \u2192SL[\u03c1\u2081\u2082] F \u2192SL[\u03c3\u2081\u2082] G') (x x' : M) (y : F) :\n    f (x - x') y = f x y - f x' y", "start": [311, 1], "end": [312, 66], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_neg\u2082", "code": "theorem map_neg\u2082 (f : M \u2192SL[\u03c1\u2081\u2082] F \u2192SL[\u03c3\u2081\u2082] G') (x : M) (y : F) : f (-x) y = -f x y", "start": [315, 1], "end": [316, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_smul\u2082", "code": "theorem map_smul\u2082 (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (c : \ud835\udd5c) (x : E) (y : F) : f (c \u2022 x) y = c \u2022 f x y", "start": [321, 1], "end": [322, 30], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap", "code": "structure IsBoundedBilinearMap (f : E \u00d7 F \u2192 G) : Prop where\n  add_left : \u2200 (x\u2081 x\u2082 : E) (y : F), f (x\u2081 + x\u2082, y) = f (x\u2081, y) + f (x\u2082, y)\n  smul_left : \u2200 (c : \ud835\udd5c) (x : E) (y : F), f (c \u2022 x, y) = c \u2022 f (x, y)\n  add_right : \u2200 (x : E) (y\u2081 y\u2082 : F), f (x, y\u2081 + y\u2082) = f (x, y\u2081) + f (x, y\u2082)\n  smul_right : \u2200 (c : \ud835\udd5c) (x : E) (y : F), f (x, c \u2022 y) = c \u2022 f (x, y)\n  bound : \u2203 C > 0, \u2200 (x : E) (y : F), \u2016f (x, y)\u2016 \u2264 C * \u2016x\u2016 * \u2016y\u2016", "start": [329, 1], "end": [336, 65], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isBoundedBilinearMap", "code": "theorem ContinuousLinearMap.isBoundedBilinearMap (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) :\n    IsBoundedBilinearMap \ud835\udd5c fun x : E \u00d7 F => f x.1 x.2", "start": [343, 1], "end": [352, 81], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.toContinuousLinearMap", "code": "def IsBoundedBilinearMap.toContinuousLinearMap (hf : IsBoundedBilinearMap \ud835\udd5c f) :\n    E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G :=\n  LinearMap.mkContinuousOfExistsBound\u2082\n    (LinearMap.mk\u2082 _ f.curry hf.add_left hf.smul_left hf.add_right hf.smul_right) <|\n    hf.bound.imp fun _ \u21a6 And.right", "start": [356, 1], "end": [362, 35], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.isBigO", "code": "protected theorem IsBoundedBilinearMap.isBigO (h : IsBoundedBilinearMap \ud835\udd5c f) :\n    f =O[\u22a4] fun p : E \u00d7 F => \u2016p.1\u2016 * \u2016p.2\u2016", "start": [364, 1], "end": [368, 80], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.isBigO_comp", "code": "theorem IsBoundedBilinearMap.isBigO_comp {\u03b1 : Type*} (H : IsBoundedBilinearMap \ud835\udd5c f) {g : \u03b1 \u2192 E}\n    {h : \u03b1 \u2192 F} {l : Filter \u03b1} : (fun x => f (g x, h x)) =O[l] fun x => \u2016g x\u2016 * \u2016h x\u2016", "start": [372, 1], "end": [374, 31], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.isBigO'", "code": "protected theorem IsBoundedBilinearMap.isBigO' (h : IsBoundedBilinearMap \ud835\udd5c f) :\n    f =O[\u22a4] fun p : E \u00d7 F => \u2016p\u2016 * \u2016p\u2016", "start": [378, 1], "end": [382, 62], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.map_sub_left", "code": "theorem IsBoundedBilinearMap.map_sub_left (h : IsBoundedBilinearMap \ud835\udd5c f) {x y : E} {z : F} :\n    f (x - y, z) = f (x, z) - f (y, z)", "start": [386, 1], "end": [388, 47], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.map_sub_right", "code": "theorem IsBoundedBilinearMap.map_sub_right (h : IsBoundedBilinearMap \ud835\udd5c f) {x : E} {y z : F} :\n    f (x, y - z) = f (x, y) - f (x, z)", "start": [391, 1], "end": [393, 42], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.continuous", "code": "theorem IsBoundedBilinearMap.continuous (h : IsBoundedBilinearMap \ud835\udd5c f) : Continuous f", "start": [397, 1], "end": [409, 96], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.continuous_left", "code": "theorem IsBoundedBilinearMap.continuous_left (h : IsBoundedBilinearMap \ud835\udd5c f) {e\u2082 : F} :\n    Continuous fun e\u2081 => f (e\u2081, e\u2082)", "start": [412, 1], "end": [414, 61], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.continuous_right", "code": "theorem IsBoundedBilinearMap.continuous_right (h : IsBoundedBilinearMap \ud835\udd5c f) {e\u2081 : E} :\n    Continuous fun e\u2082 => f (e\u2081, e\u2082)", "start": [417, 1], "end": [419, 61], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.continuous\u2082", "code": "theorem ContinuousLinearMap.continuous\u2082 (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) :\n    Continuous (Function.uncurry fun x y => f x y)", "start": [422, 1], "end": [425, 36], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.isBoundedLinearMap_left", "code": "theorem IsBoundedBilinearMap.isBoundedLinearMap_left (h : IsBoundedBilinearMap \ud835\udd5c f) (y : F) :\n    IsBoundedLinearMap \ud835\udd5c fun x => f (x, y)", "start": [428, 1], "end": [430, 54], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.isBoundedLinearMap_right", "code": "theorem IsBoundedBilinearMap.isBoundedLinearMap_right (h : IsBoundedBilinearMap \ud835\udd5c f) (x : E) :\n    IsBoundedLinearMap \ud835\udd5c fun y => f (x, y)", "start": [433, 1], "end": [435, 49], "kind": "commanddeclaration"}, {"full_name": "isBoundedBilinearMap_smul", "code": "theorem isBoundedBilinearMap_smul {\ud835\udd5c' : Type*} [NormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c' E] [IsScalarTower \ud835\udd5c \ud835\udd5c' E] :\n    IsBoundedBilinearMap \ud835\udd5c fun p : \ud835\udd5c' \u00d7 E => p.1 \u2022 p.2", "start": [438, 1], "end": [441, 57], "kind": "commanddeclaration"}, {"full_name": "isBoundedBilinearMap_mul", "code": "theorem isBoundedBilinearMap_mul : IsBoundedBilinearMap \ud835\udd5c fun p : \ud835\udd5c \u00d7 \ud835\udd5c => p.1 * p.2", "start": [444, 1], "end": [446, 34], "kind": "commanddeclaration"}, {"full_name": "isBoundedBilinearMap_comp", "code": "theorem isBoundedBilinearMap_comp :\n    IsBoundedBilinearMap \ud835\udd5c fun p : (F \u2192L[\ud835\udd5c] G) \u00d7 (E \u2192L[\ud835\udd5c] F) => p.1.comp p.2", "start": [449, 1], "end": [451, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isBoundedLinearMap_comp_left", "code": "theorem ContinuousLinearMap.isBoundedLinearMap_comp_left (g : F \u2192L[\ud835\udd5c] G) :\n    IsBoundedLinearMap \ud835\udd5c fun f : E \u2192L[\ud835\udd5c] F => ContinuousLinearMap.comp g f", "start": [454, 1], "end": [456, 55], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isBoundedLinearMap_comp_right", "code": "theorem ContinuousLinearMap.isBoundedLinearMap_comp_right (f : E \u2192L[\ud835\udd5c] F) :\n    IsBoundedLinearMap \ud835\udd5c fun g : F \u2192L[\ud835\udd5c] G => ContinuousLinearMap.comp g f", "start": [459, 1], "end": [461, 54], "kind": "commanddeclaration"}, {"full_name": "isBoundedBilinearMap_apply", "code": "theorem isBoundedBilinearMap_apply : IsBoundedBilinearMap \ud835\udd5c fun p : (E \u2192L[\ud835\udd5c] F) \u00d7 E => p.1 p.2", "start": [464, 1], "end": [465, 92], "kind": "commanddeclaration"}, {"full_name": "isBoundedBilinearMap_smulRight", "code": "theorem isBoundedBilinearMap_smulRight :\n    IsBoundedBilinearMap \ud835\udd5c fun p =>\n      (ContinuousLinearMap.smulRight : (E \u2192L[\ud835\udd5c] \ud835\udd5c) \u2192 F \u2192 E \u2192L[\ud835\udd5c] F) p.1 p.2", "start": [468, 1], "end": [474, 42], "kind": "commanddeclaration"}, {"full_name": "isBoundedBilinearMap_compMultilinear", "code": "theorem isBoundedBilinearMap_compMultilinear {\u03b9 : Type*} {E : \u03b9 \u2192 Type*} [Fintype \u03b9]\n    [\u2200 i, NormedAddCommGroup (E i)] [\u2200 i, NormedSpace \ud835\udd5c (E i)] :\n    IsBoundedBilinearMap \ud835\udd5c fun p : (F \u2192L[\ud835\udd5c] G) \u00d7 ContinuousMultilinearMap \ud835\udd5c E F =>\n      p.1.compContinuousMultilinearMap p.2", "start": [477, 1], "end": [483, 63], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.linearDeriv", "code": "def IsBoundedBilinearMap.linearDeriv (h : IsBoundedBilinearMap \ud835\udd5c f) (p : E \u00d7 F) : E \u00d7 F \u2192\u2097[\ud835\udd5c] G :=\n  (h.toContinuousLinearMap.deriv\u2082 p).toLinearMap", "start": [486, 1], "end": [492, 49], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.deriv", "code": "def IsBoundedBilinearMap.deriv (h : IsBoundedBilinearMap \ud835\udd5c f) (p : E \u00d7 F) : E \u00d7 F \u2192L[\ud835\udd5c] G :=\n  h.toContinuousLinearMap.deriv\u2082 p", "start": [495, 1], "end": [499, 35], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.deriv_apply", "code": "@[simp]\ntheorem IsBoundedBilinearMap.deriv_apply (h : IsBoundedBilinearMap \ud835\udd5c f) (p q : E \u00d7 F) :\n    h.deriv p q = f (p.1, q.2) + f (q.1, p.2)", "start": [502, 1], "end": [505, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mulLeftRight_isBoundedBilinear", "code": "theorem ContinuousLinearMap.mulLeftRight_isBoundedBilinear (\ud835\udd5c' : Type*) [NormedRing \ud835\udd5c']\n    [NormedAlgebra \ud835\udd5c \ud835\udd5c'] :\n    IsBoundedBilinearMap \ud835\udd5c fun p : \ud835\udd5c' \u00d7 \ud835\udd5c' => ContinuousLinearMap.mulLeftRight \ud835\udd5c \ud835\udd5c' p.1 p.2", "start": [510, 1], "end": [515, 63], "kind": "commanddeclaration"}, {"full_name": "IsBoundedBilinearMap.isBoundedLinearMap_deriv", "code": "theorem IsBoundedBilinearMap.isBoundedLinearMap_deriv (h : IsBoundedBilinearMap \ud835\udd5c f) :\n    IsBoundedLinearMap \ud835\udd5c fun p : E \u00d7 F => h.deriv p", "start": [520, 1], "end": [524, 52], "kind": "commanddeclaration"}, {"full_name": "Continuous.clm_comp", "code": "@[continuity]\ntheorem Continuous.clm_comp {X} [TopologicalSpace X] {g : X \u2192 F \u2192L[\ud835\udd5c] G} {f : X \u2192 E \u2192L[\ud835\udd5c] F}\n    (hg : Continuous g) (hf : Continuous f) : Continuous fun x => (g x).comp (f x)", "start": [529, 1], "end": [532, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.clm_comp", "code": "theorem ContinuousOn.clm_comp {X} [TopologicalSpace X] {g : X \u2192 F \u2192L[\ud835\udd5c] G} {f : X \u2192 E \u2192L[\ud835\udd5c] F}\n    {s : Set X} (hg : ContinuousOn g s) (hf : ContinuousOn f s) :\n    ContinuousOn (fun x => (g x).comp (f x)) s", "start": [535, 1], "end": [538, 61], "kind": "commanddeclaration"}, {"full_name": "Continuous.clm_apply", "code": "@[continuity]\ntheorem Continuous.clm_apply {X} [TopologicalSpace X] {f : X \u2192 (E \u2192L[\ud835\udd5c] F)} {g : X \u2192 E}\n    (hf : Continuous f) (hg : Continuous g) : Continuous (fun x \u21a6 (f x) (g x))", "start": [541, 1], "end": [544, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.clm_apply", "code": "theorem ContinuousOn.clm_apply {X} [TopologicalSpace X] {f : X \u2192 (E \u2192L[\ud835\udd5c] F)} {g : X \u2192 E}\n    {s : Set X} (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x \u21a6 f x (g x)) s", "start": [546, 1], "end": [549, 71], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.isOpen", "code": "protected theorem isOpen [CompleteSpace E] : IsOpen (range ((\u2191) : (E \u2243L[\ud835\udd5c] F) \u2192 E \u2192L[\ud835\udd5c] F))", "start": [562, 1], "end": [575, 14], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.nhds", "code": "protected theorem nhds [CompleteSpace E] (e : E \u2243L[\ud835\udd5c] F) :\n    range ((\u2191) : (E \u2243L[\ud835\udd5c] F) \u2192 E \u2192L[\ud835\udd5c] F) \u2208 \ud835\udcdd (e : E \u2192L[\ud835\udd5c] F)", "start": [578, 1], "end": [580, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NNReal.rpow", "code": "noncomputable def rpow (x : \u211d\u22650) (y : \u211d) : \u211d\u22650 :=\n  \u27e8(x : \u211d) ^ y, Real.rpow_nonneg_of_nonneg x.2 y\u27e9", "start": [31, 1], "end": [35, 50], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_eq_pow", "code": "@[simp]\ntheorem rpow_eq_pow (x : \u211d\u22650) (y : \u211d) : rpow x y = x ^ y", "start": [41, 1], "end": [43, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_rpow", "code": "@[simp, norm_cast]\ntheorem coe_rpow (x : \u211d\u22650) (y : \u211d) : ((x ^ y : \u211d\u22650) : \u211d) = (x : \u211d) ^ y", "start": [46, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_zero", "code": "@[simp]\ntheorem rpow_zero (x : \u211d\u22650) : x ^ (0 : \u211d) = 1", "start": [51, 1], "end": [53, 32], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_eq_zero_iff", "code": "@[simp]\ntheorem rpow_eq_zero_iff {x : \u211d\u22650} {y : \u211d} : x ^ y = 0 \u2194 x = 0 \u2227 y \u2260 0", "start": [56, 1], "end": [59, 44], "kind": "commanddeclaration"}, {"full_name": "NNReal.zero_rpow", "code": "@[simp]\ntheorem zero_rpow {x : \u211d} (h : x \u2260 0) : (0 : \u211d\u22650) ^ x = 0", "start": [62, 1], "end": [64, 32], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_one", "code": "@[simp]\ntheorem rpow_one (x : \u211d\u22650) : x ^ (1 : \u211d) = x", "start": [67, 1], "end": [69, 31], "kind": "commanddeclaration"}, {"full_name": "NNReal.one_rpow", "code": "@[simp]\ntheorem one_rpow (x : \u211d) : (1 : \u211d\u22650) ^ x = 1", "start": [72, 1], "end": [74, 31], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_add", "code": "theorem rpow_add {x : \u211d\u22650} (hx : x \u2260 0) (y z : \u211d) : x ^ (y + z) = x ^ y * x ^ z", "start": [77, 1], "end": [78, 56], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_add'", "code": "theorem rpow_add' (x : \u211d\u22650) {y z : \u211d} (h : y + z \u2260 0) : x ^ (y + z) = x ^ y * x ^ z", "start": [81, 1], "end": [82, 36], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_mul", "code": "theorem rpow_mul (x : \u211d\u22650) (y z : \u211d) : x ^ (y * z) = (x ^ y) ^ z", "start": [85, 1], "end": [86, 37], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_neg", "code": "theorem rpow_neg (x : \u211d\u22650) (y : \u211d) : x ^ (-y) = (x ^ y)\u207b\u00b9", "start": [89, 1], "end": [90, 35], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_neg_one", "code": "theorem rpow_neg_one (x : \u211d\u22650) : x ^ (-1 : \u211d) = x\u207b\u00b9", "start": [93, 1], "end": [93, 74], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_sub", "code": "theorem rpow_sub {x : \u211d\u22650} (hx : x \u2260 0) (y z : \u211d) : x ^ (y - z) = x ^ y / x ^ z", "start": [96, 1], "end": [97, 56], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_sub'", "code": "theorem rpow_sub' (x : \u211d\u22650) {y z : \u211d} (h : y - z \u2260 0) : x ^ (y - z) = x ^ y / x ^ z", "start": [100, 1], "end": [101, 36], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_inv_rpow_self", "code": "theorem rpow_inv_rpow_self {y : \u211d} (hy : y \u2260 0) (x : \u211d\u22650) : (x ^ y) ^ (1 / y) = x", "start": [104, 1], "end": [105, 26], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_self_rpow_inv", "code": "theorem rpow_self_rpow_inv {y : \u211d} (hy : y \u2260 0) (x : \u211d\u22650) : (x ^ (1 / y)) ^ y = x", "start": [108, 1], "end": [109, 26], "kind": "commanddeclaration"}, {"full_name": "NNReal.inv_rpow", "code": "theorem inv_rpow (x : \u211d\u22650) (y : \u211d) : x\u207b\u00b9 ^ y = (x ^ y)\u207b\u00b9", "start": [112, 1], "end": [113, 35], "kind": "commanddeclaration"}, {"full_name": "NNReal.div_rpow", "code": "theorem div_rpow (x y : \u211d\u22650) (z : \u211d) : (x / y) ^ z = x ^ z / y ^ z", "start": [116, 1], "end": [117, 39], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_eq_rpow", "code": "theorem sqrt_eq_rpow (x : \u211d\u22650) : sqrt x = x ^ (1 / (2 : \u211d))", "start": [120, 1], "end": [123, 30], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_nat_cast", "code": "@[simp, norm_cast]\ntheorem rpow_nat_cast (x : \u211d\u22650) (n : \u2115) : x ^ (n : \u211d) = x ^ n", "start": [126, 1], "end": [128, 78], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_two", "code": "@[simp]\ntheorem rpow_two (x : \u211d\u22650) : x ^ (2 : \u211d) = x ^ 2", "start": [131, 1], "end": [134, 29], "kind": "commanddeclaration"}, {"full_name": "NNReal.mul_rpow", "code": "theorem mul_rpow {x y : \u211d\u22650} {z : \u211d} : (x * y) ^ z = x ^ z * y ^ z", "start": [137, 1], "end": [138, 37], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpowMonoidHom", "code": "@[simps]\ndef rpowMonoidHom (r : \u211d) : \u211d\u22650 \u2192* \u211d\u22650 where\n  toFun := (\u00b7 ^ r)\n  map_one' := one_rpow _\n  map_mul' _x _y := mul_rpow", "start": [141, 1], "end": [146, 29], "kind": "commanddeclaration"}, {"full_name": "NNReal.list_prod_map_rpow", "code": "theorem list_prod_map_rpow (l : List \u211d\u22650) (r : \u211d) :\n    (l.map (\u00b7 ^ r)).prod = l.prod ^ r", "start": [148, 1], "end": [151, 31], "kind": "commanddeclaration"}, {"full_name": "NNReal.list_prod_map_rpow'", "code": "theorem list_prod_map_rpow' {\u03b9} (l : List \u03b9) (f : \u03b9 \u2192 \u211d\u22650) (r : \u211d) :\n    (l.map (f \u00b7 ^ r)).prod = (l.map f).prod ^ r", "start": [153, 1], "end": [155, 46], "kind": "commanddeclaration"}, {"full_name": "NNReal.multiset_prod_map_rpow", "code": "lemma multiset_prod_map_rpow {\u03b9} (s : Multiset \u03b9) (f : \u03b9 \u2192 \u211d\u22650) (r : \u211d) :\n    (s.map (f \u00b7 ^ r)).prod = (s.map f).prod ^ r :=\n  s.prod_hom' (rpowMonoidHom r) _", "start": [157, 1], "end": [160, 34], "kind": "mathlibtacticlemma"}, {"full_name": "NNReal.finset_prod_rpow", "code": "lemma finset_prod_rpow {\u03b9} (s : Finset \u03b9) (f : \u03b9 \u2192 \u211d\u22650) (r : \u211d) :\n    (\u220f i in s, f i ^ r) = (\u220f i in s, f i) ^ r :=\n  multiset_prod_map_rpow _ _ _", "start": [162, 1], "end": [165, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Real.list_prod_map_rpow", "code": "theorem _root_.Real.list_prod_map_rpow (l : List \u211d) (hl : \u2200 x \u2208 l, (0 : \u211d) \u2264 x) (r : \u211d) :\n    (l.map (\u00b7 ^ r)).prod = l.prod ^ r", "start": [171, 1], "end": [178, 22], "kind": "commanddeclaration"}, {"full_name": "Real.list_prod_map_rpow'", "code": "theorem _root_.Real.list_prod_map_rpow' {\u03b9} (l : List \u03b9) (f : \u03b9 \u2192 \u211d)\n    (hl : \u2200 i \u2208 l, (0 : \u211d) \u2264 f i) (r : \u211d) :\n    (l.map (f \u00b7 ^ r)).prod = (l.map f).prod ^ r", "start": [180, 1], "end": [184, 17], "kind": "commanddeclaration"}, {"full_name": "Real.multiset_prod_map_rpow", "code": "theorem _root_.Real.multiset_prod_map_rpow {\u03b9} (s : Multiset \u03b9) (f : \u03b9 \u2192 \u211d)\n    (hs : \u2200 i \u2208 s, (0 : \u211d) \u2264 f i) (r : \u211d) :\n    (s.map (f \u00b7 ^ r)).prod = (s.map f).prod ^ r", "start": [186, 1], "end": [191, 48], "kind": "commanddeclaration"}, {"full_name": "Real.finset_prod_rpow", "code": "theorem _root_.Real.finset_prod_rpow\n    {\u03b9} (s : Finset \u03b9) (f : \u03b9 \u2192 \u211d) (hs : \u2200 i \u2208 s, 0 \u2264 f i) (r : \u211d) :\n    (\u220f i in s, f i ^ r) = (\u220f i in s, f i) ^ r", "start": [193, 1], "end": [197, 43], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_le_rpow", "code": "theorem rpow_le_rpow {x y : \u211d\u22650} {z : \u211d} (h\u2081 : x \u2264 y) (h\u2082 : 0 \u2264 z) : x ^ z \u2264 y ^ z", "start": [201, 1], "end": [202, 30], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_lt_rpow", "code": "theorem rpow_lt_rpow {x y : \u211d\u22650} {z : \u211d} (h\u2081 : x < y) (h\u2082 : 0 < z) : x ^ z < y ^ z", "start": [205, 1], "end": [206, 30], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_lt_rpow_iff", "code": "theorem rpow_lt_rpow_iff {x y : \u211d\u22650} {z : \u211d} (hz : 0 < z) : x ^ z < y ^ z \u2194 x < y", "start": [209, 1], "end": [210, 35], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_le_rpow_iff", "code": "theorem rpow_le_rpow_iff {x y : \u211d\u22650} {z : \u211d} (hz : 0 < z) : x ^ z \u2264 y ^ z \u2194 x \u2264 y", "start": [213, 1], "end": [214, 35], "kind": "commanddeclaration"}, {"full_name": "NNReal.le_rpow_one_div_iff", "code": "theorem le_rpow_one_div_iff {x y : \u211d\u22650} {z : \u211d} (hz : 0 < z) : x \u2264 y ^ (1 / z) \u2194 x ^ z \u2264 y", "start": [217, 1], "end": [218, 56], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_one_div_le_iff", "code": "theorem rpow_one_div_le_iff {x y : \u211d\u22650} {z : \u211d} (hz : 0 < z) : x ^ (1 / z) \u2264 y \u2194 x \u2264 y ^ z", "start": [221, 1], "end": [222, 56], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_lt_rpow_of_exponent_lt", "code": "theorem rpow_lt_rpow_of_exponent_lt {x : \u211d\u22650} {y z : \u211d} (hx : 1 < x) (hyz : y < z) :\n    x ^ y < x ^ z", "start": [225, 1], "end": [227, 42], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_le_rpow_of_exponent_le", "code": "theorem rpow_le_rpow_of_exponent_le {x : \u211d\u22650} {y z : \u211d} (hx : 1 \u2264 x) (hyz : y \u2264 z) :\n    x ^ y \u2264 x ^ z", "start": [230, 1], "end": [232, 42], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_lt_rpow_of_exponent_gt", "code": "theorem rpow_lt_rpow_of_exponent_gt {x : \u211d\u22650} {y z : \u211d} (hx0 : 0 < x) (hx1 : x < 1) (hyz : z < y) :\n    x ^ y < x ^ z", "start": [235, 1], "end": [237, 47], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_le_rpow_of_exponent_ge", "code": "theorem rpow_le_rpow_of_exponent_ge {x : \u211d\u22650} {y z : \u211d} (hx0 : 0 < x) (hx1 : x \u2264 1) (hyz : z \u2264 y) :\n    x ^ y \u2264 x ^ z", "start": [240, 1], "end": [242, 47], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_pos", "code": "theorem rpow_pos {p : \u211d} {x : \u211d\u22650} (hx_pos : 0 < x) : 0 < x ^ p", "start": [245, 1], "end": [254, 50], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_lt_one", "code": "theorem rpow_lt_one {x : \u211d\u22650} {z : \u211d} (hx1 : x < 1) (hz : 0 < z) : x ^ z < 1", "start": [257, 1], "end": [258, 41], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_le_one", "code": "theorem rpow_le_one {x : \u211d\u22650} {z : \u211d} (hx2 : x \u2264 1) (hz : 0 \u2264 z) : x ^ z \u2264 1", "start": [261, 1], "end": [262, 30], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_lt_one_of_one_lt_of_neg", "code": "theorem rpow_lt_one_of_one_lt_of_neg {x : \u211d\u22650} {z : \u211d} (hx : 1 < x) (hz : z < 0) : x ^ z < 1", "start": [265, 1], "end": [266, 42], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_le_one_of_one_le_of_nonpos", "code": "theorem rpow_le_one_of_one_le_of_nonpos {x : \u211d\u22650} {z : \u211d} (hx : 1 \u2264 x) (hz : z \u2264 0) : x ^ z \u2264 1", "start": [269, 1], "end": [270, 45], "kind": "commanddeclaration"}, {"full_name": "NNReal.one_lt_rpow", "code": "theorem one_lt_rpow {x : \u211d\u22650} {z : \u211d} (hx : 1 < x) (hz : 0 < z) : 1 < x ^ z", "start": [273, 1], "end": [274, 25], "kind": "commanddeclaration"}, {"full_name": "NNReal.one_le_rpow", "code": "theorem one_le_rpow {x : \u211d\u22650} {z : \u211d} (h : 1 \u2264 x) (h\u2081 : 0 \u2264 z) : 1 \u2264 x ^ z", "start": [277, 1], "end": [278, 24], "kind": "commanddeclaration"}, {"full_name": "NNReal.one_lt_rpow_of_pos_of_lt_one_of_neg", "code": "theorem one_lt_rpow_of_pos_of_lt_one_of_neg {x : \u211d\u22650} {z : \u211d} (hx1 : 0 < x) (hx2 : x < 1)\n    (hz : z < 0) : 1 < x ^ z", "start": [281, 1], "end": [283, 54], "kind": "commanddeclaration"}, {"full_name": "NNReal.one_le_rpow_of_pos_of_le_one_of_nonpos", "code": "theorem one_le_rpow_of_pos_of_le_one_of_nonpos {x : \u211d\u22650} {z : \u211d} (hx1 : 0 < x) (hx2 : x \u2264 1)\n    (hz : z \u2264 0) : 1 \u2264 x ^ z", "start": [286, 1], "end": [288, 57], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_le_self_of_le_one", "code": "theorem rpow_le_self_of_le_one {x : \u211d\u22650} {z : \u211d} (hx : x \u2264 1) (h_one_le : 1 \u2264 z) : x ^ z \u2264 x", "start": [291, 1], "end": [296, 57], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_left_injective", "code": "theorem rpow_left_injective {x : \u211d} (hx : x \u2260 0) : Function.Injective fun y : \u211d\u22650 => y ^ x", "start": [299, 1], "end": [300, 98], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_eq_rpow_iff", "code": "theorem rpow_eq_rpow_iff {x y : \u211d\u22650} {z : \u211d} (hz : z \u2260 0) : x ^ z = y ^ z \u2194 x = y", "start": [303, 1], "end": [304, 34], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_left_surjective", "code": "theorem rpow_left_surjective {x : \u211d} (hx : x \u2260 0) : Function.Surjective fun y : \u211d\u22650 => y ^ x", "start": [307, 1], "end": [308, 82], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_left_bijective", "code": "theorem rpow_left_bijective {x : \u211d} (hx : x \u2260 0) : Function.Bijective fun y : \u211d\u22650 => y ^ x", "start": [311, 1], "end": [312, 52], "kind": "commanddeclaration"}, {"full_name": "NNReal.eq_rpow_one_div_iff", "code": "theorem eq_rpow_one_div_iff {x y : \u211d\u22650} {z : \u211d} (hz : z \u2260 0) : x = y ^ (1 / z) \u2194 x ^ z = y", "start": [315, 1], "end": [316, 52], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_one_div_eq_iff", "code": "theorem rpow_one_div_eq_iff {x y : \u211d\u22650} {z : \u211d} (hz : z \u2260 0) : x ^ (1 / z) = y \u2194 x = y ^ z", "start": [319, 1], "end": [320, 52], "kind": "commanddeclaration"}, {"full_name": "NNReal.pow_nat_rpow_nat_inv", "code": "theorem pow_nat_rpow_nat_inv (x : \u211d\u22650) {n : \u2115} (hn : n \u2260 0) : (x ^ n) ^ (n\u207b\u00b9 : \u211d) = x", "start": [323, 1], "end": [325, 41], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_nat_inv_pow_nat", "code": "theorem rpow_nat_inv_pow_nat (x : \u211d\u22650) {n : \u2115} (hn : n \u2260 0) : (x ^ (n\u207b\u00b9 : \u211d)) ^ n = x", "start": [328, 1], "end": [330, 41], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_rpow_of_nonneg", "code": "theorem _root_.Real.toNNReal_rpow_of_nonneg {x y : \u211d} (hx : 0 \u2264 x) :\n    Real.toNNReal (x ^ y) = Real.toNNReal x ^ y", "start": [333, 1], "end": [336, 44], "kind": "commanddeclaration"}, {"full_name": "NNReal.strictMono_rpow_of_pos", "code": "theorem strictMono_rpow_of_pos {z : \u211d} (h : 0 < z) : StrictMono fun x : \u211d\u22650 => x ^ z", "start": [339, 1], "end": [340, 70], "kind": "commanddeclaration"}, {"full_name": "NNReal.monotone_rpow_of_nonneg", "code": "theorem monotone_rpow_of_nonneg {z : \u211d} (h : 0 \u2264 z) : Monotone fun x : \u211d\u22650 => x ^ z", "start": [342, 1], "end": [344, 41], "kind": "commanddeclaration"}, {"full_name": "NNReal.orderIsoRpow", "code": "@[simps! apply]\ndef orderIsoRpow (y : \u211d) (hy : 0 < y) : \u211d\u22650 \u2243o \u211d\u22650 :=\n  (strictMono_rpow_of_pos hy).orderIsoOfRightInverse (fun x => x ^ y) (fun x => x ^ (1 / y))\n    fun x => by\n      dsimp\n      rw [\u2190 rpow_mul, one_div_mul_cancel hy.ne.symm, rpow_one]", "start": [346, 1], "end": [353, 63], "kind": "commanddeclaration"}, {"full_name": "NNReal.orderIsoRpow_symm_eq", "code": "theorem orderIsoRpow_symm_eq (y : \u211d) (hy : 0 < y) :\n    (orderIsoRpow y hy).symm = orderIsoRpow (1 / y) (one_div_pos.2 hy)", "start": [355, 1], "end": [357, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow", "code": "noncomputable def rpow : \u211d\u22650\u221e \u2192 \u211d \u2192 \u211d\u22650\u221e\n  | some x, y => if x = 0 \u2227 y < 0 then \u22a4 else (x ^ y : \u211d\u22650)\n  | none, y => if 0 < y then \u22a4 else if y = 0 then 1 else 0", "start": [363, 1], "end": [369, 59], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_eq_pow", "code": "@[simp]\ntheorem rpow_eq_pow (x : \u211d\u22650\u221e) (y : \u211d) : rpow x y = x ^ y", "start": [375, 1], "end": [377, 6], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_zero", "code": "@[simp]\ntheorem rpow_zero {x : \u211d\u22650\u221e} : x ^ (0 : \u211d) = 1", "start": [380, 1], "end": [384, 23], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_rpow_def", "code": "theorem top_rpow_def (y : \u211d) : (\u22a4 : \u211d\u22650\u221e) ^ y = if 0 < y then \u22a4 else if y = 0 then 1 else 0", "start": [387, 1], "end": [388, 6], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_rpow_of_pos", "code": "@[simp]\ntheorem top_rpow_of_pos {y : \u211d} (h : 0 < y) : (\u22a4 : \u211d\u22650\u221e) ^ y = \u22a4", "start": [391, 1], "end": [392, 94], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_rpow_of_neg", "code": "@[simp]\ntheorem top_rpow_of_neg {y : \u211d} (h : y < 0) : (\u22a4 : \u211d\u22650\u221e) ^ y = 0", "start": [395, 1], "end": [397, 43], "kind": "commanddeclaration"}, {"full_name": "ENNReal.zero_rpow_of_pos", "code": "@[simp]\ntheorem zero_rpow_of_pos {y : \u211d} (h : 0 < y) : (0 : \u211d\u22650\u221e) ^ y = 0", "start": [400, 1], "end": [404, 32], "kind": "commanddeclaration"}, {"full_name": "ENNReal.zero_rpow_of_neg", "code": "@[simp]\ntheorem zero_rpow_of_neg {y : \u211d} (h : y < 0) : (0 : \u211d\u22650\u221e) ^ y = \u22a4", "start": [407, 1], "end": [411, 23], "kind": "commanddeclaration"}, {"full_name": "ENNReal.zero_rpow_def", "code": "theorem zero_rpow_def (y : \u211d) : (0 : \u211d\u22650\u221e) ^ y = if 0 < y then 0 else if y = 0 then 1 else \u22a4", "start": [414, 1], "end": [418, 50], "kind": "commanddeclaration"}, {"full_name": "ENNReal.zero_rpow_mul_self", "code": "@[simp]\ntheorem zero_rpow_mul_self (y : \u211d) : (0 : \u211d\u22650\u221e) ^ y * (0 : \u211d\u22650\u221e) ^ y = (0 : \u211d\u22650\u221e) ^ y", "start": [421, 1], "end": [425, 46], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_rpow_of_ne_zero", "code": "@[norm_cast]\ntheorem coe_rpow_of_ne_zero {x : \u211d\u22650} (h : x \u2260 0) (y : \u211d) : (x : \u211d\u22650\u221e) ^ y = (x ^ y : \u211d\u22650)", "start": [428, 1], "end": [432, 11], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_rpow_of_nonneg", "code": "@[norm_cast]\ntheorem coe_rpow_of_nonneg (x : \u211d\u22650) {y : \u211d} (h : 0 \u2264 y) : (x : \u211d\u22650\u221e) ^ y = (x ^ y : \u211d\u22650)", "start": [435, 1], "end": [441, 35], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_rpow_def", "code": "theorem coe_rpow_def (x : \u211d\u22650) (y : \u211d) :\n    (x : \u211d\u22650\u221e) ^ y = if x = 0 \u2227 y < 0 then \u22a4 else (x ^ y : \u211d\u22650\u221e)", "start": [444, 1], "end": [446, 6], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_one", "code": "@[simp]\ntheorem rpow_one (x : \u211d\u22650\u221e) : x ^ (1 : \u211d) = x", "start": [449, 1], "end": [455, 38], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_rpow", "code": "@[simp]\ntheorem one_rpow (x : \u211d) : (1 : \u211d\u22650\u221e) ^ x = 1", "start": [458, 1], "end": [461, 7], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_eq_zero_iff", "code": "@[simp]\ntheorem rpow_eq_zero_iff {x : \u211d\u22650\u221e} {y : \u211d} : x ^ y = 0 \u2194 x = 0 \u2227 0 < y \u2228 x = \u22a4 \u2227 y < 0", "start": [464, 1], "end": [472, 38], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_eq_top_iff", "code": "@[simp]\ntheorem rpow_eq_top_iff {x : \u211d\u22650\u221e} {y : \u211d} : x ^ y = \u22a4 \u2194 x = 0 \u2227 y < 0 \u2228 x = \u22a4 \u2227 0 < y", "start": [475, 1], "end": [483, 38], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_eq_top_iff_of_pos", "code": "theorem rpow_eq_top_iff_of_pos {x : \u211d\u22650\u221e} {y : \u211d} (hy : 0 < y) : x ^ y = \u22a4 \u2194 x = \u22a4", "start": [486, 1], "end": [487, 39], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_eq_top_of_nonneg", "code": "theorem rpow_eq_top_of_nonneg (x : \u211d\u22650\u221e) {y : \u211d} (hy0 : 0 \u2264 y) : x ^ y = \u22a4 \u2192 x = \u22a4", "start": [490, 1], "end": [496, 17], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_ne_top_of_nonneg", "code": "theorem rpow_ne_top_of_nonneg {x : \u211d\u22650\u221e} {y : \u211d} (hy0 : 0 \u2264 y) (h : x \u2260 \u22a4) : x ^ y \u2260 \u22a4", "start": [499, 1], "end": [500, 45], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_lt_top_of_nonneg", "code": "theorem rpow_lt_top_of_nonneg {x : \u211d\u22650\u221e} {y : \u211d} (hy0 : 0 \u2264 y) (h : x \u2260 \u22a4) : x ^ y < \u22a4", "start": [503, 1], "end": [504, 62], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_add", "code": "theorem rpow_add {x : \u211d\u22650\u221e} (y z : \u211d) (hx : x \u2260 0) (h'x : x \u2260 \u22a4) : x ^ (y + z) = x ^ y * x ^ z", "start": [507, 1], "end": [511, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_neg", "code": "theorem rpow_neg (x : \u211d\u22650\u221e) (y : \u211d) : x ^ (-y) = (x ^ y)\u207b\u00b9", "start": [514, 1], "end": [522, 65], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_sub", "code": "theorem rpow_sub {x : \u211d\u22650\u221e} (y z : \u211d) (hx : x \u2260 0) (h'x : x \u2260 \u22a4) : x ^ (y - z) = x ^ y / x ^ z", "start": [525, 1], "end": [526, 69], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_neg_one", "code": "theorem rpow_neg_one (x : \u211d\u22650\u221e) : x ^ (-1 : \u211d) = x\u207b\u00b9", "start": [529, 1], "end": [529, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_mul", "code": "theorem rpow_mul (x : \u211d\u22650\u221e) (y z : \u211d) : x ^ (y * z) = (x ^ y) ^ z", "start": [532, 1], "end": [544, 78], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_nat_cast", "code": "@[simp, norm_cast]\ntheorem rpow_nat_cast (x : \u211d\u22650\u221e) (n : \u2115) : x ^ (n : \u211d) = x ^ n", "start": [547, 1], "end": [551, 52], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_two", "code": "@[simp]\ntheorem rpow_two (x : \u211d\u22650\u221e) : x ^ (2 : \u211d) = x ^ 2", "start": [554, 1], "end": [557, 29], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_rpow_eq_ite", "code": "theorem mul_rpow_eq_ite (x y : \u211d\u22650\u221e) (z : \u211d) :\n    (x * y) ^ z = if (x = 0 \u2227 y = \u22a4 \u2228 x = \u22a4 \u2227 y = 0) \u2227 z < 0 then \u22a4 else x ^ z * y ^ z", "start": [560, 1], "end": [578, 12], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_rpow_of_ne_top", "code": "theorem mul_rpow_of_ne_top {x y : \u211d\u22650\u221e} (hx : x \u2260 \u22a4) (hy : y \u2260 \u22a4) (z : \u211d) :\n    (x * y) ^ z = x ^ z * y ^ z", "start": [581, 1], "end": [582, 64], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_mul_rpow", "code": "@[norm_cast]\ntheorem coe_mul_rpow (x y : \u211d\u22650) (z : \u211d) : ((x : \u211d\u22650\u221e) * y) ^ z = (x : \u211d\u22650\u221e) ^ z * (y : \u211d\u22650\u221e) ^ z", "start": [585, 1], "end": [587, 45], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_rpow_of_ne_zero", "code": "theorem mul_rpow_of_ne_zero {x y : \u211d\u22650\u221e} (hx : x \u2260 0) (hy : y \u2260 0) (z : \u211d) :\n    (x * y) ^ z = x ^ z * y ^ z", "start": [590, 1], "end": [591, 64], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_rpow_of_nonneg", "code": "theorem mul_rpow_of_nonneg (x y : \u211d\u22650\u221e) {z : \u211d} (hz : 0 \u2264 z) : (x * y) ^ z = x ^ z * y ^ z", "start": [594, 1], "end": [595, 36], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_rpow", "code": "theorem inv_rpow (x : \u211d\u22650\u221e) (y : \u211d) : x\u207b\u00b9 ^ y = (x ^ y)\u207b\u00b9", "start": [598, 1], "end": [605, 14], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_rpow_of_nonneg", "code": "theorem div_rpow_of_nonneg (x y : \u211d\u22650\u221e) {z : \u211d} (hz : 0 \u2264 z) : (x / y) ^ z = x ^ z / y ^ z", "start": [608, 1], "end": [609, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.strictMono_rpow_of_pos", "code": "theorem strictMono_rpow_of_pos {z : \u211d} (h : 0 < z) : StrictMono fun x : \u211d\u22650\u221e => x ^ z", "start": [612, 1], "end": [618, 96], "kind": "commanddeclaration"}, {"full_name": "ENNReal.monotone_rpow_of_nonneg", "code": "theorem monotone_rpow_of_nonneg {z : \u211d} (h : 0 \u2264 z) : Monotone fun x : \u211d\u22650\u221e => x ^ z", "start": [621, 1], "end": [623, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.orderIsoRpow", "code": "@[simps! apply]\ndef orderIsoRpow (y : \u211d) (hy : 0 < y) : \u211d\u22650\u221e \u2243o \u211d\u22650\u221e :=\n  (strictMono_rpow_of_pos hy).orderIsoOfRightInverse (fun x => x ^ y) (fun x => x ^ (1 / y))\n    fun x => by\n    dsimp\n    rw [\u2190 rpow_mul, one_div_mul_cancel hy.ne.symm, rpow_one]", "start": [626, 1], "end": [633, 61], "kind": "commanddeclaration"}, {"full_name": "ENNReal.orderIsoRpow_symm_apply", "code": "theorem orderIsoRpow_symm_apply (y : \u211d) (hy : 0 < y) :\n    (orderIsoRpow y hy).symm = orderIsoRpow (1 / y) (one_div_pos.2 hy)", "start": [636, 1], "end": [639, 6], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_le_rpow", "code": "theorem rpow_le_rpow {x y : \u211d\u22650\u221e} {z : \u211d} (h\u2081 : x \u2264 y) (h\u2082 : 0 \u2264 z) : x ^ z \u2264 y ^ z", "start": [642, 1], "end": [643, 32], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_lt_rpow", "code": "theorem rpow_lt_rpow {x y : \u211d\u22650\u221e} {z : \u211d} (h\u2081 : x < y) (h\u2082 : 0 < z) : x ^ z < y ^ z", "start": [646, 1], "end": [647, 31], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_le_rpow_iff", "code": "theorem rpow_le_rpow_iff {x y : \u211d\u22650\u221e} {z : \u211d} (hz : 0 < z) : x ^ z \u2264 y ^ z \u2194 x \u2264 y", "start": [650, 1], "end": [651, 40], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_lt_rpow_iff", "code": "theorem rpow_lt_rpow_iff {x y : \u211d\u22650\u221e} {z : \u211d} (hz : 0 < z) : x ^ z < y ^ z \u2194 x < y", "start": [654, 1], "end": [655, 40], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_rpow_one_div_iff", "code": "theorem le_rpow_one_div_iff {x y : \u211d\u22650\u221e} {z : \u211d} (hz : 0 < z) : x \u2264 y ^ (1 / z) \u2194 x ^ z \u2264 y", "start": [658, 1], "end": [661, 73], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_rpow_one_div_iff", "code": "theorem lt_rpow_one_div_iff {x y : \u211d\u22650\u221e} {z : \u211d} (hz : 0 < z) : x < y ^ (1 / z) \u2194 x ^ z < y", "start": [664, 1], "end": [667, 73], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_one_div_le_iff", "code": "theorem rpow_one_div_le_iff {x y : \u211d\u22650\u221e} {z : \u211d} (hz : 0 < z) : x ^ (1 / z) \u2264 y \u2194 x \u2264 y ^ z", "start": [670, 1], "end": [673, 80], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_lt_rpow_of_exponent_lt", "code": "theorem rpow_lt_rpow_of_exponent_lt {x : \u211d\u22650\u221e} {y z : \u211d} (hx : 1 < x) (hx' : x \u2260 \u22a4) (hyz : y < z) :\n    x ^ y < x ^ z", "start": [676, 1], "end": [681, 47], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_le_rpow_of_exponent_le", "code": "theorem rpow_le_rpow_of_exponent_le {x : \u211d\u22650\u221e} {y z : \u211d} (hx : 1 \u2264 x) (hyz : y \u2264 z) :\n    x ^ y \u2264 x ^ z", "start": [684, 1], "end": [693, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_lt_rpow_of_exponent_gt", "code": "theorem rpow_lt_rpow_of_exponent_gt {x : \u211d\u22650\u221e} {y z : \u211d} (hx0 : 0 < x) (hx1 : x < 1) (hyz : z < y) :\n    x ^ y < x ^ z", "start": [696, 1], "end": [700, 92], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_le_rpow_of_exponent_ge", "code": "theorem rpow_le_rpow_of_exponent_ge {x : \u211d\u22650\u221e} {y z : \u211d} (hx1 : x \u2264 1) (hyz : z \u2264 y) :\n    x ^ y \u2264 x ^ z", "start": [703, 1], "end": [713, 76], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_le_self_of_le_one", "code": "theorem rpow_le_self_of_le_one {x : \u211d\u22650\u221e} {z : \u211d} (hx : x \u2264 1) (h_one_le : 1 \u2264 z) : x ^ z \u2264 x", "start": [716, 1], "end": [718, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_rpow_self_of_one_le", "code": "theorem le_rpow_self_of_one_le {x : \u211d\u22650\u221e} {z : \u211d} (hx : 1 \u2264 x) (h_one_le : 1 \u2264 z) : x \u2264 x ^ z", "start": [721, 1], "end": [723, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_pos_of_nonneg", "code": "theorem rpow_pos_of_nonneg {p : \u211d} {x : \u211d\u22650\u221e} (hx_pos : 0 < x) (hp_nonneg : 0 \u2264 p) : 0 < x ^ p", "start": [726, 1], "end": [732, 37], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_pos", "code": "theorem rpow_pos {p : \u211d} {x : \u211d\u22650\u221e} (hx_pos : 0 < x) (hx_ne_top : x \u2260 \u22a4) : 0 < x ^ p", "start": [735, 1], "end": [739, 79], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_lt_one", "code": "theorem rpow_lt_one {x : \u211d\u22650\u221e} {z : \u211d} (hx : x < 1) (hz : 0 < z) : x ^ z < 1", "start": [742, 1], "end": [745, 70], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_le_one", "code": "theorem rpow_le_one {x : \u211d\u22650\u221e} {z : \u211d} (hx : x \u2264 1) (hz : 0 \u2264 z) : x ^ z \u2264 1", "start": [748, 1], "end": [751, 59], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_lt_one_of_one_lt_of_neg", "code": "theorem rpow_lt_one_of_one_lt_of_neg {x : \u211d\u22650\u221e} {z : \u211d} (hx : 1 < x) (hz : z < 0) : x ^ z < 1", "start": [754, 1], "end": [759, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_le_one_of_one_le_of_neg", "code": "theorem rpow_le_one_of_one_le_of_neg {x : \u211d\u22650\u221e} {z : \u211d} (hx : 1 \u2264 x) (hz : z < 0) : x ^ z \u2264 1", "start": [762, 1], "end": [767, 63], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_lt_rpow", "code": "theorem one_lt_rpow {x : \u211d\u22650\u221e} {z : \u211d} (hx : 1 < x) (hz : 0 < z) : 1 < x ^ z", "start": [770, 1], "end": [774, 72], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_le_rpow", "code": "theorem one_le_rpow {x : \u211d\u22650\u221e} {z : \u211d} (hx : 1 \u2264 x) (hz : 0 < z) : 1 \u2264 x ^ z", "start": [777, 1], "end": [781, 83], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_lt_rpow_of_pos_of_lt_one_of_neg", "code": "theorem one_lt_rpow_of_pos_of_lt_one_of_neg {x : \u211d\u22650\u221e} {z : \u211d} (hx1 : 0 < x) (hx2 : x < 1)\n    (hz : z < 0) : 1 < x ^ z", "start": [784, 1], "end": [788, 99], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_le_rpow_of_pos_of_le_one_of_neg", "code": "theorem one_le_rpow_of_pos_of_le_one_of_neg {x : \u211d\u22650\u221e} {z : \u211d} (hx1 : 0 < x) (hx2 : x \u2264 1)\n    (hz : z < 0) : 1 \u2264 x ^ z", "start": [791, 1], "end": [796, 73], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_rpow", "code": "theorem toNNReal_rpow (x : \u211d\u22650\u221e) (z : \u211d) : x.toNNReal ^ z = (x ^ z).toNNReal", "start": [799, 1], "end": [809, 45], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_rpow", "code": "theorem toReal_rpow (x : \u211d\u22650\u221e) (z : \u211d) : x.toReal ^ z = (x ^ z).toReal", "start": [812, 1], "end": [813, 80], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_rpow_of_pos", "code": "theorem ofReal_rpow_of_pos {x p : \u211d} (hx_pos : 0 < x) :\n    ENNReal.ofReal x ^ p = ENNReal.ofReal (x ^ p)", "start": [816, 1], "end": [820, 16], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_rpow_of_nonneg", "code": "theorem ofReal_rpow_of_nonneg {x p : \u211d} (hx_nonneg : 0 \u2264 x) (hp_nonneg : 0 \u2264 p) :\n    ENNReal.ofReal x ^ p = ENNReal.ofReal (x ^ p)", "start": [823, 1], "end": [832, 57], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_left_injective", "code": "theorem rpow_left_injective {x : \u211d} (hx : x \u2260 0) : Function.Injective fun y : \u211d\u22650\u221e => y ^ x", "start": [835, 1], "end": [838, 87], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_left_surjective", "code": "theorem rpow_left_surjective {x : \u211d} (hx : x \u2260 0) : Function.Surjective fun y : \u211d\u22650\u221e => y ^ x", "start": [841, 1], "end": [842, 82], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_left_bijective", "code": "theorem rpow_left_bijective {x : \u211d} (hx : x \u2260 0) : Function.Bijective fun y : \u211d\u22650\u221e => y ^ x", "start": [845, 1], "end": [846, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Complex.lean", "imports": ["Mathlib/Analysis/Complex/Basic.lean", "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsROrC.measurableSpace", "code": "instance (priority := 900) IsROrC.measurableSpace {\ud835\udd5c : Type*} [IsROrC \ud835\udd5c] : MeasurableSpace \ud835\udd5c :=\n  borel \ud835\udd5c", "start": [16, 1], "end": [17, 10], "kind": "commanddeclaration"}, {"full_name": "IsROrC.borelSpace", "code": "instance (priority := 900) IsROrC.borelSpace {\ud835\udd5c : Type*} [IsROrC \ud835\udd5c] : BorelSpace \ud835\udd5c :=\n  \u27e8rfl\u27e9", "start": [20, 1], "end": [21, 8], "kind": "commanddeclaration"}, {"full_name": "Complex.measurableSpace", "code": "instance Complex.measurableSpace : MeasurableSpace \u2102 :=\n  borel \u2102", "start": [24, 1], "end": [25, 10], "kind": "commanddeclaration"}, {"full_name": "Complex.borelSpace", "code": "instance Complex.borelSpace : BorelSpace \u2102 :=\n  \u27e8rfl\u27e9", "start": [28, 1], "end": [29, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/SpecificFunctions/Basic.lean", "imports": ["Mathlib/Tactic/LinearCombination.lean", "Mathlib/Analysis/Convex/Slope.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "strictConvexOn_exp", "code": "theorem strictConvexOn_exp : StrictConvexOn \u211d univ exp", "start": [42, 1], "end": [65, 59], "kind": "commanddeclaration"}, {"full_name": "convexOn_exp", "code": "theorem convexOn_exp : ConvexOn \u211d univ exp", "start": [68, 1], "end": [70, 30], "kind": "commanddeclaration"}, {"full_name": "convexOn_pow", "code": "theorem convexOn_pow (n : \u2115) : ConvexOn \u211d (Ici 0) fun x : \u211d => x ^ n", "start": [73, 1], "end": [96, 59], "kind": "commanddeclaration"}, {"full_name": "Even.convexOn_pow", "code": "nonrec theorem Even.convexOn_pow {n : \u2115} (hn : Even n) :\n    ConvexOn \u211d Set.univ fun x : \u211d => x ^ n", "start": [99, 1], "end": [117, 73], "kind": "commanddeclaration"}, {"full_name": "convexOn_zpow", "code": "theorem convexOn_zpow : \u2200 m : \u2124, ConvexOn \u211d (Ioi 0) fun x : \u211d => x ^ m", "start": [121, 1], "end": [149, 17], "kind": "commanddeclaration"}, {"full_name": "strictConcaveOn_log_Ioi", "code": "theorem strictConcaveOn_log_Ioi : StrictConcaveOn \u211d (Ioi 0) log", "start": [156, 1], "end": [183, 35], "kind": "commanddeclaration"}, {"full_name": "one_add_mul_self_lt_rpow_one_add", "code": "theorem one_add_mul_self_lt_rpow_one_add {s : \u211d} (hs : -1 \u2264 s) (hs' : s \u2260 0) {p : \u211d} (hp : 1 < p) :\n    1 + p * s < (1 + s) ^ p", "start": [186, 1], "end": [217, 16], "kind": "commanddeclaration"}, {"full_name": "one_add_mul_self_le_rpow_one_add", "code": "theorem one_add_mul_self_le_rpow_one_add {s : \u211d} (hs : -1 \u2264 s) {p : \u211d} (hp : 1 \u2264 p) :\n    1 + p * s \u2264 (1 + s) ^ p", "start": [220, 1], "end": [228, 56], "kind": "commanddeclaration"}, {"full_name": "strictConvexOn_rpow", "code": "theorem strictConvexOn_rpow {p : \u211d} (hp : 1 < p) : StrictConvexOn \u211d (Ici 0) fun x : \u211d => x ^ p", "start": [235, 1], "end": [273, 28], "kind": "commanddeclaration"}, {"full_name": "convexOn_rpow", "code": "theorem convexOn_rpow {p : \u211d} (hp : 1 \u2264 p) : ConvexOn \u211d (Ici 0) fun x : \u211d => x ^ p", "start": [276, 1], "end": [279, 42], "kind": "commanddeclaration"}, {"full_name": "strictConcaveOn_log_Iio", "code": "theorem strictConcaveOn_log_Iio : StrictConcaveOn \u211d (Iio 0) log", "start": [282, 1], "end": [292, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Jensen.lean", "imports": ["Mathlib/Analysis/Convex/Combination.lean", "Mathlib/Analysis/Convex/Function.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ConvexOn.map_centerMass_le", "code": "theorem ConvexOn.map_centerMass_le (hf : ConvexOn \ud835\udd5c s f) (h\u2080 : \u2200 i \u2208 t, 0 \u2264 w i)\n    (h\u2081 : 0 < \u2211 i in t, w i) (hmem : \u2200 i \u2208 t, p i \u2208 s) :\n    f (t.centerMass w p) \u2264 t.centerMass w (f \u2218 p)", "start": [45, 1], "end": [52, 100], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.le_map_centerMass", "code": "theorem ConcaveOn.le_map_centerMass (hf : ConcaveOn \ud835\udd5c s f) (h\u2080 : \u2200 i \u2208 t, 0 \u2264 w i)\n    (h\u2081 : 0 < \u2211 i in t, w i) (hmem : \u2200 i \u2208 t, p i \u2208 s) :\n    t.centerMass w (f \u2218 p) \u2264 f (t.centerMass w p)", "start": [55, 1], "end": [59, 76], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.map_sum_le", "code": "theorem ConvexOn.map_sum_le (hf : ConvexOn \ud835\udd5c s f) (h\u2080 : \u2200 i \u2208 t, 0 \u2264 w i) (h\u2081 : \u2211 i in t, w i = 1)\n    (hmem : \u2200 i \u2208 t, p i \u2208 s) : f (\u2211 i in t, w i \u2022 p i) \u2264 \u2211 i in t, w i \u2022 f (p i)", "start": [62, 1], "end": [66, 57], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.le_map_sum", "code": "theorem ConcaveOn.le_map_sum (hf : ConcaveOn \ud835\udd5c s f) (h\u2080 : \u2200 i \u2208 t, 0 \u2264 w i)\n    (h\u2081 : \u2211 i in t, w i = 1) (hmem : \u2200 i \u2208 t, p i \u2208 s) :\n    (\u2211 i in t, w i \u2022 f (p i)) \u2264 f (\u2211 i in t, w i \u2022 p i)", "start": [69, 1], "end": [73, 69], "kind": "commanddeclaration"}, {"full_name": "le_sup_of_mem_convexHull", "code": "theorem le_sup_of_mem_convexHull {s : Finset E} (hf : ConvexOn \ud835\udd5c (convexHull \ud835\udd5c (s : Set E)) f)\n    (hx : x \u2208 convexHull \ud835\udd5c (s : Set E)) :\n    f x \u2264 s.sup' (coe_nonempty.1 <| convexHull_nonempty_iff.1 \u27e8x, hx\u27e9) f", "start": [87, 1], "end": [92, 45], "kind": "commanddeclaration"}, {"full_name": "inf_le_of_mem_convexHull", "code": "theorem inf_le_of_mem_convexHull {s : Finset E} (hf : ConcaveOn \ud835\udd5c (convexHull \ud835\udd5c (s : Set E)) f)\n    (hx : x \u2208 convexHull \ud835\udd5c (s : Set E)) :\n    s.inf' (coe_nonempty.1 <| convexHull_nonempty_iff.1 \u27e8x, hx\u27e9) f \u2264 f x", "start": [95, 1], "end": [98, 38], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.exists_ge_of_centerMass", "code": "theorem ConvexOn.exists_ge_of_centerMass (h : ConvexOn \ud835\udd5c s f) (hw\u2080 : \u2200 i \u2208 t, 0 \u2264 w i)\n    (hw\u2081 : 0 < \u2211 i in t, w i) (hp : \u2200 i \u2208 t, p i \u2208 s) :\n    \u2203 i \u2208 t, f (t.centerMass w p) \u2264 f (p i)", "start": [101, 1], "end": [115, 39], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.exists_le_of_centerMass", "code": "theorem ConcaveOn.exists_le_of_centerMass (h : ConcaveOn \ud835\udd5c s f) (hw\u2080 : \u2200 i \u2208 t, 0 \u2264 w i)\n    (hw\u2081 : 0 < \u2211 i in t, w i) (hp : \u2200 i \u2208 t, p i \u2208 s) : \u2203 i \u2208 t, f (p i) \u2264 f (t.centerMass w p)", "start": [118, 1], "end": [122, 81], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.exists_ge_of_mem_convexHull", "code": "theorem ConvexOn.exists_ge_of_mem_convexHull (hf : ConvexOn \ud835\udd5c (convexHull \ud835\udd5c s) f) {x}\n    (hx : x \u2208 convexHull \ud835\udd5c s) : \u2203 y \u2208 s, f x \u2264 f y", "start": [125, 1], "end": [134, 28], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.exists_le_of_mem_convexHull", "code": "theorem ConcaveOn.exists_le_of_mem_convexHull (hf : ConcaveOn \ud835\udd5c (convexHull \ud835\udd5c s) f) {x}\n    (hx : x \u2208 convexHull \ud835\udd5c s) : \u2203 y \u2208 s, f y \u2264 f x", "start": [137, 1], "end": [141, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/ConjugateExponents.lean", "imports": ["Mathlib/Data/Real/ENNReal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.IsConjugateExponent", "code": "structure IsConjugateExponent (p q : \u211d) : Prop where\n  one_lt : 1 < p\n  inv_add_inv_conj : 1 / p + 1 / q = 1", "start": [27, 1], "end": [32, 39], "kind": "commanddeclaration"}, {"full_name": "Real.conjugateExponent", "code": "def conjugateExponent (p : \u211d) : \u211d := p / (p - 1)", "start": [35, 1], "end": [36, 49], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.pos", "code": "theorem pos : 0 < p", "start": [47, 1], "end": [47, 53], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.nonneg", "code": "theorem nonneg : 0 \u2264 p", "start": [50, 1], "end": [50, 41], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.ne_zero", "code": "theorem ne_zero : p \u2260 0", "start": [53, 1], "end": [53, 42], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.sub_one_pos", "code": "theorem sub_one_pos : 0 < p - 1", "start": [56, 1], "end": [56, 54], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.sub_one_ne_zero", "code": "theorem sub_one_ne_zero : p - 1 \u2260 0", "start": [59, 1], "end": [59, 62], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.one_div_pos", "code": "theorem one_div_pos : 0 < 1 / p", "start": [62, 1], "end": [62, 62], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.one_div_nonneg", "code": "theorem one_div_nonneg : 0 \u2264 1 / p", "start": [65, 1], "end": [65, 61], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.one_div_ne_zero", "code": "theorem one_div_ne_zero : 1 / p \u2260 0", "start": [68, 1], "end": [68, 62], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.conj_eq", "code": "theorem conj_eq : q = p / (p - 1)", "start": [71, 1], "end": [74, 31], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.conjugate_eq", "code": "theorem conjugate_eq : conjugateExponent p = q", "start": [77, 1], "end": [77, 65], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.sub_one_mul_conj", "code": "theorem sub_one_mul_conj : (p - 1) * q = p", "start": [80, 1], "end": [81, 66], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.mul_eq_add", "code": "theorem mul_eq_add : p * q = p + q", "start": [84, 1], "end": [85, 76], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.symm", "code": "@[symm]\nprotected theorem symm : q.IsConjugateExponent p", "start": [88, 1], "end": [93, 71], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.div_conj_eq_sub_one", "code": "theorem div_conj_eq_sub_one : p / q = p - 1", "start": [96, 1], "end": [98, 26], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.one_lt_nnreal", "code": "theorem one_lt_nnreal : 1 < Real.toNNReal p", "start": [101, 1], "end": [103, 17], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.inv_add_inv_conj_nnreal", "code": "theorem inv_add_inv_conj_nnreal : 1 / Real.toNNReal p + 1 / Real.toNNReal q = 1", "start": [106, 1], "end": [108, 86], "kind": "commanddeclaration"}, {"full_name": "Real.IsConjugateExponent.inv_add_inv_conj_ennreal", "code": "theorem inv_add_inv_conj_ennreal : 1 / ENNReal.ofReal p + 1 / ENNReal.ofReal q = 1", "start": [111, 1], "end": [114, 87], "kind": "commanddeclaration"}, {"full_name": "Real.isConjugateExponent_iff", "code": "theorem isConjugateExponent_iff {p q : \u211d} (h : 1 < p) : p.IsConjugateExponent q \u2194 q = p / (p - 1)", "start": [119, 1], "end": [120, 92], "kind": "commanddeclaration"}, {"full_name": "Real.isConjugateExponent_conjugateExponent", "code": "theorem isConjugateExponent_conjugateExponent {p : \u211d} (h : 1 < p) :\n    p.IsConjugateExponent (conjugateExponent p)", "start": [123, 1], "end": [124, 85], "kind": "commanddeclaration"}, {"full_name": "Real.isConjugateExponent_one_div", "code": "theorem isConjugateExponent_one_div {a b : \u211d} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :\n    (1 / a).IsConjugateExponent (1 / b)", "start": [127, 1], "end": [130, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Polynomial/Tower.lean", "imports": ["Mathlib/Algebra/Algebra/Tower.lean", "Mathlib/Data/Polynomial/AlgebraMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.aeval_map_algebraMap", "code": "@[simp]\ntheorem aeval_map_algebraMap (x : B) (p : R[X]) : aeval x (map (algebraMap R A) p) = aeval x p", "start": [39, 1], "end": [41, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_algebraMap_apply", "code": "theorem aeval_algebraMap_apply (x : A) (p : R[X]) :\n    aeval (algebraMap A B x) p = algebraMap A B (aeval x p)", "start": [54, 1], "end": [56, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_algebraMap_eq_zero_iff", "code": "@[simp]\ntheorem aeval_algebraMap_eq_zero_iff [NoZeroSMulDivisors A B] [Nontrivial B] (x : A) (p : R[X]) :\n    aeval (algebraMap A B x) p = 0 \u2194 aeval x p = 0", "start": [59, 1], "end": [63, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_algebraMap_eq_zero_iff_of_injective", "code": "theorem aeval_algebraMap_eq_zero_iff_of_injective {x : A} {p : R[X]}\n    (h : Function.Injective (algebraMap A B)) : aeval (algebraMap A B x) p = 0 \u2194 aeval x p = 0", "start": [68, 1], "end": [70, 69], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.aeval_coe", "code": "@[simp]\ntheorem aeval_coe (S : Subalgebra R A) (x : S) (p : R[X]) : aeval (x : A) p = aeval x p", "start": [85, 1], "end": [87, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/FiniteType.lean", "imports": ["Mathlib/GroupTheory/Finiteness.lean", "Mathlib/RingTheory/Noetherian.lean", "Mathlib/RingTheory/Adjoin/Tower.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/FreeAlgebra.lean", "Mathlib/RingTheory/Finiteness.lean"], "premises": [{"full_name": "Algebra.FiniteType", "code": "class Algebra.FiniteType [CommSemiring R] [Semiring A] [Algebra R A] : Prop where\n  out : (\u22a4 : Subalgebra R A).FG", "start": [38, 1], "end": [41, 32], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.finiteType", "code": "instance (priority := 100) finiteType {R : Type*} (A : Type*) [CommSemiring R] [Semiring A]\n    [Algebra R A] [hRA : Finite R A] : Algebra.FiniteType R A :=\n  \u27e8Subalgebra.fg_of_submodule_fg hRA.1\u27e9", "start": [57, 1], "end": [59, 40], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.self", "code": "theorem self : FiniteType R R", "start": [77, 1], "end": [78, 33], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.polynomial", "code": "protected theorem polynomial : FiniteType R R[X]", "start": [81, 1], "end": [84, 34], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.freeAlgebra", "code": "protected theorem freeAlgebra (\u03b9 : Type*) [Finite \u03b9] : FiniteType R (FreeAlgebra R \u03b9)", "start": [89, 1], "end": [94, 47], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.mvPolynomial", "code": "protected theorem mvPolynomial (\u03b9 : Type*) [Finite \u03b9] : FiniteType R (MvPolynomial \u03b9 R)", "start": [96, 1], "end": [101, 44], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.of_restrictScalars_finiteType", "code": "theorem of_restrictScalars_finiteType [Algebra S A] [IsScalarTower R S A] [hA : FiniteType R A] :\n    FiniteType S A", "start": [104, 1], "end": [112, 31], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.of_surjective", "code": "theorem of_surjective (hRA : FiniteType R A) (f : A \u2192\u2090[R] B) (hf : Surjective f) : FiniteType R B", "start": [117, 1], "end": [120, 81], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.equiv", "code": "theorem equiv (hRA : FiniteType R A) (e : A \u2243\u2090[R] B) : FiniteType R B", "start": [123, 1], "end": [124, 35], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.trans", "code": "theorem trans [Algebra S A] [IsScalarTower R S A] (hRS : FiniteType R S) (hSA : FiniteType S A) :\n    FiniteType R A", "start": [127, 1], "end": [129, 26], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.iff_quotient_freeAlgebra", "code": "theorem iff_quotient_freeAlgebra :\n    FiniteType R A \u2194\n      \u2203 (s : Finset A) (f : FreeAlgebra R s \u2192\u2090[R] A), Surjective f", "start": [132, 1], "end": [146, 71], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.iff_quotient_mvPolynomial", "code": "theorem iff_quotient_mvPolynomial :\n    FiniteType R S \u2194\n      \u2203 (s : Finset S) (f : MvPolynomial { x // x \u2208 s } R \u2192\u2090[R] S), Surjective f", "start": [148, 1], "end": [161, 85], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.iff_quotient_freeAlgebra'", "code": "theorem iff_quotient_freeAlgebra' : FiniteType R A \u2194\n    \u2203 (\u03b9 : Type uA) (_ : Fintype \u03b9) (f : FreeAlgebra R \u03b9 \u2192\u2090[R] A), Surjective f", "start": [164, 1], "end": [174, 71], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.iff_quotient_mvPolynomial'", "code": "theorem iff_quotient_mvPolynomial' : FiniteType R S \u2194\n    \u2203 (\u03b9 : Type uS) (_ : Fintype \u03b9) (f : MvPolynomial \u03b9 R \u2192\u2090[R] S), Surjective f", "start": [176, 1], "end": [186, 72], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.iff_quotient_mvPolynomial''", "code": "theorem iff_quotient_mvPolynomial'' :\n    FiniteType R S \u2194 \u2203 (n : \u2115) (f : MvPolynomial (Fin n) R \u2192\u2090[R] S), Surjective f", "start": [189, 1], "end": [199, 78], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.prod", "code": "instance prod [hA : FiniteType R A] [hB : FiniteType R B] : FiniteType R (A \u00d7 B) :=\n  \u27e8by rw [\u2190 Subalgebra.prod_top]; exact hA.1.prod hB.1\u27e9", "start": [202, 1], "end": [203, 56], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.isNoetherianRing", "code": "theorem isNoetherianRing (R S : Type*) [CommRing R] [CommRing S] [Algebra R S]\n    [h : Algebra.FiniteType R S] [IsNoetherianRing R] : IsNoetherianRing S", "start": [206, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.fg_iff_finiteType", "code": "theorem _root_.Subalgebra.fg_iff_finiteType (S : Subalgebra R A) : S.FG \u2194 Algebra.FiniteType R S", "start": [217, 1], "end": [218, 53], "kind": "commanddeclaration"}, {"full_name": "RingHom.FiniteType", "code": "def FiniteType (f : A \u2192+* B) : Prop :=\n  @Algebra.FiniteType A B _ _ f.toAlgebra", "start": [231, 1], "end": [233, 42], "kind": "commanddeclaration"}, {"full_name": "RingHom.Finite.finiteType", "code": "theorem finiteType {f : A \u2192+* B} (hf : f.Finite) : FiniteType f", "start": [238, 1], "end": [239, 51], "kind": "commanddeclaration"}, {"full_name": "RingHom.FiniteType.id", "code": "theorem id : FiniteType (RingHom.id A)", "start": [248, 1], "end": [249, 28], "kind": "commanddeclaration"}, {"full_name": "RingHom.FiniteType.comp_surjective", "code": "theorem comp_surjective {f : A \u2192+* B} {g : B \u2192+* C} (hf : f.FiniteType) (hg : Surjective g) :\n    (g.comp f).FiniteType", "start": [254, 1], "end": [262, 7], "kind": "commanddeclaration"}, {"full_name": "RingHom.FiniteType.of_surjective", "code": "theorem of_surjective (f : A \u2192+* B) (hf : Surjective f) : f.FiniteType", "start": [265, 1], "end": [267, 34], "kind": "commanddeclaration"}, {"full_name": "RingHom.FiniteType.comp", "code": "theorem comp {g : B \u2192+* C} {f : A \u2192+* B} (hg : g.FiniteType) (hf : f.FiniteType) :\n    (g.comp f).FiniteType", "start": [270, 1], "end": [280, 10], "kind": "commanddeclaration"}, {"full_name": "RingHom.FiniteType.of_finite", "code": "theorem of_finite {f : A \u2192+* B} (hf : f.Finite) : f.FiniteType", "start": [283, 1], "end": [284, 51], "kind": "commanddeclaration"}, {"full_name": "RingHom.Finite.to_finiteType", "code": "alias _root_.RingHom.Finite.to_finiteType := of_finite", "start": [287, 1], "end": [287, 55], "kind": "stdtacticaliasalias"}, {"full_name": "RingHom.FiniteType.of_comp_finiteType", "code": "theorem of_comp_finiteType {f : A \u2192+* B} {g : B \u2192+* C} (h : (g.comp f).FiniteType) :\n    g.FiniteType", "start": [290, 1], "end": [297, 63], "kind": "commanddeclaration"}, {"full_name": "AlgHom.FiniteType", "code": "def FiniteType (f : A \u2192\u2090[R] B) : Prop :=\n  f.toRingHom.FiniteType", "start": [312, 1], "end": [315, 25], "kind": "commanddeclaration"}, {"full_name": "AlgHom.Finite.finiteType", "code": "theorem finiteType {f : A \u2192\u2090[R] B} (hf : f.Finite) : FiniteType f", "start": [320, 1], "end": [321, 31], "kind": "commanddeclaration"}, {"full_name": "AlgHom.FiniteType.id", "code": "theorem id : FiniteType (AlgHom.id R A)", "start": [330, 1], "end": [331, 26], "kind": "commanddeclaration"}, {"full_name": "AlgHom.FiniteType.comp", "code": "theorem comp {g : B \u2192\u2090[R] C} {f : A \u2192\u2090[R] B} (hg : g.FiniteType) (hf : f.FiniteType) :\n    (g.comp f).FiniteType", "start": [336, 1], "end": [338, 32], "kind": "commanddeclaration"}, {"full_name": "AlgHom.FiniteType.comp_surjective", "code": "theorem comp_surjective {f : A \u2192\u2090[R] B} {g : B \u2192\u2090[R] C} (hf : f.FiniteType) (hg : Surjective g) :\n    (g.comp f).FiniteType", "start": [341, 1], "end": [343, 43], "kind": "commanddeclaration"}, {"full_name": "AlgHom.FiniteType.of_surjective", "code": "theorem of_surjective (f : A \u2192\u2090[R] B) (hf : Surjective f) : f.FiniteType", "start": [346, 1], "end": [347, 50], "kind": "commanddeclaration"}, {"full_name": "AlgHom.FiniteType.of_comp_finiteType", "code": "theorem of_comp_finiteType {f : A \u2192\u2090[R] B} {g : B \u2192\u2090[R] C} (h : (g.comp f).FiniteType) :\n    g.FiniteType", "start": [350, 1], "end": [352, 42], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mem_adjoin_support", "code": "theorem mem_adjoin_support (f : R[M]) : f \u2208 adjoin R (of' R M '' f.support)", "start": [373, 1], "end": [379, 22], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.support_gen_of_gen", "code": "theorem support_gen_of_gen {S : Set R[M]} (hS : Algebra.adjoin R S = \u22a4) :\n    Algebra.adjoin R (\u22c3 f \u2208 S, of' R M '' (f.support : Set M)) = \u22a4", "start": [382, 1], "end": [393, 49], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.support_gen_of_gen'", "code": "theorem support_gen_of_gen' {S : Set R[M]} (hS : Algebra.adjoin R S = \u22a4) :\n    Algebra.adjoin R (of' R M '' \u22c3 f \u2208 S, (f.support : Set M)) = \u22a4", "start": [396, 1], "end": [403, 31], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.exists_finset_adjoin_eq_top", "code": "theorem exists_finset_adjoin_eq_top [h : FiniteType R R[M]] :\n    \u2203 G : Finset M, Algebra.adjoin R (of' R M '' G) = \u22a4", "start": [412, 1], "end": [422, 31], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.of'_mem_span", "code": "theorem of'_mem_span [Nontrivial R] {m : M} {S : Set M} :\n    of' R M m \u2208 span R (of' R M '' S) \u2194 m \u2208 S", "start": [425, 1], "end": [432, 16], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mem_closure_of_mem_span_closure", "code": "theorem mem_closure_of_mem_span_closure [Nontrivial R] {m : M} {S : Set M}\n    (h : of' R M m \u2208 span R (Submonoid.closure (of' R M '' S) : Set R[M])) :\n    m \u2208 closure S", "start": [435, 1], "end": [447, 31], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mvPolynomial_aeval_of_surjective_of_closure", "code": "theorem mvPolynomial_aeval_of_surjective_of_closure [AddCommMonoid M] [CommSemiring R] {S : Set M}\n    (hS : closure S = \u22a4) :\n    Function.Surjective\n      (MvPolynomial.aeval fun s : S => of' R M \u2191s : MvPolynomial S R \u2192 R[M])", "start": [454, 1], "end": [475, 41], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.freeAlgebra_lift_of_surjective_of_closure", "code": "theorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}\n    (hS : closure S = \u22a4) :\n    Function.Surjective\n      (FreeAlgebra.lift R fun s : S => of' R M \u2191s : FreeAlgebra R S \u2192 R[M])", "start": [480, 1], "end": [501, 41], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.finiteType_of_fg", "code": "instance finiteType_of_fg [CommRing R] [h : AddMonoid.FG M] :\n    FiniteType R R[M] := by\n  obtain \u27e8S, hS\u27e9 := h.out\n  exact (FiniteType.freeAlgebra R (S : Set M)).of_surjective\n      (FreeAlgebra.lift R fun s : (S : Set M) => of' R M \u2191s)\n      (freeAlgebra_lift_of_surjective_of_closure hS)", "start": [505, 1], "end": [512, 53], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.finiteType_iff_fg", "code": "theorem finiteType_iff_fg [CommRing R] [Nontrivial R] :\n    FiniteType R R[M] \u2194 AddMonoid.FG M", "start": [517, 1], "end": [527, 43], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.fg_of_finiteType", "code": "theorem fg_of_finiteType [CommRing R] [Nontrivial R] [h : FiniteType R R[M]] :\n    AddMonoid.FG M", "start": [530, 1], "end": [533, 24], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.finiteType_iff_group_fg", "code": "theorem finiteType_iff_group_fg {G : Type*} [AddCommGroup G] [CommRing R] [Nontrivial R] :\n    FiniteType R R[G] \u2194 AddGroup.FG G", "start": [536, 1], "end": [540, 63], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mem_adjoin_support", "code": "theorem mem_adjoin_support (f : MonoidAlgebra R M) : f \u2208 adjoin R (of R M '' f.support)", "start": [555, 1], "end": [560, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.support_gen_of_gen", "code": "theorem support_gen_of_gen {S : Set (MonoidAlgebra R M)} (hS : Algebra.adjoin R S = \u22a4) :\n    Algebra.adjoin R (\u22c3 f \u2208 S, of R M '' (f.support : Set M)) = \u22a4", "start": [563, 1], "end": [577, 49], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.support_gen_of_gen'", "code": "theorem support_gen_of_gen' {S : Set (MonoidAlgebra R M)} (hS : Algebra.adjoin R S = \u22a4) :\n    Algebra.adjoin R (of R M '' \u22c3 f \u2208 S, (f.support : Set M)) = \u22a4", "start": [580, 1], "end": [587, 31], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.exists_finset_adjoin_eq_top", "code": "theorem exists_finset_adjoin_eq_top [h : FiniteType R (MonoidAlgebra R M)] :\n    \u2203 G : Finset M, Algebra.adjoin R (of R M '' G) = \u22a4", "start": [596, 1], "end": [606, 31], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.of_mem_span_of_iff", "code": "theorem of_mem_span_of_iff [Nontrivial R] {m : M} {S : Set M} :\n    of R M m \u2208 span R (of R M '' S) \u2194 m \u2208 S", "start": [609, 1], "end": [616, 16], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mem_closure_of_mem_span_closure", "code": "theorem mem_closure_of_mem_span_closure [Nontrivial R] {m : M} {S : Set M}\n    (h : of R M m \u2208 span R (Submonoid.closure (of R M '' S) : Set (MonoidAlgebra R M))) :\n    m \u2208 closure S", "start": [619, 1], "end": [626, 37], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mvPolynomial_aeval_of_surjective_of_closure", "code": "theorem mvPolynomial_aeval_of_surjective_of_closure [CommMonoid M] [CommSemiring R] {S : Set M}\n    (hS : closure S = \u22a4) :\n    Function.Surjective\n      (MvPolynomial.aeval fun s : S => of R M \u2191s : MvPolynomial S R \u2192 MonoidAlgebra R M)", "start": [633, 1], "end": [652, 41], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.freeAlgebra_lift_of_surjective_of_closure", "code": "theorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}\n    (hS : closure S = \u22a4) :\n    Function.Surjective\n      (FreeAlgebra.lift R fun s : S => of R M \u2191s : FreeAlgebra R S \u2192 MonoidAlgebra R M)", "start": [658, 1], "end": [678, 41], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.finiteType_of_fg", "code": "instance finiteType_of_fg [CommRing R] [Monoid.FG M] : FiniteType R (MonoidAlgebra R M) :=\n  (AddMonoidAlgebra.finiteType_of_fg R (Additive M)).equiv (toAdditiveAlgEquiv R M).symm", "start": [680, 1], "end": [682, 89], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.finiteType_iff_fg", "code": "theorem finiteType_iff_fg [CommRing R] [Nontrivial R] :\n    FiniteType R (MonoidAlgebra R M) \u2194 Monoid.FG M", "start": [685, 1], "end": [691, 56], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.fg_of_finiteType", "code": "theorem fg_of_finiteType [CommRing R] [Nontrivial R] [h : FiniteType R (MonoidAlgebra R M)] :\n    Monoid.FG M", "start": [694, 1], "end": [697, 24], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.finiteType_iff_group_fg", "code": "theorem finiteType_iff_group_fg {G : Type*} [Group G] [CommRing R] [Nontrivial R] :\n    FiniteType R (MonoidAlgebra R G) \u2194 Group.FG G", "start": [700, 1], "end": [703, 57], "kind": "commanddeclaration"}, {"full_name": "modulePolynomialOfEndo", "code": "def modulePolynomialOfEndo : Module R[X] M :=\n  Module.compHom M (Polynomial.aeval f).toRingHom", "start": [716, 1], "end": [719, 50], "kind": "commanddeclaration"}, {"full_name": "modulePolynomialOfEndo_smul_def", "code": "theorem modulePolynomialOfEndo_smul_def (n : R[X]) (a : M) :\n    @HSMul.hSMul _ _ _ (by letI := modulePolynomialOfEndo f; infer_instance) n a =\n    Polynomial.aeval f n a", "start": [722, 1], "end": [725, 6], "kind": "commanddeclaration"}, {"full_name": "modulePolynomialOfEndo.isScalarTower", "code": "theorem modulePolynomialOfEndo.isScalarTower :\n    @IsScalarTower R R[X] M _\n      (by\n        letI := modulePolynomialOfEndo f\n        infer_instance)\n      _", "start": [730, 1], "end": [739, 7], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.injective_of_surjective_endomorphism", "code": "theorem Module.Finite.injective_of_surjective_endomorphism [hfg : Finite R M]\n    (f_surj : Function.Surjective f) : Function.Injective f", "start": [744, 1], "end": [773, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Polynomial/ScaleRoots.lean", "imports": ["Mathlib/Data/Polynomial/AlgebraMap.lean", "Mathlib/RingTheory/NonZeroDivisors.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.scaleRoots", "code": "noncomputable def scaleRoots (p : R[X]) (s : R) : R[X] :=\n  \u2211 i in p.support, monomial i (p.coeff i * s ^ (p.natDegree - i))", "start": [29, 1], "end": [31, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_scaleRoots", "code": "@[simp]\ntheorem coeff_scaleRoots (p : R[X]) (s : R) (i : \u2115) :\n    (scaleRoots p s).coeff i = coeff p i * s ^ (p.natDegree - i)", "start": [34, 1], "end": [37, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_scaleRoots_natDegree", "code": "theorem coeff_scaleRoots_natDegree (p : R[X]) (s : R) :\n    (scaleRoots p s).coeff p.natDegree = p.leadingCoeff", "start": [40, 1], "end": [42, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.zero_scaleRoots", "code": "@[simp]\ntheorem zero_scaleRoots (s : R) : scaleRoots 0 s = 0", "start": [45, 1], "end": [48, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.scaleRoots_ne_zero", "code": "theorem scaleRoots_ne_zero {p : R[X]} (hp : p \u2260 0) (s : R) : scaleRoots p s \u2260 0", "start": [51, 1], "end": [57, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_scaleRoots_le", "code": "theorem support_scaleRoots_le (p : R[X]) (s : R) : (scaleRoots p s).support \u2264 p.support", "start": [60, 1], "end": [62, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_scaleRoots_eq", "code": "theorem support_scaleRoots_eq (p : R[X]) {s : R} (hs : s \u2208 nonZeroDivisors R) :\n    (scaleRoots p s).support = p.support", "start": [65, 1], "end": [72, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_scaleRoots", "code": "@[simp]\ntheorem degree_scaleRoots (p : R[X]) {s : R} : degree (scaleRoots p s) = degree p", "start": [75, 1], "end": [84, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_scaleRoots", "code": "@[simp]\ntheorem natDegree_scaleRoots (p : R[X]) (s : R) : natDegree (scaleRoots p s) = natDegree p", "start": [87, 1], "end": [89, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_scaleRoots_iff", "code": "theorem monic_scaleRoots_iff {p : R[X]} (s : R) : Monic (scaleRoots p s) \u2194 Monic p", "start": [92, 1], "end": [93, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_scaleRoots", "code": "theorem map_scaleRoots (p : R[X]) (x : R) (f : R \u2192+* S) (h : f p.leadingCoeff \u2260 0) :\n    (p.scaleRoots x).map f = (p.map f).scaleRoots (f x)", "start": [96, 1], "end": [99, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.scaleRoots_eval\u2082_mul", "code": "theorem scaleRoots_eval\u2082_mul {p : S[X]} (f : S \u2192+* R) (r : R) (s : S) :\n    eval\u2082 f (f s * r) (scaleRoots p s) = f s ^ p.natDegree * eval\u2082 f r p", "start": [108, 1], "end": [126, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.scaleRoots_eval\u2082_eq_zero", "code": "theorem scaleRoots_eval\u2082_eq_zero {p : S[X]} (f : S \u2192+* R) {r : R} {s : S} (hr : eval\u2082 f r p = 0) :\n    eval\u2082 f (f s * r) (scaleRoots p s) = 0", "start": [130, 1], "end": [131, 89], "kind": "commanddeclaration"}, {"full_name": "Polynomial.scaleRoots_aeval_eq_zero", "code": "theorem scaleRoots_aeval_eq_zero [Algebra R A] {p : R[X]} {a : A} {r : R} (ha : aeval a p = 0) :\n    aeval (algebraMap R A r * a) (scaleRoots p r) = 0", "start": [134, 1], "end": [136, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.scaleRoots_eval\u2082_eq_zero_of_eval\u2082_div_eq_zero", "code": "theorem scaleRoots_eval\u2082_eq_zero_of_eval\u2082_div_eq_zero {p : S[X]} {f : S \u2192+* K}\n    (hf : Function.Injective f) {r s : S} (hr : eval\u2082 f (f r / f s) p = 0)\n    (hs : s \u2208 nonZeroDivisors S) : eval\u2082 f (f r) (scaleRoots p s) = 0", "start": [139, 1], "end": [145, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.scaleRoots_aeval_eq_zero_of_aeval_div_eq_zero", "code": "theorem scaleRoots_aeval_eq_zero_of_aeval_div_eq_zero [Algebra R K]\n    (inj : Function.Injective (algebraMap R K)) {p : R[X]} {r s : R}\n    (hr : aeval (algebraMap R K r / algebraMap R K s) p = 0) (hs : s \u2208 nonZeroDivisors R) :\n    aeval (algebraMap R K r) (scaleRoots p s) = 0", "start": [148, 1], "end": [152, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Charpoly/LinearMap.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PiToModule.fromMatrix", "code": "def PiToModule.fromMatrix [DecidableEq \u03b9] : Matrix \u03b9 \u03b9 R \u2192\u2097[R] (\u03b9 \u2192 R) \u2192\u2097[R] M :=\n  (LinearMap.llcomp R _ _ _ (Fintype.total R R b)).comp algEquivMatrix'.symm.toLinearMap", "start": [34, 1], "end": [37, 89], "kind": "commanddeclaration"}, {"full_name": "PiToModule.fromMatrix_apply", "code": "theorem PiToModule.fromMatrix_apply [DecidableEq \u03b9] (A : Matrix \u03b9 \u03b9 R) (w : \u03b9 \u2192 R) :\n    PiToModule.fromMatrix R b A w = Fintype.total R R b (A.mulVec w)", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "PiToModule.fromMatrix_apply_single_one", "code": "theorem PiToModule.fromMatrix_apply_single_one [DecidableEq \u03b9] (A : Matrix \u03b9 \u03b9 R) (j : \u03b9) :\n    PiToModule.fromMatrix R b A (Pi.single j 1) = \u2211 i : \u03b9, A i j \u2022 b i", "start": [45, 1], "end": [48, 20], "kind": "commanddeclaration"}, {"full_name": "PiToModule.fromEnd", "code": "def PiToModule.fromEnd : Module.End R M \u2192\u2097[R] (\u03b9 \u2192 R) \u2192\u2097[R] M :=\n  LinearMap.lcomp _ _ (Fintype.total R R b)", "start": [51, 1], "end": [54, 44], "kind": "commanddeclaration"}, {"full_name": "PiToModule.fromEnd_apply", "code": "theorem PiToModule.fromEnd_apply (f : Module.End R M) (w : \u03b9 \u2192 R) :\n    PiToModule.fromEnd R b f w = f (Fintype.total R R b w)", "start": [57, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "PiToModule.fromEnd_apply_single_one", "code": "theorem PiToModule.fromEnd_apply_single_one [DecidableEq \u03b9] (f : Module.End R M) (i : \u03b9) :\n    PiToModule.fromEnd R b f (Pi.single i 1) = f (b i)", "start": [62, 1], "end": [67, 16], "kind": "commanddeclaration"}, {"full_name": "PiToModule.fromEnd_injective", "code": "theorem PiToModule.fromEnd_injective (hb : Submodule.span R (Set.range b) = \u22a4) :\n    Function.Injective (PiToModule.fromEnd R b)", "start": [70, 1], "end": [77, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.Represents", "code": "def Matrix.Represents (A : Matrix \u03b9 \u03b9 R) (f : Module.End R M) : Prop :=\n  PiToModule.fromMatrix R b A = PiToModule.fromEnd R b f", "start": [84, 1], "end": [87, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.Represents.congr_fun", "code": "theorem Matrix.Represents.congr_fun {A : Matrix \u03b9 \u03b9 R} {f : Module.End R M} (h : A.Represents b f)\n    (x) : Fintype.total R R b (A.mulVec x) = f (Fintype.total R R b x)", "start": [92, 1], "end": [94, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.represents_iff", "code": "theorem Matrix.represents_iff {A : Matrix \u03b9 \u03b9 R} {f : Module.End R M} :\n    A.Represents b f \u2194 \u2200 x, Fintype.total R R b (A.mulVec x) = f (Fintype.total R R b x)", "start": [97, 1], "end": [99, 66], "kind": "commanddeclaration"}, {"full_name": "Matrix.represents_iff'", "code": "theorem Matrix.represents_iff' {A : Matrix \u03b9 \u03b9 R} {f : Module.End R M} :\n    A.Represents b f \u2194 \u2200 j, \u2211 i : \u03b9, A i j \u2022 b i = f (b j)", "start": [102, 1], "end": [113, 12], "kind": "commanddeclaration"}, {"full_name": "Matrix.Represents.mul", "code": "theorem Matrix.Represents.mul {A A' : Matrix \u03b9 \u03b9 R} {f f' : Module.End R M} (h : A.Represents b f)\n    (h' : Matrix.Represents b A' f') : (A * A').Represents b (f * f')", "start": [116, 1], "end": [123, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.Represents.one", "code": "theorem Matrix.Represents.one : (1 : Matrix \u03b9 \u03b9 R).Represents b 1", "start": [126, 1], "end": [130, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.Represents.add", "code": "theorem Matrix.Represents.add {A A' : Matrix \u03b9 \u03b9 R} {f f' : Module.End R M} (h : A.Represents b f)\n    (h' : Matrix.Represents b A' f') : (A + A').Represents b (f + f')", "start": [133, 1], "end": [135, 66], "kind": "commanddeclaration"}, {"full_name": "Matrix.Represents.zero", "code": "theorem Matrix.Represents.zero : (0 : Matrix \u03b9 \u03b9 R).Represents b 0", "start": [138, 1], "end": [140, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.Represents.smul", "code": "theorem Matrix.Represents.smul {A : Matrix \u03b9 \u03b9 R} {f : Module.End R M} (h : A.Represents b f)\n    (r : R) : (r \u2022 A).Represents b (r \u2022 f)", "start": [143, 1], "end": [146, 55], "kind": "commanddeclaration"}, {"full_name": "Matrix.Represents.eq", "code": "theorem Matrix.Represents.eq {A : Matrix \u03b9 \u03b9 R} {f f' : Module.End R M} (h : A.Represents b f)\n    (h' : A.Represents b f') : f = f'", "start": [149, 1], "end": [151, 56], "kind": "commanddeclaration"}, {"full_name": "Matrix.isRepresentation", "code": "def Matrix.isRepresentation : Subalgebra R (Matrix \u03b9 \u03b9 R) where\n  carrier := { A | \u2203 f : Module.End R M, A.Represents b f }\n  mul_mem' := fun \u27e8f\u2081, e\u2081\u27e9 \u27e8f\u2082, e\u2082\u27e9 => \u27e8f\u2081 * f\u2082, e\u2081.mul e\u2082\u27e9\n  one_mem' := \u27e81, Matrix.Represents.one\u27e9\n  add_mem' := fun \u27e8f\u2081, e\u2081\u27e9 \u27e8f\u2082, e\u2082\u27e9 => \u27e8f\u2081 + f\u2082, e\u2081.add e\u2082\u27e9\n  zero_mem' := \u27e80, Matrix.Represents.zero\u27e9\n  algebraMap_mem' r := \u27e8r \u2022 (1 : Module.End R M), Matrix.Represents.one.smul r\u27e9", "start": [156, 1], "end": [164, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.isRepresentation.toEnd", "code": "noncomputable def Matrix.isRepresentation.toEnd : Matrix.isRepresentation R b \u2192\u2090[R] Module.End R M\n    where\n  toFun A := A.2.choose\n  map_one' := (1 : Matrix.isRepresentation R b).2.choose_spec.eq hb Matrix.Represents.one\n  map_mul' A\u2081 A\u2082 := (A\u2081 * A\u2082).2.choose_spec.eq hb (A\u2081.2.choose_spec.mul A\u2082.2.choose_spec)\n  map_zero' := (0 : Matrix.isRepresentation R b).2.choose_spec.eq hb Matrix.Represents.zero\n  map_add' A\u2081 A\u2082 := (A\u2081 + A\u2082).2.choose_spec.eq hb (A\u2081.2.choose_spec.add A\u2082.2.choose_spec)\n  commutes' r :=\n    (r \u2022 (1 : Matrix.isRepresentation R b)).2.choose_spec.eq hb (Matrix.Represents.one.smul r)", "start": [167, 1], "end": [176, 95], "kind": "commanddeclaration"}, {"full_name": "Matrix.isRepresentation.toEnd_represents", "code": "theorem Matrix.isRepresentation.toEnd_represents (A : Matrix.isRepresentation R b) :\n    (A : Matrix \u03b9 \u03b9 R).Represents b (Matrix.isRepresentation.toEnd R b hb A)", "start": [179, 1], "end": [181, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.isRepresentation.eq_toEnd_of_represents", "code": "theorem Matrix.isRepresentation.eq_toEnd_of_represents (A : Matrix.isRepresentation R b)\n    {f : Module.End R M} (h : (A : Matrix \u03b9 \u03b9 R).Represents b f) :\n    Matrix.isRepresentation.toEnd R b hb A = f", "start": [184, 1], "end": [187, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.isRepresentation.toEnd_exists_mem_ideal", "code": "theorem Matrix.isRepresentation.toEnd_exists_mem_ideal (f : Module.End R M) (I : Ideal R)\n    (hI : LinearMap.range f \u2264 I \u2022 \u22a4) :\n    \u2203 M, Matrix.isRepresentation.toEnd R b hb M = f \u2227 \u2200 i j, M.1 i j \u2208 I", "start": [190, 1], "end": [206, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.isRepresentation.toEnd_surjective", "code": "theorem Matrix.isRepresentation.toEnd_surjective :\n    Function.Surjective (Matrix.isRepresentation.toEnd R b hb)", "start": [209, 1], "end": [213, 15], "kind": "commanddeclaration"}, {"full_name": "LinearMap.exists_monic_and_coeff_mem_pow_and_aeval_eq_zero_of_range_le_smul", "code": "theorem LinearMap.exists_monic_and_coeff_mem_pow_and_aeval_eq_zero_of_range_le_smul\n    [Module.Finite R M] (f : Module.End R M) (I : Ideal R) (hI : LinearMap.range f \u2264 I \u2022 \u22a4) :\n    \u2203 p : R[X], p.Monic \u2227 (\u2200 k, p.coeff k \u2208 I ^ (p.natDegree - k)) \u2227 Polynomial.aeval f p = 0", "start": [218, 1], "end": [245, 92], "kind": "commanddeclaration"}, {"full_name": "LinearMap.exists_monic_and_aeval_eq_zero", "code": "theorem LinearMap.exists_monic_and_aeval_eq_zero [Module.Finite R M] (f : Module.End R M) :\n    \u2203 p : R[X], p.Monic \u2227 Polynomial.aeval f p = 0", "start": [248, 1], "end": [251, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/Products.lean", "imports": ["Mathlib/CategoryTheory/Limits/HasLimits.lean", "Mathlib/CategoryTheory/DiscreteCategory.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.Fan", "code": "abbrev Fan (f : \u03b2 \u2192 C) :=\n  Cone (Discrete.functor f)", "start": [54, 1], "end": [56, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofan", "code": "abbrev Cofan (f : \u03b2 \u2192 C) :=\n  Cocone (Discrete.functor f)", "start": [59, 1], "end": [61, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fan.mk", "code": "@[simps! pt \u03c0_app]\ndef Fan.mk {f : \u03b2 \u2192 C} (P : C) (p : \u2200 b, P \u27f6 f b) : Fan f where\n  pt := P\n  \u03c0 := Discrete.natTrans (fun X => p X.as)", "start": [64, 1], "end": [68, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofan.mk", "code": "@[simps! pt \u03b9_app]\ndef Cofan.mk {f : \u03b2 \u2192 C} (P : C) (p : \u2200 b, f b \u27f6 P) : Cofan f where\n  pt := P\n  \u03b9 := Discrete.natTrans (fun X => p X.as)", "start": [71, 1], "end": [75, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fan.proj", "code": "def Fan.proj {f : \u03b2 \u2192 C} (p : Fan f) (j : \u03b2) : p.pt \u27f6 f j :=\n  p.\u03c0.app (Discrete.mk j)", "start": [78, 1], "end": [81, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofan.inj", "code": "def Cofan.inj {f : \u03b2 \u2192 C} (p : Cofan f) (j : \u03b2) : f j \u27f6 p.pt :=\n  p.\u03b9.app (Discrete.mk j)", "start": [84, 1], "end": [87, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.fan_mk_proj", "code": "@[simp]\ntheorem fan_mk_proj {f : \u03b2 \u2192 C} (P : C) (p : \u2200 b, P \u27f6 f b) (j : \u03b2) : (Fan.mk P p).proj j = p j", "start": [89, 1], "end": [91, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cofan_mk_inj", "code": "@[simp]\ntheorem cofan_mk_inj {f : \u03b2 \u2192 C} (P : C) (p : \u2200 b, f b \u27f6 P) (j : \u03b2) :\n    (Cofan.mk P p).inj j = p j", "start": [94, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasProduct", "code": "abbrev HasProduct (f : \u03b2 \u2192 C) :=\n  HasLimit (Discrete.functor f)", "start": [99, 1], "end": [101, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasCoproduct", "code": "abbrev HasCoproduct (f : \u03b2 \u2192 C) :=\n  HasColimit (Discrete.functor f)", "start": [104, 1], "end": [106, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.mkFanLimit", "code": "@[simps]\ndef mkFanLimit {f : \u03b2 \u2192 C} (t : Fan f) (lift : \u2200 s : Fan f, s.pt \u27f6 t.pt)\n    (fac : \u2200 (s : Fan f) (j : \u03b2), lift s \u226b t.proj j = s.proj j := by aesop_cat)\n    (uniq : \u2200 (s : Fan f) (m : s.pt \u27f6 t.pt) (_ : \u2200 j : \u03b2, m \u226b t.proj j = s.proj j),\n      m = lift s := by aesop_cat) :\n    IsLimit t :=\n  { lift }", "start": [109, 1], "end": [117, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fan.IsLimit.desc", "code": "def Fan.IsLimit.desc {F : \u03b2 \u2192 C} {c : Fan F} (hc : IsLimit c) {A : C}\n    (f : \u2200 i, A \u27f6 F i) : A \u27f6 c.pt :=\n  hc.lift (Fan.mk A f)", "start": [120, 1], "end": [123, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Fan.IsLimit.fac", "code": "@[reassoc (attr := simp)]\nlemma Fan.IsLimit.fac {F : \u03b2 \u2192 C} {c : Fan F} (hc : IsLimit c) {A : C}\n    (f : \u2200 i, A \u27f6 F i) (i : \u03b2) :\n    Fan.IsLimit.desc hc f \u226b c.proj i = f i :=\n  hc.fac (Fan.mk A f) \u27e8i\u27e9", "start": [125, 1], "end": [129, 26], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Fan.IsLimit.hom_ext", "code": "lemma Fan.IsLimit.hom_ext {F : I \u2192 C} {c : Fan F} (hc : IsLimit c) {A : C}\n    (f g : A \u27f6 c.pt) (h : \u2200 i, f \u226b c.proj i = g \u226b c.proj i) : f = g :=\n  hc.hom_ext (fun \u27e8i\u27e9 => h i)", "start": [131, 1], "end": [133, 30], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.mkCofanColimit", "code": "@[simps]\ndef mkCofanColimit {f : \u03b2 \u2192 C} (s : Cofan f) (desc : \u2200 t : Cofan f, s.pt \u27f6 t.pt)\n    (fac : \u2200 (t : Cofan f) (j : \u03b2), s.inj j \u226b desc t = t.inj j := by aesop_cat)\n    (uniq : \u2200 (t : Cofan f) (m : s.pt \u27f6 t.pt) (_ : \u2200 j : \u03b2, s.inj j \u226b m = t.inj j),\n      m = desc t := by aesop_cat) :\n    IsColimit s :=\n  { desc }", "start": [135, 1], "end": [143, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofan.IsColimit.desc", "code": "def Cofan.IsColimit.desc {F : \u03b2 \u2192 C} {c : Cofan F} (hc : IsColimit c) {A : C}\n    (f : \u2200 i, F i \u27f6 A) : c.pt \u27f6 A :=\n  hc.desc (Cofan.mk A f)", "start": [145, 1], "end": [148, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cofan.IsColimit.fac", "code": "@[reassoc (attr := simp)]\nlemma Cofan.IsColimit.fac {F : \u03b2 \u2192 C} {c : Cofan F} (hc : IsColimit c) {A : C}\n    (f : \u2200 i, F i \u27f6 A) (i : \u03b2) :\n    c.inj i \u226b Cofan.IsColimit.desc hc f = f i :=\n  hc.fac (Cofan.mk A f) \u27e8i\u27e9", "start": [150, 1], "end": [154, 28], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Cofan.IsColimit.hom_ext", "code": "lemma Cofan.IsColimit.hom_ext {F : I \u2192 C} {c : Cofan F} (hc : IsColimit c) {A : C}\n    (f g : c.pt \u27f6 A) (h : \u2200 i, c.inj i \u226b f = c.inj i \u226b g) : f = g :=\n  hc.hom_ext (fun \u27e8i\u27e9 => h i)", "start": [156, 1], "end": [158, 30], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.HasProductsOfShape", "code": "abbrev HasProductsOfShape (\u03b2 : Type v) :=\n  HasLimitsOfShape.{v} (Discrete \u03b2)", "start": [164, 1], "end": [166, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasCoproductsOfShape", "code": "abbrev HasCoproductsOfShape (\u03b2 : Type v) :=\n  HasColimitsOfShape.{v} (Discrete \u03b2)", "start": [169, 1], "end": [171, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.piObj", "code": "abbrev piObj (f : \u03b2 \u2192 C) [HasProduct f] :=\n  limit (Discrete.functor f)", "start": [176, 1], "end": [180, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.sigmaObj", "code": "abbrev sigmaObj (f : \u03b2 \u2192 C) [HasCoproduct f] :=\n  colimit (Discrete.functor f)", "start": [183, 1], "end": [187, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Pi.\u03c0", "code": "abbrev Pi.\u03c0 (f : \u03b2 \u2192 C) [HasProduct f] (b : \u03b2) : \u220f f \u27f6 f b :=\n  limit.\u03c0 (Discrete.functor f) (Discrete.mk b)", "start": [196, 1], "end": [198, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Sigma.\u03b9", "code": "abbrev Sigma.\u03b9 (f : \u03b2 \u2192 C) [HasCoproduct f] (b : \u03b2) : f b \u27f6 \u2210 f :=\n  colimit.\u03b9 (Discrete.functor f) (Discrete.mk b)", "start": [201, 1], "end": [203, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Pi.hom_ext", "code": "@[ext 1050]\nlemma Pi.hom_ext {f : \u03b2 \u2192 C} [HasProduct f] {X : C} (g\u2081 g\u2082 : X \u27f6 \u220f f)\n    (h : \u2200 (b : \u03b2), g\u2081 \u226b Pi.\u03c0 f b = g\u2082 \u226b Pi.\u03c0 f b) : g\u2081 = g\u2082 :=\n  limit.hom_ext (fun \u27e8j\u27e9 => h j)", "start": [209, 1], "end": [212, 33], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Sigma.hom_ext", "code": "@[ext 1050]\nlemma Sigma.hom_ext {f : \u03b2 \u2192 C} [HasCoproduct f] {X : C} (g\u2081 g\u2082 : \u2210 f \u27f6 X)\n    (h : \u2200 (b : \u03b2), Sigma.\u03b9 f b \u226b g\u2081 = Sigma.\u03b9 f b \u226b g\u2082) : g\u2081 = g\u2082 :=\n  colimit.hom_ext (fun \u27e8j\u27e9 => h j)", "start": [214, 1], "end": [217, 35], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.productIsProduct", "code": "def productIsProduct (f : \u03b2 \u2192 C) [HasProduct f] : IsLimit (Fan.mk _ (Pi.\u03c0 f)) :=\n  IsLimit.ofIsoLimit (limit.isLimit (Discrete.functor f)) (Cones.ext (Iso.refl _))", "start": [219, 1], "end": [221, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coproductIsCoproduct", "code": "def coproductIsCoproduct (f : \u03b2 \u2192 C) [HasCoproduct f] : IsColimit (Cofan.mk _ (Sigma.\u03b9 f)) :=\n  IsColimit.ofIsoColimit (colimit.isColimit (Discrete.functor f)) (Cocones.ext (Iso.refl _))", "start": [224, 1], "end": [226, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Pi.\u03c0_comp_eqToHom", "code": "@[reassoc (attr := simp, nolint simpNF)]\ntheorem Pi.\u03c0_comp_eqToHom (f : J \u2192 C) [HasProduct f] {j j' : J} (w : j = j') :\n    Pi.\u03c0 f j \u226b eqToHom (by simp [w]) = Pi.\u03c0 f j'", "start": [232, 1], "end": [236, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Sigma.eqToHom_comp_\u03b9", "code": "@[reassoc (attr := simp, nolint simpNF)]\ntheorem Sigma.eqToHom_comp_\u03b9 (f : J \u2192 C) [HasCoproduct f] {j j' : J} (w : j = j') :\n    eqToHom (by simp [w]) \u226b Sigma.\u03b9 f j' = Sigma.\u03b9 f j", "start": [241, 1], "end": [245, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Pi.lift", "code": "abbrev Pi.lift {f : \u03b2 \u2192 C} [HasProduct f] {P : C} (p : \u2200 b, P \u27f6 f b) : P \u27f6 \u220f f :=\n  limit.lift _ (Fan.mk P p)", "start": [247, 1], "end": [249, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Sigma.desc", "code": "abbrev Sigma.desc {f : \u03b2 \u2192 C} [HasCoproduct f] {P : C} (p : \u2200 b, f b \u27f6 P) : \u2210 f \u27f6 P :=\n  colimit.desc _ (Cofan.mk P p)", "start": [252, 1], "end": [254, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Pi.map", "code": "abbrev Pi.map {f g : \u03b2 \u2192 C} [HasProduct f] [HasProduct g] (p : \u2200 b, f b \u27f6 g b) : \u220f f \u27f6 \u220f g :=\n  limMap (Discrete.natTrans fun X => p X.as)", "start": [257, 1], "end": [261, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Pi.map_id", "code": "@[simp]\nlemma Pi.map_id {f : \u03b1 \u2192 C} [HasProduct f] : Pi.map (fun a => \ud835\udfd9 (f a)) = \ud835\udfd9 (\u220f f) := by\n  ext; simp", "start": [264, 1], "end": [266, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Pi.map_comp_map", "code": "lemma Pi.map_comp_map {f g h : \u03b1 \u2192 C} [HasProduct f] [HasProduct g] [HasProduct h]\n    (q : \u2200 (a : \u03b1), f a \u27f6 g a) (q' : \u2200 (a : \u03b1), g a \u27f6 h a) :\n    Pi.map q \u226b Pi.map q' = Pi.map (fun a => q a \u226b q' a) := by\n  ext; simp", "start": [268, 1], "end": [271, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Pi.map_mono", "code": "instance Pi.map_mono {f g : \u03b2 \u2192 C} [HasProduct f] [HasProduct g] (p : \u2200 b, f b \u27f6 g b)\n    [\u2200 i, Mono (p i)] : Mono <| Pi.map p :=\n  @Limits.limMap_mono _ _ _ _ (Discrete.functor f) (Discrete.functor g) _ _\n    (Discrete.natTrans fun X => p X.as) (by dsimp; infer_instance)", "start": [273, 1], "end": [276, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Pi.map'", "code": "def Pi.map' {f : \u03b1 \u2192 C} {g : \u03b2 \u2192 C} [HasProduct f] [HasProduct g] (p : \u03b2 \u2192 \u03b1)\n    (q : \u2200 (b : \u03b2), f (p b) \u27f6 g b) : \u220f f \u27f6 \u220f g :=\n  Pi.lift (fun a => Pi.\u03c0 _ _ \u226b q a)", "start": [279, 1], "end": [283, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Pi.map'_comp_\u03c0", "code": "@[reassoc (attr := simp)]\nlemma Pi.map'_comp_\u03c0 {f : \u03b1 \u2192 C} {g : \u03b2 \u2192 C} [HasProduct f] [HasProduct g] (p : \u03b2 \u2192 \u03b1)\n    (q : \u2200 (b : \u03b2), f (p b) \u27f6 g b) (b : \u03b2) : Pi.map' p q \u226b Pi.\u03c0 g b = Pi.\u03c0 f (p b) \u226b q b :=\n  limit.lift_\u03c0 _ _", "start": [285, 1], "end": [288, 19], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Pi.map'_id_id", "code": "lemma Pi.map'_id_id {f : \u03b1 \u2192 C} [HasProduct f] : Pi.map' id (fun a => \ud835\udfd9 (f a)) = \ud835\udfd9 (\u220f f) := by\n  ext; simp", "start": [290, 1], "end": [291, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Pi.map'_id", "code": "@[simp]\nlemma Pi.map'_id {f g : \u03b1 \u2192 C} [HasProduct f] [HasProduct g] (p : \u2200 b, f b \u27f6 g b) :\n    Pi.map' id p = Pi.map p :=\n  rfl", "start": [293, 1], "end": [296, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Pi.map'_comp_map'", "code": "lemma Pi.map'_comp_map' {f : \u03b1 \u2192 C} {g : \u03b2 \u2192 C} {h : \u03b3 \u2192 C} [HasProduct f] [HasProduct g]\n    [HasProduct h] (p : \u03b2 \u2192 \u03b1) (p' : \u03b3 \u2192 \u03b2) (q : \u2200 (b : \u03b2), f (p b) \u27f6 g b)\n    (q' : \u2200 (c : \u03b3), g (p' c) \u27f6 h c) :\n    Pi.map' p q \u226b Pi.map' p' q' = Pi.map' (p \u2218 p') (fun c => q (p' c) \u226b q' c) := by\n  ext; simp", "start": [298, 1], "end": [302, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Pi.map'_comp_map", "code": "lemma Pi.map'_comp_map {f : \u03b1 \u2192 C} {g h : \u03b2 \u2192 C} [HasProduct f] [HasProduct g] [HasProduct h]\n    (p : \u03b2 \u2192 \u03b1) (q : \u2200 (b : \u03b2), f (p b) \u27f6 g b) (q' : \u2200 (b : \u03b2), g b \u27f6 h b) :\n    Pi.map' p q \u226b Pi.map q' = Pi.map' p (fun b => q b \u226b q' b) := by\n  ext; simp", "start": [304, 1], "end": [307, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Pi.map_comp_map'", "code": "lemma Pi.map_comp_map' {f g : \u03b1 \u2192 C} {h : \u03b2 \u2192 C} [HasProduct f] [HasProduct g] [HasProduct h]\n    (p : \u03b2 \u2192 \u03b1) (q : \u2200 (a : \u03b1), f a \u27f6 g a) (q' : \u2200 (b : \u03b2), g (p b) \u27f6 h b) :\n    Pi.map q \u226b Pi.map' p q' = Pi.map' p (fun b => q (p b) \u226b q' b) := by\n  ext; simp", "start": [309, 1], "end": [312, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Pi.map'_eq", "code": "lemma Pi.map'_eq {f : \u03b1 \u2192 C} {g : \u03b2 \u2192 C} [HasProduct f] [HasProduct g] {p p' : \u03b2 \u2192 \u03b1}\n    {q : \u2200 (b : \u03b2), f (p b) \u27f6 g b} {q' : \u2200 (b : \u03b2), f (p' b) \u27f6 g b} (hp : p = p')\n    (hq : \u2200 (b : \u03b2), eqToHom (hp \u25b8 rfl) \u226b q b = q' b) : Pi.map' p q = Pi.map' p' q' := by\n  aesop_cat", "start": [314, 1], "end": [317, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Pi.mapIso", "code": "abbrev Pi.mapIso {f g : \u03b2 \u2192 C} [HasProductsOfShape \u03b2 C] (p : \u2200 b, f b \u2245 g b) : \u220f f \u2245 \u220f g :=\n  lim.mapIso (Discrete.natIso fun X => p X.as)", "start": [319, 1], "end": [323, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Sigma.map", "code": "abbrev Sigma.map {f g : \u03b2 \u2192 C} [HasCoproduct f] [HasCoproduct g] (p : \u2200 b, f b \u27f6 g b) : \u2210 f \u27f6 \u2210 g :=\n  colimMap (Discrete.natTrans fun X => p X.as)", "start": [326, 1], "end": [330, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Sigma.map_id", "code": "@[simp]\nlemma Sigma.map_id {f : \u03b1 \u2192 C} [HasCoproduct f] : Sigma.map (fun a => \ud835\udfd9 (f a)) = \ud835\udfd9 (\u2210 f) := by\n  ext; simp", "start": [333, 1], "end": [335, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Sigma.map_comp_map", "code": "lemma Sigma.map_comp_map {f g h : \u03b1 \u2192 C} [HasCoproduct f] [HasCoproduct g] [HasCoproduct h]\n    (q : \u2200 (a : \u03b1), f a \u27f6 g a) (q' : \u2200 (a : \u03b1), g a \u27f6 h a) :\n    Sigma.map q \u226b Sigma.map q' = Sigma.map (fun a => q a \u226b q' a) := by\n  ext; simp", "start": [337, 1], "end": [340, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Sigma.map_epi", "code": "instance Sigma.map_epi {f g : \u03b2 \u2192 C} [HasCoproduct f] [HasCoproduct g] (p : \u2200 b, f b \u27f6 g b)\n    [\u2200 i, Epi (p i)] : Epi <| Sigma.map p :=\n  @Limits.colimMap_epi _ _ _ _ (Discrete.functor f) (Discrete.functor g) _ _\n    (Discrete.natTrans fun X => p X.as) (by dsimp; infer_instance)", "start": [342, 1], "end": [345, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Sigma.map'", "code": "def Sigma.map' {f : \u03b1 \u2192 C} {g : \u03b2 \u2192 C} [HasCoproduct f] [HasCoproduct g] (p : \u03b1 \u2192 \u03b2)\n    (q : \u2200 (a : \u03b1), f a \u27f6 g (p a)) : \u2210 f \u27f6 \u2210 g :=\n  Sigma.desc (fun a => q a \u226b Sigma.\u03b9 _ _)", "start": [348, 1], "end": [352, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Sigma.\u03b9_comp_map'", "code": "@[reassoc (attr := simp)]\nlemma Sigma.\u03b9_comp_map' {f : \u03b1 \u2192 C} {g : \u03b2 \u2192 C} [HasCoproduct f] [HasCoproduct g]\n    (p : \u03b1 \u2192 \u03b2) (q : \u2200 (a : \u03b1), f a \u27f6 g (p a)) (a : \u03b1) :\n    Sigma.\u03b9 f a \u226b Sigma.map' p q = q a \u226b Sigma.\u03b9 g (p a) :=\n  colimit.\u03b9_desc _ _", "start": [354, 1], "end": [358, 21], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Sigma.map'_id_id", "code": "lemma Sigma.map'_id_id {f : \u03b1 \u2192 C} [HasCoproduct f] :\n    Sigma.map' id (fun a => \ud835\udfd9 (f a)) = \ud835\udfd9 (\u2210 f) := by\n  ext; simp", "start": [360, 1], "end": [362, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Sigma.map'_id", "code": "@[simp]\nlemma Sigma.map'_id {f g : \u03b1 \u2192 C} [HasCoproduct f] [HasCoproduct g] (p : \u2200 b, f b \u27f6 g b) :\n    Sigma.map' id p = Sigma.map p :=\n  rfl", "start": [364, 1], "end": [367, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Sigma.map'_comp_map'", "code": "lemma Sigma.map'_comp_map' {f : \u03b1 \u2192 C} {g : \u03b2 \u2192 C} {h : \u03b3 \u2192 C} [HasCoproduct f] [HasCoproduct g]\n    [HasCoproduct h] (p : \u03b1 \u2192 \u03b2) (p' : \u03b2 \u2192 \u03b3) (q : \u2200 (a : \u03b1), f a \u27f6 g (p a))\n    (q' : \u2200 (b : \u03b2), g b \u27f6 h (p' b)) :\n    Sigma.map' p q \u226b Sigma.map' p' q' = Sigma.map' (p' \u2218 p) (fun a => q a \u226b q' (p a)) := by\n  ext; simp", "start": [369, 1], "end": [373, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Sigma.map'_comp_map", "code": "lemma Sigma.map'_comp_map {f : \u03b1 \u2192 C} {g h : \u03b2 \u2192 C} [HasCoproduct f] [HasCoproduct g]\n    [HasCoproduct h] (p : \u03b1 \u2192 \u03b2) (q : \u2200 (a : \u03b1), f a \u27f6 g (p a)) (q' : \u2200 (b : \u03b2), g b \u27f6 h b) :\n    Sigma.map' p q \u226b Sigma.map q' = Sigma.map' p (fun a => q a \u226b q' (p a)) := by\n  ext; simp", "start": [375, 1], "end": [378, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Sigma.map_comp_map'", "code": "lemma Sigma.map_comp_map' {f g : \u03b1 \u2192 C} {h : \u03b2 \u2192 C} [HasCoproduct f] [HasCoproduct g]\n    [HasCoproduct h] (p : \u03b1 \u2192 \u03b2) (q : \u2200 (a : \u03b1), f a \u27f6 g a) (q' : \u2200 (a : \u03b1), g a \u27f6 h (p a)) :\n    Sigma.map q \u226b Sigma.map' p q' = Sigma.map' p (fun a => q a \u226b q' a) := by\n  ext; simp", "start": [380, 1], "end": [383, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Sigma.map'_eq", "code": "lemma Sigma.map'_eq {f : \u03b1 \u2192 C} {g : \u03b2 \u2192 C} [HasCoproduct f] [HasCoproduct g]\n    {p p' : \u03b1 \u2192 \u03b2} {q : \u2200 (a : \u03b1), f a \u27f6 g (p a)} {q' : \u2200 (a : \u03b1), f a \u27f6 g (p' a)}\n    (hp : p = p') (hq : \u2200 (a : \u03b1), q a \u226b eqToHom (hp \u25b8 rfl) = q' a) :\n    Sigma.map' p q = Sigma.map' p' q' := by\n  aesop_cat", "start": [385, 1], "end": [389, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Sigma.mapIso", "code": "abbrev Sigma.mapIso {f g : \u03b2 \u2192 C} [HasCoproductsOfShape \u03b2 C] (p : \u2200 b, f b \u2245 g b) : \u2210 f \u2245 \u2210 g :=\n  colim.mapIso (Discrete.natIso fun X => p X.as)", "start": [391, 1], "end": [395, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Pi.whiskerEquiv", "code": "@[simps]\ndef Pi.whiskerEquiv {f : J \u2192 C} {g : K \u2192 C} (e : J \u2243 K) (w : \u2200 j, g (e j) \u2245 f j)\n    [HasProduct f] [HasProduct g] : \u220f f \u2245 \u220f g where\n  hom := Pi.map' e.symm fun k => (w (e.symm k)).inv \u226b eqToHom (by simp)\n  inv := Pi.map' e fun j => (w j).hom", "start": [398, 1], "end": [405, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Sigma.whiskerEquiv", "code": "@[simps]\ndef Sigma.whiskerEquiv {f : J \u2192 C} {g : K \u2192 C} (e : J \u2243 K) (w : \u2200 j, g (e j) \u2245 f j)\n    [HasCoproduct f] [HasCoproduct g] : \u2210 f \u2245 \u2210 g where\n  hom := Sigma.map' e fun j => (w j).inv\n  inv := Sigma.map' e.symm fun k => eqToHom (by simp) \u226b (w (e.symm k)).hom", "start": [407, 1], "end": [414, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.piPiIso", "code": "@[simps]\ndef piPiIso (f : \u03b9 \u2192 Type*) (g : (i : \u03b9) \u2192 (f i) \u2192 C)\n    [\u2200 i, HasProduct (g i)] [HasProduct fun i => \u220f g i] :\n    (\u220f fun i => \u220f g i) \u2245 (\u220f fun p : \u03a3 i, f i => g p.1 p.2) where\n  hom := Pi.lift fun \u27e8i, x\u27e9 => Pi.\u03c0 _ i \u226b Pi.\u03c0 _ x\n  inv := Pi.lift fun i => Pi.lift fun x => Pi.\u03c0 _ (\u27e8i, x\u27e9 : \u03a3 i, f i)", "start": [423, 1], "end": [429, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.sigmaSigmaIso", "code": "@[simps]\ndef sigmaSigmaIso (f : \u03b9 \u2192 Type*) (g : (i : \u03b9) \u2192 (f i) \u2192 C)\n    [\u2200 i, HasCoproduct (g i)] [HasCoproduct fun i => \u2210 g i] :\n    (\u2210 fun i => \u2210 g i) \u2245 (\u2210 fun p : \u03a3 i, f i => g p.1 p.2) where\n  hom := Sigma.desc fun i => Sigma.desc fun x => Sigma.\u03b9 (fun p : \u03a3 i, f i => g p.1 p.2) \u27e8i, x\u27e9\n  inv := Sigma.desc fun \u27e8i, x\u27e9 => Sigma.\u03b9 (g i) x \u226b Sigma.\u03b9 (fun i => \u2210 g i) i", "start": [440, 1], "end": [446, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.piComparison", "code": "def piComparison [HasProduct f] [HasProduct fun b => G.obj (f b)] :\n    G.obj (\u220f f) \u27f6 \u220f fun b => G.obj (f b) :=\n  Pi.lift fun b => G.map (Pi.\u03c0 f b)", "start": [454, 1], "end": [458, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.piComparison_comp_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem piComparison_comp_\u03c0 [HasProduct f] [HasProduct fun b => G.obj (f b)] (b : \u03b2) :\n    piComparison G f \u226b Pi.\u03c0 _ b = G.map (Pi.\u03c0 f b)", "start": [461, 1], "end": [464, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.map_lift_piComparison", "code": "@[reassoc (attr := simp)]\ntheorem map_lift_piComparison [HasProduct f] [HasProduct fun b => G.obj (f b)] (P : C)\n    (g : \u2200 j, P \u27f6 f j) : G.map (Pi.lift g) \u226b piComparison G f = Pi.lift fun j => G.map (g j)", "start": [467, 1], "end": [472, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.sigmaComparison", "code": "def sigmaComparison [HasCoproduct f] [HasCoproduct fun b => G.obj (f b)] :\n    \u2210 (fun b => G.obj (f b)) \u27f6 G.obj (\u2210 f) :=\n  Sigma.desc fun b => G.map (Sigma.\u03b9 f b)", "start": [475, 1], "end": [479, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.\u03b9_comp_sigmaComparison", "code": "@[reassoc (attr := simp)]\ntheorem \u03b9_comp_sigmaComparison [HasCoproduct f] [HasCoproduct fun b => G.obj (f b)] (b : \u03b2) :\n    Sigma.\u03b9 _ b \u226b sigmaComparison G f = G.map (Sigma.\u03b9 f b)", "start": [482, 1], "end": [485, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.sigmaComparison_map_desc", "code": "@[reassoc (attr := simp)]\ntheorem sigmaComparison_map_desc [HasCoproduct f] [HasCoproduct fun b => G.obj (f b)] (P : C)\n    (g : \u2200 j, f j \u27f6 P) :\n    sigmaComparison G f \u226b G.map (Sigma.desc g) = Sigma.desc fun j => G.map (g j)", "start": [488, 1], "end": [494, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasProducts", "code": "abbrev HasProducts :=\n  \u2200 J : Type w, HasLimitsOfShape (Discrete J) C", "start": [501, 1], "end": [503, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasCoproducts", "code": "abbrev HasCoproducts :=\n  \u2200 J : Type w, HasColimitsOfShape (Discrete J) C", "start": [506, 1], "end": [508, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.has_smallest_products_of_hasProducts", "code": "theorem has_smallest_products_of_hasProducts [HasProducts.{w} C] : HasProducts.{0} C", "start": [513, 1], "end": [514, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.has_smallest_coproducts_of_hasCoproducts", "code": "theorem has_smallest_coproducts_of_hasCoproducts [HasCoproducts.{w} C] : HasCoproducts.{0} C", "start": [517, 1], "end": [519, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasProducts_of_limit_fans", "code": "theorem hasProducts_of_limit_fans (lf : \u2200 {J : Type w} (f : J \u2192 C), Fan f)\n    (lf_is_limit : \u2200 {J : Type w} (f : J \u2192 C), IsLimit (lf f)) : HasProducts.{w} C", "start": [522, 1], "end": [528, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitConeOfUnique", "code": "@[simps]\ndef limitConeOfUnique : LimitCone (Discrete.functor f)\n    where\n  cone :=\n    { pt := f default\n      \u03c0 := Discrete.natTrans (fun \u27e8j\u27e9 => eqToHom (by\n        dsimp\n        congr\n        apply Subsingleton.elim)) }\n  isLimit :=\n    { lift := fun s => s.\u03c0.app default\n      fac := fun s j => by\n        have h := Subsingleton.elim j default\n        subst h\n        simp\n      uniq := fun s m w => by\n        specialize w default\n        simpa using w }", "start": [540, 1], "end": [558, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasProduct_unique", "code": "instance (priority := 100) hasProduct_unique : HasProduct f :=\n  HasLimit.mk (limitConeOfUnique f)", "start": [561, 1], "end": [562, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.productUniqueIso", "code": "@[simps!]\ndef productUniqueIso : \u220f f \u2245 f default :=\n  IsLimit.conePointUniqueUpToIso (limit.isLimit _) (limitConeOfUnique f).isLimit", "start": [565, 1], "end": [568, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimitCoconeOfUnique", "code": "@[simps]\ndef colimitCoconeOfUnique : ColimitCocone (Discrete.functor f)\n    where\n  cocone :=\n    { pt := f default\n      \u03b9 := Discrete.natTrans (fun \u27e8j\u27e9 => eqToHom (by\n        dsimp\n        congr\n        apply Subsingleton.elim)) }\n  isColimit :=\n    { desc := fun s => s.\u03b9.app default\n      fac := fun s j => by\n        have h := Subsingleton.elim j default\n        subst h\n        apply Category.id_comp\n      uniq := fun s m w => by\n        specialize w default\n        erw [Category.id_comp] at w\n        exact w }", "start": [571, 1], "end": [590, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoproduct_unique", "code": "instance (priority := 100) hasCoproduct_unique : HasCoproduct f :=\n  HasColimit.mk (colimitCoconeOfUnique f)", "start": [593, 1], "end": [594, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coproductUniqueIso", "code": "@[simps!]\ndef coproductUniqueIso : \u2210 f \u2245 f default :=\n  IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) (colimitCoconeOfUnique f).isColimit", "start": [597, 1], "end": [600, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Pi.reindex", "code": "def Pi.reindex : piObj (f \u2218 \u03b5) \u2245 piObj f :=\n  HasLimit.isoOfEquivalence (Discrete.equivalence \u03b5) (Discrete.natIso fun _ => Iso.refl _)", "start": [613, 1], "end": [615, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Pi.reindex_hom_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem Pi.reindex_hom_\u03c0 (b : \u03b2) : (Pi.reindex \u03b5 f).hom \u226b Pi.\u03c0 f (\u03b5 b) = Pi.\u03c0 (f \u2218 \u03b5) b", "start": [618, 1], "end": [624, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Pi.reindex_inv_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem Pi.reindex_inv_\u03c0 (b : \u03b2) : (Pi.reindex \u03b5 f).inv \u226b Pi.\u03c0 (f \u2218 \u03b5) b = Pi.\u03c0 f (\u03b5 b)", "start": [627, 1], "end": [629, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Sigma.reindex", "code": "def Sigma.reindex : sigmaObj (f \u2218 \u03b5) \u2245 sigmaObj f :=\n  HasColimit.isoOfEquivalence (Discrete.equivalence \u03b5) (Discrete.natIso fun _ => Iso.refl _)", "start": [638, 1], "end": [640, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Sigma.\u03b9_reindex_hom", "code": "@[reassoc (attr := simp)]\ntheorem Sigma.\u03b9_reindex_hom (b : \u03b2) :\n    Sigma.\u03b9 (f \u2218 \u03b5) b \u226b (Sigma.reindex \u03b5 f).hom = Sigma.\u03b9 f (\u03b5 b)", "start": [643, 1], "end": [653, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Sigma.\u03b9_reindex_inv", "code": "@[reassoc (attr := simp)]\ntheorem Sigma.\u03b9_reindex_inv (b : \u03b2) :\n    Sigma.\u03b9 f (\u03b5 b) \u226b (Sigma.reindex \u03b5 f).inv = Sigma.\u03b9 (f \u2218 \u03b5) b", "start": [656, 1], "end": [658, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/ZeroObjects.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.IsZero", "code": "structure IsZero (X : C) : Prop where\n  \n  unique_to : \u2200 Y, Nonempty (Unique (X \u27f6 Y))\n  \n  unique_from : \u2200 Y, Nonempty (Unique (Y \u27f6 X))", "start": [39, 1], "end": [47, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.to_", "code": "protected def to_ (h : IsZero X) (Y : C) : X \u27f6 Y :=\n  @default _ <| (h.unique_to Y).some.toInhabited", "start": [55, 1], "end": [57, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.eq_to", "code": "theorem eq_to (h : IsZero X) (f : X \u27f6 Y) : f = h.to_ Y", "start": [60, 1], "end": [61, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.to_eq", "code": "theorem to_eq (h : IsZero X) (f : X \u27f6 Y) : h.to_ Y = f", "start": [64, 1], "end": [65, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.from_", "code": "protected def from_ (h : IsZero X) (Y : C) : Y \u27f6 X :=\n  @default _ <| (h.unique_from Y).some.toInhabited", "start": [69, 1], "end": [71, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.eq_from", "code": "theorem eq_from (h : IsZero X) (f : Y \u27f6 X) : f = h.from_ Y", "start": [74, 1], "end": [75, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.from_eq", "code": "theorem from_eq (h : IsZero X) (f : Y \u27f6 X) : h.from_ Y = f", "start": [78, 1], "end": [79, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.eq_of_src", "code": "theorem eq_of_src (hX : IsZero X) (f g : X \u27f6 Y) : f = g", "start": [82, 1], "end": [83, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.eq_of_tgt", "code": "theorem eq_of_tgt (hX : IsZero X) (f g : Y \u27f6 X) : f = g", "start": [86, 1], "end": [87, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.iso", "code": "def iso (hX : IsZero X) (hY : IsZero Y) : X \u2245 Y\n    where\n  hom := hX.to_ Y\n  inv := hX.from_ Y\n  hom_inv_id := hX.eq_of_src _ _\n  inv_hom_id := hY.eq_of_src _ _", "start": [90, 1], "end": [96, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.isInitial", "code": "protected def isInitial (hX : IsZero X) : IsInitial X :=\n  @IsInitial.ofUnique _ _ X fun Y => (hX.unique_to Y).some", "start": [99, 1], "end": [101, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.isTerminal", "code": "protected def isTerminal (hX : IsZero X) : IsTerminal X :=\n  @IsTerminal.ofUnique _ _ X fun Y => (hX.unique_from Y).some", "start": [104, 1], "end": [106, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.isoIsInitial", "code": "def isoIsInitial (hX : IsZero X) (hY : IsInitial Y) : X \u2245 Y :=\n  IsInitial.uniqueUpToIso hX.isInitial hY", "start": [109, 1], "end": [111, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.isoIsTerminal", "code": "def isoIsTerminal (hX : IsZero X) (hY : IsTerminal Y) : X \u2245 Y :=\n  IsTerminal.uniqueUpToIso hX.isTerminal hY", "start": [114, 1], "end": [116, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.of_iso", "code": "theorem of_iso (hY : IsZero Y) (e : X \u2245 Y) : IsZero X", "start": [119, 1], "end": [125, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.op", "code": "theorem op (h : IsZero X) : IsZero (Opposite.op X)", "start": [128, 1], "end": [130, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.unop", "code": "theorem unop {X : C\u1d52\u1d56} (h : IsZero X) : IsZero (Opposite.unop X)", "start": [133, 1], "end": [135, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.isZero_iff", "code": "theorem Iso.isZero_iff {X Y : C} (e : X \u2245 Y) : IsZero X \u2194 IsZero Y", "start": [144, 1], "end": [145, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.isZero", "code": "theorem Functor.isZero (F : C \u2964 D) (hF : \u2200 X, IsZero (F.obj X)) : IsZero F", "start": [148, 1], "end": [165, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject", "code": "class HasZeroObject : Prop where\n  \n  zero : \u2203 X : C, IsZero X", "start": [172, 1], "end": [175, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasZeroObject_pUnit", "code": "instance hasZeroObject_pUnit : HasZeroObject (Discrete PUnit) where zero :=\n  \u27e8\u27e8\u27e8\u27e9\u27e9,\n    { unique_to := fun \u27e8\u27e8\u27e9\u27e9 =>\n      \u27e8{ default := \ud835\udfd9 _,\n          uniq := fun _ => Subsingleton.elim _ _ }\u27e9\n      unique_from := fun \u27e8\u27e8\u27e9\u27e9 =>\n      \u27e8{ default := \ud835\udfd9 _,\n          uniq := fun _ => Subsingleton.elim _ _ }\u27e9}\u27e9", "start": [178, 1], "end": [185, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zero'", "code": "protected def HasZeroObject.zero' : Zero C where zero := HasZeroObject.zero.choose", "start": [192, 1], "end": [195, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isZero_zero", "code": "theorem isZero_zero : IsZero (0 : C)", "start": [202, 1], "end": [203, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasZeroObject_op", "code": "instance hasZeroObject_op : HasZeroObject C\u1d52\u1d56 :=\n  \u27e8\u27e8Opposite.op 0, IsZero.op (isZero_zero C)\u27e9\u27e9", "start": [206, 1], "end": [207, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasZeroObject_unop", "code": "theorem hasZeroObject_unop [HasZeroObject C\u1d52\u1d56] : HasZeroObject C", "start": [214, 1], "end": [215, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.hasZeroObject", "code": "theorem IsZero.hasZeroObject {X : C} (hX : IsZero X) : HasZeroObject C", "start": [220, 1], "end": [221, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.isoZero", "code": "def IsZero.isoZero [HasZeroObject C] {X : C} (hX : IsZero X) : X \u2245 0 :=\n  hX.iso (isZero_zero C)", "start": [224, 1], "end": [226, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.obj", "code": "theorem IsZero.obj [HasZeroObject D] {F : C \u2964 D} (hF : IsZero F) (X : C) : IsZero (F.obj X)", "start": [229, 1], "end": [233, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.uniqueTo", "code": "protected def uniqueTo (X : C) : Unique (0 \u27f6 X) :=\n  ((isZero_zero C).unique_to X).some", "start": [240, 1], "end": [242, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.uniqueFrom", "code": "protected def uniqueFrom (X : C) : Unique (X \u27f6 0) :=\n  ((isZero_zero C).unique_from X).some", "start": [245, 1], "end": [247, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.to_zero_ext", "code": "@[ext]\ntheorem to_zero_ext {X : C} (f g : X \u27f6 0) : f = g", "start": [254, 1], "end": [256, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.from_zero_ext", "code": "@[ext]\ntheorem from_zero_ext {X : C} (f g : 0 \u27f6 X) : f = g", "start": [259, 1], "end": [261, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zero_to_zero_isIso", "code": "instance zero_to_zero_isIso (f : (0 : C) \u27f6 0) : IsIso f := by\n  convert show IsIso (\ud835\udfd9 (0 : C)) by infer_instance", "start": [270, 1], "end": [271, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsInitial", "code": "def zeroIsInitial : IsInitial (0 : C) :=\n  (isZero_zero C).isInitial", "start": [274, 1], "end": [276, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsTerminal", "code": "def zeroIsTerminal : IsTerminal (0 : C) :=\n  (isZero_zero C).isTerminal", "start": [279, 1], "end": [281, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.hasInitial", "code": "instance (priority := 10) hasInitial : HasInitial C :=\n  hasInitial_of_unique 0", "start": [284, 1], "end": [286, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.hasTerminal", "code": "instance (priority := 10) hasTerminal : HasTerminal C :=\n  hasTerminal_of_unique 0", "start": [289, 1], "end": [291, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsoIsInitial", "code": "def zeroIsoIsInitial {X : C} (t : IsInitial X) : 0 \u2245 X :=\n  zeroIsInitial.uniqueUpToIso t", "start": [294, 1], "end": [296, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsoIsTerminal", "code": "def zeroIsoIsTerminal {X : C} (t : IsTerminal X) : 0 \u2245 X :=\n  zeroIsTerminal.uniqueUpToIso t", "start": [299, 1], "end": [301, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsoInitial", "code": "def zeroIsoInitial [HasInitial C] : 0 \u2245 \u22a5_ C :=\n  zeroIsInitial.uniqueUpToIso initialIsInitial", "start": [304, 1], "end": [306, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsoTerminal", "code": "def zeroIsoTerminal [HasTerminal C] : 0 \u2245 \u22a4_ C :=\n  zeroIsTerminal.uniqueUpToIso terminalIsTerminal", "start": [309, 1], "end": [311, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.initialMonoClass", "code": "instance (priority := 100) initialMonoClass : InitialMonoClass C :=\n  InitialMonoClass.of_isInitial zeroIsInitial fun X => by infer_instance", "start": [314, 1], "end": [315, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.isZero_iff", "code": "theorem Functor.isZero_iff [HasZeroObject D] (F : C \u2964 D) : IsZero F \u2194 \u2200 X, IsZero (F.obj X)", "start": [326, 1], "end": [327, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/Images.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "Mathlib/CategoryTheory/Limits/Shapes/StrongEpi.lean", "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.MonoFactorisation", "code": "structure MonoFactorisation (f : X \u27f6 Y) where\n  I : C m : I \u27f6 Y\n  [m_mono : Mono m]\n  e : X \u27f6 I\n  fac : e \u226b m = f := by aesop_cat", "start": [71, 1], "end": [77, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MonoFactorisation.self", "code": "def self [Mono f] : MonoFactorisation f where\n  I := X\n  m := f\n  e := \ud835\udfd9 X", "start": [92, 1], "end": [96, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MonoFactorisation.ext", "code": "@[ext]\ntheorem ext {F F' : MonoFactorisation f} (hI : F.I = F'.I)\n    (hm : F.m = eqToHom hI \u226b F'.m) : F = F'", "start": [105, 1], "end": [115, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MonoFactorisation.compMono", "code": "@[simps]\ndef compMono (F : MonoFactorisation f) {Y' : C} (g : Y \u27f6 Y') [Mono g] : MonoFactorisation (f \u226b g)\n    where\n  I := F.I\n  m := F.m \u226b g\n  m_mono := mono_comp _ _\n  e := F.e", "start": [118, 1], "end": [125, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MonoFactorisation.ofCompIso", "code": "@[simps]\ndef ofCompIso {Y' : C} {g : Y \u27f6 Y'} [IsIso g] (F : MonoFactorisation (f \u226b g)) : MonoFactorisation f\n    where\n  I := F.I\n  m := F.m \u226b inv g\n  m_mono := mono_comp _ _\n  e := F.e", "start": [128, 1], "end": [136, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MonoFactorisation.isoComp", "code": "@[simps]\ndef isoComp (F : MonoFactorisation f) {X' : C} (g : X' \u27f6 X) : MonoFactorisation (g \u226b f)\n    where\n  I := F.I\n  m := F.m\n  e := g \u226b F.e", "start": [139, 1], "end": [145, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MonoFactorisation.ofIsoComp", "code": "@[simps]\ndef ofIsoComp {X' : C} (g : X' \u27f6 X) [IsIso g] (F : MonoFactorisation (g \u226b f)) : MonoFactorisation f\n    where\n  I := F.I\n  m := F.m\n  e := inv g \u226b F.e", "start": [148, 1], "end": [155, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MonoFactorisation.ofArrowIso", "code": "@[simps]\ndef ofArrowIso {f g : Arrow C} (F : MonoFactorisation f.hom) (sq : f \u27f6 g) [IsIso sq] :\n    MonoFactorisation g.hom where\n  I := F.I\n  m := F.m \u226b sq.right\n  e := inv sq.left \u226b F.e\n  m_mono := mono_comp _ _\n  fac := by simp only [fac_assoc, Arrow.w, IsIso.inv_comp_eq, Category.assoc]", "start": [158, 1], "end": [167, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsImage", "code": "structure IsImage (F : MonoFactorisation f) where\n  lift : \u2200 F' : MonoFactorisation f, F.I \u27f6 F'.I\n  lift_fac : \u2200 F' : MonoFactorisation f, lift F' \u226b F'.m = F.m := by aesop_cat", "start": [174, 1], "end": [177, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsImage.fac_lift", "code": "@[reassoc (attr := simp)]\ntheorem fac_lift {F : MonoFactorisation f} (hF : IsImage F) (F' : MonoFactorisation f) :\n    F.e \u226b hF.lift F' = F'.e", "start": [187, 1], "end": [190, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsImage.self", "code": "@[simps]\ndef self [Mono f] : IsImage (MonoFactorisation.self f) where lift F' := F'.e", "start": [195, 1], "end": [197, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsImage.isoExt", "code": "@[simps]\ndef isoExt {F F' : MonoFactorisation f} (hF : IsImage F) (hF' : IsImage F') :\n    F.I \u2245 F'.I where\n  hom := hF.lift F'\n  inv := hF'.lift F\n  hom_inv_id := (cancel_mono F.m).1 (by simp)\n  inv_hom_id := (cancel_mono F'.m).1 (by simp)", "start": [206, 1], "end": [214, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsImage.isoExt_hom_m", "code": "theorem isoExt_hom_m : (isoExt hF hF').hom \u226b F'.m = F.m", "start": [219, 1], "end": [219, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsImage.isoExt_inv_m", "code": "theorem isoExt_inv_m : (isoExt hF hF').inv \u226b F.m = F'.m", "start": [222, 1], "end": [222, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsImage.e_isoExt_hom", "code": "theorem e_isoExt_hom : F.e \u226b (isoExt hF hF').hom = F'.e", "start": [225, 1], "end": [225, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsImage.e_isoExt_inv", "code": "theorem e_isoExt_inv : F'.e \u226b (isoExt hF hF').inv = F.e", "start": [228, 1], "end": [228, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsImage.ofArrowIso", "code": "@[simps]\ndef ofArrowIso {f g : Arrow C} {F : MonoFactorisation f.hom} (hF : IsImage F) (sq : f \u27f6 g)\n    [IsIso sq] : IsImage (F.ofArrowIso sq) where\n  lift F' := hF.lift (F'.ofArrowIso (inv sq))\n  lift_fac F' := by\n    simpa only [MonoFactorisation.ofArrowIso_m, Arrow.inv_right, \u2190 Category.assoc,\n      IsIso.comp_inv_eq] using hF.lift_fac (F'.ofArrowIso (inv sq))", "start": [231, 1], "end": [239, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ImageFactorisation", "code": "structure ImageFactorisation (f : X \u27f6 Y) where\n  F : MonoFactorisation f isImage : IsImage F", "start": [246, 1], "end": [249, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ImageFactorisation.ofArrowIso", "code": "@[simps]\ndef ofArrowIso {f g : Arrow C} (F : ImageFactorisation f.hom) (sq : f \u27f6 g) [IsIso sq] :\n    ImageFactorisation g.hom where\n  F := F.F.ofArrowIso sq\n  isImage := F.isImage.ofArrowIso sq", "start": [260, 1], "end": [266, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasImage", "code": "class HasImage (f : X \u27f6 Y) : Prop where mk' ::\n  exists_image : Nonempty (ImageFactorisation f)", "start": [271, 1], "end": [273, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasImage.mk", "code": "theorem HasImage.mk {f : X \u27f6 Y} (F : ImageFactorisation f) : HasImage f", "start": [278, 1], "end": [279, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasImage.of_arrow_iso", "code": "theorem HasImage.of_arrow_iso {f g : Arrow C} [h : HasImage f.hom] (sq : f \u27f6 g) [IsIso sq] :\n    HasImage g.hom", "start": [282, 1], "end": [284, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.mono_hasImage", "code": "instance (priority := 100) mono_hasImage (f : X \u27f6 Y) [Mono f] : HasImage f :=\n  HasImage.mk \u27e8_, IsImage.self f\u27e9", "start": [287, 1], "end": [288, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Image.monoFactorisation", "code": "def Image.monoFactorisation : MonoFactorisation f :=\n  (Classical.choice HasImage.exists_image).F", "start": [295, 1], "end": [297, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Image.isImage", "code": "def Image.isImage : IsImage (Image.monoFactorisation f) :=\n  (Classical.choice HasImage.exists_image).isImage", "start": [300, 1], "end": [303, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image", "code": "def image : C :=\n  (Image.monoFactorisation f).I", "start": [306, 1], "end": [308, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.\u03b9", "code": "def image.\u03b9 : image f \u27f6 Y :=\n  (Image.monoFactorisation f).m", "start": [311, 1], "end": [313, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.as_\u03b9", "code": "@[simp]\ntheorem image.as_\u03b9 : (Image.monoFactorisation f).m = image.\u03b9 f", "start": [316, 1], "end": [317, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.factorThruImage", "code": "def factorThruImage : X \u27f6 image f :=\n  (Image.monoFactorisation f).e", "start": [323, 1], "end": [325, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.as_factorThruImage", "code": "@[simp]\ntheorem as_factorThruImage : (Image.monoFactorisation f).e = factorThruImage f", "start": [328, 1], "end": [331, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.fac", "code": "@[reassoc (attr := simp)]\ntheorem image.fac : factorThruImage f \u226b image.\u03b9 f = f", "start": [334, 1], "end": [336, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.lift", "code": "def image.lift (F' : MonoFactorisation f) : image f \u27f6 F'.I :=\n  (Image.isImage f).lift F'", "start": [341, 1], "end": [344, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.lift_fac", "code": "@[reassoc (attr := simp)]\ntheorem image.lift_fac (F' : MonoFactorisation f) : image.lift F' \u226b F'.m = image.\u03b9 f", "start": [347, 1], "end": [349, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.fac_lift", "code": "@[reassoc (attr := simp)]\ntheorem image.fac_lift (F' : MonoFactorisation f) : factorThruImage f \u226b image.lift F' = F'.e", "start": [352, 1], "end": [354, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.isImage_lift", "code": "@[simp]\ntheorem image.isImage_lift (F : MonoFactorisation f) : (Image.isImage f).lift F = image.lift F", "start": [357, 1], "end": [359, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsImage.lift_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem IsImage.lift_\u03b9 {F : MonoFactorisation f} (hF : IsImage F) :\n    hF.lift (Image.monoFactorisation f) \u226b image.\u03b9 f = F.m", "start": [362, 1], "end": [365, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.lift_mono", "code": "instance image.lift_mono (F' : MonoFactorisation f) : Mono (image.lift F') := by\n  refine @mono_of_mono _ _ _ _ _ _ F'.m ?_\n  simpa using MonoFactorisation.m_mono _", "start": [373, 1], "end": [375, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasImage.uniq", "code": "theorem HasImage.uniq (F' : MonoFactorisation f) (l : image f \u27f6 F'.I) (w : l \u226b F'.m = image.\u03b9 f) :\n    l = image.lift F'", "start": [378, 1], "end": [380, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasImages", "code": "class HasImages : Prop where\n  has_image : \u2200 {X Y : C} (f : X \u27f6 Y), HasImage f", "start": [402, 1], "end": [404, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.imageMonoIsoSource", "code": "def imageMonoIsoSource [Mono f] : image f \u2245 X :=\n  IsImage.isoExt (Image.isImage f) (IsImage.self f)", "start": [415, 1], "end": [417, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.imageMonoIsoSource_inv_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem imageMonoIsoSource_inv_\u03b9 [Mono f] : (imageMonoIsoSource f).inv \u226b image.\u03b9 f = f", "start": [420, 1], "end": [422, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.imageMonoIsoSource_hom_self", "code": "@[reassoc (attr := simp)]\ntheorem imageMonoIsoSource_hom_self [Mono f] : (imageMonoIsoSource f).hom \u226b f = image.\u03b9 f", "start": [425, 1], "end": [428, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.ext", "code": "@[ext]\ntheorem image.ext [HasImage f] {W : C} {g h : image f \u27f6 W} [HasLimit (parallelPair g h)]\n    (w : factorThruImage f \u226b g = factorThruImage f \u226b h) : g = h", "start": [434, 1], "end": [459, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.epi_image_of_epi", "code": "theorem epi_image_of_epi {X Y : C} (f : X \u27f6 Y) [HasImage f] [E : Epi f] : Epi (image.\u03b9 f)", "start": [466, 1], "end": [469, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.epi_of_epi_image", "code": "theorem epi_of_epi_image {X Y : C} (f : X \u27f6 Y) [HasImage f] [Epi (image.\u03b9 f)]\n    [Epi (factorThruImage f)] : Epi f", "start": [472, 1], "end": [475, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.eqToHom", "code": "def image.eqToHom (h : f = f') : image f \u27f6 image f' :=\n  image.lift\n    { I := image f'\n      m := image.\u03b9 f'\n      e := factorThruImage f'\n      fac := by rw [h]; simp only [image.fac]}", "start": [484, 1], "end": [492, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.eqToIso", "code": "def image.eqToIso (h : f = f') : image f \u2245 image f' :=\n  asIso (image.eqToHom h)", "start": [516, 1], "end": [518, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.eq_fac", "code": "theorem image.eq_fac [HasEqualizers C] (h : f = f') :\n    image.\u03b9 f = (image.eqToIso h).hom \u226b image.\u03b9 f'", "start": [521, 1], "end": [528, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.preComp", "code": "def image.preComp [HasImage g] [HasImage (f \u226b g)] : image (f \u226b g) \u27f6 image g :=\n  image.lift\n    { I := image g\n      m := image.\u03b9 g\n      e := f \u226b factorThruImage g }", "start": [537, 1], "end": [542, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.preComp_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem image.preComp_\u03b9 [HasImage g] [HasImage (f \u226b g)] :\n    image.preComp f g \u226b image.\u03b9 g = image.\u03b9 (f \u226b g)", "start": [545, 1], "end": [549, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.factorThruImage_preComp", "code": "@[reassoc (attr := simp)]\ntheorem image.factorThruImage_preComp [HasImage g] [HasImage (f \u226b g)] :\n    factorThruImage (f \u226b g) \u226b image.preComp f g = f \u226b factorThruImage g", "start": [552, 1], "end": [554, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.preComp_mono", "code": "instance image.preComp_mono [HasImage g] [HasImage (f \u226b g)] : Mono (image.preComp f g) := by\n  refine @mono_of_mono _ _ _ _ _ _ (image.\u03b9 g) ?_\n  simp only [image.preComp_\u03b9]\n  infer_instance", "start": [557, 1], "end": [562, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.preComp_comp", "code": "theorem image.preComp_comp {W : C} (h : Z \u27f6 W) [HasImage (g \u226b h)] [HasImage (f \u226b g \u226b h)]\n    [HasImage h] [HasImage ((f \u226b g) \u226b h)] :\n    image.preComp f (g \u226b h) \u226b image.preComp g h =\n      image.eqToHom (Category.assoc f g h).symm \u226b image.preComp (f \u226b g) h", "start": [565, 1], "end": [577, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.preComp_epi_of_epi", "code": "instance image.preComp_epi_of_epi [HasImage g] [HasImage (f \u226b g)] [Epi f] :\n    Epi (image.preComp f g) := by\n  apply @epi_of_epi_fac _ _ _ _ _ _ _ _ ?_ (image.factorThruImage_preComp _ _)\n  exact epi_comp _ _", "start": [582, 1], "end": [588, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasImage_iso_comp", "code": "instance hasImage_iso_comp [IsIso f] [HasImage g] : HasImage (f \u226b g) :=\n  HasImage.mk\n    { F := (Image.monoFactorisation g).isoComp f\n      isImage := { lift := fun F' => image.lift (F'.ofIsoComp f)\n                   lift_fac := fun F' => by\n                    dsimp\n                    have : (MonoFactorisation.ofIsoComp f F').m = F'.m := rfl\n                    rw [\u2190this,image.lift_fac (MonoFactorisation.ofIsoComp f F')] } }", "start": [591, 1], "end": [598, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.isIso_precomp_iso", "code": "instance image.isIso_precomp_iso (f : X \u27f6 Y) [IsIso f] [HasImage g] : IsIso (image.preComp f g) :=\n  \u27e8\u27e8image.lift\n        { I := image (f \u226b g)\n          m := image.\u03b9 (f \u226b g)\n          e := inv f \u226b factorThruImage (f \u226b g) },\n      \u27e8by\n        ext\n        simp [image.preComp], by\n        ext\n        simp [image.preComp]\u27e9\u27e9\u27e9", "start": [601, 1], "end": [613, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasImage_comp_iso", "code": "instance hasImage_comp_iso [HasImage f] [IsIso g] : HasImage (f \u226b g) :=\n  HasImage.mk\n    { F := (Image.monoFactorisation f).compMono g\n      isImage :=\n      { lift := fun F' => image.lift F'.ofCompIso\n        lift_fac := fun F' => by\n          rw [\u2190 Category.comp_id (image.lift (MonoFactorisation.ofCompIso F') \u226b F'.m),\n            \u2190IsIso.inv_hom_id g,\u2190 Category.assoc]\n          refine congrArg (\u00b7 \u226b g) ?_\n          have : (image.lift (MonoFactorisation.ofCompIso F') \u226b F'.m) \u226b inv g =\n            image.lift (MonoFactorisation.ofCompIso F') \u226b\n            ((MonoFactorisation.ofCompIso F').m) := by\n              simp only [MonoFactorisation.ofCompIso_I, Category.assoc,\n                MonoFactorisation.ofCompIso_m]\n          rw [this, image.lift_fac (MonoFactorisation.ofCompIso F'),image.as_\u03b9] }}", "start": [618, 1], "end": [632, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.compIso", "code": "def image.compIso [HasImage f] [IsIso g] : image f \u2245 image (f \u226b g)\n    where\n  hom := image.lift (Image.monoFactorisation (f \u226b g)).ofCompIso\n  inv := image.lift ((Image.monoFactorisation f).compMono g)", "start": [635, 1], "end": [639, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.compIso_hom_comp_image_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem image.compIso_hom_comp_image_\u03b9 [HasImage f] [IsIso g] :\n    (image.compIso f g).hom \u226b image.\u03b9 (f \u226b g) = image.\u03b9 f \u226b g", "start": [642, 1], "end": [646, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.compIso_inv_comp_image_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem image.compIso_inv_comp_image_\u03b9 [HasImage f] [IsIso g] :\n    (image.compIso f g).inv \u226b image.\u03b9 f = image.\u03b9 (f \u226b g) \u226b inv g", "start": [649, 1], "end": [653, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ImageMap", "code": "structure ImageMap {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f \u27f6 g) where\n  map : image f.hom \u27f6 image g.hom\n  map_\u03b9 : map \u226b image.\u03b9 g.hom = image.\u03b9 f.hom \u226b sq.right := by aesop", "start": [673, 1], "end": [677, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inhabitedImageMap", "code": "instance inhabitedImageMap {f : Arrow C} [HasImage f.hom] : Inhabited (ImageMap (\ud835\udfd9 f)) :=\n  \u27e8\u27e8\ud835\udfd9 _, by aesop\u27e9\u27e9", "start": [686, 1], "end": [687, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ImageMap.factor_map", "code": "@[reassoc (attr := simp)]\ntheorem ImageMap.factor_map {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f \u27f6 g)\n    (m : ImageMap sq) : factorThruImage f.hom \u226b m.map = sq.left \u226b factorThruImage g.hom", "start": [692, 1], "end": [695, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ImageMap.transport", "code": "def ImageMap.transport {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f \u27f6 g)\n    (F : MonoFactorisation f.hom) {F' : MonoFactorisation g.hom} (hF' : IsImage F')\n    {map : F.I \u27f6 F'.I} (map_\u03b9 : map \u226b F'.m = F.m \u226b sq.right) : ImageMap sq where\n  map := image.lift F \u226b map \u226b hF'.lift (Image.monoFactorisation g.hom)\n  map_\u03b9 := by simp [map_\u03b9]", "start": [698, 1], "end": [705, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasImageMap", "code": "class HasImageMap {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f \u27f6 g) : Prop where\nmk' ::\n  has_image_map : Nonempty (ImageMap sq)", "start": [708, 1], "end": [711, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasImageMap.mk", "code": "theorem HasImageMap.mk {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] {sq : f \u27f6 g}\n    (m : ImageMap sq) : HasImageMap sq", "start": [716, 1], "end": [718, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasImageMap.transport", "code": "theorem HasImageMap.transport {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f \u27f6 g)\n    (F : MonoFactorisation f.hom) {F' : MonoFactorisation g.hom} (hF' : IsImage F')\n    (map : F.I \u27f6 F'.I) (map_\u03b9 : map \u226b F'.m = F.m \u226b sq.right) : HasImageMap sq", "start": [721, 1], "end": [724, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasImageMap.imageMap", "code": "def HasImageMap.imageMap {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] (sq : f \u27f6 g)\n    [HasImageMap sq] : ImageMap sq :=\n  Classical.choice <| @HasImageMap.has_image_map _ _ _ _ _ _ sq _", "start": [727, 1], "end": [730, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasImageMapOfIsIso", "code": "instance (priority := 100) hasImageMapOfIsIso {f g : Arrow C} [HasImage f.hom] [HasImage g.hom]\n    (sq : f \u27f6 g) [IsIso sq] : HasImageMap sq :=\n  HasImageMap.mk\n    { map := image.lift ((Image.monoFactorisation g.hom).ofArrowIso (inv sq))\n      map_\u03b9 := by\n        erw [\u2190 cancel_mono (inv sq).right, Category.assoc, \u2190 MonoFactorisation.ofArrowIso_m,\n          image.lift_fac, Category.assoc, \u2190 Comma.comp_right, IsIso.hom_inv_id, Comma.id_right,\n          Category.comp_id] }", "start": [734, 1], "end": [741, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasImageMap.comp", "code": "instance HasImageMap.comp {f g h : Arrow C} [HasImage f.hom] [HasImage g.hom] [HasImage h.hom]\n    (sq1 : f \u27f6 g) (sq2 : g \u27f6 h) [HasImageMap sq1] [HasImageMap sq2] : HasImageMap (sq1 \u226b sq2) :=\n  HasImageMap.mk\n    { map := (HasImageMap.imageMap sq1).map \u226b (HasImageMap.imageMap sq2).map\n      map_\u03b9 := by\n        rw [Category.assoc,ImageMap.map_\u03b9, ImageMap.map_\u03b9_assoc, Comma.comp_right] }", "start": [744, 1], "end": [749, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ImageMap.map_uniq_aux", "code": "theorem ImageMap.map_uniq_aux {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] {sq : f \u27f6 g}\n    (map : image f.hom \u27f6 image g.hom)\n    (map_\u03b9 : map \u226b image.\u03b9 g.hom = image.\u03b9 f.hom \u226b sq.right := by aesop_cat)\n    (map' : image f.hom \u27f6 image g.hom)\n    (map_\u03b9' : map' \u226b image.\u03b9 g.hom = image.\u03b9 f.hom \u226b sq.right) : (map = map')", "start": [760, 1], "end": [766, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ImageMap.map_uniq", "code": "theorem ImageMap.map_uniq {f g : Arrow C} [HasImage f.hom] [HasImage g.hom]\n    {sq : f \u27f6 g} (F G : ImageMap sq) : F.map = G.map", "start": [769, 1], "end": [771, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ImageMap.mk.injEq'", "code": "@[simp]\ntheorem ImageMap.mk.injEq' {f g : Arrow C} [HasImage f.hom] [HasImage g.hom] {sq : f \u27f6 g}\n    (map : image f.hom \u27f6 image g.hom)\n    (map_\u03b9 : map \u226b image.\u03b9 g.hom = image.\u03b9 f.hom \u226b sq.right := by aesop_cat)\n    (map' : image f.hom \u27f6 image g.hom)\n    (map_\u03b9' : map' \u226b image.\u03b9 g.hom = image.\u03b9 f.hom \u226b sq.right) : (map = map') = True", "start": [773, 1], "end": [780, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.map", "code": "abbrev image.map : image f.hom \u27f6 image g.hom :=\n  (HasImageMap.imageMap sq).map", "start": [790, 1], "end": [792, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.factor_map", "code": "theorem image.factor_map : factorThruImage f.hom \u226b image.map sq = sq.left \u226b factorThruImage g.hom", "start": [795, 1], "end": [796, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.map_\u03b9", "code": "theorem image.map_\u03b9 : image.map sq \u226b image.\u03b9 g.hom = image.\u03b9 f.hom \u226b sq.right", "start": [799, 1], "end": [799, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.map_homMk'_\u03b9", "code": "theorem image.map_homMk'_\u03b9 {X Y P Q : C} {k : X \u27f6 Y} [HasImage k] {l : P \u27f6 Q} [HasImage l]\n    {m : X \u27f6 P} {n : Y \u27f6 Q} (w : m \u226b l = k \u226b n) [HasImageMap (Arrow.homMk' w)] :\n    image.map (Arrow.homMk' w) \u226b image.\u03b9 l = image.\u03b9 k \u226b n", "start": [802, 1], "end": [805, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.imageMapComp", "code": "def imageMapComp : ImageMap (sq \u226b sq') where map := image.map sq \u226b image.map sq'", "start": [814, 1], "end": [815, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.map_comp", "code": "@[simp]\ntheorem image.map_comp [HasImageMap (sq \u226b sq')] :\n    image.map (sq \u226b sq') = image.map sq \u226b image.map sq'", "start": [818, 1], "end": [822, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.imageMapId", "code": "def imageMapId : ImageMap (\ud835\udfd9 f) where map := \ud835\udfd9 (image f.hom)", "start": [831, 1], "end": [833, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.map_id", "code": "@[simp]\ntheorem image.map_id [HasImageMap (\ud835\udfd9 f)] : image.map (\ud835\udfd9 f) = \ud835\udfd9 (image f.hom)", "start": [836, 1], "end": [839, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasImageMaps", "code": "class HasImageMaps : Prop where\n  has_image_map : \u2200 {f g : Arrow C} (st : f \u27f6 g), HasImageMap st", "start": [850, 1], "end": [852, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.im", "code": "@[simps]\ndef im : Arrow C \u2964 C where\n  obj f := image f.hom\n  map st := image.map st", "start": [863, 1], "end": [868, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.StrongEpiMonoFactorisation", "code": "structure StrongEpiMonoFactorisation {X Y : C} (f : X \u27f6 Y) extends MonoFactorisation f where\n  [e_strong_epi : StrongEpi e]", "start": [875, 1], "end": [878, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.strongEpiMonoFactorisationInhabited", "code": "instance strongEpiMonoFactorisationInhabited {X Y : C} (f : X \u27f6 Y) [StrongEpi f] :\n    Inhabited (StrongEpiMonoFactorisation f) :=\n  \u27e8\u27e8\u27e8Y, \ud835\udfd9 Y, f, by simp\u27e9\u27e9\u27e9", "start": [885, 1], "end": [888, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.StrongEpiMonoFactorisation.toMonoIsImage", "code": "def StrongEpiMonoFactorisation.toMonoIsImage {X Y : C} {f : X \u27f6 Y}\n    (F : StrongEpiMonoFactorisation f) : IsImage F.toMonoFactorisation where\n  lift G :=\n    (CommSq.mk (show G.e \u226b G.m = F.e \u226b F.m by rw [F.toMonoFactorisation.fac, G.fac])).lift", "start": [891, 1], "end": [896, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasStrongEpiMonoFactorisations", "code": "class HasStrongEpiMonoFactorisations : Prop where mk' ::\n  has_fac : \u2200 {X Y : C} (f : X \u27f6 Y), Nonempty (StrongEpiMonoFactorisation f)", "start": [901, 1], "end": [904, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasStrongEpiMonoFactorisations.mk", "code": "theorem HasStrongEpiMonoFactorisations.mk\n    (d : \u2200 {X Y : C} (f : X \u27f6 Y), StrongEpiMonoFactorisation f) :\n    HasStrongEpiMonoFactorisations C", "start": [911, 1], "end": [914, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasImages_of_hasStrongEpiMonoFactorisations", "code": "instance (priority := 100) hasImages_of_hasStrongEpiMonoFactorisations\n    [HasStrongEpiMonoFactorisations C] : HasImages C where\n  has_image f :=\n    let F' := Classical.choice (HasStrongEpiMonoFactorisations.has_fac f)\n    HasImage.mk\n      { F := F'.toMonoFactorisation\n        isImage := F'.toMonoIsImage }", "start": [917, 1], "end": [923, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasStrongEpiImages", "code": "class HasStrongEpiImages : Prop where\n  strong_factorThruImage : \u2200 {X Y : C} (f : X \u27f6 Y), StrongEpi (factorThruImage f)", "start": [932, 1], "end": [935, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.strongEpi_of_strongEpiMonoFactorisation", "code": "theorem strongEpi_of_strongEpiMonoFactorisation {X Y : C} {f : X \u27f6 Y}\n    (F : StrongEpiMonoFactorisation f) {F' : MonoFactorisation f} (hF' : IsImage F') :\n    StrongEpi F'.e", "start": [945, 1], "end": [951, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.strongEpi_factorThruImage_of_strongEpiMonoFactorisation", "code": "theorem strongEpi_factorThruImage_of_strongEpiMonoFactorisation {X Y : C} {f : X \u27f6 Y} [HasImage f]\n    (F : StrongEpiMonoFactorisation f) : StrongEpi (factorThruImage f)", "start": [954, 1], "end": [956, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasStrongEpiImages_of_hasStrongEpiMonoFactorisations", "code": "instance (priority := 100) hasStrongEpiImages_of_hasStrongEpiMonoFactorisations\n    [HasStrongEpiMonoFactorisations C] : HasStrongEpiImages C where\n  strong_factorThruImage f :=\n    strongEpi_factorThruImage_of_strongEpiMonoFactorisation <|\n      Classical.choice <| HasStrongEpiMonoFactorisations.has_fac f", "start": [959, 1], "end": [965, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasImageMapsOfHasStrongEpiImages", "code": "instance (priority := 100) hasImageMapsOfHasStrongEpiImages [HasStrongEpiImages C] : HasImageMaps C\n    where\n  has_image_map {f} {g} st :=\n    HasImageMap.mk\n      { map :=\n          (CommSq.mk\n              (show\n                (st.left \u226b factorThruImage g.hom) \u226b image.\u03b9 g.hom =\n                  factorThruImage f.hom \u226b image.\u03b9 f.hom \u226b st.right\n                by simp)).lift }", "start": [974, 1], "end": [984, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasStrongEpiImages_of_hasPullbacks_of_hasEqualizers", "code": "instance (priority := 100) hasStrongEpiImages_of_hasPullbacks_of_hasEqualizers [HasPullbacks C]\n    [HasEqualizers C] : HasStrongEpiImages C where\n  strong_factorThruImage f :=\n    StrongEpi.mk' fun {A} {B} h h_mono x y sq =>\n      CommSq.HasLift.mk'\n        { l :=\n            image.lift\n                { I := pullback h y\n                  m := pullback.snd \u226b image.\u03b9 f\n                  m_mono := mono_comp _ _\n                  e := pullback.lift _ _ sq.w } \u226b\n              pullback.fst\n          fac_left := by simp only [image.fac_lift_assoc, pullback.lift_fst]\n          fac_right := by\n            apply image.ext\n            simp only [sq.w, Category.assoc, image.fac_lift_assoc, pullback.lift_fst_assoc] }", "start": [987, 1], "end": [1004, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.isoStrongEpiMono", "code": "def image.isoStrongEpiMono {I' : C} (e : X \u27f6 I') (m : I' \u27f6 Y) (comm : e \u226b m = f) [StrongEpi e]\n    [Mono m] : I' \u2245 image f :=\n  let F : StrongEpiMonoFactorisation f := { I := I', m := m, e := e}\n  IsImage.isoExt F.toMonoIsImage <| Image.isImage f", "start": [1013, 1], "end": [1021, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.isoStrongEpiMono_hom_comp_\u03b9", "code": "@[simp]\ntheorem image.isoStrongEpiMono_hom_comp_\u03b9 {I' : C} (e : X \u27f6 I') (m : I' \u27f6 Y) (comm : e \u226b m = f)\n    [StrongEpi e] [Mono m] : (image.isoStrongEpiMono e m comm).hom \u226b image.\u03b9 f = m", "start": [1024, 1], "end": [1028, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.isoStrongEpiMono_inv_comp_mono", "code": "@[simp]\ntheorem image.isoStrongEpiMono_inv_comp_mono {I' : C} (e : X \u27f6 I') (m : I' \u27f6 Y) (comm : e \u226b m = f)\n    [StrongEpi e] [Mono m] : (image.isoStrongEpiMono e m comm).inv \u226b m = image.\u03b9 f", "start": [1031, 1], "end": [1034, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.hasStrongEpiMonoFactorisations_imp_of_isEquivalence", "code": "theorem hasStrongEpiMonoFactorisations_imp_of_isEquivalence (F : C \u2964 D) [IsEquivalence F]\n    [h : HasStrongEpiMonoFactorisations C] : HasStrongEpiMonoFactorisations D", "start": [1045, 1], "end": [1059, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/Equivalence.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "Mathlib/CategoryTheory/Adjunction/Limits.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.hasInitial_of_equivalence", "code": "theorem hasInitial_of_equivalence (e : D \u2964 C) [IsEquivalence e] [HasInitial C] : HasInitial D", "start": [27, 1], "end": [28, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.hasInitial_iff", "code": "theorem Equivalence.hasInitial_iff (e : C \u224c D) : HasInitial C \u2194 HasInitial D", "start": [31, 1], "end": [33, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hasTerminal_of_equivalence", "code": "theorem hasTerminal_of_equivalence (e : D \u2964 C) [IsEquivalence e] [HasTerminal C] : HasTerminal D", "start": [36, 1], "end": [37, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.hasTerminal_iff", "code": "theorem Equivalence.hasTerminal_iff (e : C \u224c D) : HasTerminal C \u2194 HasTerminal D", "start": [40, 1], "end": [42, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Terminal.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "Mathlib/CategoryTheory/Limits/Preserves/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.isLimitMapConeEmptyConeEquiv", "code": "def isLimitMapConeEmptyConeEquiv :\n    IsLimit (G.mapCone (asEmptyCone X)) \u2243 IsTerminal (G.obj X) :=\n  isLimitEmptyConeEquiv D _ _ (eqToIso rfl)", "start": [40, 1], "end": [44, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal.isTerminalObj", "code": "def IsTerminal.isTerminalObj [PreservesLimit (Functor.empty.{0} C) G] (l : IsTerminal X) :\n    IsTerminal (G.obj X) :=\n  isLimitMapConeEmptyConeEquiv G X (PreservesLimit.preserves l)", "start": [47, 1], "end": [50, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal.isTerminalOfObj", "code": "def IsTerminal.isTerminalOfObj [ReflectsLimit (Functor.empty.{0} C) G] (l : IsTerminal (G.obj X)) :\n    IsTerminal X :=\n  ReflectsLimit.reflects ((isLimitMapConeEmptyConeEquiv G X).symm l)", "start": [53, 1], "end": [56, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOfShapePemptyOfPreservesTerminal", "code": "def preservesLimitsOfShapePemptyOfPreservesTerminal [PreservesLimit (Functor.empty.{0} C) G] :\n    PreservesLimitsOfShape (Discrete PEmpty) G where\n  preservesLimit :=\n    preservesLimitOfIsoDiagram G (Functor.emptyExt (Functor.empty.{0} C) _)", "start": [59, 1], "end": [63, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitOfHasTerminalOfPreservesLimit", "code": "def isLimitOfHasTerminalOfPreservesLimit [PreservesLimit (Functor.empty.{0} C) G] :\n    IsTerminal (G.obj (\u22a4_ C)) :=\n  terminalIsTerminal.isTerminalObj G (\u22a4_ C)", "start": [68, 1], "end": [74, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasTerminal_of_hasTerminal_of_preservesLimit", "code": "theorem hasTerminal_of_hasTerminal_of_preservesLimit [PreservesLimit (Functor.empty.{0} C) G] :\n    HasTerminal D", "start": [77, 1], "end": [86, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesTerminal.ofIsoComparison", "code": "def PreservesTerminal.ofIsoComparison [i : IsIso (terminalComparison G)] :\n    PreservesLimit (Functor.empty C) G := by\n  apply preservesLimitOfPreservesLimitCone terminalIsTerminal\n  apply (isLimitMapConeEmptyConeEquiv _ _).symm _\n  exact @IsLimit.ofPointIso _ _ _ _ _ _ _ (limit.isLimit (Functor.empty.{0} D)) i", "start": [91, 1], "end": [97, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesTerminalOfIsIso", "code": "def preservesTerminalOfIsIso (f : G.obj (\u22a4_ C) \u27f6 \u22a4_ D) [i : IsIso f] :\n    PreservesLimit (Functor.empty C) G := by\n  rw [Subsingleton.elim f (terminalComparison G)] at i\n  exact PreservesTerminal.ofIsoComparison G", "start": [100, 1], "end": [104, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesTerminalOfIso", "code": "def preservesTerminalOfIso (f : G.obj (\u22a4_ C) \u2245 \u22a4_ D) : PreservesLimit (Functor.empty C) G :=\n  preservesTerminalOfIsIso G f.hom", "start": [107, 1], "end": [109, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesTerminal.iso", "code": "def PreservesTerminal.iso : G.obj (\u22a4_ C) \u2245 \u22a4_ D :=\n  (isLimitOfHasTerminalOfPreservesLimit G).conePointUniqueUpToIso (limit.isLimit _)", "start": [114, 1], "end": [117, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesTerminal.iso_hom", "code": "@[simp]\ntheorem PreservesTerminal.iso_hom : (PreservesTerminal.iso G).hom = terminalComparison G", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitMapCoconeEmptyCoconeEquiv", "code": "def isColimitMapCoconeEmptyCoconeEquiv :\n    IsColimit (G.mapCocone (asEmptyCocone.{v\u2081} X)) \u2243 IsInitial (G.obj X) :=\n  isColimitEmptyCoconeEquiv D _ _ (eqToIso rfl)", "start": [133, 1], "end": [137, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.isInitialObj", "code": "def IsInitial.isInitialObj [PreservesColimit (Functor.empty.{0} C) G] (l : IsInitial X) :\n    IsInitial (G.obj X) :=\n  isColimitMapCoconeEmptyCoconeEquiv G X (PreservesColimit.preserves l)", "start": [140, 1], "end": [143, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.isInitialOfObj", "code": "def IsInitial.isInitialOfObj [ReflectsColimit (Functor.empty.{0} C) G] (l : IsInitial (G.obj X)) :\n    IsInitial X :=\n  ReflectsColimit.reflects ((isColimitMapCoconeEmptyCoconeEquiv G X).symm l)", "start": [146, 1], "end": [149, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsOfShapePemptyOfPreservesInitial", "code": "def preservesColimitsOfShapePemptyOfPreservesInitial [PreservesColimit (Functor.empty.{0} C) G] :\n    PreservesColimitsOfShape (Discrete PEmpty) G where\n  preservesColimit :=\n    preservesColimitOfIsoDiagram G (Functor.emptyExt (Functor.empty.{0} C) _)", "start": [152, 1], "end": [156, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitOfHasInitialOfPreservesColimit", "code": "def isColimitOfHasInitialOfPreservesColimit [PreservesColimit (Functor.empty.{0} C) G] :\n    IsInitial (G.obj (\u22a5_ C)) :=\n  initialIsInitial.isInitialObj G (\u22a5_ C)", "start": [161, 1], "end": [166, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasInitial_of_hasInitial_of_preservesColimit", "code": "theorem hasInitial_of_hasInitial_of_preservesColimit [PreservesColimit (Functor.empty.{0} C) G] :\n    HasInitial D", "start": [169, 1], "end": [179, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesInitial.ofIsoComparison", "code": "def PreservesInitial.ofIsoComparison [i : IsIso (initialComparison G)] :\n    PreservesColimit (Functor.empty C) G := by\n  apply preservesColimitOfPreservesColimitCocone initialIsInitial\n  apply (isColimitMapCoconeEmptyCoconeEquiv _ _).symm _\n  exact @IsColimit.ofPointIso _ _ _ _ _ _ _ (colimit.isColimit (Functor.empty.{0} D)) i", "start": [184, 1], "end": [190, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesInitialOfIsIso", "code": "def preservesInitialOfIsIso (f : \u22a5_ D \u27f6 G.obj (\u22a5_ C)) [i : IsIso f] :\n    PreservesColimit (Functor.empty C) G := by\n  rw [Subsingleton.elim f (initialComparison G)] at i\n  exact PreservesInitial.ofIsoComparison G", "start": [193, 1], "end": [197, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesInitialOfIso", "code": "def preservesInitialOfIso (f : \u22a5_ D \u2245 G.obj (\u22a5_ C)) : PreservesColimit (Functor.empty C) G :=\n  preservesInitialOfIsIso G f.hom", "start": [200, 1], "end": [202, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesInitial.iso", "code": "def PreservesInitial.iso : G.obj (\u22a5_ C) \u2245 \u22a5_ D :=\n  (isColimitOfHasInitialOfPreservesColimit G).coconePointUniqueUpToIso (colimit.isColimit _)", "start": [207, 1], "end": [209, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesInitial.iso_hom", "code": "@[simp]\ntheorem PreservesInitial.iso_hom : (PreservesInitial.iso G).inv = initialComparison G", "start": [212, 1], "end": [214, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Adjunction/Comma.lean", "imports": ["Mathlib/CategoryTheory/PUnit.lean", "Mathlib/CategoryTheory/StructuredArrow.lean", "Mathlib/CategoryTheory/Adjunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.leftAdjointOfStructuredArrowInitialsAux", "code": "@[simps]\ndef leftAdjointOfStructuredArrowInitialsAux (A : C) (B : D) :\n    ((\u22a5_ StructuredArrow A G).right \u27f6 B) \u2243 (A \u27f6 G.obj B)\n    where\n  toFun g := (\u22a5_ StructuredArrow A G).hom \u226b G.map g\n  invFun f := CommaMorphism.right (initial.to (StructuredArrow.mk f))\n  left_inv g := by\n    let B' : StructuredArrow A G := StructuredArrow.mk ((\u22a5_ StructuredArrow A G).hom \u226b G.map g)\n    let g' : \u22a5_ StructuredArrow A G \u27f6 B' := StructuredArrow.homMk g rfl\n    have : initial.to _ = g' := by aesop_cat\n    change CommaMorphism.right (initial.to B') = _\n    rw [this]\n    rfl\n  right_inv f := by\n    let B' : StructuredArrow A G := StructuredArrow.mk f\n    apply (CommaMorphism.w (initial.to B')).symm.trans (Category.id_comp _)", "start": [40, 1], "end": [58, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.leftAdjointOfStructuredArrowInitials", "code": "def leftAdjointOfStructuredArrowInitials : C \u2964 D :=\n  Adjunction.leftAdjointOfEquiv (leftAdjointOfStructuredArrowInitialsAux G) fun _ _ => by simp", "start": [61, 1], "end": [66, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.adjunctionOfStructuredArrowInitials", "code": "def adjunctionOfStructuredArrowInitials : leftAdjointOfStructuredArrowInitials G \u22a3 G :=\n  Adjunction.adjunctionOfEquivLeft _ _", "start": [69, 1], "end": [74, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isRightAdjointOfStructuredArrowInitials", "code": "def isRightAdjointOfStructuredArrowInitials : IsRightAdjoint G\n    where\n  left := _\n  adj := adjunctionOfStructuredArrowInitials G", "start": [77, 1], "end": [81, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rightAdjointOfCostructuredArrowTerminalsAux", "code": "@[simps]\ndef rightAdjointOfCostructuredArrowTerminalsAux (B : D) (A : C) :\n    (G.obj B \u27f6 A) \u2243 (B \u27f6 (\u22a4_ CostructuredArrow G A).left)\n    where\n  toFun g := CommaMorphism.left (terminal.from (CostructuredArrow.mk g))\n  invFun g := G.map g \u226b (\u22a4_ CostructuredArrow G A).hom\n  left_inv := by aesop_cat\n  right_inv g := by\n    let B' : CostructuredArrow G A :=\n      CostructuredArrow.mk (G.map g \u226b (\u22a4_ CostructuredArrow G A).hom)\n    let g' : B' \u27f6 \u22a4_ CostructuredArrow G A := CostructuredArrow.homMk g rfl\n    have : terminal.from _ = g' := by aesop_cat\n    change CommaMorphism.left (terminal.from B') = _\n    rw [this]\n    rfl", "start": [90, 1], "end": [107, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rightAdjointOfCostructuredArrowTerminals", "code": "def rightAdjointOfCostructuredArrowTerminals : C \u2964 D :=\n  Adjunction.rightAdjointOfEquiv (rightAdjointOfCostructuredArrowTerminalsAux G)\n      fun B\u2081 B\u2082 A f g => by\n    rw [\u2190 Equiv.eq_symm_apply]\n    simp", "start": [110, 1], "end": [118, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.adjunctionOfCostructuredArrowTerminals", "code": "def adjunctionOfCostructuredArrowTerminals : G \u22a3 rightAdjointOfCostructuredArrowTerminals G :=\n  Adjunction.adjunctionOfEquivRight _ _", "start": [121, 1], "end": [125, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isLeftAdjointOfCostructuredArrowTerminals", "code": "def isLeftAdjointOfCostructuredArrowTerminals : IsLeftAdjoint G\n    where\n  right := rightAdjointOfCostructuredArrowTerminals G\n  adj := Adjunction.adjunctionOfEquivRight _ _", "start": [128, 1], "end": [132, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mkInitialOfLeftAdjoint", "code": "def mkInitialOfLeftAdjoint (h : F \u22a3 G) (A : C) :\n    IsInitial (StructuredArrow.mk (h.unit.app A) : StructuredArrow A G)\n    where\n  desc B := StructuredArrow.homMk ((h.homEquiv _ _).symm B.pt.hom)\n  uniq s m _ := by\n    apply StructuredArrow.ext\n    dsimp\n    erw [Equiv.eq_symm_apply, Adjunction.homEquiv_unit]\n    apply StructuredArrow.w m", "start": [141, 1], "end": [152, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mkTerminalOfRightAdjoint", "code": "def mkTerminalOfRightAdjoint (h : F \u22a3 G) (A : D) :\n    IsTerminal (CostructuredArrow.mk (h.counit.app A) : CostructuredArrow F A)\n    where\n  lift B := CostructuredArrow.homMk (h.homEquiv _ _ B.pt.hom)\n  uniq s m _ := by\n    apply CostructuredArrow.ext\n    dsimp\n    rw [h.eq_homEquiv_apply, Adjunction.homEquiv_counit]\n    exact CostructuredArrow.w m", "start": [155, 1], "end": [165, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.nonempty_isRightAdjoint_iff_hasInitial_structuredArrow", "code": "theorem nonempty_isRightAdjoint_iff_hasInitial_structuredArrow {G : D \u2964 C} :\n    Nonempty (IsRightAdjoint G) \u2194 \u2200 A, HasInitial (StructuredArrow A G)", "start": [170, 1], "end": [173, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.nonempty_isLeftAdjoint_iff_hasTerminal_costructuredArrow", "code": "theorem nonempty_isLeftAdjoint_iff_hasTerminal_costructuredArrow {F : C \u2964 D} :\n    Nonempty (IsLeftAdjoint F) \u2194 \u2200 A, HasTerminal (CostructuredArrow F A)", "start": [176, 1], "end": [179, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Conj.lean", "imports": ["Mathlib/Algebra/Hom/Equiv/Units/Basic.lean", "Mathlib/CategoryTheory/Endomorphism.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Iso.homCongr", "code": "def homCongr {X Y X\u2081 Y\u2081 : C} (\u03b1 : X \u2245 X\u2081) (\u03b2 : Y \u2245 Y\u2081) : (X \u27f6 Y) \u2243 (X\u2081 \u27f6 Y\u2081) where\n  toFun f := \u03b1.inv \u226b f \u226b \u03b2.hom\n  invFun f := \u03b1.hom \u226b f \u226b \u03b2.inv\n  left_inv f :=\n    show \u03b1.hom \u226b (\u03b1.inv \u226b f \u226b \u03b2.hom) \u226b \u03b2.inv = f by\n      rw [Category.assoc, Category.assoc, \u03b2.hom_inv_id, \u03b1.hom_inv_id_assoc, Category.comp_id]\n  right_inv f :=\n    show \u03b1.inv \u226b (\u03b1.hom \u226b f \u226b \u03b2.inv) \u226b \u03b2.hom = f by\n      rw [Category.assoc, Category.assoc, \u03b2.inv_hom_id, \u03b1.inv_hom_id_assoc, Category.comp_id]", "start": [34, 1], "end": [44, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.homCongr_apply", "code": "@[simp]\ntheorem homCongr_apply {X Y X\u2081 Y\u2081 : C} (\u03b1 : X \u2245 X\u2081) (\u03b2 : Y \u2245 Y\u2081) (f : X \u27f6 Y) :\n    \u03b1.homCongr \u03b2 f = \u03b1.inv \u226b f \u226b \u03b2.hom", "start": [48, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.homCongr_comp", "code": "theorem homCongr_comp {X Y Z X\u2081 Y\u2081 Z\u2081 : C} (\u03b1 : X \u2245 X\u2081) (\u03b2 : Y \u2245 Y\u2081) (\u03b3 : Z \u2245 Z\u2081) (f : X \u27f6 Y)\n    (g : Y \u27f6 Z) : \u03b1.homCongr \u03b3 (f \u226b g) = \u03b1.homCongr \u03b2 f \u226b \u03b2.homCongr \u03b3 g", "start": [54, 1], "end": [55, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.homCongr_refl", "code": "theorem homCongr_refl {X Y : C} (f : X \u27f6 Y) : (Iso.refl X).homCongr (Iso.refl Y) f = f", "start": [59, 1], "end": [59, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.homCongr_trans", "code": "theorem homCongr_trans {X\u2081 Y\u2081 X\u2082 Y\u2082 X\u2083 Y\u2083 : C} (\u03b1\u2081 : X\u2081 \u2245 X\u2082) (\u03b2\u2081 : Y\u2081 \u2245 Y\u2082) (\u03b1\u2082 : X\u2082 \u2245 X\u2083)\n    (\u03b2\u2082 : Y\u2082 \u2245 Y\u2083) (f : X\u2081 \u27f6 Y\u2081) :\n    (\u03b1\u2081 \u226a\u226b \u03b1\u2082).homCongr (\u03b2\u2081 \u226a\u226b \u03b2\u2082) f = (\u03b1\u2081.homCongr \u03b2\u2081).trans (\u03b1\u2082.homCongr \u03b2\u2082) f", "start": [63, 1], "end": [65, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.homCongr_symm", "code": "@[simp]\ntheorem homCongr_symm {X\u2081 Y\u2081 X\u2082 Y\u2082 : C} (\u03b1 : X\u2081 \u2245 X\u2082) (\u03b2 : Y\u2081 \u2245 Y\u2082) :\n    (\u03b1.homCongr \u03b2).symm = \u03b1.symm.homCongr \u03b2.symm", "start": [68, 1], "end": [71, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.conj", "code": "def conj : End X \u2243* End Y :=\n  { homCongr \u03b1 \u03b1 with map_mul' := fun f g => homCongr_comp \u03b1 \u03b1 \u03b1 g f }", "start": [76, 1], "end": [79, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.conj_apply", "code": "theorem conj_apply (f : End X) : \u03b1.conj f = \u03b1.inv \u226b f \u226b \u03b1.hom", "start": [82, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.conj_comp", "code": "@[simp]\ntheorem conj_comp (f g : End X) : \u03b1.conj (f \u226b g) = \u03b1.conj f \u226b \u03b1.conj g", "start": [86, 1], "end": [88, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.conj_id", "code": "@[simp]\ntheorem conj_id : \u03b1.conj (\ud835\udfd9 X) = \ud835\udfd9 Y", "start": [91, 1], "end": [93, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.refl_conj", "code": "@[simp]\ntheorem refl_conj (f : End X) : (Iso.refl X).conj f = f", "start": [96, 1], "end": [98, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.trans_conj", "code": "@[simp]\ntheorem trans_conj {Z : C} (\u03b2 : Y \u2245 Z) (f : End X) : (\u03b1 \u226a\u226b \u03b2).conj f = \u03b2.conj (\u03b1.conj f)", "start": [101, 1], "end": [103, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.symm_self_conj", "code": "@[simp]\ntheorem symm_self_conj (f : End X) : \u03b1.symm.conj (\u03b1.conj f) = f", "start": [106, 1], "end": [108, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.self_symm_conj", "code": "@[simp]\ntheorem self_symm_conj (f : End Y) : \u03b1.conj (\u03b1.symm.conj f) = f", "start": [111, 1], "end": [113, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.conj_pow", "code": "theorem conj_pow (f : End X) (n : \u2115) : \u03b1.conj (f ^ n) = \u03b1.conj f ^ n", "start": [117, 1], "end": [118, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.conjAut", "code": "def conjAut : Aut X \u2243* Aut Y :=\n  (Aut.unitsEndEquivAut X).symm.trans <| (Units.mapEquiv \u03b1.conj).trans <| Aut.unitsEndEquivAut Y", "start": [122, 1], "end": [124, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.conjAut_apply", "code": "theorem conjAut_apply (f : Aut X) : \u03b1.conjAut f = \u03b1.symm \u226a\u226b f \u226a\u226b \u03b1", "start": [128, 1], "end": [128, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.conjAut_hom", "code": "@[simp]\ntheorem conjAut_hom (f : Aut X) : (\u03b1.conjAut f).hom = \u03b1.conj f.hom", "start": [132, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.trans_conjAut", "code": "@[simp]\ntheorem trans_conjAut {Z : C} (\u03b2 : Y \u2245 Z) (f : Aut X) :\n    (\u03b1 \u226a\u226b \u03b2).conjAut f = \u03b2.conjAut (\u03b1.conjAut f)", "start": [138, 1], "end": [141, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.conjAut_mul", "code": "theorem conjAut_mul (f g : Aut X) : \u03b1.conjAut (f * g) = \u03b1.conjAut f * \u03b1.conjAut g", "start": [146, 1], "end": [147, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.conjAut_trans", "code": "@[simp]\ntheorem conjAut_trans (f g : Aut X) : \u03b1.conjAut (f \u226a\u226b g) = \u03b1.conjAut f \u226a\u226b \u03b1.conjAut g", "start": [151, 1], "end": [153, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.conjAut_pow", "code": "theorem conjAut_pow (f : Aut X) (n : \u2115) : \u03b1.conjAut (f ^ n) = \u03b1.conjAut f ^ n", "start": [158, 1], "end": [159, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.conjAut_zpow", "code": "theorem conjAut_zpow (f : Aut X) (n : \u2124) : \u03b1.conjAut (f ^ n) = \u03b1.conjAut f ^ n", "start": [164, 1], "end": [165, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_homCongr", "code": "theorem map_homCongr {X Y X\u2081 Y\u2081 : C} (\u03b1 : X \u2245 X\u2081) (\u03b2 : Y \u2245 Y\u2081) (f : X \u27f6 Y) :\n    F.map (Iso.homCongr \u03b1 \u03b2 f) = Iso.homCongr (F.mapIso \u03b1) (F.mapIso \u03b2) (F.map f)", "start": [177, 1], "end": [178, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_conj", "code": "theorem map_conj {X Y : C} (\u03b1 : X \u2245 Y) (f : End X) :\n    F.map (\u03b1.conj f) = (F.mapIso \u03b1).conj (F.map f)", "start": [181, 1], "end": [183, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_conjAut", "code": "theorem map_conjAut (F : C \u2964 D) {X Y : C} (\u03b1 : X \u2245 Y) (f : Aut X) :\n    F.mapIso (\u03b1.conjAut f) = (F.mapIso \u03b1).conjAut (F.mapIso f)", "start": [186, 1], "end": [188, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Unit.lean", "imports": ["Mathlib/CategoryTheory/Limits/HasLimits.lean", "Mathlib/CategoryTheory/PUnit.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.punitCone", "code": "def punitCone : Cone F :=\n  \u27e8\u27e8\u27e8\u27e9\u27e9, (Functor.punitExt _ _).hom\u27e9", "start": [28, 1], "end": [30, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.punitCocone", "code": "def punitCocone : Cocone F :=\n  \u27e8\u27e8\u27e8\u27e9\u27e9, (Functor.punitExt _ _).hom\u27e9", "start": [33, 1], "end": [35, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.punitConeIsLimit", "code": "def punitConeIsLimit {c : Cone F} : IsLimit c where\n  lift := fun s => eqToHom (by simp)", "start": [38, 1], "end": [41, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.punitCoconeIsColimit", "code": "def punitCoconeIsColimit {c : Cocone F} : IsColimit c where\n  desc := fun s => eqToHom (by simp)", "start": [44, 1], "end": [47, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Constructions/EpiMono.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Pullbacks.lean", "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.preserves_mono_of_preservesLimit", "code": "theorem preserves_mono_of_preservesLimit {X Y : C} (f : X \u27f6 Y) [PreservesLimit (cospan f f) F]\n    [Mono f] : Mono (F.map f)", "start": [32, 1], "end": [37, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesMonomorphisms_of_preservesLimitsOfShape", "code": "instance (priority := 100) preservesMonomorphisms_of_preservesLimitsOfShape\n    [PreservesLimitsOfShape WalkingCospan F] : F.PreservesMonomorphisms where\n  preserves f _ := preserves_mono_of_preservesLimit F f", "start": [40, 1], "end": [42, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.reflects_mono_of_reflectsLimit", "code": "theorem reflects_mono_of_reflectsLimit {X Y : C} (f : X \u27f6 Y) [ReflectsLimit (cospan f f) F]\n    [Mono (F.map f)] : Mono f", "start": [45, 1], "end": [50, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.reflectsMonomorphisms_of_reflectsLimitsOfShape", "code": "instance (priority := 100) reflectsMonomorphisms_of_reflectsLimitsOfShape\n    [ReflectsLimitsOfShape WalkingCospan F] : F.ReflectsMonomorphisms where\n  reflects f _ := reflects_mono_of_reflectsLimit F f", "start": [53, 1], "end": [55, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preserves_epi_of_preservesColimit", "code": "theorem preserves_epi_of_preservesColimit {X Y : C} (f : X \u27f6 Y) [PreservesColimit (span f f) F]\n    [Epi f] : Epi (F.map f)", "start": [58, 1], "end": [63, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesEpimorphisms_of_preservesColimitsOfShape", "code": "instance (priority := 100) preservesEpimorphisms_of_preservesColimitsOfShape\n    [PreservesColimitsOfShape WalkingSpan F] : F.PreservesEpimorphisms where\n  preserves f _ := preserves_epi_of_preservesColimit F f", "start": [66, 1], "end": [68, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.reflects_epi_of_reflectsColimit", "code": "theorem reflects_epi_of_reflectsColimit {X Y : C} (f : X \u27f6 Y) [ReflectsColimit (span f f) F]\n    [Epi (F.map f)] : Epi f", "start": [71, 1], "end": [78, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.reflectsEpimorphisms_of_reflectsColimitsOfShape", "code": "instance (priority := 100) reflectsEpimorphisms_of_reflectsColimitsOfShape\n    [ReflectsColimitsOfShape WalkingSpan F] : F.ReflectsEpimorphisms where\n  reflects f _ := reflects_epi_of_reflectsColimit F f", "start": [81, 1], "end": [83, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/QuasiSeparated.lean", "imports": ["Mathlib/Topology/NoetherianSpace.lean", "Mathlib/Topology/Separation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsQuasiSeparated", "code": "def IsQuasiSeparated (s : Set \u03b1) : Prop :=\n  \u2200 U V : Set \u03b1, U \u2286 s \u2192 IsOpen U \u2192 IsCompact U \u2192 V \u2286 s \u2192 IsOpen V \u2192 IsCompact V \u2192 IsCompact (U \u2229 V)", "start": [36, 1], "end": [41, 101], "kind": "commanddeclaration"}, {"full_name": "QuasiSeparatedSpace", "code": "@[mk_iff]\nclass QuasiSeparatedSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] : Prop where\n  \n  inter_isCompact :\n    \u2200 U V : Set \u03b1, IsOpen U \u2192 IsCompact U \u2192 IsOpen V \u2192 IsCompact V \u2192 IsCompact (U \u2229 V)", "start": [44, 1], "end": [51, 87], "kind": "commanddeclaration"}, {"full_name": "isQuasiSeparated_univ_iff", "code": "theorem isQuasiSeparated_univ_iff {\u03b1 : Type*} [TopologicalSpace \u03b1] :\n    IsQuasiSeparated (Set.univ : Set \u03b1) \u2194 QuasiSeparatedSpace \u03b1", "start": [54, 1], "end": [57, 26], "kind": "commanddeclaration"}, {"full_name": "isQuasiSeparated_univ", "code": "theorem isQuasiSeparated_univ {\u03b1 : Type*} [TopologicalSpace \u03b1] [QuasiSeparatedSpace \u03b1] :\n    IsQuasiSeparated (Set.univ : Set \u03b1)", "start": [60, 1], "end": [62, 46], "kind": "commanddeclaration"}, {"full_name": "IsQuasiSeparated.image_of_embedding", "code": "theorem IsQuasiSeparated.image_of_embedding {s : Set \u03b1} (H : IsQuasiSeparated s) (h : Embedding f) :\n    IsQuasiSeparated (f '' s)", "start": [65, 1], "end": [87, 48], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.isQuasiSeparated_iff", "code": "theorem OpenEmbedding.isQuasiSeparated_iff (h : OpenEmbedding f) {s : Set \u03b1} :\n    IsQuasiSeparated s \u2194 IsQuasiSeparated (f '' s)", "start": [90, 1], "end": [97, 76], "kind": "commanddeclaration"}, {"full_name": "isQuasiSeparated_iff_quasiSeparatedSpace", "code": "theorem isQuasiSeparated_iff_quasiSeparatedSpace (s : Set \u03b1) (hs : IsOpen s) :\n    IsQuasiSeparated s \u2194 QuasiSeparatedSpace s", "start": [100, 1], "end": [104, 7], "kind": "commanddeclaration"}, {"full_name": "IsQuasiSeparated.of_subset", "code": "theorem IsQuasiSeparated.of_subset {s t : Set \u03b1} (ht : IsQuasiSeparated t) (h : s \u2286 t) :\n    IsQuasiSeparated s", "start": [107, 1], "end": [110, 59], "kind": "commanddeclaration"}, {"full_name": "T2Space.to_quasiSeparatedSpace", "code": "instance (priority := 100) T2Space.to_quasiSeparatedSpace [T2Space \u03b1] : QuasiSeparatedSpace \u03b1 :=\n  \u27e8fun _ _ _ hU' _ hV' => hU'.inter hV'\u27e9", "start": [113, 1], "end": [114, 41], "kind": "commanddeclaration"}, {"full_name": "NoetherianSpace.to_quasiSeparatedSpace", "code": "instance (priority := 100) NoetherianSpace.to_quasiSeparatedSpace [NoetherianSpace \u03b1] :\n    QuasiSeparatedSpace \u03b1 :=\n  \u27e8fun _ _ _ _ _ _ => NoetherianSpace.isCompact _\u27e9", "start": [117, 1], "end": [119, 51], "kind": "commanddeclaration"}, {"full_name": "IsQuasiSeparated.of_quasiSeparatedSpace", "code": "theorem IsQuasiSeparated.of_quasiSeparatedSpace (s : Set \u03b1) [QuasiSeparatedSpace \u03b1] :\n    IsQuasiSeparated s", "start": [122, 1], "end": [124, 54], "kind": "commanddeclaration"}, {"full_name": "QuasiSeparatedSpace.of_openEmbedding", "code": "theorem QuasiSeparatedSpace.of_openEmbedding (h : OpenEmbedding f) [QuasiSeparatedSpace \u03b2] :\n    QuasiSeparatedSpace \u03b1", "start": [127, 1], "end": [130, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/ENNReal.lean", "imports": ["Mathlib/Topology/Instances/ENNReal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ENNReal.eventually_le_limsup", "code": "theorem eventually_le_limsup [CountableInterFilter f] (u : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u2200\u1da0 y in f, u y \u2264 f.limsup u", "start": [23, 1], "end": [25, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.limsup_eq_zero_iff", "code": "theorem limsup_eq_zero_iff [CountableInterFilter f] {u : \u03b1 \u2192 \u211d\u22650\u221e} :\n    f.limsup u = 0 \u2194 u =\u1da0[f] 0", "start": [28, 1], "end": [30, 16], "kind": "commanddeclaration"}, {"full_name": "ENNReal.limsup_const_mul_of_ne_top", "code": "theorem limsup_const_mul_of_ne_top {u : \u03b1 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e} (ha_top : a \u2260 \u22a4) :\n    (f.limsup fun x : \u03b1 => a * u x) = a * f.limsup u", "start": [33, 1], "end": [47, 43], "kind": "commanddeclaration"}, {"full_name": "ENNReal.limsup_const_mul", "code": "theorem limsup_const_mul [CountableInterFilter f] {u : \u03b1 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e} :\n    f.limsup (a * u \u00b7) = a * f.limsup u", "start": [50, 1], "end": [68, 48], "kind": "commanddeclaration"}, {"full_name": "ENNReal.limsup_mul_le", "code": "theorem limsup_mul_le [CountableInterFilter f] (u v : \u03b1 \u2192 \u211d\u22650\u221e) :\n    f.limsup (u * v) \u2264 f.limsup u * f.limsup v", "start": [71, 1], "end": [77, 52], "kind": "commanddeclaration"}, {"full_name": "ENNReal.limsup_add_le", "code": "theorem limsup_add_le [CountableInterFilter f] (u v : \u03b1 \u2192 \u211d\u22650\u221e) :\n    f.limsup (u + v) \u2264 f.limsup u + f.limsup v", "start": [80, 1], "end": [83, 73], "kind": "commanddeclaration"}, {"full_name": "ENNReal.limsup_liminf_le_liminf_limsup", "code": "theorem limsup_liminf_le_liminf_limsup {\u03b2} [Countable \u03b2] {f : Filter \u03b1} [CountableInterFilter f]\n    {g : Filter \u03b2} (u : \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e) :\n    (f.limsup fun a : \u03b1 => g.liminf fun b : \u03b2 => u a b) \u2264\n      g.liminf fun b => f.limsup fun a => u a b", "start": [86, 1], "end": [93, 90], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean", "imports": ["Mathlib/Analysis/NormedSpace/BoundedLinearMaps.lean", "Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean", "Mathlib/MeasureTheory/Measure/WithDensity.lean", "Mathlib/MeasureTheory/Function/SimpleFuncDense.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/NormedSpace/FiniteDimension.lean"], "premises": [{"full_name": "MeasureTheory.StronglyMeasurable", "code": "def StronglyMeasurable [MeasurableSpace \u03b1] (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2203 fs : \u2115 \u2192 \u03b1 \u2192\u209b \u03b2, \u2200 x, Tendsto (fun n => fs n x) atTop (\ud835\udcdd (f x))", "start": [77, 1], "end": [79, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable", "code": "def FinStronglyMeasurable [Zero \u03b2] {_ : MeasurableSpace \u03b1} (f : \u03b1 \u2192 \u03b2) (\u03bc : Measure \u03b1) : Prop :=\n  \u2203 fs : \u2115 \u2192 \u03b1 \u2192\u209b \u03b2, (\u2200 n, \u03bc (support (fs n)) < \u221e) \u2227 \u2200 x, Tendsto (fun n => fs n x) atTop (\ud835\udcdd (f x))", "start": [85, 1], "end": [88, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable", "code": "def AEStronglyMeasurable {_ : MeasurableSpace \u03b1} (f : \u03b1 \u2192 \u03b2) (\u03bc : Measure \u03b1) : Prop :=\n  \u2203 g, StronglyMeasurable g \u2227 f =\u1d50[\u03bc] g", "start": [91, 1], "end": [94, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable", "code": "def AEFinStronglyMeasurable [Zero \u03b2] {_ : MeasurableSpace \u03b1} (f : \u03b1 \u2192 \u03b2) (\u03bc : Measure \u03b1) : Prop :=\n  \u2203 g, FinStronglyMeasurable g \u03bc \u2227 f =\u1d50[\u03bc] g", "start": [97, 1], "end": [100, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.aestronglyMeasurable", "code": "@[aesop 30% apply (rule_sets [Measurable])]\nprotected theorem StronglyMeasurable.aestronglyMeasurable {\u03b1 \u03b2} {_ : MeasurableSpace \u03b1}\n    [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {\u03bc : Measure \u03b1} (hf : StronglyMeasurable f) :\n    AEStronglyMeasurable f \u03bc", "start": [109, 1], "end": [113, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Subsingleton.stronglyMeasurable", "code": "@[simp]\ntheorem Subsingleton.stronglyMeasurable {\u03b1 \u03b2} [MeasurableSpace \u03b1] [TopologicalSpace \u03b2]\n    [Subsingleton \u03b2] (f : \u03b1 \u2192 \u03b2) : StronglyMeasurable f", "start": [116, 1], "end": [125, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.stronglyMeasurable", "code": "theorem SimpleFunc.stronglyMeasurable {\u03b1 \u03b2} {_ : MeasurableSpace \u03b1} [TopologicalSpace \u03b2]\n    (f : \u03b1 \u2192\u209b \u03b2) : StronglyMeasurable f", "start": [128, 1], "end": [130, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.stronglyMeasurable_of_isEmpty", "code": "theorem stronglyMeasurable_of_isEmpty [IsEmpty \u03b1] {_ : MeasurableSpace \u03b1} [TopologicalSpace \u03b2]\n    (f : \u03b1 \u2192 \u03b2) : StronglyMeasurable f", "start": [133, 1], "end": [135, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.stronglyMeasurable_of_fintype", "code": "theorem stronglyMeasurable_of_fintype [Fintype \u03b1] {_ : MeasurableSpace \u03b1}\n    [MeasurableSingletonClass \u03b1] [TopologicalSpace \u03b2]\n    (f : \u03b1 \u2192 \u03b2) : StronglyMeasurable f", "start": [138, 1], "end": [141, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.stronglyMeasurable_const", "code": "theorem stronglyMeasurable_const {\u03b1 \u03b2} {_ : MeasurableSpace \u03b1} [TopologicalSpace \u03b2] {b : \u03b2} :\n    StronglyMeasurable fun _ : \u03b1 => b", "start": [143, 1], "end": [145, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.stronglyMeasurable_one", "code": "@[to_additive]\ntheorem stronglyMeasurable_one {\u03b1 \u03b2} {_ : MeasurableSpace \u03b1} [TopologicalSpace \u03b2] [One \u03b2] :\n    StronglyMeasurable (1 : \u03b1 \u2192 \u03b2)", "start": [148, 1], "end": [151, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.stronglyMeasurable_const'", "code": "theorem stronglyMeasurable_const' {\u03b1 \u03b2} {m : MeasurableSpace \u03b1} [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 x y, f x = f y) : StronglyMeasurable f", "start": [155, 1], "end": [162, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Subsingleton.stronglyMeasurable'", "code": "@[simp]\ntheorem Subsingleton.stronglyMeasurable' {\u03b1 \u03b2} [MeasurableSpace \u03b1] [TopologicalSpace \u03b2]\n    [Subsingleton \u03b1] (f : \u03b1 \u2192 \u03b2) : StronglyMeasurable f", "start": [166, 1], "end": [169, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.approx", "code": "protected noncomputable def approx {_ : MeasurableSpace \u03b1} (hf : StronglyMeasurable f) :\n    \u2115 \u2192 \u03b1 \u2192\u209b \u03b2 :=\n  hf.choose", "start": [180, 1], "end": [185, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.tendsto_approx", "code": "protected theorem tendsto_approx {_ : MeasurableSpace \u03b1} (hf : StronglyMeasurable f) :\n    \u2200 x, Tendsto (fun n => hf.approx n x) atTop (\ud835\udcdd (f x))", "start": [188, 1], "end": [190, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.approxBounded", "code": "noncomputable def approxBounded {_ : MeasurableSpace \u03b1} [Norm \u03b2] [SMul \u211d \u03b2]\n    (hf : StronglyMeasurable f) (c : \u211d) : \u2115 \u2192 SimpleFunc \u03b1 \u03b2 := fun n =>\n  (hf.approx n).map fun x => min 1 (c / \u2016x\u2016) \u2022 x", "start": [193, 1], "end": [198, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.tendsto_approxBounded_of_norm_le", "code": "theorem tendsto_approxBounded_of_norm_le {\u03b2} {f : \u03b1 \u2192 \u03b2} [NormedAddCommGroup \u03b2] [NormedSpace \u211d \u03b2]\n    {m : MeasurableSpace \u03b1} (hf : StronglyMeasurable[m] f) {c : \u211d} {x : \u03b1} (hfx : \u2016f x\u2016 \u2264 c) :\n    Tendsto (fun n => hf.approxBounded c n x) atTop (\ud835\udcdd (f x))", "start": [201, 1], "end": [230, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.tendsto_approxBounded_ae", "code": "theorem tendsto_approxBounded_ae {\u03b2} {f : \u03b1 \u2192 \u03b2} [NormedAddCommGroup \u03b2] [NormedSpace \u211d \u03b2]\n    {m m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} (hf : StronglyMeasurable[m] f) {c : \u211d}\n    (hf_bound : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 c) :\n    \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => hf.approxBounded c n x) atTop (\ud835\udcdd (f x))", "start": [233, 1], "end": [237, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.norm_approxBounded_le", "code": "theorem norm_approxBounded_le {\u03b2} {f : \u03b1 \u2192 \u03b2} [SeminormedAddCommGroup \u03b2] [NormedSpace \u211d \u03b2]\n    {m : MeasurableSpace \u03b1} {c : \u211d} (hf : StronglyMeasurable[m] f) (hc : 0 \u2264 c) (n : \u2115) (x : \u03b1) :\n    \u2016hf.approxBounded c n x\u2016 \u2264 c", "start": [240, 1], "end": [255, 69], "kind": "commanddeclaration"}, {"full_name": "stronglyMeasurable_bot_iff", "code": "theorem _root_.stronglyMeasurable_bot_iff [Nonempty \u03b2] [T2Space \u03b2] :\n    StronglyMeasurable[\u22a5] f \u2194 \u2203 c, f = fun _ => c", "start": [258, 1], "end": [275, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.finStronglyMeasurable_of_set_sigmaFinite", "code": "theorem finStronglyMeasurable_of_set_sigmaFinite [TopologicalSpace \u03b2] [Zero \u03b2]\n    {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} (hf_meas : StronglyMeasurable f) {t : Set \u03b1}\n    (ht : MeasurableSet t) (hft_zero : \u2200 x \u2208 t\u1d9c, f x = 0) (ht\u03bc : SigmaFinite (\u03bc.restrict t)) :\n    FinStronglyMeasurable f \u03bc", "start": [280, 1], "end": [327, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.finStronglyMeasurable", "code": "@[aesop 5% apply (rule_sets [Measurable])]\nprotected theorem finStronglyMeasurable [TopologicalSpace \u03b2] [Zero \u03b2] {m0 : MeasurableSpace \u03b1}\n    (hf : StronglyMeasurable f) (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] : FinStronglyMeasurable f \u03bc", "start": [330, 1], "end": [336, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.measurable", "code": "@[aesop 5% apply (rule_sets [Measurable])]\nprotected theorem measurable {_ : MeasurableSpace \u03b1} [TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2]\n    [MeasurableSpace \u03b2] [BorelSpace \u03b2] (hf : StronglyMeasurable f) : Measurable f", "start": [339, 1], "end": [344, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.aemeasurable", "code": "@[aesop 5% apply (rule_sets [Measurable])]\nprotected theorem aemeasurable {_ : MeasurableSpace \u03b1} [TopologicalSpace \u03b2]\n    [PseudoMetrizableSpace \u03b2] [MeasurableSpace \u03b2] [BorelSpace \u03b2] {\u03bc : Measure \u03b1}\n    (hf : StronglyMeasurable f) : AEMeasurable f \u03bc", "start": [347, 1], "end": [352, 29], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp_stronglyMeasurable", "code": "theorem _root_.Continuous.comp_stronglyMeasurable {_ : MeasurableSpace \u03b1} [TopologicalSpace \u03b2]\n    [TopologicalSpace \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : Continuous g) (hf : StronglyMeasurable f) :\n    StronglyMeasurable fun x => g (f x)", "start": [355, 1], "end": [358, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.measurableSet_mulSupport", "code": "@[to_additive]\nnonrec theorem measurableSet_mulSupport {m : MeasurableSpace \u03b1} [One \u03b2] [TopologicalSpace \u03b2]\n    [MetrizableSpace \u03b2] (hf : StronglyMeasurable f) : MeasurableSet (mulSupport f)", "start": [361, 1], "end": [365, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.mono", "code": "protected theorem mono {m m' : MeasurableSpace \u03b1} [TopologicalSpace \u03b2]\n    (hf : StronglyMeasurable[m'] f) (h_mono : m' \u2264 m) : StronglyMeasurable[m] f", "start": [369, 1], "end": [376, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.prod_mk", "code": "protected theorem prod_mk {m : MeasurableSpace \u03b1} [TopologicalSpace \u03b2] [TopologicalSpace \u03b3]\n    {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    StronglyMeasurable fun x => (f x, g x)", "start": [379, 1], "end": [384, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.comp_measurable", "code": "theorem comp_measurable [TopologicalSpace \u03b2] {_ : MeasurableSpace \u03b1} {_ : MeasurableSpace \u03b3}\n    {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b1} (hf : StronglyMeasurable f) (hg : Measurable g) :\n    StronglyMeasurable (f \u2218 g)", "start": [387, 1], "end": [390, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.of_uncurry_left", "code": "theorem of_uncurry_left [TopologicalSpace \u03b2] {_ : MeasurableSpace \u03b1} {_ : MeasurableSpace \u03b3}\n    {f : \u03b1 \u2192 \u03b3 \u2192 \u03b2} (hf : StronglyMeasurable (uncurry f)) {x : \u03b1} : StronglyMeasurable (f x)", "start": [393, 1], "end": [395, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.of_uncurry_right", "code": "theorem of_uncurry_right [TopologicalSpace \u03b2] {_ : MeasurableSpace \u03b1} {_ : MeasurableSpace \u03b3}\n    {f : \u03b1 \u2192 \u03b3 \u2192 \u03b2} (hf : StronglyMeasurable (uncurry f)) {y : \u03b3} :\n    StronglyMeasurable fun x => f x y", "start": [398, 1], "end": [401, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.mul", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\nprotected theorem mul [Mul \u03b2] [ContinuousMul \u03b2] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f * g)", "start": [408, 1], "end": [411, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.mul_const", "code": "@[to_additive (attr := measurability)]\ntheorem mul_const [Mul \u03b2] [ContinuousMul \u03b2] (hf : StronglyMeasurable f) (c : \u03b2) :\n    StronglyMeasurable fun x => f x * c", "start": [415, 1], "end": [418, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.const_mul", "code": "@[to_additive (attr := measurability)]\ntheorem const_mul [Mul \u03b2] [ContinuousMul \u03b2] (hf : StronglyMeasurable f) (c : \u03b2) :\n    StronglyMeasurable fun x => c * f x", "start": [422, 1], "end": [425, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.inv", "code": "@[to_additive (attr := measurability)]\nprotected theorem inv [Inv \u03b2] [ContinuousInv \u03b2] (hf : StronglyMeasurable f) :\n    StronglyMeasurable f\u207b\u00b9", "start": [429, 1], "end": [432, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.div", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\nprotected theorem div [Div \u03b2] [ContinuousDiv \u03b2] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f / g)", "start": [436, 1], "end": [439, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.smul", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\nprotected theorem smul {\ud835\udd5c} [TopologicalSpace \ud835\udd5c] [SMul \ud835\udd5c \u03b2] [ContinuousSMul \ud835\udd5c \u03b2] {f : \u03b1 \u2192 \ud835\udd5c}\n    {g : \u03b1 \u2192 \u03b2} (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    StronglyMeasurable fun x => f x \u2022 g x", "start": [443, 1], "end": [447, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.const_smul", "code": "@[measurability]\nprotected theorem const_smul {\ud835\udd5c} [SMul \ud835\udd5c \u03b2] [ContinuousConstSMul \ud835\udd5c \u03b2] (hf : StronglyMeasurable f)\n    (c : \ud835\udd5c) : StronglyMeasurable (c \u2022 f)", "start": [451, 1], "end": [454, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.const_smul'", "code": "@[measurability]\nprotected theorem const_smul' {\ud835\udd5c} [SMul \ud835\udd5c \u03b2] [ContinuousConstSMul \ud835\udd5c \u03b2] (hf : StronglyMeasurable f)\n    (c : \ud835\udd5c) : StronglyMeasurable fun x => c \u2022 f x", "start": [457, 1], "end": [460, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.smul_const", "code": "@[to_additive (attr := measurability)]\nprotected theorem smul_const {\ud835\udd5c} [TopologicalSpace \ud835\udd5c] [SMul \ud835\udd5c \u03b2] [ContinuousSMul \ud835\udd5c \u03b2] {f : \u03b1 \u2192 \ud835\udd5c}\n    (hf : StronglyMeasurable f) (c : \u03b2) : StronglyMeasurable fun x => f x \u2022 c", "start": [463, 1], "end": [466, 80], "kind": "commanddeclaration"}, {"full_name": "Measurable.add_stronglyMeasurable", "code": "theorem _root_.Measurable.add_stronglyMeasurable\n    {\u03b1 E : Type*} {_ : MeasurableSpace \u03b1} [AddGroup E] [TopologicalSpace E]\n    [MeasurableSpace E] [BorelSpace E] [ContinuousAdd E] [PseudoMetrizableSpace E]\n    {g f : \u03b1 \u2192 E} (hg : Measurable g) (hf : StronglyMeasurable f) :\n    Measurable (g + f)", "start": [470, 1], "end": [482, 28], "kind": "commanddeclaration"}, {"full_name": "Measurable.sub_stronglyMeasurable", "code": "theorem _root_.Measurable.sub_stronglyMeasurable\n    {\u03b1 E : Type*} {_ : MeasurableSpace \u03b1} [AddCommGroup E] [TopologicalSpace E]\n    [MeasurableSpace E] [BorelSpace E] [ContinuousAdd E] [ContinuousNeg E] [PseudoMetrizableSpace E]\n    {g f : \u03b1 \u2192 E} (hg : Measurable g) (hf : StronglyMeasurable f) :\n    Measurable (g - f)", "start": [484, 1], "end": [493, 41], "kind": "commanddeclaration"}, {"full_name": "Measurable.stronglyMeasurable_add", "code": "theorem _root_.Measurable.stronglyMeasurable_add\n    {\u03b1 E : Type*} {_ : MeasurableSpace \u03b1} [AddGroup E] [TopologicalSpace E]\n    [MeasurableSpace E] [BorelSpace E] [ContinuousAdd E] [PseudoMetrizableSpace E]\n    {g f : \u03b1 \u2192 E} (hg : Measurable g) (hf : StronglyMeasurable f) :\n    Measurable (f + g)", "start": [495, 1], "end": [507, 28], "kind": "commanddeclaration"}, {"full_name": "stronglyMeasurable_const_smul_iff", "code": "theorem _root_.stronglyMeasurable_const_smul_iff {m : MeasurableSpace \u03b1} (c : G) :\n    (StronglyMeasurable fun x => c \u2022 f x) \u2194 StronglyMeasurable f", "start": [519, 1], "end": [521, 92], "kind": "commanddeclaration"}, {"full_name": "IsUnit.stronglyMeasurable_const_smul_iff", "code": "nonrec theorem _root_.IsUnit.stronglyMeasurable_const_smul_iff {_ : MeasurableSpace \u03b1} {c : M}\n    (hc : IsUnit c) :\n    (StronglyMeasurable fun x => c \u2022 f x) \u2194 StronglyMeasurable f", "start": [524, 1], "end": [528, 43], "kind": "commanddeclaration"}, {"full_name": "stronglyMeasurable_const_smul_iff\u2080", "code": "theorem _root_.stronglyMeasurable_const_smul_iff\u2080 {_ : MeasurableSpace \u03b1} {c : G\u2080} (hc : c \u2260 0) :\n    (StronglyMeasurable fun x => c \u2022 f x) \u2194 StronglyMeasurable f", "start": [531, 1], "end": [533, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.sup", "code": "@[aesop safe 20 (rule_sets [Measurable])]\nprotected theorem sup [Sup \u03b2] [ContinuousSup \u03b2] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f \u2294 g)", "start": [546, 1], "end": [550, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.inf", "code": "@[aesop safe 20 (rule_sets [Measurable])]\nprotected theorem inf [Inf \u03b2] [ContinuousInf \u03b2] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f \u2293 g)", "start": [553, 1], "end": [557, 64], "kind": "commanddeclaration"}, {"full_name": "List.stronglyMeasurable_prod'", "code": "@[to_additive (attr := measurability)]\ntheorem _root_.List.stronglyMeasurable_prod' (l : List (\u03b1 \u2192 M))\n    (hl : \u2200 f \u2208 l, StronglyMeasurable f) : StronglyMeasurable l.prod", "start": [571, 1], "end": [577, 28], "kind": "commanddeclaration"}, {"full_name": "List.stronglyMeasurable_prod", "code": "@[to_additive (attr := measurability)]\ntheorem _root_.List.stronglyMeasurable_prod (l : List (\u03b1 \u2192 M))\n    (hl : \u2200 f \u2208 l, StronglyMeasurable f) :\n    StronglyMeasurable fun x => (l.map fun f : \u03b1 \u2192 M => f x).prod", "start": [581, 1], "end": [585, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.stronglyMeasurable_prod'", "code": "@[to_additive (attr := measurability)]\ntheorem _root_.Multiset.stronglyMeasurable_prod' (l : Multiset (\u03b1 \u2192 M))\n    (hl : \u2200 f \u2208 l, StronglyMeasurable f) : StronglyMeasurable l.prod", "start": [595, 1], "end": [599, 61], "kind": "commanddeclaration"}, {"full_name": "Multiset.stronglyMeasurable_prod", "code": "@[to_additive (attr := measurability)]\ntheorem _root_.Multiset.stronglyMeasurable_prod (s : Multiset (\u03b1 \u2192 M))\n    (hs : \u2200 f \u2208 s, StronglyMeasurable f) :\n    StronglyMeasurable fun x => (s.map fun f : \u03b1 \u2192 M => f x).prod", "start": [603, 1], "end": [607, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.stronglyMeasurable_prod'", "code": "@[to_additive (attr := measurability)]\ntheorem _root_.Finset.stronglyMeasurable_prod' {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1 \u2192 M} (s : Finset \u03b9)\n    (hf : \u2200 i \u2208 s, StronglyMeasurable (f i)) : StronglyMeasurable (\u220f i in s, f i)", "start": [611, 1], "end": [614, 98], "kind": "commanddeclaration"}, {"full_name": "Finset.stronglyMeasurable_prod", "code": "@[to_additive (attr := measurability)]\ntheorem _root_.Finset.stronglyMeasurable_prod {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1 \u2192 M} (s : Finset \u03b9)\n    (hf : \u2200 i \u2208 s, StronglyMeasurable (f i)) : StronglyMeasurable fun a => \u220f i in s, f i a", "start": [618, 1], "end": [621, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.isSeparable_range", "code": "theorem isSeparable_range {m : MeasurableSpace \u03b1} [TopologicalSpace \u03b2] (hf : StronglyMeasurable f) :\n    TopologicalSpace.IsSeparable (range f)", "start": [627, 1], "end": [637, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.separableSpace_range_union_singleton", "code": "theorem separableSpace_range_union_singleton {_ : MeasurableSpace \u03b1} [TopologicalSpace \u03b2]\n    [PseudoMetrizableSpace \u03b2] (hf : StronglyMeasurable f) {b : \u03b2} :\n    SeparableSpace (range f \u222a {b} : Set \u03b2)", "start": [640, 1], "end": [644, 79], "kind": "commanddeclaration"}, {"full_name": "Measurable.stronglyMeasurable", "code": "@[aesop 90% apply (rule_sets [Measurable])]\ntheorem _root_.Measurable.stronglyMeasurable [TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2]\n    [SecondCountableTopology \u03b2] [OpensMeasurableSpace \u03b2] (hf : Measurable f) :\n    StronglyMeasurable f", "start": [651, 1], "end": [659, 82], "kind": "commanddeclaration"}, {"full_name": "stronglyMeasurable_iff_measurable", "code": "theorem _root_.stronglyMeasurable_iff_measurable [TopologicalSpace \u03b2] [MetrizableSpace \u03b2]\n    [BorelSpace \u03b2] [SecondCountableTopology \u03b2] : StronglyMeasurable f \u2194 Measurable f", "start": [662, 1], "end": [665, 68], "kind": "commanddeclaration"}, {"full_name": "stronglyMeasurable_id", "code": "@[measurability]\ntheorem _root_.stronglyMeasurable_id [TopologicalSpace \u03b1] [PseudoMetrizableSpace \u03b1]\n    [OpensMeasurableSpace \u03b1] [SecondCountableTopology \u03b1] : StronglyMeasurable (id : \u03b1 \u2192 \u03b1)", "start": [668, 1], "end": [671, 35], "kind": "commanddeclaration"}, {"full_name": "stronglyMeasurable_iff_measurable_separable", "code": "theorem _root_.stronglyMeasurable_iff_measurable_separable {m : MeasurableSpace \u03b1}\n    [TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [MeasurableSpace \u03b2] [BorelSpace \u03b2] :\n    StronglyMeasurable f \u2194 Measurable f \u2227 IsSeparable (range f)", "start": [676, 1], "end": [684, 59], "kind": "commanddeclaration"}, {"full_name": "Continuous.stronglyMeasurable", "code": "theorem _root_.Continuous.stronglyMeasurable [MeasurableSpace \u03b1] [TopologicalSpace \u03b1]\n    [OpensMeasurableSpace \u03b1] [TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2]\n    [h : SecondCountableTopologyEither \u03b1 \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) :\n    StronglyMeasurable f", "start": [687, 1], "end": [699, 43], "kind": "commanddeclaration"}, {"full_name": "Continuous.stronglyMeasurable_of_hasCompactSupport", "code": "theorem _root_.Continuous.stronglyMeasurable_of_hasCompactSupport\n    [MeasurableSpace \u03b1] [TopologicalSpace \u03b1] [OpensMeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    [TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2] [Zero \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Continuous f) (h'f : HasCompactSupport f) : StronglyMeasurable f", "start": [702, 1], "end": [709, 88], "kind": "commanddeclaration"}, {"full_name": "Embedding.comp_stronglyMeasurable_iff", "code": "theorem _root_.Embedding.comp_stronglyMeasurable_iff {m : MeasurableSpace \u03b1} [TopologicalSpace \u03b2]\n    [PseudoMetrizableSpace \u03b2] [TopologicalSpace \u03b3] [PseudoMetrizableSpace \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : Embedding g) : (StronglyMeasurable fun x => g (f x)) \u2194 StronglyMeasurable f", "start": [711, 1], "end": [729, 52], "kind": "commanddeclaration"}, {"full_name": "stronglyMeasurable_of_tendsto", "code": "theorem _root_.stronglyMeasurable_of_tendsto {\u03b9 : Type*} {m : MeasurableSpace \u03b1}\n    [TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] (u : Filter \u03b9) [NeBot u] [IsCountablyGenerated u]\n    {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b2} (hf : \u2200 i, StronglyMeasurable (f i)) (lim : Tendsto f u (\ud835\udcdd g)) :\n    StronglyMeasurable g", "start": [732, 1], "end": [749, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.piecewise", "code": "protected theorem piecewise {m : MeasurableSpace \u03b1} [TopologicalSpace \u03b2] {s : Set \u03b1}\n    {_ : DecidablePred (\u00b7 \u2208 s)} (hs : MeasurableSet s) (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (Set.piecewise s f g)", "start": [752, 1], "end": [760, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.ite", "code": "protected theorem ite {_ : MeasurableSpace \u03b1} [TopologicalSpace \u03b2] {p : \u03b1 \u2192 Prop}\n    {_ : DecidablePred p} (hp : MeasurableSet { a : \u03b1 | p a }) (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x)", "start": [763, 1], "end": [771, 40], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.stronglyMeasurable_extend", "code": "@[measurability]\ntheorem _root_.MeasurableEmbedding.stronglyMeasurable_extend {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} {g' : \u03b3 \u2192 \u03b2}\n    {m\u03b1 : MeasurableSpace \u03b1} {m\u03b3 : MeasurableSpace \u03b3} [TopologicalSpace \u03b2]\n    (hg : MeasurableEmbedding g) (hf : StronglyMeasurable f) (hg' : StronglyMeasurable g') :\n    StronglyMeasurable (Function.extend g f g')", "start": [774, 1], "end": [786, 27], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.exists_stronglyMeasurable_extend", "code": "theorem _root_.MeasurableEmbedding.exists_stronglyMeasurable_extend {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3}\n    {_ : MeasurableSpace \u03b1} {_ : MeasurableSpace \u03b3} [TopologicalSpace \u03b2]\n    (hg : MeasurableEmbedding g) (hf : StronglyMeasurable f) (hne : \u03b3 \u2192 Nonempty \u03b2) :\n    \u2203 f' : \u03b3 \u2192 \u03b2, StronglyMeasurable f' \u2227 f' \u2218 g = f", "start": [789, 1], "end": [795, 53], "kind": "commanddeclaration"}, {"full_name": "stronglyMeasurable_of_stronglyMeasurable_union_cover", "code": "theorem _root_.stronglyMeasurable_of_stronglyMeasurable_union_cover {m : MeasurableSpace \u03b1}\n    [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} (s t : Set \u03b1) (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h : univ \u2286 s \u222a t) (hc : StronglyMeasurable fun a : s => f a)\n    (hd : StronglyMeasurable fun a : t => f a) : StronglyMeasurable f", "start": [798, 1], "end": [813, 40], "kind": "commanddeclaration"}, {"full_name": "stronglyMeasurable_of_restrict_of_restrict_compl", "code": "theorem _root_.stronglyMeasurable_of_restrict_of_restrict_compl {_ : MeasurableSpace \u03b1}\n    [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hs : MeasurableSet s)\n    (h\u2081 : StronglyMeasurable (s.restrict f)) (h\u2082 : StronglyMeasurable (s\u1d9c.restrict f)) :\n    StronglyMeasurable f", "start": [816, 1], "end": [821, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.indicator", "code": "@[measurability]\nprotected theorem indicator {_ : MeasurableSpace \u03b1} [TopologicalSpace \u03b2] [Zero \u03b2]\n    (hf : StronglyMeasurable f) {s : Set \u03b1} (hs : MeasurableSet s) :\n    StronglyMeasurable (s.indicator f)", "start": [824, 1], "end": [828, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.dist", "code": "@[aesop safe 20 apply (rule_sets [Measurable])]\nprotected theorem dist {_ : MeasurableSpace \u03b1} {\u03b2 : Type*} [PseudoMetricSpace \u03b2] {f g : \u03b1 \u2192 \u03b2}\n    (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    StronglyMeasurable fun x => dist (f x) (g x)", "start": [831, 1], "end": [835, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.norm", "code": "@[measurability]\nprotected theorem norm {_ : MeasurableSpace \u03b1} {\u03b2 : Type*} [SeminormedAddCommGroup \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : StronglyMeasurable f) : StronglyMeasurable fun x => \u2016f x\u2016", "start": [838, 1], "end": [841, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.nnnorm", "code": "@[measurability]\nprotected theorem nnnorm {_ : MeasurableSpace \u03b1} {\u03b2 : Type*} [SeminormedAddCommGroup \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : StronglyMeasurable f) : StronglyMeasurable fun x => \u2016f x\u2016\u208a", "start": [844, 1], "end": [847, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.ennnorm", "code": "@[measurability]\nprotected theorem ennnorm {_ : MeasurableSpace \u03b1} {\u03b2 : Type*} [SeminormedAddCommGroup \u03b2]\n    {f : \u03b1 \u2192 \u03b2} (hf : StronglyMeasurable f) : Measurable fun a => (\u2016f a\u2016\u208a : \u211d\u22650\u221e)", "start": [850, 1], "end": [853, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.real_toNNReal", "code": "@[measurability]\nprotected theorem real_toNNReal {_ : MeasurableSpace \u03b1} {f : \u03b1 \u2192 \u211d} (hf : StronglyMeasurable f) :\n    StronglyMeasurable fun x => (f x).toNNReal", "start": [856, 1], "end": [859, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.measurableSet_eq_fun", "code": "theorem measurableSet_eq_fun {m : MeasurableSpace \u03b1} {E} [TopologicalSpace E] [MetrizableSpace E]\n    {f g : \u03b1 \u2192 E} (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    MeasurableSet { x | f x = g x }", "start": [862, 1], "end": [866, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.measurableSet_lt", "code": "theorem measurableSet_lt {m : MeasurableSpace \u03b1} [TopologicalSpace \u03b2] [LinearOrder \u03b2]\n    [OrderClosedTopology \u03b2] [PseudoMetrizableSpace \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : MeasurableSet { a | f a < g a }", "start": [869, 1], "end": [873, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.measurableSet_le", "code": "theorem measurableSet_le {m : MeasurableSpace \u03b1} [TopologicalSpace \u03b2] [Preorder \u03b2]\n    [OrderClosedTopology \u03b2] [PseudoMetrizableSpace \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : MeasurableSet { a | f a \u2264 g a }", "start": [876, 1], "end": [880, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.stronglyMeasurable_in_set", "code": "theorem stronglyMeasurable_in_set {m : MeasurableSpace \u03b1} [TopologicalSpace \u03b2] [Zero \u03b2] {s : Set \u03b1}\n    {f : \u03b1 \u2192 \u03b2} (hs : MeasurableSet s) (hf : StronglyMeasurable f)\n    (hf_zero : \u2200 x, x \u2209 s \u2192 f x = 0) :\n    \u2203 fs : \u2115 \u2192 \u03b1 \u2192\u209b \u03b2,\n      (\u2200 x, Tendsto (fun n => fs n x) atTop (\ud835\udcdd (f x))) \u2227 \u2200 (x) (_ : x \u2209 s) (n), fs n x = 0", "start": [883, 1], "end": [900, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.stronglyMeasurable_of_measurableSpace_le_on", "code": "theorem stronglyMeasurable_of_measurableSpace_le_on {\u03b1 E} {m m\u2082 : MeasurableSpace \u03b1}\n    [TopologicalSpace E] [Zero E] {s : Set \u03b1} {f : \u03b1 \u2192 E} (hs_m : MeasurableSet[m] s)\n    (hs : \u2200 t, MeasurableSet[m] (s \u2229 t) \u2192 MeasurableSet[m\u2082] (s \u2229 t))\n    (hf : StronglyMeasurable[m] f) (hf_zero : \u2200 (x) (_ : x \u2209 s), f x = 0) :\n    StronglyMeasurable[m\u2082] f", "start": [903, 1], "end": [940, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.StronglyMeasurable.exists_spanning_measurableSet_norm_le", "code": "theorem exists_spanning_measurableSet_norm_le [SeminormedAddCommGroup \u03b2] {m m0 : MeasurableSpace \u03b1}\n    (hm : m \u2264 m0) (hf : StronglyMeasurable[m] f) (\u03bc : Measure \u03b1) [SigmaFinite (\u03bc.trim hm)] :\n    \u2203 s : \u2115 \u2192 Set \u03b1,\n      (\u2200 n, MeasurableSet[m] (s n) \u2227 \u03bc (s n) < \u221e \u2227 \u2200 x \u2208 s n, \u2016f x\u2016 \u2264 n) \u2227\n      \u22c3 i, s i = Set.univ", "start": [943, 1], "end": [973, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.finStronglyMeasurable_zero", "code": "theorem finStronglyMeasurable_zero {\u03b1 \u03b2} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} [Zero \u03b2]\n    [TopologicalSpace \u03b2] : FinStronglyMeasurable (0 : \u03b1 \u2192 \u03b2) \u03bc", "start": [981, 1], "end": [986, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable.aefinStronglyMeasurable", "code": "theorem aefinStronglyMeasurable [Zero \u03b2] [TopologicalSpace \u03b2] (hf : FinStronglyMeasurable f \u03bc) :\n    AEFinStronglyMeasurable f \u03bc", "start": [993, 1], "end": [995, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable.approx", "code": "protected noncomputable def approx : \u2115 \u2192 \u03b1 \u2192\u209b \u03b2 :=\n  hf.choose", "start": [1002, 1], "end": [1006, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable.fin_support_approx", "code": "protected theorem fin_support_approx : \u2200 n, \u03bc (support (hf.approx n)) < \u221e", "start": [1009, 1], "end": [1010, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable.tendsto_approx", "code": "protected theorem tendsto_approx : \u2200 x, Tendsto (fun n => hf.approx n x) atTop (\ud835\udcdd (f x))", "start": [1013, 1], "end": [1014, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable.stronglyMeasurable", "code": "@[aesop 5% apply (rule_sets [Measurable])]\nprotected theorem stronglyMeasurable [Zero \u03b2] [TopologicalSpace \u03b2]\n    (hf : FinStronglyMeasurable f \u03bc) : StronglyMeasurable f", "start": [1019, 1], "end": [1023, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable.exists_set_sigmaFinite", "code": "theorem exists_set_sigmaFinite [Zero \u03b2] [TopologicalSpace \u03b2] [T2Space \u03b2]\n    (hf : FinStronglyMeasurable f \u03bc) :\n    \u2203 t, MeasurableSet t \u2227 (\u2200 x \u2208 t\u1d9c, f x = 0) \u2227 SigmaFinite (\u03bc.restrict t)", "start": [1026, 1], "end": [1046, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable.measurable", "code": "protected theorem measurable [Zero \u03b2] [TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2]\n    [MeasurableSpace \u03b2] [BorelSpace \u03b2] (hf : FinStronglyMeasurable f \u03bc) : Measurable f", "start": [1049, 1], "end": [1052, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable.mul", "code": "@[aesop safe 20 (rule_sets [Measurable])]\nprotected theorem mul [MonoidWithZero \u03b2] [ContinuousMul \u03b2] (hf : FinStronglyMeasurable f \u03bc)\n    (hg : FinStronglyMeasurable g \u03bc) : FinStronglyMeasurable (f * g) \u03bc", "start": [1059, 1], "end": [1066, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable.add", "code": "@[aesop safe 20 (rule_sets [Measurable])]\nprotected theorem add [AddMonoid \u03b2] [ContinuousAdd \u03b2] (hf : FinStronglyMeasurable f \u03bc)\n    (hg : FinStronglyMeasurable g \u03bc) : FinStronglyMeasurable (f + g) \u03bc", "start": [1069, 1], "end": [1076, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable.neg", "code": "@[measurability]\nprotected theorem neg [AddGroup \u03b2] [TopologicalAddGroup \u03b2] (hf : FinStronglyMeasurable f \u03bc) :\n    FinStronglyMeasurable (-f) \u03bc", "start": [1079, 1], "end": [1085, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable.sub", "code": "@[measurability]\nprotected theorem sub [AddGroup \u03b2] [ContinuousSub \u03b2] (hf : FinStronglyMeasurable f \u03bc)\n    (hg : FinStronglyMeasurable g \u03bc) : FinStronglyMeasurable (f - g) \u03bc", "start": [1088, 1], "end": [1095, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable.const_smul", "code": "@[measurability]\nprotected theorem const_smul {\ud835\udd5c} [TopologicalSpace \ud835\udd5c] [AddMonoid \u03b2] [Monoid \ud835\udd5c]\n    [DistribMulAction \ud835\udd5c \u03b2] [ContinuousSMul \ud835\udd5c \u03b2] (hf : FinStronglyMeasurable f \u03bc) (c : \ud835\udd5c) :\n    FinStronglyMeasurable (c \u2022 f) \u03bc", "start": [1098, 1], "end": [1104, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable.sup", "code": "@[aesop safe 20 (rule_sets [Measurable])]\nprotected theorem sup [SemilatticeSup \u03b2] [ContinuousSup \u03b2] (hf : FinStronglyMeasurable f \u03bc)\n    (hg : FinStronglyMeasurable g \u03bc) : FinStronglyMeasurable (f \u2294 g) \u03bc", "start": [1113, 1], "end": [1120, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FinStronglyMeasurable.inf", "code": "@[aesop safe 20 (rule_sets [Measurable])]\nprotected theorem inf [SemilatticeInf \u03b2] [ContinuousInf \u03b2] (hf : FinStronglyMeasurable f \u03bc)\n    (hg : FinStronglyMeasurable g \u03bc) : FinStronglyMeasurable (f \u2293 g) \u03bc", "start": [1123, 1], "end": [1130, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.finStronglyMeasurable_iff_stronglyMeasurable_and_exists_set_sigmaFinite", "code": "theorem finStronglyMeasurable_iff_stronglyMeasurable_and_exists_set_sigmaFinite {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2}\n    [TopologicalSpace \u03b2] [T2Space \u03b2] [Zero \u03b2] {_ : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} :\n    FinStronglyMeasurable f \u03bc \u2194\n      StronglyMeasurable f \u2227\n        \u2203 t, MeasurableSet t \u2227 (\u2200 x \u2208 t\u1d9c, f x = 0) \u2227 SigmaFinite (\u03bc.restrict t)", "start": [1137, 1], "end": [1144, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.aefinStronglyMeasurable_zero", "code": "theorem aefinStronglyMeasurable_zero {\u03b1 \u03b2} {_ : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) [Zero \u03b2]\n    [TopologicalSpace \u03b2] : AEFinStronglyMeasurable (0 : \u03b1 \u2192 \u03b2) \u03bc", "start": [1147, 1], "end": [1149, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.aestronglyMeasurable_const", "code": "@[measurability]\ntheorem aestronglyMeasurable_const {\u03b1 \u03b2} {_ : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    [TopologicalSpace \u03b2] {b : \u03b2} : AEStronglyMeasurable (fun _ : \u03b1 => b) \u03bc", "start": [1154, 1], "end": [1157, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.aestronglyMeasurable_one", "code": "@[to_additive (attr := measurability)]\ntheorem aestronglyMeasurable_one {\u03b1 \u03b2} {_ : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} [TopologicalSpace \u03b2]\n    [One \u03b2] : AEStronglyMeasurable (1 : \u03b1 \u2192 \u03b2) \u03bc", "start": [1160, 1], "end": [1163, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Subsingleton.aestronglyMeasurable", "code": "@[simp]\ntheorem Subsingleton.aestronglyMeasurable {_ : MeasurableSpace \u03b1} [TopologicalSpace \u03b2]\n    [Subsingleton \u03b2] {\u03bc : Measure \u03b1} (f : \u03b1 \u2192 \u03b2) : AEStronglyMeasurable f \u03bc", "start": [1167, 1], "end": [1170, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Subsingleton.aestronglyMeasurable'", "code": "@[simp]\ntheorem Subsingleton.aestronglyMeasurable' {_ : MeasurableSpace \u03b1} [TopologicalSpace \u03b2]\n    [Subsingleton \u03b1] {\u03bc : Measure \u03b1} (f : \u03b1 \u2192 \u03b2) : AEStronglyMeasurable f \u03bc", "start": [1173, 1], "end": [1176, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.aestronglyMeasurable_zero_measure", "code": "@[simp]\ntheorem aestronglyMeasurable_zero_measure [MeasurableSpace \u03b1] [TopologicalSpace \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    AEStronglyMeasurable f (0 : Measure \u03b1)", "start": [1179, 1], "end": [1184, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SimpleFunc.aestronglyMeasurable", "code": "@[measurability]\ntheorem SimpleFunc.aestronglyMeasurable {_ : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} [TopologicalSpace \u03b2]\n    (f : \u03b1 \u2192\u209b \u03b2) : AEStronglyMeasurable f \u03bc", "start": [1187, 1], "end": [1190, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.mk", "code": "protected noncomputable def mk (f : \u03b1 \u2192 \u03b2) (hf : AEStronglyMeasurable f \u03bc) : \u03b1 \u2192 \u03b2 :=\n  hf.choose", "start": [1200, 1], "end": [1203, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.stronglyMeasurable_mk", "code": "theorem stronglyMeasurable_mk (hf : AEStronglyMeasurable f \u03bc) : StronglyMeasurable (hf.mk f)", "start": [1206, 1], "end": [1207, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.measurable_mk", "code": "theorem measurable_mk [PseudoMetrizableSpace \u03b2] [MeasurableSpace \u03b2] [BorelSpace \u03b2]\n    (hf : AEStronglyMeasurable f \u03bc) : Measurable (hf.mk f)", "start": [1210, 1], "end": [1212, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.ae_eq_mk", "code": "theorem ae_eq_mk (hf : AEStronglyMeasurable f \u03bc) : f =\u1d50[\u03bc] hf.mk f", "start": [1215, 1], "end": [1216, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.aemeasurable", "code": "@[aesop 5% apply (rule_sets [Measurable])]\nprotected theorem aemeasurable {\u03b2} [MeasurableSpace \u03b2] [TopologicalSpace \u03b2]\n    [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : AEStronglyMeasurable f \u03bc) :\n    AEMeasurable f \u03bc", "start": [1219, 1], "end": [1223, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.congr", "code": "theorem congr (hf : AEStronglyMeasurable f \u03bc) (h : f =\u1d50[\u03bc] g) : AEStronglyMeasurable g \u03bc", "start": [1228, 1], "end": [1229, 64], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_congr", "code": "theorem _root_.aestronglyMeasurable_congr (h : f =\u1d50[\u03bc] g) :\n    AEStronglyMeasurable f \u03bc \u2194 AEStronglyMeasurable g \u03bc", "start": [1232, 1], "end": [1234, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.mono_measure", "code": "theorem mono_measure {\u03bd : Measure \u03b1} (hf : AEStronglyMeasurable f \u03bc) (h : \u03bd \u2264 \u03bc) :\n    AEStronglyMeasurable f \u03bd", "start": [1237, 1], "end": [1239, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.mono'", "code": "protected theorem mono' {\u03bd : Measure \u03b1} (h : AEStronglyMeasurable f \u03bc) (h' : \u03bd \u226a \u03bc) :\n    AEStronglyMeasurable f \u03bd", "start": [1242, 1], "end": [1244, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.mono_set", "code": "theorem mono_set {s t} (h : s \u2286 t) (ht : AEStronglyMeasurable f (\u03bc.restrict t)) :\n    AEStronglyMeasurable f (\u03bc.restrict s)", "start": [1247, 1], "end": [1249, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.restrict", "code": "protected theorem restrict (hfm : AEStronglyMeasurable f \u03bc) {s} :\n    AEStronglyMeasurable f (\u03bc.restrict s)", "start": [1252, 1], "end": [1254, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.ae_mem_imp_eq_mk", "code": "theorem ae_mem_imp_eq_mk {s} (h : AEStronglyMeasurable f (\u03bc.restrict s)) :\n    \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 f x = h.mk f x", "start": [1257, 1], "end": [1259, 35], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp_aestronglyMeasurable", "code": "theorem _root_.Continuous.comp_aestronglyMeasurable {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : Continuous g)\n    (hf : AEStronglyMeasurable f \u03bc) : AEStronglyMeasurable (fun x => g (f x)) \u03bc", "start": [1262, 1], "end": [1266, 96], "kind": "commanddeclaration"}, {"full_name": "Continuous.aestronglyMeasurable", "code": "theorem _root_.Continuous.aestronglyMeasurable [TopologicalSpace \u03b1] [OpensMeasurableSpace \u03b1]\n    [PseudoMetrizableSpace \u03b2] [SecondCountableTopologyEither \u03b1 \u03b2] (hf : Continuous f) :\n    AEStronglyMeasurable f \u03bc", "start": [1269, 1], "end": [1274, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.prod_mk", "code": "protected theorem prod_mk {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} (hf : AEStronglyMeasurable f \u03bc)\n    (hg : AEStronglyMeasurable g \u03bc) : AEStronglyMeasurable (fun x => (f x, g x)) \u03bc", "start": [1277, 1], "end": [1280, 37], "kind": "commanddeclaration"}, {"full_name": "Measurable.aestronglyMeasurable", "code": "@[aesop unsafe 30% apply (rule_sets [Measurable])]\ntheorem _root_.Measurable.aestronglyMeasurable {_ : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    [MeasurableSpace \u03b2] [PseudoMetrizableSpace \u03b2] [SecondCountableTopology \u03b2]\n    [OpensMeasurableSpace \u03b2] (hf : Measurable f) : AEStronglyMeasurable f \u03bc", "start": [1283, 1], "end": [1288, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.mul", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\nprotected theorem mul [Mul \u03b2] [ContinuousMul \u03b2] (hf : AEStronglyMeasurable f \u03bc)\n    (hg : AEStronglyMeasurable g \u03bc) : AEStronglyMeasurable (f * g) \u03bc", "start": [1293, 1], "end": [1297, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.mul_const", "code": "@[to_additive (attr := measurability)]\nprotected theorem mul_const [Mul \u03b2] [ContinuousMul \u03b2] (hf : AEStronglyMeasurable f \u03bc) (c : \u03b2) :\n    AEStronglyMeasurable (fun x => f x * c) \u03bc", "start": [1301, 1], "end": [1304, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.const_mul", "code": "@[to_additive (attr := measurability)]\nprotected theorem const_mul [Mul \u03b2] [ContinuousMul \u03b2] (hf : AEStronglyMeasurable f \u03bc) (c : \u03b2) :\n    AEStronglyMeasurable (fun x => c * f x) \u03bc", "start": [1308, 1], "end": [1311, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.inv", "code": "@[to_additive (attr := measurability)]\nprotected theorem inv [Inv \u03b2] [ContinuousInv \u03b2] (hf : AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable f\u207b\u00b9 \u03bc", "start": [1315, 1], "end": [1318, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.div", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\nprotected theorem div [Group \u03b2] [TopologicalGroup \u03b2] (hf : AEStronglyMeasurable f \u03bc)\n    (hg : AEStronglyMeasurable g \u03bc) : AEStronglyMeasurable (f / g) \u03bc", "start": [1322, 1], "end": [1326, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.smul", "code": "@[to_additive (attr := aesop safe 20 apply (rule_sets [Measurable]))]\nprotected theorem smul {\ud835\udd5c} [TopologicalSpace \ud835\udd5c] [SMul \ud835\udd5c \u03b2] [ContinuousSMul \ud835\udd5c \u03b2] {f : \u03b1 \u2192 \ud835\udd5c}\n    {g : \u03b1 \u2192 \u03b2} (hf : AEStronglyMeasurable f \u03bc) (hg : AEStronglyMeasurable g \u03bc) :\n    AEStronglyMeasurable (fun x => f x \u2022 g x) \u03bc", "start": [1330, 1], "end": [1334, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.const_smul", "code": "@[measurability]\nprotected theorem const_smul {\ud835\udd5c} [SMul \ud835\udd5c \u03b2] [ContinuousConstSMul \ud835\udd5c \u03b2]\n    (hf : AEStronglyMeasurable f \u03bc) (c : \ud835\udd5c) : AEStronglyMeasurable (c \u2022 f) \u03bc", "start": [1338, 1], "end": [1341, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.const_smul'", "code": "@[measurability]\nprotected theorem const_smul' {\ud835\udd5c} [SMul \ud835\udd5c \u03b2] [ContinuousConstSMul \ud835\udd5c \u03b2]\n    (hf : AEStronglyMeasurable f \u03bc) (c : \ud835\udd5c) : AEStronglyMeasurable (fun x => c \u2022 f x) \u03bc", "start": [1344, 1], "end": [1347, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.smul_const", "code": "@[to_additive (attr := measurability)]\nprotected theorem smul_const {\ud835\udd5c} [TopologicalSpace \ud835\udd5c] [SMul \ud835\udd5c \u03b2] [ContinuousSMul \ud835\udd5c \u03b2] {f : \u03b1 \u2192 \ud835\udd5c}\n    (hf : AEStronglyMeasurable f \u03bc) (c : \u03b2) : AEStronglyMeasurable (fun x => f x \u2022 c) \u03bc", "start": [1350, 1], "end": [1353, 84], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.sup", "code": "@[aesop safe 20 apply (rule_sets [Measurable])]\nprotected theorem sup [SemilatticeSup \u03b2] [ContinuousSup \u03b2] (hf : AEStronglyMeasurable f \u03bc)\n    (hg : AEStronglyMeasurable g \u03bc) : AEStronglyMeasurable (f \u2294 g) \u03bc", "start": [1361, 1], "end": [1365, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.inf", "code": "@[aesop safe 20 apply (rule_sets [Measurable])]\nprotected theorem inf [SemilatticeInf \u03b2] [ContinuousInf \u03b2] (hf : AEStronglyMeasurable f \u03bc)\n    (hg : AEStronglyMeasurable g \u03bc) : AEStronglyMeasurable (f \u2293 g) \u03bc", "start": [1368, 1], "end": [1372, 33], "kind": "commanddeclaration"}, {"full_name": "List.aestronglyMeasurable_prod'", "code": "@[to_additive (attr := measurability)]\ntheorem _root_.List.aestronglyMeasurable_prod' (l : List (\u03b1 \u2192 M))\n    (hl : \u2200 f \u2208 l, AEStronglyMeasurable f \u03bc) : AEStronglyMeasurable l.prod \u03bc", "start": [1386, 1], "end": [1392, 28], "kind": "commanddeclaration"}, {"full_name": "List.aestronglyMeasurable_prod", "code": "@[to_additive (attr := measurability)]\ntheorem _root_.List.aestronglyMeasurable_prod\n    (l : List (\u03b1 \u2192 M)) (hl : \u2200 f \u2208 l, AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (fun x => (l.map fun f : \u03b1 \u2192 M => f x).prod) \u03bc", "start": [1396, 1], "end": [1400, 74], "kind": "commanddeclaration"}, {"full_name": "Multiset.aestronglyMeasurable_prod'", "code": "@[to_additive (attr := measurability)]\ntheorem _root_.Multiset.aestronglyMeasurable_prod' (l : Multiset (\u03b1 \u2192 M))\n    (hl : \u2200 f \u2208 l, AEStronglyMeasurable f \u03bc) : AEStronglyMeasurable l.prod \u03bc", "start": [1410, 1], "end": [1414, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.aestronglyMeasurable_prod", "code": "@[to_additive (attr := measurability)]\ntheorem _root_.Multiset.aestronglyMeasurable_prod (s : Multiset (\u03b1 \u2192 M))\n    (hs : \u2200 f \u2208 s, AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (fun x => (s.map fun f : \u03b1 \u2192 M => f x).prod) \u03bc", "start": [1418, 1], "end": [1422, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.aestronglyMeasurable_prod'", "code": "@[to_additive (attr := measurability)]\ntheorem _root_.Finset.aestronglyMeasurable_prod' {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1 \u2192 M} (s : Finset \u03b9)\n    (hf : \u2200 i \u2208 s, AEStronglyMeasurable (f i) \u03bc) : AEStronglyMeasurable (\u220f i in s, f i) \u03bc", "start": [1426, 1], "end": [1431, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.aestronglyMeasurable_prod", "code": "@[to_additive (attr := measurability)]\ntheorem _root_.Finset.aestronglyMeasurable_prod {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1 \u2192 M} (s : Finset \u03b9)\n    (hf : \u2200 i \u2208 s, AEStronglyMeasurable (f i) \u03bc) :\n    AEStronglyMeasurable (fun a => \u220f i in s, f i a) \u03bc", "start": [1435, 1], "end": [1439, 73], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.aestronglyMeasurable", "code": "@[aesop 90% apply (rule_sets [Measurable])]\ntheorem _root_.AEMeasurable.aestronglyMeasurable [PseudoMetrizableSpace \u03b2] [OpensMeasurableSpace \u03b2]\n    [SecondCountableTopology \u03b2] (hf : AEMeasurable f \u03bc) : AEStronglyMeasurable f \u03bc", "start": [1449, 1], "end": [1453, 62], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_id", "code": "@[measurability]\ntheorem _root_.aestronglyMeasurable_id {\u03b1 : Type*} [TopologicalSpace \u03b1] [PseudoMetrizableSpace \u03b1]\n    {_ : MeasurableSpace \u03b1} [OpensMeasurableSpace \u03b1] [SecondCountableTopology \u03b1] {\u03bc : Measure \u03b1} :\n    AEStronglyMeasurable (id : \u03b1 \u2192 \u03b1) \u03bc", "start": [1456, 1], "end": [1460, 39], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_iff_aemeasurable", "code": "theorem _root_.aestronglyMeasurable_iff_aemeasurable [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]\n    [SecondCountableTopology \u03b2] : AEStronglyMeasurable f \u03bc \u2194 AEMeasurable f \u03bc", "start": [1463, 1], "end": [1466, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.dist", "code": "@[aesop safe 20 apply (rule_sets [Measurable])]\nprotected theorem dist {\u03b2 : Type*} [PseudoMetricSpace \u03b2] {f g : \u03b1 \u2192 \u03b2}\n    (hf : AEStronglyMeasurable f \u03bc) (hg : AEStronglyMeasurable g \u03bc) :\n    AEStronglyMeasurable (fun x => dist (f x) (g x)) \u03bc", "start": [1471, 1], "end": [1475, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.norm", "code": "@[measurability]\nprotected theorem norm {\u03b2 : Type*} [SeminormedAddCommGroup \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : AEStronglyMeasurable f \u03bc) : AEStronglyMeasurable (fun x => \u2016f x\u2016) \u03bc", "start": [1478, 1], "end": [1481, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.nnnorm", "code": "@[measurability]\nprotected theorem nnnorm {\u03b2 : Type*} [SeminormedAddCommGroup \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : AEStronglyMeasurable f \u03bc) : AEStronglyMeasurable (fun x => \u2016f x\u2016\u208a) \u03bc", "start": [1484, 1], "end": [1487, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.ennnorm", "code": "@[measurability]\nprotected theorem ennnorm {\u03b2 : Type*} [SeminormedAddCommGroup \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : AEStronglyMeasurable f \u03bc) : AEMeasurable (fun a => (\u2016f a\u2016\u208a : \u211d\u22650\u221e)) \u03bc", "start": [1490, 1], "end": [1493, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.edist", "code": "@[aesop safe 20 apply (rule_sets [Measurable])]\nprotected theorem edist {\u03b2 : Type*} [SeminormedAddCommGroup \u03b2] {f g : \u03b1 \u2192 \u03b2}\n    (hf : AEStronglyMeasurable f \u03bc) (hg : AEStronglyMeasurable g \u03bc) :\n    AEMeasurable (fun a => edist (f a) (g a)) \u03bc", "start": [1496, 1], "end": [1500, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.real_toNNReal", "code": "@[measurability]\nprotected theorem real_toNNReal {f : \u03b1 \u2192 \u211d} (hf : AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (fun x => (f x).toNNReal) \u03bc", "start": [1503, 1], "end": [1506, 56], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_indicator_iff", "code": "theorem _root_.aestronglyMeasurable_indicator_iff [Zero \u03b2] {s : Set \u03b1} (hs : MeasurableSet s) :\n    AEStronglyMeasurable (indicator s f) \u03bc \u2194 AEStronglyMeasurable f (\u03bc.restrict s)", "start": [1509, 1], "end": [1520, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.indicator", "code": "@[measurability]\nprotected theorem indicator [Zero \u03b2] (hfm : AEStronglyMeasurable f \u03bc) {s : Set \u03b1}\n    (hs : MeasurableSet s) : AEStronglyMeasurable (s.indicator f) \u03bc", "start": [1523, 1], "end": [1526, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.nullMeasurableSet_eq_fun", "code": "theorem nullMeasurableSet_eq_fun {E} [TopologicalSpace E] [MetrizableSpace E] {f g : \u03b1 \u2192 E}\n    (hf : AEStronglyMeasurable f \u03bc) (hg : AEStronglyMeasurable g \u03bc) :\n    NullMeasurableSet { x | f x = g x } \u03bc", "start": [1529, 1], "end": [1537, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.nullMeasurableSet_lt", "code": "theorem nullMeasurableSet_lt [LinearOrder \u03b2] [OrderClosedTopology \u03b2] [PseudoMetrizableSpace \u03b2]\n    {f g : \u03b1 \u2192 \u03b2} (hf : AEStronglyMeasurable f \u03bc) (hg : AEStronglyMeasurable g \u03bc) :\n    NullMeasurableSet { a | f a < g a } \u03bc", "start": [1540, 1], "end": [1547, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.nullMeasurableSet_le", "code": "theorem nullMeasurableSet_le [Preorder \u03b2] [OrderClosedTopology \u03b2] [PseudoMetrizableSpace \u03b2]\n    {f g : \u03b1 \u2192 \u03b2} (hf : AEStronglyMeasurable f \u03bc) (hg : AEStronglyMeasurable g \u03bc) :\n    NullMeasurableSet { a | f a \u2264 g a } \u03bc", "start": [1550, 1], "end": [1557, 23], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_of_aestronglyMeasurable_trim", "code": "theorem _root_.aestronglyMeasurable_of_aestronglyMeasurable_trim {\u03b1} {m m0 : MeasurableSpace \u03b1}\n    {\u03bc : Measure \u03b1} (hm : m \u2264 m0) {f : \u03b1 \u2192 \u03b2} (hf : AEStronglyMeasurable f (\u03bc.trim hm)) :\n    AEStronglyMeasurable f \u03bc", "start": [1560, 1], "end": [1563, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.comp_aemeasurable", "code": "theorem comp_aemeasurable {\u03b3 : Type*} {_ : MeasurableSpace \u03b3} {_ : MeasurableSpace \u03b1} {f : \u03b3 \u2192 \u03b1}\n    {\u03bc : Measure \u03b3} (hg : AEStronglyMeasurable g (Measure.map f \u03bc)) (hf : AEMeasurable f \u03bc) :\n    AEStronglyMeasurable (g \u2218 f) \u03bc", "start": [1566, 1], "end": [1570, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.comp_measurable", "code": "theorem comp_measurable {\u03b3 : Type*} {_ : MeasurableSpace \u03b3} {_ : MeasurableSpace \u03b1} {f : \u03b3 \u2192 \u03b1}\n    {\u03bc : Measure \u03b3} (hg : AEStronglyMeasurable g (Measure.map f \u03bc)) (hf : Measurable f) :\n    AEStronglyMeasurable (g \u2218 f) \u03bc", "start": [1573, 1], "end": [1576, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.comp_quasiMeasurePreserving", "code": "theorem comp_quasiMeasurePreserving {\u03b3 : Type*} {_ : MeasurableSpace \u03b3} {_ : MeasurableSpace \u03b1}\n    {f : \u03b3 \u2192 \u03b1} {\u03bc : Measure \u03b3} {\u03bd : Measure \u03b1} (hg : AEStronglyMeasurable g \u03bd)\n    (hf : QuasiMeasurePreserving f \u03bc \u03bd) : AEStronglyMeasurable (g \u2218 f) \u03bc", "start": [1579, 1], "end": [1582, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.comp_measurePreserving", "code": "theorem comp_measurePreserving {\u03b3 : Type*} {_ : MeasurableSpace \u03b3} {_ : MeasurableSpace \u03b1}\n    {f : \u03b3 \u2192 \u03b1} {\u03bc : Measure \u03b3} {\u03bd : Measure \u03b1} (hg : AEStronglyMeasurable g \u03bd)\n    (hf : MeasurePreserving f \u03bc \u03bd) : AEStronglyMeasurable (g \u2218 f) \u03bc", "start": [1585, 1], "end": [1588, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.isSeparable_ae_range", "code": "theorem isSeparable_ae_range (hf : AEStronglyMeasurable f \u03bc) :\n    \u2203 t : Set \u03b2, IsSeparable t \u2227 \u2200\u1d50 x \u2202\u03bc, f x \u2208 t", "start": [1590, 1], "end": [1594, 12], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_iff_aemeasurable_separable", "code": "theorem _root_.aestronglyMeasurable_iff_aemeasurable_separable [PseudoMetrizableSpace \u03b2]\n    [MeasurableSpace \u03b2] [BorelSpace \u03b2] :\n    AEStronglyMeasurable f \u03bc \u2194\n      AEMeasurable f \u03bc \u2227 \u2203 t : Set \u03b2, IsSeparable t \u2227 \u2200\u1d50 x \u2202\u03bc, f x \u2208 t", "start": [1597, 1], "end": [1612, 80], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_iff_nullMeasurable_separable", "code": "theorem _root_.aestronglyMeasurable_iff_nullMeasurable_separable [PseudoMetrizableSpace \u03b2]\n    [MeasurableSpace \u03b2] [BorelSpace \u03b2] :\n    AEStronglyMeasurable f \u03bc \u2194\n      NullMeasurable f \u03bc \u2227 \u2203 t : Set \u03b2, IsSeparable t \u2227 \u2200\u1d50 x \u2202\u03bc, f x \u2208 t", "start": [1615, 1], "end": [1621, 73], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.aestronglyMeasurable_map_iff", "code": "theorem _root_.MeasurableEmbedding.aestronglyMeasurable_map_iff {\u03b3 : Type*}\n    {m\u03b3 : MeasurableSpace \u03b3} {m\u03b1 : MeasurableSpace \u03b1} {f : \u03b3 \u2192 \u03b1} {\u03bc : Measure \u03b3}\n    (hf : MeasurableEmbedding f) {g : \u03b1 \u2192 \u03b2} :\n    AEStronglyMeasurable g (Measure.map f \u03bc) \u2194 AEStronglyMeasurable (g \u2218 f) \u03bc", "start": [1623, 1], "end": [1630, 40], "kind": "commanddeclaration"}, {"full_name": "Embedding.aestronglyMeasurable_comp_iff", "code": "theorem _root_.Embedding.aestronglyMeasurable_comp_iff [PseudoMetrizableSpace \u03b2]\n    [PseudoMetrizableSpace \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : Embedding g) :\n    AEStronglyMeasurable (fun x => g (f x)) \u03bc \u2194 AEStronglyMeasurable f \u03bc", "start": [1633, 1], "end": [1652, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.aestronglyMeasurable_comp_iff", "code": "theorem _root_.MeasureTheory.MeasurePreserving.aestronglyMeasurable_comp_iff {\u03b2 : Type*}\n    {f : \u03b1 \u2192 \u03b2} {m\u03b1 : MeasurableSpace \u03b1} {\u03bca : Measure \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {\u03bcb : Measure \u03b2}\n    (hf : MeasurePreserving f \u03bca \u03bcb) (h\u2082 : MeasurableEmbedding f) {g : \u03b2 \u2192 \u03b3} :\n    AEStronglyMeasurable (g \u2218 f) \u03bca \u2194 AEStronglyMeasurable g \u03bcb", "start": [1655, 1], "end": [1659, 52], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_of_tendsto_ae", "code": "theorem _root_.aestronglyMeasurable_of_tendsto_ae {\u03b9 : Type*} [PseudoMetrizableSpace \u03b2]\n    (u : Filter \u03b9) [NeBot u] [IsCountablyGenerated u] {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 i, AEStronglyMeasurable (f i) \u03bc) (lim : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) u (\ud835\udcdd (g x))) :\n    AEStronglyMeasurable g \u03bc", "start": [1662, 1], "end": [1680, 15], "kind": "commanddeclaration"}, {"full_name": "exists_stronglyMeasurable_limit_of_tendsto_ae", "code": "theorem _root_.exists_stronglyMeasurable_limit_of_tendsto_ae [PseudoMetrizableSpace \u03b2]\n    {f : \u2115 \u2192 \u03b1 \u2192 \u03b2} (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc)\n    (h_ae_tendsto : \u2200\u1d50 x \u2202\u03bc, \u2203 l : \u03b2, Tendsto (fun n => f n x) atTop (\ud835\udcdd l)) :\n    \u2203 (f_lim : \u03b1 \u2192 \u03b2) (hf_lim_meas : StronglyMeasurable f_lim),\n      \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (f_lim x))", "start": [1683, 1], "end": [1697, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.sum_measure", "code": "theorem sum_measure [PseudoMetrizableSpace \u03b2] {m : MeasurableSpace \u03b1} {\u03bc : \u03b9 \u2192 Measure \u03b1}\n    (h : \u2200 i, AEStronglyMeasurable f (\u03bc i)) : AEStronglyMeasurable f (Measure.sum \u03bc)", "start": [1700, 1], "end": [1713, 16], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_sum_measure_iff", "code": "@[simp]\ntheorem _root_.aestronglyMeasurable_sum_measure_iff [PseudoMetrizableSpace \u03b2]\n    {_m : MeasurableSpace \u03b1} {\u03bc : \u03b9 \u2192 Measure \u03b1} :\n    AEStronglyMeasurable f (sum \u03bc) \u2194 \u2200 i, AEStronglyMeasurable f (\u03bc i)", "start": [1716, 1], "end": [1720, 64], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_add_measure_iff", "code": "@[simp]\ntheorem _root_.aestronglyMeasurable_add_measure_iff [PseudoMetrizableSpace \u03b2] {\u03bd : Measure \u03b1} :\n    AEStronglyMeasurable f (\u03bc + \u03bd) \u2194 AEStronglyMeasurable f \u03bc \u2227 AEStronglyMeasurable f \u03bd", "start": [1723, 1], "end": [1727, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.add_measure", "code": "@[measurability]\ntheorem add_measure [PseudoMetrizableSpace \u03b2] {\u03bd : Measure \u03b1} {f : \u03b1 \u2192 \u03b2}\n    (h\u03bc : AEStronglyMeasurable f \u03bc) (h\u03bd : AEStronglyMeasurable f \u03bd) :\n    AEStronglyMeasurable f (\u03bc + \u03bd)", "start": [1730, 1], "end": [1734, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.iUnion", "code": "@[measurability]\nprotected theorem iUnion [PseudoMetrizableSpace \u03b2] {s : \u03b9 \u2192 Set \u03b1}\n    (h : \u2200 i, AEStronglyMeasurable f (\u03bc.restrict (s i))) :\n    AEStronglyMeasurable f (\u03bc.restrict (\u22c3 i, s i))", "start": [1737, 1], "end": [1741, 53], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_iUnion_iff", "code": "@[simp]\ntheorem _root_.aestronglyMeasurable_iUnion_iff [PseudoMetrizableSpace \u03b2] {s : \u03b9 \u2192 Set \u03b1} :\n    AEStronglyMeasurable f (\u03bc.restrict (\u22c3 i, s i)) \u2194\n      \u2200 i, AEStronglyMeasurable f (\u03bc.restrict (s i))", "start": [1744, 1], "end": [1749, 33], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_union_iff", "code": "@[simp]\ntheorem _root_.aestronglyMeasurable_union_iff [PseudoMetrizableSpace \u03b2] {s t : Set \u03b1} :\n    AEStronglyMeasurable f (\u03bc.restrict (s \u222a t)) \u2194\n      AEStronglyMeasurable f (\u03bc.restrict s) \u2227 AEStronglyMeasurable f (\u03bc.restrict t)", "start": [1752, 1], "end": [1756, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.aestronglyMeasurable_uIoc_iff", "code": "theorem aestronglyMeasurable_uIoc_iff [LinearOrder \u03b1] [PseudoMetrizableSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {a b : \u03b1} :\n    AEStronglyMeasurable f (\u03bc.restrict <| uIoc a b) \u2194\n      AEStronglyMeasurable f (\u03bc.restrict <| Ioc a b) \u2227\n        AEStronglyMeasurable f (\u03bc.restrict <| Ioc b a)", "start": [1759, 1], "end": [1764, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.smul_measure", "code": "@[measurability]\ntheorem smul_measure {R : Type*} [Monoid R] [DistribMulAction R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]\n    (h : AEStronglyMeasurable f \u03bc) (c : R) : AEStronglyMeasurable f (c \u2022 \u03bc)", "start": [1768, 1], "end": [1771, 66], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_smul_const_iff", "code": "theorem _root_.aestronglyMeasurable_smul_const_iff {f : \u03b1 \u2192 \ud835\udd5c} {c : E} (hc : c \u2260 0) :\n    AEStronglyMeasurable (fun x => f x \u2022 c) \u03bc \u2194 AEStronglyMeasurable f \u03bc", "start": [1780, 1], "end": [1782, 75], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_const_smul_iff", "code": "theorem _root_.aestronglyMeasurable_const_smul_iff (c : G) :\n    AEStronglyMeasurable (fun x => c \u2022 f x) \u03bc \u2194 AEStronglyMeasurable f \u03bc", "start": [1794, 1], "end": [1796, 92], "kind": "commanddeclaration"}, {"full_name": "IsUnit.aestronglyMeasurable_const_smul_iff", "code": "nonrec theorem _root_.IsUnit.aestronglyMeasurable_const_smul_iff {c : M} (hc : IsUnit c) :\n    AEStronglyMeasurable (fun x => c \u2022 f x) \u03bc \u2194 AEStronglyMeasurable f \u03bc", "start": [1799, 1], "end": [1802, 45], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_const_smul_iff\u2080", "code": "theorem _root_.aestronglyMeasurable_const_smul_iff\u2080 {c : G\u2080} (hc : c \u2260 0) :\n    AEStronglyMeasurable (fun x => c \u2022 f x) \u03bc \u2194 AEStronglyMeasurable f \u03bc", "start": [1805, 1], "end": [1807, 56], "kind": "commanddeclaration"}, {"full_name": "StronglyMeasurable.apply_continuousLinearMap", "code": "theorem _root_.StronglyMeasurable.apply_continuousLinearMap {_m : MeasurableSpace \u03b1}\n    {\u03c6 : \u03b1 \u2192 F \u2192L[\ud835\udd5c] E}\n    (h\u03c6 : StronglyMeasurable \u03c6) (v : F) : StronglyMeasurable fun a => \u03c6 a v", "start": [1822, 1], "end": [1825, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.apply_continuousLinearMap", "code": "@[measurability]\ntheorem apply_continuousLinearMap {\u03c6 : \u03b1 \u2192 F \u2192L[\ud835\udd5c] E} (h\u03c6 : AEStronglyMeasurable \u03c6 \u03bc) (v : F) :\n    AEStronglyMeasurable (fun a => \u03c6 a v) \u03bc", "start": [1828, 1], "end": [1831, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.aestronglyMeasurable_comp\u2082", "code": "theorem _root_.ContinuousLinearMap.aestronglyMeasurable_comp\u2082 (L : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) {f : \u03b1 \u2192 E}\n    {g : \u03b1 \u2192 F} (hf : AEStronglyMeasurable f \u03bc) (hg : AEStronglyMeasurable g \u03bc) :\n    AEStronglyMeasurable (fun x => L (f x) (g x)) \u03bc", "start": [1834, 1], "end": [1837, 59], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_withDensity_iff", "code": "theorem _root_.aestronglyMeasurable_withDensity_iff {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace \u211d E] {f : \u03b1 \u2192 \u211d\u22650} (hf : Measurable f) {g : \u03b1 \u2192 E} :\n    AEStronglyMeasurable g (\u03bc.withDensity fun x => (f x : \u211d\u22650\u221e)) \u2194\n      AEStronglyMeasurable (fun x => (f x : \u211d) \u2022 g x) \u03bc", "start": [1843, 1], "end": [1866, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.mk", "code": "protected noncomputable def mk (f : \u03b1 \u2192 \u03b2) (hf : AEFinStronglyMeasurable f \u03bc) : \u03b1 \u2192 \u03b2 :=\n  hf.choose", "start": [1882, 1], "end": [1885, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.finStronglyMeasurable_mk", "code": "theorem finStronglyMeasurable_mk (hf : AEFinStronglyMeasurable f \u03bc) :\n    FinStronglyMeasurable (hf.mk f) \u03bc", "start": [1888, 1], "end": [1890, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.ae_eq_mk", "code": "theorem ae_eq_mk (hf : AEFinStronglyMeasurable f \u03bc) : f =\u1d50[\u03bc] hf.mk f", "start": [1893, 1], "end": [1894, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.aemeasurable", "code": "@[aesop 10% apply (rule_sets [Measurable])]\nprotected theorem aemeasurable {\u03b2} [Zero \u03b2] [MeasurableSpace \u03b2] [TopologicalSpace \u03b2]\n    [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : AEFinStronglyMeasurable f \u03bc) :\n    AEMeasurable f \u03bc", "start": [1898, 1], "end": [1902, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.mul", "code": "@[aesop safe 20 (rule_sets [Measurable])]\nprotected theorem mul [MonoidWithZero \u03b2] [ContinuousMul \u03b2] (hf : AEFinStronglyMeasurable f \u03bc)\n    (hg : AEFinStronglyMeasurable g \u03bc) : AEFinStronglyMeasurable (f * g) \u03bc", "start": [1910, 1], "end": [1914, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.add", "code": "@[aesop safe 20 (rule_sets [Measurable])]\nprotected theorem add [AddMonoid \u03b2] [ContinuousAdd \u03b2] (hf : AEFinStronglyMeasurable f \u03bc)\n    (hg : AEFinStronglyMeasurable g \u03bc) : AEFinStronglyMeasurable (f + g) \u03bc", "start": [1917, 1], "end": [1921, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.neg", "code": "@[measurability]\nprotected theorem neg [AddGroup \u03b2] [TopologicalAddGroup \u03b2] (hf : AEFinStronglyMeasurable f \u03bc) :\n    AEFinStronglyMeasurable (-f) \u03bc", "start": [1924, 1], "end": [1927, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.sub", "code": "@[measurability]\nprotected theorem sub [AddGroup \u03b2] [ContinuousSub \u03b2] (hf : AEFinStronglyMeasurable f \u03bc)\n    (hg : AEFinStronglyMeasurable g \u03bc) : AEFinStronglyMeasurable (f - g) \u03bc", "start": [1930, 1], "end": [1934, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.const_smul", "code": "@[measurability]\nprotected theorem const_smul {\ud835\udd5c} [TopologicalSpace \ud835\udd5c] [AddMonoid \u03b2] [Monoid \ud835\udd5c]\n    [DistribMulAction \ud835\udd5c \u03b2] [ContinuousSMul \ud835\udd5c \u03b2] (hf : AEFinStronglyMeasurable f \u03bc) (c : \ud835\udd5c) :\n    AEFinStronglyMeasurable (c \u2022 f) \u03bc", "start": [1937, 1], "end": [1941, 84], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.sup", "code": "@[aesop safe 20 (rule_sets [Measurable])]\nprotected theorem sup [SemilatticeSup \u03b2] [ContinuousSup \u03b2] (hf : AEFinStronglyMeasurable f \u03bc)\n    (hg : AEFinStronglyMeasurable g \u03bc) : AEFinStronglyMeasurable (f \u2294 g) \u03bc", "start": [1950, 1], "end": [1954, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.inf", "code": "@[aesop safe 20 (rule_sets [Measurable])]\nprotected theorem inf [SemilatticeInf \u03b2] [ContinuousInf \u03b2] (hf : AEFinStronglyMeasurable f \u03bc)\n    (hg : AEFinStronglyMeasurable g \u03bc) : AEFinStronglyMeasurable (f \u2293 g) \u03bc", "start": [1957, 1], "end": [1961, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.exists_set_sigmaFinite", "code": "theorem exists_set_sigmaFinite (hf : AEFinStronglyMeasurable f \u03bc) :\n    \u2203 t, MeasurableSet t \u2227 f =\u1d50[\u03bc.restrict t\u1d9c] 0 \u2227 SigmaFinite (\u03bc.restrict t)", "start": [1968, 1], "end": [1975, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.sigmaFiniteSet", "code": "def sigmaFiniteSet (hf : AEFinStronglyMeasurable f \u03bc) : Set \u03b1 :=\n  hf.exists_set_sigmaFinite.choose", "start": [1978, 1], "end": [1980, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.measurableSet", "code": "protected theorem measurableSet (hf : AEFinStronglyMeasurable f \u03bc) :\n    MeasurableSet hf.sigmaFiniteSet", "start": [1983, 1], "end": [1985, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.ae_eq_zero_compl", "code": "theorem ae_eq_zero_compl (hf : AEFinStronglyMeasurable f \u03bc) :\n    f =\u1d50[\u03bc.restrict hf.sigmaFiniteSet\u1d9c] 0", "start": [1988, 1], "end": [1990, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEFinStronglyMeasurable.sigmaFinite_restrict", "code": "instance sigmaFinite_restrict (hf : AEFinStronglyMeasurable f \u03bc) :\n    SigmaFinite (\u03bc.restrict hf.sigmaFiniteSet) :=\n  hf.exists_set_sigmaFinite.choose_spec.2.2", "start": [1993, 1], "end": [1995, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.finStronglyMeasurable_iff_measurable", "code": "theorem finStronglyMeasurable_iff_measurable {_m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1)\n    [SigmaFinite \u03bc] : FinStronglyMeasurable f \u03bc \u2194 Measurable f", "start": [2006, 1], "end": [2010, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.finStronglyMeasurable_of_measurable", "code": "@[aesop 90% apply (rule_sets [Measurable])]\ntheorem finStronglyMeasurable_of_measurable {_m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1)\n    [SigmaFinite \u03bc] (hf : Measurable f) : FinStronglyMeasurable f \u03bc", "start": [2013, 1], "end": [2018, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.aefinStronglyMeasurable_iff_aemeasurable", "code": "theorem aefinStronglyMeasurable_iff_aemeasurable {_m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1)\n    [SigmaFinite \u03bc] : AEFinStronglyMeasurable f \u03bc \u2194 AEMeasurable f \u03bc", "start": [2020, 1], "end": [2024, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.aefinStronglyMeasurable_of_aemeasurable", "code": "@[aesop 90% apply (rule_sets [Measurable])]\ntheorem aefinStronglyMeasurable_of_aemeasurable {_m0 : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1)\n    [SigmaFinite \u03bc] (hf : AEMeasurable f \u03bc) : AEFinStronglyMeasurable f \u03bc", "start": [2027, 1], "end": [2032, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measurable_uncurry_of_continuous_of_measurable", "code": "theorem measurable_uncurry_of_continuous_of_measurable {\u03b1 \u03b2 \u03b9 : Type*} [TopologicalSpace \u03b9]\n    [MetrizableSpace \u03b9] [MeasurableSpace \u03b9] [SecondCountableTopology \u03b9] [OpensMeasurableSpace \u03b9]\n    {m\u03b2 : MeasurableSpace \u03b2} [TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]\n    {m : MeasurableSpace \u03b1} {u : \u03b9 \u2192 \u03b1 \u2192 \u03b2} (hu_cont : \u2200 x, Continuous fun i => u i x)\n    (h : \u2200 i, Measurable (u i)) : Measurable (Function.uncurry u)", "start": [2036, 1], "end": [2065, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.stronglyMeasurable_uncurry_of_continuous_of_stronglyMeasurable", "code": "theorem stronglyMeasurable_uncurry_of_continuous_of_stronglyMeasurable {\u03b1 \u03b2 \u03b9 : Type*}\n    [TopologicalSpace \u03b9] [MetrizableSpace \u03b9] [MeasurableSpace \u03b9] [SecondCountableTopology \u03b9]\n    [OpensMeasurableSpace \u03b9] [TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [MeasurableSpace \u03b1]\n    {u : \u03b9 \u2192 \u03b1 \u2192 \u03b2} (hu_cont : \u2200 x, Continuous fun i => u i x) (h : \u2200 i, StronglyMeasurable (u i)) :\n    StronglyMeasurable (Function.uncurry u)", "start": [2068, 1], "end": [2105, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/Germ.lean", "imports": ["Mathlib/Algebra/Module/Pi.lean", "Mathlib/Order/Filter/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.const_eventuallyEq'", "code": "theorem const_eventuallyEq' [NeBot l] {a b : \u03b2} : (\u2200\u1da0 _ in l, a = b) \u2194 a = b", "start": [59, 1], "end": [60, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.const_eventuallyEq", "code": "theorem const_eventuallyEq [NeBot l] {a b : \u03b2} : ((fun _ => a) =\u1da0[l] fun _ => b) \u2194 a = b", "start": [63, 1], "end": [64, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.comp_tendsto", "code": "theorem EventuallyEq.comp_tendsto {f' : \u03b1 \u2192 \u03b2} (H : f =\u1da0[l] f') {g : \u03b3 \u2192 \u03b1} {lc : Filter \u03b3}\n    (hg : Tendsto g lc l) : f \u2218 g =\u1da0[lc] f' \u2218 g", "start": [67, 1], "end": [69, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.germSetoid", "code": "def germSetoid (l : Filter \u03b1) (\u03b2 : Type*) : Setoid (\u03b1 \u2192 \u03b2) where\n  r := EventuallyEq l\n  iseqv := \u27e8EventuallyEq.refl _, EventuallyEq.symm, EventuallyEq.trans\u27e9", "start": [72, 1], "end": [75, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ", "code": "def Germ (l : Filter \u03b1) (\u03b2 : Type*) : Type _ :=\n  Quotient (germSetoid l \u03b2)", "start": [78, 1], "end": [80, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.productSetoid", "code": "def productSetoid (l : Filter \u03b1) (\u03b5 : \u03b1 \u2192 Type*) : Setoid ((a : _) \u2192 \u03b5 a) where\n  r f g := \u2200\u1da0 a in l, f a = g a\n  iseqv :=\n    \u27e8fun _ => eventually_of_forall fun _ => rfl, fun h => h.mono fun _ => Eq.symm,\n      fun h1 h2 => h1.congr (h2.mono fun _ hx => hx \u25b8 Iff.rfl)\u27e9", "start": [83, 1], "end": [89, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.Product", "code": "def Product (l : Filter \u03b1) (\u03b5 : \u03b1 \u2192 Type*) : Type _ :=\n  Quotient (productSetoid l \u03b5)", "start": [92, 1], "end": [96, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.Product.coeTC", "code": "instance coeTC : CoeTC ((a : _) \u2192 \u03b5 a) (l.Product \u03b5) :=\n  \u27e8@Quotient.mk' _ (productSetoid _ \u03b5)\u27e9", "start": [103, 1], "end": [104, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.Product.inhabited", "code": "instance inhabited [(a : _) \u2192 Inhabited (\u03b5 a)] : Inhabited (l.Product \u03b5) :=\n  \u27e8(\u2191fun a => (default : \u03b5 a) : l.Product \u03b5)\u27e9", "start": [106, 1], "end": [107, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.ofFun", "code": "@[coe]\ndef ofFun : (\u03b1 \u2192 \u03b2) \u2192 (Germ l \u03b2) := @Quotient.mk' _ (germSetoid _ _)", "start": [114, 1], "end": [115, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const", "code": "@[coe] def const {l : Filter \u03b1} (b : \u03b2) : (Germ l \u03b2) := ofFun fun _ => b", "start": [120, 1], "end": [121, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coeTC", "code": "instance coeTC : CoeTC \u03b2 (Germ l \u03b2) :=\n  \u27e8const\u27e9", "start": [123, 1], "end": [124, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.quot_mk_eq_coe", "code": "@[simp]\ntheorem quot_mk_eq_coe (l : Filter \u03b1) (f : \u03b1 \u2192 \u03b2) : Quot.mk _ f = (f : Germ l \u03b2)", "start": [126, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.mk'_eq_coe", "code": "@[simp]\ntheorem mk'_eq_coe (l : Filter \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    @Quotient.mk' _ (germSetoid _ _) f = (f : Germ l \u03b2)", "start": [131, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.inductionOn", "code": "@[elab_as_elim]\ntheorem inductionOn (f : Germ l \u03b2) {p : Germ l \u03b2 \u2192 Prop} (h : \u2200 f : \u03b1 \u2192 \u03b2, p f) : p f", "start": [137, 1], "end": [139, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.inductionOn\u2082", "code": "@[elab_as_elim]\ntheorem inductionOn\u2082 (f : Germ l \u03b2) (g : Germ l \u03b3) {p : Germ l \u03b2 \u2192 Germ l \u03b3 \u2192 Prop}\n    (h : \u2200 (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3), p f g) : p f g", "start": [142, 1], "end": [145, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.inductionOn\u2083", "code": "@[elab_as_elim]\ntheorem inductionOn\u2083 (f : Germ l \u03b2) (g : Germ l \u03b3) (h : Germ l \u03b4)\n    {p : Germ l \u03b2 \u2192 Germ l \u03b3 \u2192 Germ l \u03b4 \u2192 Prop}\n    (H : \u2200 (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3) (h : \u03b1 \u2192 \u03b4), p f g h) : p f g h", "start": [148, 1], "end": [152, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.map'", "code": "def map' {lc : Filter \u03b3} (F : (\u03b1 \u2192 \u03b2) \u2192 \u03b3 \u2192 \u03b4) (hF : (l.EventuallyEq \u21d2 lc.EventuallyEq) F F) :\n    Germ l \u03b2 \u2192 Germ lc \u03b4 :=\n  Quotient.map' F hF", "start": [155, 1], "end": [159, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.liftOn", "code": "def liftOn {\u03b3 : Sort*} (f : Germ l \u03b2) (F : (\u03b1 \u2192 \u03b2) \u2192 \u03b3) (hF : (l.EventuallyEq \u21d2 (\u00b7 = \u00b7)) F F) :\n    \u03b3 :=\n  Quotient.liftOn' f F hF", "start": [162, 1], "end": [166, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.map'_coe", "code": "@[simp]\ntheorem map'_coe {lc : Filter \u03b3} (F : (\u03b1 \u2192 \u03b2) \u2192 \u03b3 \u2192 \u03b4) (hF : (l.EventuallyEq \u21d2 lc.EventuallyEq) F F)\n    (f : \u03b1 \u2192 \u03b2) : map' F hF f = F f", "start": [169, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_eq", "code": "@[simp, norm_cast]\ntheorem coe_eq : (f : Germ l \u03b2) = g \u2194 f =\u1da0[l] g", "start": [175, 1], "end": [177, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.germ_eq", "code": "alias \u27e8_, _root_.Filter.EventuallyEq.germ_eq\u27e9 := coe_eq", "start": [180, 1], "end": [180, 56], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Filter.Germ.map", "code": "def map (op : \u03b2 \u2192 \u03b3) : Germ l \u03b2 \u2192 Germ l \u03b3 :=\n  map' ((\u00b7 \u2218 \u00b7) op) fun _ _ H => H.mono fun _ H => congr_arg op H", "start": [183, 1], "end": [185, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.map_coe", "code": "@[simp]\ntheorem map_coe (op : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) : map op (f : Germ l \u03b2) = op \u2218 f", "start": [188, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.map_id", "code": "@[simp]\ntheorem map_id : map id = (id : Germ l \u03b2 \u2192 Germ l \u03b2)", "start": [193, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.map_map", "code": "theorem map_map (op\u2081 : \u03b3 \u2192 \u03b4) (op\u2082 : \u03b2 \u2192 \u03b3) (f : Germ l \u03b2) :\n    map op\u2081 (map op\u2082 f) = map (op\u2081 \u2218 op\u2082) f", "start": [199, 1], "end": [201, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.map\u2082", "code": "def map\u2082 (op : \u03b2 \u2192 \u03b3 \u2192 \u03b4) : Germ l \u03b2 \u2192 Germ l \u03b3 \u2192 Germ l \u03b4 :=\n  Quotient.map\u2082' (fun f g x => op (f x) (g x)) fun f f' Hf g g' Hg =>\n    Hg.mp <| Hf.mono fun x Hf Hg => by simp only [Hf, Hg]", "start": [204, 1], "end": [207, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.map\u2082_coe", "code": "@[simp]\ntheorem map\u2082_coe (op : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3) :\n    map\u2082 op (f : Germ l \u03b2) g = fun x => op (f x) (g x)", "start": [210, 1], "end": [213, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.Tendsto", "code": "protected def Tendsto (f : Germ l \u03b2) (lb : Filter \u03b2) : Prop :=\n  liftOn f (fun f => Tendsto f l lb) fun _f _g H => propext (tendsto_congr' H)", "start": [216, 1], "end": [219, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_tendsto", "code": "@[simp, norm_cast]\ntheorem coe_tendsto {f : \u03b1 \u2192 \u03b2} {lb : Filter \u03b2} : (f : Germ l \u03b2).Tendsto lb \u2194 Tendsto f l lb", "start": [222, 1], "end": [224, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.germ_tendsto", "code": "alias \u27e8_, _root_.Filter.Tendsto.germ_tendsto\u27e9 := coe_tendsto", "start": [227, 1], "end": [227, 61], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Filter.Germ.compTendsto'", "code": "def compTendsto' (f : Germ l \u03b2) {lc : Filter \u03b3} (g : Germ lc \u03b1) (hg : g.Tendsto l) : Germ lc \u03b2 :=\n  liftOn f (fun f => g.map f) fun _f\u2081 _f\u2082 hF =>\n    inductionOn g (fun _g hg => coe_eq.2 <| hg.eventually hF) hg", "start": [230, 1], "end": [234, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_compTendsto'", "code": "@[simp]\ntheorem coe_compTendsto' (f : \u03b1 \u2192 \u03b2) {lc : Filter \u03b3} {g : Germ lc \u03b1} (hg : g.Tendsto l) :\n    (f : Germ l \u03b2).compTendsto' g hg = g.map f", "start": [237, 1], "end": [240, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.compTendsto", "code": "def compTendsto (f : Germ l \u03b2) {lc : Filter \u03b3} (g : \u03b3 \u2192 \u03b1) (hg : Tendsto g lc l) : Germ lc \u03b2 :=\n  f.compTendsto' _ hg.germ_tendsto", "start": [243, 1], "end": [246, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_compTendsto", "code": "@[simp]\ntheorem coe_compTendsto (f : \u03b1 \u2192 \u03b2) {lc : Filter \u03b3} {g : \u03b3 \u2192 \u03b1} (hg : Tendsto g lc l) :\n    (f : Germ l \u03b2).compTendsto g hg = f \u2218 g", "start": [249, 1], "end": [252, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.compTendsto'_coe", "code": "@[simp, nolint simpNF] theorem compTendsto'_coe (f : Germ l \u03b2) {lc : Filter \u03b3} {g : \u03b3 \u2192 \u03b1} (hg : Tendsto g lc l) :\n    f.compTendsto' _ hg.germ_tendsto = f.compTendsto g hg", "start": [255, 1], "end": [258, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_inj", "code": "@[simp, norm_cast]\ntheorem const_inj [NeBot l] {a b : \u03b2} : (\u2191a : Germ l \u03b2) = \u2191b \u2194 a = b", "start": [260, 1], "end": [262, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.map_const", "code": "@[simp]\ntheorem map_const (l : Filter \u03b1) (a : \u03b2) (f : \u03b2 \u2192 \u03b3) : (\u2191a : Germ l \u03b2).map f = \u2191(f a)", "start": [265, 1], "end": [267, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.map\u2082_const", "code": "@[simp]\ntheorem map\u2082_const (l : Filter \u03b1) (b : \u03b2) (c : \u03b3) (f : \u03b2 \u2192 \u03b3 \u2192 \u03b4) :\n    map\u2082 f (\u2191b : Germ l \u03b2) \u2191c = \u2191(f b c)", "start": [270, 1], "end": [273, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_compTendsto", "code": "@[simp]\ntheorem const_compTendsto {l : Filter \u03b1} (b : \u03b2) {lc : Filter \u03b3} {g : \u03b3 \u2192 \u03b1} (hg : Tendsto g lc l) :\n    (\u2191b : Germ l \u03b2).compTendsto g hg = \u2191b", "start": [276, 1], "end": [279, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_compTendsto'", "code": "@[simp]\ntheorem const_compTendsto' {l : Filter \u03b1} (b : \u03b2) {lc : Filter \u03b3} {g : Germ lc \u03b1}\n    (hg : g.Tendsto l) : (\u2191b : Germ l \u03b2).compTendsto' g hg = \u2191b", "start": [282, 1], "end": [285, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.LiftPred", "code": "def LiftPred (p : \u03b2 \u2192 Prop) (f : Germ l \u03b2) : Prop :=\n  liftOn f (fun f => \u2200\u1da0 x in l, p (f x)) fun _f _g H =>\n    propext <| eventually_congr <| H.mono fun _x hx => hx \u25b8 Iff.rfl", "start": [288, 1], "end": [291, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.liftPred_coe", "code": "@[simp]\ntheorem liftPred_coe {p : \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} : LiftPred p (f : Germ l \u03b2) \u2194 \u2200\u1da0 x in l, p (f x)", "start": [294, 1], "end": [296, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.liftPred_const", "code": "theorem liftPred_const {p : \u03b2 \u2192 Prop} {x : \u03b2} (hx : p x) : LiftPred p (\u2191x : Germ l \u03b2)", "start": [299, 1], "end": [300, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.liftPred_const_iff", "code": "@[simp]\ntheorem liftPred_const_iff [NeBot l] {p : \u03b2 \u2192 Prop} {x : \u03b2} : LiftPred p (\u2191x : Germ l \u03b2) \u2194 p x", "start": [303, 1], "end": [305, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.LiftRel", "code": "def LiftRel (r : \u03b2 \u2192 \u03b3 \u2192 Prop) (f : Germ l \u03b2) (g : Germ l \u03b3) : Prop :=\n  Quotient.liftOn\u2082' f g (fun f g => \u2200\u1da0 x in l, r (f x) (g x)) fun _f _g _f' _g' Hf Hg =>\n    propext <| eventually_congr <| Hg.mp <| Hf.mono fun _x hf hg => hf \u25b8 hg \u25b8 Iff.rfl", "start": [308, 1], "end": [311, 86], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.liftRel_coe", "code": "@[simp]\ntheorem liftRel_coe {r : \u03b2 \u2192 \u03b3 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} :\n    LiftRel r (f : Germ l \u03b2) g \u2194 \u2200\u1da0 x in l, r (f x) (g x)", "start": [314, 1], "end": [317, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.liftRel_const", "code": "theorem liftRel_const {r : \u03b2 \u2192 \u03b3 \u2192 Prop} {x : \u03b2} {y : \u03b3} (h : r x y) :\n    LiftRel r (\u2191x : Germ l \u03b2) \u2191y", "start": [320, 1], "end": [322, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.liftRel_const_iff", "code": "@[simp]\ntheorem liftRel_const_iff [NeBot l] {r : \u03b2 \u2192 \u03b3 \u2192 Prop} {x : \u03b2} {y : \u03b3} :\n    LiftRel r (\u2191x : Germ l \u03b2) \u2191y \u2194 r x y", "start": [325, 1], "end": [328, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.inhabited", "code": "instance inhabited [Inhabited \u03b2] : Inhabited (Germ l \u03b2) :=\n  \u27e8\u2191(default : \u03b2)\u27e9", "start": [331, 1], "end": [332, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.mul", "code": "@[to_additive]\ninstance mul [Mul M] : Mul (Germ l M) :=\n  \u27e8map\u2082 (\u00b7 * \u00b7)\u27e9", "start": [338, 1], "end": [340, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_mul", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul [Mul M] (f g : \u03b1 \u2192 M) : \u2191(f * g) = (f * g : Germ l M)", "start": [342, 1], "end": [344, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.one", "code": "@[to_additive]\ninstance one [One M] : One (Germ l M) :=\n  \u27e8\u2191(1 : M)\u27e9", "start": [348, 1], "end": [350, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_one", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one [One M] : \u2191(1 : \u03b1 \u2192 M) = (1 : Germ l M)", "start": [352, 1], "end": [354, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.semigroup", "code": "@[to_additive]\ninstance semigroup [Semigroup M] : Semigroup (Germ l M) :=\n  { mul_assoc := fun a b c => Quotient.inductionOn\u2083' a b c\n      fun _ _ _ => congrArg ofFun <| mul_assoc .. }", "start": [358, 1], "end": [361, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.commSemigroup", "code": "@[to_additive]\ninstance commSemigroup [CommSemigroup M] : CommSemigroup (Germ l M) :=\n  { mul_comm := Quotient.ind\u2082' fun _ _ => congrArg ofFun <| mul_comm .. }", "start": [363, 1], "end": [365, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.leftCancelSemigroup", "code": "@[to_additive]\ninstance leftCancelSemigroup [LeftCancelSemigroup M] : LeftCancelSemigroup (Germ l M) :=\n  { Germ.semigroup with\n    mul_left_cancel := fun f\u2081 f\u2082 f\u2083 =>\n      inductionOn\u2083 f\u2081 f\u2082 f\u2083 fun _f\u2081 _f\u2082 _f\u2083 H =>\n        coe_eq.2 ((coe_eq.1 H).mono fun _x => mul_left_cancel) }", "start": [367, 1], "end": [372, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.rightCancelSemigroup", "code": "@[to_additive]\ninstance rightCancelSemigroup [RightCancelSemigroup M] : RightCancelSemigroup (Germ l M) :=\n  { Germ.semigroup with\n    mul_right_cancel := fun f\u2081 f\u2082 f\u2083 =>\n      inductionOn\u2083 f\u2081 f\u2082 f\u2083 fun _f\u2081 _f\u2082 _f\u2083 H =>\n        coe_eq.2 <| (coe_eq.1 H).mono fun _x => mul_right_cancel }", "start": [374, 1], "end": [379, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.mulOneClass", "code": "@[to_additive]\ninstance mulOneClass [MulOneClass M] : MulOneClass (Germ l M) :=\n  { one_mul := Quotient.ind' fun _ => congrArg ofFun <| one_mul _\n    mul_one := Quotient.ind' fun _ => congrArg ofFun <| mul_one _ }", "start": [381, 1], "end": [384, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.smul", "code": "@[to_additive]\ninstance smul [SMul M G] : SMul M (Germ l G) :=\n  \u27e8fun n => map (n \u2022 \u00b7)\u27e9", "start": [386, 1], "end": [388, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.pow", "code": "@[to_additive existing smul]\ninstance pow [Pow G M] : Pow (Germ l G) M :=\n  \u27e8fun f n => map (\u00b7 ^ n) f\u27e9", "start": [390, 1], "end": [392, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_smul", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_smul [SMul M G] (n : M) (f : \u03b1 \u2192 G) : \u2191(n \u2022 f) = n \u2022 (f : Germ l G)", "start": [394, 1], "end": [396, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_smul", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem const_smul [SMul M G] (n : M) (a : G) : (\u2191(n \u2022 a) : Germ l G) = n \u2022 (\u2191a : Germ l G)", "start": [400, 1], "end": [402, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_pow", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow [Pow G M] (f : \u03b1 \u2192 G) (n : M) : \u2191(f ^ n) = (f : Germ l G) ^ n", "start": [406, 1], "end": [408, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_pow", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem const_pow [Pow G M] (a : G) (n : M) : (\u2191(a ^ n) : Germ l G) = (\u2191a : Germ l G) ^ n", "start": [411, 1], "end": [413, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.monoid", "code": "@[to_additive]\ninstance monoid [Monoid M] : Monoid (Germ l M) :=\n  { Function.Surjective.monoid ofFun (surjective_quot_mk _) (by rfl)\n      (fun _ _ => by rfl) fun _ _ => by rfl with\n    toSemigroup := semigroup\n    toOne := one\n    npow := fun n a => a ^ n }", "start": [417, 1], "end": [423, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coeMulHom", "code": "@[to_additive \"Coercion from functions to germs as an additive monoid homomorphism.\"]\ndef coeMulHom [Monoid M] (l : Filter \u03b1) : (\u03b1 \u2192 M) \u2192* Germ l M where\n  toFun := ofFun; map_one' := rfl; map_mul' _ _ := rfl", "start": [425, 1], "end": [428, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_coeMulHom", "code": "@[to_additive (attr := simp)]\ntheorem coe_coeMulHom [Monoid M] : (coeMulHom l : (\u03b1 \u2192 M) \u2192 Germ l M) = ofFun", "start": [432, 1], "end": [434, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.commMonoid", "code": "@[to_additive]\ninstance commMonoid [CommMonoid M] : CommMonoid (Germ l M) :=\n  { mul_comm := mul_comm }", "start": [438, 1], "end": [440, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.natCast", "code": "instance natCast [NatCast M] : NatCast (Germ l M) where\n  natCast n := (n : \u03b1 \u2192 M)", "start": [442, 1], "end": [443, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_nat", "code": "@[simp]\ntheorem coe_nat [NatCast M] (n : \u2115) : ((fun _ \u21a6 n : \u03b1 \u2192 M) : Germ l M) = n", "start": [445, 1], "end": [446, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_nat", "code": "@[simp, norm_cast]\ntheorem const_nat [NatCast M] (n : \u2115) : ((n : M) : Germ l M) = n", "start": [448, 1], "end": [449, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_ofNat", "code": "@[simp, norm_cast]\ntheorem coe_ofNat [NatCast M] (n : \u2115) [n.AtLeastTwo] :\n    ((OfNat.ofNat n : \u03b1 \u2192 M) : Germ l M) = OfNat.ofNat n", "start": [451, 1], "end": [454, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_ofNat", "code": "@[simp, norm_cast]\ntheorem const_ofNat [NatCast M] (n : \u2115) [n.AtLeastTwo] :\n    ((OfNat.ofNat n : M) : Germ l M) = OfNat.ofNat n", "start": [456, 1], "end": [459, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.intCast", "code": "instance intCast [IntCast M] : IntCast (Germ l M) where\n  intCast n := (n : \u03b1 \u2192 M)", "start": [461, 1], "end": [462, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_int", "code": "@[simp]\ntheorem coe_int [IntCast M] (n : \u2124) : ((fun _ \u21a6 n : \u03b1 \u2192 M) : Germ l M) = n", "start": [464, 1], "end": [465, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.addMonoidWithOne", "code": "instance addMonoidWithOne [AddMonoidWithOne M] : AddMonoidWithOne (Germ l M) :=\n  { natCast, addMonoid, one with\n    natCast_zero := congrArg ofFun <| by simp; rfl\n    natCast_succ := fun _ => congrArg ofFun <| by simp [Function.comp]; rfl }", "start": [467, 1], "end": [470, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.addCommMonoidWithOne", "code": "instance addCommMonoidWithOne [AddCommMonoidWithOne M] : AddCommMonoidWithOne (Germ l M) :=\n  { add_comm := add_comm }", "start": [472, 1], "end": [473, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.inv", "code": "@[to_additive]\ninstance inv [Inv G] : Inv (Germ l G) :=\n  \u27e8map Inv.inv\u27e9", "start": [475, 1], "end": [477, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_inv", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv [Inv G] (f : \u03b1 \u2192 G) : \u2191f\u207b\u00b9 = (f\u207b\u00b9 : Germ l G)", "start": [479, 1], "end": [481, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_inv", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem const_inv [Inv G] (a : G) : (\u2191(a\u207b\u00b9) : Germ l G) = (\u2191a)\u207b\u00b9", "start": [485, 1], "end": [487, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.div", "code": "@[to_additive]\ninstance div [Div M] : Div (Germ l M) :=\n  \u27e8map\u2082 (\u00b7 / \u00b7)\u27e9", "start": [491, 1], "end": [493, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_div", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div [Div M] (f g : \u03b1 \u2192 M) : \u2191(f / g) = (f / g : Germ l M)", "start": [495, 1], "end": [497, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_div", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem const_div [Div M] (a b : M) : (\u2191(a / b) : Germ l M) = \u2191a / \u2191b", "start": [501, 1], "end": [503, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.involutiveInv", "code": "@[to_additive]\ninstance involutiveInv [InvolutiveInv G] : InvolutiveInv (Germ l G) :=\n  { inv_inv := Quotient.ind' fun _ => congrArg ofFun<| inv_inv _ }", "start": [507, 1], "end": [509, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.hasDistribNeg", "code": "instance hasDistribNeg [Mul G] [HasDistribNeg G] : HasDistribNeg (Germ l G) :=\n  { neg_mul := Quotient.ind\u2082' fun _ _ => congrArg ofFun <| neg_mul ..\n    mul_neg := Quotient.ind\u2082' fun _ _ => congrArg ofFun <| mul_neg .. }", "start": [511, 1], "end": [513, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.invOneClass", "code": "@[to_additive]\ninstance invOneClass [InvOneClass G] : InvOneClass (Germ l G) :=\n  \u27e8congr_arg ofFun inv_one\u27e9", "start": [515, 1], "end": [517, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.divInvMonoid", "code": "@[to_additive subNegMonoid]\ninstance divInvMonoid [DivInvMonoid G] : DivInvMonoid (Germ l G) :=\n  { monoid, inv, div with\n    zpow := fun z f => f ^ z\n    zpow_zero' := Quotient.ind' fun _ => congrArg ofFun <|\n      funext <| fun _ => DivInvMonoid.zpow_zero' _\n    zpow_succ' := fun _ => Quotient.ind' fun _ => congrArg ofFun <|\n      funext <| fun _ => DivInvMonoid.zpow_succ' ..\n    zpow_neg' := fun _ => Quotient.ind' fun _ => congrArg ofFun <|\n      funext <| fun _ => DivInvMonoid.zpow_neg' ..\n    div_eq_mul_inv := Quotient.ind\u2082' fun _ _ => congrArg ofFun <|\n      div_eq_mul_inv .. }", "start": [519, 1], "end": [530, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.divisionMonoid", "code": "@[to_additive]\ninstance divisionMonoid [DivisionMonoid G] : DivisionMonoid (Germ l G) where\n  inv_inv := inv_inv\n  mul_inv_rev x y := inductionOn\u2082 x y fun _ _ \u21a6 congr_arg ofFun <| mul_inv_rev _ _\n  inv_eq_of_mul x y := inductionOn\u2082 x y fun _ _ h \u21a6 coe_eq.2 <| (coe_eq.1 h).mono fun _ \u21a6\n    DivisionMonoid.inv_eq_of_mul _ _", "start": [532, 1], "end": [537, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.group", "code": "@[to_additive]\ninstance group [Group G] : Group (Germ l G) :=\n  { mul_left_inv := Quotient.ind' fun _ => congrArg ofFun <| mul_left_inv _ }", "start": [539, 1], "end": [541, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.commGroup", "code": "@[to_additive]\ninstance commGroup [CommGroup G] : CommGroup (Germ l G) :=\n  { mul_comm := mul_comm }", "start": [543, 1], "end": [545, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.addGroupWithOne", "code": "instance addGroupWithOne [AddGroupWithOne G] : AddGroupWithOne (Germ l G) :=\n  { intCast, addMonoidWithOne, addGroup with\n    intCast_ofNat := fun _ => congrArg ofFun <| by simp\n    intCast_negSucc := fun _ => congrArg ofFun <| by simp [Function.comp]; rfl }", "start": [547, 1], "end": [550, 81], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.nontrivial", "code": "instance nontrivial [Nontrivial R] [NeBot l] : Nontrivial (Germ l R) :=\n  let \u27e8x, y, h\u27e9 := exists_pair_ne R\n  \u27e8\u27e8\u2191x, \u2191y, mt const_inj.1 h\u27e9\u27e9", "start": [558, 1], "end": [560, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.mulZeroClass", "code": "instance mulZeroClass [MulZeroClass R] : MulZeroClass (Germ l R) :=\n  { zero_mul := Quotient.ind' fun _ => congrArg ofFun <| zero_mul _\n    mul_zero := Quotient.ind' fun _ => congrArg ofFun <| mul_zero _ }", "start": [563, 1], "end": [565, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.mulZeroOneClass", "code": "instance mulZeroOneClass [MulZeroOneClass R] : MulZeroOneClass (Germ l R) :=\n  { mulZeroClass, mulOneClass with }", "start": [567, 1], "end": [568, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.monoidWithZero", "code": "instance monoidWithZero [MonoidWithZero R] : MonoidWithZero (Germ l R) :=\n  { monoid, mulZeroClass with }", "start": [570, 1], "end": [571, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.distrib", "code": "instance distrib [Distrib R] : Distrib (Germ l R) :=\n  { left_distrib := fun a b c => Quotient.inductionOn\u2083' a b c\n      fun _ _ _ => congrArg ofFun <| left_distrib ..\n    right_distrib := fun a b c => Quotient.inductionOn\u2083' a b c\n      fun _ _ _ => congrArg ofFun <| right_distrib .. }", "start": [573, 1], "end": [577, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.nonUnitalNonAssocSemiring", "code": "instance nonUnitalNonAssocSemiring [NonUnitalNonAssocSemiring R] :\n    NonUnitalNonAssocSemiring (Germ l R) :=\n  { addCommMonoid, distrib, mulZeroClass with }", "start": [579, 1], "end": [581, 48], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.nonUnitalSemiring", "code": "instance nonUnitalSemiring [NonUnitalSemiring R] : NonUnitalSemiring (Germ l R) :=\n  { mul_assoc := mul_assoc }", "start": [583, 1], "end": [584, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.nonAssocSemiring", "code": "instance nonAssocSemiring [NonAssocSemiring R] : NonAssocSemiring (Germ l R) :=\n  { nonUnitalNonAssocSemiring, mulZeroOneClass, addMonoidWithOne with }", "start": [586, 1], "end": [587, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.nonUnitalNonAssocRing", "code": "instance nonUnitalNonAssocRing [NonUnitalNonAssocRing R] :\n    NonUnitalNonAssocRing (Germ l R) :=\n  { addCommGroup, nonUnitalNonAssocSemiring with }", "start": [589, 1], "end": [591, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.nonUnitalRing", "code": "instance nonUnitalRing [NonUnitalRing R] : NonUnitalRing (Germ l R) :=\n  { mul_assoc := mul_assoc }", "start": [593, 1], "end": [594, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.nonAssocRing", "code": "instance nonAssocRing [NonAssocRing R] : NonAssocRing (Germ l R) :=\n  { nonUnitalNonAssocRing, nonAssocSemiring, addGroupWithOne with }", "start": [596, 1], "end": [597, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.semiring", "code": "instance semiring [Semiring R] : Semiring (Germ l R) :=\n  { nonUnitalSemiring, nonAssocSemiring, monoidWithZero with }", "start": [599, 1], "end": [600, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.ring", "code": "instance ring [Ring R] : Ring (Germ l R) :=\n  { semiring, addCommGroup, nonAssocRing with }", "start": [602, 1], "end": [603, 48], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.nonUnitalCommSemiring", "code": "instance nonUnitalCommSemiring [NonUnitalCommSemiring R] : NonUnitalCommSemiring (Germ l R) :=\n  { mul_comm := mul_comm }", "start": [605, 1], "end": [606, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.commSemiring", "code": "instance commSemiring [CommSemiring R] : CommSemiring (Germ l R) :=\n  { mul_comm := mul_comm }", "start": [608, 1], "end": [609, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.nonUnitalCommRing", "code": "instance nonUnitalCommRing [NonUnitalCommRing R] : NonUnitalCommRing (Germ l R) :=\n  { nonUnitalRing, commSemigroup with }", "start": [611, 1], "end": [612, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.commRing", "code": "instance commRing [CommRing R] : CommRing (Germ l R) :=\n  { mul_comm := mul_comm }", "start": [614, 1], "end": [615, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coeRingHom", "code": "def coeRingHom [Semiring R] (l : Filter \u03b1) : (\u03b1 \u2192 R) \u2192+* Germ l R :=\n  { (coeMulHom l : _ \u2192* Germ l R), (coeAddHom l : _ \u2192+ Germ l R) with toFun := ofFun }", "start": [617, 1], "end": [619, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_coeRingHom", "code": "@[simp]\ntheorem coe_coeRingHom [Semiring R] : (coeRingHom l : (\u03b1 \u2192 R) \u2192 Germ l R) = ofFun", "start": [622, 1], "end": [624, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.instSMul'", "code": "@[to_additive]\ninstance instSMul' [SMul M \u03b2] : SMul (Germ l M) (Germ l \u03b2) :=\n  \u27e8map\u2082 (\u00b7 \u2022 \u00b7)\u27e9", "start": [633, 1], "end": [635, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_smul'", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_smul' [SMul M \u03b2] (c : \u03b1 \u2192 M) (f : \u03b1 \u2192 \u03b2) : \u2191(c \u2022 f) = (c : Germ l M) \u2022 (f : Germ l \u03b2)", "start": [639, 1], "end": [641, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.mulAction", "code": "@[to_additive]\ninstance mulAction [Monoid M] [MulAction M \u03b2] : MulAction M (Germ l \u03b2) where\n  one_smul f :=\n    inductionOn f fun f => by\n      norm_cast\n      simp only [one_smul]\n      rfl\n  mul_smul c\u2081 c\u2082 f :=\n    inductionOn f fun f => by\n      norm_cast\n      simp only [mul_smul]\n      rfl", "start": [645, 1], "end": [657, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.mulAction'", "code": "@[to_additive]\ninstance mulAction' [Monoid M] [MulAction M \u03b2] : MulAction (Germ l M) (Germ l \u03b2) where\n  one_smul f := inductionOn f fun f => by simp only [\u2190 coe_one, \u2190 coe_smul', one_smul]\n  mul_smul c\u2081 c\u2082 f :=\n    inductionOn\u2083 c\u2081 c\u2082 f fun c\u2081 c\u2082 f => by\n      norm_cast\n      simp only [mul_smul]\n      rfl", "start": [659, 1], "end": [667, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.distribMulAction", "code": "instance distribMulAction [Monoid M] [AddMonoid N] [DistribMulAction M N] :\n    DistribMulAction M (Germ l N) where\n  smul_add c f g :=\n    inductionOn\u2082 f g fun f g => by\n      norm_cast\n      simp only [smul_add]\n      rfl\n  smul_zero c := by simp only [\u2190 coe_zero, \u2190 coe_smul, smul_zero]", "start": [671, 1], "end": [679, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.distribMulAction'", "code": "instance distribMulAction' [Monoid M] [AddMonoid N] [DistribMulAction M N] :\n    DistribMulAction (Germ l M) (Germ l N) where\n  smul_add c f g :=\n    inductionOn\u2083 c f g fun c f g => by\n      norm_cast\n      simp only [smul_add]\n      rfl\n  smul_zero c := inductionOn c fun c => by simp only [\u2190 coe_zero, \u2190 coe_smul', smul_zero]", "start": [681, 1], "end": [689, 90], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.module", "code": "instance module [Semiring R] [AddCommMonoid M] [Module R M] : Module R (Germ l M) where\n  add_smul c\u2081 c\u2082 f :=\n    inductionOn f fun f => by\n      norm_cast\n      simp only [add_smul]\n      rfl\n  zero_smul f :=\n    inductionOn f fun f => by\n      norm_cast\n      simp only [zero_smul, coe_zero]\n      rfl", "start": [692, 1], "end": [703, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.module'", "code": "instance module' [Semiring R] [AddCommMonoid M] [Module R M] : Module (Germ l R) (Germ l M) where\n  add_smul c\u2081 c\u2082 f :=\n    inductionOn\u2083 c\u2081 c\u2082 f fun c\u2081 c\u2082 f => by\n      norm_cast\n      simp only [add_smul]\n      rfl\n  zero_smul f := inductionOn f fun f => by simp only [\u2190 coe_zero, \u2190 coe_smul', zero_smul]", "start": [705, 1], "end": [712, 90], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.le", "code": "instance le [LE \u03b2] : LE (Germ l \u03b2) :=\n  \u27e8LiftRel (\u00b7 \u2264 \u00b7)\u27e9", "start": [717, 1], "end": [718, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.le_def", "code": "theorem le_def [LE \u03b2] : ((\u00b7 \u2264 \u00b7) : Germ l \u03b2 \u2192 Germ l \u03b2 \u2192 Prop) = LiftRel (\u00b7 \u2264 \u00b7)", "start": [720, 1], "end": [721, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_le", "code": "@[simp]\ntheorem coe_le [LE \u03b2] : (f : Germ l \u03b2) \u2264 g \u2194 f \u2264\u1da0[l] g", "start": [724, 1], "end": [726, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_nonneg", "code": "theorem coe_nonneg [LE \u03b2] [Zero \u03b2] {f : \u03b1 \u2192 \u03b2} : 0 \u2264 (f : Germ l \u03b2) \u2194 \u2200\u1da0 x in l, 0 \u2264 f x", "start": [729, 1], "end": [730, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_le", "code": "theorem const_le [LE \u03b2] {x y : \u03b2} : x \u2264 y \u2192 (\u2191x : Germ l \u03b2) \u2264 \u2191y", "start": [733, 1], "end": [734, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_le_iff", "code": "@[simp, norm_cast]\ntheorem const_le_iff [LE \u03b2] [NeBot l] {x y : \u03b2} : (\u2191x : Germ l \u03b2) \u2264 \u2191y \u2194 x \u2264 y", "start": [737, 1], "end": [739, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.preorder", "code": "instance preorder [Preorder \u03b2] : Preorder (Germ l \u03b2) where\n  le := (\u00b7 \u2264 \u00b7)\n  le_refl f := inductionOn f <| EventuallyLE.refl l\n  le_trans f\u2081 f\u2082 f\u2083 := inductionOn\u2083 f\u2081 f\u2082 f\u2083 fun f\u2081 f\u2082 f\u2083 => EventuallyLE.trans", "start": [742, 1], "end": [745, 80], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.partialOrder", "code": "instance partialOrder [PartialOrder \u03b2] : PartialOrder (Germ l \u03b2) :=\n  { Filter.Germ.preorder with\n    le := (\u00b7 \u2264 \u00b7)\n    le_antisymm := fun f g =>\n      inductionOn\u2082 f g fun _ _ h\u2081 h\u2082 => (EventuallyLE.antisymm h\u2081 h\u2082).germ_eq }", "start": [747, 1], "end": [751, 80], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.bot", "code": "instance bot [Bot \u03b2] : Bot (Germ l \u03b2) :=\n  \u27e8\u2191(\u22a5 : \u03b2)\u27e9", "start": [753, 1], "end": [754, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.top", "code": "instance top [Top \u03b2] : Top (Germ l \u03b2) :=\n  \u27e8\u2191(\u22a4 : \u03b2)\u27e9", "start": [756, 1], "end": [757, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_bot", "code": "@[simp, norm_cast]\ntheorem const_bot [Bot \u03b2] : (\u2191(\u22a5 : \u03b2) : Germ l \u03b2) = \u22a5", "start": [759, 1], "end": [761, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_top", "code": "@[simp, norm_cast]\ntheorem const_top [Top \u03b2] : (\u2191(\u22a4 : \u03b2) : Germ l \u03b2) = \u22a4", "start": [764, 1], "end": [766, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.orderBot", "code": "instance orderBot [LE \u03b2] [OrderBot \u03b2] : OrderBot (Germ l \u03b2) where\n  bot := \u22a5\n  bot_le f := inductionOn f fun _ => eventually_of_forall fun _ => bot_le", "start": [769, 1], "end": [771, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.orderTop", "code": "instance orderTop [LE \u03b2] [OrderTop \u03b2] : OrderTop (Germ l \u03b2) where\n  top := \u22a4\n  le_top f := inductionOn f fun _ => eventually_of_forall fun _ => le_top", "start": [773, 1], "end": [775, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.sup", "code": "instance sup [Sup \u03b2] : Sup (Germ l \u03b2) :=\n  \u27e8map\u2082 (\u00b7 \u2294 \u00b7)\u27e9", "start": [780, 1], "end": [781, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.inf", "code": "instance inf [Inf \u03b2] : Inf (Germ l \u03b2) :=\n  \u27e8map\u2082 (\u00b7 \u2293 \u00b7)\u27e9", "start": [783, 1], "end": [784, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_sup", "code": "@[simp, norm_cast]\ntheorem const_sup [Sup \u03b2] (a b : \u03b2) : \u2191(a \u2294 b) = (\u2191a \u2294 \u2191b : Germ l \u03b2)", "start": [786, 1], "end": [788, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_inf", "code": "@[simp, norm_cast]\ntheorem const_inf [Inf \u03b2] (a b : \u03b2) : \u2191(a \u2293 b) = (\u2191a \u2293 \u2191b : Germ l \u03b2)", "start": [791, 1], "end": [793, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.semilatticeSup", "code": "instance semilatticeSup [SemilatticeSup \u03b2] : SemilatticeSup (Germ l \u03b2) :=\n  { Germ.partialOrder with\n    sup := (\u00b7 \u2294 \u00b7)\n    le_sup_left := fun f g =>\n        inductionOn\u2082 f g fun _f _g => eventually_of_forall fun _x => le_sup_left\n    le_sup_right := fun f g =>\n      inductionOn\u2082 f g fun _f _g => eventually_of_forall fun _x => le_sup_right\n    sup_le := fun f\u2081 f\u2082 g =>\n      inductionOn\u2083 f\u2081 f\u2082 g fun _f\u2081 _f\u2082 _g h\u2081 h\u2082 => h\u2082.mp <| h\u2081.mono fun _x => sup_le }", "start": [796, 1], "end": [804, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.semilatticeInf", "code": "instance semilatticeInf [SemilatticeInf \u03b2] : SemilatticeInf (Germ l \u03b2) :=\n  { Germ.partialOrder with\n    inf := (\u00b7 \u2293 \u00b7)\n    inf_le_left := fun f g =>\n        inductionOn\u2082 f g fun _f _g => eventually_of_forall fun _x => inf_le_left\n    inf_le_right := fun f g =>\n      inductionOn\u2082 f g fun _f _g => eventually_of_forall fun _x => inf_le_right\n    le_inf := fun f\u2081 f\u2082 g =>\n      inductionOn\u2083 f\u2081 f\u2082 g fun _f\u2081 _f\u2082 _g h\u2081 h\u2082 => h\u2082.mp <| h\u2081.mono fun _x => le_inf }", "start": [806, 1], "end": [814, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.lattice", "code": "instance lattice [Lattice \u03b2] : Lattice (Germ l \u03b2) :=\n  { Germ.semilatticeSup, Germ.semilatticeInf with }", "start": [816, 1], "end": [817, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.distribLattice", "code": "instance distribLattice [DistribLattice \u03b2] : DistribLattice (Germ l \u03b2) :=\n  { Germ.semilatticeSup, Germ.semilatticeInf with\n    le_sup_inf := fun f g h =>\n      inductionOn\u2083 f g h fun _f _g _h => eventually_of_forall fun _ => le_sup_inf }", "start": [819, 1], "end": [822, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.orderedCommMonoid", "code": "@[to_additive]\ninstance orderedCommMonoid [OrderedCommMonoid \u03b2] : OrderedCommMonoid (Germ l \u03b2) :=\n  { Germ.partialOrder, Germ.commMonoid with\n    mul_le_mul_left := fun f g =>\n      inductionOn\u2082 f g fun _f _g H h =>\n        inductionOn h fun _h => H.mono fun _x H => mul_le_mul_left' H _ }", "start": [824, 1], "end": [829, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.orderedCancelCommMonoid", "code": "@[to_additive]\ninstance orderedCancelCommMonoid [OrderedCancelCommMonoid \u03b2]  :\n    OrderedCancelCommMonoid (Germ l \u03b2) :=\n  { Germ.orderedCommMonoid with\n    le_of_mul_le_mul_left := fun f g h =>\n      inductionOn\u2083 f g h fun _f _g _h H => H.mono fun _x => le_of_mul_le_mul_left' }", "start": [831, 1], "end": [836, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.orderedCommGroup", "code": "@[to_additive]\ninstance orderedCommGroup [OrderedCommGroup \u03b2] : OrderedCommGroup (Germ l \u03b2) :=\n  { Germ.orderedCancelCommMonoid, Germ.commGroup with }", "start": [838, 1], "end": [840, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.existsMulOfLE", "code": "@[to_additive]\ninstance existsMulOfLE [Mul \u03b2] [LE \u03b2] [ExistsMulOfLE \u03b2] : ExistsMulOfLE (Germ l \u03b2) where\n  exists_mul_of_le {x y} := inductionOn\u2082 x y fun f g (h : f \u2264\u1da0[l] g) \u21a6 by\n    classical\n    choose c hc using fun x (hx : f x \u2264 g x) \u21a6 exists_mul_of_le hx\n    refine \u27e8ofFun <| fun x \u21a6 if hx : f x \u2264 g x then c x hx else f x, coe_eq.2 ?_\u27e9\n    filter_upwards [h] with x hx\n    rw [dif_pos hx, hc]", "start": [842, 1], "end": [849, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.CanonicallyOrderedCommMonoid", "code": "@[to_additive]\ninstance CanonicallyOrderedCommMonoid [CanonicallyOrderedCommMonoid \u03b2] :\n    CanonicallyOrderedCommMonoid (Germ l \u03b2) :=\n  { orderedCommMonoid, orderBot, existsMulOfLE with\n    le_self_mul := fun x y \u21a6 inductionOn\u2082 x y fun _ _ \u21a6 eventually_of_forall fun _ \u21a6 le_self_mul }", "start": [851, 1], "end": [855, 99], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.orderedSemiring", "code": "instance orderedSemiring [OrderedSemiring \u03b2] : OrderedSemiring (Germ l \u03b2) :=\n  { Germ.semiring,\n    Germ.orderedAddCommMonoid with\n    zero_le_one := const_le zero_le_one\n    mul_le_mul_of_nonneg_left := fun x y z =>\n      inductionOn\u2083 x y z fun _f _g _h hfg hh =>\n          hh.mp <| hfg.mono fun _a => mul_le_mul_of_nonneg_left\n    mul_le_mul_of_nonneg_right := fun x y z =>\n      inductionOn\u2083 x y z fun _f _g _h hfg hh =>\n          hh.mp <| hfg.mono fun _a => mul_le_mul_of_nonneg_right }", "start": [857, 1], "end": [866, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.orderedCommSemiring", "code": "instance orderedCommSemiring [OrderedCommSemiring \u03b2] : OrderedCommSemiring (Germ l \u03b2) :=\n  { Germ.orderedSemiring, Germ.commSemiring with }", "start": [868, 1], "end": [869, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.orderedRing", "code": "instance orderedRing [OrderedRing \u03b2] : OrderedRing (Germ l \u03b2) :=\n  { Germ.ring,\n    Germ.orderedAddCommGroup with\n    zero_le_one := const_le zero_le_one\n    mul_nonneg := fun x y =>\n      inductionOn\u2082 x y fun _f _g hf hg => hg.mp <| hf.mono fun _a => mul_nonneg }", "start": [871, 1], "end": [876, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.orderedCommRing", "code": "instance orderedCommRing [OrderedCommRing \u03b2] : OrderedCommRing (Germ l \u03b2) :=\n  { Germ.orderedRing, Germ.orderedCommSemiring with }", "start": [878, 1], "end": [879, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "tendsto_rpow_atTop", "code": "theorem tendsto_rpow_atTop {y : \u211d} (hy : 0 < y) : Tendsto (fun x : \u211d => x ^ y) atTop atTop", "start": [34, 1], "end": [45, 94], "kind": "commanddeclaration"}, {"full_name": "tendsto_rpow_neg_atTop", "code": "theorem tendsto_rpow_neg_atTop {y : \u211d} (hy : 0 < y) : Tendsto (fun x : \u211d => x ^ (-y)) atTop (\ud835\udcdd 0)", "start": [48, 1], "end": [51, 46], "kind": "commanddeclaration"}, {"full_name": "tendsto_rpow_atTop_of_base_lt_one", "code": "lemma tendsto_rpow_atTop_of_base_lt_one (b : \u211d) (hb\u2080 : -1 < b) (hb\u2081 : b < 1) :\n    Tendsto (rpow b) atTop (\ud835\udcdd (0:\u211d)) := by\n  show Tendsto (fun z => b^z) atTop (\ud835\udcdd 0)\n  rcases lt_trichotomy b 0 with hb|rfl|hb\n  case inl =>   simp_rw [Real.rpow_def_of_nonpos hb.le, hb.ne, ite_false]\n    rw [\u2190isLittleO_const_iff (c := (1:\u211d)) one_ne_zero, (one_mul (1 : \u211d)).symm]\n    refine IsLittleO.mul_isBigO ?exp ?cos\n    case exp =>\n      rw [isLittleO_const_iff one_ne_zero]\n      refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_of_neg ?_).mpr tendsto_id\n      rw [\u2190log_neg_eq_log, log_neg_iff (by linarith)]\n      linarith\n    case cos =>\n      rw [isBigO_iff]\n      exact \u27e81, eventually_of_forall fun x => by simp [Real.abs_cos_le_one]\u27e9\n  case inr.inl =>  refine Tendsto.mono_right ?_ (Iff.mpr pure_le_nhds_iff rfl)\n    rw [tendsto_pure]\n    filter_upwards [eventually_ne_atTop 0] with _ hx\n    simp [hx]\n  case inr.inr =>   simp_rw [Real.rpow_def_of_pos hb]\n    refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_of_neg ?_).mpr tendsto_id\n    exact (log_neg_iff hb).mpr hb\u2081", "start": [55, 1], "end": [79, 35], "kind": "mathlibtacticlemma"}, {"full_name": "tendsto_rpow_atTop_of_base_gt_one", "code": "lemma tendsto_rpow_atTop_of_base_gt_one (b : \u211d) (hb : 1 < b) :\n    Tendsto (rpow b) atBot (\ud835\udcdd (0:\u211d)) := by\n  show Tendsto (fun z => b^z) atBot (nhds 0)\n  simp_rw [Real.rpow_def_of_pos (by positivity : 0 < b)]\n  refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_of_pos ?_).mpr tendsto_id\n  exact (log_pos_iff (by positivity)).mpr <| by aesop", "start": [81, 1], "end": [86, 54], "kind": "mathlibtacticlemma"}, {"full_name": "tendsto_rpow_atBot_of_base_lt_one", "code": "lemma tendsto_rpow_atBot_of_base_lt_one (b : \u211d) (hb\u2080 : 0 < b) (hb\u2081 : b < 1) :\n    Tendsto (rpow b) atBot atTop := by\n  show Tendsto (fun z => b^z) atBot atTop\n  simp_rw [Real.rpow_def_of_pos (by positivity : 0 < b)]\n  refine tendsto_exp_atTop.comp <| (tendsto_const_mul_atTop_iff_neg <| tendsto_id (\u03b1 := \u211d)).mpr ?_\n  exact (log_neg_iff hb\u2080).mpr hb\u2081", "start": [88, 1], "end": [93, 34], "kind": "mathlibtacticlemma"}, {"full_name": "tendsto_rpow_atBot_of_base_gt_one", "code": "lemma tendsto_rpow_atBot_of_base_gt_one (b : \u211d) (hb : 1 < b) : Tendsto (rpow b) atBot (\ud835\udcdd 0) := by\n  show Tendsto (fun z => b^z) atBot (\ud835\udcdd 0)\n  simp_rw [Real.rpow_def_of_pos (by positivity : 0 < b)]\n  refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_iff_pos <| tendsto_id (\u03b1 := \u211d)).mpr ?_\n  exact (log_pos_iff (by positivity)).mpr <| by aesop", "start": [95, 1], "end": [99, 54], "kind": "mathlibtacticlemma"}, {"full_name": "tendsto_rpow_div_mul_add", "code": "theorem tendsto_rpow_div_mul_add (a b c : \u211d) (hb : 0 \u2260 b) :\n    Tendsto (fun x => x ^ (a / (b * x + c))) atTop (\ud835\udcdd 1)", "start": [102, 1], "end": [118, 13], "kind": "commanddeclaration"}, {"full_name": "tendsto_rpow_div", "code": "theorem tendsto_rpow_div : Tendsto (fun x => x ^ ((1 : \u211d) / x)) atTop (\ud835\udcdd 1)", "start": [121, 1], "end": [126, 7], "kind": "commanddeclaration"}, {"full_name": "tendsto_rpow_neg_div", "code": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : \u211d) / x)) atTop (\ud835\udcdd 1)", "start": [129, 1], "end": [134, 7], "kind": "commanddeclaration"}, {"full_name": "tendsto_exp_div_rpow_atTop", "code": "theorem tendsto_exp_div_rpow_atTop (s : \u211d) : Tendsto (fun x : \u211d => exp x / x ^ s) atTop atTop", "start": [137, 1], "end": [143, 46], "kind": "commanddeclaration"}, {"full_name": "tendsto_exp_mul_div_rpow_atTop", "code": "theorem tendsto_exp_mul_div_rpow_atTop (s : \u211d) (b : \u211d) (hb : 0 < b) :\n    Tendsto (fun x : \u211d => exp (b * x) / x ^ s) atTop atTop", "start": [146, 1], "end": [152, 27], "kind": "commanddeclaration"}, {"full_name": "tendsto_rpow_mul_exp_neg_mul_atTop_nhds_0", "code": "theorem tendsto_rpow_mul_exp_neg_mul_atTop_nhds_0 (s : \u211d) (b : \u211d) (hb : 0 < b) :\n    Tendsto (fun x : \u211d => x ^ s * exp (-b * x)) atTop (\ud835\udcdd 0)", "start": [155, 1], "end": [159, 83], "kind": "commanddeclaration"}, {"full_name": "NNReal.tendsto_rpow_atTop", "code": "nonrec theorem NNReal.tendsto_rpow_atTop {y : \u211d} (hy : 0 < y) :\n    Tendsto (fun x : \u211d\u22650 => x ^ y) atTop atTop", "start": [162, 1], "end": [169, 58], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_rpow_at_top", "code": "theorem ENNReal.tendsto_rpow_at_top {y : \u211d} (hy : 0 < y) :\n    Tendsto (fun x : \u211d\u22650\u221e => x ^ y) (\ud835\udcdd \u22a4) (\ud835\udcdd \u22a4)", "start": [172, 1], "end": [187, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.isTheta_exp_arg_mul_im", "code": "theorem isTheta_exp_arg_mul_im (hl : IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => |(g x).im|) :\n    (fun x => Real.exp (arg (f x) * im (g x))) =\u0398[l] fun _ => (1 : \u211d)", "start": [205, 1], "end": [212, 70], "kind": "commanddeclaration"}, {"full_name": "Complex.isBigO_cpow_rpow", "code": "theorem isBigO_cpow_rpow (hl : IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => |(g x).im|) :\n    (fun x => f x ^ g x) =O[l] fun x => abs (f x) ^ (g x).re", "start": [215, 1], "end": [225, 10], "kind": "commanddeclaration"}, {"full_name": "Complex.isTheta_cpow_rpow", "code": "theorem isTheta_cpow_rpow (hl_im : IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => |(g x).im|)\n    (hl : \u2200\u1da0 x in l, f x = 0 \u2192 re (g x) = 0 \u2192 g x = 0) :\n    (fun x => f x ^ g x) =\u0398[l] fun x => abs (f x) ^ (g x).re", "start": [228, 1], "end": [239, 10], "kind": "commanddeclaration"}, {"full_name": "Complex.isTheta_cpow_const_rpow", "code": "theorem isTheta_cpow_const_rpow {b : \u2102} (hl : b.re = 0 \u2192 b \u2260 0 \u2192 \u2200\u1da0 x in l, f x \u2260 0) :\n    (fun x => f x ^ b) =\u0398[l] fun x => abs (f x) ^ b.re", "start": [242, 1], "end": [251, 10], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.rpow", "code": "theorem IsBigOWith.rpow (h : IsBigOWith c l f g) (hc : 0 \u2264 c) (hr : 0 \u2264 r) (hg : 0 \u2264\u1da0[l] g) :\n    IsBigOWith (c ^ r) l (fun x => f x ^ r) fun x => g x ^ r", "start": [264, 1], "end": [271, 88], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.rpow", "code": "theorem IsBigO.rpow (hr : 0 \u2264 r) (hg : 0 \u2264\u1da0[l] g) (h : f =O[l] g) :\n    (fun x => f x ^ r) =O[l] fun x => g x ^ r", "start": [274, 1], "end": [277, 28], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.rpow", "code": "theorem IsLittleO.rpow (hr : 0 < r) (hg : 0 \u2264\u1da0[l] g) (h : f =o[l] g) :\n    (fun x => f x ^ r) =o[l] fun x => g x ^ r", "start": [280, 1], "end": [285, 71], "kind": "commanddeclaration"}, {"full_name": "isLittleO_rpow_exp_pos_mul_atTop", "code": "theorem isLittleO_rpow_exp_pos_mul_atTop (s : \u211d) {b : \u211d} (hb : 0 < b) :\n    (fun x : \u211d => x ^ s) =o[atTop] fun x => exp (b * x)", "start": [292, 1], "end": [297, 55], "kind": "commanddeclaration"}, {"full_name": "isLittleO_zpow_exp_pos_mul_atTop", "code": "theorem isLittleO_zpow_exp_pos_mul_atTop (k : \u2124) {b : \u211d} (hb : 0 < b) :\n    (fun x : \u211d => x ^ k) =o[atTop] fun x => exp (b * x)", "start": [300, 1], "end": [303, 73], "kind": "commanddeclaration"}, {"full_name": "isLittleO_pow_exp_pos_mul_atTop", "code": "theorem isLittleO_pow_exp_pos_mul_atTop (k : \u2115) {b : \u211d} (hb : 0 < b) :\n    (fun x : \u211d => x ^ k) =o[atTop] fun x => exp (b * x)", "start": [306, 1], "end": [309, 52], "kind": "commanddeclaration"}, {"full_name": "isLittleO_rpow_exp_atTop", "code": "theorem isLittleO_rpow_exp_atTop (s : \u211d) : (fun x : \u211d => x ^ s) =o[atTop] exp", "start": [312, 1], "end": [314, 72], "kind": "commanddeclaration"}, {"full_name": "isLittleO_exp_neg_mul_rpow_atTop", "code": "theorem isLittleO_exp_neg_mul_rpow_atTop {a : \u211d} (ha : 0 < a) (b : \u211d) :\n    IsLittleO atTop (fun x : \u211d => exp (-a * x)) fun x : \u211d => x ^ b", "start": [317, 1], "end": [327, 91], "kind": "commanddeclaration"}, {"full_name": "isLittleO_log_rpow_atTop", "code": "theorem isLittleO_log_rpow_atTop {r : \u211d} (hr : 0 < r) : log =o[atTop] fun x => x ^ r", "start": [330, 1], "end": [335, 94], "kind": "commanddeclaration"}, {"full_name": "isLittleO_log_rpow_rpow_atTop", "code": "theorem isLittleO_log_rpow_rpow_atTop {s : \u211d} (r : \u211d) (hs : 0 < s) :\n    (fun x => log x ^ r) =o[atTop] fun x => x ^ s", "start": [338, 1], "end": [354, 101], "kind": "commanddeclaration"}, {"full_name": "isLittleO_abs_log_rpow_rpow_nhds_zero", "code": "theorem isLittleO_abs_log_rpow_rpow_nhds_zero {s : \u211d} (r : \u211d) (hs : s < 0) :\n    (fun x => |log x| ^ r) =o[\ud835\udcdd[>] 0] fun x => x ^ s", "start": [357, 1], "end": [363, 81], "kind": "commanddeclaration"}, {"full_name": "isLittleO_log_rpow_nhds_zero", "code": "theorem isLittleO_log_rpow_nhds_zero {r : \u211d} (hr : r < 0) : log =o[\ud835\udcdd[>] 0] fun x => x ^ r", "start": [366, 1], "end": [370, 21], "kind": "commanddeclaration"}, {"full_name": "tendsto_log_div_rpow_nhds_zero", "code": "theorem tendsto_log_div_rpow_nhds_zero {r : \u211d} (hr : r < 0) :\n    Tendsto (fun x => log x / x ^ r) (\ud835\udcdd[>] 0) (\ud835\udcdd 0)", "start": [373, 1], "end": [375, 58], "kind": "commanddeclaration"}, {"full_name": "tendsto_log_mul_rpow_nhds_zero", "code": "theorem tendsto_log_mul_rpow_nhds_zero {r : \u211d} (hr : 0 < r) :\n    Tendsto (fun x => log x * x ^ r) (\ud835\udcdd[>] 0) (\ud835\udcdd 0)", "start": [378, 1], "end": [381, 90], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/SpecialFunctions/Basic.lean", "imports": ["Mathlib/MeasureTheory/Constructions/BorelSpace/Complex.lean", "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.measurable_exp", "code": "@[measurability]\ntheorem measurable_exp : Measurable exp", "start": [28, 1], "end": [30, 28], "kind": "commanddeclaration"}, {"full_name": "Real.measurable_log", "code": "@[measurability]\ntheorem measurable_log : Measurable log", "start": [33, 1], "end": [36, 85], "kind": "commanddeclaration"}, {"full_name": "Real.measurable_sin", "code": "@[measurability]\ntheorem measurable_sin : Measurable sin", "start": [39, 1], "end": [41, 28], "kind": "commanddeclaration"}, {"full_name": "Real.measurable_cos", "code": "@[measurability]\ntheorem measurable_cos : Measurable cos", "start": [44, 1], "end": [46, 28], "kind": "commanddeclaration"}, {"full_name": "Real.measurable_sinh", "code": "@[measurability]\ntheorem measurable_sinh : Measurable sinh", "start": [49, 1], "end": [51, 29], "kind": "commanddeclaration"}, {"full_name": "Real.measurable_cosh", "code": "@[measurability]\ntheorem measurable_cosh : Measurable cosh", "start": [54, 1], "end": [56, 29], "kind": "commanddeclaration"}, {"full_name": "Real.measurable_arcsin", "code": "@[measurability]\ntheorem measurable_arcsin : Measurable arcsin", "start": [59, 1], "end": [61, 31], "kind": "commanddeclaration"}, {"full_name": "Real.measurable_arccos", "code": "@[measurability]\ntheorem measurable_arccos : Measurable arccos", "start": [64, 1], "end": [66, 31], "kind": "commanddeclaration"}, {"full_name": "Complex.measurable_re", "code": "@[measurability]\ntheorem measurable_re : Measurable re", "start": [73, 1], "end": [75, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.measurable_im", "code": "@[measurability]\ntheorem measurable_im : Measurable im", "start": [78, 1], "end": [80, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.measurable_ofReal", "code": "@[measurability]\ntheorem measurable_ofReal : Measurable ((\u2191) : \u211d \u2192 \u2102)", "start": [83, 1], "end": [85, 31], "kind": "commanddeclaration"}, {"full_name": "Complex.measurable_exp", "code": "@[measurability]\ntheorem measurable_exp : Measurable exp", "start": [88, 1], "end": [90, 28], "kind": "commanddeclaration"}, {"full_name": "Complex.measurable_sin", "code": "@[measurability]\ntheorem measurable_sin : Measurable sin", "start": [93, 1], "end": [95, 28], "kind": "commanddeclaration"}, {"full_name": "Complex.measurable_cos", "code": "@[measurability]\ntheorem measurable_cos : Measurable cos", "start": [98, 1], "end": [100, 28], "kind": "commanddeclaration"}, {"full_name": "Complex.measurable_sinh", "code": "@[measurability]\ntheorem measurable_sinh : Measurable sinh", "start": [103, 1], "end": [105, 29], "kind": "commanddeclaration"}, {"full_name": "Complex.measurable_cosh", "code": "@[measurability]\ntheorem measurable_cosh : Measurable cosh", "start": [108, 1], "end": [110, 29], "kind": "commanddeclaration"}, {"full_name": "Complex.measurable_arg", "code": "@[measurability]\ntheorem measurable_arg : Measurable arg", "start": [113, 1], "end": [121, 22], "kind": "commanddeclaration"}, {"full_name": "Complex.measurable_log", "code": "@[measurability]\ntheorem measurable_log : Measurable log", "start": [124, 1], "end": [127, 56], "kind": "commanddeclaration"}, {"full_name": "Measurable.exp", "code": "@[measurability]\ntheorem Measurable.exp : Measurable fun x => Real.exp (f x)", "start": [138, 1], "end": [140, 30], "kind": "commanddeclaration"}, {"full_name": "Measurable.log", "code": "@[measurability]\ntheorem Measurable.log : Measurable fun x => log (f x)", "start": [143, 1], "end": [145, 25], "kind": "commanddeclaration"}, {"full_name": "Measurable.cos", "code": "@[measurability]\ntheorem Measurable.cos : Measurable fun x => Real.cos (f x)", "start": [148, 1], "end": [150, 30], "kind": "commanddeclaration"}, {"full_name": "Measurable.sin", "code": "@[measurability]\ntheorem Measurable.sin : Measurable fun x => Real.sin (f x)", "start": [153, 1], "end": [155, 30], "kind": "commanddeclaration"}, {"full_name": "Measurable.cosh", "code": "@[measurability]\ntheorem Measurable.cosh : Measurable fun x => Real.cosh (f x)", "start": [158, 1], "end": [160, 31], "kind": "commanddeclaration"}, {"full_name": "Measurable.sinh", "code": "@[measurability]\ntheorem Measurable.sinh : Measurable fun x => Real.sinh (f x)", "start": [163, 1], "end": [165, 31], "kind": "commanddeclaration"}, {"full_name": "Measurable.sqrt", "code": "@[measurability]\ntheorem Measurable.sqrt : Measurable fun x => sqrt (f x)", "start": [168, 1], "end": [170, 37], "kind": "commanddeclaration"}, {"full_name": "Measurable.cexp", "code": "@[measurability]\ntheorem Measurable.cexp : Measurable fun x => Complex.exp (f x)", "start": [181, 1], "end": [183, 33], "kind": "commanddeclaration"}, {"full_name": "Measurable.ccos", "code": "@[measurability]\ntheorem Measurable.ccos : Measurable fun x => Complex.cos (f x)", "start": [186, 1], "end": [188, 33], "kind": "commanddeclaration"}, {"full_name": "Measurable.csin", "code": "@[measurability]\ntheorem Measurable.csin : Measurable fun x => Complex.sin (f x)", "start": [191, 1], "end": [193, 33], "kind": "commanddeclaration"}, {"full_name": "Measurable.ccosh", "code": "@[measurability]\ntheorem Measurable.ccosh : Measurable fun x => Complex.cosh (f x)", "start": [196, 1], "end": [198, 34], "kind": "commanddeclaration"}, {"full_name": "Measurable.csinh", "code": "@[measurability]\ntheorem Measurable.csinh : Measurable fun x => Complex.sinh (f x)", "start": [201, 1], "end": [203, 34], "kind": "commanddeclaration"}, {"full_name": "Measurable.carg", "code": "@[measurability]\ntheorem Measurable.carg : Measurable fun x => arg (f x)", "start": [206, 1], "end": [208, 25], "kind": "commanddeclaration"}, {"full_name": "Measurable.clog", "code": "@[measurability]\ntheorem Measurable.clog : Measurable fun x => Complex.log (f x)", "start": [211, 1], "end": [213, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.hasMeasurablePow", "code": "instance Complex.hasMeasurablePow : MeasurablePow \u2102 \u2102 :=\n  \u27e8Measurable.ite (measurable_fst (measurableSet_singleton 0))\n      (Measurable.ite (measurable_snd (measurableSet_singleton 0)) measurable_one measurable_zero)\n      (measurable_fst.clog.mul measurable_snd).cexp\u27e9", "start": [220, 1], "end": [223, 53], "kind": "commanddeclaration"}, {"full_name": "Real.hasMeasurablePow", "code": "instance Real.hasMeasurablePow : MeasurablePow \u211d \u211d :=\n  \u27e8Complex.measurable_re.comp <|\n      (Complex.measurable_ofReal.comp measurable_fst).pow\n        (Complex.measurable_ofReal.comp measurable_snd)\u27e9", "start": [226, 1], "end": [229, 57], "kind": "commanddeclaration"}, {"full_name": "NNReal.hasMeasurablePow", "code": "instance NNReal.hasMeasurablePow : MeasurablePow \u211d\u22650 \u211d :=\n  \u27e8(measurable_fst.coe_nnreal_real.pow measurable_snd).subtype_mk\u27e9", "start": [232, 1], "end": [233, 67], "kind": "commanddeclaration"}, {"full_name": "ENNReal.hasMeasurablePow", "code": "instance ENNReal.hasMeasurablePow : MeasurablePow \u211d\u22650\u221e \u211d := by\n  refine' \u27e8ENNReal.measurable_of_measurable_nnreal_prod _ _\u27e9\n  \u00b7 simp_rw [ENNReal.coe_rpow_def]\n    refine' Measurable.ite _ measurable_const (measurable_fst.pow measurable_snd).coe_nnreal_ennreal\n    exact\n      MeasurableSet.inter (measurable_fst (measurableSet_singleton 0))\n        (measurable_snd measurableSet_Iio)\n  \u00b7 simp_rw [ENNReal.top_rpow_def]\n    refine' Measurable.ite measurableSet_Ioi measurable_const _\n    exact Measurable.ite (measurableSet_singleton 0) measurable_const measurable_const", "start": [236, 1], "end": [245, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/MeanInequalities.lean", "imports": ["Mathlib/Data/Real/ConjugateExponents.lean", "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Convex/Jensen.lean", "Mathlib/Analysis/Convex/SpecificFunctions/Basic.lean"], "premises": [{"full_name": "Real.geom_mean_le_arith_mean_weighted", "code": "theorem geom_mean_le_arith_mean_weighted (w z : \u03b9 \u2192 \u211d) (hw : \u2200 i \u2208 s, 0 \u2264 w i)\n    (hw' : \u2211 i in s, w i = 1) (hz : \u2200 i \u2208 s, 0 \u2264 z i) :\n    \u220f i in s, z i ^ w i \u2264 \u2211 i in s, w i * z i", "start": [112, 1], "end": [135, 24], "kind": "commanddeclaration"}, {"full_name": "Real.geom_mean_weighted_of_constant", "code": "theorem geom_mean_weighted_of_constant (w z : \u03b9 \u2192 \u211d) (x : \u211d) (hw : \u2200 i \u2208 s, 0 \u2264 w i)\n    (hw' : \u2211 i in s, w i = 1) (hz : \u2200 i \u2208 s, 0 \u2264 z i) (hx : \u2200 i \u2208 s, w i \u2260 0 \u2192 z i = x) :\n    \u220f i in s, z i ^ w i = x", "start": [138, 1], "end": [154, 21], "kind": "commanddeclaration"}, {"full_name": "Real.arith_mean_weighted_of_constant", "code": "theorem arith_mean_weighted_of_constant (w z : \u03b9 \u2192 \u211d) (x : \u211d) (hw' : \u2211 i in s, w i = 1)\n    (hx : \u2200 i \u2208 s, w i \u2260 0 \u2192 z i = x) : \u2211 i in s, w i * z i = x", "start": [157, 1], "end": [165, 45], "kind": "commanddeclaration"}, {"full_name": "Real.geom_mean_eq_arith_mean_weighted_of_constant", "code": "theorem geom_mean_eq_arith_mean_weighted_of_constant (w z : \u03b9 \u2192 \u211d) (x : \u211d) (hw : \u2200 i \u2208 s, 0 \u2264 w i)\n    (hw' : \u2211 i in s, w i = 1) (hz : \u2200 i \u2208 s, 0 \u2264 z i) (hx : \u2200 i \u2208 s, w i \u2260 0 \u2192 z i = x) :\n    \u220f i in s, z i ^ w i = \u2211 i in s, w i * z i", "start": [168, 1], "end": [171, 86], "kind": "commanddeclaration"}, {"full_name": "NNReal.geom_mean_le_arith_mean_weighted", "code": "theorem geom_mean_le_arith_mean_weighted (w z : \u03b9 \u2192 \u211d\u22650) (hw' : \u2211 i in s, w i = 1) :\n    (\u220f i in s, z i ^ (w i : \u211d)) \u2264 \u2211 i in s, w i * z i", "start": [178, 1], "end": [184, 59], "kind": "commanddeclaration"}, {"full_name": "NNReal.geom_mean_le_arith_mean2_weighted", "code": "theorem geom_mean_le_arith_mean2_weighted (w\u2081 w\u2082 p\u2081 p\u2082 : \u211d\u22650) :\n    w\u2081 + w\u2082 = 1 \u2192 p\u2081 ^ (w\u2081 : \u211d) * p\u2082 ^ (w\u2082 : \u211d) \u2264 w\u2081 * p\u2081 + w\u2082 * p\u2082", "start": [187, 1], "end": [193, 62], "kind": "commanddeclaration"}, {"full_name": "NNReal.geom_mean_le_arith_mean3_weighted", "code": "theorem geom_mean_le_arith_mean3_weighted (w\u2081 w\u2082 w\u2083 p\u2081 p\u2082 p\u2083 : \u211d\u22650) :\n    w\u2081 + w\u2082 + w\u2083 = 1 \u2192\n      p\u2081 ^ (w\u2081 : \u211d) * p\u2082 ^ (w\u2082 : \u211d) * p\u2083 ^ (w\u2083 : \u211d) \u2264 w\u2081 * p\u2081 + w\u2082 * p\u2082 + w\u2083 * p\u2083", "start": [196, 1], "end": [201, 87], "kind": "commanddeclaration"}, {"full_name": "NNReal.geom_mean_le_arith_mean4_weighted", "code": "theorem geom_mean_le_arith_mean4_weighted (w\u2081 w\u2082 w\u2083 w\u2084 p\u2081 p\u2082 p\u2083 p\u2084 : \u211d\u22650) :\n    w\u2081 + w\u2082 + w\u2083 + w\u2084 = 1 \u2192\n      p\u2081 ^ (w\u2081 : \u211d) * p\u2082 ^ (w\u2082 : \u211d) * p\u2083 ^ (w\u2083 : \u211d) * p\u2084 ^ (w\u2084 : \u211d) \u2264\n        w\u2081 * p\u2081 + w\u2082 * p\u2082 + w\u2083 * p\u2083 + w\u2084 * p\u2084", "start": [204, 1], "end": [210, 95], "kind": "commanddeclaration"}, {"full_name": "Real.geom_mean_le_arith_mean2_weighted", "code": "theorem geom_mean_le_arith_mean2_weighted {w\u2081 w\u2082 p\u2081 p\u2082 : \u211d} (hw\u2081 : 0 \u2264 w\u2081) (hw\u2082 : 0 \u2264 w\u2082)\n    (hp\u2081 : 0 \u2264 p\u2081) (hp\u2082 : 0 \u2264 p\u2082) (hw : w\u2081 + w\u2082 = 1) : p\u2081 ^ w\u2081 * p\u2082 ^ w\u2082 \u2264 w\u2081 * p\u2081 + w\u2082 * p\u2082", "start": [217, 1], "end": [220, 37], "kind": "commanddeclaration"}, {"full_name": "Real.geom_mean_le_arith_mean3_weighted", "code": "theorem geom_mean_le_arith_mean3_weighted {w\u2081 w\u2082 w\u2083 p\u2081 p\u2082 p\u2083 : \u211d} (hw\u2081 : 0 \u2264 w\u2081) (hw\u2082 : 0 \u2264 w\u2082)\n    (hw\u2083 : 0 \u2264 w\u2083) (hp\u2081 : 0 \u2264 p\u2081) (hp\u2082 : 0 \u2264 p\u2082) (hp\u2083 : 0 \u2264 p\u2083) (hw : w\u2081 + w\u2082 + w\u2083 = 1) :\n    p\u2081 ^ w\u2081 * p\u2082 ^ w\u2082 * p\u2083 ^ w\u2083 \u2264 w\u2081 * p\u2081 + w\u2082 * p\u2082 + w\u2083 * p\u2083", "start": [223, 1], "end": [228, 23], "kind": "commanddeclaration"}, {"full_name": "Real.geom_mean_le_arith_mean4_weighted", "code": "theorem geom_mean_le_arith_mean4_weighted {w\u2081 w\u2082 w\u2083 w\u2084 p\u2081 p\u2082 p\u2083 p\u2084 : \u211d} (hw\u2081 : 0 \u2264 w\u2081)\n    (hw\u2082 : 0 \u2264 w\u2082) (hw\u2083 : 0 \u2264 w\u2083) (hw\u2084 : 0 \u2264 w\u2084) (hp\u2081 : 0 \u2264 p\u2081) (hp\u2082 : 0 \u2264 p\u2082) (hp\u2083 : 0 \u2264 p\u2083)\n    (hp\u2084 : 0 \u2264 p\u2084) (hw : w\u2081 + w\u2082 + w\u2083 + w\u2084 = 1) :\n    p\u2081 ^ w\u2081 * p\u2082 ^ w\u2082 * p\u2083 ^ w\u2083 * p\u2084 ^ w\u2084 \u2264 w\u2081 * p\u2081 + w\u2082 * p\u2082 + w\u2083 * p\u2083 + w\u2084 * p\u2084", "start": [231, 1], "end": [237, 37], "kind": "commanddeclaration"}, {"full_name": "Real.young_inequality_of_nonneg", "code": "theorem young_inequality_of_nonneg {a b p q : \u211d} (ha : 0 \u2264 a) (hb : 0 \u2264 b)\n    (hpq : p.IsConjugateExponent q) : a * b \u2264 a ^ p / p + b ^ q / q", "start": [251, 1], "end": [256, 85], "kind": "commanddeclaration"}, {"full_name": "Real.young_inequality", "code": "theorem young_inequality (a b : \u211d) {p q : \u211d} (hpq : p.IsConjugateExponent q) :\n    a * b \u2264 |a| ^ p / p + |b| ^ q / q", "start": [259, 1], "end": [266, 72], "kind": "commanddeclaration"}, {"full_name": "NNReal.young_inequality", "code": "theorem young_inequality (a b : \u211d\u22650) {p q : \u211d\u22650} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) :\n    a * b \u2264 a ^ (p : \u211d) / p + b ^ (q : \u211d) / q", "start": [273, 1], "end": [277, 86], "kind": "commanddeclaration"}, {"full_name": "NNReal.young_inequality_real", "code": "theorem young_inequality_real (a b : \u211d\u22650) {p q : \u211d} (hpq : p.IsConjugateExponent q) :\n    a * b \u2264 a ^ p / Real.toNNReal p + b ^ q / Real.toNNReal q", "start": [280, 1], "end": [285, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.young_inequality", "code": "theorem young_inequality (a b : \u211d\u22650\u221e) {p q : \u211d} (hpq : p.IsConjugateExponent q) :\n    a * b \u2264 a ^ p / ENNReal.ofReal p + b ^ q / ENNReal.ofReal q", "start": [292, 1], "end": [305, 63], "kind": "commanddeclaration"}, {"full_name": "NNReal.inner_le_Lp_mul_Lp_of_norm_le_one", "code": "private theorem inner_le_Lp_mul_Lp_of_norm_le_one (f g : \u03b9 \u2192 \u211d\u22650) {p q : \u211d}\n    (hpq : p.IsConjugateExponent q) (hf : \u2211 i in s, f i ^ p \u2264 1) (hg : \u2211 i in s, g i ^ q \u2264 1) :\n    \u2211 i in s, f i * g i \u2264 1", "start": [319, 1], "end": [333, 41], "kind": "commanddeclaration"}, {"full_name": "NNReal.inner_le_Lp_mul_Lp_of_norm_eq_zero", "code": "private theorem inner_le_Lp_mul_Lp_of_norm_eq_zero (f g : \u03b9 \u2192 \u211d\u22650) {p q : \u211d}\n    (hpq : p.IsConjugateExponent q) (hf : \u2211 i in s, f i ^ p = 0) :\n    \u2211 i in s, f i * g i \u2264 (\u2211 i in s, f i ^ p) ^ (1 / p) * (\u2211 i in s, g i ^ q) ^ (1 / q)", "start": [335, 1], "end": [343, 46], "kind": "commanddeclaration"}, {"full_name": "NNReal.inner_le_Lp_mul_Lq", "code": "theorem inner_le_Lp_mul_Lq (f g : \u03b9 \u2192 \u211d\u22650) {p q : \u211d} (hpq : p.IsConjugateExponent q) :\n    \u2211 i in s, f i * g i \u2264 (\u2211 i in s, f i ^ p) ^ (1 / p) * (\u2211 i in s, g i ^ q) ^ (1 / q)", "start": [345, 1], "end": [374, 34], "kind": "commanddeclaration"}, {"full_name": "NNReal.inner_le_Lp_mul_Lq_tsum", "code": "theorem inner_le_Lp_mul_Lq_tsum {f g : \u03b9 \u2192 \u211d\u22650} {p q : \u211d} (hpq : p.IsConjugateExponent q)\n    (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ q) :\n    (Summable fun i => f i * g i) \u2227\n      \u2211' i, f i * g i \u2264 (\u2211' i, f i ^ p) ^ (1 / p) * (\u2211' i, g i ^ q) ^ (1 / q)", "start": [377, 1], "end": [398, 38], "kind": "commanddeclaration"}, {"full_name": "NNReal.summable_mul_of_Lp_Lq", "code": "theorem summable_mul_of_Lp_Lq {f g : \u03b9 \u2192 \u211d\u22650} {p q : \u211d} (hpq : p.IsConjugateExponent q)\n    (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ q) :\n    Summable fun i => f i * g i", "start": [401, 1], "end": [404, 40], "kind": "commanddeclaration"}, {"full_name": "NNReal.inner_le_Lp_mul_Lq_tsum'", "code": "theorem inner_le_Lp_mul_Lq_tsum' {f g : \u03b9 \u2192 \u211d\u22650} {p q : \u211d} (hpq : p.IsConjugateExponent q)\n    (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ q) :\n    \u2211' i, f i * g i \u2264 (\u2211' i, f i ^ p) ^ (1 / p) * (\u2211' i, g i ^ q) ^ (1 / q)", "start": [407, 1], "end": [410, 40], "kind": "commanddeclaration"}, {"full_name": "NNReal.inner_le_Lp_mul_Lq_hasSum", "code": "theorem inner_le_Lp_mul_Lq_hasSum {f g : \u03b9 \u2192 \u211d\u22650} {A B : \u211d\u22650} {p q : \u211d}\n    (hpq : p.IsConjugateExponent q) (hf : HasSum (fun i => f i ^ p) (A ^ p))\n    (hg : HasSum (fun i => g i ^ q) (B ^ q)) : \u2203 C, C \u2264 A * B \u2227 HasSum (fun i => f i * g i) C", "start": [413, 1], "end": [426, 64], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_sum_le_const_mul_sum_rpow", "code": "theorem rpow_sum_le_const_mul_sum_rpow (f : \u03b9 \u2192 \u211d\u22650) {p : \u211d} (hp : 1 \u2264 p) :\n    (\u2211 i in s, f i) ^ p \u2264 (card s : \u211d\u22650) ^ (p - 1) * \u2211 i in s, f i ^ p", "start": [429, 1], "end": [444, 71], "kind": "commanddeclaration"}, {"full_name": "NNReal.isGreatest_Lp", "code": "theorem isGreatest_Lp (f : \u03b9 \u2192 \u211d\u22650) {p q : \u211d} (hpq : p.IsConjugateExponent q) :\n    IsGreatest ((fun g : \u03b9 \u2192 \u211d\u22650 => \u2211 i in s, f i * g i) '' { g | \u2211 i in s, g i ^ q \u2264 1 })\n      ((\u2211 i in s, f i ^ p) ^ (1 / p))", "start": [447, 1], "end": [468, 81], "kind": "commanddeclaration"}, {"full_name": "NNReal.Lp_add_le", "code": "theorem Lp_add_le (f g : \u03b9 \u2192 \u211d\u22650) {p : \u211d} (hp : 1 \u2264 p) :\n    (\u2211 i in s, (f i + g i) ^ p) ^ (1 / p) \u2264\n      (\u2211 i in s, f i ^ p) ^ (1 / p) + (\u2211 i in s, g i ^ p) ^ (1 / p)", "start": [471, 1], "end": [485, 97], "kind": "commanddeclaration"}, {"full_name": "NNReal.Lp_add_le_tsum", "code": "theorem Lp_add_le_tsum {f g : \u03b9 \u2192 \u211d\u22650} {p : \u211d} (hp : 1 \u2264 p) (hf : Summable fun i => f i ^ p)\n    (hg : Summable fun i => g i ^ p) :\n    (Summable fun i => (f i + g i) ^ p) \u2227\n      (\u2211' i, (f i + g i) ^ p) ^ (1 / p) \u2264\n        (\u2211' i, f i ^ p) ^ (1 / p) + (\u2211' i, g i ^ p) ^ (1 / p)", "start": [488, 1], "end": [514, 34], "kind": "commanddeclaration"}, {"full_name": "NNReal.summable_Lp_add", "code": "theorem summable_Lp_add {f g : \u03b9 \u2192 \u211d\u22650} {p : \u211d} (hp : 1 \u2264 p) (hf : Summable fun i => f i ^ p)\n    (hg : Summable fun i => g i ^ p) : Summable fun i => (f i + g i) ^ p", "start": [517, 1], "end": [519, 30], "kind": "commanddeclaration"}, {"full_name": "NNReal.Lp_add_le_tsum'", "code": "theorem Lp_add_le_tsum' {f g : \u03b9 \u2192 \u211d\u22650} {p : \u211d} (hp : 1 \u2264 p) (hf : Summable fun i => f i ^ p)\n    (hg : Summable fun i => g i ^ p) :\n    (\u2211' i, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211' i, f i ^ p) ^ (1 / p) + (\u2211' i, g i ^ p) ^ (1 / p)", "start": [522, 1], "end": [525, 30], "kind": "commanddeclaration"}, {"full_name": "NNReal.Lp_add_le_hasSum", "code": "theorem Lp_add_le_hasSum {f g : \u03b9 \u2192 \u211d\u22650} {A B : \u211d\u22650} {p : \u211d} (hp : 1 \u2264 p)\n    (hf : HasSum (fun i => f i ^ p) (A ^ p)) (hg : HasSum (fun i => g i ^ p) (B ^ p)) :\n    \u2203 C, C \u2264 A + B \u2227 HasSum (fun i => (f i + g i) ^ p) (C ^ p)", "start": [528, 1], "end": [541, 56], "kind": "commanddeclaration"}, {"full_name": "Real.inner_le_Lp_mul_Lq", "code": "theorem inner_le_Lp_mul_Lq (hpq : IsConjugateExponent p q) :\n    \u2211 i in s, f i * g i \u2264 (\u2211 i in s, |f i| ^ p) ^ (1 / p) * (\u2211 i in s, |g i| ^ q) ^ (1 / q)", "start": [550, 1], "end": [561, 37], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_sum_le_const_mul_sum_rpow", "code": "theorem rpow_sum_le_const_mul_sum_rpow (hp : 1 \u2264 p) :\n    (\u2211 i in s, |f i|) ^ p \u2264 (card s : \u211d) ^ (p - 1) * \u2211 i in s, |f i| ^ p", "start": [564, 1], "end": [572, 13], "kind": "commanddeclaration"}, {"full_name": "Real.Lp_add_le", "code": "theorem Lp_add_le (hp : 1 \u2264 p) :\n    (\u2211 i in s, |f i + g i| ^ p) ^ (1 / p) \u2264\n      (\u2211 i in s, |f i| ^ p) ^ (1 / p) + (\u2211 i in s, |g i| ^ p) ^ (1 / p)", "start": [576, 1], "end": [587, 20], "kind": "commanddeclaration"}, {"full_name": "Real.inner_le_Lp_mul_Lq_of_nonneg", "code": "theorem inner_le_Lp_mul_Lq_of_nonneg (hpq : IsConjugateExponent p q) (hf : \u2200 i \u2208 s, 0 \u2264 f i)\n    (hg : \u2200 i \u2208 s, 0 \u2264 g i) :\n    \u2211 i in s, f i * g i \u2264 (\u2211 i in s, f i ^ p) ^ (1 / p) * (\u2211 i in s, g i ^ q) ^ (1 / q)", "start": [592, 1], "end": [599, 48], "kind": "commanddeclaration"}, {"full_name": "Real.inner_le_Lp_mul_Lq_tsum_of_nonneg", "code": "theorem inner_le_Lp_mul_Lq_tsum_of_nonneg (hpq : p.IsConjugateExponent q) (hf : \u2200 i, 0 \u2264 f i)\n    (hg : \u2200 i, 0 \u2264 g i) (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ q) :\n    (Summable fun i => f i * g i) \u2227\n      \u2211' i, f i * g i \u2264 (\u2211' i, f i ^ p) ^ (1 / p) * (\u2211' i, g i ^ q) ^ (1 / q)", "start": [602, 1], "end": [613, 57], "kind": "commanddeclaration"}, {"full_name": "Real.summable_mul_of_Lp_Lq_of_nonneg", "code": "theorem summable_mul_of_Lp_Lq_of_nonneg (hpq : p.IsConjugateExponent q) (hf : \u2200 i, 0 \u2264 f i)\n    (hg : \u2200 i, 0 \u2264 g i) (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ q) :\n    Summable fun i => f i * g i", "start": [616, 1], "end": [619, 64], "kind": "commanddeclaration"}, {"full_name": "Real.inner_le_Lp_mul_Lq_tsum_of_nonneg'", "code": "theorem inner_le_Lp_mul_Lq_tsum_of_nonneg' (hpq : p.IsConjugateExponent q) (hf : \u2200 i, 0 \u2264 f i)\n    (hg : \u2200 i, 0 \u2264 g i) (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ q) :\n    \u2211' i, f i * g i \u2264 (\u2211' i, f i ^ p) ^ (1 / p) * (\u2211' i, g i ^ q) ^ (1 / q)", "start": [622, 1], "end": [625, 64], "kind": "commanddeclaration"}, {"full_name": "Real.inner_le_Lp_mul_Lq_hasSum_of_nonneg", "code": "theorem inner_le_Lp_mul_Lq_hasSum_of_nonneg (hpq : p.IsConjugateExponent q) {A B : \u211d} (hA : 0 \u2264 A)\n    (hB : 0 \u2264 B) (hf : \u2200 i, 0 \u2264 f i) (hg : \u2200 i, 0 \u2264 g i)\n    (hf_sum : HasSum (fun i => f i ^ p) (A ^ p)) (hg_sum : HasSum (fun i => g i ^ q) (B ^ q)) :\n    \u2203 C : \u211d, 0 \u2264 C \u2227 C \u2264 A * B \u2227 HasSum (fun i => f i * g i) C", "start": [628, 1], "end": [643, 12], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_sum_le_const_mul_sum_rpow_of_nonneg", "code": "theorem rpow_sum_le_const_mul_sum_rpow_of_nonneg (hp : 1 \u2264 p) (hf : \u2200 i \u2208 s, 0 \u2264 f i) :\n    (\u2211 i in s, f i) ^ p \u2264 (card s : \u211d) ^ (p - 1) * \u2211 i in s, f i ^ p", "start": [646, 1], "end": [652, 39], "kind": "commanddeclaration"}, {"full_name": "Real.Lp_add_le_of_nonneg", "code": "theorem Lp_add_le_of_nonneg (hp : 1 \u2264 p) (hf : \u2200 i \u2208 s, 0 \u2264 f i) (hg : \u2200 i \u2208 s, 0 \u2264 g i) :\n    (\u2211 i in s, (f i + g i) ^ p) ^ (1 / p) \u2264\n      (\u2211 i in s, f i ^ p) ^ (1 / p) + (\u2211 i in s, g i ^ p) ^ (1 / p)", "start": [655, 1], "end": [663, 60], "kind": "commanddeclaration"}, {"full_name": "Real.Lp_add_le_tsum_of_nonneg", "code": "theorem Lp_add_le_tsum_of_nonneg (hp : 1 \u2264 p) (hf : \u2200 i, 0 \u2264 f i) (hg : \u2200 i, 0 \u2264 g i)\n    (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ p) :\n    (Summable fun i => (f i + g i) ^ p) \u2227\n      (\u2211' i, (f i + g i) ^ p) ^ (1 / p) \u2264\n        (\u2211' i, f i ^ p) ^ (1 / p) + (\u2211' i, g i ^ p) ^ (1 / p)", "start": [666, 1], "end": [678, 47], "kind": "commanddeclaration"}, {"full_name": "Real.summable_Lp_add_of_nonneg", "code": "theorem summable_Lp_add_of_nonneg (hp : 1 \u2264 p) (hf : \u2200 i, 0 \u2264 f i) (hg : \u2200 i, 0 \u2264 g i)\n    (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ p) :\n    Summable fun i => (f i + g i) ^ p", "start": [681, 1], "end": [684, 54], "kind": "commanddeclaration"}, {"full_name": "Real.Lp_add_le_tsum_of_nonneg'", "code": "theorem Lp_add_le_tsum_of_nonneg' (hp : 1 \u2264 p) (hf : \u2200 i, 0 \u2264 f i) (hg : \u2200 i, 0 \u2264 g i)\n    (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ p) :\n    (\u2211' i, (f i + g i) ^ p) ^ (1 / p) \u2264 (\u2211' i, f i ^ p) ^ (1 / p) + (\u2211' i, g i ^ p) ^ (1 / p)", "start": [687, 1], "end": [690, 54], "kind": "commanddeclaration"}, {"full_name": "Real.Lp_add_le_hasSum_of_nonneg", "code": "theorem Lp_add_le_hasSum_of_nonneg (hp : 1 \u2264 p) (hf : \u2200 i, 0 \u2264 f i) (hg : \u2200 i, 0 \u2264 g i) {A B : \u211d}\n    (hA : 0 \u2264 A) (hB : 0 \u2264 B) (hfA : HasSum (fun i => f i ^ p) (A ^ p))\n    (hgB : HasSum (fun i => g i ^ p) (B ^ p)) :\n    \u2203 C, 0 \u2264 C \u2227 C \u2264 A + B \u2227 HasSum (fun i => (f i + g i) ^ p) (C ^ p)", "start": [693, 1], "end": [709, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inner_le_Lp_mul_Lq", "code": "theorem inner_le_Lp_mul_Lq (hpq : p.IsConjugateExponent q) :\n    \u2211 i in s, f i * g i \u2264 (\u2211 i in s, f i ^ p) ^ (1 / p) * (\u2211 i in s, g i ^ q) ^ (1 / q)", "start": [718, 1], "end": [744, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_sum_le_const_mul_sum_rpow", "code": "theorem rpow_sum_le_const_mul_sum_rpow (hp : 1 \u2264 p) :\n    (\u2211 i in s, f i) ^ p \u2264 (card s : \u211d\u22650\u221e) ^ (p - 1) * \u2211 i in s, f i ^ p", "start": [747, 1], "end": [762, 72], "kind": "commanddeclaration"}, {"full_name": "ENNReal.Lp_add_le", "code": "theorem Lp_add_le (hp : 1 \u2264 p) :\n    (\u2211 i in s, (f i + g i) ^ p) ^ (1 / p) \u2264\n      (\u2211 i in s, f i ^ p) ^ (1 / p) + (\u2211 i in s, g i ^ p) ^ (1 / p)", "start": [765, 1], "end": [783, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/MeanInequalitiesPow.lean", "imports": ["Mathlib/Tactic/Positivity.lean", "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Convex/Jensen.lean", "Mathlib/Analysis/Convex/SpecificFunctions/Basic.lean"], "premises": [{"full_name": "Real.pow_arith_mean_le_arith_mean_pow", "code": "theorem pow_arith_mean_le_arith_mean_pow (w z : \u03b9 \u2192 \u211d) (hw : \u2200 i \u2208 s, 0 \u2264 w i)\n    (hw' : \u2211 i in s, w i = 1) (hz : \u2200 i \u2208 s, 0 \u2264 z i) (n : \u2115) :\n    (\u2211 i in s, w i * z i) ^ n \u2264 \u2211 i in s, w i * z i ^ n", "start": [60, 1], "end": [63, 40], "kind": "commanddeclaration"}, {"full_name": "Real.pow_arith_mean_le_arith_mean_pow_of_even", "code": "theorem pow_arith_mean_le_arith_mean_pow_of_even (w z : \u03b9 \u2192 \u211d) (hw : \u2200 i \u2208 s, 0 \u2264 w i)\n    (hw' : \u2211 i in s, w i = 1) {n : \u2115} (hn : Even n) :\n    (\u2211 i in s, w i * z i) ^ n \u2264 \u2211 i in s, w i * z i ^ n", "start": [66, 1], "end": [69, 55], "kind": "commanddeclaration"}, {"full_name": "Real.pow_sum_div_card_le_sum_pow", "code": "theorem pow_sum_div_card_le_sum_pow {f : \u03b9 \u2192 \u211d} (n : \u2115) (hf : \u2200 a \u2208 s, 0 \u2264 f a) :\n    (\u2211 x in s, f x) ^ (n + 1) / (s.card : \u211d) ^ n \u2264 \u2211 x in s, f x ^ (n + 1)", "start": [72, 1], "end": [87, 88], "kind": "commanddeclaration"}, {"full_name": "Real.zpow_arith_mean_le_arith_mean_zpow", "code": "theorem zpow_arith_mean_le_arith_mean_zpow (w z : \u03b9 \u2192 \u211d) (hw : \u2200 i \u2208 s, 0 \u2264 w i)\n    (hw' : \u2211 i in s, w i = 1) (hz : \u2200 i \u2208 s, 0 < z i) (m : \u2124) :\n    (\u2211 i in s, w i * z i) ^ m \u2264 \u2211 i in s, w i * z i ^ m", "start": [90, 1], "end": [93, 41], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_arith_mean_le_arith_mean_rpow", "code": "theorem rpow_arith_mean_le_arith_mean_rpow (w z : \u03b9 \u2192 \u211d) (hw : \u2200 i \u2208 s, 0 \u2264 w i)\n    (hw' : \u2211 i in s, w i = 1) (hz : \u2200 i \u2208 s, 0 \u2264 z i) {p : \u211d} (hp : 1 \u2264 p) :\n    (\u2211 i in s, w i * z i) ^ p \u2264 \u2211 i in s, w i * z i ^ p", "start": [96, 1], "end": [99, 42], "kind": "commanddeclaration"}, {"full_name": "Real.arith_mean_le_rpow_mean", "code": "theorem arith_mean_le_rpow_mean (w z : \u03b9 \u2192 \u211d) (hw : \u2200 i \u2208 s, 0 \u2264 w i) (hw' : \u2211 i in s, w i = 1)\n    (hz : \u2200 i \u2208 s, 0 \u2264 z i) {p : \u211d} (hp : 1 \u2264 p) :\n    \u2211 i in s, w i * z i \u2264 (\u2211 i in s, w i * z i ^ p) ^ (1 / p)", "start": [102, 1], "end": [111, 70], "kind": "commanddeclaration"}, {"full_name": "NNReal.pow_arith_mean_le_arith_mean_pow", "code": "theorem pow_arith_mean_le_arith_mean_pow (w z : \u03b9 \u2192 \u211d\u22650) (hw' : \u2211 i in s, w i = 1) (n : \u2115) :\n    (\u2211 i in s, w i * z i) ^ n \u2264 \u2211 i in s, w i * z i ^ n", "start": [118, 1], "end": [124, 62], "kind": "commanddeclaration"}, {"full_name": "NNReal.pow_sum_div_card_le_sum_pow", "code": "theorem pow_sum_div_card_le_sum_pow (f : \u03b9 \u2192 \u211d\u22650) (n : \u2115) :\n    (\u2211 x in s, f x) ^ (n + 1) / (s.card : \u211d) ^ n \u2264 \u2211 x in s, f x ^ (n + 1)", "start": [127, 1], "end": [130, 97], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_arith_mean_le_arith_mean_rpow", "code": "theorem rpow_arith_mean_le_arith_mean_rpow (w z : \u03b9 \u2192 \u211d\u22650) (hw' : \u2211 i in s, w i = 1) {p : \u211d}\n    (hp : 1 \u2264 p) : (\u2211 i in s, w i * z i) ^ p \u2264 \u2211 i in s, w i * z i ^ p", "start": [133, 1], "end": [139, 63], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_arith_mean_le_arith_mean2_rpow", "code": "theorem rpow_arith_mean_le_arith_mean2_rpow (w\u2081 w\u2082 z\u2081 z\u2082 : \u211d\u22650) (hw' : w\u2081 + w\u2082 = 1) {p : \u211d}\n    (hp : 1 \u2264 p) : (w\u2081 * z\u2081 + w\u2082 * z\u2082) ^ p \u2264 w\u2081 * z\u2081 ^ p + w\u2082 * z\u2082 ^ p", "start": [142, 1], "end": [147, 34], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_add_le_mul_rpow_add_rpow", "code": "theorem rpow_add_le_mul_rpow_add_rpow (z\u2081 z\u2082 : \u211d\u22650) {p : \u211d} (hp : 1 \u2264 p) :\n    (z\u2081 + z\u2082) ^ p \u2264 (2 : \u211d\u22650) ^ (p - 1) * (z\u2081 ^ p + z\u2082 ^ p)", "start": [150, 1], "end": [161, 9], "kind": "commanddeclaration"}, {"full_name": "NNReal.arith_mean_le_rpow_mean", "code": "theorem arith_mean_le_rpow_mean (w z : \u03b9 \u2192 \u211d\u22650) (hw' : \u2211 i in s, w i = 1) {p : \u211d} (hp : 1 \u2264 p) :\n    \u2211 i in s, w i * z i \u2264 (\u2211 i in s, w i * z i ^ p) ^ (1 / p)", "start": [164, 1], "end": [170, 39], "kind": "commanddeclaration"}, {"full_name": "NNReal.add_rpow_le_one_of_add_le_one", "code": "private theorem add_rpow_le_one_of_add_le_one {p : \u211d} (a b : \u211d\u22650) (hab : a + b \u2264 1) (hp1 : 1 \u2264 p) :\n    a ^ p + b ^ p \u2264 1", "start": [173, 1], "end": [178, 63], "kind": "commanddeclaration"}, {"full_name": "NNReal.add_rpow_le_rpow_add", "code": "theorem add_rpow_le_rpow_add {p : \u211d} (a b : \u211d\u22650) (hp1 : 1 \u2264 p) : a ^ p + b ^ p \u2264 (a + b) ^ p", "start": [180, 1], "end": [194, 64], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_add_rpow_le_add", "code": "theorem rpow_add_rpow_le_add {p : \u211d} (a b : \u211d\u22650) (hp1 : 1 \u2264 p) :\n    (a ^ p + b ^ p) ^ (1 / p) \u2264 a + b", "start": [197, 1], "end": [201, 37], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_add_rpow_le", "code": "theorem rpow_add_rpow_le {p q : \u211d} (a b : \u211d\u22650) (hp_pos : 0 < p) (hpq : p \u2264 q) :\n    (a ^ q + b ^ q) ^ (1 / q) \u2264 (a ^ p + b ^ p) ^ (1 / p)", "start": [204, 1], "end": [215, 46], "kind": "commanddeclaration"}, {"full_name": "NNReal.rpow_add_le_add_rpow", "code": "theorem rpow_add_le_add_rpow {p : \u211d} (a b : \u211d\u22650) (hp : 0 \u2264 p) (hp1 : p \u2264 1) :\n    (a + b) ^ p \u2264 a ^ p + b ^ p", "start": [218, 1], "end": [225, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_arith_mean_le_arith_mean_rpow", "code": "theorem rpow_arith_mean_le_arith_mean_rpow (w z : \u03b9 \u2192 \u211d\u22650\u221e) (hw' : \u2211 i in s, w i = 1) {p : \u211d}\n    (hp : 1 \u2264 p) : (\u2211 i in s, w i * z i) ^ p \u2264 \u2211 i in s, w i * z i ^ p", "start": [232, 1], "end": [279, 39], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_arith_mean_le_arith_mean2_rpow", "code": "theorem rpow_arith_mean_le_arith_mean2_rpow (w\u2081 w\u2082 z\u2081 z\u2082 : \u211d\u22650\u221e) (hw' : w\u2081 + w\u2082 = 1) {p : \u211d}\n    (hp : 1 \u2264 p) : (w\u2081 * z\u2081 + w\u2082 * z\u2082) ^ p \u2264 w\u2081 * z\u2081 ^ p + w\u2082 * z\u2082 ^ p", "start": [282, 1], "end": [288, 34], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_add_le_mul_rpow_add_rpow", "code": "theorem rpow_add_le_mul_rpow_add_rpow (z\u2081 z\u2082 : \u211d\u22650\u221e) {p : \u211d} (hp : 1 \u2264 p) :\n    (z\u2081 + z\u2082) ^ p \u2264 (2 : \u211d\u22650\u221e) ^ (p - 1) * (z\u2081 ^ p + z\u2082 ^ p)", "start": [291, 1], "end": [302, 9], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_rpow_le_rpow_add", "code": "theorem add_rpow_le_rpow_add {p : \u211d} (a b : \u211d\u22650\u221e) (hp1 : 1 \u2264 p) : a ^ p + b ^ p \u2264 (a + b) ^ p", "start": [305, 1], "end": [315, 63], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_add_rpow_le_add", "code": "theorem rpow_add_rpow_le_add {p : \u211d} (a b : \u211d\u22650\u221e) (hp1 : 1 \u2264 p) :\n    (a ^ p + b ^ p) ^ (1 / p) \u2264 a + b", "start": [318, 1], "end": [322, 37], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_add_rpow_le", "code": "theorem rpow_add_rpow_le {p q : \u211d} (a b : \u211d\u22650\u221e) (hp_pos : 0 < p) (hpq : p \u2264 q) :\n    (a ^ q + b ^ q) ^ (1 / q) \u2264 (a ^ p + b ^ p) ^ (1 / p)", "start": [325, 1], "end": [335, 46], "kind": "commanddeclaration"}, {"full_name": "ENNReal.rpow_add_le_add_rpow", "code": "theorem rpow_add_le_add_rpow {p : \u211d} (a b : \u211d\u22650\u221e) (hp : 0 \u2264 p) (hp1 : p \u2264 1) :\n    (a + b) ^ p \u2264 a ^ p + b ^ p", "start": [338, 1], "end": [345, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/IntegralClosure.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Charpoly/LinearMap.lean", "Mathlib/LinearAlgebra/FiniteDimensional.lean", "Mathlib/RingTheory/Adjoin/FG.lean", "Mathlib/Data/Polynomial/Expand.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Polynomial/ScaleRoots.lean", "Mathlib/RingTheory/FiniteType.lean", "Mathlib/RingTheory/TensorProduct.lean", "Mathlib/RingTheory/Polynomial/Tower.lean"], "premises": [{"full_name": "RingHom.IsIntegralElem", "code": "def RingHom.IsIntegralElem (f : R \u2192+* A) (x : A) :=\n  \u2203 p : R[X], Monic p \u2227 eval\u2082 f x p = 0", "start": [44, 1], "end": [47, 40], "kind": "commanddeclaration"}, {"full_name": "RingHom.IsIntegral", "code": "def RingHom.IsIntegral (f : R \u2192+* A) :=\n  \u2200 x : A, f.IsIntegralElem x", "start": [50, 1], "end": [53, 30], "kind": "commanddeclaration"}, {"full_name": "IsIntegral", "code": "def IsIntegral (x : A) : Prop :=\n  (algebraMap R A).IsIntegralElem x", "start": [58, 1], "end": [62, 36], "kind": "commanddeclaration"}, {"full_name": "Algebra.IsIntegral", "code": "protected def Algebra.IsIntegral : Prop :=\n  (algebraMap R A).IsIntegral", "start": [67, 1], "end": [69, 30], "kind": "commanddeclaration"}, {"full_name": "RingHom.is_integral_map", "code": "theorem RingHom.is_integral_map {x : R} : f.IsIntegralElem (f x)", "start": [74, 1], "end": [75, 38], "kind": "commanddeclaration"}, {"full_name": "isIntegral_algebraMap", "code": "theorem isIntegral_algebraMap {x : R} : IsIntegral R (algebraMap R A x)", "start": [78, 1], "end": [79, 35], "kind": "commanddeclaration"}, {"full_name": "isIntegral_of_noetherian", "code": "theorem isIntegral_of_noetherian (H : IsNoetherian R A) (x : A) : IsIntegral R x", "start": [82, 1], "end": [98, 40], "kind": "commanddeclaration"}, {"full_name": "isIntegral_of_submodule_noetherian", "code": "theorem isIntegral_of_submodule_noetherian (S : Subalgebra R A)\n    (H : IsNoetherian R (Subalgebra.toSubmodule S)) (x : A) (hx : x \u2208 S) : IsIntegral R x", "start": [101, 1], "end": [111, 45], "kind": "commanddeclaration"}, {"full_name": "isIntegral_of_finite", "code": "theorem isIntegral_of_finite (e : A) : IsIntegral K e", "start": [124, 1], "end": [125, 67], "kind": "commanddeclaration"}, {"full_name": "Algebra.isIntegral_of_finite", "code": "theorem Algebra.isIntegral_of_finite : Algebra.IsIntegral K A", "start": [129, 1], "end": [131, 95], "kind": "commanddeclaration"}, {"full_name": "map_isIntegral", "code": "theorem map_isIntegral {B C F : Type*} [Ring B] [Ring C] [Algebra R B] [Algebra A B] [Algebra R C]\n    [IsScalarTower R A B] [Algebra A C] [IsScalarTower R A C] {b : B} [AlgHomClass F A B C] (f : F)\n    (hb : IsIntegral R b) : IsIntegral R (f b)", "start": [144, 1], "end": [150, 80], "kind": "commanddeclaration"}, {"full_name": "isIntegral_map_of_comp_eq_of_isIntegral", "code": "theorem isIntegral_map_of_comp_eq_of_isIntegral {R S T U : Type*} [CommRing R] [CommRing S]\n    [CommRing T] [CommRing U] [Algebra R S] [Algebra T U] (\u03c6 : R \u2192+* T) (\u03c8 : S \u2192+* U)\n    (h : (algebraMap T U).comp \u03c6 = \u03c8.comp (algebraMap R S)) {a : S} (ha : IsIntegral R a) :\n    IsIntegral T (\u03c8 a)", "start": [153, 1], "end": [161, 22], "kind": "commanddeclaration"}, {"full_name": "isIntegral_algHom_iff", "code": "theorem isIntegral_algHom_iff {A B : Type*} [Ring A] [Ring B] [Algebra R A] [Algebra R B]\n    (f : A \u2192\u2090[R] B) (hf : Function.Injective f) {x : A} : IsIntegral R (f x) \u2194 IsIntegral R x", "start": [164, 1], "end": [170, 32], "kind": "commanddeclaration"}, {"full_name": "isIntegral_algEquiv", "code": "@[simp]\ntheorem isIntegral_algEquiv {A B : Type*} [Ring A] [Ring B] [Algebra R A] [Algebra R B]\n    (f : A \u2243\u2090[R] B) {x : A} : IsIntegral R (f x) \u2194 IsIntegral R x", "start": [173, 1], "end": [176, 88], "kind": "commanddeclaration"}, {"full_name": "isIntegral_of_isScalarTower", "code": "theorem isIntegral_of_isScalarTower [Algebra A B] [IsScalarTower R A B] {x : B}\n    (hx : IsIntegral R x) : IsIntegral A x", "start": [179, 1], "end": [182, 97], "kind": "commanddeclaration"}, {"full_name": "map_isIntegral_int", "code": "theorem map_isIntegral_int {B C F : Type*} [Ring B] [Ring C] {b : B} [RingHomClass F B C] (f : F)\n    (hb : IsIntegral \u2124 b) : IsIntegral \u2124 (f b)", "start": [185, 1], "end": [187, 46], "kind": "commanddeclaration"}, {"full_name": "isIntegral_ofSubring", "code": "theorem isIntegral_ofSubring {x : A} (T : Subring R) (hx : IsIntegral T x) : IsIntegral R x", "start": [190, 1], "end": [191, 33], "kind": "commanddeclaration"}, {"full_name": "IsIntegral.algebraMap", "code": "theorem IsIntegral.algebraMap [Algebra A B] [IsScalarTower R A B] {x : A} (h : IsIntegral R x) :\n    IsIntegral R (algebraMap A B x)", "start": [194, 1], "end": [198, 76], "kind": "commanddeclaration"}, {"full_name": "isIntegral_algebraMap_iff", "code": "theorem isIntegral_algebraMap_iff [Algebra A B] [IsScalarTower R A B] {x : A}\n    (hAB : Function.Injective (algebraMap A B)) :\n    IsIntegral R (algebraMap A B x) \u2194 IsIntegral R x", "start": [201, 1], "end": [204, 59], "kind": "commanddeclaration"}, {"full_name": "isIntegral_iff_isIntegral_closure_finite", "code": "theorem isIntegral_iff_isIntegral_closure_finite {r : A} :\n    IsIntegral R r \u2194 \u2203 s : Set R, s.Finite \u2227 IsIntegral (Subring.closure s) r", "start": [207, 1], "end": [214, 35], "kind": "commanddeclaration"}, {"full_name": "FG_adjoin_singleton_of_integral", "code": "theorem FG_adjoin_singleton_of_integral (x : A) (hx : IsIntegral R x) :\n    (Algebra.adjoin R ({x} : Set A)).toSubmodule.FG", "start": [217, 1], "end": [244, 69], "kind": "commanddeclaration"}, {"full_name": "FG_adjoin_of_finite", "code": "theorem FG_adjoin_of_finite {s : Set A} (hfs : s.Finite) (his : \u2200 x \u2208 s, IsIntegral R x) :\n    (Algebra.adjoin R s).toSubmodule.FG", "start": [247, 1], "end": [261, 8], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_adjoin_finset", "code": "theorem isNoetherian_adjoin_finset [IsNoetherianRing R] (s : Finset A)\n    (hs : \u2200 x \u2208 s, IsIntegral R x) : IsNoetherian R (Algebra.adjoin R (\u2191s : Set A))", "start": [264, 1], "end": [266, 77], "kind": "commanddeclaration"}, {"full_name": "isIntegral_of_mem_of_FG", "code": "theorem isIntegral_of_mem_of_FG (S : Subalgebra R A) (HS : S.toSubmodule.FG) (x : A) (hx : x \u2208 S) :\n    IsIntegral R x", "start": [269, 1], "end": [369, 67], "kind": "commanddeclaration"}, {"full_name": "Module.End.isIntegral", "code": "theorem Module.End.isIntegral {M : Type*} [AddCommGroup M] [Module R M] [Module.Finite R M] :\n    Algebra.IsIntegral R (Module.End R M)", "start": [372, 1], "end": [374, 45], "kind": "commanddeclaration"}, {"full_name": "isIntegral_of_smul_mem_submodule", "code": "theorem isIntegral_of_smul_mem_submodule {M : Type*} [AddCommGroup M] [Module R M] [Module A M]\n    [IsScalarTower R A M] [NoZeroSMulDivisors A M] (N : Submodule R M) (hN : N \u2260 \u22a5) (hN' : N.FG)\n    (x : A) (hx : \u2200 n \u2208 N, x \u2022 n \u2208 N) : IsIntegral R x", "start": [377, 1], "end": [417, 30], "kind": "commanddeclaration"}, {"full_name": "RingHom.Finite.to_isIntegral", "code": "theorem RingHom.Finite.to_isIntegral (h : f.Finite) : f.IsIntegral", "start": [422, 1], "end": [424, 51], "kind": "commanddeclaration"}, {"full_name": "RingHom.IsIntegral.of_finite", "code": "alias RingHom.IsIntegral.of_finite := RingHom.Finite.to_isIntegral", "start": [427, 1], "end": [427, 67], "kind": "stdtacticaliasalias"}, {"full_name": "RingHom.IsIntegral.to_finite", "code": "theorem RingHom.IsIntegral.to_finite (h : f.IsIntegral) (h' : f.FiniteType) : f.Finite", "start": [430, 1], "end": [436, 60], "kind": "commanddeclaration"}, {"full_name": "RingHom.Finite.of_isIntegral_of_finiteType", "code": "alias RingHom.Finite.of_isIntegral_of_finiteType := RingHom.IsIntegral.to_finite", "start": [439, 1], "end": [439, 81], "kind": "stdtacticaliasalias"}, {"full_name": "RingHom.finite_iff_isIntegral_and_finiteType", "code": "theorem RingHom.finite_iff_isIntegral_and_finiteType : f.Finite \u2194 f.IsIntegral \u2227 f.FiniteType", "start": [442, 1], "end": [444, 79], "kind": "commanddeclaration"}, {"full_name": "Algebra.IsIntegral.finite", "code": "theorem Algebra.IsIntegral.finite (h : Algebra.IsIntegral R A) [h' : Algebra.FiniteType R A] :\n    Module.Finite R A", "start": [447, 1], "end": [460, 29], "kind": "commanddeclaration"}, {"full_name": "Algebra.IsIntegral.of_finite", "code": "theorem Algebra.IsIntegral.of_finite [h : Module.Finite R A] : Algebra.IsIntegral R A", "start": [463, 1], "end": [468, 36], "kind": "commanddeclaration"}, {"full_name": "Algebra.finite_iff_isIntegral_and_finiteType", "code": "theorem Algebra.finite_iff_isIntegral_and_finiteType :\n    Module.Finite R A \u2194 Algebra.IsIntegral R A \u2227 Algebra.FiniteType R A", "start": [471, 1], "end": [474, 83], "kind": "commanddeclaration"}, {"full_name": "RingHom.is_integral_of_mem_closure", "code": "theorem RingHom.is_integral_of_mem_closure {x y z : S} (hx : f.IsIntegralElem x)\n    (hy : f.IsIntegralElem y) (hz : z \u2208 Subring.closure ({x, y} : Set S)) : f.IsIntegralElem z", "start": [479, 1], "end": [486, 89], "kind": "commanddeclaration"}, {"full_name": "isIntegral_of_mem_closure", "code": "theorem isIntegral_of_mem_closure {x y z : A} (hx : IsIntegral R x) (hy : IsIntegral R y)\n    (hz : z \u2208 Subring.closure ({x, y} : Set A)) : IsIntegral R z", "start": [489, 1], "end": [491, 55], "kind": "commanddeclaration"}, {"full_name": "RingHom.is_integral_zero", "code": "theorem RingHom.is_integral_zero : f.IsIntegralElem 0", "start": [494, 1], "end": [495, 33], "kind": "commanddeclaration"}, {"full_name": "isIntegral_zero", "code": "theorem isIntegral_zero : IsIntegral R (0 : A)", "start": [498, 1], "end": [499, 36], "kind": "commanddeclaration"}, {"full_name": "RingHom.is_integral_one", "code": "theorem RingHom.is_integral_one : f.IsIntegralElem 1", "start": [502, 1], "end": [503, 32], "kind": "commanddeclaration"}, {"full_name": "isIntegral_one", "code": "theorem isIntegral_one : IsIntegral R (1 : A)", "start": [506, 1], "end": [507, 35], "kind": "commanddeclaration"}, {"full_name": "RingHom.is_integral_add", "code": "theorem RingHom.is_integral_add {x y : S} (hx : f.IsIntegralElem x) (hy : f.IsIntegralElem y) :\n    f.IsIntegralElem (x + y)", "start": [510, 1], "end": [513, 98], "kind": "commanddeclaration"}, {"full_name": "isIntegral_add", "code": "theorem isIntegral_add {x y : A} (hx : IsIntegral R x) (hy : IsIntegral R y) :\n    IsIntegral R (x + y)", "start": [516, 1], "end": [518, 41], "kind": "commanddeclaration"}, {"full_name": "RingHom.is_integral_neg", "code": "theorem RingHom.is_integral_neg {x : S} (hx : f.IsIntegralElem x) : f.IsIntegralElem (-x)", "start": [521, 1], "end": [522, 95], "kind": "commanddeclaration"}, {"full_name": "isIntegral_neg", "code": "theorem isIntegral_neg {x : A} (hx : IsIntegral R x) : IsIntegral R (-x)", "start": [525, 1], "end": [526, 38], "kind": "commanddeclaration"}, {"full_name": "RingHom.is_integral_sub", "code": "theorem RingHom.is_integral_sub {x y : S} (hx : f.IsIntegralElem x) (hy : f.IsIntegralElem y) :\n    f.IsIntegralElem (x - y)", "start": [529, 1], "end": [531, 80], "kind": "commanddeclaration"}, {"full_name": "isIntegral_sub", "code": "theorem isIntegral_sub {x y : A} (hx : IsIntegral R x) (hy : IsIntegral R y) :\n    IsIntegral R (x - y)", "start": [534, 1], "end": [536, 41], "kind": "commanddeclaration"}, {"full_name": "RingHom.is_integral_mul", "code": "theorem RingHom.is_integral_mul {x y : S} (hx : f.IsIntegralElem x) (hy : f.IsIntegralElem y) :\n    f.IsIntegralElem (x * y)", "start": [539, 1], "end": [542, 100], "kind": "commanddeclaration"}, {"full_name": "isIntegral_mul", "code": "theorem isIntegral_mul {x y : A} (hx : IsIntegral R x) (hy : IsIntegral R y) :\n    IsIntegral R (x * y)", "start": [545, 1], "end": [547, 41], "kind": "commanddeclaration"}, {"full_name": "isIntegral_smul", "code": "theorem isIntegral_smul [Algebra S A] [Algebra R S] [IsScalarTower R S A] {x : A} (r : R)\n    (hx : IsIntegral S x) : IsIntegral S (r \u2022 x)", "start": [550, 1], "end": [553, 48], "kind": "commanddeclaration"}, {"full_name": "isIntegral_of_pow", "code": "theorem isIntegral_of_pow {x : A} {n : \u2115} (hn : 0 < n) (hx : IsIntegral R <| x ^ n) :\n    IsIntegral R x", "start": [556, 1], "end": [561, 77], "kind": "commanddeclaration"}, {"full_name": "integralClosure", "code": "def integralClosure : Subalgebra R A where\n  carrier := { r | IsIntegral R r }\n  zero_mem' := isIntegral_zero\n  one_mem' := isIntegral_one\n  add_mem' := isIntegral_add\n  mul_mem' := isIntegral_mul\n  algebraMap_mem' _ := isIntegral_algebraMap", "start": [566, 1], "end": [573, 45], "kind": "commanddeclaration"}, {"full_name": "mem_integralClosure_iff_mem_FG", "code": "theorem mem_integralClosure_iff_mem_FG {r : A} :\n    r \u2208 integralClosure R A \u2194 \u2203 M : Subalgebra R A, M.toSubmodule.FG \u2227 r \u2208 M", "start": [576, 1], "end": [580, 60], "kind": "commanddeclaration"}, {"full_name": "adjoin_le_integralClosure", "code": "theorem adjoin_le_integralClosure {x : A} (hx : IsIntegral R x) :\n    Algebra.adjoin R {x} \u2264 integralClosure R A", "start": [585, 1], "end": [589, 11], "kind": "commanddeclaration"}, {"full_name": "le_integralClosure_iff_isIntegral", "code": "theorem le_integralClosure_iff_isIntegral {S : Subalgebra R A} :\n    S \u2264 integralClosure R A \u2194 Algebra.IsIntegral R S", "start": [592, 1], "end": [597, 57], "kind": "commanddeclaration"}, {"full_name": "isIntegral_sup", "code": "theorem isIntegral_sup {S T : Subalgebra R A} :\n    Algebra.IsIntegral R (S \u2294 T : Subalgebra R A) \u2194\n      Algebra.IsIntegral R S \u2227 Algebra.IsIntegral R T", "start": [600, 1], "end": [603, 62], "kind": "commanddeclaration"}, {"full_name": "integralClosure_map_algEquiv", "code": "theorem integralClosure_map_algEquiv (f : A \u2243\u2090[R] B) :\n    (integralClosure R A).map (f : A \u2192\u2090[R] B) = integralClosure R B", "start": [606, 1], "end": [616, 9], "kind": "commanddeclaration"}, {"full_name": "integralClosure.isIntegral", "code": "theorem integralClosure.isIntegral (x : integralClosure R A) : IsIntegral R x", "start": [619, 1], "end": [623, 76], "kind": "commanddeclaration"}, {"full_name": "RingHom.isIntegral_of_isIntegral_mul_unit", "code": "theorem RingHom.isIntegral_of_isIntegral_mul_unit (x y : S) (r : R) (hr : f r * y = 1)\n    (hx : f.IsIntegralElem (x * y)) : f.IsIntegralElem x", "start": [626, 1], "end": [631, 46], "kind": "commanddeclaration"}, {"full_name": "isIntegral_of_isIntegral_mul_unit", "code": "theorem isIntegral_of_isIntegral_mul_unit {x y : A} {r : R} (hr : algebraMap R A r * y = 1)\n    (hx : IsIntegral R (x * y)) : IsIntegral R x", "start": [634, 1], "end": [636, 65], "kind": "commanddeclaration"}, {"full_name": "isIntegral_of_mem_closure'", "code": "theorem isIntegral_of_mem_closure' (G : Set A) (hG : \u2200 x \u2208 G, IsIntegral R x) :\n    \u2200 x \u2208 Subring.closure G, IsIntegral R x", "start": [639, 1], "end": [643, 56], "kind": "commanddeclaration"}, {"full_name": "isIntegral_of_mem_closure''", "code": "theorem isIntegral_of_mem_closure'' {S : Type*} [CommRing S] {f : R \u2192+* S} (G : Set S)\n    (hG : \u2200 x \u2208 G, f.IsIntegralElem x) : \u2200 x \u2208 Subring.closure G, f.IsIntegralElem x", "start": [646, 1], "end": [648, 60], "kind": "commanddeclaration"}, {"full_name": "IsIntegral.pow", "code": "theorem IsIntegral.pow {x : A} (h : IsIntegral R x) (n : \u2115) : IsIntegral R (x ^ n)", "start": [651, 1], "end": [652, 36], "kind": "commanddeclaration"}, {"full_name": "IsIntegral.nsmul", "code": "theorem IsIntegral.nsmul {x : A} (h : IsIntegral R x) (n : \u2115) : IsIntegral R (n \u2022 x)", "start": [655, 1], "end": [656, 38], "kind": "commanddeclaration"}, {"full_name": "IsIntegral.zsmul", "code": "theorem IsIntegral.zsmul {x : A} (h : IsIntegral R x) (n : \u2124) : IsIntegral R (n \u2022 x)", "start": [659, 1], "end": [660, 38], "kind": "commanddeclaration"}, {"full_name": "IsIntegral.multiset_prod", "code": "theorem IsIntegral.multiset_prod {s : Multiset A} (h : \u2200 x \u2208 s, IsIntegral R x) :\n    IsIntegral R s.prod", "start": [663, 1], "end": [665, 44], "kind": "commanddeclaration"}, {"full_name": "IsIntegral.multiset_sum", "code": "theorem IsIntegral.multiset_sum {s : Multiset A} (h : \u2200 x \u2208 s, IsIntegral R x) :\n    IsIntegral R s.sum", "start": [668, 1], "end": [670, 43], "kind": "commanddeclaration"}, {"full_name": "IsIntegral.prod", "code": "theorem IsIntegral.prod {\u03b1 : Type*} {s : Finset \u03b1} (f : \u03b1 \u2192 A) (h : \u2200 x \u2208 s, IsIntegral R (f x)) :\n    IsIntegral R (\u220f x in s, f x)", "start": [673, 1], "end": [675, 35], "kind": "commanddeclaration"}, {"full_name": "IsIntegral.sum", "code": "theorem IsIntegral.sum {\u03b1 : Type*} {s : Finset \u03b1} (f : \u03b1 \u2192 A) (h : \u2200 x \u2208 s, IsIntegral R (f x)) :\n    IsIntegral R (\u2211 x in s, f x)", "start": [678, 1], "end": [680, 34], "kind": "commanddeclaration"}, {"full_name": "IsIntegral.det", "code": "theorem IsIntegral.det {n : Type*} [Fintype n] [DecidableEq n] {M : Matrix n n A}\n    (h : \u2200 i j, IsIntegral R (M i j)) : IsIntegral R M.det", "start": [683, 1], "end": [686, 96], "kind": "commanddeclaration"}, {"full_name": "IsIntegral.pow_iff", "code": "@[simp]\ntheorem IsIntegral.pow_iff {x : A} {n : \u2115} (hn : 0 < n) : IsIntegral R (x ^ n) \u2194 IsIntegral R x", "start": [689, 1], "end": [691, 56], "kind": "commanddeclaration"}, {"full_name": "IsIntegral.tmul", "code": "theorem IsIntegral.tmul (x : A) {y : B} (h : IsIntegral R y) : IsIntegral A (x \u2297\u209c[R] y)", "start": [698, 1], "end": [715, 51], "kind": "commanddeclaration"}, {"full_name": "normalizeScaleRoots", "code": "noncomputable def normalizeScaleRoots (p : R[X]) : R[X] :=\n  \u2211 i in p.support,\n    monomial i (if i = p.natDegree then 1 else p.coeff i * p.leadingCoeff ^ (p.natDegree - 1 - i))", "start": [722, 1], "end": [725, 99], "kind": "commanddeclaration"}, {"full_name": "normalizeScaleRoots_coeff_mul_leadingCoeff_pow", "code": "theorem normalizeScaleRoots_coeff_mul_leadingCoeff_pow (i : \u2115) (hp : 1 \u2264 natDegree p) :\n    (normalizeScaleRoots p).coeff i * p.leadingCoeff ^ i =\n      p.coeff i * p.leadingCoeff ^ (p.natDegree - 1)", "start": [728, 1], "end": [739, 43], "kind": "commanddeclaration"}, {"full_name": "leadingCoeff_smul_normalizeScaleRoots", "code": "theorem leadingCoeff_smul_normalizeScaleRoots (p : R[X]) :\n    p.leadingCoeff \u2022 normalizeScaleRoots p = scaleRoots p p.leadingCoeff", "start": [742, 1], "end": [756, 74], "kind": "commanddeclaration"}, {"full_name": "normalizeScaleRoots_support", "code": "theorem normalizeScaleRoots_support : (normalizeScaleRoots p).support \u2264 p.support", "start": [759, 1], "end": [765, 21], "kind": "commanddeclaration"}, {"full_name": "normalizeScaleRoots_degree", "code": "theorem normalizeScaleRoots_degree : (normalizeScaleRoots p).degree = p.degree", "start": [768, 1], "end": [772, 29], "kind": "commanddeclaration"}, {"full_name": "normalizeScaleRoots_eval\u2082_leadingCoeff_mul", "code": "theorem normalizeScaleRoots_eval\u2082_leadingCoeff_mul (h : 1 \u2264 p.natDegree) (f : R \u2192+* S) (x : S) :\n    (normalizeScaleRoots p).eval\u2082 f (f p.leadingCoeff * x) =\n      f p.leadingCoeff ^ (p.natDegree - 1) * p.eval\u2082 f x", "start": [775, 1], "end": [784, 7], "kind": "commanddeclaration"}, {"full_name": "normalizeScaleRoots_monic", "code": "theorem normalizeScaleRoots_monic (h : p \u2260 0) : (normalizeScaleRoots p).Monic", "start": [787, 1], "end": [791, 30], "kind": "commanddeclaration"}, {"full_name": "RingHom.isIntegralElem_leadingCoeff_mul", "code": "theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval\u2082 f x = 0) :\n    f.IsIntegralElem (f p.leadingCoeff * x)", "start": [794, 1], "end": [813, 61], "kind": "commanddeclaration"}, {"full_name": "isIntegral_leadingCoeff_smul", "code": "theorem isIntegral_leadingCoeff_smul [Algebra R S] (h : aeval x p = 0) :\n    IsIntegral R (p.leadingCoeff \u2022 x)", "start": [816, 1], "end": [822, 63], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure", "code": "class IsIntegralClosure (A R B : Type*) [CommRing R] [CommSemiring A] [CommRing B] [Algebra R B]\n  [Algebra A B] : Prop where\n  algebraMap_injective' : Function.Injective (algebraMap A B)\n  isIntegral_iff : \u2200 {x : B}, IsIntegral R x \u2194 \u2203 y, algebraMap A B y = x", "start": [831, 1], "end": [838, 73], "kind": "commanddeclaration"}, {"full_name": "integralClosure.isIntegralClosure", "code": "instance integralClosure.isIntegralClosure (R A : Type*) [CommRing R] [CommRing A] [Algebra R A] :\n    IsIntegralClosure (integralClosure R A) R A where\n  algebraMap_injective' := Subtype.coe_injective\n  isIntegral_iff {x} := \u27e8fun h => \u27e8\u27e8x, h\u27e9, rfl\u27e9, by rintro \u27e8\u27e8_, h\u27e9, rfl\u27e9; exact h\u27e9", "start": [841, 1], "end": [844, 83], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.algebraMap_injective", "code": "theorem algebraMap_injective (A R B : Type*) [CommRing R] [CommSemiring A] [CommRing B]\n    [Algebra R B] [Algebra A B] [IsIntegralClosure A R B] : Function.Injective (algebraMap A B)", "start": [850, 1], "end": [852, 26], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.isIntegral", "code": "protected theorem isIntegral [Algebra R A] [IsScalarTower R A B] (x : A) : IsIntegral R x", "start": [860, 1], "end": [862, 74], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.isIntegral_algebra", "code": "theorem isIntegral_algebra [Algebra R A] [IsScalarTower R A B] : Algebra.IsIntegral R A", "start": [865, 1], "end": [866, 37], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.noZeroSMulDivisors", "code": "theorem noZeroSMulDivisors [Algebra R A] [IsScalarTower R A B] [NoZeroSMulDivisors R B] :\n    NoZeroSMulDivisors R A", "start": [869, 1], "end": [874, 71], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.mk'", "code": "noncomputable def mk' (x : B) (hx : IsIntegral R x) : A :=\n  Classical.choose (isIntegral_iff.mp hx)", "start": [879, 1], "end": [881, 42], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.algebraMap_mk'", "code": "@[simp]\ntheorem algebraMap_mk' (x : B) (hx : IsIntegral R x) : algebraMap A B (mk' A x hx) = x", "start": [884, 1], "end": [886, 47], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.mk'_one", "code": "@[simp]\ntheorem mk'_one (h : IsIntegral R (1 : B) := isIntegral_one) : mk' A 1 h = 1", "start": [889, 1], "end": [891, 72], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.mk'_zero", "code": "@[simp]\ntheorem mk'_zero (h : IsIntegral R (0 : B) := isIntegral_zero) : mk' A 0 h = 0", "start": [894, 1], "end": [896, 73], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.mk'_add", "code": "theorem mk'_add (x y : B) (hx : IsIntegral R x) (hy : IsIntegral R y) :\n    mk' A (x + y) (isIntegral_add hx hy) = mk' A x hx + mk' A y hy", "start": [900, 1], "end": [902, 79], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.mk'_mul", "code": "theorem mk'_mul (x y : B) (hx : IsIntegral R x) (hy : IsIntegral R y) :\n    mk' A (x * y) (isIntegral_mul hx hy) = mk' A x hx * mk' A y hy", "start": [906, 1], "end": [908, 79], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.mk'_algebraMap", "code": "@[simp]\ntheorem mk'_algebraMap [Algebra R A] [IsScalarTower R A B] (x : R)\n    (h : IsIntegral R (algebraMap R B x) := isIntegral_algebraMap) :\n    IsIntegralClosure.mk' A (algebraMap R B x) h = algebraMap R A x", "start": [911, 1], "end": [915, 89], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.lift", "code": "noncomputable def lift : S \u2192\u2090[R] A where\n  toFun x := mk' A (algebraMap S B x) (IsIntegral.algebraMap (h x))\n  map_one' := by simp only [RingHom.map_one, mk'_one]\n  map_zero' := by simp only [RingHom.map_zero, mk'_zero]\n  map_add' x y := by simp_rw [\u2190 mk'_add, RingHom.map_add]\n  map_mul' x y := by simp_rw [\u2190 mk'_mul, RingHom.map_mul]\n  commutes' x := by simp_rw [\u2190 IsScalarTower.algebraMap_apply, mk'_algebraMap]", "start": [927, 1], "end": [935, 79], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.algebraMap_lift", "code": "@[simp]\ntheorem algebraMap_lift (x : S) : algebraMap A B (lift A B h x) = algebraMap S B x", "start": [938, 1], "end": [940, 68], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.equiv", "code": "noncomputable def equiv : A \u2243\u2090[R] A' :=\n  AlgEquiv.ofAlgHom (lift _ B (isIntegral_algebra R B)) (lift _ B (isIntegral_algebra R B))\n    (by\n      ext x\n      apply algebraMap_injective A' R B\n      simp)\n    (by\n      ext x\n      apply algebraMap_injective A R B\n      simp)", "start": [952, 1], "end": [962, 12], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.algebraMap_equiv", "code": "@[simp]\ntheorem algebraMap_equiv (x : A) : algebraMap A' B (equiv R A B A' x) = algebraMap A B x", "start": [965, 1], "end": [967, 50], "kind": "commanddeclaration"}, {"full_name": "isIntegral_trans_aux", "code": "theorem isIntegral_trans_aux (x : B) {p : A[X]} (pmonic : Monic p) (hp : aeval x p = 0) :\n    IsIntegral (adjoin R (\u2191(p.map <| algebraMap A B).frange : Set B)) x", "start": [986, 1], "end": [1009, 51], "kind": "commanddeclaration"}, {"full_name": "isIntegral_trans", "code": "theorem isIntegral_trans (A_int : Algebra.IsIntegral R A) (x : B) (hx : IsIntegral A x) :\n    IsIntegral R x", "start": [1014, 1], "end": [1027, 43], "kind": "commanddeclaration"}, {"full_name": "Algebra.isIntegral_trans", "code": "nonrec theorem Algebra.isIntegral_trans\n    (hA : Algebra.IsIntegral R A) (hB : Algebra.IsIntegral A B) : Algebra.IsIntegral R B", "start": [1030, 1], "end": [1035, 40], "kind": "commanddeclaration"}, {"full_name": "RingHom.isIntegral_trans", "code": "theorem RingHom.isIntegral_trans (hf : f.IsIntegral) (hg : g.IsIntegral) : (g.comp f).IsIntegral", "start": [1038, 1], "end": [1042, 10], "kind": "commanddeclaration"}, {"full_name": "RingHom.isIntegral_of_surjective", "code": "theorem RingHom.isIntegral_of_surjective (hf : Function.Surjective f) : f.IsIntegral", "start": [1045, 1], "end": [1046, 74], "kind": "commanddeclaration"}, {"full_name": "isIntegral_of_surjective", "code": "theorem isIntegral_of_surjective (h : Function.Surjective (algebraMap R A)) :\n    Algebra.IsIntegral R A", "start": [1049, 1], "end": [1051, 46], "kind": "commanddeclaration"}, {"full_name": "isIntegral_tower_bot_of_isIntegral", "code": "theorem isIntegral_tower_bot_of_isIntegral (H : Function.Injective (algebraMap A B)) {x : A}\n    (h : IsIntegral R (algebraMap A B x)) : IsIntegral R x", "start": [1054, 1], "end": [1063, 14], "kind": "commanddeclaration"}, {"full_name": "RingHom.isIntegral_tower_bot_of_isIntegral", "code": "nonrec theorem RingHom.isIntegral_tower_bot_of_isIntegral (hg : Function.Injective g)\n    (hfg : (g.comp f).IsIntegral) : f.IsIntegral", "start": [1066, 1], "end": [1071, 21], "kind": "commanddeclaration"}, {"full_name": "isIntegral_tower_bot_of_isIntegral_field", "code": "theorem isIntegral_tower_bot_of_isIntegral_field {R A B : Type*} [CommRing R] [Field A]\n    [CommRing B] [Nontrivial B] [Algebra R A] [Algebra A B] [Algebra R B] [IsScalarTower R A B]\n    {x : A} (h : IsIntegral R (algebraMap A B x)) : IsIntegral R x", "start": [1074, 1], "end": [1077, 66], "kind": "commanddeclaration"}, {"full_name": "RingHom.isIntegralElem_of_isIntegralElem_comp", "code": "theorem RingHom.isIntegralElem_of_isIntegralElem_comp {x : T} (h : (g.comp f).IsIntegralElem x) :\n    g.IsIntegralElem x", "start": [1080, 1], "end": [1083, 51], "kind": "commanddeclaration"}, {"full_name": "RingHom.isIntegral_tower_top_of_isIntegral", "code": "theorem RingHom.isIntegral_tower_top_of_isIntegral (h : (g.comp f).IsIntegral) : g.IsIntegral", "start": [1087, 1], "end": [1088, 67], "kind": "commanddeclaration"}, {"full_name": "isIntegral_tower_top_of_isIntegral", "code": "theorem isIntegral_tower_top_of_isIntegral {x : B} (h : IsIntegral R x) : IsIntegral A x", "start": [1091, 1], "end": [1097, 12], "kind": "commanddeclaration"}, {"full_name": "RingHom.isIntegral_quotient_of_isIntegral", "code": "theorem RingHom.isIntegral_quotient_of_isIntegral {I : Ideal S} (hf : f.IsIntegral) :\n    (Ideal.quotientMap I f le_rfl).IsIntegral", "start": [1100, 1], "end": [1105, 78], "kind": "commanddeclaration"}, {"full_name": "isIntegral_quotient_of_isIntegral", "code": "theorem isIntegral_quotient_of_isIntegral {I : Ideal A} (hRA : Algebra.IsIntegral R A) :\n    Algebra.IsIntegral (R \u29f8 I.comap (algebraMap R A)) (A \u29f8 I)", "start": [1108, 1], "end": [1110, 57], "kind": "commanddeclaration"}, {"full_name": "isIntegral_quotientMap_iff", "code": "theorem isIntegral_quotientMap_iff {I : Ideal S} :\n    (Ideal.quotientMap I f le_rfl).IsIntegral \u2194\n      ((Ideal.Quotient.mk I).comp f : R \u2192+* S \u29f8 I).IsIntegral", "start": [1113, 1], "end": [1122, 72], "kind": "commanddeclaration"}, {"full_name": "isField_of_isIntegral_of_isField", "code": "theorem isField_of_isIntegral_of_isField {R S : Type*} [CommRing R] [Nontrivial R] [CommRing S]\n    [IsDomain S] [Algebra R S] (H : Algebra.IsIntegral R S)\n    (hRS : Function.Injective (algebraMap R S)) (hS : IsField S) : IsField R", "start": [1125, 1], "end": [1161, 58], "kind": "commanddeclaration"}, {"full_name": "isField_of_isIntegral_of_isField'", "code": "theorem isField_of_isIntegral_of_isField' {R S : Type*} [CommRing R] [CommRing S] [IsDomain S]\n    [Algebra R S] (H : Algebra.IsIntegral R S) (hR : IsField R) : IsField S", "start": [1164, 1], "end": [1178, 35], "kind": "commanddeclaration"}, {"full_name": "Algebra.IsIntegral.isField_iff_isField", "code": "theorem Algebra.IsIntegral.isField_iff_isField {R S : Type*} [CommRing R] [Nontrivial R]\n    [CommRing S] [IsDomain S] [Algebra R S] (H : Algebra.IsIntegral R S)\n    (hRS : Function.Injective (algebraMap R S)) : IsField R \u2194 IsField S", "start": [1181, 1], "end": [1184, 80], "kind": "commanddeclaration"}, {"full_name": "integralClosure_idem", "code": "theorem integralClosure_idem {R : Type*} {A : Type*} [CommRing R] [CommRing A] [Algebra R A] :\n    integralClosure (integralClosure R A : Set A) A = \u22a5", "start": [1189, 1], "end": [1196, 13], "kind": "commanddeclaration"}, {"full_name": "roots_mem_integralClosure", "code": "theorem roots_mem_integralClosure {f : R[X]} (hf : f.Monic) {a : S}\n    (ha : a \u2208 f.aroots S) : a \u2208 integralClosure R S", "start": [1206, 1], "end": [1208, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Polynomial/IntegralNormalization.lean", "imports": ["Mathlib/Data/Polynomial/Degree/Lemmas.lean", "Mathlib/Data/Polynomial/Monic.lean", "Mathlib/Data/Polynomial/AlgebraMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.integralNormalization", "code": "noncomputable def integralNormalization (f : R[X]) : R[X] :=\n  \u2211 i in f.support,\n    monomial i (if f.degree = i then 1 else coeff f i * f.leadingCoeff ^ (f.natDegree - 1 - i))", "start": [33, 1], "end": [40, 96], "kind": "commanddeclaration"}, {"full_name": "Polynomial.integralNormalization_zero", "code": "@[simp]\ntheorem integralNormalization_zero : integralNormalization (0 : R[X]) = 0", "start": [43, 1], "end": [45, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.integralNormalization_coeff", "code": "theorem integralNormalization_coeff {f : R[X]} {i : \u2115} :\n    (integralNormalization f).coeff i =\n      if f.degree = i then 1 else coeff f i * f.leadingCoeff ^ (f.natDegree - 1 - i)", "start": [48, 1], "end": [53, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.integralNormalization_support", "code": "theorem integralNormalization_support {f : R[X]} :\n    (integralNormalization f).support \u2286 f.support", "start": [56, 1], "end": [59, 99], "kind": "commanddeclaration"}, {"full_name": "Polynomial.integralNormalization_coeff_degree", "code": "theorem integralNormalization_coeff_degree {f : R[X]} {i : \u2115} (hi : f.degree = i) :\n    (integralNormalization f).coeff i = 1", "start": [62, 1], "end": [63, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.integralNormalization_coeff_natDegree", "code": "theorem integralNormalization_coeff_natDegree {f : R[X]} (hf : f \u2260 0) :\n    (integralNormalization f).coeff (natDegree f) = 1", "start": [66, 1], "end": [68, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.integralNormalization_coeff_ne_degree", "code": "theorem integralNormalization_coeff_ne_degree {f : R[X]} {i : \u2115} (hi : f.degree \u2260 i) :\n    coeff (integralNormalization f) i = coeff f i * f.leadingCoeff ^ (f.natDegree - 1 - i)", "start": [71, 1], "end": [73, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.integralNormalization_coeff_ne_natDegree", "code": "theorem integralNormalization_coeff_ne_natDegree {f : R[X]} {i : \u2115} (hi : i \u2260 natDegree f) :\n    coeff (integralNormalization f) i = coeff f i * f.leadingCoeff ^ (f.natDegree - 1 - i)", "start": [76, 1], "end": [78, 76], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_integralNormalization", "code": "theorem monic_integralNormalization {f : R[X]} (hf : f \u2260 0) : Monic (integralNormalization f)", "start": [81, 1], "end": [85, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_integralNormalization", "code": "@[simp]\ntheorem support_integralNormalization {f : R[X]} :\n    (integralNormalization f).support = f.support", "start": [94, 1], "end": [102, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.integralNormalization_eval\u2082_eq_zero", "code": "theorem integralNormalization_eval\u2082_eq_zero {p : R[X]} (f : R \u2192+* S) {z : S} (hz : eval\u2082 f z p = 0)\n    (inj : \u2200 x : R, f x = 0 \u2192 x = 0) :\n    eval\u2082 f (z * f p.leadingCoeff) (integralNormalization p) = 0", "start": [113, 1], "end": [144, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.integralNormalization_aeval_eq_zero", "code": "theorem integralNormalization_aeval_eq_zero [Algebra R S] {f : R[X]} {z : S} (hz : aeval z f = 0)\n    (inj : \u2200 x : R, algebraMap R S x = 0 \u2192 x = 0) :\n    aeval (z * algebraMap R S f.leadingCoeff) (integralNormalization f) = 0", "start": [147, 1], "end": [150, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "imports": ["Mathlib/Data/Pi/Algebra.lean", "Mathlib/CategoryTheory/Limits/Shapes/Images.lean", "Mathlib/CategoryTheory/Limits/Shapes/ZeroObjects.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/IsomorphismClasses.lean", "Mathlib/CategoryTheory/Limits/Shapes/Products.lean"], "premises": [{"full_name": "CategoryTheory.Limits.HasZeroMorphisms", "code": "class HasZeroMorphisms where\n  \n  [Zero : \u2200 X Y : C, Zero (X \u27f6 Y)]\n  \n  comp_zero : \u2200 {X Y : C} (f : X \u27f6 Y) (Z : C), f \u226b (0 : Y \u27f6 Z) = (0 : X \u27f6 Z) := by aesop_cat\n  \n  zero_comp : \u2200 (X : C) {Y Z : C} (f : Y \u27f6 Z), (0 : X \u27f6 Y) \u226b f = (0 : X \u27f6 Z) := by aesop_cat", "start": [49, 1], "end": [57, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.comp_zero", "code": "@[simp]\ntheorem comp_zero [HasZeroMorphisms C] {X Y : C} {f : X \u27f6 Y} {Z : C} :\n    f \u226b (0 : Y \u27f6 Z) = (0 : X \u27f6 Z)", "start": [66, 1], "end": [69, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.zero_comp", "code": "@[simp]\ntheorem zero_comp [HasZeroMorphisms C] {X : C} {Y Z : C} {f : Y \u27f6 Z} :\n    (0 : X \u27f6 Y) \u226b f = (0 : X \u27f6 Z)", "start": [72, 1], "end": [75, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasZeroMorphismsPEmpty", "code": "instance hasZeroMorphismsPEmpty : HasZeroMorphisms (Discrete PEmpty) where\n  Zero := by aesop_cat", "start": [78, 1], "end": [79, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasZeroMorphismsPUnit", "code": "instance hasZeroMorphismsPUnit : HasZeroMorphisms (Discrete PUnit) where\n  Zero := fun X Y => by repeat (constructor)", "start": [82, 1], "end": [83, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroMorphisms.ext_aux", "code": "private theorem ext_aux (I J : HasZeroMorphisms C)\n    (w : \u2200 X Y : C, (I.Zero X Y).zero = (J.Zero X Y).zero) : I = J", "start": [88, 1], "end": [98, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroMorphisms.ext", "code": "theorem ext (I J : HasZeroMorphisms C) : I = J", "start": [101, 1], "end": [114, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasZeroMorphismsOpposite", "code": "instance hasZeroMorphismsOpposite [HasZeroMorphisms C] : HasZeroMorphisms C\u1d52\u1d56 where\n  Zero X Y := \u27e8(0 : unop Y \u27f6 unop X).op\u27e9\n  comp_zero f Z := congr_arg Quiver.Hom.op (HasZeroMorphisms.zero_comp (unop Z) f.unop)\n  zero_comp X {Y Z} (f : Y \u27f6 Z) :=\n    congrArg Quiver.Hom.op (HasZeroMorphisms.comp_zero f.unop (unop X))", "start": [124, 1], "end": [128, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.op_zero", "code": "@[simp] lemma op_zero (X Y : C) : (0 : X \u27f6 Y).op = 0 := rfl", "start": [135, 1], "end": [135, 60], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.unop_zero", "code": "@[simp] lemma unop_zero (X Y : C\u1d52\u1d56) : (0 : X \u27f6 Y).unop = 0 := rfl", "start": [138, 1], "end": [138, 66], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.zero_of_comp_mono", "code": "theorem zero_of_comp_mono {X Y Z : C} {f : X \u27f6 Y} (g : Y \u27f6 Z) [Mono g] (h : f \u226b g = 0) : f = 0", "start": [141, 1], "end": [143, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.zero_of_epi_comp", "code": "theorem zero_of_epi_comp {X Y Z : C} (f : X \u27f6 Y) {g : Y \u27f6 Z} [Epi f] (h : f \u226b g = 0) : g = 0", "start": [146, 1], "end": [148, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.eq_zero_of_image_eq_zero", "code": "theorem eq_zero_of_image_eq_zero {X Y : C} {f : X \u27f6 Y} [HasImage f] (w : image.\u03b9 f = 0) : f = 0", "start": [151, 1], "end": [152, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.nonzero_image_of_nonzero", "code": "theorem nonzero_image_of_nonzero {X Y : C} {f : X \u27f6 Y} [HasImage f] (w : f \u2260 0) : image.\u03b9 f \u2260 0", "start": [155, 1], "end": [156, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.zero_app", "code": "@[simp]\ntheorem zero_app (F G : C \u2964 D) (j : C) : (0 : F \u27f6 G).app j = 0", "start": [172, 1], "end": [173, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.eq_zero_of_src", "code": "theorem eq_zero_of_src {X Y : C} (o : IsZero X) (f : X \u27f6 Y) : f = 0", "start": [182, 1], "end": [183, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.eq_zero_of_tgt", "code": "theorem eq_zero_of_tgt {X Y : C} (o : IsZero Y) (f : X \u27f6 Y) : f = 0", "start": [186, 1], "end": [187, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.iff_id_eq_zero", "code": "theorem iff_id_eq_zero (X : C) : IsZero X \u2194 \ud835\udfd9 X = 0", "start": [190, 1], "end": [195, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.of_mono_zero", "code": "theorem of_mono_zero (X Y : C) [Mono (0 : X \u27f6 Y)] : IsZero X", "start": [198, 1], "end": [199, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.of_epi_zero", "code": "theorem of_epi_zero (X Y : C) [Epi (0 : X \u27f6 Y)] : IsZero Y", "start": [202, 1], "end": [203, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.of_mono_eq_zero", "code": "theorem of_mono_eq_zero {X Y : C} (f : X \u27f6 Y) [Mono f] (h : f = 0) : IsZero X", "start": [206, 1], "end": [208, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.of_epi_eq_zero", "code": "theorem of_epi_eq_zero {X Y : C} (f : X \u27f6 Y) [Epi f] (h : f = 0) : IsZero Y", "start": [211, 1], "end": [213, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.iff_isSplitMono_eq_zero", "code": "theorem iff_isSplitMono_eq_zero {X Y : C} (f : X \u27f6 Y) [IsSplitMono f] : IsZero X \u2194 f = 0", "start": [216, 1], "end": [223, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.iff_isSplitEpi_eq_zero", "code": "theorem iff_isSplitEpi_eq_zero {X Y : C} (f : X \u27f6 Y) [IsSplitEpi f] : IsZero Y \u2194 f = 0", "start": [226, 1], "end": [233, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.of_mono", "code": "theorem of_mono {X Y : C} (f : X \u27f6 Y) [Mono f] (i : IsZero Y) : IsZero X", "start": [236, 1], "end": [239, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.of_epi", "code": "theorem of_epi {X Y : C} (f : X \u27f6 Y) [Epi f] (i : IsZero X) : IsZero Y", "start": [242, 1], "end": [245, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.hasZeroMorphisms", "code": "def IsZero.hasZeroMorphisms {O : C} (hO : IsZero O) : HasZeroMorphisms C where\n  Zero X Y := { zero := hO.from_ X \u226b hO.to_ Y }\n  zero_comp X {Y Z} f := by\n    change (hO.from_ X \u226b hO.to_ Y) \u226b f = hO.from_ X \u226b hO.to_ Z\n    rw [Category.assoc]\n    congr\n    apply hO.eq_of_src\n  comp_zero {X Y} f Z := by\n    change f \u226b (hO.from_ Y \u226b hO.to_ Z) = hO.from_ X \u226b hO.to_ Z\n    rw [\u2190 Category.assoc]\n    congr\n    apply hO.eq_of_tgt", "start": [250, 1], "end": [269, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroMorphismsOfZeroObject", "code": "def zeroMorphismsOfZeroObject : HasZeroMorphisms C where\n  Zero X Y := { zero := (default : X \u27f6 0) \u226b default }\n  zero_comp X {Y Z} f := by\n    change ((default : X \u27f6 0) \u226b default) \u226b f = (default : X \u27f6 0) \u226b default\n    rw [Category.assoc]\n    congr\n    simp only [eq_iff_true_of_subsingleton]\n  comp_zero {X Y} f Z := by\n    change f \u226b (default : Y \u27f6 0) \u226b default = (default : X \u27f6 0) \u226b default\n    rw [\u2190 Category.assoc]\n    congr\n    simp only [eq_iff_true_of_subsingleton]", "start": [278, 1], "end": [297, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsoIsInitial_hom", "code": "@[simp]\ntheorem zeroIsoIsInitial_hom {X : C} (t : IsInitial X) : (zeroIsoIsInitial t).hom = 0", "start": [304, 1], "end": [305, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsoIsInitial_inv", "code": "@[simp]\ntheorem zeroIsoIsInitial_inv {X : C} (t : IsInitial X) : (zeroIsoIsInitial t).inv = 0", "start": [308, 1], "end": [309, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsoIsTerminal_hom", "code": "@[simp]\ntheorem zeroIsoIsTerminal_hom {X : C} (t : IsTerminal X) : (zeroIsoIsTerminal t).hom = 0", "start": [312, 1], "end": [313, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsoIsTerminal_inv", "code": "@[simp]\ntheorem zeroIsoIsTerminal_inv {X : C} (t : IsTerminal X) : (zeroIsoIsTerminal t).inv = 0", "start": [316, 1], "end": [317, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsoInitial_hom", "code": "@[simp]\ntheorem zeroIsoInitial_hom [HasInitial C] : zeroIsoInitial.hom = (0 : 0 \u27f6 \u22a5_ C)", "start": [320, 1], "end": [321, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsoInitial_inv", "code": "@[simp]\ntheorem zeroIsoInitial_inv [HasInitial C] : zeroIsoInitial.inv = (0 : \u22a5_ C \u27f6 0)", "start": [324, 1], "end": [325, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsoTerminal_hom", "code": "@[simp]\ntheorem zeroIsoTerminal_hom [HasTerminal C] : zeroIsoTerminal.hom = (0 : 0 \u27f6 \u22a4_ C)", "start": [328, 1], "end": [329, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsoTerminal_inv", "code": "@[simp]\ntheorem zeroIsoTerminal_inv [HasTerminal C] : zeroIsoTerminal.inv = (0 : \u22a4_ C \u27f6 0)", "start": [332, 1], "end": [333, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsZero.map", "code": "@[simp]\ntheorem IsZero.map [HasZeroObject D] [HasZeroMorphisms D] {F : C \u2964 D} (hF : IsZero F) {X Y : C}\n    (f : X \u27f6 Y) : F.map f = 0", "start": [349, 1], "end": [352, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.zero_obj", "code": "@[simp]\ntheorem _root_.CategoryTheory.Functor.zero_obj [HasZeroObject D] (X : C) :\n    IsZero ((0 : C \u2964 D).obj X)", "start": [355, 1], "end": [358, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.zero_map", "code": "@[simp]\ntheorem _root_.CategoryTheory.zero_map [HasZeroObject D] [HasZeroMorphisms D] {X Y : C}\n    (f : X \u27f6 Y) : (0 : C \u2964 D).map f = 0", "start": [361, 1], "end": [364, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.id_zero", "code": "@[simp]\ntheorem id_zero : \ud835\udfd9 (0 : C) = (0 : (0 : C) \u27f6 0)", "start": [373, 1], "end": [374, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.zero_of_to_zero", "code": "theorem zero_of_to_zero {X : C} (f : X \u27f6 0) : f = 0", "start": [378, 1], "end": [379, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.zero_of_target_iso_zero", "code": "theorem zero_of_target_iso_zero {X Y : C} (f : X \u27f6 Y) (i : Y \u2245 0) : f = 0", "start": [382, 1], "end": [384, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.zero_of_from_zero", "code": "theorem zero_of_from_zero {X : C} (f : 0 \u27f6 X) : f = 0", "start": [387, 1], "end": [388, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.zero_of_source_iso_zero", "code": "theorem zero_of_source_iso_zero {X Y : C} (f : X \u27f6 Y) (i : X \u2245 0) : f = 0", "start": [391, 1], "end": [393, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.zero_of_source_iso_zero'", "code": "theorem zero_of_source_iso_zero' {X Y : C} (f : X \u27f6 Y) (i : IsIsomorphic X 0) : f = 0", "start": [396, 1], "end": [397, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.zero_of_target_iso_zero'", "code": "theorem zero_of_target_iso_zero' {X Y : C} (f : X \u27f6 Y) (i : IsIsomorphic Y 0) : f = 0", "start": [400, 1], "end": [401, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.mono_of_source_iso_zero", "code": "theorem mono_of_source_iso_zero {X Y : C} (f : X \u27f6 Y) (i : X \u2245 0) : Mono f", "start": [404, 1], "end": [405, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.epi_of_target_iso_zero", "code": "theorem epi_of_target_iso_zero {X Y : C} (f : X \u27f6 Y) (i : Y \u2245 0) : Epi f", "start": [408, 1], "end": [409, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.idZeroEquivIsoZero", "code": "def idZeroEquivIsoZero (X : C) : \ud835\udfd9 X = 0 \u2243 (X \u2245 0) where\n  toFun h :=\n    { hom := 0\n      inv := 0 }\n  invFun i := zero_of_target_iso_zero (\ud835\udfd9 X) i\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat", "start": [412, 1], "end": [422, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.idZeroEquivIsoZero_apply_hom", "code": "@[simp]\ntheorem idZeroEquivIsoZero_apply_hom (X : C) (h : \ud835\udfd9 X = 0) : ((idZeroEquivIsoZero X) h).hom = 0", "start": [425, 1], "end": [427, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.idZeroEquivIsoZero_apply_inv", "code": "@[simp]\ntheorem idZeroEquivIsoZero_apply_inv (X : C) (h : \ud835\udfd9 X = 0) : ((idZeroEquivIsoZero X) h).inv = 0", "start": [430, 1], "end": [432, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isoZeroOfMonoZero", "code": "@[simps]\ndef isoZeroOfMonoZero {X Y : C} (h : Mono (0 : X \u27f6 Y)) : X \u2245 0 where\n  hom := 0\n  inv := 0\n  hom_inv_id := (cancel_mono (0 : X \u27f6 Y)).mp (by simp)", "start": [435, 1], "end": [440, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isoZeroOfEpiZero", "code": "@[simps]\ndef isoZeroOfEpiZero {X Y : C} (h : Epi (0 : X \u27f6 Y)) : Y \u2245 0 where\n  hom := 0\n  inv := 0\n  hom_inv_id := (cancel_epi (0 : X \u27f6 Y)).mp (by simp)", "start": [443, 1], "end": [448, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isoZeroOfMonoEqZero", "code": "def isoZeroOfMonoEqZero {X Y : C} {f : X \u27f6 Y} [Mono f] (h : f = 0) : X \u2245 0 := by\n  subst h\n  apply isoZeroOfMonoZero \u2039_\u203a", "start": [451, 1], "end": [454, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isoZeroOfEpiEqZero", "code": "def isoZeroOfEpiEqZero {X Y : C} {f : X \u27f6 Y} [Epi f] (h : f = 0) : Y \u2245 0 := by\n  subst h\n  apply isoZeroOfEpiZero \u2039_\u203a", "start": [457, 1], "end": [460, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isoOfIsIsomorphicZero", "code": "def isoOfIsIsomorphicZero {X : C} (P : IsIsomorphic X 0) : X \u2245 0 where\n  hom := 0\n  inv := 0\n  hom_inv_id := by\n    cases' P with P\n    rw [\u2190P.hom_inv_id,\u2190Category.id_comp P.inv]\n    apply Eq.symm\n    simp only [id_comp, Iso.hom_inv_id, comp_zero]\n    apply (idZeroEquivIsoZero X).invFun P\n  inv_hom_id := by simp", "start": [463, 1], "end": [474, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIsoZeroEquiv", "code": "@[simps]\ndef isIsoZeroEquiv (X Y : C) : IsIso (0 : X \u27f6 Y) \u2243 \ud835\udfd9 X = 0 \u2227 \ud835\udfd9 Y = 0 where\n  toFun := by\n    intro i\n    rw [\u2190 IsIso.hom_inv_id (0 : X \u27f6 Y)]\n    rw [\u2190 IsIso.inv_hom_id (0 : X \u27f6 Y)]\n    simp only [eq_self_iff_true,comp_zero,and_self,zero_comp]\n  invFun h := \u27e8\u27e8(0 : Y \u27f6 X), by aesop_cat\u27e9\u27e9\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat", "start": [483, 1], "end": [495, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIsoZeroSelfEquiv", "code": "def isIsoZeroSelfEquiv (X : C) : IsIso (0 : X \u27f6 X) \u2243 \ud835\udfd9 X = 0 := by simpa using isIsoZeroEquiv X X", "start": [501, 1], "end": [504, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIsoZeroEquivIsoZero", "code": "def isIsoZeroEquivIsoZero (X Y : C) : IsIso (0 : X \u27f6 Y) \u2243 (X \u2245 0) \u00d7 (Y \u2245 0) := by\n  refine' (isIsoZeroEquiv X Y).trans _\n  symm\n  fconstructor\n  \u00b7 rintro \u27e8eX, eY\u27e9\n    fconstructor\n    exact (idZeroEquivIsoZero X).symm eX\n    exact (idZeroEquivIsoZero Y).symm eY\n  \u00b7 rintro \u27e8hX, hY\u27e9\n    fconstructor\n    exact (idZeroEquivIsoZero X) hX\n    exact (idZeroEquivIsoZero Y) hY\n  \u00b7 aesop_cat\n  \u00b7 aesop_cat", "start": [511, 1], "end": [528, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIso_of_source_target_iso_zero", "code": "theorem isIso_of_source_target_iso_zero {X Y : C} (f : X \u27f6 Y) (i : X \u2245 0) (j : Y \u2245 0) :\n    IsIso f", "start": [531, 1], "end": [534, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isIsoZeroSelfEquivIsoZero", "code": "def isIsoZeroSelfEquivIsoZero (X : C) : IsIso (0 : X \u27f6 X) \u2243 (X \u2245 0) :=\n  (isIsoZeroEquivIsoZero X X).trans subsingletonProdSelfEquiv", "start": [537, 1], "end": [541, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasZeroObject_of_hasInitial_object", "code": "theorem hasZeroObject_of_hasInitial_object [HasZeroMorphisms C] [HasInitial C] :\n    HasZeroObject C", "start": [546, 1], "end": [553, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasZeroObject_of_hasTerminal_object", "code": "theorem hasZeroObject_of_hasTerminal_object [HasZeroMorphisms C] [HasTerminal C] :\n    HasZeroObject C", "start": [556, 1], "end": [563, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image_\u03b9_comp_eq_zero", "code": "theorem image_\u03b9_comp_eq_zero {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} [HasImage f]\n    [Epi (factorThruImage f)] (h : f \u226b g = 0) : image.\u03b9 f \u226b g = 0", "start": [570, 1], "end": [572, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.comp_factorThruImage_eq_zero", "code": "theorem comp_factorThruImage_eq_zero {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} [HasImage g]\n    (h : f \u226b g = 0) : f \u226b factorThruImage g = 0", "start": [575, 1], "end": [577, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.monoFactorisationZero", "code": "@[simps]\ndef monoFactorisationZero (X Y : C) : MonoFactorisation (0 : X \u27f6 Y) where\n  I := 0\n  m := 0\n  e := 0", "start": [584, 1], "end": [590, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.imageFactorisationZero", "code": "def imageFactorisationZero (X Y : C) : ImageFactorisation (0 : X \u27f6 Y) where\n  F := monoFactorisationZero X Y\n  isImage := { lift := fun F' => 0 }", "start": [593, 1], "end": [597, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasImage_zero", "code": "instance hasImage_zero {X Y : C} : HasImage (0 : X \u27f6 Y) :=\n  HasImage.mk <| imageFactorisationZero _ _", "start": [600, 1], "end": [601, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.imageZero", "code": "def imageZero {X Y : C} : image (0 : X \u27f6 Y) \u2245 0 :=\n  IsImage.isoExt (Image.isImage (0 : X \u27f6 Y)) (imageFactorisationZero X Y).isImage", "start": [604, 1], "end": [606, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.imageZero'", "code": "def imageZero' {X Y : C} {f : X \u27f6 Y} (h : f = 0) [HasImage f] : image f \u2245 0 :=\n  image.eqToIso h \u226a\u226b imageZero", "start": [609, 1], "end": [611, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.\u03b9_zero", "code": "@[simp]\ntheorem image.\u03b9_zero {X Y : C} [HasImage (0 : X \u27f6 Y)] : image.\u03b9 (0 : X \u27f6 Y) = 0", "start": [614, 1], "end": [617, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.image.\u03b9_zero'", "code": "@[simp]\ntheorem image.\u03b9_zero' [HasEqualizers C] {X Y : C} {f : X \u27f6 Y} (h : f = 0) [HasImage f] :\n    image.\u03b9 f = 0", "start": [620, 1], "end": [628, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isSplitMono_sigma_\u03b9", "code": "instance isSplitMono_sigma_\u03b9 {\u03b2 : Type u'} [HasZeroMorphisms C] (f : \u03b2 \u2192 C)\n    [HasColimit (Discrete.functor f)] (b : \u03b2) : IsSplitMono (Sigma.\u03b9 f b) :=\n  IsSplitMono.mk' { retraction := Sigma.desc <| Pi.single b (\ud835\udfd9 _) }", "start": [633, 1], "end": [636, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isSplitEpi_pi_\u03c0", "code": "instance isSplitEpi_pi_\u03c0 {\u03b2 : Type u'} [HasZeroMorphisms C] (f : \u03b2 \u2192 C)\n    [HasLimit (Discrete.functor f)] (b : \u03b2) : IsSplitEpi (Pi.\u03c0 f b) :=\n  IsSplitEpi.mk' { section_ := Pi.lift <| Pi.single b (\ud835\udfd9 _) }", "start": [639, 1], "end": [642, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isSplitMono_coprod_inl", "code": "instance isSplitMono_coprod_inl [HasZeroMorphisms C] {X Y : C} [HasColimit (pair X Y)] :\n    IsSplitMono (coprod.inl : X \u27f6 X \u2a3f Y) :=\n  IsSplitMono.mk' { retraction := coprod.desc (\ud835\udfd9 X) 0 }", "start": [645, 1], "end": [648, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isSplitMono_coprod_inr", "code": "instance isSplitMono_coprod_inr [HasZeroMorphisms C] {X Y : C} [HasColimit (pair X Y)] :\n    IsSplitMono (coprod.inr : Y \u27f6 X \u2a3f Y) :=\n  IsSplitMono.mk' { retraction := coprod.desc 0 (\ud835\udfd9 Y) }", "start": [651, 1], "end": [654, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isSplitEpi_prod_fst", "code": "instance isSplitEpi_prod_fst [HasZeroMorphisms C] {X Y : C} [HasLimit (pair X Y)] :\n    IsSplitEpi (prod.fst : X \u2a2f Y \u27f6 X) :=\n  IsSplitEpi.mk' { section_ := prod.lift (\ud835\udfd9 X) 0 }", "start": [657, 1], "end": [660, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isSplitEpi_prod_snd", "code": "instance isSplitEpi_prod_snd [HasZeroMorphisms C] {X Y : C} [HasLimit (pair X Y)] :\n    IsSplitEpi (prod.snd : X \u2a2f Y \u27f6 Y) :=\n  IsSplitEpi.mk' { section_ := prod.lift 0 (\ud835\udfd9 Y) }", "start": [663, 1], "end": [666, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/ConeCategory.lean", "imports": ["Mathlib/CategoryTheory/Adjunction/Comma.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Terminal.lean", "Mathlib/CategoryTheory/Limits/Shapes/Equivalence.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Over.lean"], "premises": [{"full_name": "CategoryTheory.Limits.Cone.toStructuredArrow", "code": "@[simps]\ndef Cone.toStructuredArrow {F : J \u2964 C} (c : Cone F) : J \u2964 StructuredArrow c.pt F where\n  obj j := StructuredArrow.mk (c.\u03c0.app j)\n  map f := StructuredArrow.homMk f", "start": [38, 1], "end": [43, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.toStructuredArrowIsoToStructuredArrow", "code": "def Cone.toStructuredArrowIsoToStructuredArrow {F : J \u2964 C} (c : Cone F) :\n    c.toStructuredArrow \u2245 (\ud835\udfed J).toStructuredArrow c.pt F c.\u03c0.app (by simp) :=\n  Iso.refl _", "start": [45, 1], "end": [48, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toStructuredArrowIsoToStructuredArrow", "code": "def _root_.CategoryTheory.Functor.toStructuredArrowIsoToStructuredArrow (G : J \u2964 K) (X : C)\n    (F : K \u2964 C) (f : (Y : J) \u2192 X \u27f6 F.obj (G.obj Y))\n    (h : \u2200 {Y Z : J} (g : Y \u27f6 Z), f Y \u226b F.map (G.map g) = f Z) :\n    G.toStructuredArrow X F f h \u2245\n      (Cone.mk X \u27e8f, by simp [h]\u27e9).toStructuredArrow \u22d9 StructuredArrow.pre _ _ _ :=\n  Iso.refl _", "start": [50, 1], "end": [56, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.toStructuredArrowCompProj", "code": "@[simps!]\ndef Cone.toStructuredArrowCompProj {F : J \u2964 C} (c : Cone F) :\n    c.toStructuredArrow \u22d9 StructuredArrow.proj _ _ \u2245 \ud835\udfed J :=\n  Iso.refl _", "start": [58, 1], "end": [63, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.toStructuredArrow_comp_proj", "code": "@[simp]\nlemma Cone.toStructuredArrow_comp_proj {F : J \u2964 C} (c : Cone F) :\n    c.toStructuredArrow \u22d9 StructuredArrow.proj _ _ = \ud835\udfed J :=\n  rfl", "start": [65, 1], "end": [68, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Cone.toStructuredArrowCompToUnderCompForget", "code": "@[simps!]\ndef Cone.toStructuredArrowCompToUnderCompForget {F : J \u2964 C} (c : Cone F) :\n    c.toStructuredArrow \u22d9 StructuredArrow.toUnder _ _ \u22d9 Under.forget _ \u2245 F :=\n  Iso.refl _", "start": [70, 1], "end": [76, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.toStructuredArrow_comp_toUnder_comp_forget", "code": "@[simp]\nlemma Cone.toStructuredArrow_comp_toUnder_comp_forget {F : J \u2964 C} (c : Cone F) :\n    c.toStructuredArrow \u22d9 StructuredArrow.toUnder _ _ \u22d9 Under.forget _ = F :=\n  rfl", "start": [78, 1], "end": [81, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Cone.fromStructuredArrow", "code": "@[simps!]\ndef Cone.fromStructuredArrow (F : C \u2964 D) {X : D} (G : J \u2964 StructuredArrow X F) :\n    Cone (G \u22d9 StructuredArrow.proj X F \u22d9 F) where\n  \u03c0 := { app := fun j => (G.obj j).hom }", "start": [83, 1], "end": [87, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.toStructuredArrowCone", "code": "@[simps]\ndef Cone.toStructuredArrowCone {K : J \u2964 C} (c : Cone K) (F : C \u2964 D) {X : D} (f : X \u27f6 F.obj c.pt) :\n    Cone ((F.mapCone c).toStructuredArrow \u22d9 StructuredArrow.map f \u22d9 StructuredArrow.pre _ K F) where\n  pt := StructuredArrow.mk f\n  \u03c0 := { app := fun j => StructuredArrow.homMk (c.\u03c0.app j) rfl }", "start": [90, 1], "end": [97, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.toCostructuredArrow", "code": "@[simps]\ndef Cone.toCostructuredArrow (F : J \u2964 C) : Cone F \u2964 CostructuredArrow (const J) F\n    where\n  obj c := CostructuredArrow.mk c.\u03c0\n  map f := CostructuredArrow.homMk f.hom", "start": [100, 1], "end": [106, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.fromCostructuredArrow", "code": "@[simps]\ndef Cone.fromCostructuredArrow (F : J \u2964 C) : CostructuredArrow (const J) F \u2964 Cone F\n    where\n  obj c := \u27e8c.left, c.hom\u27e9\n  map f :=\n    { hom := f.left\n      w := fun j => by\n        convert congr_fun (congr_arg NatTrans.app f.w) j\n        dsimp\n        simp }", "start": [109, 1], "end": [120, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.equivCostructuredArrow", "code": "@[simps! (config := { notRecursive := [`PLift, `ULift] })]\ndef Cone.equivCostructuredArrow (F : J \u2964 C) : Cone F \u224c CostructuredArrow (const J) F :=\n  Equivalence.mk (Cone.toCostructuredArrow F) (Cone.fromCostructuredArrow F)\n    (NatIso.ofComponents Cones.eta)\n    (NatIso.ofComponents fun c => (CostructuredArrow.eta _).symm)", "start": [130, 1], "end": [136, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.isLimitEquivIsTerminal", "code": "def Cone.isLimitEquivIsTerminal {F : J \u2964 C} (c : Cone F) : IsLimit c \u2243 IsTerminal c :=\n  IsLimit.isoUniqueConeMorphism.toEquiv.trans\n    { toFun := fun h => IsTerminal.ofUnique _\n      invFun := fun h s => \u27e8\u27e8IsTerminal.from h s\u27e9, fun a => IsTerminal.hom_ext h a _\u27e9\n      left_inv := by aesop_cat\n      right_inv := by aesop_cat }", "start": [139, 1], "end": [145, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimit_iff_hasTerminal_cone", "code": "theorem hasLimit_iff_hasTerminal_cone (F : J \u2964 C) : HasLimit F \u2194 HasTerminal (Cone F)", "start": [148, 1], "end": [151, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitsOfShape_iff_isLeftAdjoint_const", "code": "theorem hasLimitsOfShape_iff_isLeftAdjoint_const :\n    HasLimitsOfShape J C \u2194 Nonempty (IsLeftAdjoint (const J : C \u2964 _))", "start": [154, 1], "end": [163, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.liftConeMorphism_eq_isTerminal_from", "code": "theorem IsLimit.liftConeMorphism_eq_isTerminal_from {F : J \u2964 C} {c : Cone F} (hc : IsLimit c)\n    (s : Cone F) : hc.liftConeMorphism s = IsTerminal.from (Cone.isLimitEquivIsTerminal _ hc) _", "start": [166, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsTerminal.from_eq_liftConeMorphism", "code": "theorem IsTerminal.from_eq_liftConeMorphism {F : J \u2964 C} {c : Cone F} (hc : IsTerminal c)\n    (s : Cone F) :\n    IsTerminal.from hc s = ((Cone.isLimitEquivIsTerminal _).symm hc).liftConeMorphism s", "start": [171, 1], "end": [174, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.ofPreservesConeTerminal", "code": "def IsLimit.ofPreservesConeTerminal {F : J \u2964 C} {F' : K \u2964 D} (G : Cone F \u2964 Cone F')\n    [PreservesLimit (Functor.empty.{0} _) G] {c : Cone F} (hc : IsLimit c) : IsLimit (G.obj c) :=\n  (Cone.isLimitEquivIsTerminal _).symm <| (Cone.isLimitEquivIsTerminal _ hc).isTerminalObj _ _", "start": [177, 1], "end": [180, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.ofReflectsConeTerminal", "code": "def IsLimit.ofReflectsConeTerminal {F : J \u2964 C} {F' : K \u2964 D} (G : Cone F \u2964 Cone F')\n    [ReflectsLimit (Functor.empty.{0} _) G] {c : Cone F} (hc : IsLimit (G.obj c)) : IsLimit c :=\n  (Cone.isLimitEquivIsTerminal _).symm <| (Cone.isLimitEquivIsTerminal _ hc).isTerminalOfObj _ _", "start": [183, 1], "end": [186, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.toCostructuredArrow", "code": "@[simps]\ndef Cocone.toCostructuredArrow {F : J \u2964 C} (c : Cocone F) : J \u2964 CostructuredArrow F c.pt where\n  obj j := CostructuredArrow.mk (c.\u03b9.app j)\n  map f := CostructuredArrow.homMk f", "start": [189, 1], "end": [194, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.toCostructuredArrowIsoToCostructuredArrow", "code": "def Cocone.toCostructuredArrowIsoToCostructuredArrow {F : J \u2964 C} (c : Cocone F) :\n    c.toCostructuredArrow \u2245 (\ud835\udfed J).toCostructuredArrow F c.pt c.\u03b9.app (by simp) :=\n  Iso.refl _", "start": [196, 1], "end": [199, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toCostructuredArrowIsoToCostructuredArrow", "code": "def _root_.CategoryTheory.Functor.toCostructuredArrowIsoToCostructuredArrow (G : J \u2964 K)\n    (F : K \u2964 C) (X : C) (f : (Y : J) \u2192 F.obj (G.obj Y) \u27f6 X)\n    (h : \u2200 {Y Z : J} (g : Y \u27f6 Z), F.map (G.map g) \u226b f Z = f Y) :\n    G.toCostructuredArrow F X f h \u2245\n      (Cocone.mk X \u27e8f, by simp [h]\u27e9).toCostructuredArrow \u22d9 CostructuredArrow.pre _ _ _ :=\n  Iso.refl _", "start": [201, 1], "end": [207, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.toCostructuredArrowCompProj", "code": "@[simps!]\ndef Cocone.toCostructuredArrowCompProj {F : J \u2964 C} (c : Cocone F) :\n    c.toCostructuredArrow \u22d9 CostructuredArrow.proj _ _ \u2245 \ud835\udfed J :=\n  Iso.refl _", "start": [209, 1], "end": [214, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.toCostructuredArrow_comp_proj", "code": "@[simp]\nlemma Cocone.toCostructuredArrow_comp_proj {F : J \u2964 C} (c : Cocone F) :\n    c.toCostructuredArrow \u22d9 CostructuredArrow.proj _ _ = \ud835\udfed J :=\n  rfl", "start": [216, 1], "end": [219, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Cocone.toCostructuredArrowCompToOverCompForget", "code": "@[simps!]\ndef Cocone.toCostructuredArrowCompToOverCompForget {F : J \u2964 C} (c : Cocone F) :\n    c.toCostructuredArrow \u22d9 CostructuredArrow.toOver _ _ \u22d9 Over.forget _ \u2245 F :=\n  Iso.refl _", "start": [221, 1], "end": [227, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.toCostructuredArrow_comp_toOver_comp_forget", "code": "@[simp]\nlemma Cocone.toCostructuredArrow_comp_toOver_comp_forget {F : J \u2964 C} (c : Cocone F) :\n    c.toCostructuredArrow \u22d9 CostructuredArrow.toOver _ _ \u22d9 Over.forget _ = F :=\n  rfl", "start": [229, 1], "end": [232, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Cocone.fromCostructuredArrow", "code": "@[simps!]\ndef Cocone.fromCostructuredArrow (F : C \u2964 D) {X : D} (G : J \u2964 CostructuredArrow F X) :\n    Cocone (G \u22d9 CostructuredArrow.proj F X \u22d9 F) where\n  \u03b9 := { app := fun j => (G.obj j).hom }", "start": [234, 1], "end": [238, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.toCostructuredArrowCocone", "code": "@[simps]\ndef Cocone.toCostructuredArrowCocone {K : J \u2964 C} (c : Cocone K) (F : C \u2964 D) {X : D}\n    (f : F.obj c.pt \u27f6 X) : Cocone ((F.mapCocone c).toCostructuredArrow \u22d9\n      CostructuredArrow.map f \u22d9 CostructuredArrow.pre _ _ _) where\n  pt := CostructuredArrow.mk f\n  \u03b9 := { app := fun j => CostructuredArrow.homMk (c.\u03b9.app j) rfl }", "start": [240, 1], "end": [247, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.toStructuredArrow", "code": "@[simps]\ndef Cocone.toStructuredArrow (F : J \u2964 C) : Cocone F \u2964 StructuredArrow F (const J)\n    where\n  obj c := StructuredArrow.mk c.\u03b9\n  map f := StructuredArrow.homMk f.hom", "start": [249, 1], "end": [255, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.fromStructuredArrow", "code": "@[simps]\ndef Cocone.fromStructuredArrow (F : J \u2964 C) : StructuredArrow F (const J) \u2964 Cocone F\n    where\n  obj c := \u27e8c.right, c.hom\u27e9\n  map f :=\n    { hom := f.right\n      w := fun j => by\n        convert (congr_fun (congr_arg NatTrans.app f.w) j).symm\n        dsimp\n        simp }", "start": [258, 1], "end": [269, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.equivStructuredArrow", "code": "@[simps! (config := { notRecursive := [`PLift, `ULift] })]\ndef Cocone.equivStructuredArrow (F : J \u2964 C) : Cocone F \u224c StructuredArrow F (const J) :=\n  Equivalence.mk (Cocone.toStructuredArrow F) (Cocone.fromStructuredArrow F)\n    (NatIso.ofComponents Cocones.eta)\n    (NatIso.ofComponents fun c => (StructuredArrow.eta _).symm)", "start": [272, 1], "end": [278, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.isColimitEquivIsInitial", "code": "def Cocone.isColimitEquivIsInitial {F : J \u2964 C} (c : Cocone F) : IsColimit c \u2243 IsInitial c :=\n  IsColimit.isoUniqueCoconeMorphism.toEquiv.trans\n    { toFun := fun h => IsInitial.ofUnique _\n      invFun := fun h s => \u27e8\u27e8IsInitial.to h s\u27e9, fun a => IsInitial.hom_ext h a _\u27e9\n      left_inv := by aesop_cat\n      right_inv := by aesop_cat }", "start": [281, 1], "end": [287, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimit_iff_hasInitial_cocone", "code": "theorem hasColimit_iff_hasInitial_cocone (F : J \u2964 C) : HasColimit F \u2194 HasInitial (Cocone F)", "start": [290, 1], "end": [293, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimitsOfShape_iff_isRightAdjoint_const", "code": "theorem hasColimitsOfShape_iff_isRightAdjoint_const :\n    HasColimitsOfShape J C \u2194 Nonempty (IsRightAdjoint (const J : C \u2964 _))", "start": [296, 1], "end": [305, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.descCoconeMorphism_eq_isInitial_to", "code": "theorem IsColimit.descCoconeMorphism_eq_isInitial_to {F : J \u2964 C} {c : Cocone F} (hc : IsColimit c)\n    (s : Cocone F) :\n    hc.descCoconeMorphism s = IsInitial.to (Cocone.isColimitEquivIsInitial _ hc) _", "start": [308, 1], "end": [311, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsInitial.to_eq_descCoconeMorphism", "code": "theorem IsInitial.to_eq_descCoconeMorphism {F : J \u2964 C} {c : Cocone F} (hc : IsInitial c)\n    (s : Cocone F) :\n    IsInitial.to hc s = ((Cocone.isColimitEquivIsInitial _).symm hc).descCoconeMorphism s", "start": [314, 1], "end": [317, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.ofPreservesCoconeInitial", "code": "def IsColimit.ofPreservesCoconeInitial {F : J \u2964 C} {F' : K \u2964 D} (G : Cocone F \u2964 Cocone F')\n    [PreservesColimit (Functor.empty.{0} _) G] {c : Cocone F} (hc : IsColimit c) :\n    IsColimit (G.obj c) :=\n  (Cocone.isColimitEquivIsInitial _).symm <| (Cocone.isColimitEquivIsInitial _ hc).isInitialObj _ _", "start": [320, 1], "end": [324, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.ofReflectsCoconeInitial", "code": "def IsColimit.ofReflectsCoconeInitial {F : J \u2964 C} {F' : K \u2964 D} (G : Cocone F \u2964 Cocone F')\n    [ReflectsColimit (Functor.empty.{0} _) G] {c : Cocone F} (hc : IsColimit (G.obj c)) :\n    IsColimit c :=\n  (Cocone.isColimitEquivIsInitial _).symm <|\n    (Cocone.isColimitEquivIsInitial _ hc).isInitialOfObj _ _", "start": [327, 1], "end": [332, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/FinCategory.lean", "imports": ["Mathlib/CategoryTheory/DiscreteCategory.lean", "Mathlib/Data/Fintype/Card.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Category/ULift.lean", "Mathlib/CategoryTheory/Opposites.lean"], "premises": [{"full_name": "CategoryTheory.discreteFintype", "code": "instance discreteFintype {\u03b1 : Type*} [Fintype \u03b1] : Fintype (Discrete \u03b1) :=\n  Fintype.ofEquiv \u03b1 discreteEquiv.symm", "start": [34, 1], "end": [35, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.discreteHomFintype", "code": "instance discreteHomFintype {\u03b1 : Type*} (X Y : Discrete \u03b1) : Fintype (X \u27f6 Y) := by\n  apply ULift.fintype", "start": [38, 1], "end": [39, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinCategory", "code": "class FinCategory (J : Type v) [SmallCategory J] where\n  fintypeObj : Fintype J := by infer_instance\n  fintypeHom : \u2200 j j' : J, Fintype (j \u27f6 j') := by infer_instance", "start": [42, 1], "end": [45, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finCategoryDiscreteOfFintype", "code": "instance finCategoryDiscreteOfFintype (J : Type v) [Fintype J] : FinCategory (Discrete J) where", "start": [50, 1], "end": [50, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinCategory.ObjAsType", "code": "abbrev ObjAsType : Type :=\n  InducedCategory \u03b1 (Fintype.equivFin \u03b1).symm", "start": [57, 1], "end": [60, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinCategory.objAsTypeEquiv", "code": "noncomputable def objAsTypeEquiv : ObjAsType \u03b1 \u224c \u03b1 :=\n  (inducedFunctor (Fintype.equivFin \u03b1).symm).asEquivalence", "start": [66, 1], "end": [68, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinCategory.AsType", "code": "abbrev AsType : Type :=\n  Fin (Fintype.card \u03b1)", "start": [71, 1], "end": [74, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinCategory.categoryAsType", "code": "@[simps (config := .lemmasOnly) id comp]\nnoncomputable instance categoryAsType : SmallCategory (AsType \u03b1)\n    where\n  Hom i j := Fin (Fintype.card (@Quiver.Hom (ObjAsType \u03b1) _ i j))\n  id i := Fintype.equivFin _ (\ud835\udfd9 _)\n  comp f g := Fintype.equivFin _ ((Fintype.equivFin _).symm f \u226b (Fintype.equivFin _).symm g)", "start": [77, 1], "end": [82, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinCategory.asTypeToObjAsType", "code": "@[simps]\nnoncomputable def asTypeToObjAsType : AsType \u03b1 \u2964 ObjAsType \u03b1\n    where\n  obj := id\n  map {X Y} := (Fintype.equivFin _).symm", "start": [87, 1], "end": [92, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinCategory.objAsTypeToAsType", "code": "@[simps]\nnoncomputable def objAsTypeToAsType : ObjAsType \u03b1 \u2964 AsType \u03b1\n    where\n  obj := id\n  map {X Y} := Fintype.equivFin _", "start": [95, 1], "end": [100, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinCategory.asTypeEquivObjAsType", "code": "noncomputable def asTypeEquivObjAsType : AsType \u03b1 \u224c ObjAsType \u03b1 :=\n  Equivalence.mk (asTypeToObjAsType \u03b1) (objAsTypeToAsType \u03b1)\n    (NatIso.ofComponents Iso.refl)\n    (NatIso.ofComponents Iso.refl)", "start": [103, 1], "end": [107, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinCategory.asTypeFinCategory", "code": "noncomputable instance asTypeFinCategory : FinCategory (AsType \u03b1) where\n  fintypeHom := fun _ _ => show Fintype (Fin _) from inferInstance", "start": [110, 1], "end": [111, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinCategory.equivAsType", "code": "noncomputable def equivAsType : AsType \u03b1 \u224c \u03b1 :=\n  (asTypeEquivObjAsType \u03b1).trans (objAsTypeEquiv \u03b1)", "start": [114, 1], "end": [116, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finCategoryOpposite", "code": "instance finCategoryOpposite {J : Type v} [SmallCategory J] [FinCategory J] : FinCategory J\u1d52\u1d56\n    where\n  fintypeObj := Fintype.ofEquiv _ equivToOpposite\n  fintypeHom j j' := Fintype.ofEquiv _ (opEquiv j j').symm", "start": [123, 1], "end": [128, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finCategoryUlift", "code": "instance finCategoryUlift {J : Type v} [SmallCategory J] [FinCategory J] :\n    FinCategory.{max w v} (ULiftHom.{w, max w v} (ULift.{w, v} J))\n    where\n  fintypeObj := ULift.fintype J\n  fintypeHom := fun _ _ => ULift.fintype _", "start": [131, 1], "end": [136, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Adjunction/FullyFaithful.lean", "imports": ["Mathlib/CategoryTheory/Conj.lean", "Mathlib/CategoryTheory/Yoneda.lean", "Mathlib/CategoryTheory/Adjunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.unit_isIso_of_L_fully_faithful", "code": "instance unit_isIso_of_L_fully_faithful [Full L] [Faithful L] : IsIso (Adjunction.unit h) :=\n  @NatIso.isIso_of_isIso_app _ _ _ _ _ _ (Adjunction.unit h) fun X =>\n    @Yoneda.isIso _ _ _ _ ((Adjunction.unit h).app X)\n      \u27e8\u27e8{ app := fun Y f => L.preimage ((h.homEquiv (unop Y) (L.obj X)).symm f) },\n          \u27e8by\n            ext x\n            apply L.map_injective\n            aesop_cat,\n           by\n            ext x\n            dsimp\n            simp only [Adjunction.homEquiv_counit, preimage_comp, preimage_map, Category.assoc]\n            rw [\u2190 h.unit_naturality]\n            simp\u27e9\u27e9\u27e9", "start": [43, 1], "end": [63, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.counit_isIso_of_R_fully_faithful", "code": "instance counit_isIso_of_R_fully_faithful [Full R] [Faithful R] : IsIso (Adjunction.counit h) :=\n  @NatIso.isIso_of_isIso_app _ _ _ _ _ _ (Adjunction.counit h) fun X =>\n    @isIso_of_op _ _ _ _ _ <|\n      @Coyoneda.isIso _ _ _ _ ((Adjunction.counit h).app X).op\n        \u27e8\u27e8{ app := fun Y f => R.preimage ((h.homEquiv (R.obj X) Y) f) },\n            \u27e8by\n              ext x\n              apply R.map_injective\n              simp,\n             by\n              ext x\n              dsimp\n              simp only [Adjunction.homEquiv_unit, preimage_comp, preimage_map]\n              rw [\u2190 h.counit_naturality]\n              simp\u27e9\u27e9\u27e9", "start": [67, 1], "end": [85, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.inv_map_unit", "code": "@[simp]\ntheorem inv_map_unit {X : C} [IsIso (h.unit.app X)] :\n    inv (L.map (h.unit.app X)) = h.counit.app (L.obj X)", "start": [89, 1], "end": [94, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerLeftLCounitIsoOfIsIsoUnit", "code": "@[simps!]\nnoncomputable def whiskerLeftLCounitIsoOfIsIsoUnit [IsIso h.unit] : L \u22d9 R \u22d9 L \u2245 L :=\n  (L.associator R L).symm \u226a\u226b isoWhiskerRight (asIso h.unit).symm L \u226a\u226b Functor.leftUnitor _", "start": [97, 1], "end": [100, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.inv_counit_map", "code": "@[simp]\ntheorem inv_counit_map {X : D} [IsIso (h.counit.app X)] :\n    inv (R.map (h.counit.app X)) = h.unit.app (R.obj X)", "start": [104, 1], "end": [109, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerLeftRUnitIsoOfIsIsoCounit", "code": "@[simps!]\nnoncomputable def whiskerLeftRUnitIsoOfIsIsoCounit [IsIso h.counit] : R \u22d9 L \u22d9 R \u2245 R :=\n  (R.associator L R).symm \u226a\u226b isoWhiskerRight (asIso h.counit) R \u226a\u226b Functor.leftUnitor _", "start": [112, 1], "end": [115, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.lFullOfUnitIsIso", "code": "noncomputable def lFullOfUnitIsIso [IsIso h.unit] : Full L where\n  preimage {X Y} f := h.homEquiv _ (L.obj Y) f \u226b inv (h.unit.app Y)", "start": [119, 1], "end": [121, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.L_faithful_of_unit_isIso", "code": "theorem L_faithful_of_unit_isIso [IsIso h.unit] : Faithful L", "start": [125, 1], "end": [129, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rFullOfCounitIsIso", "code": "noncomputable def rFullOfCounitIsIso [IsIso h.counit] : Full R where\n  preimage {X Y} f := inv (h.counit.app X) \u226b (h.homEquiv (R.obj X) Y).symm f", "start": [133, 1], "end": [135, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.R_faithful_of_counit_isIso", "code": "theorem R_faithful_of_counit_isIso [IsIso h.counit] : Faithful R", "start": [139, 1], "end": [143, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerLeft_counit_iso_of_L_fully_faithful", "code": "instance whiskerLeft_counit_iso_of_L_fully_faithful [Full L] [Faithful L] :\n    IsIso (whiskerLeft L h.counit) := by\n  have := h.left_triangle\n  rw [\u2190 IsIso.eq_inv_comp] at this\n  rw [this]\n  infer_instance", "start": [147, 1], "end": [152, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerRight_counit_iso_of_L_fully_faithful", "code": "instance whiskerRight_counit_iso_of_L_fully_faithful [Full L] [Faithful L] :\n    IsIso (whiskerRight h.counit R) := by\n  have := h.right_triangle\n  rw [\u2190 IsIso.eq_inv_comp] at this\n  rw [this]\n  infer_instance", "start": [156, 1], "end": [161, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerLeft_unit_iso_of_R_fully_faithful", "code": "instance whiskerLeft_unit_iso_of_R_fully_faithful [Full R] [Faithful R] :\n    IsIso (whiskerLeft R h.unit) := by\n  have := h.right_triangle\n  rw [\u2190 IsIso.eq_comp_inv] at this\n  rw [this]\n  infer_instance", "start": [165, 1], "end": [170, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerRight_unit_iso_of_R_fully_faithful", "code": "instance whiskerRight_unit_iso_of_R_fully_faithful [Full R] [Faithful R] :\n    IsIso (whiskerRight h.unit L) := by\n  have := h.left_triangle\n  rw [\u2190 IsIso.eq_comp_inv] at this\n  rw [this]\n  infer_instance", "start": [174, 1], "end": [179, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.restrictFullyFaithful", "code": "def Adjunction.restrictFullyFaithful (iC : C \u2964 C') (iD : D \u2964 D') {L' : C' \u2964 D'} {R' : D' \u2964 C'}\n    (adj : L' \u22a3 R') {L : C \u2964 D} {R : D \u2964 C} (comm1 : iC \u22d9 L' \u2245 L \u22d9 iD) (comm2 : iD \u22d9 R' \u2245 R \u22d9 iC)\n    [Full iC] [Faithful iC] [Full iD] [Faithful iD] : L \u22a3 R :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y =>\n        calc\n          (L.obj X \u27f6 Y) \u2243 (iD.obj (L.obj X) \u27f6 iD.obj Y) := equivOfFullyFaithful iD\n          _ \u2243 (L'.obj (iC.obj X) \u27f6 iD.obj Y) := Iso.homCongr (comm1.symm.app X) (Iso.refl _)\n          _ \u2243 (iC.obj X \u27f6 R'.obj (iD.obj Y)) := adj.homEquiv _ _\n          _ \u2243 (iC.obj X \u27f6 iC.obj (R.obj Y)) := Iso.homCongr (Iso.refl _) (comm2.app Y)\n          _ \u2243 (X \u27f6 R.obj Y) := (equivOfFullyFaithful iC).symm\n\n      homEquiv_naturality_left_symm := fun {X' X Y} f g => by\n        apply iD.map_injective\n        simpa [Trans.trans] using (comm1.inv.naturality_assoc f _).symm\n      homEquiv_naturality_right := fun {X Y' Y} f g => by\n        apply iC.map_injective\n        suffices R'.map (iD.map g) \u226b comm2.hom.app Y = comm2.hom.app Y' \u226b iC.map (R.map g) by\n          simp [Trans.trans, this]\n        apply comm2.hom.naturality g }", "start": [192, 1], "end": [217, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Comma.lean", "imports": ["Mathlib/CategoryTheory/Limits/Creates.lean", "Mathlib/CategoryTheory/StructuredArrow.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Constructions/EpiMono.lean", "Mathlib/CategoryTheory/Limits/Unit.lean", "Mathlib/CategoryTheory/Arrow.lean"], "premises": [{"full_name": "CategoryTheory.Comma.limitAuxiliaryCone", "code": "@[simps!]\ndef limitAuxiliaryCone (c\u2081 : Cone (F \u22d9 fst L R)) : Cone ((F \u22d9 snd L R) \u22d9 R) :=\n  (Cones.postcompose (whiskerLeft F (Comma.natTrans L R) : _)).obj (L.mapCone c\u2081)", "start": [46, 1], "end": [50, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.coneOfPreserves", "code": "@[simps]\ndef coneOfPreserves [PreservesLimit (F \u22d9 snd L R) R] (c\u2081 : Cone (F \u22d9 fst L R))\n    {c\u2082 : Cone (F \u22d9 snd L R)} (t\u2082 : IsLimit c\u2082) : Cone F\n    where\n  pt :=\n    { left := c\u2081.pt\n      right := c\u2082.pt\n      hom := (isLimitOfPreserves R t\u2082).lift (limitAuxiliaryCone _ c\u2081) }\n  \u03c0 :=\n    { app := fun j =>\n        { left := c\u2081.\u03c0.app j\n          right := c\u2082.\u03c0.app j\n          w := ((isLimitOfPreserves R t\u2082).fac (limitAuxiliaryCone F c\u2081) j).symm }\n      naturality := fun j\u2081 j\u2082 t => by\n        ext\n        \u00b7 simp [\u2190 c\u2081.w t]\n        \u00b7 simp [\u2190 c\u2082.w t] }", "start": [53, 1], "end": [73, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.coneOfPreservesIsLimit", "code": "def coneOfPreservesIsLimit [PreservesLimit (F \u22d9 snd L R) R] {c\u2081 : Cone (F \u22d9 fst L R)}\n    (t\u2081 : IsLimit c\u2081) {c\u2082 : Cone (F \u22d9 snd L R)} (t\u2082 : IsLimit c\u2082) :\n    IsLimit (coneOfPreserves F c\u2081 t\u2082) where\n  lift s :=\n    { left := t\u2081.lift ((fst L R).mapCone s)\n      right := t\u2082.lift ((snd L R).mapCone s)\n      w :=\n        (isLimitOfPreserves R t\u2082).hom_ext fun j => by\n          rw [coneOfPreserves_pt_hom, assoc, assoc, (isLimitOfPreserves R t\u2082).fac,\n            limitAuxiliaryCone_\u03c0_app, \u2190 L.map_comp_assoc, t\u2081.fac, R.mapCone_\u03c0_app,\n            \u2190 R.map_comp, t\u2082.fac]\n          exact (s.\u03c0.app j).w }\n  uniq s m w := by\n    apply CommaMorphism.ext\n    \u00b7 exact t\u2081.uniq ((fst L R).mapCone s) _ (fun j => by simp [\u2190 w])\n    \u00b7 exact t\u2082.uniq ((snd L R).mapCone s) _ (fun j => by simp [\u2190 w])", "start": [76, 1], "end": [93, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.colimitAuxiliaryCocone", "code": "@[simps!]\ndef colimitAuxiliaryCocone (c\u2082 : Cocone (F \u22d9 snd L R)) : Cocone ((F \u22d9 fst L R) \u22d9 L) :=\n  (Cocones.precompose (whiskerLeft F (Comma.natTrans L R) : _)).obj (R.mapCocone c\u2082)", "start": [96, 1], "end": [100, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.coconeOfPreserves", "code": "@[simps]\ndef coconeOfPreserves [PreservesColimit (F \u22d9 fst L R) L] {c\u2081 : Cocone (F \u22d9 fst L R)}\n    (t\u2081 : IsColimit c\u2081) (c\u2082 : Cocone (F \u22d9 snd L R)) : Cocone F\n    where\n  pt :=\n    { left := c\u2081.pt\n      right := c\u2082.pt\n      hom := (isColimitOfPreserves L t\u2081).desc (colimitAuxiliaryCocone _ c\u2082) }\n  \u03b9 :=\n    { app := fun j =>\n        { left := c\u2081.\u03b9.app j\n          right := c\u2082.\u03b9.app j\n          w := (isColimitOfPreserves L t\u2081).fac (colimitAuxiliaryCocone _ c\u2082) j }\n      naturality := fun j\u2081 j\u2082 t => by\n        ext\n        \u00b7 simp [\u2190 c\u2081.w t]\n        \u00b7 simp [\u2190 c\u2082.w t] }", "start": [103, 1], "end": [124, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.coconeOfPreservesIsColimit", "code": "def coconeOfPreservesIsColimit [PreservesColimit (F \u22d9 fst L R) L] {c\u2081 : Cocone (F \u22d9 fst L R)}\n    (t\u2081 : IsColimit c\u2081) {c\u2082 : Cocone (F \u22d9 snd L R)} (t\u2082 : IsColimit c\u2082) :\n    IsColimit (coconeOfPreserves F t\u2081 c\u2082) where\n  desc s :=\n    { left := t\u2081.desc ((fst L R).mapCocone s)\n      right := t\u2082.desc ((snd L R).mapCocone s)\n      w :=\n        (isColimitOfPreserves L t\u2081).hom_ext fun j => by\n          rw [coconeOfPreserves_pt_hom, (isColimitOfPreserves L t\u2081).fac_assoc,\n            colimitAuxiliaryCocone_\u03b9_app, assoc, \u2190 R.map_comp, t\u2082.fac, L.mapCocone_\u03b9_app, \u2190\n            L.map_comp_assoc, t\u2081.fac]\n          exact (s.\u03b9.app j).w }\n  uniq s m w := by\n    apply CommaMorphism.ext\n    \u00b7 exact t\u2081.uniq ((fst L R).mapCocone s) _ (fun j => by simp [\u2190 w])\n    \u00b7 exact t\u2082.uniq ((snd L R).mapCocone s) _ (fun j => by simp [\u2190 w])", "start": [127, 1], "end": [144, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.hasLimit", "code": "instance hasLimit (F : J \u2964 Comma L R) [HasLimit (F \u22d9 fst L R)] [HasLimit (F \u22d9 snd L R)]\n    [PreservesLimit (F \u22d9 snd L R) R] : HasLimit F :=\n  HasLimit.mk \u27e8_, coneOfPreservesIsLimit _ (limit.isLimit _) (limit.isLimit _)\u27e9", "start": [147, 1], "end": [149, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.hasLimitsOfShape", "code": "instance hasLimitsOfShape [HasLimitsOfShape J A] [HasLimitsOfShape J B]\n    [PreservesLimitsOfShape J R] : HasLimitsOfShape J (Comma L R) where", "start": [152, 1], "end": [153, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.hasLimitsOfSize", "code": "instance hasLimitsOfSize [HasLimitsOfSize.{w, w'} A] [HasLimitsOfSize.{w, w'} B]\n    [PreservesLimitsOfSize.{w, w'} R] : HasLimitsOfSize.{w, w'} (Comma L R) :=\n  \u27e8fun _ _ => inferInstance\u27e9", "start": [156, 1], "end": [158, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.hasColimit", "code": "instance hasColimit (F : J \u2964 Comma L R) [HasColimit (F \u22d9 fst L R)] [HasColimit (F \u22d9 snd L R)]\n    [PreservesColimit (F \u22d9 fst L R) L] : HasColimit F :=\n  HasColimit.mk \u27e8_, coconeOfPreservesIsColimit _ (colimit.isColimit _) (colimit.isColimit _)\u27e9", "start": [161, 1], "end": [163, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.hasColimitsOfShape", "code": "instance hasColimitsOfShape [HasColimitsOfShape J A] [HasColimitsOfShape J B]\n    [PreservesColimitsOfShape J L] : HasColimitsOfShape J (Comma L R) where", "start": [166, 1], "end": [167, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.hasColimitsOfSize", "code": "instance hasColimitsOfSize [HasColimitsOfSize.{w, w'} A] [HasColimitsOfSize.{w, w'} B]\n    [PreservesColimitsOfSize.{w, w'} L] : HasColimitsOfSize.{w, w'} (Comma L R) :=\n  \u27e8fun _ _ => inferInstance\u27e9", "start": [170, 1], "end": [172, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.hasLimit", "code": "instance hasLimit (F : J \u2964 Arrow T) [i\u2081 : HasLimit (F \u22d9 leftFunc)] [i\u2082 : HasLimit (F \u22d9 rightFunc)] :\n    HasLimit F := by\n  haveI : HasLimit (F \u22d9 Comma.fst _ _) := i\u2081\n  haveI : HasLimit (F \u22d9 Comma.snd _ _) := i\u2082\n  apply Comma.hasLimit", "start": [179, 1], "end": [183, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.hasLimitsOfShape", "code": "instance hasLimitsOfShape [HasLimitsOfShape J T] : HasLimitsOfShape J (Arrow T) where", "start": [186, 1], "end": [186, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.hasLimits", "code": "instance hasLimits [HasLimits T] : HasLimits (Arrow T) :=\n  \u27e8fun _ _ => inferInstance\u27e9", "start": [189, 1], "end": [190, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.hasColimit", "code": "instance hasColimit (F : J \u2964 Arrow T) [i\u2081 : HasColimit (F \u22d9 leftFunc)]\n    [i\u2082 : HasColimit (F \u22d9 rightFunc)] : HasColimit F := by\n  haveI : HasColimit (F \u22d9 Comma.fst _ _) := i\u2081\n  haveI : HasColimit (F \u22d9 Comma.snd _ _) := i\u2082\n  apply Comma.hasColimit", "start": [193, 1], "end": [197, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.hasColimitsOfShape", "code": "instance hasColimitsOfShape [HasColimitsOfShape J T] : HasColimitsOfShape J (Arrow T) where", "start": [200, 1], "end": [200, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.hasColimits", "code": "instance hasColimits [HasColimits T] : HasColimits (Arrow T) :=\n  \u27e8fun _ _ => inferInstance\u27e9", "start": [203, 1], "end": [204, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.hasLimit", "code": "instance hasLimit [i\u2081 : HasLimit (F \u22d9 proj X G)] [i\u2082 : PreservesLimit (F \u22d9 proj X G) G] :\n    HasLimit F := by\n  haveI : HasLimit (F \u22d9 Comma.snd (Functor.fromPUnit X) G) := i\u2081\n  haveI : PreservesLimit (F \u22d9 Comma.snd (Functor.fromPUnit X) G) _ := i\u2082\n  apply Comma.hasLimit", "start": [213, 1], "end": [217, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.hasLimitsOfShape", "code": "instance hasLimitsOfShape [HasLimitsOfShape J A] [PreservesLimitsOfShape J G] :\n    HasLimitsOfShape J (StructuredArrow X G) where", "start": [220, 1], "end": [221, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.hasLimitsOfSize", "code": "instance hasLimitsOfSize [HasLimitsOfSize.{w, w'} A] [PreservesLimitsOfSize.{w, w'} G] :\n    HasLimitsOfSize.{w, w'} (StructuredArrow X G) :=\n  \u27e8fun J hJ => by infer_instance\u27e9", "start": [224, 1], "end": [226, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.createsLimit", "code": "noncomputable instance createsLimit [i : PreservesLimit (F \u22d9 proj X G) G] :\n    CreatesLimit F (proj X G) :=\n  letI : PreservesLimit (F \u22d9 Comma.snd (Functor.fromPUnit X) G) G := i\n  createsLimitOfReflectsIso fun _ t =>\n    { liftedCone := Comma.coneOfPreserves F punitCone t\n      makesLimit := Comma.coneOfPreservesIsLimit _ punitConeIsLimit _\n      validLift := Cones.ext (Iso.refl _) fun _ => (id_comp _).symm }", "start": [229, 1], "end": [235, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.createsLimitsOfShape", "code": "noncomputable instance createsLimitsOfShape [PreservesLimitsOfShape J G] :\n    CreatesLimitsOfShape J (proj X G) where", "start": [238, 1], "end": [239, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.createsLimitsOfSize", "code": "noncomputable instance createsLimitsOfSize [PreservesLimitsOfSize.{w, w'} G] :\n    CreatesLimitsOfSize.{w, w'} (proj X G : _) where", "start": [242, 1], "end": [243, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.mono_right_of_mono", "code": "instance mono_right_of_mono [HasPullbacks A] [PreservesLimitsOfShape WalkingCospan G]\n    {Y Z : StructuredArrow X G} (f : Y \u27f6 Z) [Mono f] : Mono f.right :=\n  show Mono ((proj X G).map f) from inferInstance", "start": [246, 1], "end": [248, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.mono_iff_mono_right", "code": "theorem mono_iff_mono_right [HasPullbacks A] [PreservesLimitsOfShape WalkingCospan G]\n    {Y Z : StructuredArrow X G} (f : Y \u27f6 Z) : Mono f \u2194 Mono f.right", "start": [251, 1], "end": [253, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.hasColimit", "code": "instance hasColimit [i\u2081 : HasColimit (F \u22d9 proj G X)] [i\u2082 : PreservesColimit (F \u22d9 proj G X) G] :\n    HasColimit F := by\n  haveI : HasColimit (F \u22d9 Comma.fst G (Functor.fromPUnit X)) := i\u2081\n  haveI : PreservesColimit (F \u22d9 Comma.fst G (Functor.fromPUnit X)) _ := i\u2082\n  apply Comma.hasColimit", "start": [262, 1], "end": [266, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.hasColimitsOfShape", "code": "instance hasColimitsOfShape [HasColimitsOfShape J A] [PreservesColimitsOfShape J G] :\n    HasColimitsOfShape J (CostructuredArrow G X) where", "start": [269, 1], "end": [270, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.hasColimitsOfSize", "code": "instance hasColimitsOfSize [HasColimitsOfSize.{w, w'} A] [PreservesColimitsOfSize.{w, w'} G] :\n    HasColimitsOfSize.{w, w'} (CostructuredArrow G X) :=\n  \u27e8fun _ _ => inferInstance\u27e9", "start": [273, 1], "end": [275, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.createsColimit", "code": "noncomputable instance createsColimit [i : PreservesColimit (F \u22d9 proj G X) G] :\n    CreatesColimit F (proj G X) :=\n  letI : PreservesColimit (F \u22d9 Comma.fst G (Functor.fromPUnit X)) G := i\n  createsColimitOfReflectsIso fun _ t =>\n    { liftedCocone := Comma.coconeOfPreserves F t punitCocone\n      makesColimit := Comma.coconeOfPreservesIsColimit _ _ punitCoconeIsColimit\n      validLift := Cocones.ext (Iso.refl _) fun _ => comp_id _ }", "start": [278, 1], "end": [284, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.createsColimitsOfShape", "code": "noncomputable instance createsColimitsOfShape [PreservesColimitsOfShape J G] :\n    CreatesColimitsOfShape J (proj G X) where", "start": [287, 1], "end": [288, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.createsColimitsOfSize", "code": "noncomputable instance createsColimitsOfSize [PreservesColimitsOfSize.{w, w'} G] :\n    CreatesColimitsOfSize.{w, w'} (proj G X : _) where", "start": [291, 1], "end": [292, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.epi_left_of_epi", "code": "instance epi_left_of_epi [HasPushouts A] [PreservesColimitsOfShape WalkingSpan G]\n    {Y Z : CostructuredArrow G X} (f : Y \u27f6 Z) [Epi f] : Epi f.left :=\n  show Epi ((proj G X).map f) from inferInstance", "start": [295, 1], "end": [297, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.epi_iff_epi_left", "code": "theorem epi_iff_epi_left [HasPushouts A] [PreservesColimitsOfShape WalkingSpan G]\n    {Y Z : CostructuredArrow G X} (f : Y \u27f6 Z) : Epi f \u2194 Epi f.left", "start": [300, 1], "end": [302, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Adjunction/Opposites.lean", "imports": ["Mathlib/CategoryTheory/Opposites.lean", "Mathlib/CategoryTheory/Yoneda.lean", "Mathlib/CategoryTheory/Adjunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Adjunction.adjointOfOpAdjointOp", "code": "@[simps! unit_app counit_app]\ndef adjointOfOpAdjointOp (F : C \u2964 D) (G : D \u2964 C) (h : G.op \u22a3 F.op) : F \u22a3 G :=\n  Adjunction.mkOfHomEquiv {\n    homEquiv := fun {X Y} =>\n      ((h.homEquiv (Opposite.op Y) (Opposite.op X)).trans (opEquiv _ _)).symm.trans\n        (opEquiv _ _)\n    homEquiv_naturality_left_symm := by\n      intros X' X Y f g\n      dsimp [opEquiv]\n      erw [homEquiv_unit, homEquiv_unit]\n      simp\n    homEquiv_naturality_right := by\n      intros X Y Y' f g\n      dsimp [opEquiv]\n      erw [homEquiv_counit, homEquiv_counit]\n      simp }", "start": [33, 1], "end": [59, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.adjointUnopOfAdjointOp", "code": "def adjointUnopOfAdjointOp (F : C \u2964 D) (G : D\u1d52\u1d56 \u2964 C\u1d52\u1d56) (h : G \u22a3 F.op) : F \u22a3 G.unop :=\n  adjointOfOpAdjointOp F G.unop (h.ofNatIsoLeft G.opUnopIso.symm)", "start": [62, 1], "end": [64, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.unopAdjointOfOpAdjoint", "code": "def unopAdjointOfOpAdjoint (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) (G : D \u2964 C) (h : G.op \u22a3 F) : F.unop \u22a3 G :=\n  adjointOfOpAdjointOp _ _ (h.ofNatIsoRight F.opUnopIso.symm)", "start": [67, 1], "end": [69, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.unopAdjointUnopOfAdjoint", "code": "def unopAdjointUnopOfAdjoint (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) (G : D\u1d52\u1d56 \u2964 C\u1d52\u1d56) (h : G \u22a3 F) : F.unop \u22a3 G.unop :=\n  adjointUnopOfAdjointOp F.unop G (h.ofNatIsoRight F.opUnopIso.symm)", "start": [72, 1], "end": [74, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.opAdjointOpOfAdjoint", "code": "@[simps! unit_app counit_app]\ndef opAdjointOpOfAdjoint (F : C \u2964 D) (G : D \u2964 C) (h : G \u22a3 F) : F.op \u22a3 G.op :=\n  Adjunction.mkOfHomEquiv {\n    homEquiv := fun X Y =>\n      (opEquiv _ Y).trans ((h.homEquiv _ _).symm.trans (opEquiv X (Opposite.op _)).symm)\n    homEquiv_naturality_left_symm := by\n      intros X' X Y f g\n      dsimp [opEquiv]\n      erw [homEquiv_unit, homEquiv_unit]\n      simp\n    homEquiv_naturality_right := by\n      intros X' X Y f g\n      dsimp [opEquiv]\n      erw [homEquiv_counit, homEquiv_counit]\n      simp }", "start": [77, 1], "end": [102, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.adjointOpOfAdjointUnop", "code": "def adjointOpOfAdjointUnop (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) (G : D \u2964 C) (h : G \u22a3 F.unop) : F \u22a3 G.op :=\n  (opAdjointOpOfAdjoint F.unop _ h).ofNatIsoLeft F.opUnopIso", "start": [105, 1], "end": [107, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.opAdjointOfUnopAdjoint", "code": "def opAdjointOfUnopAdjoint (F : C \u2964 D) (G : D\u1d52\u1d56 \u2964 C\u1d52\u1d56) (h : G.unop \u22a3 F) : F.op \u22a3 G :=\n  (opAdjointOpOfAdjoint _ G.unop h).ofNatIsoRight G.opUnopIso", "start": [110, 1], "end": [112, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.adjointOfUnopAdjointUnop", "code": "def adjointOfUnopAdjointUnop (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) (G : D\u1d52\u1d56 \u2964 C\u1d52\u1d56) (h : G.unop \u22a3 F.unop) : F \u22a3 G :=\n  (adjointOpOfAdjointUnop _ _ h).ofNatIsoRight G.opUnopIso", "start": [115, 1], "end": [117, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.leftAdjointsCoyonedaEquiv", "code": "def leftAdjointsCoyonedaEquiv {F F' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G) :\n    F.op \u22d9 coyoneda \u2245 F'.op \u22d9 coyoneda :=\n  NatIso.ofComponents fun X =>\n    NatIso.ofComponents fun Y =>\n      ((adj1.homEquiv X.unop Y).trans (adj2.homEquiv X.unop Y).symm).toIso", "start": [120, 1], "end": [128, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.leftAdjointUniq", "code": "def leftAdjointUniq {F F' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G) : F \u2245 F' :=\n  NatIso.removeOp (fullyFaithfulCancelRight _ (leftAdjointsCoyonedaEquiv adj2 adj1))", "start": [131, 1], "end": [133, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.homEquiv_leftAdjointUniq_hom_app", "code": "theorem homEquiv_leftAdjointUniq_hom_app {F F' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G)\n    (x : C) : adj1.homEquiv _ _ ((leftAdjointUniq adj1 adj2).hom.app x) = adj2.unit.app x", "start": [137, 1], "end": [146, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.unit_leftAdjointUniq_hom", "code": "@[reassoc (attr := simp)]\ntheorem unit_leftAdjointUniq_hom {F F' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G) :\n    adj1.unit \u226b whiskerRight (leftAdjointUniq adj1 adj2).hom G = adj2.unit", "start": [149, 1], "end": [154, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.unit_leftAdjointUniq_hom_app", "code": "@[reassoc (attr := simp)]\ntheorem unit_leftAdjointUniq_hom_app {F F' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G)\n    (x : C) : adj1.unit.app x \u226b G.map ((leftAdjointUniq adj1 adj2).hom.app x) = adj2.unit.app x", "start": [157, 1], "end": [160, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.leftAdjointUniq_hom_counit", "code": "@[reassoc (attr := simp)]\ntheorem leftAdjointUniq_hom_counit {F F' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G) :\n    whiskerLeft G (leftAdjointUniq adj1 adj2).hom \u226b adj2.counit = adj1.counit", "start": [163, 1], "end": [171, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.leftAdjointUniq_hom_app_counit", "code": "@[reassoc (attr := simp)]\ntheorem leftAdjointUniq_hom_app_counit {F F' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G)\n    (x : D) :\n    (leftAdjointUniq adj1 adj2).hom.app (G.obj x) \u226b adj2.counit.app x = adj1.counit.app x", "start": [174, 1], "end": [179, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.leftAdjointUniq_inv_app", "code": "@[simp]\ntheorem leftAdjointUniq_inv_app {F F' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G) (x : C) :\n    (leftAdjointUniq adj1 adj2).inv.app x = (leftAdjointUniq adj2 adj1).hom.app x", "start": [182, 1], "end": [185, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.leftAdjointUniq_trans", "code": "@[reassoc (attr := simp)]\ntheorem leftAdjointUniq_trans {F F' F'' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G)\n    (adj3 : F'' \u22a3 G) :\n    (leftAdjointUniq adj1 adj2).hom \u226b (leftAdjointUniq adj2 adj3).hom =\n      (leftAdjointUniq adj1 adj3).hom", "start": [188, 1], "end": [198, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.leftAdjointUniq_trans_app", "code": "@[reassoc (attr := simp)]\ntheorem leftAdjointUniq_trans_app {F F' F'' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G)\n    (adj3 : F'' \u22a3 G) (x : C) :\n    (leftAdjointUniq adj1 adj2).hom.app x \u226b (leftAdjointUniq adj2 adj3).hom.app x =\n      (leftAdjointUniq adj1 adj3).hom.app x", "start": [201, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.leftAdjointUniq_refl", "code": "@[simp]\ntheorem leftAdjointUniq_refl {F : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) :\n    (leftAdjointUniq adj1 adj1).hom = \ud835\udfd9 _", "start": [210, 1], "end": [218, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.rightAdjointUniq", "code": "def rightAdjointUniq {F : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F \u22a3 G') : G \u2245 G' :=\n  NatIso.removeOp (leftAdjointUniq (opAdjointOpOfAdjoint _ F adj2) (opAdjointOpOfAdjoint _ _ adj1))", "start": [221, 1], "end": [223, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.homEquiv_symm_rightAdjointUniq_hom_app", "code": "theorem homEquiv_symm_rightAdjointUniq_hom_app {F : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G)\n    (adj2 : F \u22a3 G') (x : D) :\n    (adj2.homEquiv _ _).symm ((rightAdjointUniq adj1 adj2).hom.app x) = adj1.counit.app x", "start": [227, 1], "end": [240, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.unit_rightAdjointUniq_hom_app", "code": "@[reassoc (attr := simp)]\ntheorem unit_rightAdjointUniq_hom_app {F : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F \u22a3 G')\n    (x : C) : adj1.unit.app x \u226b (rightAdjointUniq adj1 adj2).hom.app (F.obj x) =\n      adj2.unit.app x", "start": [243, 1], "end": [259, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.unit_rightAdjointUniq_hom", "code": "@[reassoc (attr := simp)]\ntheorem unit_rightAdjointUniq_hom {F : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F \u22a3 G') :\n    adj1.unit \u226b whiskerLeft F (rightAdjointUniq adj1 adj2).hom = adj2.unit", "start": [262, 1], "end": [266, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.rightAdjointUniq_hom_app_counit", "code": "@[reassoc (attr := simp)]\ntheorem rightAdjointUniq_hom_app_counit {F : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F \u22a3 G')\n    (x : D) :\n    F.map ((rightAdjointUniq adj1 adj2).hom.app x) \u226b adj2.counit.app x = adj1.counit.app x", "start": [269, 1], "end": [285, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.rightAdjointUniq_hom_counit", "code": "@[reassoc (attr := simp)]\ntheorem rightAdjointUniq_hom_counit {F : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F \u22a3 G') :\n    whiskerRight (rightAdjointUniq adj1 adj2).hom F \u226b adj2.counit = adj1.counit", "start": [288, 1], "end": [292, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.rightAdjointUniq_inv_app", "code": "@[simp]\ntheorem rightAdjointUniq_inv_app {F : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F \u22a3 G')\n    (x : D) : (rightAdjointUniq adj1 adj2).inv.app x = (rightAdjointUniq adj2 adj1).hom.app x", "start": [295, 1], "end": [298, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.rightAdjointUniq_trans_app", "code": "@[reassoc (attr := simp)]\ntheorem rightAdjointUniq_trans_app {F : C \u2964 D} {G G' G'' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F \u22a3 G')\n    (adj3 : F \u22a3 G'') (x : D) :\n    (rightAdjointUniq adj1 adj2).hom.app x \u226b (rightAdjointUniq adj2 adj3).hom.app x =\n      (rightAdjointUniq adj1 adj3).hom.app x", "start": [301, 1], "end": [308, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.rightAdjointUniq_trans", "code": "@[reassoc (attr := simp)]\ntheorem rightAdjointUniq_trans {F : C \u2964 D} {G G' G'' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F \u22a3 G')\n    (adj3 : F \u22a3 G'') :\n    (rightAdjointUniq adj1 adj2).hom \u226b (rightAdjointUniq adj2 adj3).hom =\n      (rightAdjointUniq adj1 adj3).hom", "start": [311, 1], "end": [317, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.rightAdjointUniq_refl", "code": "@[simp]\ntheorem rightAdjointUniq_refl {F : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) :\n    (rightAdjointUniq adj1 adj1).hom = \ud835\udfd9 _", "start": [320, 1], "end": [324, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.natIsoOfLeftAdjointNatIso", "code": "def natIsoOfLeftAdjointNatIso {F F' : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G')\n    (l : F \u2245 F') : G \u2245 G' :=\n  rightAdjointUniq adj1 (adj2.ofNatIsoLeft l.symm)", "start": [327, 1], "end": [332, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.natIsoOfRightAdjointNatIso", "code": "def natIsoOfRightAdjointNatIso {F F' : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G')\n    (r : G \u2245 G') : F \u2245 F' :=\n  leftAdjointUniq adj1 (adj2.ofNatIsoRight r.symm)", "start": [335, 1], "end": [340, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Sets/Compacts.lean", "imports": ["Mathlib/Topology/Sets/Closeds.lean", "Mathlib/Topology/QuasiSeparated.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopologicalSpace.Compacts", "code": "structure Compacts (\u03b1 : Type*) [TopologicalSpace \u03b1] where\n  carrier : Set \u03b1\n  isCompact' : IsCompact carrier", "start": [35, 1], "end": [38, 33], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.Simps.coe", "code": "def Simps.coe (s : Compacts \u03b1) : Set \u03b1 := s", "start": [47, 1], "end": [48, 44], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.isCompact", "code": "protected theorem isCompact (s : Compacts \u03b1) : IsCompact (s : Set \u03b1)", "start": [52, 1], "end": [53, 15], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.ext", "code": "@[ext]\nprotected theorem ext {s t : Compacts \u03b1} (h : (s : Set \u03b1) = t) : s = t", "start": [61, 1], "end": [63, 17], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.coe_mk", "code": "@[simp]\ntheorem coe_mk (s : Set \u03b1) (h) : (mk s h : Set \u03b1) = s", "start": [66, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.carrier_eq_coe", "code": "@[simp]\ntheorem carrier_eq_coe (s : Compacts \u03b1) : s.carrier = s", "start": [71, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.coe_sup", "code": "@[simp]\ntheorem coe_sup (s t : Compacts \u03b1) : (\u2191(s \u2294 t) : Set \u03b1) = \u2191s \u222a \u2191t", "start": [103, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.coe_inf", "code": "@[simp]\ntheorem coe_inf [T2Space \u03b1] (s t : Compacts \u03b1) : (\u2191(s \u2293 t) : Set \u03b1) = \u2191s \u2229 \u2191t", "start": [108, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.coe_top", "code": "@[simp]\ntheorem coe_top [CompactSpace \u03b1] : (\u2191(\u22a4 : Compacts \u03b1) : Set \u03b1) = univ", "start": [113, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.coe_bot", "code": "@[simp]\ntheorem coe_bot : (\u2191(\u22a5 : Compacts \u03b1) : Set \u03b1) = \u2205", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.coe_finset_sup", "code": "@[simp]\ntheorem coe_finset_sup {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 Compacts \u03b1} :\n    (\u2191(s.sup f) : Set \u03b1) = s.sup fun i => \u2191(f i)", "start": [123, 1], "end": [128, 8], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.map", "code": "protected def map (f : \u03b1 \u2192 \u03b2) (hf : Continuous f) (K : Compacts \u03b1) : Compacts \u03b2 :=\n  \u27e8f '' K.1, K.2.image hf\u27e9", "start": [131, 1], "end": [133, 27], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.coe_map", "code": "@[simp, norm_cast]\ntheorem coe_map {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) (s : Compacts \u03b1) : (s.map f hf : Set \u03b2) = f '' s", "start": [136, 1], "end": [138, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.map_id", "code": "@[simp]\ntheorem map_id (K : Compacts \u03b1) : K.map id continuous_id = K", "start": [141, 1], "end": [143, 33], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.map_comp", "code": "theorem map_comp (f : \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b2) (hf : Continuous f) (hg : Continuous g) (K : Compacts \u03b1) :\n    K.map (f \u2218 g) (hf.comp hg) = (K.map g hg).map f hf", "start": [146, 1], "end": [148, 39], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.equiv", "code": "@[simps]\nprotected def equiv (f : \u03b1 \u2243\u209c \u03b2) : Compacts \u03b1 \u2243 Compacts \u03b2 where\n  toFun := Compacts.map f f.continuous\n  invFun := Compacts.map _ f.symm.continuous\n  left_inv s := by\n    ext1\n    simp only [coe_map, \u2190 image_comp, f.symm_comp_self, image_id]\n  right_inv s := by\n    ext1\n    simp only [coe_map, \u2190 image_comp, f.self_comp_symm, image_id]", "start": [151, 1], "end": [161, 66], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.equiv_refl", "code": "@[simp]\ntheorem equiv_refl : Compacts.equiv (Homeomorph.refl \u03b1) = Equiv.refl _", "start": [164, 1], "end": [166, 19], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.equiv_trans", "code": "@[simp]\ntheorem equiv_trans (f : \u03b1 \u2243\u209c \u03b2) (g : \u03b2 \u2243\u209c \u03b3) :\n    Compacts.equiv (f.trans g) = (Compacts.equiv f).trans (Compacts.equiv g)", "start": [169, 1], "end": [173, 54], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.equiv_symm", "code": "@[simp]\ntheorem equiv_symm (f : \u03b1 \u2243\u209c \u03b2) : Compacts.equiv f.symm = (Compacts.equiv f).symm", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.coe_equiv_apply_eq_preimage", "code": "theorem coe_equiv_apply_eq_preimage (f : \u03b1 \u2243\u209c \u03b2) (K : Compacts \u03b1) :\n    (Compacts.equiv f K : Set \u03b2) = f.symm \u207b\u00b9' (K : Set \u03b1)", "start": [181, 1], "end": [184, 32], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.prod", "code": "protected def prod (K : Compacts \u03b1) (L : Compacts \u03b2) : Compacts (\u03b1 \u00d7 \u03b2) where\n  carrier := K \u00d7\u02e2 L\n  isCompact' := IsCompact.prod K.2 L.2", "start": [187, 1], "end": [191, 39], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Compacts.coe_prod", "code": "@[simp]\ntheorem coe_prod (K : Compacts \u03b1) (L : Compacts \u03b2) :\n    (K.prod L : Set (\u03b1 \u00d7 \u03b2)) = (K : Set \u03b1) \u00d7\u02e2 (L : Set \u03b2)", "start": [194, 1], "end": [197, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts", "code": "structure NonemptyCompacts (\u03b1 : Type*) [TopologicalSpace \u03b1] extends Compacts \u03b1 where\n  nonempty' : carrier.Nonempty", "start": [206, 1], "end": [208, 31], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.Simps.coe", "code": "def Simps.coe (s : NonemptyCompacts \u03b1) : Set \u03b1 := s", "start": [220, 1], "end": [221, 52], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.isCompact", "code": "protected theorem isCompact (s : NonemptyCompacts \u03b1) : IsCompact (s : Set \u03b1)", "start": [225, 1], "end": [226, 15], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.nonempty", "code": "protected theorem nonempty (s : NonemptyCompacts \u03b1) : (s : Set \u03b1).Nonempty", "start": [229, 1], "end": [230, 14], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.toCloseds", "code": "def toCloseds [T2Space \u03b1] (s : NonemptyCompacts \u03b1) : Closeds \u03b1 :=\n  \u27e8s, s.isCompact.isClosed\u27e9", "start": [233, 1], "end": [235, 28], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.ext", "code": "@[ext]\nprotected theorem ext {s t : NonemptyCompacts \u03b1} (h : (s : Set \u03b1) = t) : s = t", "start": [238, 1], "end": [240, 17], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.coe_mk", "code": "@[simp]\ntheorem coe_mk (s : Compacts \u03b1) (h) : (mk s h : Set \u03b1) = s", "start": [243, 1], "end": [245, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.carrier_eq_coe", "code": "theorem carrier_eq_coe (s : NonemptyCompacts \u03b1) : s.carrier = s", "start": [249, 1], "end": [250, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.coe_toCompacts", "code": "@[simp] theorem coe_toCompacts (s : NonemptyCompacts \u03b1) : (s.toCompacts : Set \u03b1) = s", "start": [253, 1], "end": [254, 84], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.coe_sup", "code": "@[simp]\ntheorem coe_sup (s t : NonemptyCompacts \u03b1) : (\u2191(s \u2294 t) : Set \u03b1) = \u2191s \u222a \u2191t", "start": [268, 1], "end": [270, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.coe_top", "code": "@[simp]\ntheorem coe_top [CompactSpace \u03b1] [Nonempty \u03b1] : (\u2191(\u22a4 : NonemptyCompacts \u03b1) : Set \u03b1) = univ", "start": [273, 1], "end": [275, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.toCompactSpace", "code": "instance toCompactSpace {s : NonemptyCompacts \u03b1} : CompactSpace s :=\n  isCompact_iff_compactSpace.1 s.isCompact", "start": [285, 1], "end": [286, 43], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.toNonempty", "code": "instance toNonempty {s : NonemptyCompacts \u03b1} : Nonempty s :=\n  s.nonempty.to_subtype", "start": [289, 1], "end": [290, 24], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.prod", "code": "protected def prod (K : NonemptyCompacts \u03b1) (L : NonemptyCompacts \u03b2) : NonemptyCompacts (\u03b1 \u00d7 \u03b2) :=\n  { K.toCompacts.prod L.toCompacts with nonempty' := K.nonempty.prod L.nonempty }", "start": [293, 1], "end": [296, 82], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.coe_prod", "code": "@[simp]\ntheorem coe_prod (K : NonemptyCompacts \u03b1) (L : NonemptyCompacts \u03b2) :\n    (K.prod L : Set (\u03b1 \u00d7 \u03b2)) = (K : Set \u03b1) \u00d7\u02e2 (L : Set \u03b2)", "start": [299, 1], "end": [302, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts", "code": "structure PositiveCompacts (\u03b1 : Type*) [TopologicalSpace \u03b1] extends Compacts \u03b1 where\n  interior_nonempty' : (interior carrier).Nonempty", "start": [309, 1], "end": [312, 51], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.Simps.coe", "code": "def Simps.coe (s : PositiveCompacts \u03b1) : Set \u03b1 := s", "start": [324, 1], "end": [325, 52], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.isCompact", "code": "protected theorem isCompact (s : PositiveCompacts \u03b1) : IsCompact (s : Set \u03b1)", "start": [329, 1], "end": [330, 15], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.interior_nonempty", "code": "theorem interior_nonempty (s : PositiveCompacts \u03b1) : (interior (s : Set \u03b1)).Nonempty", "start": [333, 1], "end": [334, 23], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.nonempty", "code": "protected theorem nonempty (s : PositiveCompacts \u03b1) : (s : Set \u03b1).Nonempty", "start": [337, 1], "end": [338, 43], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.toNonemptyCompacts", "code": "def toNonemptyCompacts (s : PositiveCompacts \u03b1) : NonemptyCompacts \u03b1 :=\n  \u27e8s.toCompacts, s.nonempty\u27e9", "start": [341, 1], "end": [343, 29], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.ext", "code": "@[ext]\nprotected theorem ext {s t : PositiveCompacts \u03b1} (h : (s : Set \u03b1) = t) : s = t", "start": [346, 1], "end": [348, 17], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.coe_mk", "code": "@[simp]\ntheorem coe_mk (s : Compacts \u03b1) (h) : (mk s h : Set \u03b1) = s", "start": [351, 1], "end": [353, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.carrier_eq_coe", "code": "theorem carrier_eq_coe (s : PositiveCompacts \u03b1) : s.carrier = s", "start": [357, 1], "end": [358, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.coe_toCompacts", "code": "@[simp]\ntheorem coe_toCompacts (s : PositiveCompacts \u03b1) : (s.toCompacts : Set \u03b1) = s", "start": [361, 1], "end": [363, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.coe_sup", "code": "@[simp]\ntheorem coe_sup (s t : PositiveCompacts \u03b1) : (\u2191(s \u2294 t) : Set \u03b1) = \u2191s \u222a \u2191t", "start": [379, 1], "end": [381, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.coe_top", "code": "@[simp]\ntheorem coe_top [CompactSpace \u03b1] [Nonempty \u03b1] : (\u2191(\u22a4 : PositiveCompacts \u03b1) : Set \u03b1) = univ", "start": [384, 1], "end": [386, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.map", "code": "protected def map (f : \u03b1 \u2192 \u03b2) (hf : Continuous f) (hf' : IsOpenMap f) (K : PositiveCompacts \u03b1) :\n    PositiveCompacts \u03b2 :=\n  { Compacts.map f hf K.toCompacts with\n    interior_nonempty' :=\n      (K.interior_nonempty'.image _).mono (hf'.image_interior_subset K.toCompacts) }", "start": [389, 1], "end": [394, 85], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.coe_map", "code": "@[simp, norm_cast]\ntheorem coe_map {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) (hf' : IsOpenMap f) (s : PositiveCompacts \u03b1) :\n    (s.map f hf hf' : Set \u03b2) = f '' s", "start": [397, 1], "end": [400, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.map_id", "code": "@[simp]\ntheorem map_id (K : PositiveCompacts \u03b1) : K.map id continuous_id IsOpenMap.id = K", "start": [403, 1], "end": [405, 41], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.map_comp", "code": "theorem map_comp (f : \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b2) (hf : Continuous f) (hg : Continuous g) (hf' : IsOpenMap f)\n    (hg' : IsOpenMap g) (K : PositiveCompacts \u03b1) :\n    K.map (f \u2218 g) (hf.comp hg) (hf'.comp hg') = (K.map g hg hg').map f hf hf'", "start": [408, 1], "end": [411, 47], "kind": "commanddeclaration"}, {"full_name": "exists_positiveCompacts_subset", "code": "theorem _root_.exists_positiveCompacts_subset [LocallyCompactSpace \u03b1] {U : Set \u03b1} (ho : IsOpen U)\n    (hn : U.Nonempty) : \u2203 K : PositiveCompacts \u03b1, \u2191K \u2286 U", "start": [414, 1], "end": [418, 30], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.nonempty'", "code": "instance nonempty' [WeaklyLocallyCompactSpace \u03b1] [Nonempty \u03b1] : Nonempty (PositiveCompacts \u03b1) := by\n  inhabit \u03b1\n  rcases exists_compact_mem_nhds (default : \u03b1) with \u27e8K, hKc, hK\u27e9\n  exact \u27e8\u27e8K, hKc\u27e9, _, mem_interior_iff_mem_nhds.2 hK\u27e9", "start": [424, 1], "end": [428, 54], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.prod", "code": "protected def prod (K : PositiveCompacts \u03b1) (L : PositiveCompacts \u03b2) :\n    PositiveCompacts (\u03b1 \u00d7 \u03b2) where\n  toCompacts := K.toCompacts.prod L.toCompacts\n  interior_nonempty' := by\n    simp only [Compacts.carrier_eq_coe, Compacts.coe_prod, interior_prod_eq]\n    exact K.interior_nonempty.prod L.interior_nonempty", "start": [431, 1], "end": [438, 55], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.PositiveCompacts.coe_prod", "code": "@[simp]\ntheorem coe_prod (K : PositiveCompacts \u03b1) (L : PositiveCompacts \u03b2) :\n    (K.prod L : Set (\u03b1 \u00d7 \u03b2)) = (K : Set \u03b1) \u00d7\u02e2 (L : Set \u03b2)", "start": [441, 1], "end": [444, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens", "code": "structure CompactOpens (\u03b1 : Type*) [TopologicalSpace \u03b1] extends Compacts \u03b1 where\n  isOpen' : IsOpen carrier", "start": [451, 1], "end": [454, 27], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.Simps.coe", "code": "def Simps.coe (s : CompactOpens \u03b1) : Set \u03b1 := s", "start": [466, 1], "end": [467, 48], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.isCompact", "code": "protected theorem isCompact (s : CompactOpens \u03b1) : IsCompact (s : Set \u03b1)", "start": [471, 1], "end": [472, 15], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.isOpen", "code": "protected theorem isOpen (s : CompactOpens \u03b1) : IsOpen (s : Set \u03b1)", "start": [475, 1], "end": [476, 12], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.toOpens", "code": "@[simps]\ndef toOpens (s : CompactOpens \u03b1) : Opens \u03b1 := \u27e8s, s.isOpen\u27e9", "start": [479, 1], "end": [481, 60], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.toClopens", "code": "@[simps]\ndef toClopens [T2Space \u03b1] (s : CompactOpens \u03b1) : Clopens \u03b1 :=\n  \u27e8s, s.isOpen, s.isCompact.isClosed\u27e9", "start": [484, 1], "end": [487, 38], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.ext", "code": "@[ext]\nprotected theorem ext {s t : CompactOpens \u03b1} (h : (s : Set \u03b1) = t) : s = t", "start": [490, 1], "end": [492, 17], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.coe_mk", "code": "@[simp]\ntheorem coe_mk (s : Compacts \u03b1) (h) : (mk s h : Set \u03b1) = s", "start": [495, 1], "end": [497, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.coe_sup", "code": "@[simp]\ntheorem coe_sup (s t : CompactOpens \u03b1) : (\u2191(s \u2294 t) : Set \u03b1) = \u2191s \u222a \u2191t", "start": [541, 1], "end": [543, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.coe_inf", "code": "@[simp]\ntheorem coe_inf [T2Space \u03b1] (s t : CompactOpens \u03b1) : (\u2191(s \u2293 t) : Set \u03b1) = \u2191s \u2229 \u2191t", "start": [546, 1], "end": [548, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.coe_top", "code": "@[simp]\ntheorem coe_top [CompactSpace \u03b1] : (\u2191(\u22a4 : CompactOpens \u03b1) : Set \u03b1) = univ", "start": [551, 1], "end": [553, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.coe_bot", "code": "@[simp]\ntheorem coe_bot : (\u2191(\u22a5 : CompactOpens \u03b1) : Set \u03b1) = \u2205", "start": [556, 1], "end": [558, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.coe_sdiff", "code": "@[simp]\ntheorem coe_sdiff [T2Space \u03b1] (s t : CompactOpens \u03b1) : (\u2191(s \\ t) : Set \u03b1) = \u2191s \\ \u2191t", "start": [561, 1], "end": [563, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.coe_compl", "code": "@[simp]\ntheorem coe_compl [T2Space \u03b1] [CompactSpace \u03b1] (s : CompactOpens \u03b1) : (\u2191s\u1d9c : Set \u03b1) = (\u2191s)\u1d9c", "start": [566, 1], "end": [568, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.map", "code": "@[simps toCompacts]\ndef map (f : \u03b1 \u2192 \u03b2) (hf : Continuous f) (hf' : IsOpenMap f) (s : CompactOpens \u03b1) : CompactOpens \u03b2 :=\n  \u27e8s.toCompacts.map f hf, hf' _ s.isOpen\u27e9", "start": [574, 1], "end": [577, 42], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.coe_map", "code": "@[simp, norm_cast]\ntheorem coe_map {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) (hf' : IsOpenMap f) (s : CompactOpens \u03b1) :\n    (s.map f hf hf' : Set \u03b2) = f '' s", "start": [580, 1], "end": [583, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.map_id", "code": "@[simp]\ntheorem map_id (K : CompactOpens \u03b1) : K.map id continuous_id IsOpenMap.id = K", "start": [586, 1], "end": [588, 37], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.map_comp", "code": "theorem map_comp (f : \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b2) (hf : Continuous f) (hg : Continuous g) (hf' : IsOpenMap f)\n    (hg' : IsOpenMap g) (K : CompactOpens \u03b1) :\n    K.map (f \u2218 g) (hf.comp hg) (hf'.comp hg') = (K.map g hg hg').map f hf hf'", "start": [591, 1], "end": [594, 43], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.prod", "code": "protected def prod (K : CompactOpens \u03b1) (L : CompactOpens \u03b2) : CompactOpens (\u03b1 \u00d7 \u03b2) :=\n  { K.toCompacts.prod L.toCompacts with isOpen' := K.isOpen.prod L.isOpen }", "start": [597, 1], "end": [600, 76], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.CompactOpens.coe_prod", "code": "@[simp]\ntheorem coe_prod (K : CompactOpens \u03b1) (L : CompactOpens \u03b2) :\n    (K.prod L : Set (\u03b1 \u00d7 \u03b2)) = (K : Set \u03b1) \u00d7\u02e2 (L : Set \u03b2)", "start": [603, 1], "end": [606, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/EssSup.lean", "imports": ["Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "Mathlib/Order/Filter/ENNReal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "essSup", "code": "def essSup {_ : MeasurableSpace \u03b1} (f : \u03b1 \u2192 \u03b2) (\u03bc : Measure \u03b1) :=\n  \u03bc.ae.limsup f", "start": [42, 1], "end": [45, 16], "kind": "commanddeclaration"}, {"full_name": "essInf", "code": "def essInf {_ : MeasurableSpace \u03b1} (f : \u03b1 \u2192 \u03b2) (\u03bc : Measure \u03b1) :=\n  \u03bc.ae.liminf f", "start": [48, 1], "end": [51, 16], "kind": "commanddeclaration"}, {"full_name": "essSup_congr_ae", "code": "theorem essSup_congr_ae {f g : \u03b1 \u2192 \u03b2} (hfg : f =\u1d50[\u03bc] g) : essSup f \u03bc = essSup g \u03bc", "start": [54, 1], "end": [55, 19], "kind": "commanddeclaration"}, {"full_name": "essInf_congr_ae", "code": "theorem essInf_congr_ae {f g : \u03b1 \u2192 \u03b2} (hfg : f =\u1d50[\u03bc] g) : essInf f \u03bc = essInf g \u03bc", "start": [58, 1], "end": [59, 39], "kind": "commanddeclaration"}, {"full_name": "essSup_const'", "code": "@[simp]\ntheorem essSup_const' [NeZero \u03bc] (c : \u03b2) : essSup (fun _ : \u03b1 => c) \u03bc = c", "start": [62, 1], "end": [64, 17], "kind": "commanddeclaration"}, {"full_name": "essInf_const'", "code": "@[simp]\ntheorem essInf_const' [NeZero \u03bc] (c : \u03b2) : essInf (fun _ : \u03b1 => c) \u03bc = c", "start": [67, 1], "end": [69, 17], "kind": "commanddeclaration"}, {"full_name": "essSup_const", "code": "theorem essSup_const (c : \u03b2) (h\u03bc : \u03bc \u2260 0) : essSup (fun _ : \u03b1 => c) \u03bc = c", "start": [72, 1], "end": [73, 40], "kind": "commanddeclaration"}, {"full_name": "essInf_const", "code": "theorem essInf_const (c : \u03b2) (h\u03bc : \u03bc \u2260 0) : essInf (fun _ : \u03b1 => c) \u03bc = c", "start": [76, 1], "end": [77, 40], "kind": "commanddeclaration"}, {"full_name": "essSup_eq_sInf", "code": "theorem essSup_eq_sInf {m : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    essSup f \u03bc = sInf { a | \u03bc { x | a < f x } = 0 }", "start": [86, 1], "end": [89, 45], "kind": "commanddeclaration"}, {"full_name": "essInf_eq_sSup", "code": "theorem essInf_eq_sSup {m : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    essInf f \u03bc = sSup { a | \u03bc { x | f x < a } = 0 }", "start": [92, 1], "end": [95, 45], "kind": "commanddeclaration"}, {"full_name": "ae_lt_of_essSup_lt", "code": "theorem ae_lt_of_essSup_lt (hx : essSup f \u03bc < x)\n    (hf : IsBoundedUnder (\u00b7 \u2264 \u00b7) \u03bc.ae f := by isBoundedDefault) :\n    \u2200\u1d50 y \u2202\u03bc, f y < x", "start": [98, 1], "end": [101, 35], "kind": "commanddeclaration"}, {"full_name": "ae_lt_of_lt_essInf", "code": "theorem ae_lt_of_lt_essInf (hx : x < essInf f \u03bc)\n    (hf : IsBoundedUnder (\u00b7 \u2265 \u00b7) \u03bc.ae f := by isBoundedDefault) :\n    \u2200\u1d50 y \u2202\u03bc, x < f y", "start": [104, 1], "end": [107, 35], "kind": "commanddeclaration"}, {"full_name": "ae_le_essSup", "code": "theorem ae_le_essSup\n    (hf : IsBoundedUnder (\u00b7 \u2264 \u00b7) \u03bc.ae f := by isBoundedDefault) :\n    \u2200\u1d50 y \u2202\u03bc, f y \u2264 essSup f \u03bc", "start": [112, 1], "end": [115, 26], "kind": "commanddeclaration"}, {"full_name": "ae_essInf_le", "code": "theorem ae_essInf_le\n    (hf : IsBoundedUnder (\u00b7 \u2265 \u00b7) \u03bc.ae f := by isBoundedDefault) :\n    \u2200\u1d50 y \u2202\u03bc, essInf f \u03bc \u2264 f y", "start": [118, 1], "end": [121, 26], "kind": "commanddeclaration"}, {"full_name": "meas_essSup_lt", "code": "theorem meas_essSup_lt\n    (hf : IsBoundedUnder (\u00b7 \u2264 \u00b7) \u03bc.ae f := by isBoundedDefault) :\n    \u03bc { y | essSup f \u03bc < f y } = 0", "start": [124, 1], "end": [128, 24], "kind": "commanddeclaration"}, {"full_name": "meas_lt_essInf", "code": "theorem meas_lt_essInf\n    (hf : IsBoundedUnder (\u00b7 \u2265 \u00b7) \u03bc.ae f := by isBoundedDefault) :\n    \u03bc { y | f y < essInf f \u03bc } = 0", "start": [131, 1], "end": [135, 24], "kind": "commanddeclaration"}, {"full_name": "essSup_measure_zero", "code": "@[simp]\ntheorem essSup_measure_zero {m : MeasurableSpace \u03b1} {f : \u03b1 \u2192 \u03b2} : essSup f (0 : Measure \u03b1) = \u22a5", "start": [144, 1], "end": [146, 77], "kind": "commanddeclaration"}, {"full_name": "essInf_measure_zero", "code": "@[simp]\ntheorem essInf_measure_zero {_ : MeasurableSpace \u03b1} {f : \u03b1 \u2192 \u03b2} : essInf f (0 : Measure \u03b1) = \u22a4", "start": [149, 1], "end": [151, 35], "kind": "commanddeclaration"}, {"full_name": "essSup_mono_ae", "code": "theorem essSup_mono_ae {f g : \u03b1 \u2192 \u03b2} (hfg : f \u2264\u1d50[\u03bc] g) : essSup f \u03bc \u2264 essSup g \u03bc", "start": [154, 1], "end": [155, 23], "kind": "commanddeclaration"}, {"full_name": "essInf_mono_ae", "code": "theorem essInf_mono_ae {f g : \u03b1 \u2192 \u03b2} (hfg : f \u2264\u1d50[\u03bc] g) : essInf f \u03bc \u2264 essInf g \u03bc", "start": [158, 1], "end": [159, 23], "kind": "commanddeclaration"}, {"full_name": "essSup_le_of_ae_le", "code": "theorem essSup_le_of_ae_le {f : \u03b1 \u2192 \u03b2} (c : \u03b2) (hf : f \u2264\u1d50[\u03bc] fun _ => c) : essSup f \u03bc \u2264 c", "start": [162, 1], "end": [166, 23], "kind": "commanddeclaration"}, {"full_name": "le_essInf_of_ae_le", "code": "theorem le_essInf_of_ae_le {f : \u03b1 \u2192 \u03b2} (c : \u03b2) (hf : (fun _ => c) \u2264\u1d50[\u03bc] f) : c \u2264 essInf f \u03bc", "start": [169, 1], "end": [170, 41], "kind": "commanddeclaration"}, {"full_name": "essSup_const_bot", "code": "theorem essSup_const_bot : essSup (fun _ : \u03b1 => (\u22a5 : \u03b2)) \u03bc = (\u22a5 : \u03b2)", "start": [173, 1], "end": [174, 19], "kind": "commanddeclaration"}, {"full_name": "essInf_const_top", "code": "theorem essInf_const_top : essInf (fun _ : \u03b1 => (\u22a4 : \u03b2)) \u03bc = (\u22a4 : \u03b2)", "start": [177, 1], "end": [178, 19], "kind": "commanddeclaration"}, {"full_name": "OrderIso.essSup_apply", "code": "theorem OrderIso.essSup_apply {m : MeasurableSpace \u03b1} {\u03b3} [CompleteLattice \u03b3] (f : \u03b1 \u2192 \u03b2)\n    (\u03bc : Measure \u03b1) (g : \u03b2 \u2243o \u03b3) : g (essSup f \u03bc) = essSup (fun x => g (f x)) \u03bc", "start": [181, 1], "end": [184, 29], "kind": "commanddeclaration"}, {"full_name": "OrderIso.essInf_apply", "code": "theorem OrderIso.essInf_apply {_ : MeasurableSpace \u03b1} {\u03b3} [CompleteLattice \u03b3] (f : \u03b1 \u2192 \u03b2)\n    (\u03bc : Measure \u03b1) (g : \u03b2 \u2243o \u03b3) : g (essInf f \u03bc) = essInf (fun x => g (f x)) \u03bc", "start": [187, 1], "end": [189, 52], "kind": "commanddeclaration"}, {"full_name": "essSup_mono_measure", "code": "theorem essSup_mono_measure {f : \u03b1 \u2192 \u03b2} (h\u03bc\u03bd : \u03bd \u226a \u03bc) : essSup f \u03bd \u2264 essSup f \u03bc", "start": [192, 1], "end": [194, 29], "kind": "commanddeclaration"}, {"full_name": "essSup_mono_measure'", "code": "theorem essSup_mono_measure' {\u03b1 : Type*} {\u03b2 : Type*} {_ : MeasurableSpace \u03b1}\n    {\u03bc \u03bd : MeasureTheory.Measure \u03b1} [CompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2} (h\u03bc\u03bd : \u03bd \u2264 \u03bc) :\n    essSup f \u03bd \u2264 essSup f \u03bc", "start": [197, 1], "end": [200, 63], "kind": "commanddeclaration"}, {"full_name": "essInf_antitone_measure", "code": "theorem essInf_antitone_measure {f : \u03b1 \u2192 \u03b2} (h\u03bc\u03bd : \u03bc \u226a \u03bd) : essInf f \u03bd \u2264 essInf f \u03bc", "start": [203, 1], "end": [205, 29], "kind": "commanddeclaration"}, {"full_name": "essSup_smul_measure", "code": "theorem essSup_smul_measure {f : \u03b1 \u2192 \u03b2} {c : \u211d\u22650\u221e} (hc : c \u2260 0) :\n    essSup f (c \u2022 \u03bc) = essSup f \u03bc", "start": [208, 1], "end": [214, 12], "kind": "commanddeclaration"}, {"full_name": "essSup_comp_le_essSup_map_measure", "code": "theorem essSup_comp_le_essSup_map_measure (hf : AEMeasurable f \u03bc) :\n    essSup (g \u2218 f) \u03bc \u2264 essSup g (Measure.map f \u03bc)", "start": [221, 1], "end": [229, 43], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.essSup_map_measure", "code": "theorem MeasurableEmbedding.essSup_map_measure (hf : MeasurableEmbedding f) :\n    essSup g (Measure.map f \u03bc) = essSup (g \u2218 f) \u03bc", "start": [232, 1], "end": [237, 31], "kind": "commanddeclaration"}, {"full_name": "essSup_map_measure_of_measurable", "code": "theorem essSup_map_measure_of_measurable (hg : Measurable g) (hf : AEMeasurable f \u03bc) :\n    essSup g (Measure.map f \u03bc) = essSup (g \u2218 f) \u03bc", "start": [243, 1], "end": [249, 13], "kind": "commanddeclaration"}, {"full_name": "essSup_map_measure", "code": "theorem essSup_map_measure (hg : AEMeasurable g (Measure.map f \u03bc)) (hf : AEMeasurable f \u03bc) :\n    essSup g (Measure.map f \u03bc) = essSup (g \u2218 f) \u03bc", "start": [252, 1], "end": [258, 18], "kind": "commanddeclaration"}, {"full_name": "essSup_indicator_eq_essSup_restrict", "code": "theorem essSup_indicator_eq_essSup_restrict [Zero \u03b2] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}\n    (hf : 0 \u2264\u1d50[\u03bc.restrict s] f) (hs : MeasurableSet s) (hs_not_null : \u03bc s \u2260 0) :\n    essSup (s.indicator f) \u03bc = essSup f (\u03bc.restrict s)", "start": [268, 1], "end": [295, 25], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ae_le_essSup", "code": "theorem ae_le_essSup (f : \u03b1 \u2192 \u211d\u22650\u221e) : \u2200\u1d50 y \u2202\u03bc, f y \u2264 essSup f \u03bc", "start": [304, 1], "end": [305, 25], "kind": "commanddeclaration"}, {"full_name": "ENNReal.essSup_eq_zero_iff", "code": "@[simp]\ntheorem essSup_eq_zero_iff : essSup f \u03bc = 0 \u2194 f =\u1d50[\u03bc] 0", "start": [308, 1], "end": [310, 21], "kind": "commanddeclaration"}, {"full_name": "ENNReal.essSup_const_mul", "code": "theorem essSup_const_mul {a : \u211d\u22650\u221e} : essSup (fun x : \u03b1 => a * f x) \u03bc = a * essSup f \u03bc", "start": [313, 1], "end": [314, 19], "kind": "commanddeclaration"}, {"full_name": "ENNReal.essSup_mul_le", "code": "theorem essSup_mul_le (f g : \u03b1 \u2192 \u211d\u22650\u221e) : essSup (f * g) \u03bc \u2264 essSup f \u03bc * essSup g \u03bc", "start": [317, 1], "end": [318, 20], "kind": "commanddeclaration"}, {"full_name": "ENNReal.essSup_add_le", "code": "theorem essSup_add_le (f g : \u03b1 \u2192 \u211d\u22650\u221e) : essSup (f + g) \u03bc \u2264 essSup f \u03bc + essSup g \u03bc", "start": [321, 1], "end": [322, 20], "kind": "commanddeclaration"}, {"full_name": "ENNReal.essSup_liminf_le", "code": "theorem essSup_liminf_le {\u03b9} [Countable \u03b9] [LinearOrder \u03b9] (f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e) :\n    essSup (fun x => atTop.liminf fun n => f n x) \u03bc \u2264\n      atTop.liminf fun n => essSup (fun x => f n x) \u03bc", "start": [325, 1], "end": [329, 64], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_essSup", "code": "theorem coe_essSup {f : \u03b1 \u2192 \u211d\u22650} (hf : IsBoundedUnder (\u00b7 \u2264 \u00b7) \u03bc.ae f) :\n    ((essSup f \u03bc : \u211d\u22650) : \u211d\u22650\u221e) = essSup (fun x => (f x : \u211d\u22650\u221e)) \u03bc", "start": [332, 1], "end": [336, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/AEEqFun.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "Mathlib/Topology/ContinuousFunction/Algebra.lean", "Mathlib/Order/Filter/Germ.lean", "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean"], "premises": [{"full_name": "MeasureTheory.Measure.aeEqSetoid", "code": "def Measure.aeEqSetoid (\u03bc : Measure \u03b1) : Setoid { f : \u03b1 \u2192 \u03b2 // AEStronglyMeasurable f \u03bc } :=\n  \u27e8fun f g => (f : \u03b1 \u2192 \u03b2) =\u1d50[\u03bc] g, fun {f} => ae_eq_refl f.val, fun {_ _} => ae_eq_symm,\n    fun {_ _ _} => ae_eq_trans\u27e9", "start": [91, 1], "end": [95, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun", "code": "def AEEqFun (\u03bc : Measure \u03b1) : Type _ :=\n  Quotient (\u03bc.aeEqSetoid \u03b2)", "start": [100, 1], "end": [104, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.mk", "code": "def mk {\u03b2 : Type*} [TopologicalSpace \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : AEStronglyMeasurable f \u03bc) : \u03b1 \u2192\u2098[\u03bc] \u03b2 :=\n  Quotient.mk'' \u27e8f, hf\u27e9", "start": [119, 1], "end": [122, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.cast", "code": "@[coe]\ndef cast (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) : \u03b1 \u2192 \u03b2 :=\n  AEStronglyMeasurable.mk _ (Quotient.out' f : { f : \u03b1 \u2192 \u03b2 // AEStronglyMeasurable f \u03bc }).2", "start": [125, 1], "end": [129, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instCoeFun", "code": "instance instCoeFun : CoeFun (\u03b1 \u2192\u2098[\u03bc] \u03b2) fun _ => \u03b1 \u2192 \u03b2 := \u27e8cast\u27e9", "start": [131, 1], "end": [132, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.stronglyMeasurable", "code": "protected theorem stronglyMeasurable (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) : StronglyMeasurable f", "start": [135, 1], "end": [136, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.aestronglyMeasurable", "code": "protected theorem aestronglyMeasurable (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) : AEStronglyMeasurable f \u03bc", "start": [139, 1], "end": [140, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.measurable", "code": "protected theorem measurable [PseudoMetrizableSpace \u03b2] [MeasurableSpace \u03b2] [BorelSpace \u03b2]\n    (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) : Measurable f", "start": [143, 1], "end": [145, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.aemeasurable", "code": "protected theorem aemeasurable [PseudoMetrizableSpace \u03b2] [MeasurableSpace \u03b2] [BorelSpace \u03b2]\n    (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) : AEMeasurable f \u03bc", "start": [148, 1], "end": [150, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.quot_mk_eq_mk", "code": "@[simp]\ntheorem quot_mk_eq_mk (f : \u03b1 \u2192 \u03b2) (hf) :\n    (Quot.mk (@Setoid.r _ <| \u03bc.aeEqSetoid \u03b2) \u27e8f, hf\u27e9 : \u03b1 \u2192\u2098[\u03bc] \u03b2) = mk f hf", "start": [153, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.mk_eq_mk", "code": "@[simp]\ntheorem mk_eq_mk {f g : \u03b1 \u2192 \u03b2} {hf hg} : (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b2) = mk g hg \u2194 f =\u1d50[\u03bc] g", "start": [159, 1], "end": [161, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.mk_coeFn", "code": "@[simp]\ntheorem mk_coeFn (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) : mk f f.aestronglyMeasurable = f", "start": [164, 1], "end": [170, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.ext", "code": "@[ext]\ntheorem ext {f g : \u03b1 \u2192\u2098[\u03bc] \u03b2} (h : f =\u1d50[\u03bc] g) : f = g", "start": [173, 1], "end": [175, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.ext_iff", "code": "theorem ext_iff {f g : \u03b1 \u2192\u2098[\u03bc] \u03b2} : f = g \u2194 f =\u1d50[\u03bc] g", "start": [178, 1], "end": [179, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_mk", "code": "theorem coeFn_mk (f : \u03b1 \u2192 \u03b2) (hf) : (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b2) =\u1d50[\u03bc] f", "start": [182, 1], "end": [184, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.induction_on", "code": "@[elab_as_elim]\ntheorem induction_on (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) {p : (\u03b1 \u2192\u2098[\u03bc] \u03b2) \u2192 Prop} (H : \u2200 f hf, p (mk f hf)) : p f", "start": [187, 1], "end": [189, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.induction_on\u2082", "code": "@[elab_as_elim]\ntheorem induction_on\u2082 {\u03b1' \u03b2' : Type*} [MeasurableSpace \u03b1'] [TopologicalSpace \u03b2'] {\u03bc' : Measure \u03b1'}\n    (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) (f' : \u03b1' \u2192\u2098[\u03bc'] \u03b2') {p : (\u03b1 \u2192\u2098[\u03bc] \u03b2) \u2192 (\u03b1' \u2192\u2098[\u03bc'] \u03b2') \u2192 Prop}\n    (H : \u2200 f hf f' hf', p (mk f hf) (mk f' hf')) : p f f'", "start": [192, 1], "end": [196, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.induction_on\u2083", "code": "@[elab_as_elim]\ntheorem induction_on\u2083 {\u03b1' \u03b2' : Type*} [MeasurableSpace \u03b1'] [TopologicalSpace \u03b2'] {\u03bc' : Measure \u03b1'}\n    {\u03b1'' \u03b2'' : Type*} [MeasurableSpace \u03b1''] [TopologicalSpace \u03b2''] {\u03bc'' : Measure \u03b1''}\n    (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) (f' : \u03b1' \u2192\u2098[\u03bc'] \u03b2') (f'' : \u03b1'' \u2192\u2098[\u03bc''] \u03b2'')\n    {p : (\u03b1 \u2192\u2098[\u03bc] \u03b2) \u2192 (\u03b1' \u2192\u2098[\u03bc'] \u03b2') \u2192 (\u03b1'' \u2192\u2098[\u03bc''] \u03b2'') \u2192 Prop}\n    (H : \u2200 f hf f' hf' f'' hf'', p (mk f hf) (mk f' hf') (mk f'' hf'')) : p f f' f''", "start": [199, 1], "end": [205, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.compQuasiMeasurePreserving", "code": "def compQuasiMeasurePreserving (g : \u03b2 \u2192\u2098[\u03bd] \u03b3) (f : \u03b1 \u2192 \u03b2) (hf : QuasiMeasurePreserving f \u03bc \u03bd) :\n    \u03b1 \u2192\u2098[\u03bc] \u03b3 :=\n  Quotient.liftOn' g (fun g \u21a6 mk (g \u2218 f) <| g.2.comp_quasiMeasurePreserving hf) <| fun _ _ h \u21a6\n    mk_eq_mk.2 <| h.comp_tendsto hf.tendsto_ae", "start": [218, 1], "end": [224, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.compQuasiMeasurePreserving_mk", "code": "@[simp]\ntheorem compQuasiMeasurePreserving_mk {g : \u03b2 \u2192 \u03b3} (hg : AEStronglyMeasurable g \u03bd)\n    (hf : QuasiMeasurePreserving f \u03bc \u03bd) :\n    (mk g hg).compQuasiMeasurePreserving f hf = mk (g \u2218 f) (hg.comp_quasiMeasurePreserving hf)", "start": [226, 1], "end": [230, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.compQuasiMeasurePreserving_eq_mk", "code": "theorem compQuasiMeasurePreserving_eq_mk (g : \u03b2 \u2192\u2098[\u03bd] \u03b3) (hf : QuasiMeasurePreserving f \u03bc \u03bd) :\n    g.compQuasiMeasurePreserving f hf =\n      mk (g \u2218 f) (g.aestronglyMeasurable.comp_quasiMeasurePreserving hf)", "start": [232, 1], "end": [235, 75], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_compQuasiMeasurePreserving", "code": "theorem coeFn_compQuasiMeasurePreserving (g : \u03b2 \u2192\u2098[\u03bd] \u03b3) (hf : QuasiMeasurePreserving f \u03bc \u03bd) :\n    g.compQuasiMeasurePreserving f hf =\u1d50[\u03bc] g \u2218 f", "start": [237, 1], "end": [240, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.compMeasurePreserving", "code": "def compMeasurePreserving (g : \u03b2 \u2192\u2098[\u03bd] \u03b3) (f : \u03b1 \u2192 \u03b2) (hf : MeasurePreserving f \u03bc \u03bd) : \u03b1 \u2192\u2098[\u03bc] \u03b3 :=\n  g.compQuasiMeasurePreserving f hf.quasiMeasurePreserving", "start": [248, 1], "end": [253, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.compMeasurePreserving_mk", "code": "@[simp]\ntheorem compMeasurePreserving_mk {g : \u03b2 \u2192 \u03b3} (hg : AEStronglyMeasurable g \u03bd)\n    (hf : MeasurePreserving f \u03bc \u03bd) :\n    (mk g hg).compMeasurePreserving f hf =\n      mk (g \u2218 f) (hg.comp_quasiMeasurePreserving hf.quasiMeasurePreserving)", "start": [255, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.compMeasurePreserving_eq_mk", "code": "theorem compMeasurePreserving_eq_mk (g : \u03b2 \u2192\u2098[\u03bd] \u03b3) (hf : MeasurePreserving f \u03bc \u03bd) :\n    g.compMeasurePreserving f hf =\n      mk (g \u2218 f) (g.aestronglyMeasurable.comp_quasiMeasurePreserving hf.quasiMeasurePreserving)", "start": [262, 1], "end": [265, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_compMeasurePreserving", "code": "theorem coeFn_compMeasurePreserving (g : \u03b2 \u2192\u2098[\u03bd] \u03b3) (hf : MeasurePreserving f \u03bc \u03bd) :\n    g.compMeasurePreserving f hf =\u1d50[\u03bc] g \u2218 f", "start": [267, 1], "end": [269, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.comp", "code": "def comp (g : \u03b2 \u2192 \u03b3) (hg : Continuous g) (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) : \u03b1 \u2192\u2098[\u03bc] \u03b3 :=\n  Quotient.liftOn' f (fun f => mk (g \u2218 (f : \u03b1 \u2192 \u03b2)) (hg.comp_aestronglyMeasurable f.2))\n    fun _ _ H => mk_eq_mk.2 <| H.fun_comp g", "start": [273, 1], "end": [278, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.comp_mk", "code": "@[simp]\ntheorem comp_mk (g : \u03b2 \u2192 \u03b3) (hg : Continuous g) (f : \u03b1 \u2192 \u03b2) (hf) :\n    comp g hg (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b2) = mk (g \u2218 f) (hg.comp_aestronglyMeasurable hf)", "start": [281, 1], "end": [284, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.comp_eq_mk", "code": "theorem comp_eq_mk (g : \u03b2 \u2192 \u03b3) (hg : Continuous g) (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) :\n    comp g hg f = mk (g \u2218 f) (hg.comp_aestronglyMeasurable f.aestronglyMeasurable)", "start": [287, 1], "end": [289, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_comp", "code": "theorem coeFn_comp (g : \u03b2 \u2192 \u03b3) (hg : Continuous g) (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) : comp g hg f =\u1d50[\u03bc] g \u2218 f", "start": [292, 1], "end": [294, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.compMeasurable", "code": "def compMeasurable (g : \u03b2 \u2192 \u03b3) (hg : Measurable g) (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) : \u03b1 \u2192\u2098[\u03bc] \u03b3 :=\n  Quotient.liftOn' f\n    (fun f' => mk (g \u2218 (f' : \u03b1 \u2192 \u03b2)) (hg.comp_aemeasurable f'.2.aemeasurable).aestronglyMeasurable)\n    fun _ _ H => mk_eq_mk.2 <| H.fun_comp g", "start": [302, 1], "end": [308, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.compMeasurable_mk", "code": "@[simp]\ntheorem compMeasurable_mk (g : \u03b2 \u2192 \u03b3) (hg : Measurable g) (f : \u03b1 \u2192 \u03b2)\n    (hf : AEStronglyMeasurable f \u03bc) :\n    compMeasurable g hg (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b2) =\n      mk (g \u2218 f) (hg.comp_aemeasurable hf.aemeasurable).aestronglyMeasurable", "start": [311, 1], "end": [316, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.compMeasurable_eq_mk", "code": "theorem compMeasurable_eq_mk (g : \u03b2 \u2192 \u03b3) (hg : Measurable g) (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) :\n    compMeasurable g hg f = mk (g \u2218 f) (hg.comp_aemeasurable f.aemeasurable).aestronglyMeasurable", "start": [319, 1], "end": [321, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_compMeasurable", "code": "theorem coeFn_compMeasurable (g : \u03b2 \u2192 \u03b3) (hg : Measurable g) (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) :\n    compMeasurable g hg f =\u1d50[\u03bc] g \u2218 f", "start": [324, 1], "end": [327, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.pair", "code": "def pair (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) (g : \u03b1 \u2192\u2098[\u03bc] \u03b3) : \u03b1 \u2192\u2098[\u03bc] \u03b2 \u00d7 \u03b3 :=\n  Quotient.liftOn\u2082' f g (fun f g => mk (fun x => (f.1 x, g.1 x)) (f.2.prod_mk g.2))\n    fun _f _g _f' _g' Hf Hg => mk_eq_mk.2 <| Hf.prod_mk Hg", "start": [332, 1], "end": [335, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.pair_mk_mk", "code": "@[simp]\ntheorem pair_mk_mk (f : \u03b1 \u2192 \u03b2) (hf) (g : \u03b1 \u2192 \u03b3) (hg) :\n    (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b2).pair (mk g hg) = mk (fun x => (f x, g x)) (hf.prod_mk hg)", "start": [338, 1], "end": [341, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.pair_eq_mk", "code": "theorem pair_eq_mk (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) (g : \u03b1 \u2192\u2098[\u03bc] \u03b3) :\n    f.pair g =\n      mk (fun x => (f x, g x)) (f.aestronglyMeasurable.prod_mk g.aestronglyMeasurable)", "start": [344, 1], "end": [347, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_pair", "code": "theorem coeFn_pair (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) (g : \u03b1 \u2192\u2098[\u03bc] \u03b3) : f.pair g =\u1d50[\u03bc] fun x => (f x, g x)", "start": [350, 1], "end": [352, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.comp\u2082", "code": "def comp\u2082 (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : Continuous (uncurry g)) (f\u2081 : \u03b1 \u2192\u2098[\u03bc] \u03b2) (f\u2082 : \u03b1 \u2192\u2098[\u03bc] \u03b3) :\n    \u03b1 \u2192\u2098[\u03bc] \u03b4 :=\n  comp _ hg (f\u2081.pair f\u2082)", "start": [355, 1], "end": [361, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.comp\u2082_mk_mk", "code": "@[simp]\ntheorem comp\u2082_mk_mk (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : Continuous (uncurry g)) (f\u2081 : \u03b1 \u2192 \u03b2) (f\u2082 : \u03b1 \u2192 \u03b3)\n    (hf\u2081 hf\u2082) :\n    comp\u2082 g hg (mk f\u2081 hf\u2081 : \u03b1 \u2192\u2098[\u03bc] \u03b2) (mk f\u2082 hf\u2082) =\n      mk (fun a => g (f\u2081 a) (f\u2082 a)) (hg.comp_aestronglyMeasurable (hf\u2081.prod_mk hf\u2082))", "start": [364, 1], "end": [369, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.comp\u2082_eq_pair", "code": "theorem comp\u2082_eq_pair (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : Continuous (uncurry g)) (f\u2081 : \u03b1 \u2192\u2098[\u03bc] \u03b2)\n    (f\u2082 : \u03b1 \u2192\u2098[\u03bc] \u03b3) : comp\u2082 g hg f\u2081 f\u2082 = comp _ hg (f\u2081.pair f\u2082)", "start": [372, 1], "end": [374, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.comp\u2082_eq_mk", "code": "theorem comp\u2082_eq_mk (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : Continuous (uncurry g)) (f\u2081 : \u03b1 \u2192\u2098[\u03bc] \u03b2)\n    (f\u2082 : \u03b1 \u2192\u2098[\u03bc] \u03b3) :\n    comp\u2082 g hg f\u2081 f\u2082 =\n      mk (fun a => g (f\u2081 a) (f\u2082 a))\n        (hg.comp_aestronglyMeasurable (f\u2081.aestronglyMeasurable.prod_mk f\u2082.aestronglyMeasurable))", "start": [377, 1], "end": [382, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_comp\u2082", "code": "theorem coeFn_comp\u2082 (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : Continuous (uncurry g)) (f\u2081 : \u03b1 \u2192\u2098[\u03bc] \u03b2)\n    (f\u2082 : \u03b1 \u2192\u2098[\u03bc] \u03b3) : comp\u2082 g hg f\u2081 f\u2082 =\u1d50[\u03bc] fun a => g (f\u2081 a) (f\u2082 a)", "start": [385, 1], "end": [388, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.comp\u2082Measurable", "code": "def comp\u2082Measurable (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : Measurable (uncurry g)) (f\u2081 : \u03b1 \u2192\u2098[\u03bc] \u03b2)\n    (f\u2082 : \u03b1 \u2192\u2098[\u03bc] \u03b3) : \u03b1 \u2192\u2098[\u03bc] \u03b4 :=\n  compMeasurable _ hg (f\u2081.pair f\u2082)", "start": [397, 1], "end": [403, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.comp\u2082Measurable_mk_mk", "code": "@[simp]\ntheorem comp\u2082Measurable_mk_mk (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : Measurable (uncurry g)) (f\u2081 : \u03b1 \u2192 \u03b2)\n    (f\u2082 : \u03b1 \u2192 \u03b3) (hf\u2081 hf\u2082) :\n    comp\u2082Measurable g hg (mk f\u2081 hf\u2081 : \u03b1 \u2192\u2098[\u03bc] \u03b2) (mk f\u2082 hf\u2082) =\n      mk (fun a => g (f\u2081 a) (f\u2082 a))\n        (hg.comp_aemeasurable (hf\u2081.aemeasurable.prod_mk hf\u2082.aemeasurable)).aestronglyMeasurable", "start": [406, 1], "end": [412, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.comp\u2082Measurable_eq_pair", "code": "theorem comp\u2082Measurable_eq_pair (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : Measurable (uncurry g)) (f\u2081 : \u03b1 \u2192\u2098[\u03bc] \u03b2)\n    (f\u2082 : \u03b1 \u2192\u2098[\u03bc] \u03b3) : comp\u2082Measurable g hg f\u2081 f\u2082 = compMeasurable _ hg (f\u2081.pair f\u2082)", "start": [415, 1], "end": [417, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.comp\u2082Measurable_eq_mk", "code": "theorem comp\u2082Measurable_eq_mk (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : Measurable (uncurry g)) (f\u2081 : \u03b1 \u2192\u2098[\u03bc] \u03b2)\n    (f\u2082 : \u03b1 \u2192\u2098[\u03bc] \u03b3) :\n    comp\u2082Measurable g hg f\u2081 f\u2082 =\n      mk (fun a => g (f\u2081 a) (f\u2082 a))\n        (hg.comp_aemeasurable (f\u2081.aemeasurable.prod_mk f\u2082.aemeasurable)).aestronglyMeasurable", "start": [420, 1], "end": [425, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_comp\u2082Measurable", "code": "theorem coeFn_comp\u2082Measurable (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : Measurable (uncurry g)) (f\u2081 : \u03b1 \u2192\u2098[\u03bc] \u03b2)\n    (f\u2082 : \u03b1 \u2192\u2098[\u03bc] \u03b3) : comp\u2082Measurable g hg f\u2081 f\u2082 =\u1d50[\u03bc] fun a => g (f\u2081 a) (f\u2082 a)", "start": [428, 1], "end": [431, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.toGerm", "code": "def toGerm (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) : Germ \u03bc.ae \u03b2 :=\n  Quotient.liftOn' f (fun f => ((f : \u03b1 \u2192 \u03b2) : Germ \u03bc.ae \u03b2)) fun _ _ H => Germ.coe_eq.2 H", "start": [436, 1], "end": [439, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.mk_toGerm", "code": "@[simp]\ntheorem mk_toGerm (f : \u03b1 \u2192 \u03b2) (hf) : (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b2).toGerm = f", "start": [442, 1], "end": [444, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.toGerm_eq", "code": "theorem toGerm_eq (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) : f.toGerm = (f : \u03b1 \u2192 \u03b2)", "start": [447, 1], "end": [447, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.toGerm_injective", "code": "theorem toGerm_injective : Injective (toGerm : (\u03b1 \u2192\u2098[\u03bc] \u03b2) \u2192 Germ \u03bc.ae \u03b2)", "start": [450, 1], "end": [451, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.comp_toGerm", "code": "theorem comp_toGerm (g : \u03b2 \u2192 \u03b3) (hg : Continuous g) (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) :\n    (comp g hg f).toGerm = f.toGerm.map g", "start": [454, 1], "end": [456, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.compMeasurable_toGerm", "code": "theorem compMeasurable_toGerm [MeasurableSpace \u03b2] [BorelSpace \u03b2] [PseudoMetrizableSpace \u03b2]\n    [PseudoMetrizableSpace \u03b3] [SecondCountableTopology \u03b3] [MeasurableSpace \u03b3]\n    [OpensMeasurableSpace \u03b3] (g : \u03b2 \u2192 \u03b3) (hg : Measurable g) (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) :\n    (compMeasurable g hg f).toGerm = f.toGerm.map g", "start": [459, 1], "end": [463, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.comp\u2082_toGerm", "code": "theorem comp\u2082_toGerm (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : Continuous (uncurry g)) (f\u2081 : \u03b1 \u2192\u2098[\u03bc] \u03b2)\n    (f\u2082 : \u03b1 \u2192\u2098[\u03bc] \u03b3) : (comp\u2082 g hg f\u2081 f\u2082).toGerm = f\u2081.toGerm.map\u2082 g f\u2082.toGerm", "start": [466, 1], "end": [468, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.comp\u2082Measurable_toGerm", "code": "theorem comp\u2082Measurable_toGerm [PseudoMetrizableSpace \u03b2] [MeasurableSpace \u03b2] [BorelSpace \u03b2]\n    [PseudoMetrizableSpace \u03b3] [SecondCountableTopologyEither \u03b2 \u03b3]\n    [MeasurableSpace \u03b3] [BorelSpace \u03b3] [PseudoMetrizableSpace \u03b4] [SecondCountableTopology \u03b4]\n    [MeasurableSpace \u03b4] [OpensMeasurableSpace \u03b4] (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : Measurable (uncurry g))\n    (f\u2081 : \u03b1 \u2192\u2098[\u03bc] \u03b2) (f\u2082 : \u03b1 \u2192\u2098[\u03bc] \u03b3) :\n    (comp\u2082Measurable g hg f\u2081 f\u2082).toGerm = f\u2081.toGerm.map\u2082 g f\u2082.toGerm", "start": [471, 1], "end": [477, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.LiftPred", "code": "def LiftPred (p : \u03b2 \u2192 Prop) (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) : Prop :=\n  f.toGerm.LiftPred p", "start": [480, 1], "end": [483, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.LiftRel", "code": "def LiftRel (r : \u03b2 \u2192 \u03b3 \u2192 Prop) (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) (g : \u03b1 \u2192\u2098[\u03bc] \u03b3) : Prop :=\n  f.toGerm.LiftRel r g.toGerm", "start": [486, 1], "end": [489, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.liftRel_mk_mk", "code": "theorem liftRel_mk_mk {r : \u03b2 \u2192 \u03b3 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} {hf hg} :\n    LiftRel r (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b2) (mk g hg) \u2194 \u2200\u1d50 a \u2202\u03bc, r (f a) (g a)", "start": [492, 1], "end": [494, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.liftRel_iff_coeFn", "code": "theorem liftRel_iff_coeFn {r : \u03b2 \u2192 \u03b3 \u2192 Prop} {f : \u03b1 \u2192\u2098[\u03bc] \u03b2} {g : \u03b1 \u2192\u2098[\u03bc] \u03b3} :\n    LiftRel r f g \u2194 \u2200\u1d50 a \u2202\u03bc, r (f a) (g a)", "start": [497, 1], "end": [498, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instPreorder", "code": "instance instPreorder [Preorder \u03b2] : Preorder (\u03b1 \u2192\u2098[\u03bc] \u03b2) :=\n  Preorder.lift toGerm", "start": [503, 1], "end": [504, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.mk_le_mk", "code": "@[simp]\ntheorem mk_le_mk [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf hg) : (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b2) \u2264 mk g hg \u2194 f \u2264\u1d50[\u03bc] g", "start": [507, 1], "end": [509, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_le", "code": "@[simp, norm_cast]\ntheorem coeFn_le [Preorder \u03b2] {f g : \u03b1 \u2192\u2098[\u03bc] \u03b2} : (f : \u03b1 \u2192 \u03b2) \u2264\u1d50[\u03bc] g \u2194 f \u2264 g", "start": [512, 1], "end": [514, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instPartialOrder", "code": "instance instPartialOrder [PartialOrder \u03b2] : PartialOrder (\u03b1 \u2192\u2098[\u03bc] \u03b2) :=\n  PartialOrder.lift toGerm toGerm_injective", "start": [517, 1], "end": [518, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instSup", "code": "instance instSup : Sup (\u03b1 \u2192\u2098[\u03bc] \u03b2) where sup f g := AEEqFun.comp\u2082 (\u00b7 \u2294 \u00b7) continuous_sup f g", "start": [527, 1], "end": [527, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_sup", "code": "theorem coeFn_sup (f g : \u03b1 \u2192\u2098[\u03bc] \u03b2) : \u21d1(f \u2294 g) =\u1d50[\u03bc] fun x => f x \u2294 g x", "start": [530, 1], "end": [531, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.le_sup_left", "code": "protected theorem le_sup_left (f g : \u03b1 \u2192\u2098[\u03bc] \u03b2) : f \u2264 f \u2294 g", "start": [534, 1], "end": [538, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.le_sup_right", "code": "protected theorem le_sup_right (f g : \u03b1 \u2192\u2098[\u03bc] \u03b2) : g \u2264 f \u2294 g", "start": [541, 1], "end": [545, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.sup_le", "code": "protected theorem sup_le (f g f' : \u03b1 \u2192\u2098[\u03bc] \u03b2) (hf : f \u2264 f') (hg : g \u2264 f') : f \u2294 g \u2264 f'", "start": [548, 1], "end": [552, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instInf", "code": "instance instInf : Inf (\u03b1 \u2192\u2098[\u03bc] \u03b2) where inf f g := AEEqFun.comp\u2082 (\u00b7 \u2293 \u00b7) continuous_inf f g", "start": [561, 1], "end": [561, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_inf", "code": "theorem coeFn_inf (f g : \u03b1 \u2192\u2098[\u03bc] \u03b2) : \u21d1(f \u2293 g) =\u1d50[\u03bc] fun x => f x \u2293 g x", "start": [564, 1], "end": [565, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.inf_le_left", "code": "protected theorem inf_le_left (f g : \u03b1 \u2192\u2098[\u03bc] \u03b2) : f \u2293 g \u2264 f", "start": [568, 1], "end": [572, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.inf_le_right", "code": "protected theorem inf_le_right (f g : \u03b1 \u2192\u2098[\u03bc] \u03b2) : f \u2293 g \u2264 g", "start": [575, 1], "end": [579, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.le_inf", "code": "protected theorem le_inf (f' f g : \u03b1 \u2192\u2098[\u03bc] \u03b2) (hf : f' \u2264 f) (hg : f' \u2264 g) : f' \u2264 f \u2293 g", "start": [582, 1], "end": [586, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instLattice", "code": "instance instLattice [Lattice \u03b2] [TopologicalLattice \u03b2] : Lattice (\u03b1 \u2192\u2098[\u03bc] \u03b2) :=\n  { AEEqFun.instPartialOrder with\n    sup := Sup.sup\n    le_sup_left := AEEqFun.le_sup_left\n    le_sup_right := AEEqFun.le_sup_right\n    sup_le := AEEqFun.sup_le\n    inf := Inf.inf\n    inf_le_left := AEEqFun.inf_le_left\n    inf_le_right := AEEqFun.inf_le_right\n    le_inf := AEEqFun.le_inf }", "start": [591, 1], "end": [600, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.const", "code": "def const (b : \u03b2) : \u03b1 \u2192\u2098[\u03bc] \u03b2 :=\n  mk (fun _ : \u03b1 => b) aestronglyMeasurable_const", "start": [609, 1], "end": [612, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_const", "code": "theorem coeFn_const (b : \u03b2) : (const \u03b1 b : \u03b1 \u2192\u2098[\u03bc] \u03b2) =\u1d50[\u03bc] Function.const \u03b1 b", "start": [615, 1], "end": [616, 15], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instInhabited", "code": "instance instInhabited [Inhabited \u03b2] : Inhabited (\u03b1 \u2192\u2098[\u03bc] \u03b2) :=\n  \u27e8const \u03b1 default\u27e9", "start": [621, 1], "end": [622, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instOne", "code": "@[to_additive]\ninstance instOne [One \u03b2] : One (\u03b1 \u2192\u2098[\u03bc] \u03b2) :=\n  \u27e8const \u03b1 1\u27e9", "start": [625, 1], "end": [627, 14], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.one_def", "code": "@[to_additive]\ntheorem one_def [One \u03b2] : (1 : \u03b1 \u2192\u2098[\u03bc] \u03b2) = mk (fun _ : \u03b1 => 1) aestronglyMeasurable_const", "start": [631, 1], "end": [633, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_one", "code": "@[to_additive]\ntheorem coeFn_one [One \u03b2] : \u21d1(1 : \u03b1 \u2192\u2098[\u03bc] \u03b2) =\u1d50[\u03bc] 1", "start": [637, 1], "end": [639, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.one_toGerm", "code": "@[to_additive (attr := simp)]\ntheorem one_toGerm [One \u03b2] : (1 : \u03b1 \u2192\u2098[\u03bc] \u03b2).toGerm = 1", "start": [643, 1], "end": [645, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instSMul", "code": "instance instSMul : SMul \ud835\udd5c (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  \u27e8fun c f => comp ((\u00b7 \u2022 \u00b7) c) (continuous_id.const_smul c) f\u27e9", "start": [659, 1], "end": [660, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.smul_mk", "code": "@[simp]\ntheorem smul_mk (c : \ud835\udd5c) (f : \u03b1 \u2192 \u03b3) (hf : AEStronglyMeasurable f \u03bc) :\n    c \u2022 (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b3) = mk (c \u2022 f) (hf.const_smul _)", "start": [663, 1], "end": [666, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_smul", "code": "theorem coeFn_smul (c : \ud835\udd5c) (f : \u03b1 \u2192\u2098[\u03bc] \u03b3) : \u21d1(c \u2022 f) =\u1d50[\u03bc] c \u2022 \u21d1f", "start": [669, 1], "end": [670, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.smul_toGerm", "code": "theorem smul_toGerm (c : \ud835\udd5c) (f : \u03b1 \u2192\u2098[\u03bc] \u03b3) : (c \u2022 f).toGerm = c \u2022 f.toGerm", "start": [673, 1], "end": [674, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instSMulCommClass", "code": "instance instSMulCommClass [SMulCommClass \ud835\udd5c \ud835\udd5c' \u03b3] : SMulCommClass \ud835\udd5c \ud835\udd5c' (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  \u27e8fun a b f => induction_on f fun f hf => by simp_rw [smul_mk, smul_comm]\u27e9", "start": [677, 1], "end": [678, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instIsScalarTower", "code": "instance instIsScalarTower [SMul \ud835\udd5c \ud835\udd5c'] [IsScalarTower \ud835\udd5c \ud835\udd5c' \u03b3] : IsScalarTower \ud835\udd5c \ud835\udd5c' (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  \u27e8fun a b f => induction_on f fun f hf => by simp_rw [smul_mk, smul_assoc]\u27e9", "start": [681, 1], "end": [682, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instIsCentralScalar", "code": "instance instIsCentralScalar [SMul \ud835\udd5c\u1d50\u1d52\u1d56 \u03b3] [IsCentralScalar \ud835\udd5c \u03b3] : IsCentralScalar \ud835\udd5c (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  \u27e8fun a f => induction_on f fun f hf => by simp_rw [smul_mk, op_smul_eq_smul]\u27e9", "start": [685, 1], "end": [686, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instMul", "code": "@[to_additive]\ninstance instMul : Mul (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  \u27e8comp\u2082 (\u00b7 * \u00b7) continuous_mul\u27e9", "start": [695, 1], "end": [697, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.mk_mul_mk", "code": "@[to_additive (attr := simp)]\ntheorem mk_mul_mk (f g : \u03b1 \u2192 \u03b3) (hf : AEStronglyMeasurable f \u03bc) (hg : AEStronglyMeasurable g \u03bc) :\n    (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b3) * mk g hg = mk (f * g) (hf.mul hg)", "start": [701, 1], "end": [704, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_mul", "code": "@[to_additive]\ntheorem coeFn_mul (f g : \u03b1 \u2192\u2098[\u03bc] \u03b3) : \u21d1(f * g) =\u1d50[\u03bc] f * g", "start": [708, 1], "end": [710, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.mul_toGerm", "code": "@[to_additive (attr := simp)]\ntheorem mul_toGerm (f g : \u03b1 \u2192\u2098[\u03bc] \u03b3) : (f * g).toGerm = f.toGerm * g.toGerm", "start": [714, 1], "end": [716, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instAddMonoid", "code": "instance instAddMonoid [AddMonoid \u03b3] [ContinuousAdd \u03b3] : AddMonoid (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  toGerm_injective.addMonoid toGerm zero_toGerm add_toGerm fun _ _ => smul_toGerm _ _", "start": [722, 1], "end": [723, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instAddCommMonoid", "code": "instance instAddCommMonoid [AddCommMonoid \u03b3] [ContinuousAdd \u03b3] : AddCommMonoid (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  toGerm_injective.addCommMonoid toGerm zero_toGerm add_toGerm fun _ _ => smul_toGerm _ _", "start": [726, 1], "end": [727, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instPowNat", "code": "instance instPowNat : Pow (\u03b1 \u2192\u2098[\u03bc] \u03b3) \u2115 :=\n  \u27e8fun f n => comp _ (continuous_pow n) f\u27e9", "start": [734, 1], "end": [735, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.mk_pow", "code": "@[simp]\ntheorem mk_pow (f : \u03b1 \u2192 \u03b3) (hf) (n : \u2115) :\n    (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b3) ^ n =\n      mk (f ^ n) ((_root_.continuous_pow n).comp_aestronglyMeasurable hf)", "start": [738, 1], "end": [742, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_pow", "code": "theorem coeFn_pow (f : \u03b1 \u2192\u2098[\u03bc] \u03b3) (n : \u2115) : \u21d1(f ^ n) =\u1d50[\u03bc] (\u21d1f) ^ n", "start": [745, 1], "end": [746, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.pow_toGerm", "code": "@[simp]\ntheorem pow_toGerm (f : \u03b1 \u2192\u2098[\u03bc] \u03b3) (n : \u2115) : (f ^ n).toGerm = f.toGerm ^ n", "start": [749, 1], "end": [751, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instMonoid", "code": "@[to_additive existing]\ninstance instMonoid : Monoid (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  toGerm_injective.monoid toGerm one_toGerm mul_toGerm pow_toGerm", "start": [754, 1], "end": [756, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.toGermMonoidHom", "code": "@[to_additive (attr := simps) \"`AEEqFun.toGerm` as an `AddMonoidHom`.\"]\ndef toGermMonoidHom : (\u03b1 \u2192\u2098[\u03bc] \u03b3) \u2192* \u03bc.ae.Germ \u03b3 where\n  toFun := toGerm\n  map_one' := one_toGerm\n  map_mul' := mul_toGerm", "start": [759, 1], "end": [764, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instCommMonoid", "code": "@[to_additive existing]\ninstance instCommMonoid [CommMonoid \u03b3] [ContinuousMul \u03b3] : CommMonoid (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  toGerm_injective.commMonoid toGerm one_toGerm mul_toGerm pow_toGerm", "start": [772, 1], "end": [774, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instInv", "code": "@[to_additive]\ninstance instInv : Inv (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  \u27e8comp Inv.inv continuous_inv\u27e9", "start": [783, 1], "end": [785, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.inv_mk", "code": "@[to_additive (attr := simp)]\ntheorem inv_mk (f : \u03b1 \u2192 \u03b3) (hf) : (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b3)\u207b\u00b9 = mk f\u207b\u00b9 hf.inv", "start": [789, 1], "end": [791, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_inv", "code": "@[to_additive]\ntheorem coeFn_inv (f : \u03b1 \u2192\u2098[\u03bc] \u03b3) : \u21d1f\u207b\u00b9 =\u1d50[\u03bc] f\u207b\u00b9", "start": [795, 1], "end": [797, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.inv_toGerm", "code": "@[to_additive]\ntheorem inv_toGerm (f : \u03b1 \u2192\u2098[\u03bc] \u03b3) : f\u207b\u00b9.toGerm = f.toGerm\u207b\u00b9", "start": [801, 1], "end": [803, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instDiv", "code": "@[to_additive]\ninstance instDiv : Div (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  \u27e8comp\u2082 Div.div continuous_div'\u27e9", "start": [811, 1], "end": [813, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.mk_div", "code": "@[to_additive (attr := simp, nolint simpNF)] theorem mk_div (f g : \u03b1 \u2192 \u03b3) (hf : AEStronglyMeasurable f \u03bc) (hg : AEStronglyMeasurable g \u03bc) :\n    mk (f / g) (hf.div hg) = (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b3) / mk g hg", "start": [817, 1], "end": [820, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_div", "code": "@[to_additive]\ntheorem coeFn_div (f g : \u03b1 \u2192\u2098[\u03bc] \u03b3) : \u21d1(f / g) =\u1d50[\u03bc] f / g", "start": [824, 1], "end": [826, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.div_toGerm", "code": "@[to_additive]\ntheorem div_toGerm (f g : \u03b1 \u2192\u2098[\u03bc] \u03b3) : (f / g).toGerm = f.toGerm / g.toGerm", "start": [830, 1], "end": [832, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instPowInt", "code": "instance instPowInt : Pow (\u03b1 \u2192\u2098[\u03bc] \u03b3) \u2124 :=\n  \u27e8fun f n => comp _ (continuous_zpow n) f\u27e9", "start": [840, 1], "end": [841, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.mk_zpow", "code": "@[simp]\ntheorem mk_zpow (f : \u03b1 \u2192 \u03b3) (hf) (n : \u2124) :\n    (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b3) ^ n = mk (f ^ n) ((continuous_zpow n).comp_aestronglyMeasurable hf)", "start": [844, 1], "end": [847, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_zpow", "code": "theorem coeFn_zpow (f : \u03b1 \u2192\u2098[\u03bc] \u03b3) (n : \u2124) : \u21d1(f ^ n) =\u1d50[\u03bc] (\u21d1f) ^ n", "start": [850, 1], "end": [851, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.zpow_toGerm", "code": "@[simp]\ntheorem zpow_toGerm (f : \u03b1 \u2192\u2098[\u03bc] \u03b3) (n : \u2124) : (f ^ n).toGerm = f.toGerm ^ n", "start": [854, 1], "end": [856, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instAddGroup", "code": "instance instAddGroup [AddGroup \u03b3] [TopologicalAddGroup \u03b3] : AddGroup (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  toGerm_injective.addGroup toGerm zero_toGerm add_toGerm neg_toGerm sub_toGerm\n    (fun _ _ => smul_toGerm _ _) fun _ _ => smul_toGerm _ _", "start": [863, 1], "end": [865, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instAddCommGroup", "code": "instance instAddCommGroup [AddCommGroup \u03b3] [TopologicalAddGroup \u03b3] : AddCommGroup (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  { add_comm := add_comm }", "start": [868, 1], "end": [869, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instGroup", "code": "@[to_additive existing]\ninstance instGroup [Group \u03b3] [TopologicalGroup \u03b3] : Group (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  toGerm_injective.group _ one_toGerm mul_toGerm inv_toGerm div_toGerm pow_toGerm zpow_toGerm", "start": [872, 1], "end": [874, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instCommGroup", "code": "@[to_additive existing]\ninstance instCommGroup [CommGroup \u03b3] [TopologicalGroup \u03b3] : CommGroup (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  { mul_comm := mul_comm }", "start": [877, 1], "end": [879, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instMulAction", "code": "instance instMulAction [Monoid \ud835\udd5c] [MulAction \ud835\udd5c \u03b3] [ContinuousConstSMul \ud835\udd5c \u03b3] :\n    MulAction \ud835\udd5c (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  toGerm_injective.mulAction toGerm smul_toGerm", "start": [886, 1], "end": [888, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instDistribMulAction", "code": "instance instDistribMulAction [Monoid \ud835\udd5c] [AddMonoid \u03b3] [ContinuousAdd \u03b3] [DistribMulAction \ud835\udd5c \u03b3]\n    [ContinuousConstSMul \ud835\udd5c \u03b3] : DistribMulAction \ud835\udd5c (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  toGerm_injective.distribMulAction (toGermAddMonoidHom : (\u03b1 \u2192\u2098[\u03bc] \u03b3) \u2192+ _) fun c : \ud835\udd5c =>\n    smul_toGerm c", "start": [891, 1], "end": [894, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.instModule", "code": "instance instModule [Semiring \ud835\udd5c] [AddCommMonoid \u03b3] [ContinuousAdd \u03b3] [Module \ud835\udd5c \u03b3]\n    [ContinuousConstSMul \ud835\udd5c \u03b3] : Module \ud835\udd5c (\u03b1 \u2192\u2098[\u03bc] \u03b3) :=\n  toGerm_injective.module \ud835\udd5c (toGermAddMonoidHom : (\u03b1 \u2192\u2098[\u03bc] \u03b3) \u2192+ _) smul_toGerm", "start": [897, 1], "end": [899, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.lintegral", "code": "def lintegral (f : \u03b1 \u2192\u2098[\u03bc] \u211d\u22650\u221e) : \u211d\u22650\u221e :=\n  Quotient.liftOn' f (fun f => \u222b\u207b a, (f : \u03b1 \u2192 \u211d\u22650\u221e) a \u2202\u03bc) fun _ _ => lintegral_congr_ae", "start": [906, 1], "end": [908, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.lintegral_mk", "code": "@[simp]\ntheorem lintegral_mk (f : \u03b1 \u2192 \u211d\u22650\u221e) (hf) : (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u211d\u22650\u221e).lintegral = \u222b\u207b a, f a \u2202\u03bc", "start": [911, 1], "end": [913, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.lintegral_coeFn", "code": "theorem lintegral_coeFn (f : \u03b1 \u2192\u2098[\u03bc] \u211d\u22650\u221e) : \u222b\u207b a, f a \u2202\u03bc = f.lintegral", "start": [916, 1], "end": [917, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.lintegral_zero", "code": "@[simp]\nnonrec theorem lintegral_zero : lintegral (0 : \u03b1 \u2192\u2098[\u03bc] \u211d\u22650\u221e) = 0", "start": [920, 1], "end": [922, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.lintegral_eq_zero_iff", "code": "@[simp]\ntheorem lintegral_eq_zero_iff {f : \u03b1 \u2192\u2098[\u03bc] \u211d\u22650\u221e} : lintegral f = 0 \u2194 f = 0", "start": [925, 1], "end": [927, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.lintegral_add", "code": "theorem lintegral_add (f g : \u03b1 \u2192\u2098[\u03bc] \u211d\u22650\u221e) : lintegral (f + g) = lintegral f + lintegral g", "start": [930, 1], "end": [931, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.lintegral_mono", "code": "theorem lintegral_mono {f g : \u03b1 \u2192\u2098[\u03bc] \u211d\u22650\u221e} : f \u2264 g \u2192 lintegral f \u2264 lintegral g", "start": [934, 1], "end": [935, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_abs", "code": "theorem coeFn_abs {\u03b2} [TopologicalSpace \u03b2] [Lattice \u03b2] [TopologicalLattice \u03b2] [AddGroup \u03b2]\n    [TopologicalAddGroup \u03b2] (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) : \u21d1|f| =\u1d50[\u03bc] fun x => |f x|", "start": [940, 1], "end": [944, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.posPart", "code": "def posPart (f : \u03b1 \u2192\u2098[\u03bc] \u03b3) : \u03b1 \u2192\u2098[\u03bc] \u03b3 :=\n  comp (fun x => max x 0) (continuous_id.max continuous_const) f", "start": [953, 1], "end": [955, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.posPart_mk", "code": "@[simp]\ntheorem posPart_mk (f : \u03b1 \u2192 \u03b3) (hf) :\n    posPart (mk f hf : \u03b1 \u2192\u2098[\u03bc] \u03b3) =\n      mk (fun x => max (f x) 0)\n        ((continuous_id.max continuous_const).comp_aestronglyMeasurable hf)", "start": [958, 1], "end": [963, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.coeFn_posPart", "code": "theorem coeFn_posPart (f : \u03b1 \u2192\u2098[\u03bc] \u03b3) : \u21d1(posPart f) =\u1d50[\u03bc] fun a => max (f a) 0", "start": [966, 1], "end": [967, 19], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.toAEEqFun", "code": "def toAEEqFun (f : C(\u03b1, \u03b2)) : \u03b1 \u2192\u2098[\u03bc] \u03b2 :=\n  AEEqFun.mk f f.continuous.aestronglyMeasurable", "start": [984, 1], "end": [987, 49], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coeFn_toAEEqFun", "code": "theorem coeFn_toAEEqFun (f : C(\u03b1, \u03b2)) : f.toAEEqFun \u03bc =\u1d50[\u03bc] f", "start": [990, 1], "end": [991, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.toAEEqFunMulHom", "code": "@[to_additive \"The `AddHom` from the group of continuous maps from `\u03b1` to `\u03b2` to the group of\nequivalence classes of `\u03bc`-almost-everywhere measurable functions.\"]\ndef toAEEqFunMulHom : C(\u03b1, \u03b2) \u2192* \u03b1 \u2192\u2098[\u03bc] \u03b2 where\n  toFun := ContinuousMap.toAEEqFun \u03bc\n  map_one' := rfl\n  map_mul' f g :=\n    AEEqFun.mk_mul_mk _ _ f.continuous.aestronglyMeasurable g.continuous.aestronglyMeasurable", "start": [996, 1], "end": [1004, 94], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.toAEEqFunLinearMap", "code": "def toAEEqFunLinearMap : C(\u03b1, \u03b3) \u2192\u2097[\ud835\udd5c] \u03b1 \u2192\u2098[\u03bc] \u03b3 :=\n  { toAEEqFunAddHom \u03bc with\n    map_smul' := fun c f => AEEqFun.smul_mk c f f.continuous.aestronglyMeasurable }", "start": [1013, 1], "end": [1017, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "zero_cpow_eq_nhds", "code": "theorem zero_cpow_eq_nhds {b : \u2102} (hb : b \u2260 0) : (fun x : \u2102 => (0 : \u2102) ^ x) =\u1da0[\ud835\udcdd b] 0", "start": [37, 1], "end": [43, 43], "kind": "commanddeclaration"}, {"full_name": "cpow_eq_nhds", "code": "theorem cpow_eq_nhds {a b : \u2102} (ha : a \u2260 0) :\n    (fun x => x ^ b) =\u1da0[\ud835\udcdd a] fun x => exp (log x * b)", "start": [46, 1], "end": [53, 43], "kind": "commanddeclaration"}, {"full_name": "cpow_eq_nhds'", "code": "theorem cpow_eq_nhds' {p : \u2102 \u00d7 \u2102} (hp_fst : p.fst \u2260 0) :\n    (fun x => x.1 ^ x.2) =\u1da0[\ud835\udcdd p] fun x => exp (log x.1 * x.2)", "start": [56, 1], "end": [66, 52], "kind": "commanddeclaration"}, {"full_name": "continuousAt_const_cpow", "code": "theorem continuousAt_const_cpow {a b : \u2102} (ha : a \u2260 0) : ContinuousAt (fun x : \u2102 => a ^ x) b", "start": [70, 1], "end": [75, 95], "kind": "commanddeclaration"}, {"full_name": "continuousAt_const_cpow'", "code": "theorem continuousAt_const_cpow' {a b : \u2102} (h : b \u2260 0) : ContinuousAt (fun x : \u2102 => a ^ x) b", "start": [78, 1], "end": [82, 37], "kind": "commanddeclaration"}, {"full_name": "continuousAt_cpow", "code": "theorem continuousAt_cpow {p : \u2102 \u00d7 \u2102} (hp_fst : 0 < p.fst.re \u2228 p.fst.im \u2260 0) :\n    ContinuousAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2) p", "start": [85, 1], "end": [100, 34], "kind": "commanddeclaration"}, {"full_name": "continuousAt_cpow_const", "code": "theorem continuousAt_cpow_const {a b : \u2102} (ha : 0 < a.re \u2228 a.im \u2260 0) :\n    ContinuousAt (fun x => cpow x b) a", "start": [103, 1], "end": [105, 88], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.cpow", "code": "theorem Filter.Tendsto.cpow {l : Filter \u03b1} {f g : \u03b1 \u2192 \u2102} {a b : \u2102} (hf : Tendsto f l (\ud835\udcdd a))\n    (hg : Tendsto g l (\ud835\udcdd b)) (ha : 0 < a.re \u2228 a.im \u2260 0) :\n    Tendsto (fun x => f x ^ g x) l (\ud835\udcdd (a ^ b))", "start": [108, 1], "end": [111, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.const_cpow", "code": "theorem Filter.Tendsto.const_cpow {l : Filter \u03b1} {f : \u03b1 \u2192 \u2102} {a b : \u2102} (hf : Tendsto f l (\ud835\udcdd b))\n    (h : a \u2260 0 \u2228 b \u2260 0) : Tendsto (fun x => a ^ f x) l (\ud835\udcdd (a ^ b))", "start": [114, 1], "end": [118, 64], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.cpow", "code": "nonrec theorem ContinuousWithinAt.cpow (hf : ContinuousWithinAt f s a)\n    (hg : ContinuousWithinAt g s a) (h0 : 0 < (f a).re \u2228 (f a).im \u2260 0) :\n    ContinuousWithinAt (fun x => f x ^ g x) s a", "start": [123, 1], "end": [126, 16], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.const_cpow", "code": "nonrec theorem ContinuousWithinAt.const_cpow {b : \u2102} (hf : ContinuousWithinAt f s a)\n    (h : b \u2260 0 \u2228 f a \u2260 0) : ContinuousWithinAt (fun x => b ^ f x) s a", "start": [129, 1], "end": [131, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.cpow", "code": "nonrec theorem ContinuousAt.cpow (hf : ContinuousAt f a) (hg : ContinuousAt g a)\n    (h0 : 0 < (f a).re \u2228 (f a).im \u2260 0) : ContinuousAt (fun x => f x ^ g x) a", "start": [134, 1], "end": [136, 16], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.const_cpow", "code": "nonrec theorem ContinuousAt.const_cpow {b : \u2102} (hf : ContinuousAt f a) (h : b \u2260 0 \u2228 f a \u2260 0) :\n    ContinuousAt (fun x => b ^ f x) a", "start": [139, 1], "end": [141, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.cpow", "code": "theorem ContinuousOn.cpow (hf : ContinuousOn f s) (hg : ContinuousOn g s)\n    (h0 : \u2200 a \u2208 s, 0 < (f a).re \u2228 (f a).im \u2260 0) : ContinuousOn (fun x => f x ^ g x) s", "start": [144, 1], "end": [146, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.const_cpow", "code": "theorem ContinuousOn.const_cpow {b : \u2102} (hf : ContinuousOn f s) (h : b \u2260 0 \u2228 \u2200 a \u2208 s, f a \u2260 0) :\n    ContinuousOn (fun x => b ^ f x) s", "start": [149, 1], "end": [150, 101], "kind": "commanddeclaration"}, {"full_name": "Continuous.cpow", "code": "theorem Continuous.cpow (hf : Continuous f) (hg : Continuous g)\n    (h0 : \u2200 a, 0 < (f a).re \u2228 (f a).im \u2260 0) : Continuous fun x => f x ^ g x", "start": [153, 1], "end": [155, 85], "kind": "commanddeclaration"}, {"full_name": "Continuous.const_cpow", "code": "theorem Continuous.const_cpow {b : \u2102} (hf : Continuous f) (h : b \u2260 0 \u2228 \u2200 a, f a \u2260 0) :\n    Continuous fun x => b ^ f x", "start": [158, 1], "end": [160, 93], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.cpow_const", "code": "theorem ContinuousOn.cpow_const {b : \u2102} (hf : ContinuousOn f s)\n    (h : \u2200 a : \u03b1, a \u2208 s \u2192 0 < (f a).re \u2228 (f a).im \u2260 0) : ContinuousOn (fun x => f x ^ b) s", "start": [163, 1], "end": [165, 31], "kind": "commanddeclaration"}, {"full_name": "Real.continuousAt_const_rpow", "code": "theorem continuousAt_const_rpow {a b : \u211d} (h : a \u2260 0) : ContinuousAt (rpow a) b", "start": [179, 1], "end": [186, 12], "kind": "commanddeclaration"}, {"full_name": "Real.continuousAt_const_rpow'", "code": "theorem continuousAt_const_rpow' {a b : \u211d} (h : b \u2260 0) : ContinuousAt (rpow a) b", "start": [189, 1], "end": [196, 12], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_eq_nhds_of_neg", "code": "theorem rpow_eq_nhds_of_neg {p : \u211d \u00d7 \u211d} (hp_fst : p.fst < 0) :\n    (fun x : \u211d \u00d7 \u211d => x.1 ^ x.2) =\u1da0[\ud835\udcdd p] fun x => exp (log x.1 * x.2) * cos (x.2 * \u03c0)", "start": [199, 1], "end": [206, 81], "kind": "commanddeclaration"}, {"full_name": "Real.rpow_eq_nhds_of_pos", "code": "theorem rpow_eq_nhds_of_pos {p : \u211d \u00d7 \u211d} (hp_fst : 0 < p.fst) :\n    (fun x : \u211d \u00d7 \u211d => x.1 ^ x.2) =\u1da0[\ud835\udcdd p] fun x => exp (log x.1 * x.2)", "start": [209, 1], "end": [216, 81], "kind": "commanddeclaration"}, {"full_name": "Real.continuousAt_rpow_of_ne", "code": "theorem continuousAt_rpow_of_ne (p : \u211d \u00d7 \u211d) (hp : p.1 \u2260 0) :\n    ContinuousAt (fun p : \u211d \u00d7 \u211d => p.1 ^ p.2) p", "start": [219, 1], "end": [234, 24], "kind": "commanddeclaration"}, {"full_name": "Real.continuousAt_rpow_of_pos", "code": "theorem continuousAt_rpow_of_pos (p : \u211d \u00d7 \u211d) (hp : 0 < p.2) :\n    ContinuousAt (fun p : \u211d \u00d7 \u211d => p.1 ^ p.2) p", "start": [237, 1], "end": [252, 80], "kind": "commanddeclaration"}, {"full_name": "Real.continuousAt_rpow", "code": "theorem continuousAt_rpow (p : \u211d \u00d7 \u211d) (h : p.1 \u2260 0 \u2228 0 < p.2) :\n    ContinuousAt (fun p : \u211d \u00d7 \u211d => p.1 ^ p.2) p", "start": [255, 1], "end": [257, 86], "kind": "commanddeclaration"}, {"full_name": "Real.continuousAt_rpow_const", "code": "theorem continuousAt_rpow_const (x : \u211d) (q : \u211d) (h : x \u2260 0 \u2228 0 < q) :\n    ContinuousAt (fun x : \u211d => x ^ q) x", "start": [260, 1], "end": [265, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.rpow", "code": "theorem Filter.Tendsto.rpow {l : Filter \u03b1} {f g : \u03b1 \u2192 \u211d} {x y : \u211d} (hf : Tendsto f l (\ud835\udcdd x))\n    (hg : Tendsto g l (\ud835\udcdd y)) (h : x \u2260 0 \u2228 0 < y) : Tendsto (fun t => f t ^ g t) l (\ud835\udcdd (x ^ y))", "start": [274, 1], "end": [276, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.rpow_const", "code": "theorem Filter.Tendsto.rpow_const {l : Filter \u03b1} {f : \u03b1 \u2192 \u211d} {x p : \u211d} (hf : Tendsto f l (\ud835\udcdd x))\n    (h : x \u2260 0 \u2228 0 \u2264 p) : Tendsto (fun a => f a ^ p) l (\ud835\udcdd (x ^ p))", "start": [279, 1], "end": [282, 70], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.rpow", "code": "nonrec theorem ContinuousAt.rpow (hf : ContinuousAt f x) (hg : ContinuousAt g x)\n    (h : f x \u2260 0 \u2228 0 < g x) : ContinuousAt (fun t => f t ^ g t) x", "start": [287, 1], "end": [289, 15], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.rpow", "code": "nonrec theorem ContinuousWithinAt.rpow (hf : ContinuousWithinAt f s x)\n    (hg : ContinuousWithinAt g s x) (h : f x \u2260 0 \u2228 0 < g x) :\n    ContinuousWithinAt (fun t => f t ^ g t) s x", "start": [292, 1], "end": [295, 15], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.rpow", "code": "theorem ContinuousOn.rpow (hf : ContinuousOn f s) (hg : ContinuousOn g s)\n    (h : \u2200 x \u2208 s, f x \u2260 0 \u2228 0 < g x) : ContinuousOn (fun t => f t ^ g t) s", "start": [298, 1], "end": [300, 36], "kind": "commanddeclaration"}, {"full_name": "Continuous.rpow", "code": "theorem Continuous.rpow (hf : Continuous f) (hg : Continuous g) (h : \u2200 x, f x \u2260 0 \u2228 0 < g x) :\n    Continuous fun x => f x ^ g x", "start": [303, 1], "end": [305, 84], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.rpow_const", "code": "nonrec theorem ContinuousWithinAt.rpow_const (hf : ContinuousWithinAt f s x) (h : f x \u2260 0 \u2228 0 \u2264 p) :\n    ContinuousWithinAt (fun x => f x ^ p) s x", "start": [308, 1], "end": [310, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.rpow_const", "code": "nonrec theorem ContinuousAt.rpow_const (hf : ContinuousAt f x) (h : f x \u2260 0 \u2228 0 \u2264 p) :\n    ContinuousAt (fun x => f x ^ p) x", "start": [313, 1], "end": [315, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.rpow_const", "code": "theorem ContinuousOn.rpow_const (hf : ContinuousOn f s) (h : \u2200 x \u2208 s, f x \u2260 0 \u2228 0 \u2264 p) :\n    ContinuousOn (fun x => f x ^ p) s", "start": [318, 1], "end": [319, 83], "kind": "commanddeclaration"}, {"full_name": "Continuous.rpow_const", "code": "theorem Continuous.rpow_const (hf : Continuous f) (h : \u2200 x, f x \u2260 0 \u2228 0 \u2264 p) :\n    Continuous fun x => f x ^ p", "start": [322, 1], "end": [324, 74], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousAt_cpow_zero_of_re_pos", "code": "theorem continuousAt_cpow_zero_of_re_pos {z : \u2102} (hz : 0 < z.re) :\n    ContinuousAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2) (0, z)", "start": [341, 1], "end": [362, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousAt_cpow_of_re_pos", "code": "theorem continuousAt_cpow_of_re_pos {p : \u2102 \u00d7 \u2102} (h\u2081 : 0 \u2264 p.1.re \u2228 p.1.im \u2260 0) (h\u2082 : 0 < p.2.re) :\n    ContinuousAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2) p", "start": [366, 1], "end": [374, 69], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousAt_cpow_const_of_re_pos", "code": "theorem continuousAt_cpow_const_of_re_pos {z w : \u2102} (hz : 0 \u2264 re z \u2228 im z \u2260 0) (hw : 0 < re w) :\n    ContinuousAt (fun x => x ^ w) z", "start": [377, 1], "end": [381, 101], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousAt_ofReal_cpow", "code": "theorem continuousAt_ofReal_cpow (x : \u211d) (y : \u2102) (h : 0 < y.re \u2228 x \u2260 0) :\n    ContinuousAt (fun p => (p.1 : \u2102) ^ p.2 : \u211d \u00d7 \u2102 \u2192 \u2102) (x, y)", "start": [384, 1], "end": [410, 85], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousAt_ofReal_cpow_const", "code": "theorem continuousAt_ofReal_cpow_const (x : \u211d) (y : \u2102) (h : 0 < y.re \u2228 x \u2260 0) :\n    ContinuousAt (fun a => (a : \u2102) ^ y : \u211d \u2192 \u2102) x", "start": [413, 1], "end": [416, 58], "kind": "commanddeclaration"}, {"full_name": "Complex.continuous_ofReal_cpow_const", "code": "theorem continuous_ofReal_cpow_const {y : \u2102} (hs : 0 < y.re) :\n    Continuous (fun x => (x : \u2102) ^ y : \u211d \u2192 \u2102)", "start": [419, 1], "end": [421, 90], "kind": "commanddeclaration"}, {"full_name": "NNReal.continuousAt_rpow", "code": "theorem continuousAt_rpow {x : \u211d\u22650} {y : \u211d} (h : x \u2260 0 \u2228 0 < y) :\n    ContinuousAt (fun p : \u211d\u22650 \u00d7 \u211d => p.1 ^ p.2) (x, y)", "start": [433, 1], "end": [447, 93], "kind": "commanddeclaration"}, {"full_name": "NNReal.eventually_pow_one_div_le", "code": "theorem eventually_pow_one_div_le (x : \u211d\u22650) {y : \u211d\u22650} (hy : 1 < y) :\n    \u2200\u1da0 n : \u2115 in atTop, x ^ (1 / n : \u211d) \u2264 y", "start": [450, 1], "end": [456, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.nnrpow", "code": "theorem Filter.Tendsto.nnrpow {\u03b1 : Type*} {f : Filter \u03b1} {u : \u03b1 \u2192 \u211d\u22650} {v : \u03b1 \u2192 \u211d} {x : \u211d\u22650}\n    {y : \u211d} (hx : Tendsto u f (\ud835\udcdd x)) (hy : Tendsto v f (\ud835\udcdd y)) (h : x \u2260 0 \u2228 0 < y) :\n    Tendsto (fun a => u a ^ v a) f (\ud835\udcdd (x ^ y))", "start": [463, 1], "end": [466, 65], "kind": "commanddeclaration"}, {"full_name": "NNReal.continuousAt_rpow_const", "code": "theorem continuousAt_rpow_const {x : \u211d\u22650} {y : \u211d} (h : x \u2260 0 \u2228 0 \u2264 y) :\n    ContinuousAt (fun z => z ^ y) x", "start": [471, 1], "end": [475, 54], "kind": "commanddeclaration"}, {"full_name": "NNReal.continuous_rpow_const", "code": "theorem continuous_rpow_const {y : \u211d} (h : 0 \u2264 y) : Continuous fun x : \u211d\u22650 => x ^ y", "start": [478, 1], "end": [479, 76], "kind": "commanddeclaration"}, {"full_name": "ENNReal.eventually_pow_one_div_le", "code": "theorem eventually_pow_one_div_le {x : \u211d\u22650\u221e} (hx : x \u2260 \u221e) {y : \u211d\u22650\u221e} (hy : 1 < y) :\n    \u2200\u1da0 n : \u2115 in atTop, x ^ (1 / n : \u211d) \u2264 y", "start": [489, 1], "end": [497, 76], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuousAt_rpow_const_of_pos", "code": "private theorem continuousAt_rpow_const_of_pos {x : \u211d\u22650\u221e} {y : \u211d} (h : 0 < y) :\n    ContinuousAt (fun a : \u211d\u22650\u221e => a ^ y) x", "start": [500, 1], "end": [510, 35], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuous_rpow_const", "code": "@[continuity]\ntheorem continuous_rpow_const {y : \u211d} : Continuous fun a : \u211d\u22650\u221e => a ^ y", "start": [512, 1], "end": [522, 82], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos", "code": "theorem tendsto_const_mul_rpow_nhds_zero_of_pos {c : \u211d\u22650\u221e} (hc : c \u2260 \u221e) {y : \u211d} (hy : 0 < y) :\n    Tendsto (fun x : \u211d\u22650\u221e => c * x ^ y) (\ud835\udcdd 0) (\ud835\udcdd 0)", "start": [525, 1], "end": [529, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.ennrpow_const", "code": "theorem Filter.Tendsto.ennrpow_const {\u03b1 : Type*} {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e} (r : \u211d)\n    (hm : Tendsto m f (\ud835\udcdd a)) : Tendsto (fun x => m x ^ r) f (\ud835\udcdd (a ^ r))", "start": [534, 1], "end": [536, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/IndicatorFunction.lean", "imports": ["Mathlib/Algebra/IndicatorFunction.lean", "Mathlib/Analysis/Normed/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "norm_indicator_eq_indicator_norm", "code": "theorem norm_indicator_eq_indicator_norm : \u2016indicator s f a\u2016 = indicator s (fun a => \u2016f a\u2016) a", "start": [25, 1], "end": [26, 59], "kind": "commanddeclaration"}, {"full_name": "nnnorm_indicator_eq_indicator_nnnorm", "code": "theorem nnnorm_indicator_eq_indicator_nnnorm :\n    \u2016indicator s f a\u2016\u208a = indicator s (fun a => \u2016f a\u2016\u208a) a", "start": [29, 1], "end": [31, 61], "kind": "commanddeclaration"}, {"full_name": "norm_indicator_le_of_subset", "code": "theorem norm_indicator_le_of_subset (h : s \u2286 t) (f : \u03b1 \u2192 E) (a : \u03b1) :\n    \u2016indicator s f a\u2016 \u2264 \u2016indicator t f a\u2016", "start": [34, 1], "end": [37, 72], "kind": "commanddeclaration"}, {"full_name": "indicator_norm_le_norm_self", "code": "theorem indicator_norm_le_norm_self : indicator s (fun a => \u2016f a\u2016) a \u2264 \u2016f a\u2016", "start": [40, 1], "end": [41, 50], "kind": "commanddeclaration"}, {"full_name": "norm_indicator_le_norm_self", "code": "theorem norm_indicator_le_norm_self : \u2016indicator s f a\u2016 \u2264 \u2016f a\u2016", "start": [44, 1], "end": [46, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Integral/MeanInequalities.lean", "imports": ["Mathlib/Analysis/MeanInequalitiesPow.lean", "Mathlib/Analysis/MeanInequalities.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "Mathlib/MeasureTheory/Function/SpecialFunctions/Basic.lean"], "premises": [{"full_name": "ENNReal.lintegral_mul_le_one_of_lintegral_rpow_eq_one", "code": "theorem lintegral_mul_le_one_of_lintegral_rpow_eq_one {p q : \u211d} (hpq : p.IsConjugateExponent q)\n    {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) (hf_norm : \u222b\u207b a, f a ^ p \u2202\u03bc = 1)\n    (hg_norm : \u222b\u207b a, g a ^ q \u2202\u03bc = 1) : (\u222b\u207b a, (f * g) a \u2202\u03bc) \u2264 1", "start": [61, 1], "end": [74, 43], "kind": "commanddeclaration"}, {"full_name": "ENNReal.funMulInvSnorm", "code": "def funMulInvSnorm (f : \u03b1 \u2192 \u211d\u22650\u221e) (p : \u211d) (\u03bc : Measure \u03b1) : \u03b1 \u2192 \u211d\u22650\u221e := fun a =>\n  f a * ((\u222b\u207b c, f c ^ p \u2202\u03bc) ^ (1 / p))\u207b\u00b9", "start": [77, 1], "end": [79, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.fun_eq_funMulInvSnorm_mul_snorm", "code": "theorem fun_eq_funMulInvSnorm_mul_snorm {p : \u211d} (f : \u03b1 \u2192 \u211d\u22650\u221e) (hf_nonzero : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 0)\n    (hf_top : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 \u22a4) {a : \u03b1} :\n    f a = funMulInvSnorm f p \u03bc a * (\u222b\u207b c, f c ^ p \u2202\u03bc) ^ (1 / p)", "start": [82, 1], "end": [85, 79], "kind": "commanddeclaration"}, {"full_name": "ENNReal.funMulInvSnorm_rpow", "code": "theorem funMulInvSnorm_rpow {p : \u211d} (hp0 : 0 < p) {f : \u03b1 \u2192 \u211d\u22650\u221e} {a : \u03b1} :\n    funMulInvSnorm f p \u03bc a ^ p = f a ^ p * (\u222b\u207b c, f c ^ p \u2202\u03bc)\u207b\u00b9", "start": [88, 1], "end": [93, 66], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lintegral_rpow_funMulInvSnorm_eq_one", "code": "theorem lintegral_rpow_funMulInvSnorm_eq_one {p : \u211d} (hp0_lt : 0 < p) {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf_nonzero : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 0) (hf_top : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 \u22a4) :\n    \u222b\u207b c, funMulInvSnorm f p \u03bc c ^ p \u2202\u03bc = 1", "start": [96, 1], "end": [101, 19], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_ne_top", "code": "theorem lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_ne_top {p q : \u211d} (hpq : p.IsConjugateExponent q)\n    {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) (hf_nontop : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 \u22a4)\n    (hg_nontop : (\u222b\u207b a, g a ^ q \u2202\u03bc) \u2260 \u22a4) (hf_nonzero : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 0)\n    (hg_nonzero : (\u222b\u207b a, g a ^ q \u2202\u03bc) \u2260 0) :\n    (\u222b\u207b a, (f * g) a \u2202\u03bc) \u2264 (\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b a, g a ^ q \u2202\u03bc) ^ (1 / q)", "start": [104, 1], "end": [125, 87], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ae_eq_zero_of_lintegral_rpow_eq_zero", "code": "theorem ae_eq_zero_of_lintegral_rpow_eq_zero {p : \u211d} (hp0 : 0 \u2264 p) {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) (hf_zero : \u222b\u207b a, f a ^ p \u2202\u03bc = 0) : f =\u1d50[\u03bc] 0", "start": [128, 1], "end": [134, 70], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero", "code": "theorem lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero {p : \u211d} (hp0 : 0 \u2264 p) {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) (hf_zero : \u222b\u207b a, f a ^ p \u2202\u03bc = 0) : (\u222b\u207b a, (f * g) a \u2202\u03bc) = 0", "start": [137, 1], "end": [144, 38], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top", "code": "theorem lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top {p q : \u211d} (hp0_lt : 0 < p) (hq0 : 0 \u2264 q)\n    {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf_top : \u222b\u207b a, f a ^ p \u2202\u03bc = \u22a4) (hg_nonzero : (\u222b\u207b a, g a ^ q \u2202\u03bc) \u2260 0) :\n    (\u222b\u207b a, (f * g) a \u2202\u03bc) \u2264 (\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b a, g a ^ q \u2202\u03bc) ^ (1 / q)", "start": [147, 1], "end": [153, 25], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lintegral_mul_le_Lp_mul_Lq", "code": "theorem lintegral_mul_le_Lp_mul_Lq (\u03bc : Measure \u03b1) {p q : \u211d} (hpq : p.IsConjugateExponent q)\n    {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    (\u222b\u207b a, (f * g) a \u2202\u03bc) \u2264 (\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b a, g a ^ q \u2202\u03bc) ^ (1 / q)", "start": [156, 1], "end": [175, 101], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lintegral_rpow_add_lt_top_of_lintegral_rpow_lt_top", "code": "theorem lintegral_rpow_add_lt_top_of_lintegral_rpow_lt_top {p : \u211d} {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) (hf_top : (\u222b\u207b a, f a ^ p \u2202\u03bc) < \u22a4) (hg_top : (\u222b\u207b a, g a ^ p \u2202\u03bc) < \u22a4)\n    (hp1 : 1 \u2264 p) : (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) < \u22a4", "start": [178, 1], "end": [213, 43], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lintegral_Lp_mul_le_Lq_mul_Lr", "code": "theorem lintegral_Lp_mul_le_Lq_mul_Lr {\u03b1} [MeasurableSpace \u03b1] {p q r : \u211d} (hp0_lt : 0 < p)\n    (hpq : p < q) (hpqr : 1 / p = 1 / q + 1 / r) (\u03bc : Measure \u03b1) {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    (\u222b\u207b a, (f * g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264\n      (\u222b\u207b a, f a ^ q \u2202\u03bc) ^ (1 / q) * (\u222b\u207b a, g a ^ r \u2202\u03bc) ^ (1 / r)", "start": [216, 1], "end": [251, 80], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow", "code": "theorem lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow {p q : \u211d}\n    (hpq : p.IsConjugateExponent q) {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc)\n    (hf_top : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 \u22a4) :\n    (\u222b\u207b a, f a * g a ^ (p - 1) \u2202\u03bc) \u2264\n      (\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b a, g a ^ p \u2202\u03bc) ^ (1 / q)", "start": [254, 1], "end": [271, 48], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lintegral_rpow_add_le_add_snorm_mul_lintegral_rpow_add", "code": "theorem lintegral_rpow_add_le_add_snorm_mul_lintegral_rpow_add {p q : \u211d}\n    (hpq : p.IsConjugateExponent q) {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc)\n    (hf_top : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 \u22a4) (hg : AEMeasurable g \u03bc) (hg_top : (\u222b\u207b a, g a ^ p \u2202\u03bc) \u2260 \u22a4) :\n    (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) \u2264\n      ((\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) + (\u222b\u207b a, g a ^ p \u2202\u03bc) ^ (1 / p)) *\n        (\u222b\u207b a, (f a + g a) ^ p \u2202\u03bc) ^ (1 / q)", "start": [274, 1], "end": [309, 94], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lintegral_Lp_add_le_aux", "code": "private theorem lintegral_Lp_add_le_aux {p q : \u211d} (hpq : p.IsConjugateExponent q) {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) (hf_top : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 \u22a4) (hg : AEMeasurable g \u03bc)\n    (hg_top : (\u222b\u207b a, g a ^ p \u2202\u03bc) \u2260 \u22a4) (h_add_zero : (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) \u2260 0)\n    (h_add_top : (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) \u2260 \u22a4) :\n    (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264\n      (\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) + (\u222b\u207b a, g a ^ p \u2202\u03bc) ^ (1 / p)", "start": [312, 1], "end": [342, 82], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lintegral_Lp_add_le", "code": "theorem lintegral_Lp_add_le {p : \u211d} {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc)\n    (hp1 : 1 \u2264 p) :\n    (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264\n      (\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) + (\u222b\u207b a, g a ^ p \u2202\u03bc) ^ (1 / p)", "start": [344, 1], "end": [371, 64], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lintegral_Lp_add_le_of_le_one", "code": "theorem lintegral_Lp_add_le_of_le_one {p : \u211d} {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) (hp0 : 0 \u2264 p)\n    (hp1 : p \u2264 1) :\n    (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264\n      (2 : \u211d\u22650\u221e) ^ (1 / p - 1) * ((\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) + (\u222b\u207b a, g a ^ p \u2202\u03bc) ^ (1 / p))", "start": [374, 1], "end": [391, 64], "kind": "commanddeclaration"}, {"full_name": "NNReal.lintegral_mul_le_Lp_mul_Lq", "code": "theorem NNReal.lintegral_mul_le_Lp_mul_Lq {p q : \u211d} (hpq : p.IsConjugateExponent q) {f g : \u03b1 \u2192 \u211d\u22650}\n    (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    (\u222b\u207b a, (f * g) a \u2202\u03bc) \u2264\n      (\u222b\u207b a, (f a : \u211d\u22650\u221e) ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b a, (g a : \u211d\u22650\u221e) ^ q \u2202\u03bc) ^ (1 / q)", "start": [396, 1], "end": [404, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/TangentCone.lean", "imports": ["Mathlib/Analysis/Convex/Topology.lean", "Mathlib/Analysis/NormedSpace/Basic.lean", "Mathlib/Analysis/SpecificLimits/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "tangentConeAt", "code": "def tangentConeAt (s : Set E) (x : E) : Set E :=\n  { y : E | \u2203 (c : \u2115 \u2192 \ud835\udd5c) (d : \u2115 \u2192 E),\n    (\u2200\u1da0 n in atTop, x + d n \u2208 s) \u2227\n    Tendsto (fun n => \u2016c n\u2016) atTop atTop \u2227\n    Tendsto (fun n => c n \u2022 d n) atTop (\ud835\udcdd y) }", "start": [46, 1], "end": [51, 47], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffWithinAt", "code": "@[mk_iff uniqueDiffWithinAt_iff]\nstructure UniqueDiffWithinAt (s : Set E) (x : E) : Prop where\n  dense_tangentCone : Dense (Submodule.span \ud835\udd5c (tangentConeAt \ud835\udd5c s x) : Set E)\n  mem_closure : x \u2208 closure s", "start": [54, 1], "end": [62, 30], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffOn", "code": "def UniqueDiffOn (s : Set E) : Prop :=\n  \u2200 x \u2208 s, UniqueDiffWithinAt \ud835\udd5c s x", "start": [65, 1], "end": [70, 36], "kind": "commanddeclaration"}, {"full_name": "mem_tangentConeAt_of_pow_smul", "code": "theorem mem_tangentConeAt_of_pow_smul {r : \ud835\udd5c} (hr\u2080 : r \u2260 0) (hr : \u2016r\u2016 < 1)\n    (hs : \u2200\u1da0 n : \u2115 in atTop, x + r ^ n \u2022 y \u2208 s) : y \u2208 tangentConeAt \ud835\udd5c s x", "start": [88, 1], "end": [93, 71], "kind": "commanddeclaration"}, {"full_name": "tangentCone_univ", "code": "theorem tangentCone_univ : tangentConeAt \ud835\udd5c univ x = univ", "start": [95, 1], "end": [98, 44], "kind": "commanddeclaration"}, {"full_name": "tangentCone_mono", "code": "theorem tangentCone_mono (h : s \u2286 t) : tangentConeAt \ud835\udd5c s x \u2286 tangentConeAt \ud835\udd5c t x", "start": [101, 1], "end": [103, 64], "kind": "commanddeclaration"}, {"full_name": "tangentConeAt.lim_zero", "code": "theorem tangentConeAt.lim_zero {\u03b1 : Type*} (l : Filter \u03b1) {c : \u03b1 \u2192 \ud835\udd5c} {d : \u03b1 \u2192 E}\n    (hc : Tendsto (fun n => \u2016c n\u2016) l atTop) (hd : Tendsto (fun n => c n \u2022 d n) l (\ud835\udcdd y)) :\n    Tendsto d l (\ud835\udcdd 0)", "start": [106, 1], "end": [121, 10], "kind": "commanddeclaration"}, {"full_name": "tangentCone_mono_nhds", "code": "theorem tangentCone_mono_nhds (h : \ud835\udcdd[s] x \u2264 \ud835\udcdd[t] x) :\n    tangentConeAt \ud835\udd5c s x \u2286 tangentConeAt \ud835\udd5c t x", "start": [124, 1], "end": [131, 94], "kind": "commanddeclaration"}, {"full_name": "tangentCone_congr", "code": "theorem tangentCone_congr (h : \ud835\udcdd[s] x = \ud835\udcdd[t] x) : tangentConeAt \ud835\udd5c s x = tangentConeAt \ud835\udd5c t x", "start": [134, 1], "end": [136, 99], "kind": "commanddeclaration"}, {"full_name": "tangentCone_inter_nhds", "code": "theorem tangentCone_inter_nhds (ht : t \u2208 \ud835\udcdd x) : tangentConeAt \ud835\udd5c (s \u2229 t) x = tangentConeAt \ud835\udd5c s x", "start": [139, 1], "end": [141, 53], "kind": "commanddeclaration"}, {"full_name": "subset_tangentCone_prod_left", "code": "theorem subset_tangentCone_prod_left {t : Set F} {y : F} (ht : y \u2208 closure t) :\n    LinearMap.inl \ud835\udd5c E F '' tangentConeAt \ud835\udd5c s x \u2286 tangentConeAt \ud835\udd5c (s \u00d7\u02e2 t) (x, y)", "start": [144, 1], "end": [161, 75], "kind": "commanddeclaration"}, {"full_name": "subset_tangentCone_prod_right", "code": "theorem subset_tangentCone_prod_right {t : Set F} {y : F} (hs : x \u2208 closure s) :\n    LinearMap.inr \ud835\udd5c E F '' tangentConeAt \ud835\udd5c t y \u2286 tangentConeAt \ud835\udd5c (s \u00d7\u02e2 t) (x, y)", "start": [164, 1], "end": [181, 75], "kind": "commanddeclaration"}, {"full_name": "mapsTo_tangentCone_pi", "code": "theorem mapsTo_tangentCone_pi {\u03b9 : Type*} [DecidableEq \u03b9] {E : \u03b9 \u2192 Type*}\n    [\u2200 i, NormedAddCommGroup (E i)] [\u2200 i, NormedSpace \ud835\udd5c (E i)] {s : \u2200 i, Set (E i)} {x : \u2200 i, E i}\n    {i : \u03b9} (hi : \u2200 (j) (_ : j \u2260 i), x j \u2208 closure (s j)) :\n    MapsTo (LinearMap.single i : E i \u2192\u2097[\ud835\udd5c] \u2200 j, E j) (tangentConeAt \ud835\udd5c (s i) (x i))\n      (tangentConeAt \ud835\udd5c (Set.pi univ s) x)", "start": [184, 1], "end": [205, 77], "kind": "commanddeclaration"}, {"full_name": "mem_tangentCone_of_openSegment_subset", "code": "theorem mem_tangentCone_of_openSegment_subset {s : Set G} {x y : G} (h : openSegment \u211d x y \u2286 s) :\n    y - x \u2208 tangentConeAt \u211d s x", "start": [208, 1], "end": [218, 51], "kind": "commanddeclaration"}, {"full_name": "mem_tangentCone_of_segment_subset", "code": "theorem mem_tangentCone_of_segment_subset {s : Set G} {x y : G} (h : segment \u211d x y \u2286 s) :\n    y - x \u2208 tangentConeAt \u211d s x", "start": [221, 1], "end": [225, 85], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffOn.uniqueDiffWithinAt", "code": "theorem UniqueDiffOn.uniqueDiffWithinAt {s : Set E} {x} (hs : UniqueDiffOn \ud835\udd5c s) (h : x \u2208 s) :\n    UniqueDiffWithinAt \ud835\udd5c s x", "start": [238, 1], "end": [240, 9], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffWithinAt_univ", "code": "theorem uniqueDiffWithinAt_univ : UniqueDiffWithinAt \ud835\udd5c univ x", "start": [243, 1], "end": [245, 7], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffOn_univ", "code": "theorem uniqueDiffOn_univ : UniqueDiffOn \ud835\udd5c (univ : Set E)", "start": [248, 1], "end": [249, 37], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffOn_empty", "code": "theorem uniqueDiffOn_empty : UniqueDiffOn \ud835\udd5c (\u2205 : Set E)", "start": [252, 1], "end": [253, 22], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffWithinAt.congr_pt", "code": "theorem UniqueDiffWithinAt.congr_pt (h : UniqueDiffWithinAt \ud835\udd5c s x) (hy : x = y) :\n    UniqueDiffWithinAt \ud835\udd5c s y", "start": [256, 1], "end": [257, 39], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffWithinAt.mono_nhds", "code": "theorem UniqueDiffWithinAt.mono_nhds (h : UniqueDiffWithinAt \ud835\udd5c s x) (st : \ud835\udcdd[s] x \u2264 \ud835\udcdd[t] x) :\n    UniqueDiffWithinAt \ud835\udd5c t x", "start": [259, 1], "end": [263, 83], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffWithinAt.mono", "code": "theorem UniqueDiffWithinAt.mono (h : UniqueDiffWithinAt \ud835\udd5c s x) (st : s \u2286 t) :\n    UniqueDiffWithinAt \ud835\udd5c t x", "start": [266, 1], "end": [268, 38], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffWithinAt_congr", "code": "theorem uniqueDiffWithinAt_congr (st : \ud835\udcdd[s] x = \ud835\udcdd[t] x) :\n    UniqueDiffWithinAt \ud835\udd5c s x \u2194 UniqueDiffWithinAt \ud835\udd5c t x", "start": [271, 1], "end": [273, 82], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffWithinAt_inter", "code": "theorem uniqueDiffWithinAt_inter (ht : t \u2208 \ud835\udcdd x) :\n    UniqueDiffWithinAt \ud835\udd5c (s \u2229 t) x \u2194 UniqueDiffWithinAt \ud835\udd5c s x", "start": [276, 1], "end": [278, 63], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffWithinAt.inter", "code": "theorem UniqueDiffWithinAt.inter (hs : UniqueDiffWithinAt \ud835\udd5c s x) (ht : t \u2208 \ud835\udcdd x) :\n    UniqueDiffWithinAt \ud835\udd5c (s \u2229 t) x", "start": [281, 1], "end": [283, 37], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffWithinAt_inter'", "code": "theorem uniqueDiffWithinAt_inter' (ht : t \u2208 \ud835\udcdd[s] x) :\n    UniqueDiffWithinAt \ud835\udd5c (s \u2229 t) x \u2194 UniqueDiffWithinAt \ud835\udd5c s x", "start": [286, 1], "end": [288, 64], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffWithinAt.inter'", "code": "theorem UniqueDiffWithinAt.inter' (hs : UniqueDiffWithinAt \ud835\udd5c s x) (ht : t \u2208 \ud835\udcdd[s] x) :\n    UniqueDiffWithinAt \ud835\udd5c (s \u2229 t) x", "start": [291, 1], "end": [293, 38], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffWithinAt_of_mem_nhds", "code": "theorem uniqueDiffWithinAt_of_mem_nhds (h : s \u2208 \ud835\udcdd x) : UniqueDiffWithinAt \ud835\udd5c s x", "start": [296, 1], "end": [297, 64], "kind": "commanddeclaration"}, {"full_name": "IsOpen.uniqueDiffWithinAt", "code": "theorem IsOpen.uniqueDiffWithinAt (hs : IsOpen s) (xs : x \u2208 s) : UniqueDiffWithinAt \ud835\udd5c s x", "start": [300, 1], "end": [301, 57], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffOn.inter", "code": "theorem UniqueDiffOn.inter (hs : UniqueDiffOn \ud835\udd5c s) (ht : IsOpen t) : UniqueDiffOn \ud835\udd5c (s \u2229 t)", "start": [304, 1], "end": [305, 58], "kind": "commanddeclaration"}, {"full_name": "IsOpen.uniqueDiffOn", "code": "theorem IsOpen.uniqueDiffOn (hs : IsOpen s) : UniqueDiffOn \ud835\udd5c s", "start": [308, 1], "end": [309, 46], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffWithinAt.prod", "code": "theorem UniqueDiffWithinAt.prod {t : Set F} {y : F} (hs : UniqueDiffWithinAt \ud835\udd5c s x)\n    (ht : UniqueDiffWithinAt \ud835\udd5c t y) : UniqueDiffWithinAt \ud835\udd5c (s \u00d7\u02e2 t) (x, y)", "start": [312, 1], "end": [322, 35], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffWithinAt.univ_pi", "code": "theorem UniqueDiffWithinAt.univ_pi (\u03b9 : Type*) [Finite \u03b9] (E : \u03b9 \u2192 Type*)\n    [\u2200 i, NormedAddCommGroup (E i)] [\u2200 i, NormedSpace \ud835\udd5c (E i)] (s : \u2200 i, Set (E i)) (x : \u2200 i, E i)\n    (h : \u2200 i, UniqueDiffWithinAt \ud835\udd5c (s i) (x i)) : UniqueDiffWithinAt \ud835\udd5c (Set.pi univ s) x", "start": [325, 1], "end": [334, 98], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffWithinAt.pi", "code": "theorem UniqueDiffWithinAt.pi (\u03b9 : Type*) [Finite \u03b9] (E : \u03b9 \u2192 Type*)\n    [\u2200 i, NormedAddCommGroup (E i)] [\u2200 i, NormedSpace \ud835\udd5c (E i)] (s : \u2200 i, Set (E i)) (x : \u2200 i, E i)\n    (I : Set \u03b9) (h : \u2200 i \u2208 I, UniqueDiffWithinAt \ud835\udd5c (s i) (x i)) :\n    UniqueDiffWithinAt \ud835\udd5c (Set.pi I s) x", "start": [337, 1], "end": [344, 60], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffOn.prod", "code": "theorem UniqueDiffOn.prod {t : Set F} (hs : UniqueDiffOn \ud835\udd5c s) (ht : UniqueDiffOn \ud835\udd5c t) :\n    UniqueDiffOn \ud835\udd5c (s \u00d7\u02e2 t)", "start": [347, 1], "end": [350, 64], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffOn.pi", "code": "theorem UniqueDiffOn.pi (\u03b9 : Type*) [Finite \u03b9] (E : \u03b9 \u2192 Type*) [\u2200 i, NormedAddCommGroup (E i)]\n    [\u2200 i, NormedSpace \ud835\udd5c (E i)] (s : \u2200 i, Set (E i)) (I : Set \u03b9)\n    (h : \u2200 i \u2208 I, UniqueDiffOn \ud835\udd5c (s i)) : UniqueDiffOn \ud835\udd5c (Set.pi I s)", "start": [353, 1], "end": [358, 81], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffOn.univ_pi", "code": "theorem UniqueDiffOn.univ_pi (\u03b9 : Type*) [Finite \u03b9] (E : \u03b9 \u2192 Type*)\n    [\u2200 i, NormedAddCommGroup (E i)] [\u2200 i, NormedSpace \ud835\udd5c (E i)] (s : \u2200 i, Set (E i))\n    (h : \u2200 i, UniqueDiffOn \ud835\udd5c (s i)) : UniqueDiffOn \ud835\udd5c (Set.pi univ s)", "start": [361, 1], "end": [366, 41], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffWithinAt_convex", "code": "theorem uniqueDiffWithinAt_convex {s : Set G} (conv : Convex \u211d s) (hs : (interior s).Nonempty)\n    {x : G} (hx : x \u2208 closure s) : UniqueDiffWithinAt \u211d s x", "start": [369, 1], "end": [383, 64], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffOn_convex", "code": "theorem uniqueDiffOn_convex {s : Set G} (conv : Convex \u211d s) (hs : (interior s).Nonempty) :\n    UniqueDiffOn \u211d s", "start": [386, 1], "end": [390, 68], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffOn_Ici", "code": "theorem uniqueDiffOn_Ici (a : \u211d) : UniqueDiffOn \u211d (Ici a)", "start": [393, 1], "end": [394, 82], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffOn_Iic", "code": "theorem uniqueDiffOn_Iic (a : \u211d) : UniqueDiffOn \u211d (Iic a)", "start": [397, 1], "end": [398, 82], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffOn_Ioi", "code": "theorem uniqueDiffOn_Ioi (a : \u211d) : UniqueDiffOn \u211d (Ioi a)", "start": [401, 1], "end": [402, 26], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffOn_Iio", "code": "theorem uniqueDiffOn_Iio (a : \u211d) : UniqueDiffOn \u211d (Iio a)", "start": [405, 1], "end": [406, 26], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffOn_Icc", "code": "theorem uniqueDiffOn_Icc {a b : \u211d} (hab : a < b) : UniqueDiffOn \u211d (Icc a b)", "start": [409, 1], "end": [410, 89], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffOn_Ico", "code": "theorem uniqueDiffOn_Ico (a b : \u211d) : UniqueDiffOn \u211d (Ico a b)", "start": [413, 1], "end": [416, 59], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffOn_Ioc", "code": "theorem uniqueDiffOn_Ioc (a b : \u211d) : UniqueDiffOn \u211d (Ioc a b)", "start": [419, 1], "end": [422, 59], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffOn_Ioo", "code": "theorem uniqueDiffOn_Ioo (a b : \u211d) : UniqueDiffOn \u211d (Ioo a b)", "start": [425, 1], "end": [426, 26], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffOn_Icc_zero_one", "code": "theorem uniqueDiffOn_Icc_zero_one : UniqueDiffOn \u211d (Icc (0 : \u211d) 1)", "start": [429, 1], "end": [431, 31], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffWithinAt_Ioo", "code": "theorem uniqueDiffWithinAt_Ioo {a b t : \u211d} (ht : t \u2208 Set.Ioo a b) :\n    UniqueDiffWithinAt \u211d (Set.Ioo a b) t", "start": [434, 1], "end": [436, 42], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffWithinAt_Ioi", "code": "theorem uniqueDiffWithinAt_Ioi (a : \u211d) : UniqueDiffWithinAt \u211d (Ioi a) a", "start": [439, 1], "end": [440, 63], "kind": "commanddeclaration"}, {"full_name": "uniqueDiffWithinAt_Iio", "code": "theorem uniqueDiffWithinAt_Iio (a : \u211d) : UniqueDiffWithinAt \u211d (Iio a) a", "start": [443, 1], "end": [444, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Algebraic.lean", "imports": ["Mathlib/LinearAlgebra/FiniteDimensional.lean", "Mathlib/RingTheory/Polynomial/IntegralNormalization.lean", "Mathlib/RingTheory/IntegralClosure.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsAlgebraic", "code": "def IsAlgebraic (x : A) : Prop :=\n  \u2203 p : R[X], p \u2260 0 \u2227 aeval x p = 0", "start": [30, 1], "end": [33, 36], "kind": "commanddeclaration"}, {"full_name": "Transcendental", "code": "def Transcendental (x : A) : Prop :=\n  \u00acIsAlgebraic R x", "start": [36, 1], "end": [38, 19], "kind": "commanddeclaration"}, {"full_name": "is_transcendental_of_subsingleton", "code": "theorem is_transcendental_of_subsingleton [Subsingleton R] (x : A) : Transcendental R x", "start": [41, 1], "end": [42, 46], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.IsAlgebraic", "code": "nonrec\ndef Subalgebra.IsAlgebraic (S : Subalgebra R A) : Prop :=\n  \u2200 x \u2208 S, IsAlgebraic R x", "start": [47, 1], "end": [50, 27], "kind": "commanddeclaration"}, {"full_name": "Algebra.IsAlgebraic", "code": "nonrec\ndef Algebra.IsAlgebraic : Prop :=\n  \u2200 x : A, IsAlgebraic R x", "start": [55, 1], "end": [58, 27], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.isAlgebraic_iff", "code": "theorem Subalgebra.isAlgebraic_iff (S : Subalgebra R A) :\n    S.IsAlgebraic \u2194 @Algebra.IsAlgebraic R S _ _ S.algebra", "start": [63, 1], "end": [71, 41], "kind": "commanddeclaration"}, {"full_name": "Algebra.isAlgebraic_iff", "code": "theorem Algebra.isAlgebraic_iff : Algebra.IsAlgebraic R A \u2194 (\u22a4 : Subalgebra R A).IsAlgebraic", "start": [74, 1], "end": [77, 65], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_iff_not_injective", "code": "theorem isAlgebraic_iff_not_injective {x : A} :\n    IsAlgebraic R x \u2194 \u00acFunction.Injective (Polynomial.aeval x : R[X] \u2192\u2090[R] A)", "start": [80, 1], "end": [82, 88], "kind": "commanddeclaration"}, {"full_name": "IsIntegral.isAlgebraic", "code": "theorem IsIntegral.isAlgebraic [Nontrivial R] {x : A} : IsIntegral R x \u2192 IsAlgebraic R x", "start": [95, 1], "end": [97, 43], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_zero", "code": "theorem isAlgebraic_zero [Nontrivial R] : IsAlgebraic R (0 : A)", "start": [102, 1], "end": [103, 28], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_algebraMap", "code": "theorem isAlgebraic_algebraMap [Nontrivial R] (x : R) : IsAlgebraic R (algebraMap R A x)", "start": [106, 1], "end": [108, 77], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_one", "code": "theorem isAlgebraic_one [Nontrivial R] : IsAlgebraic R (1 : A)", "start": [111, 1], "end": [113, 33], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_nat", "code": "theorem isAlgebraic_nat [Nontrivial R] (n : \u2115) : IsAlgebraic R (n : A)", "start": [116, 1], "end": [118, 44], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_int", "code": "theorem isAlgebraic_int [Nontrivial R] (n : \u2124) : IsAlgebraic R (n : A)", "start": [121, 1], "end": [123, 44], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_rat", "code": "theorem isAlgebraic_rat (R : Type u) {A : Type v} [DivisionRing A] [Field R] [Algebra R A] (n : \u211a) :\n    IsAlgebraic R (n : A)", "start": [126, 1], "end": [129, 44], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_of_mem_rootSet", "code": "theorem isAlgebraic_of_mem_rootSet {R : Type u} {A : Type v} [Field R] [Field A] [Algebra R A]\n    {p : R[X]} {x : A} (hx : x \u2208 p.rootSet A) : IsAlgebraic R x", "start": [132, 1], "end": [134, 66], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_algebraMap_of_isAlgebraic", "code": "theorem isAlgebraic_algebraMap_of_isAlgebraic {a : S} :\n    IsAlgebraic R a \u2192 IsAlgebraic R (algebraMap S A a)", "start": [139, 1], "end": [141, 58], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_algHom_of_isAlgebraic", "code": "theorem isAlgebraic_algHom_of_isAlgebraic {B} [Ring B] [Algebra R B] (f : A \u2192\u2090[R] B) {a : A}\n    (h : IsAlgebraic R a) : IsAlgebraic R (f a)", "start": [144, 1], "end": [149, 60], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.isAlgebraic", "code": "theorem AlgEquiv.isAlgebraic {B} [Ring B] [Algebra R B] (e : A \u2243\u2090[R] B)\n    (h : Algebra.IsAlgebraic R A) : Algebra.IsAlgebraic R B", "start": [152, 1], "end": [155, 92], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.isAlgebraic_iff", "code": "theorem AlgEquiv.isAlgebraic_iff {B} [Ring B] [Algebra R B] (e : A \u2243\u2090[R] B) :\n    Algebra.IsAlgebraic R A \u2194 Algebra.IsAlgebraic R B", "start": [158, 1], "end": [160, 38], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_algebraMap_iff", "code": "theorem isAlgebraic_algebraMap_iff {a : S} (h : Function.Injective (algebraMap S A)) :\n    IsAlgebraic R (algebraMap S A a) \u2194 IsAlgebraic R a", "start": [163, 1], "end": [166, 43], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_of_pow", "code": "theorem isAlgebraic_of_pow {r : A} {n : \u2115} (hn : 0 < n) (ht : IsAlgebraic R (r ^ n)) :\n    IsAlgebraic R r", "start": [169, 1], "end": [174, 40], "kind": "commanddeclaration"}, {"full_name": "Transcendental.pow", "code": "theorem Transcendental.pow {r : A} (ht : Transcendental R r) {n : \u2115} (hn : 0 < n) :\n    Transcendental R (r ^ n)", "start": [177, 1], "end": [178, 75], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_iff_isIntegral", "code": "theorem isAlgebraic_iff_isIntegral {x : A} : IsAlgebraic K x \u2194 IsIntegral K x", "start": [187, 1], "end": [192, 50], "kind": "commanddeclaration"}, {"full_name": "Algebra.isAlgebraic_iff_isIntegral", "code": "protected theorem Algebra.isAlgebraic_iff_isIntegral :\n    Algebra.IsAlgebraic K A \u2194 Algebra.IsIntegral K A", "start": [195, 1], "end": [197, 100], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_of_larger_base_of_injective", "code": "theorem isAlgebraic_of_larger_base_of_injective\n    (hinj : Function.Injective (algebraMap R S)) {x : A}\n    (A_alg : IsAlgebraic R x) : IsAlgebraic S x", "start": [214, 1], "end": [221, 93], "kind": "commanddeclaration"}, {"full_name": "Algebra.isAlgebraic_of_larger_base_of_injective", "code": "theorem Algebra.isAlgebraic_of_larger_base_of_injective (hinj : Function.Injective (algebraMap R S))\n    (A_alg : IsAlgebraic R A) : IsAlgebraic S A", "start": [224, 1], "end": [228, 64], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_of_larger_base", "code": "theorem isAlgebraic_of_larger_base {x : A} (A_alg : IsAlgebraic K x) :\n    IsAlgebraic L x", "start": [241, 1], "end": [244, 75], "kind": "commanddeclaration"}, {"full_name": "Algebra.isAlgebraic_of_larger_base", "code": "theorem Algebra.isAlgebraic_of_larger_base (A_alg : IsAlgebraic K A) : IsAlgebraic L A", "start": [247, 1], "end": [249, 75], "kind": "commanddeclaration"}, {"full_name": "isAlgebraic_of_finite", "code": "theorem isAlgebraic_of_finite (e : A) [FiniteDimensional K A] : IsAlgebraic K e", "start": [254, 1], "end": [255, 60], "kind": "commanddeclaration"}, {"full_name": "Algebra.isAlgebraic_of_finite", "code": "theorem Algebra.isAlgebraic_of_finite [FiniteDimensional K A] : IsAlgebraic K A", "start": [259, 1], "end": [261, 68], "kind": "commanddeclaration"}, {"full_name": "Algebra.isAlgebraic_trans", "code": "theorem Algebra.isAlgebraic_trans (L_alg : IsAlgebraic K L) (A_alg : IsAlgebraic L A) :\n    IsAlgebraic K A", "start": [274, 1], "end": [279, 37], "kind": "commanddeclaration"}, {"full_name": "Algebra.IsAlgebraic.algHom_bijective", "code": "theorem Algebra.IsAlgebraic.algHom_bijective (ha : Algebra.IsAlgebraic K L) (f : L \u2192\u2090[K] L) :\n    Function.Bijective f", "start": [290, 1], "end": [299, 34], "kind": "commanddeclaration"}, {"full_name": "AlgHom.bijective", "code": "theorem AlgHom.bijective [FiniteDimensional K L] (\u03d5 : L \u2192\u2090[K] L) : Function.Bijective \u03d5", "start": [302, 1], "end": [303, 57], "kind": "commanddeclaration"}, {"full_name": "Algebra.IsAlgebraic.algEquivEquivAlgHom", "code": "@[simps]\nnoncomputable def Algebra.IsAlgebraic.algEquivEquivAlgHom (ha : Algebra.IsAlgebraic K L) :\n    (L \u2243\u2090[K] L) \u2243* (L \u2192\u2090[K] L) where\n  toFun \u03d5 := \u03d5.toAlgHom\n  invFun \u03d5 := AlgEquiv.ofBijective \u03d5 (ha.algHom_bijective \u03d5)\n  left_inv _ := by\n    ext\n    rfl\n  right_inv _ := by\n    ext\n    rfl\n  map_mul' _ _ := rfl", "start": [308, 1], "end": [320, 22], "kind": "commanddeclaration"}, {"full_name": "algEquivEquivAlgHom", "code": "@[reducible]\nnoncomputable def algEquivEquivAlgHom [FiniteDimensional K L] :\n    (L \u2243\u2090[K] L) \u2243* (L \u2192\u2090[K] L) :=\n  (Algebra.isAlgebraic_of_finite K L).algEquivEquivAlgHom K L", "start": [323, 1], "end": [327, 62], "kind": "commanddeclaration"}, {"full_name": "exists_integral_multiple", "code": "theorem exists_integral_multiple [Algebra R S] {z : S} (hz : IsAlgebraic R z)\n    (inj : \u2200 x, algebraMap R S x = 0 \u2192 x = 0) :\n    \u2203 (x : integralClosure R S) (y : _) (_ : y \u2260 (0 : R)), z * algebraMap R S y = x", "start": [336, 1], "end": [345, 45], "kind": "commanddeclaration"}, {"full_name": "IsIntegralClosure.exists_smul_eq_mul", "code": "theorem IsIntegralClosure.exists_smul_eq_mul {L : Type*} [Field L] [Algebra R S] [Algebra S L]\n    [Algebra R L] [IsScalarTower R S L] [IsIntegralClosure S R L] (h : Algebra.IsAlgebraic R L)\n    (inj : Function.Injective (algebraMap R L)) (a : S) {b : S} (hb : b \u2260 0) :\n    \u2203 (c : S) (d : _) (_ : d \u2260 (0 : R)), d \u2022 a = b * c", "start": [348, 1], "end": [362, 98], "kind": "commanddeclaration"}, {"full_name": "inv_eq_of_aeval_divX_ne_zero", "code": "theorem inv_eq_of_aeval_divX_ne_zero {x : L} {p : K[X]} (aeval_ne : aeval x (divX p) \u2260 0) :\n    x\u207b\u00b9 = aeval x (divX p) / (aeval x p - algebraMap _ _ (p.coeff 0))", "start": [369, 1], "end": [374, 17], "kind": "commanddeclaration"}, {"full_name": "inv_eq_of_root_of_coeff_zero_ne_zero", "code": "theorem inv_eq_of_root_of_coeff_zero_ne_zero {x : L} {p : K[X]} (aeval_eq : aeval x p = 0)\n    (coeff_zero_ne : p.coeff 0 \u2260 0) : x\u207b\u00b9 = -(aeval x (divX p) / algebraMap _ _ (p.coeff 0))", "start": [378, 1], "end": [386, 70], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.inv_mem_of_root_of_coeff_zero_ne_zero", "code": "theorem Subalgebra.inv_mem_of_root_of_coeff_zero_ne_zero {x : A} {p : K[X]}\n    (aeval_eq : aeval x p = 0) (coeff_zero_ne : p.coeff 0 \u2260 0) : (x\u207b\u00b9 : L) \u2208 A", "start": [389, 1], "end": [399, 43], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.inv_mem_of_algebraic", "code": "theorem Subalgebra.inv_mem_of_algebraic {x : A} (hx : _root_.IsAlgebraic K (x : L)) :\n    (x\u207b\u00b9 : L) \u2208 A", "start": [402, 1], "end": [418, 23], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.isField_of_algebraic", "code": "theorem Subalgebra.isField_of_algebraic (hKL : Algebra.IsAlgebraic K L) : IsField A", "start": [421, 1], "end": [426, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasSMulPi", "code": "def Polynomial.hasSMulPi [Semiring R'] [SMul R' S'] : SMul R'[X] (R' \u2192 S') :=\n  \u27e8fun p f x => eval x p \u2022 f x\u27e9", "start": [435, 1], "end": [439, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasSMulPi'", "code": "noncomputable def Polynomial.hasSMulPi' [CommSemiring R'] [Semiring S'] [Algebra R' S']\n    [SMul S' T'] : SMul R'[X] (S' \u2192 T') :=\n  \u27e8fun p f x => aeval x p \u2022 f x\u27e9", "start": [442, 1], "end": [447, 33], "kind": "commanddeclaration"}, {"full_name": "polynomial_smul_apply", "code": "@[simp]\ntheorem polynomial_smul_apply [Semiring R'] [SMul R' S'] (p : R'[X]) (f : R' \u2192 S') (x : R') :\n    (p \u2022 f) x = eval x p \u2022 f x", "start": [452, 1], "end": [455, 6], "kind": "commanddeclaration"}, {"full_name": "polynomial_smul_apply'", "code": "@[simp]\ntheorem polynomial_smul_apply' [CommSemiring R'] [Semiring S'] [Algebra R' S'] [SMul S' T']\n    (p : R'[X]) (f : S' \u2192 T') (x : S') : (p \u2022 f) x = aeval x p \u2022 f x", "start": [458, 1], "end": [461, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.algebraPi", "code": "noncomputable def Polynomial.algebraPi : Algebra R'[X] (S' \u2192 T') :=\n  { Polynomial.hasSMulPi' R' S' T' with\n    toFun := fun p z => algebraMap S' T' (aeval z p)\n    map_one' := by\n      funext z\n      simp only [Polynomial.aeval_one, Pi.one_apply, map_one]\n    map_mul' := fun f g => by\n      funext z\n      simp only [Pi.mul_apply, map_mul]\n    map_zero' := by\n      funext z\n      simp only [Polynomial.aeval_zero, Pi.zero_apply, map_zero]\n    map_add' := fun f g => by\n      funext z\n      simp only [Polynomial.aeval_add, Pi.add_apply, map_add]\n    commutes' := fun p f => by\n      funext z\n      exact mul_comm _ _\n    smul_def' := fun p f => by\n      funext z\n      simp only [polynomial_smul_apply', Algebra.algebraMap_eq_smul_one, RingHom.coe_mk,\n        MonoidHom.coe_mk, OneHom.coe_mk, Pi.mul_apply, Algebra.smul_mul_assoc, one_mul] }", "start": [468, 1], "end": [490, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.algebraMap_pi_eq_aeval", "code": "@[simp]\ntheorem Polynomial.algebraMap_pi_eq_aeval :\n    (algebraMap R'[X] (S' \u2192 T') : R'[X] \u2192 S' \u2192 T') = fun p z => algebraMap _ _ (aeval z p)", "start": [495, 1], "end": [498, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.algebraMap_pi_self_eq_eval", "code": "@[simp]\ntheorem Polynomial.algebraMap_pi_self_eq_eval :\n    (algebraMap R'[X] (R' \u2192 R') : R'[X] \u2192 R' \u2192 R') = fun p z => eval z p", "start": [501, 1], "end": [504, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/Minpoly/Basic.lean", "imports": ["Mathlib/RingTheory/IntegralClosure.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "minpoly", "code": "noncomputable def minpoly (x : B) : A[X] :=\n  if hx : IsIntegral A x then degree_lt_wf.min _ hx else 0", "start": [28, 1], "end": [38, 59], "kind": "commanddeclaration"}, {"full_name": "minpoly.monic", "code": "theorem monic (hx : IsIntegral A x) : Monic (minpoly A x)", "start": [51, 1], "end": [55, 38], "kind": "commanddeclaration"}, {"full_name": "minpoly.ne_zero", "code": "theorem ne_zero [Nontrivial A] (hx : IsIntegral A x) : minpoly A x \u2260 0", "start": [58, 1], "end": [60, 21], "kind": "commanddeclaration"}, {"full_name": "minpoly.eq_zero", "code": "theorem eq_zero (hx : \u00acIsIntegral A x) : minpoly A x = 0", "start": [63, 1], "end": [64, 13], "kind": "commanddeclaration"}, {"full_name": "minpoly.algHom_eq", "code": "theorem algHom_eq (f : B \u2192\u2090[A] B') (hf : Function.Injective f) (x : B) :\n    minpoly A (f x) = minpoly A x", "start": [67, 1], "end": [70, 97], "kind": "commanddeclaration"}, {"full_name": "minpoly.algebraMap_eq", "code": "theorem algebraMap_eq {B} [CommRing B] [Algebra A B] [Algebra B B'] [IsScalarTower A B B']\n    (h : Function.Injective (algebraMap B B')) (x : B) :\n    minpoly A (algebraMap B B' x) = minpoly A x", "start": [73, 1], "end": [76, 48], "kind": "commanddeclaration"}, {"full_name": "minpoly.algEquiv_eq", "code": "@[simp]\ntheorem algEquiv_eq (f : B \u2243\u2090[A] B') (x : B) : minpoly A (f x) = minpoly A x", "start": [78, 1], "end": [80, 43], "kind": "commanddeclaration"}, {"full_name": "minpoly.aeval", "code": "@[simp]\ntheorem aeval : aeval x (minpoly A x) = 0", "start": [85, 1], "end": [93, 23], "kind": "commanddeclaration"}, {"full_name": "minpoly.ne_one", "code": "theorem ne_one [Nontrivial B] : minpoly A x \u2260 1", "start": [96, 1], "end": [100, 47], "kind": "commanddeclaration"}, {"full_name": "minpoly.map_ne_one", "code": "theorem map_ne_one [Nontrivial B] {R : Type*} [Semiring R] [Nontrivial R] (f : A \u2192+* R) :\n    (minpoly A x).map f \u2260 1", "start": [103, 1], "end": [108, 22], "kind": "commanddeclaration"}, {"full_name": "minpoly.not_isUnit", "code": "theorem not_isUnit [Nontrivial B] : \u00acIsUnit (minpoly A x)", "start": [111, 1], "end": [117, 26], "kind": "commanddeclaration"}, {"full_name": "minpoly.mem_range_of_degree_eq_one", "code": "theorem mem_range_of_degree_eq_one (hx : (minpoly A x).degree = 1) :\n    x \u2208 (algebraMap A B).range", "start": [120, 1], "end": [129, 43], "kind": "commanddeclaration"}, {"full_name": "minpoly.min", "code": "theorem min {p : A[X]} (pmonic : p.Monic) (hp : Polynomial.aeval x p = 0) :\n    degree (minpoly A x) \u2264 degree p", "start": [132, 1], "end": [138, 36], "kind": "commanddeclaration"}, {"full_name": "minpoly.unique'", "code": "theorem unique' {p : A[X]} (hm : p.Monic) (hp : Polynomial.aeval x p = 0)\n    (hl : \u2200 q : A[X], degree q < degree p \u2192 q = 0 \u2228 Polynomial.aeval x q \u2260 0) :\n    p = minpoly A x", "start": [141, 1], "end": [163, 13], "kind": "commanddeclaration"}, {"full_name": "minpoly.subsingleton", "code": "@[nontriviality]\ntheorem subsingleton [Subsingleton B] : minpoly A x = 1", "start": [166, 1], "end": [173, 31], "kind": "commanddeclaration"}, {"full_name": "minpoly.natDegree_pos", "code": "theorem natDegree_pos [Nontrivial B] (hx : IsIntegral A x) : 0 < natDegree (minpoly A x)", "start": [188, 1], "end": [196, 67], "kind": "commanddeclaration"}, {"full_name": "minpoly.degree_pos", "code": "theorem degree_pos [Nontrivial B] (hx : IsIntegral A x) : 0 < degree (minpoly A x)", "start": [199, 1], "end": [201, 53], "kind": "commanddeclaration"}, {"full_name": "minpoly.eq_X_sub_C_of_algebraMap_inj", "code": "theorem eq_X_sub_C_of_algebraMap_inj (a : A) (hf : Function.Injective (algebraMap A B)) :\n    minpoly A (algebraMap A B a) = X - C a", "start": [204, 1], "end": [215, 51], "kind": "commanddeclaration"}, {"full_name": "minpoly.aeval_ne_zero_of_dvdNotUnit_minpoly", "code": "theorem aeval_ne_zero_of_dvdNotUnit_minpoly {a : A[X]} (hx : IsIntegral A x) (hamonic : a.Monic)\n    (hdvd : DvdNotUnit a (minpoly A x)) : Polynomial.aeval x a \u2260 0", "start": [227, 1], "end": [239, 19], "kind": "commanddeclaration"}, {"full_name": "minpoly.irreducible", "code": "theorem irreducible (hx : IsIntegral A x) : Irreducible (minpoly A x)", "start": [244, 1], "end": [254, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/ConcreteCategory/Basic.lean", "imports": ["Mathlib/CategoryTheory/Functor/EpiMono.lean", "Mathlib/CategoryTheory/Limits/Constructions/EpiMono.lean", "Mathlib/CategoryTheory/Types.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.ConcreteCategory", "code": "class ConcreteCategory (C : Type u) [Category.{v} C] where\n  \n  protected forget : C \u2964 Type w\n  \n  [forget_faithful : Faithful forget]", "start": [47, 1], "end": [59, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.forget", "code": "@[reducible]\ndef forget (C : Type u) [Category.{v} C] [ConcreteCategory.{w} C] : C \u2964 Type w :=\n  ConcreteCategory.forget", "start": [66, 1], "end": [69, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ConcreteCategory.types", "code": "@[reducible]\ninstance ConcreteCategory.types : ConcreteCategory.{u, u, u+1} (Type u) where\n  forget := \ud835\udfed _", "start": [73, 1], "end": [75, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ConcreteCategory.hasCoeToSort", "code": "def ConcreteCategory.hasCoeToSort (C : Type u) [Category.{v} C] [ConcreteCategory.{w} C] :\n    CoeSort C (Type w) where\n  coe := fun X => (forget C).obj X", "start": [78, 1], "end": [88, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ConcreteCategory.funLike", "code": "@[reducible]\ndef ConcreteCategory.funLike {X Y : C} : FunLike (X \u27f6 Y) X (fun _ => Y) where\n  coe f := (forget C).map f\n  coe_injective' _ _ h := (forget C).map_injective h", "start": [100, 1], "end": [103, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ConcreteCategory.hom_ext", "code": "@[ext low] theorem ConcreteCategory.hom_ext {X Y : C} (f g : X \u27f6 Y) (w : \u2200 x : X, f x = g x) : f = g", "start": [106, 1], "end": [112, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.forget_map_eq_coe", "code": "theorem forget_map_eq_coe {X Y : C} (f : X \u27f6 Y) : (forget C).map f = f", "start": [115, 1], "end": [115, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.congr_hom", "code": "theorem congr_hom {X Y : C} {f g : X \u27f6 Y} (h : f = g) (x : X) : f x = g x", "start": [118, 1], "end": [122, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coe_id", "code": "theorem coe_id {X : C} : (\ud835\udfd9 X : X \u2192 X) = id", "start": [125, 1], "end": [126, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coe_comp", "code": "theorem coe_comp {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) : (f \u226b g : X \u2192 Z) = g \u2218 f", "start": [129, 1], "end": [130, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.id_apply", "code": "@[simp] theorem id_apply {X : C} (x : X) : (\ud835\udfd9 X : X \u2192 X) x = x", "start": [133, 1], "end": [134, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.comp_apply", "code": "@[simp] theorem comp_apply {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) : (f \u226b g) x = g (f x)", "start": [137, 1], "end": [138, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.comp_apply'", "code": "theorem comp_apply' {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) :\n    (forget C).map (f \u226b g) x = (forget C).map g ((forget C).map f x)", "start": [141, 1], "end": [142, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ConcreteCategory.congr_hom", "code": "theorem ConcreteCategory.congr_hom {X Y : C} {f g : X \u27f6 Y} (h : f = g) (x : X) : f x = g x", "start": [144, 1], "end": [145, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ConcreteCategory.congr_arg", "code": "theorem ConcreteCategory.congr_arg {X Y : C} (f : X \u27f6 Y) {x x' : X} (h : x = x') : f x = f x'", "start": [148, 1], "end": [149, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ConcreteCategory.mono_of_injective", "code": "theorem ConcreteCategory.mono_of_injective {X Y : C} (f : X \u27f6 Y) (i : Function.Injective f) :\n    Mono f", "start": [152, 1], "end": [155, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ConcreteCategory.injective_of_mono_of_preservesPullback", "code": "theorem ConcreteCategory.injective_of_mono_of_preservesPullback {X Y : C} (f : X \u27f6 Y) [Mono f]\n    [PreservesLimitsOfShape WalkingCospan (forget C)] : Function.Injective f", "start": [158, 1], "end": [160, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ConcreteCategory.mono_iff_injective_of_preservesPullback", "code": "theorem ConcreteCategory.mono_iff_injective_of_preservesPullback {X Y : C} (f : X \u27f6 Y)\n    [PreservesLimitsOfShape WalkingCospan (forget C)] : Mono f \u2194 Function.Injective f", "start": [163, 1], "end": [165, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ConcreteCategory.epi_of_surjective", "code": "theorem ConcreteCategory.epi_of_surjective {X Y : C} (f : X \u27f6 Y) (s : Function.Surjective f) :\n    Epi f", "start": [168, 1], "end": [171, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ConcreteCategory.surjective_of_epi_of_preservesPushout", "code": "theorem ConcreteCategory.surjective_of_epi_of_preservesPushout {X Y : C} (f : X \u27f6 Y) [Epi f]\n    [PreservesColimitsOfShape WalkingSpan (forget C)] : Function.Surjective f", "start": [174, 1], "end": [176, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ConcreteCategory.epi_iff_surjective_of_preservesPushout", "code": "theorem ConcreteCategory.epi_iff_surjective_of_preservesPushout {X Y : C} (f : X \u27f6 Y)\n    [PreservesColimitsOfShape WalkingSpan (forget C)] : Epi f \u2194 Function.Surjective f", "start": [179, 1], "end": [181, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ConcreteCategory.bijective_of_isIso", "code": "theorem ConcreteCategory.bijective_of_isIso {X Y : C} (f : X \u27f6 Y) [IsIso f] :\n    Function.Bijective ((forget C).map f)", "start": [184, 1], "end": [187, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ConcreteCategory.hasCoeToFun_Type", "code": "@[simp]\ntheorem ConcreteCategory.hasCoeToFun_Type {X Y : Type u} (f : X \u27f6 Y) : CoeFun.coe f = f", "start": [190, 1], "end": [191, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasForget\u2082", "code": "class HasForget\u2082 (C : Type u) (D : Type u') [Category.{v} C] [ConcreteCategory.{w} C]\n  [Category.{v'} D] [ConcreteCategory.{w} D] where\n  \n  forget\u2082 : C \u2964 D\n  \n  forget_comp : forget\u2082 \u22d9 forget D = forget C := by aesop", "start": [196, 1], "end": [204, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.forget\u2082", "code": "@[reducible]\ndef forget\u2082 (C : Type u) (D : Type u') [Category.{v} C] [ConcreteCategory.{w} C]\n    [Category.{v'} D] [ConcreteCategory.{w} D] [HasForget\u2082 C D] : C \u2964 D :=\n  HasForget\u2082.forget\u2082", "start": [207, 1], "end": [212, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.forget\u2082_faithful", "code": "instance forget\u2082_faithful (C : Type u) (D : Type u') [Category.{v} C] [ConcreteCategory.{w} C]\n    [Category.{v'} D] [ConcreteCategory.{w} D] [HasForget\u2082 C D] : Faithful (forget\u2082 C D) :=\n  HasForget\u2082.forget_comp.faithful_of_comp", "start": [215, 1], "end": [217, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.forget\u2082_preservesMonomorphisms", "code": "instance forget\u2082_preservesMonomorphisms (C : Type u) (D : Type u')\n    [Category.{v} C] [ConcreteCategory.{w} C] [Category.{v'} D] [ConcreteCategory.{w} D]\n    [HasForget\u2082 C D] [(forget C).PreservesMonomorphisms] :\n    (forget\u2082 C D).PreservesMonomorphisms :=\n  have : (forget\u2082 C D \u22d9 forget D).PreservesMonomorphisms := by\n    simp only [HasForget\u2082.forget_comp]\n    infer_instance\n  Functor.preservesMonomorphisms_of_preserves_of_reflects _ (forget D)", "start": [220, 1], "end": [227, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.forget\u2082_preservesEpimorphisms", "code": "instance forget\u2082_preservesEpimorphisms (C : Type u) (D : Type u')\n    [Category.{v} C] [ConcreteCategory.{w} C] [Category.{v'} D] [ConcreteCategory.{w} D]\n    [HasForget\u2082 C D] [(forget C).PreservesEpimorphisms] :\n    (forget\u2082 C D).PreservesEpimorphisms :=\n  have : (forget\u2082 C D \u22d9 forget D).PreservesEpimorphisms := by\n    simp only [HasForget\u2082.forget_comp]\n    infer_instance\n  Functor.preservesEpimorphisms_of_preserves_of_reflects _ (forget D)", "start": [230, 1], "end": [237, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InducedCategory.concreteCategory", "code": "instance InducedCategory.concreteCategory {C : Type u} {D : Type u'}\n    [Category.{v'} D] [ConcreteCategory.{w} D] (f : C \u2192 D) :\n      ConcreteCategory (InducedCategory D f) where\n  forget := inducedFunctor f \u22d9 forget D", "start": [240, 1], "end": [243, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InducedCategory.hasForget\u2082", "code": "instance InducedCategory.hasForget\u2082 {C : Type u} {D : Type u'} [Category.{v} D]\n    [ConcreteCategory.{w} D] (f : C \u2192 D) : HasForget\u2082 (InducedCategory D f) D where\n  forget\u2082 := inducedFunctor f\n  forget_comp := rfl", "start": [246, 1], "end": [249, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory.concreteCategory", "code": "instance FullSubcategory.concreteCategory {C : Type u} [Category.{v} C] [ConcreteCategory.{w} C]\n    (Z : C \u2192 Prop) : ConcreteCategory (FullSubcategory Z) where\n  forget := fullSubcategoryInclusion Z \u22d9 forget C", "start": [252, 1], "end": [254, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory.hasForget\u2082", "code": "instance FullSubcategory.hasForget\u2082 {C : Type u} [Category.{v} C] [ConcreteCategory.{w} C]\n    (Z : C \u2192 Prop) : HasForget\u2082 (FullSubcategory Z) C where\n  forget\u2082 := fullSubcategoryInclusion Z\n  forget_comp := rfl", "start": [257, 1], "end": [260, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasForget\u2082.mk'", "code": "def HasForget\u2082.mk' {C : Type u} {D : Type u'} [Category.{v} C] [ConcreteCategory.{w} C]\n    [Category.{v'} D] [ConcreteCategory.{w} D]\n    (obj : C \u2192 D) (h_obj : \u2200 X, (forget D).obj (obj X) = (forget C).obj X)\n    (map : \u2200 {X Y}, (X \u27f6 Y) \u2192 (obj X \u27f6 obj Y))\n    (h_map : \u2200 {X Y} {f : X \u27f6 Y}, HEq ((forget D).map (map f)) ((forget C).map f)) : HasForget\u2082 C D\n    where\n  forget\u2082 := Faithful.div _ _ _ @h_obj _ @h_map\n  forget_comp := by apply Faithful.div_comp", "start": [263, 1], "end": [273, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hasForgetToType", "code": "def hasForgetToType (C : Type u) [Category.{v} C] [ConcreteCategory.{w} C] :\n    HasForget\u2082 C (Type w) where\n  forget\u2082 := forget C\n  forget_comp := Functor.comp_id _", "start": [276, 1], "end": [281, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Zero.lean", "imports": ["Mathlib/CategoryTheory/Limits/Preserves/Shapes/Terminal.lean", "Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.PreservesZeroMorphisms", "code": "class PreservesZeroMorphisms (F : C \u2964 D) : Prop where\n  \n  map_zero : \u2200 X Y : C, F.map (0 : X \u27f6 Y) = 0 := by aesop", "start": [44, 1], "end": [47, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_zero", "code": "@[simp]\nprotected theorem map_zero (F : C \u2964 D) [PreservesZeroMorphisms F] (X Y : C) :\n    F.map (0 : X \u27f6 Y) = 0", "start": [50, 1], "end": [53, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.zero_of_map_zero", "code": "theorem zero_of_map_zero (F : C \u2964 D) [PreservesZeroMorphisms F] [Faithful F] {X Y : C} (f : X \u27f6 Y)\n    (h : F.map f = 0) : f = 0", "start": [56, 1], "end": [58, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_eq_zero_iff", "code": "theorem map_eq_zero_iff (F : C \u2964 D) [PreservesZeroMorphisms F] [Faithful F] {X Y : C} {f : X \u27f6 Y} :\n    F.map f = 0 \u2194 f = 0", "start": [61, 1], "end": [65, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesZeroMorphisms_of_isLeftAdjoint", "code": "instance (priority := 100) preservesZeroMorphisms_of_isLeftAdjoint (F : C \u2964 D) [IsLeftAdjoint F] :\n    PreservesZeroMorphisms F where\n  map_zero X Y := by\n    let adj := Adjunction.ofLeftAdjoint F\n    calc\n      F.map (0 : X \u27f6 Y) = F.map 0 \u226b F.map (adj.unit.app Y) \u226b adj.counit.app (F.obj Y) := ?_\n      _ = F.map 0 \u226b F.map ((rightAdjoint F).map (0 : F.obj X \u27f6 _)) \u226b adj.counit.app (F.obj Y) := ?_\n      _ = 0 := ?_\n    \u00b7 rw [Adjunction.left_triangle_components]\n      exact (Category.comp_id _).symm\n    \u00b7 simp only [\u2190 Category.assoc, \u2190 F.map_comp, zero_comp]\n    \u00b7 simp only [Adjunction.counit_naturality, comp_zero]", "start": [68, 1], "end": [79, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesZeroMorphisms_of_isRightAdjoint", "code": "instance (priority := 100) preservesZeroMorphisms_of_isRightAdjoint (G : C \u2964 D) [IsRightAdjoint G] :\n    PreservesZeroMorphisms G where\n  map_zero X Y := by\n    let adj := Adjunction.ofRightAdjoint G\n    calc\n      G.map (0 : X \u27f6 Y) = adj.unit.app (G.obj X) \u226b G.map (adj.counit.app X) \u226b G.map 0 := ?_\n      _ = adj.unit.app (G.obj X) \u226b G.map ((leftAdjoint G).map (0 : _ \u27f6 G.obj X)) \u226b G.map 0 := ?_\n      _ = 0 := ?_\n    \u00b7 rw [Adjunction.right_triangle_components_assoc]\n    \u00b7 simp only [\u2190 G.map_comp, comp_zero]\n    \u00b7 simp only [id_obj, comp_obj, Adjunction.unit_naturality_assoc, zero_comp]", "start": [82, 1], "end": [92, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesZeroMorphisms_of_full", "code": "instance (priority := 100) preservesZeroMorphisms_of_full (F : C \u2964 D) [Full F] :\n    PreservesZeroMorphisms F where\n  map_zero X Y :=\n    calc\n      F.map (0 : X \u27f6 Y) = F.map (0 \u226b F.preimage (0 : F.obj Y \u27f6 F.obj Y)) := by rw [zero_comp]\n      _ = 0 := by rw [F.map_comp, F.image_preimage, comp_zero]", "start": [95, 1], "end": [100, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesZeroMorphisms_evaluation_obj", "code": "instance preservesZeroMorphisms_evaluation_obj (j : D) :\n    PreservesZeroMorphisms ((evaluation D C).obj j) where", "start": [103, 1], "end": [104, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapZeroObject", "code": "@[simps]\ndef mapZeroObject [PreservesZeroMorphisms F] : F.obj 0 \u2245 0 where\n  hom := 0\n  inv := 0\n  hom_inv_id := by rw [\u2190 F.map_id, id_zero, F.map_zero, zero_comp]\n  inv_hom_id := by rw [id_zero, comp_zero]", "start": [116, 1], "end": [122, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesZeroMorphisms_of_map_zero_object", "code": "theorem preservesZeroMorphisms_of_map_zero_object (i : F.obj 0 \u2245 0) : PreservesZeroMorphisms F where", "start": [127, 1], "end": [132, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesZeroMorphisms_of_preserves_initial_object", "code": "instance (priority := 100) preservesZeroMorphisms_of_preserves_initial_object\n    [PreservesColimit (Functor.empty.{0} C) F] : PreservesZeroMorphisms F :=\n  preservesZeroMorphisms_of_map_zero_object <|\n    F.mapIso HasZeroObject.zeroIsoInitial \u226a\u226b\n      PreservesInitial.iso F \u226a\u226b HasZeroObject.zeroIsoInitial.symm", "start": [135, 1], "end": [139, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesZeroMorphisms_of_preserves_terminal_object", "code": "instance (priority := 100) preservesZeroMorphisms_of_preserves_terminal_object\n    [PreservesLimit (Functor.empty.{0} C) F] : PreservesZeroMorphisms F :=\n  preservesZeroMorphisms_of_map_zero_object <|\n    F.mapIso HasZeroObject.zeroIsoTerminal \u226a\u226b\n      PreservesTerminal.iso F \u226a\u226b HasZeroObject.zeroIsoTerminal.symm", "start": [142, 1], "end": [146, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesTerminalObjectOfPreservesZeroMorphisms", "code": "def preservesTerminalObjectOfPreservesZeroMorphisms [PreservesZeroMorphisms F] :\n    PreservesLimit (Functor.empty C) F :=\n  preservesTerminalOfIso F <|\n    F.mapIso HasZeroObject.zeroIsoTerminal.symm \u226a\u226b mapZeroObject F \u226a\u226b HasZeroObject.zeroIsoTerminal", "start": [151, 1], "end": [155, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesInitialObjectOfPreservesZeroMorphisms", "code": "def preservesInitialObjectOfPreservesZeroMorphisms [PreservesZeroMorphisms F] :\n    PreservesColimit (Functor.empty C) F :=\n  preservesInitialOfIso F <|\n    HasZeroObject.zeroIsoInitial.symm \u226a\u226b\n      (mapZeroObject F).symm \u226a\u226b (F.mapIso HasZeroObject.zeroIsoInitial.symm).symm", "start": [158, 1], "end": [163, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Sites/Sieves.lean", "imports": ["Mathlib/Data/Set/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/CompleteLattice.lean", "Mathlib/CategoryTheory/Yoneda.lean", "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "Mathlib/CategoryTheory/Over.lean"], "premises": [{"full_name": "CategoryTheory.Presieve", "code": "def Presieve (X : C) :=\n  \u2200 \u2983Y\u2984, Set (Y \u27f6 X)", "start": [40, 1], "end": [42, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.diagram", "code": "abbrev diagram (S : Presieve X) : (FullSubcategory fun f : Over X => S f.hom) \u2964 C :=\n  fullSubcategoryInclusion _ \u22d9 Over.forget X", "start": [54, 1], "end": [58, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.cocone", "code": "abbrev cocone (S : Presieve X) : Cocone S.diagram :=\n  (Over.forgetCocone X).whisker (fullSubcategoryInclusion _)", "start": [61, 1], "end": [64, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.bind", "code": "def bind (S : Presieve X) (R : \u2200 \u2983Y\u2984 \u2983f : Y \u27f6 X\u2984, S f \u2192 Presieve Y) : Presieve X := fun Z h =>\n  \u2203 (Y : C) (g : Z \u27f6 Y) (f : Y \u27f6 X) (H : S f), R H g \u2227 g \u226b f = h", "start": [67, 1], "end": [72, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.bind_comp", "code": "@[simp]\ntheorem bind_comp {S : Presieve X} {R : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, S f \u2192 Presieve Y} {g : Z \u27f6 Y}\n    (h\u2081 : S f) (h\u2082 : R h\u2081 g) : bind S R (g \u226b f)", "start": [75, 1], "end": [78, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.singleton'", "code": "inductive singleton' : \u2983Y : C\u2984 \u2192 (Y \u27f6 X) \u2192 Prop\n  | mk : singleton' f", "start": [84, 1], "end": [86, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.singleton", "code": "def singleton : Presieve X := singleton' f", "start": [88, 1], "end": [89, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.singleton.mk", "code": "lemma singleton.mk {f : Y \u27f6 X} : singleton f f := singleton'.mk", "start": [91, 1], "end": [91, 64], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Presieve.singleton_eq_iff_domain", "code": "@[simp]\ntheorem singleton_eq_iff_domain (f g : Y \u27f6 X) : singleton f g \u2194 f = g", "start": [95, 1], "end": [101, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.singleton_self", "code": "theorem singleton_self : singleton f f", "start": [104, 1], "end": [105, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.pullbackArrows", "code": "inductive pullbackArrows [HasPullbacks C] (R : Presieve X) : Presieve Y\n  | mk (Z : C) (h : Z \u27f6 X) : R h \u2192 pullbackArrows _ (pullback.snd : pullback h f \u27f6 Y)", "start": [108, 1], "end": [114, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.pullback_singleton", "code": "theorem pullback_singleton [HasPullbacks C] (g : Z \u27f6 X) :\n    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f \u27f6 _)", "start": [117, 1], "end": [125, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.ofArrows", "code": "inductive ofArrows {\u03b9 : Type*} (Y : \u03b9 \u2192 C) (f : \u2200 i, Y i \u27f6 X) : Presieve X\n  | mk (i : \u03b9) : ofArrows _ _ (f i)", "start": [128, 1], "end": [130, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.ofArrows_pUnit", "code": "theorem ofArrows_pUnit : (ofArrows _ fun _ : PUnit => f) = singleton f", "start": [133, 1], "end": [140, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.ofArrows_pullback", "code": "theorem ofArrows_pullback [HasPullbacks C] {\u03b9 : Type*} (Z : \u03b9 \u2192 C) (g : \u2200 i : \u03b9, Z i \u27f6 X) :\n    (ofArrows (fun i => pullback (g i) f) fun i => pullback.snd) =\n      pullbackArrows f (ofArrows Z g)", "start": [143, 1], "end": [153, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.ofArrows_bind", "code": "theorem ofArrows_bind {\u03b9 : Type*} (Z : \u03b9 \u2192 C) (g : \u2200 i : \u03b9, Z i \u27f6 X)\n    (j : \u2200 \u2983Y\u2984 (f : Y \u27f6 X), ofArrows Z g f \u2192 Type*) (W : \u2200 \u2983Y\u2984 (f : Y \u27f6 X) (H), j f H \u2192 C)\n    (k : \u2200 \u2983Y\u2984 (f : Y \u27f6 X) (H i), W f H i \u27f6 Y) :\n    ((ofArrows Z g).bind fun Y f H => ofArrows (W f H) (k f H)) =\n      ofArrows (fun i : \u03a3i, j _ (ofArrows.mk i) => W (g i.1) _ i.2) fun ij =>\n        k (g ij.1) _ ij.2 \u226b g ij.1", "start": [156, 1], "end": [168, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.functorPullback", "code": "def functorPullback (R : Presieve (F.obj X)) : Presieve X := fun _ f => R (F.map f)", "start": [171, 1], "end": [172, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.functorPullback_mem", "code": "@[simp]\ntheorem functorPullback_mem (R : Presieve (F.obj X)) {Y} (f : Y \u27f6 X) :\n    R.functorPullback F f \u2194 R (F.map f)", "start": [175, 1], "end": [178, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.functorPullback_id", "code": "@[simp]\ntheorem functorPullback_id (R : Presieve X) : R.functorPullback (\ud835\udfed _) = R", "start": [181, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.hasPullbacks", "code": "class hasPullbacks (R : Presieve X) : Prop where\n  \n  has_pullbacks : \u2200 {Y Z} {f : Y \u27f6 X} (_ : R f) {g : Z \u27f6 X} (_ : R g), HasPullback f g", "start": [186, 1], "end": [190, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.functorPushforward", "code": "def functorPushforward (S : Presieve X) : Presieve (F.obj X) := fun Y f =>\n  \u2203 (Z : C) (g : Z \u27f6 X) (h : Y \u27f6 F.obj Z), S g \u2227 f = h \u226b F.map g", "start": [198, 1], "end": [202, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.FunctorPushforwardStructure", "code": "structure FunctorPushforwardStructure (S : Presieve X) {Y} (f : Y \u27f6 F.obj X) where\n  \n  preobj : C\n  \n  premap : preobj \u27f6 X\n  \n  lift : Y \u27f6 F.obj preobj\n  \n  cover : S premap\n  \n  fac : f = lift \u226b F.map premap", "start": [206, 1], "end": [218, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.getFunctorPushforwardStructure", "code": "noncomputable def getFunctorPushforwardStructure {F : C \u2964 D} {S : Presieve X} {Y : D}\n    {f : Y \u27f6 F.obj X} (h : S.functorPushforward F f) : FunctorPushforwardStructure F S f := by\n  choose Z f' g h\u2081 h using h\n  exact \u27e8Z, f', g, h\u2081, h\u27e9", "start": [221, 1], "end": [225, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.functorPushforward_comp", "code": "theorem functorPushforward_comp (R : Presieve X) :\n    R.functorPushforward (F \u22d9 G) = (R.functorPushforward F).functorPushforward G", "start": [228, 1], "end": [236, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Presieve.image_mem_functorPushforward", "code": "theorem image_mem_functorPushforward (R : Presieve X) {f : Y \u27f6 X} (h : R f) :\n    R.functorPushforward F (F.map f)", "start": [239, 1], "end": [241, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve", "code": "structure Sieve {C : Type u\u2081} [Category.{v\u2081} C] (X : C) where\n  \n  arrows : Presieve X\n  \n  downward_closed : \u2200 {Y Z f} (_ : arrows f) (g : Z \u27f6 Y), arrows (g \u226b f)", "start": [248, 1], "end": [256, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.arrows_ext", "code": "theorem arrows_ext : \u2200 {R S : Sieve X}, R.arrows = S.arrows \u2192 R = S", "start": [272, 1], "end": [274, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.ext", "code": "@[ext]\nprotected theorem ext {R S : Sieve X} (h : \u2200 \u2983Y\u2984 (f : Y \u27f6 X), R f \u2194 S f) : R = S", "start": [277, 1], "end": [279, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.ext_iff", "code": "protected theorem ext_iff {R S : Sieve X} : R = S \u2194 \u2200 \u2983Y\u2984 (f : Y \u27f6 X), R f \u2194 S f", "start": [282, 1], "end": [283, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.sup", "code": "protected def sup (\ud835\udcae : Set (Sieve X)) : Sieve X\n    where\n  arrows Y := { f | \u2203 S \u2208 \ud835\udcae, Sieve.arrows S f }\n  downward_closed {_ _ f} hf _ := by\n    obtain \u27e8S, hS, hf\u27e9 := hf\n    exact \u27e8S, hS, S.downward_closed hf _\u27e9", "start": [288, 1], "end": [294, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.inf", "code": "protected def inf (\ud835\udcae : Set (Sieve X)) : Sieve X\n    where\n  arrows _ := { f | \u2200 S \u2208 \ud835\udcae, Sieve.arrows S f }\n  downward_closed {_ _ _} hf g S H := S.downward_closed (hf S H) g", "start": [297, 1], "end": [301, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.union", "code": "protected def union (S R : Sieve X) : Sieve X\n    where\n  arrows Y f := S f \u2228 R f\n  downward_closed := by rintro _ _ _ (h | h) g <;> simp [h]", "start": [304, 1], "end": [308, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.inter", "code": "protected def inter (S R : Sieve X) : Sieve X\n    where\n  arrows Y f := S f \u2227 R f\n  downward_closed := by\n    rintro _ _ _ \u27e8h\u2081, h\u2082\u27e9 g\n    simp [h\u2081, h\u2082]", "start": [311, 1], "end": [317, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.sieveInhabited", "code": "instance sieveInhabited : Inhabited (Sieve X) :=\n  \u27e8\u22a4\u27e9", "start": [355, 1], "end": [357, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.sInf_apply", "code": "@[simp]\ntheorem sInf_apply {Ss : Set (Sieve X)} {Y} (f : Y \u27f6 X) :\n    sInf Ss f \u2194 \u2200 (S : Sieve X) (_ : S \u2208 Ss), S f", "start": [360, 1], "end": [363, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.sSup_apply", "code": "@[simp]\ntheorem sSup_apply {Ss : Set (Sieve X)} {Y} (f : Y \u27f6 X) :\n    sSup Ss f \u2194 \u2203 (S : Sieve X) (_ : S \u2208 Ss), S f", "start": [366, 1], "end": [369, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.inter_apply", "code": "@[simp]\ntheorem inter_apply {R S : Sieve X} {Y} (f : Y \u27f6 X) : (R \u2293 S) f \u2194 R f \u2227 S f", "start": [372, 1], "end": [374, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.union_apply", "code": "@[simp]\ntheorem union_apply {R S : Sieve X} {Y} (f : Y \u27f6 X) : (R \u2294 S) f \u2194 R f \u2228 S f", "start": [377, 1], "end": [379, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.top_apply", "code": "@[simp]\ntheorem top_apply (f : Y \u27f6 X) : (\u22a4 : Sieve X) f", "start": [382, 1], "end": [384, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.generate", "code": "@[simps]\ndef generate (R : Presieve X) : Sieve X\n    where\n  arrows Z f := \u2203 (Y : _) (h : Z \u27f6 Y) (g : Y \u27f6 X), R g \u2227 h \u226b g = f\n  downward_closed := by\n    rintro Y Z _ \u27e8W, g, f, hf, rfl\u27e9 h\n    exact \u27e8_, h \u226b g, _, hf, by simp\u27e9", "start": [387, 1], "end": [394, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.bind", "code": "@[simps]\ndef bind (S : Presieve X) (R : \u2200 \u2983Y\u2984 \u2983f : Y \u27f6 X\u2984, S f \u2192 Sieve Y) : Sieve X\n    where\n  arrows := S.bind fun Y f h => R h\n  downward_closed := by\n    rintro Y Z f \u27e8W, f, h, hh, hf, rfl\u27e9 g\n    exact \u27e8_, g \u226b f, _, hh, by simp [hf]\u27e9", "start": [397, 1], "end": [406, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.sets_iff_generate", "code": "theorem sets_iff_generate (R : Presieve X) (S : Sieve X) : generate R \u2264 S \u2194 R \u2264 S", "start": [411, 1], "end": [414, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.giGenerate", "code": "def giGenerate : GaloisInsertion (generate : Presieve X \u2192 Sieve X) arrows\n    where\n  gc := sets_iff_generate\n  choice \ud835\udca2 _ := generate \ud835\udca2\n  choice_eq _ _ := rfl\n  le_l_u _ _ _ hf := \u27e8_, \ud835\udfd9 _, _, hf, id_comp _\u27e9", "start": [417, 1], "end": [423, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.le_generate", "code": "theorem le_generate (R : Presieve X) : R \u2264 generate R", "start": [426, 1], "end": [427, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.generate_sieve", "code": "@[simp]\ntheorem generate_sieve (S : Sieve X) : generate S = S", "start": [430, 1], "end": [432, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.id_mem_iff_eq_top", "code": "theorem id_mem_iff_eq_top : S (\ud835\udfd9 X) \u2194 S = \u22a4", "start": [435, 1], "end": [437, 101], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.generate_of_contains_isSplitEpi", "code": "theorem generate_of_contains_isSplitEpi {R : Presieve X} (f : Y \u27f6 X) [IsSplitEpi f] (hf : R f) :\n    generate R = \u22a4", "start": [440, 1], "end": [444, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.generate_of_singleton_isSplitEpi", "code": "@[simp]\ntheorem generate_of_singleton_isSplitEpi (f : Y \u27f6 X) [IsSplitEpi f] :\n    generate (Presieve.singleton f) = \u22a4", "start": [447, 1], "end": [450, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.generate_top", "code": "@[simp]\ntheorem generate_top : generate (\u22a4 : Presieve X) = \u22a4", "start": [453, 1], "end": [455, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pullback", "code": "@[simps]\ndef pullback (h : Y \u27f6 X) (S : Sieve X) : Sieve Y\n    where\n  arrows Y sl := S (sl \u226b h)\n  downward_closed g := by simp [g]", "start": [458, 1], "end": [465, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pullback_id", "code": "@[simp]\ntheorem pullback_id : S.pullback (\ud835\udfd9 _) = S", "start": [468, 1], "end": [469, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pullback_top", "code": "@[simp]\ntheorem pullback_top {f : Y \u27f6 X} : (\u22a4 : Sieve X).pullback f = \u22a4", "start": [472, 1], "end": [474, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pullback_comp", "code": "theorem pullback_comp {f : Y \u27f6 X} {g : Z \u27f6 Y} (S : Sieve X) :\n    S.pullback (g \u226b f) = (S.pullback f).pullback g", "start": [477, 1], "end": [478, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pullback_inter", "code": "@[simp]\ntheorem pullback_inter {f : Y \u27f6 X} (S R : Sieve X) :\n    (S \u2293 R).pullback f = S.pullback f \u2293 R.pullback f", "start": [481, 1], "end": [483, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pullback_eq_top_iff_mem", "code": "theorem pullback_eq_top_iff_mem (f : Y \u27f6 X) : S f \u2194 S.pullback f = \u22a4", "start": [486, 1], "end": [487, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pullback_eq_top_of_mem", "code": "theorem pullback_eq_top_of_mem (S : Sieve X) {f : Y \u27f6 X} : S f \u2192 S.pullback f = \u22a4", "start": [490, 1], "end": [491, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pushforward", "code": "@[simps]\ndef pushforward (f : Y \u27f6 X) (R : Sieve Y) : Sieve X\n    where\n  arrows Z gf := \u2203 g, g \u226b f = gf \u2227 R g\n  downward_closed := fun \u27e8j, k, z\u27e9 h => \u27e8h \u226b j, by simp [k], by simp [z]\u27e9", "start": [494, 1], "end": [501, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pushforward_apply_comp", "code": "theorem pushforward_apply_comp {R : Sieve Y} {Z : C} {g : Z \u27f6 Y} (hg : R g) (f : Y \u27f6 X) :\n    R.pushforward f (g \u226b f)", "start": [504, 1], "end": [506, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pushforward_comp", "code": "theorem pushforward_comp {f : Y \u27f6 X} {g : Z \u27f6 Y} (R : Sieve Z) :\n    R.pushforward (g \u226b f) = (R.pushforward g).pushforward f", "start": [509, 1], "end": [513, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.galoisConnection", "code": "theorem galoisConnection (f : Y \u27f6 X) : GaloisConnection (Sieve.pushforward f) (Sieve.pullback f)", "start": [516, 1], "end": [517, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pullback_monotone", "code": "theorem pullback_monotone (f : Y \u27f6 X) : Monotone (Sieve.pullback f)", "start": [520, 1], "end": [521, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pushforward_monotone", "code": "theorem pushforward_monotone (f : Y \u27f6 X) : Monotone (Sieve.pushforward f)", "start": [524, 1], "end": [525, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.le_pushforward_pullback", "code": "theorem le_pushforward_pullback (f : Y \u27f6 X) (R : Sieve Y) : R \u2264 (R.pushforward f).pullback f", "start": [528, 1], "end": [529, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pullback_pushforward_le", "code": "theorem pullback_pushforward_le (f : Y \u27f6 X) (R : Sieve X) : (R.pullback f).pushforward f \u2264 R", "start": [532, 1], "end": [533, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pushforward_union", "code": "theorem pushforward_union {f : Y \u27f6 X} (S R : Sieve Y) :\n    (S \u2294 R).pushforward f = S.pushforward f \u2294 R.pushforward f", "start": [536, 1], "end": [538, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pushforward_le_bind_of_mem", "code": "theorem pushforward_le_bind_of_mem (S : Presieve X) (R : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, S f \u2192 Sieve Y)\n    (f : Y \u27f6 X) (h : S f) : (R h).pushforward f \u2264 bind S R", "start": [541, 1], "end": [544, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.le_pullback_bind", "code": "theorem le_pullback_bind (S : Presieve X) (R : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, S f \u2192 Sieve Y) (f : Y \u27f6 X)\n    (h : S f) : R h \u2264 (bind S R).pullback f", "start": [547, 1], "end": [550, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.galoisCoinsertionOfMono", "code": "def galoisCoinsertionOfMono (f : Y \u27f6 X) [Mono f] :\n    GaloisCoinsertion (Sieve.pushforward f) (Sieve.pullback f) := by\n  apply (galoisConnection f).toGaloisCoinsertion\n  rintro S Z g \u27e8g\u2081, hf, hg\u2081\u27e9\n  rw [cancel_mono f] at hf\n  rwa [\u2190 hf]", "start": [553, 1], "end": [559, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.galoisInsertionOfIsSplitEpi", "code": "def galoisInsertionOfIsSplitEpi (f : Y \u27f6 X) [IsSplitEpi f] :\n    GaloisInsertion (Sieve.pushforward f) (Sieve.pullback f) := by\n  apply (galoisConnection f).toGaloisInsertion\n  intro S Z g hg\n  refine' \u27e8g \u226b section_ f, by simpa\u27e9", "start": [562, 1], "end": [567, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.pullbackArrows_comm", "code": "theorem pullbackArrows_comm [HasPullbacks C] {X Y : C} (f : Y \u27f6 X) (R : Presieve X) :\n    Sieve.generate (R.pullbackArrows f) = (Sieve.generate R).pullback f", "start": [570, 1], "end": [580, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPullback", "code": "@[simps]\ndef functorPullback (R : Sieve (F.obj X)) : Sieve X\n    where\n  arrows := Presieve.functorPullback F R\n  downward_closed := by\n    intro _ _ f hf g\n    unfold Presieve.functorPullback\n    rw [F.map_comp]\n    exact R.downward_closed hf (F.map g)", "start": [587, 1], "end": [598, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPullback_arrows", "code": "@[simp]\ntheorem functorPullback_arrows (R : Sieve (F.obj X)) :\n    (R.functorPullback F).arrows = R.arrows.functorPullback F", "start": [601, 1], "end": [604, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPullback_id", "code": "@[simp]\ntheorem functorPullback_id (R : Sieve X) : R.functorPullback (\ud835\udfed _) = R", "start": [607, 1], "end": [610, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPullback_comp", "code": "theorem functorPullback_comp (R : Sieve ((F \u22d9 G).obj X)) :\n    R.functorPullback (F \u22d9 G) = (R.functorPullback G).functorPullback F", "start": [613, 1], "end": [616, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPushforward_extend_eq", "code": "theorem functorPushforward_extend_eq {R : Presieve X} :\n    (generate R).arrows.functorPushforward F = R.functorPushforward F", "start": [619, 1], "end": [627, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPushforward", "code": "@[simps]\ndef functorPushforward (R : Sieve X) : Sieve (F.obj X)\n    where\n  arrows := R.arrows.functorPushforward F\n  downward_closed := by\n    intro _ _ f h g\n    obtain \u27e8X, \u03b1, \u03b2, h\u03b1, rfl\u27e9 := h\n    exact \u27e8X, \u03b1, g \u226b \u03b2, h\u03b1, by simp\u27e9", "start": [630, 1], "end": [638, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPushforward_id", "code": "@[simp]\ntheorem functorPushforward_id (R : Sieve X) : R.functorPushforward (\ud835\udfed _) = R", "start": [641, 1], "end": [649, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPushforward_comp", "code": "theorem functorPushforward_comp (R : Sieve X) :\n    R.functorPushforward (F \u22d9 G) = (R.functorPushforward F).functorPushforward G", "start": [652, 1], "end": [655, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functor_galoisConnection", "code": "theorem functor_galoisConnection (X : C) :\n    GaloisConnection (Sieve.functorPushforward F : Sieve X \u2192 Sieve (F.obj X))\n      (Sieve.functorPullback F)", "start": [658, 1], "end": [669, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPullback_monotone", "code": "theorem functorPullback_monotone (X : C) :\n    Monotone (Sieve.functorPullback F : Sieve (F.obj X) \u2192 Sieve X)", "start": [672, 1], "end": [674, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPushforward_monotone", "code": "theorem functorPushforward_monotone (X : C) :\n    Monotone (Sieve.functorPushforward F : Sieve X \u2192 Sieve (F.obj X))", "start": [677, 1], "end": [679, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.le_functorPushforward_pullback", "code": "theorem le_functorPushforward_pullback (R : Sieve X) :\n    R \u2264 (R.functorPushforward F).functorPullback F", "start": [682, 1], "end": [684, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPullback_pushforward_le", "code": "theorem functorPullback_pushforward_le (R : Sieve (F.obj X)) :\n    (R.functorPullback F).functorPushforward F \u2264 R", "start": [687, 1], "end": [689, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPushforward_union", "code": "theorem functorPushforward_union (S R : Sieve X) :\n    (S \u2294 R).functorPushforward F = S.functorPushforward F \u2294 R.functorPushforward F", "start": [692, 1], "end": [694, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPullback_union", "code": "theorem functorPullback_union (S R : Sieve (F.obj X)) :\n    (S \u2294 R).functorPullback F = S.functorPullback F \u2294 R.functorPullback F", "start": [697, 1], "end": [699, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPullback_inter", "code": "theorem functorPullback_inter (S R : Sieve (F.obj X)) :\n    (S \u2293 R).functorPullback F = S.functorPullback F \u2293 R.functorPullback F", "start": [702, 1], "end": [704, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPushforward_bot", "code": "@[simp]\ntheorem functorPushforward_bot (F : C \u2964 D) (X : C) : (\u22a5 : Sieve X).functorPushforward F = \u22a5", "start": [707, 1], "end": [709, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPushforward_top", "code": "@[simp]\ntheorem functorPushforward_top (F : C \u2964 D) (X : C) : (\u22a4 : Sieve X).functorPushforward F = \u22a4", "start": [712, 1], "end": [716, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPullback_bot", "code": "@[simp]\ntheorem functorPullback_bot (F : C \u2964 D) (X : C) : (\u22a5 : Sieve (F.obj X)).functorPullback F = \u22a5", "start": [719, 1], "end": [721, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorPullback_top", "code": "@[simp]\ntheorem functorPullback_top (F : C \u2964 D) (X : C) : (\u22a4 : Sieve (F.obj X)).functorPullback F = \u22a4", "start": [724, 1], "end": [726, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.image_mem_functorPushforward", "code": "theorem image_mem_functorPushforward (R : Sieve X) {V} {f : V \u27f6 X} (h : R f) :\n    R.functorPushforward F (F.map f)", "start": [729, 1], "end": [731, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.essSurjFullFunctorGaloisInsertion", "code": "def essSurjFullFunctorGaloisInsertion [EssSurj F] [Full F] (X : C) :\n    GaloisInsertion (Sieve.functorPushforward F : Sieve X \u2192 Sieve (F.obj X))\n      (Sieve.functorPullback F) := by\n  apply (functor_galoisConnection F X).toGaloisInsertion\n  intro S Y f hf\n  refine' \u27e8_, F.preimage ((F.objObjPreimageIso Y).hom \u226b f), (F.objObjPreimageIso Y).inv, _\u27e9\n  simpa using S.downward_closed hf _", "start": [734, 1], "end": [741, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.fullyFaithfulFunctorGaloisCoinsertion", "code": "def fullyFaithfulFunctorGaloisCoinsertion [Full F] [Faithful F] (X : C) :\n    GaloisCoinsertion (Sieve.functorPushforward F : Sieve X \u2192 Sieve (F.obj X))\n      (Sieve.functorPullback F) := by\n  apply (functor_galoisConnection F X).toGaloisCoinsertion\n  rintro S Y f \u27e8Z, g, h, h\u2081, h\u2082\u27e9\n  rw [\u2190 F.image_preimage h, \u2190 F.map_comp] at h\u2082\n  rw [F.map_injective h\u2082]\n  exact S.downward_closed h\u2081 _", "start": [744, 1], "end": [752, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functor", "code": "@[simps]\ndef functor (S : Sieve X) : C\u1d52\u1d56 \u2964 Type v\u2081\n    where\n  obj Y := { g : Y.unop \u27f6 X // S g }\n  map f g := \u27e8f.unop \u226b g.1, downward_closed _ g.2 _\u27e9", "start": [757, 1], "end": [762, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.natTransOfLe", "code": "@[simps]\ndef natTransOfLe {S T : Sieve X} (h : S \u2264 T) : S.functor \u27f6 T.functor where app Y f := \u27e8f.1, h _ f.2\u27e9", "start": [765, 1], "end": [769, 101], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorInclusion", "code": "@[simps]\ndef functorInclusion (S : Sieve X) : S.functor \u27f6 yoneda.obj X where app Y f := f.1", "start": [772, 1], "end": [774, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.natTransOfLe_comm", "code": "theorem natTransOfLe_comm {S T : Sieve X} (h : S \u2264 T) :\n    natTransOfLe h \u226b functorInclusion _ = functorInclusion _", "start": [777, 1], "end": [779, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorInclusion_is_mono", "code": "instance functorInclusion_is_mono : Mono S.functorInclusion :=\n  \u27e8fun f g h => by\n    ext Y y\n    simpa [Subtype.ext_iff_val] using congr_fun (NatTrans.congr_app h Y) y\u27e9", "start": [782, 1], "end": [786, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.sieveOfSubfunctor", "code": "@[simps]\ndef sieveOfSubfunctor {R} (f : R \u27f6 yoneda.obj X) : Sieve X\n    where\n  arrows Y g := \u2203 t, f.app (Opposite.op Y) t = g\n  downward_closed := by\n    rintro Y Z _ \u27e8t, rfl\u27e9 g\n    refine' \u27e8R.map g.op t, _\u27e9\n    rw [FunctorToTypes.naturality _ _ f]\n    simp", "start": [790, 1], "end": [801, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.sieveOfSubfunctor_functorInclusion", "code": "theorem sieveOfSubfunctor_functorInclusion : sieveOfSubfunctor S.functorInclusion = S", "start": [804, 1], "end": [811, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sieve.functorInclusion_top_isIso", "code": "instance functorInclusion_top_isIso : IsIso (\u22a4 : Sieve X).functorInclusion :=\n  \u27e8\u27e8{ app := fun Y a => \u27e8a, \u27e8\u27e9\u27e9 }, rfl, rfl\u27e9\u27e9", "start": [814, 1], "end": [815, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Products.lean", "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean", "Mathlib/CategoryTheory/Limits/ConeCategory.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.WalkingMulticospan", "code": "inductive WalkingMulticospan {L R : Type w} (fst snd : R \u2192 L) : Type w\n  | left : L \u2192 WalkingMulticospan fst snd\n  | right : R \u2192 WalkingMulticospan fst snd", "start": [38, 1], "end": [42, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingMultispan", "code": "inductive WalkingMultispan {L R : Type w} (fst snd : L \u2192 R) : Type w\n  | left : L \u2192 WalkingMultispan fst snd\n  | right : R \u2192 WalkingMultispan fst snd", "start": [45, 1], "end": [49, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingMulticospan.Hom", "code": "inductive Hom : \u2200 _ _ : WalkingMulticospan fst snd, Type w\n  | id (A) : Hom A A\n  | fst (b) : Hom (left (fst b)) (right b)\n  | snd (b) : Hom (left (snd b)) (right b)", "start": [59, 1], "end": [63, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingMulticospan.Hom.comp", "code": "def Hom.comp : \u2200 {A B C : WalkingMulticospan fst snd} (_ : Hom A B) (_ : Hom B C), Hom A C\n  | _, _, _, Hom.id X, f => f\n  | _, _, _, Hom.fst b, Hom.id _ => Hom.fst b\n  | _, _, _, Hom.snd b, Hom.id _ => Hom.snd b", "start": [73, 1], "end": [77, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingMulticospan.Hom.id_eq_id", "code": "@[simp] lemma Hom.id_eq_id (X : WalkingMulticospan fst snd) :\n    Hom.id X = \ud835\udfd9 X := rfl", "start": [91, 1], "end": [93, 26], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.WalkingMulticospan.Hom.comp_eq_comp", "code": "@[simp] lemma Hom.comp_eq_comp {X Y Z : WalkingMulticospan fst snd}\n    (f : X \u27f6 Y) (g : Y \u27f6 Z) : Hom.comp f g = f \u226b g := rfl", "start": [95, 1], "end": [97, 58], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.WalkingMultispan.Hom", "code": "inductive Hom : \u2200 _ _ : WalkingMultispan fst snd, Type v\n  | id (A) : Hom A A\n  | fst (a) : Hom (left a) (right (fst a))\n  | snd (a) : Hom (left a) (right (snd a))", "start": [108, 1], "end": [112, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingMultispan.Hom.comp", "code": "def Hom.comp : \u2200 {A B C : WalkingMultispan fst snd} (_ : Hom A B) (_ : Hom B C), Hom A C\n  | _, _, _, Hom.id X, f => f\n  | _, _, _, Hom.fst a, Hom.id _ => Hom.fst a\n  | _, _, _, Hom.snd a, Hom.id _ => Hom.snd a", "start": [122, 1], "end": [126, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingMultispan.Hom.id_eq_id", "code": "@[simp] lemma Hom.id_eq_id (X : WalkingMultispan fst snd) : Hom.id X = \ud835\udfd9 X := rfl", "start": [140, 1], "end": [141, 74], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.WalkingMultispan.Hom.comp_eq_comp", "code": "@[simp] lemma Hom.comp_eq_comp {X Y Z : WalkingMultispan fst snd}\n    (f : X \u27f6 Y) (g : Y \u27f6 Z) : Hom.comp f g = f \u226b g := rfl", "start": [143, 1], "end": [145, 58], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.MulticospanIndex", "code": "structure MulticospanIndex (C : Type u) [Category.{v} C] where\n  (L R : Type w)\n  (fstTo sndTo : R \u2192 L)\n  left : L \u2192 C\n  right : R \u2192 C\n  fst : \u2200 b, left (fstTo b) \u27f6 right b\n  snd : \u2200 b, left (sndTo b) \u27f6 right b", "start": [149, 1], "end": [157, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MultispanIndex", "code": "structure MultispanIndex (C : Type u) [Category.{v} C] where\n  (L R : Type w)\n  (fstFrom sndFrom : L \u2192 R)\n  left : L \u2192 C\n  right : R \u2192 C\n  fst : \u2200 a, left a \u27f6 right (fstFrom a)\n  snd : \u2200 a, left a \u27f6 right (sndFrom a)", "start": [160, 1], "end": [168, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MulticospanIndex.multicospan", "code": "def multicospan : WalkingMulticospan I.fstTo I.sndTo \u2964 C where\n  obj x :=\n    match x with\n    | WalkingMulticospan.left a => I.left a\n    | WalkingMulticospan.right b => I.right b\n  map {x y} f :=\n    match x, y, f with\n    | _, _, WalkingMulticospan.Hom.id x => \ud835\udfd9 _\n    | _, _, WalkingMulticospan.Hom.fst b => I.fst _\n    | _, _, WalkingMulticospan.Hom.snd b => I.snd _\n  map_id := by\n    rintro (_ | _) <;> rfl\n  map_comp := by\n    rintro (_ | _) (_ | _) (_ | _) (_ | _ | _) (_ | _ | _) <;> aesop_cat", "start": [175, 1], "end": [189, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MulticospanIndex.multicospan_obj_left", "code": "@[simp]\ntheorem multicospan_obj_left (a) : I.multicospan.obj (WalkingMulticospan.left a) = I.left a", "start": [192, 1], "end": [194, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MulticospanIndex.multicospan_obj_right", "code": "@[simp]\ntheorem multicospan_obj_right (b) : I.multicospan.obj (WalkingMulticospan.right b) = I.right b", "start": [197, 1], "end": [199, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MulticospanIndex.multicospan_map_fst", "code": "@[simp]\ntheorem multicospan_map_fst (b) : I.multicospan.map (WalkingMulticospan.Hom.fst b) = I.fst b", "start": [202, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MulticospanIndex.multicospan_map_snd", "code": "@[simp]\ntheorem multicospan_map_snd (b) : I.multicospan.map (WalkingMulticospan.Hom.snd b) = I.snd b", "start": [207, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MulticospanIndex.fstPiMap", "code": "noncomputable def fstPiMap : \u220f I.left \u27f6 \u220f I.right :=\n  Pi.lift fun b => Pi.\u03c0 I.left (I.fstTo b) \u226b I.fst b", "start": [214, 1], "end": [216, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MulticospanIndex.sndPiMap", "code": "noncomputable def sndPiMap : \u220f I.left \u27f6 \u220f I.right :=\n  Pi.lift fun b => Pi.\u03c0 I.left (I.sndTo b) \u226b I.snd b", "start": [219, 1], "end": [221, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MulticospanIndex.fstPiMap_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem fstPiMap_\u03c0 (b) : I.fstPiMap \u226b Pi.\u03c0 I.right b = Pi.\u03c0 I.left _ \u226b I.fst b", "start": [224, 1], "end": [226, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MulticospanIndex.sndPiMap_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem sndPiMap_\u03c0 (b) : I.sndPiMap \u226b Pi.\u03c0 I.right b = Pi.\u03c0 I.left _ \u226b I.snd b", "start": [229, 1], "end": [231, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MulticospanIndex.parallelPairDiagram", "code": "@[simps!]\nprotected noncomputable def parallelPairDiagram :=\n  parallelPair I.fstPiMap I.sndPiMap", "start": [234, 1], "end": [239, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MultispanIndex.multispan", "code": "def multispan : WalkingMultispan I.fstFrom I.sndFrom \u2964 C where\n  obj x :=\n    match x with\n    | WalkingMultispan.left a => I.left a\n    | WalkingMultispan.right b => I.right b\n  map {x y} f :=\n    match x, y, f with\n    | _, _, WalkingMultispan.Hom.id x => \ud835\udfd9 _\n    | _, _, WalkingMultispan.Hom.fst b => I.fst _\n    | _, _, WalkingMultispan.Hom.snd b => I.snd _\n  map_id := by\n    rintro (_ | _) <;> rfl\n  map_comp := by\n    rintro (_ | _) (_ | _) (_ | _) (_ | _ | _) (_ | _ | _) <;> aesop_cat", "start": [248, 1], "end": [262, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MultispanIndex.multispan_obj_left", "code": "@[simp]\ntheorem multispan_obj_left (a) : I.multispan.obj (WalkingMultispan.left a) = I.left a", "start": [265, 1], "end": [267, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MultispanIndex.multispan_obj_right", "code": "@[simp]\ntheorem multispan_obj_right (b) : I.multispan.obj (WalkingMultispan.right b) = I.right b", "start": [270, 1], "end": [272, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MultispanIndex.multispan_map_fst", "code": "@[simp]\ntheorem multispan_map_fst (a) : I.multispan.map (WalkingMultispan.Hom.fst a) = I.fst a", "start": [275, 1], "end": [277, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MultispanIndex.multispan_map_snd", "code": "@[simp]\ntheorem multispan_map_snd (a) : I.multispan.map (WalkingMultispan.Hom.snd a) = I.snd a", "start": [280, 1], "end": [282, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MultispanIndex.fstSigmaMap", "code": "noncomputable def fstSigmaMap : \u2210 I.left \u27f6 \u2210 I.right :=\n  Sigma.desc fun b => I.fst b \u226b Sigma.\u03b9 _ (I.fstFrom b)", "start": [287, 1], "end": [289, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MultispanIndex.sndSigmaMap", "code": "noncomputable def sndSigmaMap : \u2210 I.left \u27f6 \u2210 I.right :=\n  Sigma.desc fun b => I.snd b \u226b Sigma.\u03b9 _ (I.sndFrom b)", "start": [292, 1], "end": [294, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MultispanIndex.\u03b9_fstSigmaMap", "code": "@[reassoc (attr := simp)]\ntheorem \u03b9_fstSigmaMap (b) : Sigma.\u03b9 I.left b \u226b I.fstSigmaMap = I.fst b \u226b Sigma.\u03b9 I.right _", "start": [297, 1], "end": [299, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MultispanIndex.\u03b9_sndSigmaMap", "code": "@[reassoc (attr := simp)]\ntheorem \u03b9_sndSigmaMap (b) : Sigma.\u03b9 I.left b \u226b I.sndSigmaMap = I.snd b \u226b Sigma.\u03b9 I.right _", "start": [302, 1], "end": [304, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MultispanIndex.parallelPairDiagram", "code": "protected noncomputable abbrev parallelPairDiagram :=\n  parallelPair I.fstSigmaMap I.sndSigmaMap", "start": [307, 1], "end": [312, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork", "code": "abbrev Multifork (I : MulticospanIndex.{w} C) :=\n  Cone I.multicospan", "start": [319, 1], "end": [322, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork", "code": "abbrev Multicofork (I : MultispanIndex.{w} C) :=\n  Cocone I.multispan", "start": [325, 1], "end": [328, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.\u03b9", "code": "def \u03b9 (a : I.L) : K.pt \u27f6 I.left a :=\n  K.\u03c0.app (WalkingMulticospan.left _)", "start": [335, 1], "end": [337, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.app_left_eq_\u03b9", "code": "@[simp]\ntheorem app_left_eq_\u03b9 (a) : K.\u03c0.app (WalkingMulticospan.left a) = K.\u03b9 a", "start": [340, 1], "end": [342, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.app_right_eq_\u03b9_comp_fst", "code": "@[simp]\ntheorem app_right_eq_\u03b9_comp_fst (b) :\n    K.\u03c0.app (WalkingMulticospan.right b) = K.\u03b9 (I.fstTo b) \u226b I.fst b", "start": [345, 1], "end": [349, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.app_right_eq_\u03b9_comp_snd", "code": "@[reassoc]\ntheorem app_right_eq_\u03b9_comp_snd (b) :\n    K.\u03c0.app (WalkingMulticospan.right b) = K.\u03b9 (I.sndTo b) \u226b I.snd b", "start": [352, 1], "end": [356, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.hom_comp_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem hom_comp_\u03b9 (K\u2081 K\u2082 : Multifork I) (f : K\u2081 \u27f6 K\u2082) (j : I.L) : f.hom \u226b K\u2082.\u03b9 j = K\u2081.\u03b9 j", "start": [359, 1], "end": [361, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.of\u03b9", "code": "@[simps]\ndef of\u03b9 (I : MulticospanIndex.{w} C) (P : C) (\u03b9 : \u2200 a, P \u27f6 I.left a)\n    (w : \u2200 b, \u03b9 (I.fstTo b) \u226b I.fst b = \u03b9 (I.sndTo b) \u226b I.snd b) : Multifork I where\n  pt := P\n  \u03c0 :=\n    { app := fun x =>\n        match x with\n        | WalkingMulticospan.left a => \u03b9 _\n        | WalkingMulticospan.right b => \u03b9 (I.fstTo b) \u226b I.fst b\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;>\n          dsimp <;>\n          simp only [Category.id_comp, Category.comp_id, Functor.map_id,\n            MulticospanIndex.multicospan_obj_left, MulticospanIndex.multicospan_obj_right]\n        apply w }", "start": [364, 1], "end": [379, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.condition", "code": "@[reassoc (attr := simp)]\ntheorem condition (b) : K.\u03b9 (I.fstTo b) \u226b I.fst b = K.\u03b9 (I.sndTo b) \u226b I.snd b", "start": [382, 1], "end": [384, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.IsLimit.mk", "code": "@[simps]\ndef IsLimit.mk (lift : \u2200 E : Multifork I, E.pt \u27f6 K.pt)\n    (fac : \u2200 (E : Multifork I) (i : I.L), lift E \u226b K.\u03b9 i = E.\u03b9 i)\n    (uniq : \u2200 (E : Multifork I) (m : E.pt \u27f6 K.pt), (\u2200 i : I.L, m \u226b K.\u03b9 i = E.\u03b9 i) \u2192 m = lift E) :\n    IsLimit K :=\n  { lift\n    fac := by\n      rintro E (a | b)\n      \u00b7 apply fac\n      \u00b7 rw [\u2190 E.w (WalkingMulticospan.Hom.fst b), \u2190 K.w (WalkingMulticospan.Hom.fst b), \u2190\n          Category.assoc]\n        congr 1\n        apply fac\n    uniq := by\n      rintro E m hm\n      apply uniq\n      intro i\n      apply hm }", "start": [387, 1], "end": [405, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.pi_condition", "code": "@[reassoc (attr := simp)]\ntheorem pi_condition : Pi.lift K.\u03b9 \u226b I.fstPiMap = Pi.lift K.\u03b9 \u226b I.sndPiMap", "start": [410, 1], "end": [413, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.toPiFork", "code": "@[simps pt]\nnoncomputable def toPiFork (K : Multifork I) : Fork I.fstPiMap I.sndPiMap where\n  pt := K.pt\n  \u03c0 :=\n    { app := fun x =>\n        match x with\n        | WalkingParallelPair.zero => Pi.lift K.\u03b9\n        | WalkingParallelPair.one => Pi.lift K.\u03b9 \u226b I.fstPiMap\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;>\n          dsimp <;>\n          simp only [Category.id_comp, Functor.map_id, parallelPair_obj_zero, Category.comp_id,\n            pi_condition, parallelPair_obj_one] }", "start": [416, 1], "end": [429, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.toPiFork_\u03c0_app_zero", "code": "@[simp]\ntheorem toPiFork_\u03c0_app_zero : K.toPiFork.\u03b9 = Pi.lift K.\u03b9", "start": [432, 1], "end": [434, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.toPiFork_\u03c0_app_one", "code": "@[simp, nolint simpNF] theorem toPiFork_\u03c0_app_one : K.toPiFork.\u03c0.app WalkingParallelPair.one = Pi.lift K.\u03b9 \u226b I.fstPiMap", "start": [437, 1], "end": [439, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.ofPiFork", "code": "@[simps pt]\nnoncomputable def ofPiFork (c : Fork I.fstPiMap I.sndPiMap) : Multifork I where\n  pt := c.pt\n  \u03c0 :=\n    { app := fun x =>\n        match x with\n        | WalkingMulticospan.left a => c.\u03b9 \u226b Pi.\u03c0 _ _\n        | WalkingMulticospan.right b => c.\u03b9 \u226b I.fstPiMap \u226b Pi.\u03c0 _ _\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _)\n        \u00b7 simp\n        \u00b7 simp\n        \u00b7 dsimp; rw [c.condition_assoc]; simp\n        \u00b7 simp }", "start": [444, 1], "end": [458, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.ofPiFork_\u03c0_app_left", "code": "@[simp]\ntheorem ofPiFork_\u03c0_app_left (c : Fork I.fstPiMap I.sndPiMap) (a) :\n    (ofPiFork I c).\u03b9 a = c.\u03b9 \u226b Pi.\u03c0 _ _", "start": [461, 1], "end": [464, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multifork.ofPiFork_\u03c0_app_right", "code": "@[simp, nolint simpNF] theorem ofPiFork_\u03c0_app_right (c : Fork I.fstPiMap I.sndPiMap) (a) :\n    (ofPiFork I c).\u03c0.app (WalkingMulticospan.right a) = c.\u03b9 \u226b I.fstPiMap \u226b Pi.\u03c0 _ _", "start": [467, 1], "end": [470, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MulticospanIndex.toPiForkFunctor", "code": "@[simps]\nnoncomputable def toPiForkFunctor : Multifork I \u2964 Fork I.fstPiMap I.sndPiMap where\n  obj := Multifork.toPiFork\n  map {K\u2081 K\u2082} f :=\n    { hom := f.hom\n      w := by\n        rintro (_ | _)\n        \u00b7 apply limit.hom_ext\n          simp\n        \u00b7 apply limit.hom_ext\n          intros j\n          simp only [Multifork.toPiFork_\u03c0_app_one, Multifork.pi_condition, Category.assoc]\n          dsimp [sndPiMap]\n          simp }", "start": [481, 1], "end": [495, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MulticospanIndex.ofPiForkFunctor", "code": "@[simps]\nnoncomputable def ofPiForkFunctor : Fork I.fstPiMap I.sndPiMap \u2964 Multifork I where\n  obj := Multifork.ofPiFork I\n  map {K\u2081 K\u2082} f :=\n    { hom := f.hom\n      w := by rintro (_ | _) <;> simp }", "start": [498, 1], "end": [504, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MulticospanIndex.multiforkEquivPiFork", "code": "@[simps]\nnoncomputable def multiforkEquivPiFork : Multifork I \u224c Fork I.fstPiMap I.sndPiMap where\n  functor := toPiForkFunctor I\n  inverse := ofPiForkFunctor I\n  unitIso :=\n    NatIso.ofComponents fun K =>\n      Cones.ext (Iso.refl _) (by\n        rintro (_ | _) <;> dsimp <;>\n          simp [\u2190 Fork.app_one_eq_\u03b9_comp_left, -Fork.app_one_eq_\u03b9_comp_left])\n  counitIso :=\n    NatIso.ofComponents fun K => Fork.ext (Iso.refl _)", "start": [507, 1], "end": [521, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork.\u03c0", "code": "def \u03c0 (b : I.R) : I.right b \u27f6 K.pt :=\n  K.\u03b9.app (WalkingMultispan.right _)", "start": [530, 1], "end": [532, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork.\u03c0_eq_app_right", "code": "@[simp]\ntheorem \u03c0_eq_app_right (b) : K.\u03b9.app (WalkingMultispan.right _) = K.\u03c0 b", "start": [535, 1], "end": [537, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork.fst_app_right", "code": "@[simp]\ntheorem fst_app_right (a) : K.\u03b9.app (WalkingMultispan.left a) = I.fst a \u226b K.\u03c0 _", "start": [540, 1], "end": [543, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork.snd_app_right", "code": "@[reassoc]\ntheorem snd_app_right (a) : K.\u03b9.app (WalkingMultispan.left a) = I.snd a \u226b K.\u03c0 _", "start": [546, 1], "end": [549, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork.\u03c0_comp_hom", "code": "@[reassoc (attr := simp)] lemma \u03c0_comp_hom (K\u2081 K\u2082 : Multicofork I) (f : K\u2081 \u27f6 K\u2082) (b : I.R) : K\u2081.\u03c0 b \u226b f.hom = K\u2082.\u03c0 b :=\n  f.w _", "start": [552, 1], "end": [554, 8], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Multicofork.of\u03c0", "code": "@[simps]\ndef of\u03c0 (I : MultispanIndex.{w} C) (P : C) (\u03c0 : \u2200 b, I.right b \u27f6 P)\n    (w : \u2200 a, I.fst a \u226b \u03c0 (I.fstFrom a) = I.snd a \u226b \u03c0 (I.sndFrom a)) : Multicofork I where\n  pt := P\n  \u03b9 :=\n    { app := fun x =>\n        match x with\n        | WalkingMultispan.left a => I.fst a \u226b \u03c0 _\n        | WalkingMultispan.right b => \u03c0 _\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;> dsimp <;>\n          simp only [Functor.map_id, MultispanIndex.multispan_obj_left,\n            Category.id_comp, Category.comp_id, MultispanIndex.multispan_obj_right]\n        symm\n        apply w }", "start": [556, 1], "end": [571, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork.condition", "code": "@[reassoc (attr := simp)]\ntheorem condition (a) : I.fst a \u226b K.\u03c0 (I.fstFrom a) = I.snd a \u226b K.\u03c0 (I.sndFrom a)", "start": [574, 1], "end": [576, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork.IsColimit.mk", "code": "@[simps]\ndef IsColimit.mk (desc : \u2200 E : Multicofork I, K.pt \u27f6 E.pt)\n    (fac : \u2200 (E : Multicofork I) (i : I.R), K.\u03c0 i \u226b desc E = E.\u03c0 i)\n    (uniq : \u2200 (E : Multicofork I) (m : K.pt \u27f6 E.pt), (\u2200 i : I.R, K.\u03c0 i \u226b m = E.\u03c0 i) \u2192 m = desc E) :\n    IsColimit K :=\n  { desc\n    fac := by\n      rintro S (a | b)\n      \u00b7 rw [\u2190 K.w (WalkingMultispan.Hom.fst a), \u2190 S.w (WalkingMultispan.Hom.fst a),\n          Category.assoc]\n        congr 1\n        apply fac\n      \u00b7 apply fac\n    uniq := by\n      intro S m hm\n      apply uniq\n      intro i\n      apply hm }", "start": [579, 1], "end": [597, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork.sigma_condition", "code": "@[reassoc (attr := simp)]\ntheorem sigma_condition : I.fstSigmaMap \u226b Sigma.desc K.\u03c0 = I.sndSigmaMap \u226b Sigma.desc K.\u03c0", "start": [602, 1], "end": [605, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork.toSigmaCofork", "code": "@[simps pt]\nnoncomputable def toSigmaCofork (K : Multicofork I) : Cofork I.fstSigmaMap I.sndSigmaMap where\n  pt := K.pt\n  \u03b9 :=\n    { app := fun x =>\n        match x with\n        | WalkingParallelPair.zero => I.fstSigmaMap \u226b Sigma.desc K.\u03c0\n        | WalkingParallelPair.one => Sigma.desc K.\u03c0\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _) <;> dsimp <;>\n          simp only [Functor.map_id, parallelPair_obj_zero,\n            parallelPair_obj_one, sigma_condition, Category.id_comp, Category.comp_id] }", "start": [608, 1], "end": [620, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork.toSigmaCofork_\u03c0", "code": "@[simp]\ntheorem toSigmaCofork_\u03c0 : K.toSigmaCofork.\u03c0 = Sigma.desc K.\u03c0", "start": [623, 1], "end": [625, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork.ofSigmaCofork", "code": "@[simps pt]\nnoncomputable def ofSigmaCofork (c : Cofork I.fstSigmaMap I.sndSigmaMap) : Multicofork I where\n  pt := c.pt\n  \u03b9 :=\n    { app := fun x =>\n        match x with\n        | WalkingMultispan.left a => (Sigma.\u03b9 I.left a : _) \u226b I.fstSigmaMap \u226b c.\u03c0\n        | WalkingMultispan.right b => (Sigma.\u03b9 I.right b : _) \u226b c.\u03c0\n      naturality := by\n        rintro (_ | _) (_ | _) (_ | _ | _)\n        \u00b7 simp\n        \u00b7 simp\n        \u00b7 simp [c.condition]\n        \u00b7 simp }", "start": [630, 1], "end": [644, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork.ofSigmaCofork_\u03b9_app_left", "code": "@[simp, nolint simpNF]\ntheorem ofSigmaCofork_\u03b9_app_left (c : Cofork I.fstSigmaMap I.sndSigmaMap) (a) :\n    (ofSigmaCofork I c).\u03b9.app (WalkingMultispan.left a) =\n      (Sigma.\u03b9 I.left a : _) \u226b I.fstSigmaMap \u226b c.\u03c0", "start": [648, 1], "end": [652, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork.ofSigmaCofork_\u03b9_app_right", "code": "theorem ofSigmaCofork_\u03b9_app_right (c : Cofork I.fstSigmaMap I.sndSigmaMap) (b) :\n    (ofSigmaCofork I c).\u03b9.app (WalkingMultispan.right b) = (Sigma.\u03b9 I.right b : _) \u226b c.\u03c0", "start": [656, 1], "end": [658, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicofork.ofSigmaCofork_\u03b9_app_right'", "code": "@[simp]\ntheorem ofSigmaCofork_\u03b9_app_right' (c : Cofork I.fstSigmaMap I.sndSigmaMap) (b) :\n    \u03c0 (ofSigmaCofork I c) b = (Sigma.\u03b9 I.right b : _) \u226b c.\u03c0", "start": [661, 1], "end": [664, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MultispanIndex.toSigmaCoforkFunctor", "code": "@[simps]\nnoncomputable def toSigmaCoforkFunctor : Multicofork I \u2964 Cofork I.fstSigmaMap I.sndSigmaMap where\n  obj := Multicofork.toSigmaCofork\n  map {K\u2081 K\u2082} f :=\n  { hom := f.hom\n    w := by\n      rintro (_|_)\n      all_goals {\n        apply colimit.hom_ext\n        rintro \u27e8j\u27e9\n        simp } }", "start": [674, 1], "end": [685, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MultispanIndex.ofSigmaCoforkFunctor", "code": "@[simps]\nnoncomputable def ofSigmaCoforkFunctor : Cofork I.fstSigmaMap I.sndSigmaMap \u2964 Multicofork I where\n  obj := Multicofork.ofSigmaCofork I\n  map {K\u2081 K\u2082} f :=\n    { hom := f.hom\n      w := by rintro (_ | _)\n        { simp [-Multicofork.fst_app_right] }\n        { simp [-Multicofork.ofSigmaCofork_pt] } }", "start": [688, 1], "end": [702, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MultispanIndex.multicoforkEquivSigmaCofork", "code": "@[simps]\nnoncomputable def multicoforkEquivSigmaCofork :\n    Multicofork I \u224c Cofork I.fstSigmaMap I.sndSigmaMap where\n  functor := toSigmaCoforkFunctor I\n  inverse := ofSigmaCoforkFunctor I\n  unitIso := NatIso.ofComponents fun K => Cocones.ext (Iso.refl _) (by\n      rintro (_ | _) <;> simp)\n  counitIso := NatIso.ofComponents fun K =>\n    Cofork.ext (Iso.refl _)\n      (by\n        apply Limits.colimit.hom_ext\n        rintro \u27e8j\u27e9\n        dsimp\n        simp only [Category.comp_id, colimit.\u03b9_desc, Cofan.mk_\u03b9_app]\n        rfl)", "start": [704, 1], "end": [724, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasMultiequalizer", "code": "abbrev HasMultiequalizer (I : MulticospanIndex.{w} C) :=\n  HasLimit I.multicospan", "start": [729, 1], "end": [732, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.multiequalizer", "code": "abbrev multiequalizer (I : MulticospanIndex.{w} C) [HasMultiequalizer I] : C :=\n  limit I.multicospan", "start": [737, 1], "end": [739, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasMulticoequalizer", "code": "abbrev HasMulticoequalizer (I : MultispanIndex.{w} C) :=\n  HasColimit I.multispan", "start": [742, 1], "end": [745, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.multicoequalizer", "code": "abbrev multicoequalizer (I : MultispanIndex.{w} C) [HasMulticoequalizer I] : C :=\n  colimit I.multispan", "start": [748, 1], "end": [750, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multiequalizer.\u03b9", "code": "abbrev \u03b9 (a : I.L) : multiequalizer I \u27f6 I.left a :=\n  limit.\u03c0 _ (WalkingMulticospan.left a)", "start": [757, 1], "end": [759, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multiequalizer.multifork", "code": "abbrev multifork : Multifork I :=\n  limit.cone _", "start": [762, 1], "end": [764, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multiequalizer.multifork_\u03b9", "code": "@[simp]\ntheorem multifork_\u03b9 (a) : (Multiequalizer.multifork I).\u03b9 a = Multiequalizer.\u03b9 I a", "start": [767, 1], "end": [769, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multiequalizer.multifork_\u03c0_app_left", "code": "@[simp]\ntheorem multifork_\u03c0_app_left (a) :\n    (Multiequalizer.multifork I).\u03c0.app (WalkingMulticospan.left a) = Multiequalizer.\u03b9 I a", "start": [772, 1], "end": [775, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multiequalizer.condition", "code": "@[reassoc]\ntheorem condition (b) :\n    Multiequalizer.\u03b9 I (I.fstTo b) \u226b I.fst b = Multiequalizer.\u03b9 I (I.sndTo b) \u226b I.snd b", "start": [778, 1], "end": [781, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multiequalizer.lift", "code": "abbrev lift (W : C) (k : \u2200 a, W \u27f6 I.left a)\n    (h : \u2200 b, k (I.fstTo b) \u226b I.fst b = k (I.sndTo b) \u226b I.snd b) : W \u27f6 multiequalizer I :=\n  limit.lift _ (Multifork.of\u03b9 I _ k h)", "start": [784, 1], "end": [787, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multiequalizer.lift_\u03b9", "code": "@[reassoc] theorem lift_\u03b9 (W : C) (k : \u2200 a, W \u27f6 I.left a)\n    (h : \u2200 b, k (I.fstTo b) \u226b I.fst b = k (I.sndTo b) \u226b I.snd b) (a) :\n    Multiequalizer.lift I _ k h \u226b Multiequalizer.\u03b9 I a = k _", "start": [790, 1], "end": [794, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multiequalizer.hom_ext", "code": "@[ext]\ntheorem hom_ext {W : C} (i j : W \u27f6 multiequalizer I)\n    (h : \u2200 a, i \u226b Multiequalizer.\u03b9 I a = j \u226b Multiequalizer.\u03b9 I a) : i = j", "start": [797, 1], "end": [804, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multiequalizer.isoEqualizer", "code": "def isoEqualizer : multiequalizer I \u2245 equalizer I.fstPiMap I.sndPiMap :=\n  limit.isoLimitCone\n    \u27e8_, IsLimit.ofPreservesConeTerminal I.multiforkEquivPiFork.inverse (limit.isLimit _)\u27e9", "start": [812, 1], "end": [815, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multiequalizer.\u03b9Pi", "code": "def \u03b9Pi : multiequalizer I \u27f6 \u220f I.left :=\n  (isoEqualizer I).hom \u226b equalizer.\u03b9 I.fstPiMap I.sndPiMap", "start": [818, 1], "end": [820, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multiequalizer.\u03b9Pi_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem \u03b9Pi_\u03c0 (a) : \u03b9Pi I \u226b Pi.\u03c0 I.left a = \u03b9 I a", "start": [823, 1], "end": [826, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicoequalizer.\u03c0", "code": "abbrev \u03c0 (b : I.R) : I.right b \u27f6 multicoequalizer I :=\n  colimit.\u03b9 I.multispan (WalkingMultispan.right _)", "start": [837, 1], "end": [839, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicoequalizer.multicofork", "code": "abbrev multicofork : Multicofork I :=\n  colimit.cocone _", "start": [842, 1], "end": [844, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicoequalizer.multicofork_\u03c0", "code": "@[simp]\ntheorem multicofork_\u03c0 (b) : (Multicoequalizer.multicofork I).\u03c0 b = Multicoequalizer.\u03c0 I b", "start": [847, 1], "end": [849, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicoequalizer.multicofork_\u03b9_app_right", "code": "theorem multicofork_\u03b9_app_right (b) :\n    (Multicoequalizer.multicofork I).\u03b9.app (WalkingMultispan.right b) = Multicoequalizer.\u03c0 I b", "start": [853, 1], "end": [855, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicoequalizer.multicofork_\u03b9_app_right'", "code": "@[simp]\ntheorem multicofork_\u03b9_app_right' (b) :\n    colimit.\u03b9 (MultispanIndex.multispan I) (WalkingMultispan.right b) = \u03c0 I b", "start": [858, 1], "end": [861, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicoequalizer.condition", "code": "@[reassoc]\ntheorem condition (a) :\n    I.fst a \u226b Multicoequalizer.\u03c0 I (I.fstFrom a) = I.snd a \u226b Multicoequalizer.\u03c0 I (I.sndFrom a)", "start": [863, 1], "end": [866, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicoequalizer.desc", "code": "abbrev desc (W : C) (k : \u2200 b, I.right b \u27f6 W)\n    (h : \u2200 a, I.fst a \u226b k (I.fstFrom a) = I.snd a \u226b k (I.sndFrom a)) : multicoequalizer I \u27f6 W :=\n  colimit.desc _ (Multicofork.of\u03c0 I _ k h)", "start": [869, 1], "end": [872, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicoequalizer.\u03c0_desc", "code": "@[reassoc] theorem \u03c0_desc (W : C) (k : \u2200 b, I.right b \u27f6 W)\n    (h : \u2200 a, I.fst a \u226b k (I.fstFrom a) = I.snd a \u226b k (I.sndFrom a)) (b) :\n    Multicoequalizer.\u03c0 I b \u226b Multicoequalizer.desc I _ k h = k _", "start": [875, 1], "end": [879, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicoequalizer.hom_ext", "code": "@[ext]\ntheorem hom_ext {W : C} (i j : multicoequalizer I \u27f6 W)\n    (h : \u2200 b, Multicoequalizer.\u03c0 I b \u226b i = Multicoequalizer.\u03c0 I b \u226b j) : i = j", "start": [882, 1], "end": [889, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicoequalizer.isoCoequalizer", "code": "def isoCoequalizer : multicoequalizer I \u2245 coequalizer I.fstSigmaMap I.sndSigmaMap :=\n  colimit.isoColimitCocone\n    \u27e8_,\n      IsColimit.ofPreservesCoconeInitial I.multicoforkEquivSigmaCofork.inverse\n        (colimit.isColimit _)\u27e9", "start": [899, 1], "end": [904, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicoequalizer.sigma\u03c0", "code": "def sigma\u03c0 : \u2210 I.right \u27f6 multicoequalizer I :=\n  coequalizer.\u03c0 I.fstSigmaMap I.sndSigmaMap \u226b (isoCoequalizer I).inv", "start": [907, 1], "end": [909, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Multicoequalizer.\u03b9_sigma\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem \u03b9_sigma\u03c0 (b) : Sigma.\u03b9 I.right b \u226b sigma\u03c0 I = \u03c0 I b", "start": [912, 1], "end": [918, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Filtered/Basic.lean", "imports": ["Mathlib/CategoryTheory/Adjunction/Basic.lean", "Mathlib/CategoryTheory/FinCategory.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Category/Preorder.lean", "Mathlib/CategoryTheory/Category/ULift.lean", "Mathlib/CategoryTheory/Limits/Cones.lean"], "premises": [{"full_name": "CategoryTheory.IsFilteredOrEmpty", "code": "class IsFilteredOrEmpty : Prop where\n  \n  cocone_objs : \u2200 X Y : C, \u2203 (Z : _) (_ : X \u27f6 Z) (_ : Y \u27f6 Z), True\n  \n  cocone_maps : \u2200 \u2983X Y : C\u2984 (f g : X \u27f6 Y), \u2203 (Z : _) (h : Y \u27f6 Z), f \u226b h = g \u226b h", "start": [63, 1], "end": [73, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered", "code": "class IsFiltered extends IsFilteredOrEmpty C : Prop where\n  \n  [Nonempty : Nonempty C]", "start": [76, 1], "end": [86, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isFilteredOrEmpty_of_semilatticeSup", "code": "instance (priority := 100) isFilteredOrEmpty_of_semilatticeSup (\u03b1 : Type u) [SemilatticeSup \u03b1] :\n    IsFilteredOrEmpty \u03b1\n    where\n  cocone_objs X Y := \u27e8X \u2294 Y, homOfLE le_sup_left, homOfLE le_sup_right, trivial\u27e9\n  cocone_maps X Y f g := \u27e8Y, \ud835\udfd9 _, by\n    apply ULift.ext\n    apply Subsingleton.elim\u27e9", "start": [89, 1], "end": [95, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isFiltered_of_semilatticeSup_nonempty", "code": "instance (priority := 100) isFiltered_of_semilatticeSup_nonempty (\u03b1 : Type u) [SemilatticeSup \u03b1]\n    [Nonempty \u03b1] : IsFiltered \u03b1 where", "start": [98, 1], "end": [99, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isFilteredOrEmpty_of_directed_le", "code": "instance (priority := 100) isFilteredOrEmpty_of_directed_le (\u03b1 : Type u) [Preorder \u03b1]\n    [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] : IsFilteredOrEmpty \u03b1 where\n  cocone_objs X Y :=\n    let \u27e8Z, h1, h2\u27e9 := exists_ge_ge X Y\n    \u27e8Z, homOfLE h1, homOfLE h2, trivial\u27e9\n  cocone_maps X Y f g := \u27e8Y, \ud835\udfd9 _, by\n    apply ULift.ext\n    apply Subsingleton.elim\u27e9", "start": [102, 1], "end": [109, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isFiltered_of_directed_le_nonempty", "code": "instance (priority := 100) isFiltered_of_directed_le_nonempty (\u03b1 : Type u) [Preorder \u03b1]\n    [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] [Nonempty \u03b1] : IsFiltered \u03b1 where", "start": [112, 1], "end": [113, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.max", "code": "noncomputable def max (j j' : C) : C :=\n  (IsFilteredOrEmpty.cocone_objs j j').choose", "start": [146, 1], "end": [150, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.leftToMax", "code": "noncomputable def leftToMax (j j' : C) : j \u27f6 max j j' :=\n  (IsFilteredOrEmpty.cocone_objs j j').choose_spec.choose", "start": [153, 1], "end": [157, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.rightToMax", "code": "noncomputable def rightToMax (j j' : C) : j' \u27f6 max j j' :=\n  (IsFilteredOrEmpty.cocone_objs j j').choose_spec.choose_spec.choose", "start": [160, 1], "end": [164, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.coeq", "code": "noncomputable def coeq {j j' : C} (f f' : j \u27f6 j') : C :=\n  (IsFilteredOrEmpty.cocone_maps f f').choose", "start": [167, 1], "end": [173, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.coeqHom", "code": "noncomputable def coeqHom {j j' : C} (f f' : j \u27f6 j') : j' \u27f6 coeq f f' :=\n  (IsFilteredOrEmpty.cocone_maps f f').choose_spec.choose", "start": [176, 1], "end": [182, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.coeq_condition", "code": "@[reassoc]\ntheorem coeq_condition {j j' : C} (f f' : j \u27f6 j') : f \u226b coeqHom f f' = f' \u226b coeqHom f f'", "start": [186, 1], "end": [191, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFilteredOrEmpty.of_right_adjoint", "code": "theorem of_right_adjoint {L : D \u2964 C} {R : C \u2964 D} (h : L \u22a3 R) : IsFilteredOrEmpty D", "start": [205, 1], "end": [213, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint", "code": "theorem of_isRightAdjoint (R : C \u2964 D) [IsRightAdjoint R] : IsFilteredOrEmpty D", "start": [215, 1], "end": [218, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFilteredOrEmpty.of_equivalence", "code": "theorem of_equivalence (h : C \u224c D) : IsFilteredOrEmpty D", "start": [220, 1], "end": [222, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.sup_objs_exists", "code": "theorem sup_objs_exists (O : Finset C) : \u2203 S : C, \u2200 {X}, X \u2208 O \u2192 _root_.Nonempty (X \u27f6 S)", "start": [235, 1], "end": [246, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.sup_exists", "code": "theorem sup_exists :\n    \u2203 (S : C) (T : \u2200 {X : C}, X \u2208 O \u2192 (X \u27f6 S)),\n      \u2200 {X Y : C} (mX : X \u2208 O) (mY : Y \u2208 O) {f : X \u27f6 Y},\n        (\u27e8X, Y, mX, mY, f\u27e9 : \u03a3' (X Y : C) (_ : X \u2208 O) (_ : Y \u2208 O), X \u27f6 Y) \u2208 H \u2192\n          f \u226b T mY = T mX", "start": [251, 1], "end": [285, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.sup", "code": "noncomputable def sup : C :=\n  (sup_exists O H).choose", "start": [288, 1], "end": [293, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.toSup", "code": "noncomputable def toSup {X : C} (m : X \u2208 O) : X \u27f6 sup O H :=\n  (sup_exists O H).choose_spec.choose m", "start": [296, 1], "end": [299, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.toSup_commutes", "code": "theorem toSup_commutes {X Y : C} (mX : X \u2208 O) (mY : Y \u2208 O) {f : X \u27f6 Y}\n    (mf : (\u27e8X, Y, mX, mY, f\u27e9 : \u03a3' (X Y : C) (_ : X \u2208 O) (_ : Y \u2208 O), X \u27f6 Y) \u2208 H) :\n    f \u226b toSup O H mY = toSup O H mX", "start": [302, 1], "end": [307, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.cocone_nonempty", "code": "theorem cocone_nonempty (F : J \u2964 C) : _root_.Nonempty (Cocone F)", "start": [312, 1], "end": [330, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.cocone", "code": "noncomputable def cocone (F : J \u2964 C) : Cocone F :=\n  (cocone_nonempty F).some", "start": [333, 1], "end": [336, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.of_right_adjoint", "code": "theorem of_right_adjoint {L : D \u2964 C} {R : C \u2964 D} (h : L \u22a3 R) : IsFiltered D", "start": [341, 1], "end": [345, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.of_isRightAdjoint", "code": "theorem of_isRightAdjoint (R : C \u2964 D) [IsRightAdjoint R] : IsFiltered D", "start": [348, 1], "end": [350, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.of_equivalence", "code": "theorem of_equivalence (h : C \u224c D) : IsFiltered D", "start": [353, 1], "end": [355, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.max\u2083", "code": "noncomputable def max\u2083 (j\u2081 j\u2082 j\u2083 : C) : C :=\n  max (max j\u2081 j\u2082) j\u2083", "start": [365, 1], "end": [369, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.firstToMax\u2083", "code": "noncomputable def firstToMax\u2083 (j\u2081 j\u2082 j\u2083 : C) : j\u2081 \u27f6 max\u2083 j\u2081 j\u2082 j\u2083 :=\n  leftToMax j\u2081 j\u2082 \u226b leftToMax (max j\u2081 j\u2082) j\u2083", "start": [372, 1], "end": [376, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.secondToMax\u2083", "code": "noncomputable def secondToMax\u2083 (j\u2081 j\u2082 j\u2083 : C) : j\u2082 \u27f6 max\u2083 j\u2081 j\u2082 j\u2083 :=\n  rightToMax j\u2081 j\u2082 \u226b leftToMax (max j\u2081 j\u2082) j\u2083", "start": [379, 1], "end": [383, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.thirdToMax\u2083", "code": "noncomputable def thirdToMax\u2083 (j\u2081 j\u2082 j\u2083 : C) : j\u2083 \u27f6 max\u2083 j\u2081 j\u2082 j\u2083 :=\n  rightToMax (max j\u2081 j\u2082) j\u2083", "start": [386, 1], "end": [390, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.coeq\u2083", "code": "noncomputable def coeq\u2083 {j\u2081 j\u2082 : C} (f g h : j\u2081 \u27f6 j\u2082) : C :=\n  coeq (coeqHom f g \u226b leftToMax (coeq f g) (coeq g h))\n    (coeqHom g h \u226b rightToMax (coeq f g) (coeq g h))", "start": [393, 1], "end": [400, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.coeq\u2083Hom", "code": "noncomputable def coeq\u2083Hom {j\u2081 j\u2082 : C} (f g h : j\u2081 \u27f6 j\u2082) : j\u2082 \u27f6 coeq\u2083 f g h :=\n  coeqHom f g \u226b\n    leftToMax (coeq f g) (coeq g h) \u226b\n      coeqHom (coeqHom f g \u226b leftToMax (coeq f g) (coeq g h))\n        (coeqHom g h \u226b rightToMax (coeq f g) (coeq g h))", "start": [403, 1], "end": [411, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.coeq\u2083_condition\u2081", "code": "theorem coeq\u2083_condition\u2081 {j\u2081 j\u2082 : C} (f g h : j\u2081 \u27f6 j\u2082) : f \u226b coeq\u2083Hom f g h = g \u226b coeq\u2083Hom f g h", "start": [414, 1], "end": [415, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.coeq\u2083_condition\u2082", "code": "theorem coeq\u2083_condition\u2082 {j\u2081 j\u2082 : C} (f g h : j\u2081 \u27f6 j\u2082) :\n    g \u226b coeq\u2083Hom f g h = h \u226b coeq\u2083Hom f g h", "start": [418, 1], "end": [424, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.coeq\u2083_condition\u2083", "code": "theorem coeq\u2083_condition\u2083 {j\u2081 j\u2082 : C} (f g h : j\u2081 \u27f6 j\u2082) : f \u226b coeq\u2083Hom f g h = h \u226b coeq\u2083Hom f g h", "start": [427, 1], "end": [428, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.span", "code": "theorem span {i j j' : C} (f : i \u27f6 j) (f' : i \u27f6 j') :\n    \u2203 (k : C) (g : j \u27f6 k) (g' : j' \u27f6 k), f \u226b g = f' \u226b g'", "start": [431, 1], "end": [437, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.bowtie", "code": "theorem bowtie {j\u2081 j\u2082 k\u2081 k\u2082 : C} (f\u2081 : j\u2081 \u27f6 k\u2081) (g\u2081 : j\u2081 \u27f6 k\u2082) (f\u2082 : j\u2082 \u27f6 k\u2081) (g\u2082 : j\u2082 \u27f6 k\u2082) :\n    \u2203 (s : C) (\u03b1 : k\u2081 \u27f6 s) (\u03b2 : k\u2082 \u27f6 s), f\u2081 \u226b \u03b1 = g\u2081 \u226b \u03b2 \u2227 f\u2082 \u226b \u03b1 = g\u2082 \u226b \u03b2", "start": [440, 1], "end": [458, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.tulip", "code": "theorem tulip {j\u2081 j\u2082 j\u2083 k\u2081 k\u2082 l : C} (f\u2081 : j\u2081 \u27f6 k\u2081) (f\u2082 : j\u2082 \u27f6 k\u2081) (f\u2083 : j\u2082 \u27f6 k\u2082) (f\u2084 : j\u2083 \u27f6 k\u2082)\n    (g\u2081 : j\u2081 \u27f6 l) (g\u2082 : j\u2083 \u27f6 l) :\n    \u2203 (s : C) (\u03b1 : k\u2081 \u27f6 s) (\u03b2 : l \u27f6 s) (\u03b3 : k\u2082 \u27f6 s),\n      f\u2081 \u226b \u03b1 = g\u2081 \u226b \u03b2 \u2227 f\u2082 \u226b \u03b1 = f\u2083 \u226b \u03b3 \u2227 f\u2084 \u226b \u03b3 = g\u2082 \u226b \u03b2", "start": [461, 1], "end": [485, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofilteredOrEmpty", "code": "class IsCofilteredOrEmpty : Prop where\n  \n  cone_objs : \u2200 X Y : C, \u2203 (W : _) (_ : W \u27f6 X) (_ : W \u27f6 Y), True\n  \n  cone_maps : \u2200 \u2983X Y : C\u2984 (f g : X \u27f6 Y), \u2203 (W : _) (h : W \u27f6 X), h \u226b f = h \u226b g", "start": [492, 1], "end": [502, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered", "code": "class IsCofiltered extends IsCofilteredOrEmpty C : Prop where\n  \n  [Nonempty : Nonempty C]", "start": [505, 1], "end": [515, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf", "code": "instance (priority := 100) isCofilteredOrEmpty_of_semilatticeInf (\u03b1 : Type u) [SemilatticeInf \u03b1] :\n    IsCofilteredOrEmpty \u03b1 where\n  cone_objs X Y := \u27e8X \u2293 Y, homOfLE inf_le_left, homOfLE inf_le_right, trivial\u27e9\n  cone_maps X Y f g := \u27e8X, \ud835\udfd9 _, by\n    apply ULift.ext\n    apply Subsingleton.elim\u27e9", "start": [518, 1], "end": [523, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCofiltered_of_semilatticeInf_nonempty", "code": "instance (priority := 100) isCofiltered_of_semilatticeInf_nonempty (\u03b1 : Type u) [SemilatticeInf \u03b1]\n    [Nonempty \u03b1] : IsCofiltered \u03b1 where", "start": [526, 1], "end": [527, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCofilteredOrEmpty_of_directed_ge", "code": "instance (priority := 100) isCofilteredOrEmpty_of_directed_ge (\u03b1 : Type u) [Preorder \u03b1]\n    [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] : IsCofilteredOrEmpty \u03b1 where\n  cone_objs X Y :=\n    let \u27e8Z, hX, hY\u27e9 := exists_le_le X Y\n    \u27e8Z, homOfLE hX, homOfLE hY, trivial\u27e9\n  cone_maps X Y f g := \u27e8X, \ud835\udfd9 _, by\n    apply ULift.ext\n    apply Subsingleton.elim\u27e9", "start": [530, 1], "end": [537, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCofiltered_of_directed_ge_nonempty", "code": "instance (priority := 100) isCofiltered_of_directed_ge_nonempty (\u03b1 : Type u) [Preorder \u03b1]\n    [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] [Nonempty \u03b1] : IsCofiltered \u03b1 where", "start": [540, 1], "end": [541, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.min", "code": "noncomputable def min (j j' : C) : C :=\n  (IsCofilteredOrEmpty.cone_objs j j').choose", "start": [574, 1], "end": [578, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.minToLeft", "code": "noncomputable def minToLeft (j j' : C) : min j j' \u27f6 j :=\n  (IsCofilteredOrEmpty.cone_objs j j').choose_spec.choose", "start": [581, 1], "end": [585, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.minToRight", "code": "noncomputable def minToRight (j j' : C) : min j j' \u27f6 j' :=\n  (IsCofilteredOrEmpty.cone_objs j j').choose_spec.choose_spec.choose", "start": [588, 1], "end": [592, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.eq", "code": "noncomputable def eq {j j' : C} (f f' : j \u27f6 j') : C :=\n  (IsCofilteredOrEmpty.cone_maps f f').choose", "start": [595, 1], "end": [601, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.eqHom", "code": "noncomputable def eqHom {j j' : C} (f f' : j \u27f6 j') : eq f f' \u27f6 j :=\n  (IsCofilteredOrEmpty.cone_maps f f').choose_spec.choose", "start": [604, 1], "end": [610, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.eq_condition", "code": "@[reassoc]\ntheorem eq_condition {j j' : C} (f f' : j \u27f6 j') : eqHom f f' \u226b f = eqHom f f' \u226b f'", "start": [614, 1], "end": [619, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.cospan", "code": "theorem cospan {i j j' : C} (f : j \u27f6 i) (f' : j' \u27f6 i) :\n    \u2203 (k : C) (g : k \u27f6 j) (g' : k \u27f6 j'), g \u226b f = g' \u226b f'", "start": [622, 1], "end": [628, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.ranges_directed", "code": "theorem _root_.CategoryTheory.Functor.ranges_directed (F : C \u2964 Type*) (j : C) :\n    Directed (\u00b7 \u2287 \u00b7) fun f : \u03a3'i, i \u27f6 j => Set.range (F.map f.2)", "start": [631, 1], "end": [634, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint", "code": "theorem of_left_adjoint {L : C \u2964 D} {R : D \u2964 C} (h : L \u22a3 R) : IsCofilteredOrEmpty D", "start": [648, 1], "end": [657, 101], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint", "code": "theorem of_isLeftAdjoint (L : C \u2964 D) [IsLeftAdjoint L] : IsCofilteredOrEmpty D", "start": [659, 1], "end": [662, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofilteredOrEmpty.of_equivalence", "code": "theorem of_equivalence (h : C \u224c D) : IsCofilteredOrEmpty D", "start": [664, 1], "end": [666, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.inf_objs_exists", "code": "theorem inf_objs_exists (O : Finset C) : \u2203 S : C, \u2200 {X}, X \u2208 O \u2192 _root_.Nonempty (S \u27f6 X)", "start": [679, 1], "end": [690, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.inf_exists", "code": "theorem inf_exists :\n    \u2203 (S : C) (T : \u2200 {X : C}, X \u2208 O \u2192 (S \u27f6 X)),\n      \u2200 {X Y : C} (mX : X \u2208 O) (mY : Y \u2208 O) {f : X \u27f6 Y},\n        (\u27e8X, Y, mX, mY, f\u27e9 : \u03a3' (X Y : C) (_ : X \u2208 O) (_ : Y \u2208 O), X \u27f6 Y) \u2208 H \u2192\n          T mX \u226b f = T mY", "start": [695, 1], "end": [729, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.inf", "code": "noncomputable def inf : C :=\n  (inf_exists O H).choose", "start": [732, 1], "end": [737, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.infTo", "code": "noncomputable def infTo {X : C} (m : X \u2208 O) : inf O H \u27f6 X :=\n  (inf_exists O H).choose_spec.choose m", "start": [740, 1], "end": [743, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.infTo_commutes", "code": "theorem infTo_commutes {X Y : C} (mX : X \u2208 O) (mY : Y \u2208 O) {f : X \u27f6 Y}\n    (mf : (\u27e8X, Y, mX, mY, f\u27e9 : \u03a3' (X Y : C) (_ : X \u2208 O) (_ : Y \u2208 O), X \u27f6 Y) \u2208 H) :\n    infTo O H mX \u226b f = infTo O H mY", "start": [746, 1], "end": [751, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.cone_nonempty", "code": "theorem cone_nonempty (F : J \u2964 C) : _root_.Nonempty (Cone F)", "start": [756, 1], "end": [775, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.cone", "code": "noncomputable def cone (F : J \u2964 C) : Cone F :=\n  (cone_nonempty F).some", "start": [778, 1], "end": [781, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.of_left_adjoint", "code": "theorem of_left_adjoint {L : C \u2964 D} {R : D \u2964 C} (h : L \u22a3 R) : IsCofiltered D", "start": [786, 1], "end": [791, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.of_isLeftAdjoint", "code": "theorem of_isLeftAdjoint (L : C \u2964 D) [IsLeftAdjoint L] : IsCofiltered D", "start": [794, 1], "end": [796, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.of_equivalence", "code": "theorem of_equivalence (h : C \u224c D) : IsCofiltered D", "start": [799, 1], "end": [801, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty", "code": "instance isCofilteredOrEmpty_op_of_isFilteredOrEmpty [IsFilteredOrEmpty C] :\n    IsCofilteredOrEmpty C\u1d52\u1d56 where\n  cone_objs X Y :=\n    \u27e8op (IsFiltered.max X.unop Y.unop), (IsFiltered.leftToMax _ _).op,\n      (IsFiltered.rightToMax _ _).op, trivial\u27e9\n  cone_maps X Y f g :=\n    \u27e8op (IsFiltered.coeq f.unop g.unop), (IsFiltered.coeqHom _ _).op, by\n      rw [show f = f.unop.op by simp, show g = g.unop.op by simp, \u2190 op_comp, \u2190 op_comp]\n      congr 1\n      exact IsFiltered.coeq_condition f.unop g.unop\u27e9", "start": [812, 1], "end": [821, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCofiltered_op_of_isFiltered", "code": "instance isCofiltered_op_of_isFiltered [IsFiltered C] : IsCofiltered C\u1d52\u1d56 where\n  Nonempty := \u27e8op IsFiltered.Nonempty.some\u27e9", "start": [823, 1], "end": [824, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty", "code": "instance isFilteredOrEmpty_op_of_isCofilteredOrEmpty [IsCofilteredOrEmpty C] :\n    IsFilteredOrEmpty C\u1d52\u1d56 where\n  cocone_objs X Y :=\n    \u27e8op (IsCofiltered.min X.unop Y.unop), (IsCofiltered.minToLeft X.unop Y.unop).op,\n      (IsCofiltered.minToRight X.unop Y.unop).op, trivial\u27e9\n  cocone_maps X Y f g :=\n    \u27e8op (IsCofiltered.eq f.unop g.unop), (IsCofiltered.eqHom f.unop g.unop).op, by\n      rw [show f = f.unop.op by simp, show g = g.unop.op by simp, \u2190 op_comp, \u2190 op_comp]\n      congr 1\n      exact IsCofiltered.eq_condition f.unop g.unop\u27e9", "start": [827, 1], "end": [836, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isFiltered_op_of_isCofiltered", "code": "instance isFiltered_op_of_isCofiltered [IsCofiltered C] : IsFiltered C\u1d52\u1d56 where\n  Nonempty := \u27e8op IsCofiltered.Nonempty.some\u27e9", "start": [838, 1], "end": [839, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op", "code": "lemma isCofilteredOrEmpty_of_isFilteredOrEmpty_op [IsFilteredOrEmpty C\u1d52\u1d56] : IsCofilteredOrEmpty C :=\n  IsCofilteredOrEmpty.of_equivalence (opOpEquivalence _)", "start": [842, 1], "end": [844, 57], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op", "code": "lemma isFilteredOrEmpty_of_isCofilteredOrEmpty_op [IsCofilteredOrEmpty C\u1d52\u1d56] : IsFilteredOrEmpty C :=\n  IsFilteredOrEmpty.of_equivalence (opOpEquivalence _)", "start": [846, 1], "end": [848, 55], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.isCofiltered_of_isFiltered_op", "code": "lemma isCofiltered_of_isFiltered_op [IsFiltered C\u1d52\u1d56] : IsCofiltered C :=\n  IsCofiltered.of_equivalence (opOpEquivalence _)", "start": [850, 1], "end": [852, 50], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.isFiltered_of_isCofiltered_op", "code": "lemma isFiltered_of_isCofiltered_op [IsCofiltered C\u1d52\u1d56] : IsFiltered C :=\n  IsFiltered.of_equivalence (opOpEquivalence _)", "start": [854, 1], "end": [856, 48], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/TypeMax.lean", "imports": ["Mathlib/Tactic/ToAdditive.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TypeMax", "code": "@[nolint checkUnivs, to_additive existing TypeMax]\nabbrev TypeMax.{u, v} := Type max u v", "start": [24, 1], "end": [26, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/UnivLE.lean", "imports": ["Mathlib/Logic/Small/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UnivLE", "code": "@[pp_with_univ]\nabbrev UnivLE.{u, v} : Prop := \u2200 \u03b1 : Type max u v, Small.{v} \u03b1", "start": [24, 1], "end": [41, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Preserves/Limits.lean", "imports": ["Mathlib/CategoryTheory/Limits/Preserves/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.preserves_lift_mapCone", "code": "@[simp]\ntheorem preserves_lift_mapCone (c\u2081 c\u2082 : Cone F) (t : IsLimit c\u2081) :\n    (PreservesLimit.preserves t).lift (G.mapCone c\u2082) = G.map (t.lift c\u2082)", "start": [45, 1], "end": [48, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesLimitIso", "code": "def preservesLimitIso : G.obj (limit F) \u2245 limit (F \u22d9 G) :=\n  (PreservesLimit.preserves (limit.isLimit _)).conePointUniqueUpToIso (limit.isLimit _)", "start": [53, 1], "end": [57, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesLimitsIso_hom_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem preservesLimitsIso_hom_\u03c0 (j) :\n    (preservesLimitIso G F).hom \u226b limit.\u03c0 _ j = G.map (limit.\u03c0 F j)", "start": [60, 1], "end": [63, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesLimitsIso_inv_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem preservesLimitsIso_inv_\u03c0 (j) :\n    (preservesLimitIso G F).inv \u226b G.map (limit.\u03c0 F j) = limit.\u03c0 _ j", "start": [66, 1], "end": [69, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.lift_comp_preservesLimitsIso_hom", "code": "@[reassoc (attr := simp)]\ntheorem lift_comp_preservesLimitsIso_hom (t : Cone F) :\n    G.map (limit.lift _ t) \u226b (preservesLimitIso G F).hom =\n    limit.lift (F \u22d9 G) (G.mapCone _)", "start": [72, 1], "end": [77, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesLimitNatIso", "code": "@[simps!]\ndef preservesLimitNatIso : lim \u22d9 G \u2245 (whiskeringRight J C D).obj G \u22d9 lim :=\n  NatIso.ofComponents (fun F => preservesLimitIso G F)\n    (by\n      intro _ _ f\n      apply limit.hom_ext; intro j\n      dsimp\n      simp only [preservesLimitsIso_hom_\u03c0, whiskerRight_app, limMap_\u03c0, Category.assoc,\n        preservesLimitsIso_hom_\u03c0_assoc, \u2190 G.map_comp])", "start": [82, 1], "end": [92, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preserves_desc_mapCocone", "code": "@[simp]\ntheorem preserves_desc_mapCocone (c\u2081 c\u2082 : Cocone F) (t : IsColimit c\u2081) :\n    (PreservesColimit.preserves t).desc (G.mapCocone _) = G.map (t.desc c\u2082)", "start": [101, 1], "end": [104, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesColimitIso", "code": "def preservesColimitIso : G.obj (colimit F) \u2245 colimit (F \u22d9 G) :=\n  (PreservesColimit.preserves (colimit.isColimit _)).coconePointUniqueUpToIso (colimit.isColimit _)", "start": [110, 1], "end": [114, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.\u03b9_preservesColimitsIso_inv", "code": "@[reassoc (attr := simp)]\ntheorem \u03b9_preservesColimitsIso_inv (j : J) :\n    colimit.\u03b9 _ j \u226b (preservesColimitIso G F).inv = G.map (colimit.\u03b9 F j)", "start": [117, 1], "end": [120, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.\u03b9_preservesColimitsIso_hom", "code": "@[reassoc (attr := simp)]\ntheorem \u03b9_preservesColimitsIso_hom (j : J) :\n    G.map (colimit.\u03b9 F j) \u226b (preservesColimitIso G F).hom = colimit.\u03b9 (F \u22d9 G) j", "start": [123, 1], "end": [126, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesColimitsIso_inv_comp_desc", "code": "@[reassoc (attr := simp)]\ntheorem preservesColimitsIso_inv_comp_desc (t : Cocone F) :\n    (preservesColimitIso G F).inv \u226b G.map (colimit.desc _ t) =\n    colimit.desc _ (G.mapCocone t)", "start": [129, 1], "end": [134, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesColimitNatIso", "code": "@[simps!]\ndef preservesColimitNatIso : colim \u22d9 G \u2245 (whiskeringRight J C D).obj G \u22d9 colim :=\n  NatIso.ofComponents (fun F => preservesColimitIso G F)\n    (by\n      intro _ _ f\n      rw [\u2190 Iso.inv_comp_eq, \u2190 Category.assoc, \u2190 Iso.eq_comp_inv]\n      apply colimit.hom_ext; intro j\n      dsimp\n      erw [\u03b9_colimMap_assoc]\n      simp only [\u03b9_preservesColimitsIso_inv, whiskerRight_app, Category.assoc,\n        \u03b9_preservesColimitsIso_inv_assoc, \u2190 G.map_comp]\n      erw [\u03b9_colimMap])", "start": [139, 1], "end": [152, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Adjunction/Reflective.lean", "imports": ["Mathlib/CategoryTheory/Functor/ReflectsIso.lean", "Mathlib/CategoryTheory/EpiMono.lean", "Mathlib/CategoryTheory/Adjunction/FullyFaithful.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Reflective", "code": "class Reflective (R : D \u2964 C) extends IsRightAdjoint R, Full R, Faithful R", "start": [34, 1], "end": [37, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unit_obj_eq_map_unit", "code": "theorem unit_obj_eq_map_unit [Reflective i] (X : C) :\n    (ofRightAdjoint i).unit.app (i.obj ((leftAdjoint i).obj X)) =\n      i.map ((leftAdjoint i).map ((ofRightAdjoint i).unit.app X))", "start": [43, 1], "end": [50, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_unit_obj", "code": "instance isIso_unit_obj [Reflective i] {B : D} : IsIso ((ofRightAdjoint i).unit.app (i.obj B)) := by\n  have : (ofRightAdjoint i).unit.app (i.obj B) = inv (i.map ((ofRightAdjoint i).counit.app B)) := by\n    rw [\u2190 comp_hom_eq_id]\n    apply (ofRightAdjoint i).right_triangle_components\n  rw [this]\n  exact IsIso.inv_isIso", "start": [53, 1], "end": [64, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.essImage.unit_isIso", "code": "theorem Functor.essImage.unit_isIso [Reflective i] {A : C} (h : A \u2208 i.essImage) :\n    IsIso ((ofRightAdjoint i).unit.app A)", "start": [67, 1], "end": [81, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mem_essImage_of_unit_isIso", "code": "theorem mem_essImage_of_unit_isIso [IsRightAdjoint i] (A : C)\n    [IsIso ((ofRightAdjoint i).unit.app A)] : A \u2208 i.essImage", "start": [84, 1], "end": [87, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mem_essImage_of_unit_isSplitMono", "code": "theorem mem_essImage_of_unit_isSplitMono [Reflective i] {A : C}\n    [IsSplitMono ((ofRightAdjoint i).unit.app A)] : A \u2208 i.essImage", "start": [90, 1], "end": [102, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Reflective.comp", "code": "instance Reflective.comp (F : C \u2964 D) (G : D \u2964 E) [Reflective F] [Reflective G] :\n    Reflective (F \u22d9 G) where toFaithful := Faithful.comp F G", "start": [105, 1], "end": [107, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unitCompPartialBijectiveAux", "code": "def unitCompPartialBijectiveAux [Reflective i] (A : C) (B : D) :\n    (A \u27f6 i.obj B) \u2243 (i.obj ((leftAdjoint i).obj A) \u27f6 i.obj B) :=\n  ((Adjunction.ofRightAdjoint i).homEquiv _ _).symm.trans (equivOfFullyFaithful i)", "start": [110, 1], "end": [113, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unitCompPartialBijectiveAux_symm_apply", "code": "theorem unitCompPartialBijectiveAux_symm_apply [Reflective i] {A : C} {B : D}\n    (f : i.obj ((leftAdjoint i).obj A) \u27f6 i.obj B) :\n    (unitCompPartialBijectiveAux _ _).symm f = (ofRightAdjoint i).unit.app A \u226b f", "start": [116, 1], "end": [120, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unitCompPartialBijective", "code": "def unitCompPartialBijective [Reflective i] (A : C) {B : C} (hB : B \u2208 i.essImage) :\n    (A \u27f6 B) \u2243 (i.obj ((leftAdjoint i).obj A) \u27f6 B) :=\n  calc\n    (A \u27f6 B) \u2243 (A \u27f6 i.obj (Functor.essImage.witness hB)) := Iso.homCongr (Iso.refl _) hB.getIso.symm\n    _ \u2243 (i.obj _ \u27f6 i.obj (Functor.essImage.witness hB)) := unitCompPartialBijectiveAux _ _\n    _ \u2243 (i.obj ((leftAdjoint i).obj A) \u27f6 B) :=\n      Iso.homCongr (Iso.refl _) (Functor.essImage.getIso hB)", "start": [123, 1], "end": [140, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unitCompPartialBijective_symm_apply", "code": "@[simp]\ntheorem unitCompPartialBijective_symm_apply [Reflective i] (A : C) {B : C} (hB : B \u2208 i.essImage)\n    (f) : (unitCompPartialBijective A hB).symm f = (ofRightAdjoint i).unit.app A \u226b f", "start": [143, 1], "end": [146, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unitCompPartialBijective_symm_natural", "code": "theorem unitCompPartialBijective_symm_natural [Reflective i] (A : C) {B B' : C} (h : B \u27f6 B')\n    (hB : B \u2208 i.essImage) (hB' : B' \u2208 i.essImage) (f : i.obj ((leftAdjoint i).obj A) \u27f6 B) :\n    (unitCompPartialBijective A hB').symm (f \u226b h) = (unitCompPartialBijective A hB).symm f \u226b h", "start": [149, 1], "end": [152, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unitCompPartialBijective_natural", "code": "theorem unitCompPartialBijective_natural [Reflective i] (A : C) {B B' : C} (h : B \u27f6 B')\n    (hB : B \u2208 i.essImage) (hB' : B' \u2208 i.essImage) (f : A \u27f6 B) :\n    (unitCompPartialBijective A hB') (f \u226b h) = unitCompPartialBijective A hB f \u226b h", "start": [155, 1], "end": [158, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.equivEssImageOfReflective_counitIso_app", "code": "def equivEssImageOfReflective_counitIso_app [Reflective i] (X : Functor.EssImageSubcategory i) :\n    ((Functor.essImageInclusion i \u22d9 leftAdjoint i) \u22d9 Functor.toEssImage i).obj X \u2245 X := by\n  refine' Iso.symm (@asIso _ _ X _ ((ofRightAdjoint i).unit.app X.obj) ?_)\n  refine @isIso_of_reflects_iso _ _ _ _ _ _ _ i.essImageInclusion ?_ _\n  dsimp\n  exact inferInstance", "start": [167, 1], "end": [174, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.equivEssImageOfReflective_map_counitIso_app_hom", "code": "lemma equivEssImageOfReflective_map_counitIso_app_hom [Reflective i]\n    (X : Functor.EssImageSubcategory i) :\n  (Functor.essImageInclusion i).map (equivEssImageOfReflective_counitIso_app X).hom =\n    inv (NatTrans.app (ofRightAdjoint i).unit X.obj) := by\n    simp [equivEssImageOfReflective_counitIso_app, asIso]\n    rfl", "start": [176, 1], "end": [181, 8], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.equivEssImageOfReflective_map_counitIso_app_inv", "code": "lemma equivEssImageOfReflective_map_counitIso_app_inv [Reflective i]\n    (X : Functor.EssImageSubcategory i) :\n  (Functor.essImageInclusion i).map (equivEssImageOfReflective_counitIso_app X).inv =\n    (NatTrans.app (ofRightAdjoint i).unit X.obj) := rfl", "start": [183, 1], "end": [186, 56], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.equivEssImageOfReflective", "code": "@[simps]\ndef equivEssImageOfReflective [Reflective i] : D \u224c i.EssImageSubcategory\n    where\n  functor := i.toEssImage\n  inverse := i.essImageInclusion \u22d9 (leftAdjoint i : _)\n  unitIso :=\n    NatIso.ofComponents (fun X => (asIso <| (ofRightAdjoint i).counit.app X).symm)\n      (by\n        intro X Y f\n        dsimp\n        rw [IsIso.comp_inv_eq, Category.assoc, IsIso.eq_inv_comp]\n        exact ((ofRightAdjoint i).counit.naturality f).symm)\n  counitIso :=\n    NatIso.ofComponents equivEssImageOfReflective_counitIso_app\n      (by\n        intro X Y f\n        apply (Functor.essImageInclusion i).map_injective\n        have h := ((ofRightAdjoint i).unit.naturality f).symm\n        rw [Functor.id_map] at h\n        erw [Functor.map_comp, Functor.map_comp,\n          equivEssImageOfReflective_map_counitIso_app_hom,\n          equivEssImageOfReflective_map_counitIso_app_hom,\n          IsIso.comp_inv_eq, assoc, \u2190 h, IsIso.inv_hom_id_assoc, Functor.comp_map])\n  functor_unitIso_comp := fun X => by\n    apply (Functor.essImageInclusion i).map_injective\n    erw [Functor.map_comp, equivEssImageOfReflective_map_counitIso_app_hom]\n    aesop_cat", "start": [188, 1], "end": [217, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Over.lean", "imports": ["Mathlib/CategoryTheory/Adjunction/Opposites.lean", "Mathlib/CategoryTheory/Limits/Creates.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Comma.lean", "Mathlib/CategoryTheory/Limits/Preserves/Basic.lean", "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "Mathlib/CategoryTheory/Over.lean"], "premises": [{"full_name": "CategoryTheory.Over.hasColimit_of_hasColimit_comp_forget", "code": "instance hasColimit_of_hasColimit_comp_forget (F : J \u2964 Over X) [i : HasColimit (F \u22d9 forget X)] :\n    HasColimit F :=\n  @CostructuredArrow.hasColimit _ _ _ _ _ _ _ _ _ i _", "start": [44, 1], "end": [46, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.createsColimitsOfSize", "code": "instance createsColimitsOfSize : CreatesColimitsOfSize.{w, w'} (forget X) :=\n  CostructuredArrow.createsColimitsOfSize", "start": [54, 1], "end": [55, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.epi_left_of_epi", "code": "theorem epi_left_of_epi [HasPushouts C] {f g : Over X} (h : f \u27f6 g) [Epi h] : Epi h.left", "start": [65, 1], "end": [66, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.epi_iff_epi_left", "code": "theorem epi_iff_epi_left [HasPushouts C] {f g : Over X} (h : f \u27f6 g) : Epi h \u2194 Epi h.left", "start": [69, 1], "end": [70, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.pullback", "code": "@[simps]\ndef pullback {X Y : C} (f : X \u27f6 Y) : Over Y \u2964 Over X where\n  obj g := Over.mk (pullback.snd : CategoryTheory.Limits.pullback g.hom f \u27f6 X)\n  map := fun g {h} {k} =>\n    Over.homMk (pullback.lift (pullback.fst \u226b k.left) pullback.snd (by simp [pullback.condition]))", "start": [79, 1], "end": [85, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.mapPullbackAdj", "code": "def mapPullbackAdj {A B : C} (f : A \u27f6 B) : Over.map f \u22a3 pullback f :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun g h =>\n        { toFun := fun X =>\n            Over.homMk (pullback.lift X.left g.hom (Over.w X)) (pullback.lift_snd _ _ _)\n          invFun := fun Y => by\n            refine' Over.homMk _ _\n            refine' Y.left \u226b pullback.fst\n            dsimp\n            rw [\u2190 Over.w Y, Category.assoc, pullback.condition, Category.assoc]; rfl\n          left_inv := fun X => by\n            ext\n            dsimp\n            simp\n          right_inv := fun Y => by\n            apply OverMorphism.ext\n            apply pullback.hom_ext\n            \u00b7 dsimp\n              simp only [limit.lift_\u03c0, PullbackCone.mk_pt, PullbackCone.mk_\u03c0_app]\n            \u00b7 dsimp\n              simp only [limit.lift_\u03c0, PullbackCone.mk_pt, PullbackCone.mk_\u03c0_app, \u2190 Over.w Y ]\n              rfl }\n      homEquiv_naturality_right := by intros; dsimp; congr 1; aesop_cat\n      }", "start": [88, 1], "end": [114, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.pullbackId", "code": "def pullbackId {A : C} : pullback (\ud835\udfd9 A) \u2245 \ud835\udfed _ :=\n  Adjunction.rightAdjointUniq (mapPullbackAdj _) (Adjunction.id.ofNatIsoLeft Over.mapId.symm)", "start": [117, 1], "end": [119, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.pullbackComp", "code": "def pullbackComp {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) : pullback (f \u226b g) \u2245 pullback g \u22d9 pullback f :=\n  Adjunction.rightAdjointUniq (mapPullbackAdj _)\n    (((mapPullbackAdj _).comp (mapPullbackAdj _)).ofNatIsoLeft (Over.mapComp _ _).symm)", "start": [122, 1], "end": [125, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.pullbackIsRightAdjoint", "code": "instance pullbackIsRightAdjoint {A B : C} (f : A \u27f6 B) : IsRightAdjoint (pullback f) :=\n  \u27e8_, mapPullbackAdj f\u27e9", "start": [128, 1], "end": [129, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.hasLimit_of_hasLimit_comp_forget", "code": "instance hasLimit_of_hasLimit_comp_forget (F : J \u2964 Under X) [i : HasLimit (F \u22d9 forget X)] :\n    HasLimit F :=\n  @StructuredArrow.hasLimit _ _ _ _ _ _ _ _ _ i _", "start": [138, 1], "end": [140, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.mono_right_of_mono", "code": "theorem mono_right_of_mono [HasPullbacks C] {f g : Under X} (h : f \u27f6 g) [Mono h] : Mono h.right", "start": [148, 1], "end": [149, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.mono_iff_mono_right", "code": "theorem mono_iff_mono_right [HasPullbacks C] {f g : Under X} (h : f \u27f6 g) : Mono h \u2194 Mono h.right", "start": [152, 1], "end": [153, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.createsLimitsOfSize", "code": "instance createsLimitsOfSize : CreatesLimitsOfSize.{w, w'} (forget X) :=\n  StructuredArrow.createsLimitsOfSize", "start": [156, 1], "end": [157, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Under.pushout", "code": "@[simps]\ndef pushout {X Y : C} (f : X \u27f6 Y) : Under X \u2964 Under Y where\n  obj g := Under.mk (pushout.inr : Y \u27f6 CategoryTheory.Limits.pushout g.hom f)\n  map := fun g {h} {k} =>\n    Under.homMk (pushout.desc (k.right \u226b pushout.inl) pushout.inr (by simp [\u2190 pushout.condition]))", "start": [171, 1], "end": [177, 99], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Category.lean", "imports": ["Mathlib/CategoryTheory/Products/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.MonoidalCategory", "code": "class MonoidalCategory (C : Type u) [\ud835\udc9e : Category.{v} C] where\n  \n  tensorObj : C \u2192 C \u2192 C\n  \n  whiskerLeft (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) : tensorObj X Y\u2081 \u27f6 tensorObj X Y\u2082\n  \n  whiskerRight {X\u2081 X\u2082 : C} (f : X\u2081 \u27f6 X\u2082) (Y : C) : tensorObj X\u2081 Y \u27f6 tensorObj X\u2082 Y\n  \n  tensorHom {X\u2081 Y\u2081 X\u2082 Y\u2082 : C} (f : X\u2081 \u27f6 Y\u2081) (g: X\u2082 \u27f6 Y\u2082) : (tensorObj X\u2081 X\u2082 \u27f6 tensorObj Y\u2081 Y\u2082) :=\n    whiskerRight f X\u2082 \u226b whiskerLeft Y\u2081 g\n  tensorHom_def {X\u2081 Y\u2081 X\u2082 Y\u2082 : C} (f : X\u2081 \u27f6 Y\u2081) (g: X\u2082 \u27f6 Y\u2082) :\n    tensorHom f g = whiskerRight f X\u2082 \u226b whiskerLeft Y\u2081 g := by\n      aesop_cat\n  \n  tensor_id : \u2200 X\u2081 X\u2082 : C, tensorHom (\ud835\udfd9 X\u2081) (\ud835\udfd9 X\u2082) = \ud835\udfd9 (tensorObj X\u2081 X\u2082) := by aesop_cat\n  \n  tensor_comp :\n    \u2200 {X\u2081 Y\u2081 Z\u2081 X\u2082 Y\u2082 Z\u2082 : C} (f\u2081 : X\u2081 \u27f6 Y\u2081) (f\u2082 : X\u2082 \u27f6 Y\u2082) (g\u2081 : Y\u2081 \u27f6 Z\u2081) (g\u2082 : Y\u2082 \u27f6 Z\u2082),\n      tensorHom (f\u2081 \u226b g\u2081) (f\u2082 \u226b g\u2082) = tensorHom f\u2081 f\u2082 \u226b tensorHom g\u2081 g\u2082 := by\n    aesop_cat\n  \n  tensorUnit' : C\n  \n  associator : \u2200 X Y Z : C, tensorObj (tensorObj X Y) Z \u2245 tensorObj X (tensorObj Y Z)\n  whiskerLeft_id : \u2200 (X Y : C), whiskerLeft X (\ud835\udfd9 Y) = \ud835\udfd9 (tensorObj X Y) := by\n    aesop_cat\n  id_whiskerRight : \u2200 (X Y : C), whiskerRight (\ud835\udfd9 X) Y = \ud835\udfd9 (tensorObj X Y) := by\n    aesop_cat\n  \n  associator_naturality :\n    \u2200 {X\u2081 X\u2082 X\u2083 Y\u2081 Y\u2082 Y\u2083 : C} (f\u2081 : X\u2081 \u27f6 Y\u2081) (f\u2082 : X\u2082 \u27f6 Y\u2082) (f\u2083 : X\u2083 \u27f6 Y\u2083),\n      tensorHom (tensorHom f\u2081 f\u2082) f\u2083 \u226b (associator Y\u2081 Y\u2082 Y\u2083).hom =\n        (associator X\u2081 X\u2082 X\u2083).hom \u226b tensorHom f\u2081 (tensorHom f\u2082 f\u2083) := by\n    aesop_cat\n  \n  leftUnitor : \u2200 X : C, tensorObj tensorUnit' X \u2245 X\n  \n  leftUnitor_naturality :\n    \u2200 {X Y : C} (f : X \u27f6 Y),\n      tensorHom (\ud835\udfd9 tensorUnit') f \u226b (leftUnitor Y).hom = (leftUnitor X).hom \u226b f := by\n    aesop_cat\n  \n  rightUnitor : \u2200 X : C, tensorObj X tensorUnit' \u2245 X\n  \n  rightUnitor_naturality :\n    \u2200 {X Y : C} (f : X \u27f6 Y),\n      tensorHom f (\ud835\udfd9 tensorUnit') \u226b (rightUnitor Y).hom = (rightUnitor X).hom \u226b f := by\n    aesop_cat\n  \n  pentagon :\n    \u2200 W X Y Z : C,\n      tensorHom (associator W X Y).hom (\ud835\udfd9 Z) \u226b\n          (associator W (tensorObj X Y) Z).hom \u226b tensorHom (\ud835\udfd9 W) (associator X Y Z).hom =\n        (associator (tensorObj W X) Y Z).hom \u226b (associator W X (tensorObj Y Z)).hom := by\n    aesop_cat\n  \n  triangle :\n    \u2200 X Y : C,\n      (associator X tensorUnit' Y).hom \u226b tensorHom (\ud835\udfd9 X) (leftUnitor Y).hom =\n        tensorHom (rightUnitor X).hom (\ud835\udfd9 Y) := by\n    aesop_cat", "start": [63, 1], "end": [147, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorUnit", "code": "abbrev MonoidalCategory.tensorUnit (C : Type u) [Category.{v} C] [MonoidalCategory C] : C :=\n  tensorUnit' (C := C)", "start": [165, 1], "end": [167, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.id_tensorHom", "code": "theorem id_tensorHom (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082) :\n    (\ud835\udfd9 X) \u2297 f = X \u25c1 f", "start": [197, 1], "end": [199, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorHom_id", "code": "theorem tensorHom_id {X\u2081 X\u2082 : C} (f : X\u2081 \u27f6 X\u2082) (Y : C) :\n    f \u2297 (\ud835\udfd9 Y) = f \u25b7 Y", "start": [201, 1], "end": [203, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.whisker_exchange", "code": "theorem whisker_exchange {W X Y Z : C} (f : W \u27f6 X) (g : Y \u27f6 Z) :\n    W \u25c1 g \u226b f \u25b7 Z = f \u25b7 Y \u226b X \u25c1 g", "start": [205, 1], "end": [207, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorHom_def'", "code": "@[reassoc]\ntheorem tensorHom_def' {X\u2081 Y\u2081 X\u2082 Y\u2082 : C} (f : X\u2081 \u27f6 Y\u2081) (g: X\u2082 \u27f6 Y\u2082) :\n    f \u2297 g = X\u2081 \u25c1 g \u226b f \u25b7 Y\u2082", "start": [209, 1], "end": [212, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.tensorIso", "code": "@[simps]\ndef tensorIso {C : Type u} {X Y X' Y' : C} [Category.{v} C] [MonoidalCategory.{v} C] (f : X \u2245 Y)\n    (g : X' \u2245 Y') : X \u2297 X' \u2245 Y \u2297 Y' where\n  hom := f.hom \u2297 g.hom\n  inv := f.inv \u2297 g.inv\n  hom_inv_id := by rw [\u2190 tensor_comp, Iso.hom_inv_id, Iso.hom_inv_id, \u2190 tensor_id]\n  inv_hom_id := by rw [\u2190 tensor_comp, Iso.inv_hom_id, Iso.inv_hom_id, \u2190 tensor_id]", "start": [221, 1], "end": [228, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensor_isIso", "code": "instance tensor_isIso {W X Y Z : C} (f : W \u27f6 X) [IsIso f] (g : Y \u27f6 Z) [IsIso g] : IsIso (f \u2297 g) :=\n  IsIso.of_iso (asIso f \u2297 asIso g)", "start": [240, 1], "end": [241, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.inv_tensor", "code": "@[simp]\ntheorem inv_tensor {W X Y Z : C} (f : W \u27f6 X) [IsIso f] (g : Y \u27f6 Z) [IsIso g] :\n    inv (f \u2297 g) = inv f \u2297 inv g", "start": [244, 1], "end": [248, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensor_dite", "code": "theorem tensor_dite {P : Prop} [Decidable P] {W X Y Z : C} (f : W \u27f6 X) (g : P \u2192 (Y \u27f6 Z))\n    (g' : \u00acP \u2192 (Y \u27f6 Z)) : (f \u2297 if h : P then g h else g' h) = if h : P then f \u2297 g h else f \u2297 g' h", "start": [253, 1], "end": [255, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.dite_tensor", "code": "theorem dite_tensor {P : Prop} [Decidable P] {W X Y Z : C} (f : W \u27f6 X) (g : P \u2192 (Y \u27f6 Z))\n    (g' : \u00acP \u2192 (Y \u27f6 Z)) : (if h : P then g h else g' h) \u2297 f = if h : P then g h \u2297 f else g' h \u2297 f", "start": [258, 1], "end": [260, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.comp_tensor_id", "code": "@[reassoc, simp]\ntheorem comp_tensor_id (f : W \u27f6 X) (g : X \u27f6 Y) : f \u226b g \u2297 \ud835\udfd9 Z = (f \u2297 \ud835\udfd9 Z) \u226b (g \u2297 \ud835\udfd9 Z)", "start": [263, 1], "end": [266, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.id_tensor_comp", "code": "@[reassoc, simp]\ntheorem id_tensor_comp (f : W \u27f6 X) (g : X \u27f6 Y) : \ud835\udfd9 Z \u2297 f \u226b g = (\ud835\udfd9 Z \u2297 f) \u226b (\ud835\udfd9 Z \u2297 g)", "start": [269, 1], "end": [272, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.id_tensor_comp_tensor_id", "code": "@[reassoc (attr := simp)]\ntheorem id_tensor_comp_tensor_id (f : W \u27f6 X) (g : Y \u27f6 Z) : (\ud835\udfd9 Y \u2297 f) \u226b (g \u2297 \ud835\udfd9 X) = g \u2297 f", "start": [275, 1], "end": [278, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensor_id_comp_id_tensor", "code": "@[reassoc (attr := simp)]\ntheorem tensor_id_comp_id_tensor (f : W \u27f6 X) (g : Y \u27f6 Z) : (g \u2297 \ud835\udfd9 W) \u226b (\ud835\udfd9 Z \u2297 f) = g \u2297 f", "start": [281, 1], "end": [284, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.rightUnitor_conjugation", "code": "@[simp]\ntheorem rightUnitor_conjugation {X Y : C} (f : X \u27f6 Y) :\n    f \u2297 \ud835\udfd9 (\ud835\udfd9_ C) = (\u03c1_ X).hom \u226b f \u226b (\u03c1_ Y).inv", "start": [287, 1], "end": [290, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.leftUnitor_conjugation", "code": "@[simp]\ntheorem leftUnitor_conjugation {X Y : C} (f : X \u27f6 Y) :\n    \ud835\udfd9 (\ud835\udfd9_ C) \u2297 f = (\u03bb_ X).hom \u226b f \u226b (\u03bb_ Y).inv", "start": [293, 1], "end": [296, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.leftUnitor_inv_naturality", "code": "@[reassoc]\ntheorem leftUnitor_inv_naturality {X X' : C} (f : X \u27f6 X') :\n    f \u226b (\u03bb_ X').inv = (\u03bb_ X).inv \u226b (\ud835\udfd9 _ \u2297 f)", "start": [299, 1], "end": [301, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.rightUnitor_inv_naturality", "code": "@[reassoc]\ntheorem rightUnitor_inv_naturality {X X' : C} (f : X \u27f6 X') :\n    f \u226b (\u03c1_ X').inv = (\u03c1_ X).inv \u226b (f \u2297 \ud835\udfd9 _)", "start": [304, 1], "end": [306, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensor_left_iff", "code": "theorem tensor_left_iff {X Y : C} (f g : X \u27f6 Y) : \ud835\udfd9 (\ud835\udfd9_ C) \u2297 f = \ud835\udfd9 (\ud835\udfd9_ C) \u2297 g \u2194 f = g", "start": [309, 1], "end": [309, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensor_right_iff", "code": "theorem tensor_right_iff {X Y : C} (f g : X \u27f6 Y) : f \u2297 \ud835\udfd9 (\ud835\udfd9_ C) = g \u2297 \ud835\udfd9 (\ud835\udfd9_ C) \u2194 f = g", "start": [312, 1], "end": [312, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.pentagon_inv", "code": "@[reassoc]\ntheorem pentagon_inv (W X Y Z : C) :\n    (\ud835\udfd9 W \u2297 (\u03b1_ X Y Z).inv) \u226b (\u03b1_ W (X \u2297 Y) Z).inv \u226b ((\u03b1_ W X Y).inv \u2297 \ud835\udfd9 Z) =\n      (\u03b1_ W X (Y \u2297 Z)).inv \u226b (\u03b1_ (W \u2297 X) Y Z).inv", "start": [321, 1], "end": [325, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.rightUnitor_tensor", "code": "@[reassoc, simp]\ntheorem rightUnitor_tensor (X Y : C) :\n    (\u03c1_ (X \u2297 Y)).hom = (\u03b1_ X Y (\ud835\udfd9_ C)).hom \u226b (\ud835\udfd9 X \u2297 (\u03c1_ Y).hom)", "start": [328, 1], "end": [333, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.rightUnitor_tensor_inv", "code": "@[reassoc, simp]\ntheorem rightUnitor_tensor_inv (X Y : C) :\n    (\u03c1_ (X \u2297 Y)).inv = (\ud835\udfd9 X \u2297 (\u03c1_ Y).inv) \u226b (\u03b1_ X Y (\ud835\udfd9_ C)).inv", "start": [336, 1], "end": [339, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.triangle_assoc_comp_right", "code": "@[reassoc (attr := simp)]\ntheorem triangle_assoc_comp_right (X Y : C) :\n    (\u03b1_ X (\ud835\udfd9_ C) Y).inv \u226b ((\u03c1_ X).hom \u2297 \ud835\udfd9 Y) = \ud835\udfd9 X \u2297 (\u03bb_ Y).hom", "start": [342, 1], "end": [345, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.triangle_assoc_comp_left_inv", "code": "@[reassoc (attr := simp)]\ntheorem triangle_assoc_comp_left_inv (X Y : C) :\n    (\ud835\udfd9 X \u2297 (\u03bb_ Y).inv) \u226b (\u03b1_ X (\ud835\udfd9_ C) Y).inv = (\u03c1_ X).inv \u2297 \ud835\udfd9 Y", "start": [348, 1], "end": [353, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.associator_inv_naturality", "code": "@[reassoc]\ntheorem associator_inv_naturality {X Y Z X' Y' Z' : C} (f : X \u27f6 X') (g : Y \u27f6 Y') (h : Z \u27f6 Z') :\n    (f \u2297 g \u2297 h) \u226b (\u03b1_ X' Y' Z').inv = (\u03b1_ X Y Z).inv \u226b ((f \u2297 g) \u2297 h)", "start": [358, 1], "end": [362, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.associator_conjugation", "code": "@[reassoc, simp]\ntheorem associator_conjugation {X X' Y Y' Z Z' : C} (f : X \u27f6 X') (g : Y \u27f6 Y') (h : Z \u27f6 Z') :\n    (f \u2297 g) \u2297 h = (\u03b1_ X Y Z).hom \u226b (f \u2297 g \u2297 h) \u226b (\u03b1_ X' Y' Z').inv", "start": [365, 1], "end": [368, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.associator_inv_conjugation", "code": "@[reassoc]\ntheorem associator_inv_conjugation {X X' Y Y' Z Z' : C} (f : X \u27f6 X') (g : Y \u27f6 Y') (h : Z \u27f6 Z') :\n    f \u2297 g \u2297 h = (\u03b1_ X Y Z).inv \u226b ((f \u2297 g) \u2297 h) \u226b (\u03b1_ X' Y' Z').hom", "start": [371, 1], "end": [374, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.id_tensor_associator_naturality", "code": "@[reassoc]\ntheorem id_tensor_associator_naturality {X Y Z Z' : C} (h : Z \u27f6 Z') :\n    (\ud835\udfd9 (X \u2297 Y) \u2297 h) \u226b (\u03b1_ X Y Z').hom = (\u03b1_ X Y Z).hom \u226b (\ud835\udfd9 X \u2297 \ud835\udfd9 Y \u2297 h)", "start": [379, 1], "end": [382, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.id_tensor_associator_inv_naturality", "code": "@[reassoc]\ntheorem id_tensor_associator_inv_naturality {X Y Z X' : C} (f : X \u27f6 X') :\n    (f \u2297 \ud835\udfd9 (Y \u2297 Z)) \u226b (\u03b1_ X' Y Z).inv = (\u03b1_ X Y Z).inv \u226b ((f \u2297 \ud835\udfd9 Y) \u2297 \ud835\udfd9 Z)", "start": [385, 1], "end": [388, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.hom_inv_id_tensor", "code": "@[reassoc (attr := simp)]\ntheorem hom_inv_id_tensor {V W X Y Z : C} (f : V \u2245 W) (g : X \u27f6 Y) (h : Y \u27f6 Z) :\n    (f.hom \u2297 g) \u226b (f.inv \u2297 h) = (\ud835\udfd9 V \u2297 g) \u226b (\ud835\udfd9 V \u2297 h)", "start": [391, 1], "end": [394, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.inv_hom_id_tensor", "code": "@[reassoc (attr := simp)]\ntheorem inv_hom_id_tensor {V W X Y Z : C} (f : V \u2245 W) (g : X \u27f6 Y) (h : Y \u27f6 Z) :\n    (f.inv \u2297 g) \u226b (f.hom \u2297 h) = (\ud835\udfd9 W \u2297 g) \u226b (\ud835\udfd9 W \u2297 h)", "start": [397, 1], "end": [400, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorHom_inv_id", "code": "@[reassoc (attr := simp)]\ntheorem tensorHom_inv_id {V W X Y Z : C} (f : V \u2245 W) (g : X \u27f6 Y) (h : Y \u27f6 Z) :\n    (g \u2297 f.hom) \u226b (h \u2297 f.inv) = (g \u2297 \ud835\udfd9 V) \u226b (h \u2297 \ud835\udfd9 V)", "start": [403, 1], "end": [406, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensor_inv_hom_id", "code": "@[reassoc (attr := simp)]\ntheorem tensor_inv_hom_id {V W X Y Z : C} (f : V \u2245 W) (g : X \u27f6 Y) (h : Y \u27f6 Z) :\n    (g \u2297 f.inv) \u226b (h \u2297 f.hom) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "start": [409, 1], "end": [412, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.hom_inv_id_tensor'", "code": "@[reassoc (attr := simp)]\ntheorem hom_inv_id_tensor' {V W X Y Z : C} (f : V \u27f6 W) [IsIso f] (g : X \u27f6 Y) (h : Y \u27f6 Z) :\n    (f \u2297 g) \u226b (inv f \u2297 h) = (\ud835\udfd9 V \u2297 g) \u226b (\ud835\udfd9 V \u2297 h)", "start": [415, 1], "end": [418, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.inv_hom_id_tensor'", "code": "@[reassoc (attr := simp)]\ntheorem inv_hom_id_tensor' {V W X Y Z : C} (f : V \u27f6 W) [IsIso f] (g : X \u27f6 Y) (h : Y \u27f6 Z) :\n    (inv f \u2297 g) \u226b (f \u2297 h) = (\ud835\udfd9 W \u2297 g) \u226b (\ud835\udfd9 W \u2297 h)", "start": [421, 1], "end": [424, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorHom_inv_id'", "code": "@[reassoc (attr := simp)]\ntheorem tensorHom_inv_id' {V W X Y Z : C} (f : V \u27f6 W) [IsIso f] (g : X \u27f6 Y) (h : Y \u27f6 Z) :\n    (g \u2297 f) \u226b (h \u2297 inv f) = (g \u2297 \ud835\udfd9 V) \u226b (h \u2297 \ud835\udfd9 V)", "start": [427, 1], "end": [430, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensor_inv_hom_id'", "code": "@[reassoc (attr := simp)]\ntheorem tensor_inv_hom_id' {V W X Y Z : C} (f : V \u27f6 W) [IsIso f] (g : X \u27f6 Y) (h : Y \u27f6 Z) :\n    (g \u2297 inv f) \u226b (h \u2297 f) = (g \u2297 \ud835\udfd9 W) \u226b (h \u2297 \ud835\udfd9 W)", "start": [433, 1], "end": [436, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.ofTensorHom", "code": "def ofTensorHom\n    (tensorObj : C \u2192 C \u2192 C)\n    (tensorHom : \u2200 {X\u2081 Y\u2081 X\u2082 Y\u2082 : C}, (X\u2081 \u27f6 Y\u2081) \u2192 (X\u2082 \u27f6 Y\u2082) \u2192 (tensorObj X\u2081 X\u2082 \u27f6 tensorObj Y\u2081 Y\u2082))\n    (whiskerLeft : \u2200 (X : C) {Y\u2081 Y\u2082 : C}  (_f : Y\u2081 \u27f6 Y\u2082), tensorObj X Y\u2081 \u27f6 tensorObj X Y\u2082 :=\n      fun X _ _ f \u21a6 tensorHom (\ud835\udfd9 X) f)\n    (whiskerRight : \u2200 {X\u2081 X\u2082 : C} (_f : X\u2081 \u27f6 X\u2082) (Y : C), tensorObj X\u2081 Y \u27f6 tensorObj X\u2082 Y :=\n      fun f Y \u21a6 tensorHom f (\ud835\udfd9 Y))\n    (tensor_id : \u2200 X\u2081 X\u2082 : C, tensorHom (\ud835\udfd9 X\u2081) (\ud835\udfd9 X\u2082) = \ud835\udfd9 (tensorObj X\u2081 X\u2082) := by\n      aesop_cat)\n    (id_tensorHom : \u2200 (X : C) {Y\u2081 Y\u2082 : C} (f : Y\u2081 \u27f6 Y\u2082), tensorHom (\ud835\udfd9 X) f = whiskerLeft X f := by\n      aesop_cat)\n    (tensorHom_id : \u2200 {X\u2081 X\u2082 : C} (f : X\u2081 \u27f6 X\u2082) (Y : C), tensorHom f (\ud835\udfd9 Y) = whiskerRight f Y := by\n      aesop_cat)\n    (tensor_comp :\n      \u2200 {X\u2081 Y\u2081 Z\u2081 X\u2082 Y\u2082 Z\u2082 : C} (f\u2081 : X\u2081 \u27f6 Y\u2081) (f\u2082 : X\u2082 \u27f6 Y\u2082) (g\u2081 : Y\u2081 \u27f6 Z\u2081) (g\u2082 : Y\u2082 \u27f6 Z\u2082),\n        tensorHom (f\u2081 \u226b g\u2081) (f\u2082 \u226b g\u2082) = tensorHom f\u2081 f\u2082 \u226b tensorHom g\u2081 g\u2082 := by\n          aesop_cat)\n    (tensorUnit' : C)\n    (associator : \u2200 X Y Z : C, tensorObj (tensorObj X Y) Z \u2245 tensorObj X (tensorObj Y Z))\n    (associator_naturality :\n      \u2200 {X\u2081 X\u2082 X\u2083 Y\u2081 Y\u2082 Y\u2083 : C} (f\u2081 : X\u2081 \u27f6 Y\u2081) (f\u2082 : X\u2082 \u27f6 Y\u2082) (f\u2083 : X\u2083 \u27f6 Y\u2083),\n        tensorHom (tensorHom f\u2081 f\u2082) f\u2083 \u226b (associator Y\u2081 Y\u2082 Y\u2083).hom =\n          (associator X\u2081 X\u2082 X\u2083).hom \u226b tensorHom f\u2081 (tensorHom f\u2082 f\u2083) := by\n            aesop_cat)\n    (leftUnitor : \u2200 X : C, tensorObj tensorUnit' X \u2245 X)\n    (leftUnitor_naturality :\n      \u2200 {X Y : C} (f : X \u27f6 Y),\n        tensorHom (\ud835\udfd9 tensorUnit') f \u226b (leftUnitor Y).hom = (leftUnitor X).hom \u226b f := by\n          aesop_cat)\n    (rightUnitor : \u2200 X : C, tensorObj X tensorUnit' \u2245 X)\n    (rightUnitor_naturality :\n      \u2200 {X Y : C} (f : X \u27f6 Y),\n        tensorHom f (\ud835\udfd9 tensorUnit') \u226b (rightUnitor Y).hom = (rightUnitor X).hom \u226b f := by\n          aesop_cat)\n    (pentagon :\n      \u2200 W X Y Z : C,\n        tensorHom (associator W X Y).hom (\ud835\udfd9 Z) \u226b\n            (associator W (tensorObj X Y) Z).hom \u226b tensorHom (\ud835\udfd9 W) (associator X Y Z).hom =\n          (associator (tensorObj W X) Y Z).hom \u226b (associator W X (tensorObj Y Z)).hom := by\n            aesop_cat)\n    (triangle :\n      \u2200 X Y : C,\n        (associator X tensorUnit' Y).hom \u226b tensorHom (\ud835\udfd9 X) (leftUnitor Y).hom =\n          tensorHom (rightUnitor X).hom (\ud835\udfd9 Y) := by\n            aesop_cat) :\n      MonoidalCategory C where\n  tensorObj := tensorObj\n  tensorHom := tensorHom\n  whiskerLeft X _ _ f := whiskerLeft X f\n  whiskerRight f X := whiskerRight f X\n  tensorHom_def := by intros; simp [\u2190 id_tensorHom, \u2190tensorHom_id, \u2190 tensor_comp]\n  tensorUnit' := tensorUnit'\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n  whiskerLeft_id := by intros; simp [\u2190 id_tensorHom, \u2190 tensor_id]\n  id_whiskerRight := by intros; simp [\u2190 tensorHom_id, tensor_id]\n  pentagon := by intros; simp [\u2190 id_tensorHom, \u2190 tensorHom_id, pentagon]\n  triangle := by intros; simp [\u2190 id_tensorHom, \u2190 tensorHom_id, triangle]", "start": [439, 1], "end": [501, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensor", "code": "@[simps]\ndef tensor : C \u00d7 C \u2964 C where\n  obj X := X.1 \u2297 X.2\n  map {X Y : C \u00d7 C} (f : X \u27f6 Y) := f.1 \u2297 f.2", "start": [509, 1], "end": [513, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.leftAssocTensor", "code": "def leftAssocTensor : C \u00d7 C \u00d7 C \u2964 C\n    where\n  obj X := (X.1 \u2297 X.2.1) \u2297 X.2.2\n  map {X Y : C \u00d7 C \u00d7 C} (f : X \u27f6 Y) := (f.1 \u2297 f.2.1) \u2297 f.2.2", "start": [516, 1], "end": [520, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.leftAssocTensor_obj", "code": "@[simp]\ntheorem leftAssocTensor_obj (X) : (leftAssocTensor C).obj X = (X.1 \u2297 X.2.1) \u2297 X.2.2", "start": [523, 1], "end": [525, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.leftAssocTensor_map", "code": "@[simp]\ntheorem leftAssocTensor_map {X Y} (f : X \u27f6 Y) : (leftAssocTensor C).map f = (f.1 \u2297 f.2.1) \u2297 f.2.2", "start": [528, 1], "end": [530, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.rightAssocTensor", "code": "def rightAssocTensor : C \u00d7 C \u00d7 C \u2964 C\n    where\n  obj X := X.1 \u2297 X.2.1 \u2297 X.2.2\n  map {X Y : C \u00d7 C \u00d7 C} (f : X \u27f6 Y) := f.1 \u2297 f.2.1 \u2297 f.2.2", "start": [533, 1], "end": [537, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.rightAssocTensor_obj", "code": "@[simp]\ntheorem rightAssocTensor_obj (X) : (rightAssocTensor C).obj X = X.1 \u2297 X.2.1 \u2297 X.2.2", "start": [540, 1], "end": [542, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.rightAssocTensor_map", "code": "@[simp]\ntheorem rightAssocTensor_map {X Y} (f : X \u27f6 Y) : (rightAssocTensor C).map f = f.1 \u2297 f.2.1 \u2297 f.2.2", "start": [545, 1], "end": [547, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorUnitLeft", "code": "def tensorUnitLeft : C \u2964 C where\n  obj X := \ud835\udfd9_ C \u2297 X\n  map {X Y : C} (f : X \u27f6 Y) := \ud835\udfd9 (\ud835\udfd9_ C) \u2297 f", "start": [550, 1], "end": [553, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorUnitRight", "code": "def tensorUnitRight : C \u2964 C where\n  obj X := X \u2297 \ud835\udfd9_ C\n  map {X Y : C} (f : X \u27f6 Y) := f \u2297 \ud835\udfd9 (\ud835\udfd9_ C)", "start": [556, 1], "end": [559, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.associatorNatIso", "code": "@[simps!]\ndef associatorNatIso : leftAssocTensor C \u2245 rightAssocTensor C :=\n  NatIso.ofComponents\n    (by\n      intros\n      apply MonoidalCategory.associator)\n    (by\n      intros\n      apply MonoidalCategory.associator_naturality)", "start": [565, 1], "end": [574, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.leftUnitorNatIso", "code": "@[simps!]\ndef leftUnitorNatIso : tensorUnitLeft C \u2245 \ud835\udfed C :=\n  NatIso.ofComponents\n    (by\n      intros\n      apply MonoidalCategory.leftUnitor)\n    (by\n      intros\n      apply MonoidalCategory.leftUnitor_naturality)", "start": [578, 1], "end": [587, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.rightUnitorNatIso", "code": "@[simps!]\ndef rightUnitorNatIso : tensorUnitRight C \u2245 \ud835\udfed C :=\n  NatIso.ofComponents\n    (by\n      intros\n      apply MonoidalCategory.rightUnitor)\n    (by\n      intros\n      apply MonoidalCategory.rightUnitor_naturality)", "start": [591, 1], "end": [600, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorLeft", "code": "@[simps]\ndef tensorLeft (X : C) : C \u2964 C where\n  obj Y := X \u2297 Y\n  map {Y} {Y'} f := \ud835\udfd9 X \u2297 f", "start": [608, 1], "end": [612, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorLeftTensor", "code": "def tensorLeftTensor (X Y : C) : tensorLeft (X \u2297 Y) \u2245 tensorLeft Y \u22d9 tensorLeft X :=\n  NatIso.ofComponents (associator _ _) fun {Z} {Z'} f => by\n    dsimp\n    rw [\u2190 tensor_id]\n    apply associator_naturality", "start": [615, 1], "end": [622, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorLeftTensor_hom_app", "code": "@[simp]\ntheorem tensorLeftTensor_hom_app (X Y Z : C) :\n    (tensorLeftTensor X Y).hom.app Z = (associator X Y Z).hom", "start": [625, 1], "end": [628, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorLeftTensor_inv_app", "code": "@[simp]\ntheorem tensorLeftTensor_inv_app (X Y Z : C) :\n    (tensorLeftTensor X Y).inv.app Z = (associator X Y Z).inv", "start": [631, 1], "end": [633, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorRight", "code": "@[simps]\ndef tensorRight (X : C) : C \u2964 C where\n  obj Y := Y \u2297 X\n  map {Y} {Y'} f := f \u2297 \ud835\udfd9 X", "start": [636, 1], "end": [640, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensoringLeft", "code": "@[simps]\ndef tensoringLeft : C \u2964 C \u2964 C where\n  obj := tensorLeft\n  map {X} {Y} f := { app := fun Z => f \u2297 \ud835\udfd9 Z }", "start": [646, 1], "end": [653, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensoringRight", "code": "@[simps]\ndef tensoringRight : C \u2964 C \u2964 C where\n  obj := tensorRight\n  map {X} {Y} f := { app := fun Z => \ud835\udfd9 Z \u2297 f }", "start": [662, 1], "end": [669, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorRightTensor", "code": "def tensorRightTensor (X Y : C) : tensorRight (X \u2297 Y) \u2245 tensorRight X \u22d9 tensorRight Y :=\n  NatIso.ofComponents (fun Z => (associator Z X Y).symm) fun {Z} {Z'} f => by\n    dsimp\n    rw [\u2190 tensor_id]\n    apply associator_inv_naturality", "start": [681, 1], "end": [688, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorRightTensor_hom_app", "code": "@[simp]\ntheorem tensorRightTensor_hom_app (X Y Z : C) :\n    (tensorRightTensor X Y).hom.app Z = (associator Z X Y).inv", "start": [691, 1], "end": [694, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.tensorRightTensor_inv_app", "code": "@[simp]\ntheorem tensorRightTensor_inv_app (X Y Z : C) :\n    (tensorRightTensor X Y).inv.app Z = (associator Z X Y).hom", "start": [697, 1], "end": [699, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.prodMonoidal", "code": "@[simps! tensorObj tensorHom tensorUnit' associator]\ninstance prodMonoidal : MonoidalCategory (C\u2081 \u00d7 C\u2082) where\n  tensorObj X Y := (X.1 \u2297 Y.1, X.2 \u2297 Y.2)\n  tensorHom f g := (f.1 \u2297 g.1, f.2 \u2297 g.2)\n  whiskerLeft X _ _ f := (whiskerLeft X.1 f.1, whiskerLeft X.2 f.2)\n  whiskerRight f X := (whiskerRight f.1 X.1, whiskerRight f.2 X.2)\n  tensorHom_def := by simp [tensorHom_def]\n  tensorUnit' := (\ud835\udfd9_ C\u2081, \ud835\udfd9_ C\u2082)\n  associator X Y Z := (\u03b1_ X.1 Y.1 Z.1).prod (\u03b1_ X.2 Y.2 Z.2)\n  leftUnitor := fun \u27e8X\u2081, X\u2082\u27e9 => (\u03bb_ X\u2081).prod (\u03bb_ X\u2082)\n  rightUnitor := fun \u27e8X\u2081, X\u2082\u27e9 => (\u03c1_ X\u2081).prod (\u03c1_ X\u2082)", "start": [716, 1], "end": [726, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.prodMonoidal_leftUnitor_hom_fst", "code": "@[simp]\ntheorem prodMonoidal_leftUnitor_hom_fst (X : C\u2081 \u00d7 C\u2082) :\n    ((\u03bb_ X).hom : \ud835\udfd9_ _ \u2297 X \u27f6 X).1 = (\u03bb_ X.1).hom", "start": [729, 1], "end": [733, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.prodMonoidal_leftUnitor_hom_snd", "code": "@[simp]\ntheorem prodMonoidal_leftUnitor_hom_snd (X : C\u2081 \u00d7 C\u2082) :\n    ((\u03bb_ X).hom : \ud835\udfd9_ _ \u2297 X \u27f6 X).2 = (\u03bb_ X.2).hom", "start": [736, 1], "end": [740, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.prodMonoidal_leftUnitor_inv_fst", "code": "@[simp]\ntheorem prodMonoidal_leftUnitor_inv_fst (X : C\u2081 \u00d7 C\u2082) :\n    ((\u03bb_ X).inv : X \u27f6 \ud835\udfd9_ _ \u2297 X).1 = (\u03bb_ X.1).inv", "start": [743, 1], "end": [747, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.prodMonoidal_leftUnitor_inv_snd", "code": "@[simp]\ntheorem prodMonoidal_leftUnitor_inv_snd (X : C\u2081 \u00d7 C\u2082) :\n    ((\u03bb_ X).inv : X \u27f6 \ud835\udfd9_ _ \u2297 X).2 = (\u03bb_ X.2).inv", "start": [750, 1], "end": [754, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.prodMonoidal_rightUnitor_hom_fst", "code": "@[simp]\ntheorem prodMonoidal_rightUnitor_hom_fst (X : C\u2081 \u00d7 C\u2082) :\n    ((\u03c1_ X).hom : X \u2297 \ud835\udfd9_ _ \u27f6 X).1 = (\u03c1_ X.1).hom", "start": [757, 1], "end": [761, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.prodMonoidal_rightUnitor_hom_snd", "code": "@[simp]\ntheorem prodMonoidal_rightUnitor_hom_snd (X : C\u2081 \u00d7 C\u2082) :\n    ((\u03c1_ X).hom : X \u2297 \ud835\udfd9_ _ \u27f6 X).2 = (\u03c1_ X.2).hom", "start": [764, 1], "end": [768, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.prodMonoidal_rightUnitor_inv_fst", "code": "@[simp]\ntheorem prodMonoidal_rightUnitor_inv_fst (X : C\u2081 \u00d7 C\u2082) :\n    ((\u03c1_ X).inv : X \u27f6 X \u2297 \ud835\udfd9_ _).1 = (\u03c1_ X.1).inv", "start": [771, 1], "end": [775, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalCategory.prodMonoidal_rightUnitor_inv_snd", "code": "@[simp]\ntheorem prodMonoidal_rightUnitor_inv_snd (X : C\u2081 \u00d7 C\u2082) :\n    ((\u03c1_ X).inv : X \u27f6 X \u2297 \ud835\udfd9_ _).2 = (\u03c1_ X.2).inv", "start": [778, 1], "end": [782, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/ContinuousFunction/Compact.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Bounded.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/CompactOpen.lean", "Mathlib/Topology/Sets/Compacts.lean", "Mathlib/Topology/UniformSpace/Compact.lean"], "premises": [{"full_name": "ContinuousMap.equivBoundedOfCompact", "code": "@[simps (config := { fullyApplied := false })]\ndef equivBoundedOfCompact : C(\u03b1, \u03b2) \u2243 (\u03b1 \u2192\u1d47 \u03b2) :=\n  \u27e8mkOfCompact, BoundedContinuousFunction.toContinuousMap, fun f => by\n    ext\n    rfl, fun f => by\n    ext\n    rfl\u27e9", "start": [46, 1], "end": [55, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.uniformInducing_equivBoundedOfCompact", "code": "theorem uniformInducing_equivBoundedOfCompact : UniformInducing (equivBoundedOfCompact \u03b1 \u03b2)", "start": [58, 1], "end": [68, 91], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.uniformEmbedding_equivBoundedOfCompact", "code": "theorem uniformEmbedding_equivBoundedOfCompact : UniformEmbedding (equivBoundedOfCompact \u03b1 \u03b2)", "start": [71, 1], "end": [72, 98], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.addEquivBoundedOfCompact", "code": "def addEquivBoundedOfCompact [AddMonoid \u03b2] [LipschitzAdd \u03b2] : C(\u03b1, \u03b2) \u2243+ (\u03b1 \u2192\u1d47 \u03b2) :=\n  ({ toContinuousMapAddHom \u03b1 \u03b2, (equivBoundedOfCompact \u03b1 \u03b2).symm with } : (\u03b1 \u2192\u1d47 \u03b2) \u2243+ C(\u03b1, \u03b2)).symm", "start": [75, 1], "end": [81, 100], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.addEquivBoundedOfCompact_symm_apply", "code": "@[simp]\ntheorem addEquivBoundedOfCompact_symm_apply [AddMonoid \u03b2] [LipschitzAdd \u03b2] :\n    \u21d1((addEquivBoundedOfCompact \u03b1 \u03b2).symm) = toContinuousMapAddHom \u03b1 \u03b2", "start": [85, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.addEquivBoundedOfCompact_apply", "code": "@[simp]\ntheorem addEquivBoundedOfCompact_apply [AddMonoid \u03b2] [LipschitzAdd \u03b2] :\n    \u21d1(addEquivBoundedOfCompact \u03b1 \u03b2) = mkOfCompact", "start": [91, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.metricSpace", "code": "instance metricSpace : MetricSpace C(\u03b1, \u03b2) :=\n  (uniformEmbedding_equivBoundedOfCompact \u03b1 \u03b2).comapMetricSpace _", "start": [96, 1], "end": [97, 66], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.isometryEquivBoundedOfCompact", "code": "@[simps! (config := { fullyApplied := false }) toEquiv apply symm_apply]\ndef isometryEquivBoundedOfCompact : C(\u03b1, \u03b2) \u2243\u1d62 (\u03b1 \u2192\u1d47 \u03b2) where\n  isometry_toFun _ _ := rfl\n  toEquiv := equivBoundedOfCompact \u03b1 \u03b2", "start": [100, 1], "end": [106, 39], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_mkOfCompact", "code": "@[simp]\ntheorem _root_.BoundedContinuousFunction.dist_mkOfCompact (f g : C(\u03b1, \u03b2)) :\n    dist (mkOfCompact f) (mkOfCompact g) = dist f g", "start": [111, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.dist_toContinuousMap", "code": "@[simp]\ntheorem _root_.BoundedContinuousFunction.dist_toContinuousMap (f g : \u03b1 \u2192\u1d47 \u03b2) :\n    dist f.toContinuousMap g.toContinuousMap = dist f g", "start": [117, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.dist_apply_le_dist", "code": "theorem dist_apply_le_dist (x : \u03b1) : dist (f x) (g x) \u2264 dist f g", "start": [129, 1], "end": [131, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.dist_le", "code": "theorem dist_le (C0 : (0 : \u211d) \u2264 C) : dist f g \u2264 C \u2194 \u2200 x : \u03b1, dist (f x) (g x) \u2264 C", "start": [134, 1], "end": [136, 90], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.dist_le_iff_of_nonempty", "code": "theorem dist_le_iff_of_nonempty [Nonempty \u03b1] : dist f g \u2264 C \u2194 \u2200 x, dist (f x) (g x) \u2264 C", "start": [139, 1], "end": [141, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.dist_lt_iff_of_nonempty", "code": "theorem dist_lt_iff_of_nonempty [Nonempty \u03b1] : dist f g < C \u2194 \u2200 x : \u03b1, dist (f x) (g x) < C", "start": [144, 1], "end": [145, 85], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.dist_lt_of_nonempty", "code": "theorem dist_lt_of_nonempty [Nonempty \u03b1] (w : \u2200 x : \u03b1, dist (f x) (g x) < C) : dist f g < C", "start": [148, 1], "end": [149, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.dist_lt_iff", "code": "theorem dist_lt_iff (C0 : (0 : \u211d) < C) : dist f g < C \u2194 \u2200 x : \u03b1, dist (f x) (g x) < C", "start": [152, 1], "end": [154, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_eval", "code": "@[continuity]\ntheorem continuous_eval : Continuous fun p : C(\u03b1, \u03b2) \u00d7 \u03b1 => p.1 p.2", "start": [162, 1], "end": [165, 95], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_mkOfCompact", "code": "@[simp]\ntheorem _root_.BoundedContinuousFunction.norm_mkOfCompact (f : C(\u03b1, E)) : \u2016mkOfCompact f\u2016 = \u2016f\u2016", "start": [172, 1], "end": [174, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.norm_toContinuousMap_eq", "code": "@[simp]\ntheorem _root_.BoundedContinuousFunction.norm_toContinuousMap_eq (f : \u03b1 \u2192\u1d47 E) :\n    \u2016f.toContinuousMap\u2016 = \u2016f\u2016", "start": [177, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.norm_coe_le_norm", "code": "theorem norm_coe_le_norm (x : \u03b1) : \u2016f x\u2016 \u2264 \u2016f\u2016", "start": [202, 1], "end": [203, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.dist_le_two_norm", "code": "theorem dist_le_two_norm (x y : \u03b1) : dist (f x) (f y) \u2264 2 * \u2016f\u2016", "start": [206, 1], "end": [208, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.norm_le", "code": "theorem norm_le {C : \u211d} (C0 : (0 : \u211d) \u2264 C) : \u2016f\u2016 \u2264 C \u2194 \u2200 x : \u03b1, \u2016f x\u2016 \u2264 C", "start": [211, 1], "end": [213, 66], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.norm_le_of_nonempty", "code": "theorem norm_le_of_nonempty [Nonempty \u03b1] {M : \u211d} : \u2016f\u2016 \u2264 M \u2194 \u2200 x, \u2016f x\u2016 \u2264 M", "start": [216, 1], "end": [217, 77], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.norm_lt_iff", "code": "theorem norm_lt_iff {M : \u211d} (M0 : 0 < M) : \u2016f\u2016 < M \u2194 \u2200 x, \u2016f x\u2016 < M", "start": [220, 1], "end": [221, 83], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.nnnorm_lt_iff", "code": "theorem nnnorm_lt_iff {M : \u211d\u22650} (M0 : 0 < M) : \u2016f\u2016\u208a < M \u2194 \u2200 x : \u03b1, \u2016f x\u2016\u208a < M", "start": [224, 1], "end": [225, 19], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.norm_lt_iff_of_nonempty", "code": "theorem norm_lt_iff_of_nonempty [Nonempty \u03b1] {M : \u211d} : \u2016f\u2016 < M \u2194 \u2200 x, \u2016f x\u2016 < M", "start": [228, 1], "end": [229, 91], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.nnnorm_lt_iff_of_nonempty", "code": "theorem nnnorm_lt_iff_of_nonempty [Nonempty \u03b1] {M : \u211d\u22650} : \u2016f\u2016\u208a < M \u2194 \u2200 x, \u2016f x\u2016\u208a < M", "start": [232, 1], "end": [233, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.apply_le_norm", "code": "theorem apply_le_norm (f : C(\u03b1, \u211d)) (x : \u03b1) : f x \u2264 \u2016f\u2016", "start": [236, 1], "end": [237, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.neg_norm_le_apply", "code": "theorem neg_norm_le_apply (f : C(\u03b1, \u211d)) (x : \u03b1) : -\u2016f\u2016 \u2264 f x", "start": [240, 1], "end": [241, 83], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.norm_eq_iSup_norm", "code": "theorem norm_eq_iSup_norm : \u2016f\u2016 = \u2a06 x : \u03b1, \u2016f x\u2016", "start": [244, 1], "end": [245, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.norm_restrict_mono_set", "code": "theorem norm_restrict_mono_set {X : Type*} [TopologicalSpace X] (f : C(X, E))\n    {K L : TopologicalSpace.Compacts X} (hKL : K \u2264 L) : \u2016f.restrict K\u2016 \u2264 \u2016f.restrict L\u2016", "start": [248, 1], "end": [250, 98], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.normedSpace", "code": "instance normedSpace : NormedSpace \ud835\udd5c C(\u03b1, E) where\n  norm_smul_le c f := (norm_smul_le c (mkOfCompact f) : _)", "start": [269, 1], "end": [270, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.linearIsometryBoundedOfCompact", "code": "def linearIsometryBoundedOfCompact : C(\u03b1, E) \u2243\u2097\u1d62[\ud835\udd5c] \u03b1 \u2192\u1d47 E :=\n  { addEquivBoundedOfCompact \u03b1 E with\n    map_smul' := fun c f => by\n      ext\n      norm_cast\n    norm_map' := fun f => rfl }", "start": [277, 1], "end": [286, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.evalClm", "code": "def evalClm (x : \u03b1) : C(\u03b1, E) \u2192L[\ud835\udd5c] E :=\n  (BoundedContinuousFunction.evalClm \ud835\udd5c x).comp\n    (linearIsometryBoundedOfCompact \u03b1 E \ud835\udd5c).toLinearIsometry.toContinuousLinearMap", "start": [292, 1], "end": [295, 82], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.linearIsometryBoundedOfCompact_symm_apply", "code": "@[simp]\ntheorem linearIsometryBoundedOfCompact_symm_apply (f : \u03b1 \u2192\u1d47 E) :\n    (linearIsometryBoundedOfCompact \u03b1 E \ud835\udd5c).symm f = f.toContinuousMap", "start": [302, 1], "end": [305, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.linearIsometryBoundedOfCompact_apply_apply", "code": "@[simp]\ntheorem linearIsometryBoundedOfCompact_apply_apply (f : C(\u03b1, E)) (a : \u03b1) :\n    (linearIsometryBoundedOfCompact \u03b1 E \ud835\udd5c f) a = f a", "start": [308, 1], "end": [311, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.linearIsometryBoundedOfCompact_toIsometryEquiv", "code": "@[simp]\ntheorem linearIsometryBoundedOfCompact_toIsometryEquiv :\n    (linearIsometryBoundedOfCompact \u03b1 E \ud835\udd5c).toIsometryEquiv = isometryEquivBoundedOfCompact \u03b1 E", "start": [314, 1], "end": [317, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.linearIsometryBoundedOfCompact_toAddEquiv", "code": "@[simp] theorem linearIsometryBoundedOfCompact_toAddEquiv :\n    ((linearIsometryBoundedOfCompact \u03b1 E \ud835\udd5c).toLinearEquiv : C(\u03b1, E) \u2243+ (\u03b1 \u2192\u1d47 E)) =\n      addEquivBoundedOfCompact \u03b1 E", "start": [320, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.linearIsometryBoundedOfCompact_of_compact_toEquiv", "code": "@[simp]\ntheorem linearIsometryBoundedOfCompact_of_compact_toEquiv :\n    (linearIsometryBoundedOfCompact \u03b1 E \ud835\udd5c).toLinearEquiv.toEquiv = equivBoundedOfCompact \u03b1 E", "start": [327, 1], "end": [330, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.uniform_continuity", "code": "theorem uniform_continuity (f : C(\u03b1, \u03b2)) (\u03b5 : \u211d) (h : 0 < \u03b5) :\n    \u2203 \u03b4 > 0, \u2200 {x y}, dist x y < \u03b4 \u2192 dist (f x) (f y) < \u03b5", "start": [359, 1], "end": [361, 98], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.modulus", "code": "def modulus (f : C(\u03b1, \u03b2)) (\u03b5 : \u211d) (h : 0 < \u03b5) : \u211d :=\n  Classical.choose (uniform_continuity f \u03b5 h)", "start": [367, 1], "end": [369, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.modulus_pos", "code": "theorem modulus_pos (f : C(\u03b1, \u03b2)) {\u03b5 : \u211d} {h : 0 < \u03b5} : 0 < f.modulus \u03b5 h", "start": [372, 1], "end": [373, 55], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.dist_lt_of_dist_lt_modulus", "code": "theorem dist_lt_of_dist_lt_modulus (f : C(\u03b1, \u03b2)) (\u03b5 : \u211d) (h : 0 < \u03b5) {a b : \u03b1}\n    (w : dist a b < f.modulus \u03b5 h) : dist (f a) (f b) < \u03b5", "start": [376, 1], "end": [378, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compLeftContinuousCompact", "code": "protected def ContinuousLinearMap.compLeftContinuousCompact (g : \u03b2 \u2192L[\ud835\udd5c] \u03b3) :\n    C(X, \u03b2) \u2192L[\ud835\udd5c] C(X, \u03b3) :=\n  (linearIsometryBoundedOfCompact X \u03b3 \ud835\udd5c).symm.toLinearIsometry.toContinuousLinearMap.comp <|\n    (g.compLeftContinuousBounded X).comp <|\n      (linearIsometryBoundedOfCompact X \u03b2 \ud835\udd5c).toLinearIsometry.toContinuousLinearMap", "start": [394, 1], "end": [403, 84], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toLinear_compLeftContinuousCompact", "code": "@[simp]\ntheorem ContinuousLinearMap.toLinear_compLeftContinuousCompact (g : \u03b2 \u2192L[\ud835\udd5c] \u03b3) :\n    (g.compLeftContinuousCompact X : C(X, \u03b2) \u2192\u2097[\ud835\udd5c] C(X, \u03b3)) = g.compLeftContinuous \ud835\udd5c X", "start": [406, 1], "end": [410, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compLeftContinuousCompact_apply", "code": "@[simp]\ntheorem ContinuousLinearMap.compLeftContinuousCompact_apply (g : \u03b2 \u2192L[\ud835\udd5c] \u03b3) (f : C(X, \u03b2)) (x : X) :\n    g.compLeftContinuousCompact X f x = g (f x)", "start": [413, 1], "end": [416, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compRightContinuousMap", "code": "def compRightContinuousMap {X Y : Type*} (T : Type*) [TopologicalSpace X] [CompactSpace X]\n    [TopologicalSpace Y] [CompactSpace Y] [MetricSpace T] (f : C(X, Y)) : C(C(Y, T), C(X, T)) where\n  toFun g := g.comp f\n  continuous_toFun := by\n    refine' Metric.continuous_iff.mpr _\n    intro g \u03b5 \u03b5_pos\n    refine' \u27e8\u03b5, \u03b5_pos, fun g' h => _\u27e9\n    rw [ContinuousMap.dist_lt_iff \u03b5_pos] at h \u22a2\n    exact fun x => h (f x)", "start": [437, 1], "end": [447, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compRightContinuousMap_apply", "code": "@[simp]\ntheorem compRightContinuousMap_apply {X Y : Type*} (T : Type*) [TopologicalSpace X]\n    [CompactSpace X] [TopologicalSpace Y] [CompactSpace Y] [MetricSpace T] (f : C(X, Y))\n    (g : C(Y, T)) : (compRightContinuousMap T f) g = g.comp f", "start": [450, 1], "end": [454, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compRightHomeomorph", "code": "def compRightHomeomorph {X Y : Type*} (T : Type*) [TopologicalSpace X] [CompactSpace X]\n    [TopologicalSpace Y] [CompactSpace Y] [MetricSpace T] (f : X \u2243\u209c Y) : C(Y, T) \u2243\u209c C(X, T) where\n  toFun := compRightContinuousMap T f.toContinuousMap\n  invFun := compRightContinuousMap T f.symm.toContinuousMap\n  left_inv g := ext fun _ => congr_arg g (f.apply_symm_apply _)\n  right_inv g := ext fun _ => congr_arg g (f.symm_apply_apply _)", "start": [457, 1], "end": [464, 65], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compRightAlgHom_continuous", "code": "theorem compRightAlgHom_continuous {X Y : Type*} (R A : Type*) [TopologicalSpace X]\n    [CompactSpace X] [TopologicalSpace Y] [CompactSpace Y] [CommSemiring R] [Semiring A]\n    [MetricSpace A] [TopologicalSemiring A] [Algebra R A] (f : C(X, Y)) :\n    Continuous (compRightAlgHom R A f)", "start": [467, 1], "end": [471, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.summable_of_locally_summable_norm", "code": "theorem summable_of_locally_summable_norm {\u03b9 : Type*} {F : \u03b9 \u2192 C(X, E)}\n    (hF : \u2200 K : Compacts X, Summable fun i => \u2016(F i).restrict K\u2016) : Summable F", "start": [491, 1], "end": [503, 64], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.mkOfCompact_star", "code": "theorem _root_.BoundedContinuousFunction.mkOfCompact_star [CompactSpace \u03b1] (f : C(\u03b1, \u03b2)) :\n    mkOfCompact (star f) = star (mkOfCompact f)", "start": [523, 1], "end": [525, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/OpenPos.lean", "imports": ["Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.Measure.IsOpenPosMeasure", "code": "class IsOpenPosMeasure : Prop where\n  open_pos : \u2200 U : Set X, IsOpen U \u2192 U.Nonempty \u2192 \u03bc U \u2260 0", "start": [35, 1], "end": [37, 58], "kind": "commanddeclaration"}, {"full_name": "IsOpen.measure_ne_zero", "code": "theorem _root_.IsOpen.measure_ne_zero (hU : IsOpen U) (hne : U.Nonempty) : \u03bc U \u2260 0", "start": [42, 1], "end": [43, 37], "kind": "commanddeclaration"}, {"full_name": "IsOpen.measure_pos", "code": "theorem _root_.IsOpen.measure_pos (hU : IsOpen U) (hne : U.Nonempty) : 0 < \u03bc U", "start": [46, 1], "end": [47, 36], "kind": "commanddeclaration"}, {"full_name": "IsOpen.measure_pos_iff", "code": "theorem _root_.IsOpen.measure_pos_iff (hU : IsOpen U) : 0 < \u03bc U \u2194 U.Nonempty", "start": [53, 1], "end": [54, 98], "kind": "commanddeclaration"}, {"full_name": "IsOpen.measure_eq_zero_iff", "code": "theorem _root_.IsOpen.measure_eq_zero_iff (hU : IsOpen U) : \u03bc U = 0 \u2194 U = \u2205", "start": [57, 1], "end": [59, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_pos_of_nonempty_interior", "code": "theorem measure_pos_of_nonempty_interior (h : (interior s).Nonempty) : 0 < \u03bc s", "start": [62, 1], "end": [63, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_pos_of_mem_nhds", "code": "theorem measure_pos_of_mem_nhds (h : s \u2208 \ud835\udcdd x) : 0 < \u03bc s", "start": [66, 1], "end": [67, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.isOpenPosMeasure_smul", "code": "theorem isOpenPosMeasure_smul {c : \u211d\u22650\u221e} (h : c \u2260 0) : IsOpenPosMeasure (c \u2022 \u03bc)", "start": [70, 1], "end": [71, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.AbsolutelyContinuous.isOpenPosMeasure", "code": "protected theorem AbsolutelyContinuous.isOpenPosMeasure (h : \u03bc \u226a \u03bd) : IsOpenPosMeasure \u03bd", "start": [76, 1], "end": [77, 56], "kind": "commanddeclaration"}, {"full_name": "LE.le.isOpenPosMeasure", "code": "theorem _root_.LE.le.isOpenPosMeasure (h : \u03bc \u2264 \u03bd) : IsOpenPosMeasure \u03bd", "start": [80, 1], "end": [81, 42], "kind": "commanddeclaration"}, {"full_name": "IsOpen.measure_zero_iff_eq_empty", "code": "theorem _root_.IsOpen.measure_zero_iff_eq_empty (hU : IsOpen U) :\n    \u03bc U = 0 \u2194 U = \u2205", "start": [84, 1], "end": [86, 65], "kind": "commanddeclaration"}, {"full_name": "IsOpen.ae_eq_empty_iff_eq", "code": "theorem _root_.IsOpen.ae_eq_empty_iff_eq (hU : IsOpen U) :\n    U =\u1d50[\u03bc] (\u2205 : Set X) \u2194 U = \u2205", "start": [88, 1], "end": [90, 49], "kind": "commanddeclaration"}, {"full_name": "IsOpen.eq_empty_of_measure_zero", "code": "theorem _root_.IsOpen.eq_empty_of_measure_zero (hU : IsOpen U) (h\u2080 : \u03bc U = 0) : U = \u2205", "start": [92, 1], "end": [93, 35], "kind": "commanddeclaration"}, {"full_name": "IsClosed.ae_eq_univ_iff_eq", "code": "theorem _root_.IsClosed.ae_eq_univ_iff_eq (hF : IsClosed F) :\n    F =\u1d50[\u03bc] univ \u2194 F = univ", "start": [96, 1], "end": [99, 80], "kind": "commanddeclaration"}, {"full_name": "IsClosed.measure_eq_univ_iff_eq", "code": "theorem _root_.IsClosed.measure_eq_univ_iff_eq [OpensMeasurableSpace X] [IsFiniteMeasure \u03bc]\n    (hF : IsClosed F) :\n    \u03bc F = \u03bc univ \u2194 F = univ", "start": [101, 1], "end": [104, 92], "kind": "commanddeclaration"}, {"full_name": "IsClosed.measure_eq_one_iff_eq_univ", "code": "theorem _root_.IsClosed.measure_eq_one_iff_eq_univ [OpensMeasurableSpace X] [IsProbabilityMeasure \u03bc]\n    (hF : IsClosed F) :\n    \u03bc F = 1 \u2194 F = univ", "start": [106, 1], "end": [109, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.interior_eq_empty_of_null", "code": "theorem interior_eq_empty_of_null (hs : \u03bc s = 0) : interior s = \u2205", "start": [111, 1], "end": [112, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.eqOn_open_of_ae_eq", "code": "theorem eqOn_open_of_ae_eq {f g : X \u2192 Y} (h : f =\u1d50[\u03bc.restrict U] g) (hU : IsOpen U)\n    (hf : ContinuousOn f U) (hg : ContinuousOn g U) : EqOn f g U", "start": [115, 1], "end": [128, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.eq_of_ae_eq", "code": "theorem eq_of_ae_eq {f g : X \u2192 Y} (h : f =\u1d50[\u03bc] g) (hf : Continuous f) (hg : Continuous g) : f = g", "start": [131, 1], "end": [134, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.eqOn_of_ae_eq", "code": "theorem eqOn_of_ae_eq {f g : X \u2192 Y} (h : f =\u1d50[\u03bc.restrict s] g) (hf : ContinuousOn f s)\n    (hg : ContinuousOn g s) (hU : s \u2286 closure (interior s)) : EqOn f g s", "start": [137, 1], "end": [142, 18], "kind": "commanddeclaration"}, {"full_name": "Continuous.ae_eq_iff_eq", "code": "theorem _root_.Continuous.ae_eq_iff_eq {f g : X \u2192 Y} (hf : Continuous f) (hg : Continuous g) :\n    f =\u1d50[\u03bc] g \u2194 f = g", "start": [147, 1], "end": [149, 64], "kind": "commanddeclaration"}, {"full_name": "Continuous.isOpenPosMeasure_map", "code": "theorem _root_.Continuous.isOpenPosMeasure_map [OpensMeasurableSpace X]\n    {Z : Type*} [TopologicalSpace Z] [MeasurableSpace Z] [BorelSpace Z]\n    {f : X \u2192 Z} (hf : Continuous f) (hf_surj : Function.Surjective f) :\n    (Measure.map f \u03bc).IsOpenPosMeasure", "start": [154, 1], "end": [160, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_Ioi_pos", "code": "theorem measure_Ioi_pos [NoMaxOrder X] (a : X) : 0 < \u03bc (Ioi a)", "start": [170, 1], "end": [171, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_Iio_pos", "code": "theorem measure_Iio_pos [NoMinOrder X] (a : X) : 0 < \u03bc (Iio a)", "start": [174, 1], "end": [175, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_Ioo_pos", "code": "theorem measure_Ioo_pos [DenselyOrdered X] {a b : X} : 0 < \u03bc (Ioo a b) \u2194 a < b", "start": [178, 1], "end": [179, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.measure_Ioo_eq_zero", "code": "theorem measure_Ioo_eq_zero [DenselyOrdered X] {a b : X} : \u03bc (Ioo a b) = 0 \u2194 b \u2264 a", "start": [182, 1], "end": [183, 75], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.eqOn_Ioo_of_ae_eq", "code": "theorem eqOn_Ioo_of_ae_eq {a b : X} {f g : X \u2192 Y} (hfg : f =\u1d50[\u03bc.restrict (Ioo a b)] g)\n    (hf : ContinuousOn f (Ioo a b)) (hg : ContinuousOn g (Ioo a b)) : EqOn f g (Ioo a b)", "start": [186, 1], "end": [188, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.eqOn_Ioc_of_ae_eq", "code": "theorem eqOn_Ioc_of_ae_eq [DenselyOrdered X] {a b : X} {f g : X \u2192 Y}\n    (hfg : f =\u1d50[\u03bc.restrict (Ioc a b)] g) (hf : ContinuousOn f (Ioc a b))\n    (hg : ContinuousOn g (Ioc a b)) : EqOn f g (Ioc a b)", "start": [191, 1], "end": [194, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.eqOn_Ico_of_ae_eq", "code": "theorem eqOn_Ico_of_ae_eq [DenselyOrdered X] {a b : X} {f g : X \u2192 Y}\n    (hfg : f =\u1d50[\u03bc.restrict (Ico a b)] g) (hf : ContinuousOn f (Ico a b))\n    (hg : ContinuousOn g (Ico a b)) : EqOn f g (Ico a b)", "start": [197, 1], "end": [200, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.eqOn_Icc_of_ae_eq", "code": "theorem eqOn_Icc_of_ae_eq [DenselyOrdered X] {a b : X} (hne : a \u2260 b) {f g : X \u2192 Y}\n    (hfg : f =\u1d50[\u03bc.restrict (Icc a b)] g) (hf : ContinuousOn f (Icc a b))\n    (hg : ContinuousOn g (Icc a b)) : EqOn f g (Icc a b)", "start": [203, 1], "end": [206, 65], "kind": "commanddeclaration"}, {"full_name": "Metric.measure_ball_pos", "code": "theorem measure_ball_pos (x : X) {r : \u211d} (hr : 0 < r) : 0 < \u03bc (ball x r)", "start": [222, 1], "end": [223, 49], "kind": "commanddeclaration"}, {"full_name": "Metric.measure_closedBall_pos", "code": "theorem measure_closedBall_pos (x : X) {r : \u211d} (hr : 0 < r) : 0 < \u03bc (closedBall x r)", "start": [226, 1], "end": [228, 75], "kind": "commanddeclaration"}, {"full_name": "Metric.measure_closedBall_pos_iff", "code": "@[simp] lemma measure_closedBall_pos_iff {X : Type*} [MetricSpace X] {m : MeasurableSpace X}\n    (\u03bc : Measure X) [IsOpenPosMeasure \u03bc] [NoAtoms \u03bc] {x : X} {r : \u211d} :\n    0 < \u03bc (closedBall x r) \u2194 0 < r := by\n  refine' \u27e8fun h \u21a6 _, measure_closedBall_pos \u03bc x\u27e9\n  contrapose! h\n  rw [(subsingleton_closedBall x h).measure_zero \u03bc]", "start": [231, 1], "end": [236, 52], "kind": "mathlibtacticlemma"}, {"full_name": "EMetric.measure_ball_pos", "code": "theorem measure_ball_pos (x : X) {r : \u211d\u22650\u221e} (hr : r \u2260 0) : 0 < \u03bc (ball x r)", "start": [245, 1], "end": [246, 57], "kind": "commanddeclaration"}, {"full_name": "EMetric.measure_closedBall_pos", "code": "theorem measure_closedBall_pos (x : X) {r : \u211d\u22650\u221e} (hr : r \u2260 0) : 0 < \u03bc (closedBall x r)", "start": [249, 1], "end": [250, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/LpSeminorm.lean", "imports": ["Mathlib/MeasureTheory/Integral/MeanInequalities.lean", "Mathlib/Analysis/NormedSpace/IndicatorFunction.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean", "Mathlib/MeasureTheory/Function/AEEqFun.lean", "Mathlib/MeasureTheory/Function/EssSup.lean"], "premises": [{"full_name": "MeasureTheory.snorm'", "code": "def snorm' {_ : MeasurableSpace \u03b1} (f : \u03b1 \u2192 F) (q : \u211d) (\u03bc : Measure \u03b1) : \u211d\u22650\u221e :=\n  (\u222b\u207b a, (\u2016f a\u2016\u208a : \u211d\u22650\u221e) ^ q \u2202\u03bc) ^ (1 / q)", "start": [71, 1], "end": [74, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup", "code": "def snormEssSup {_ : MeasurableSpace \u03b1} (f : \u03b1 \u2192 F) (\u03bc : Measure \u03b1) :=\n  essSup (fun x => (\u2016f x\u2016\u208a : \u211d\u22650\u221e)) \u03bc", "start": [77, 1], "end": [79, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm", "code": "def snorm {_ : MeasurableSpace \u03b1} (f : \u03b1 \u2192 F) (p : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : \u211d\u22650\u221e :=\n  if p = 0 then 0 else if p = \u221e then snormEssSup f \u03bc else snorm' f (ENNReal.toReal p) \u03bc", "start": [82, 1], "end": [85, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_eq_snorm'", "code": "theorem snorm_eq_snorm' (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e) {f : \u03b1 \u2192 F} :\n    snorm f p \u03bc = snorm' f (ENNReal.toReal p) \u03bc", "start": [88, 1], "end": [89, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_eq_lintegral_rpow_nnnorm", "code": "theorem snorm_eq_lintegral_rpow_nnnorm (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e) {f : \u03b1 \u2192 F} :\n    snorm f p \u03bc = (\u222b\u207b x, (\u2016f x\u2016\u208a : \u211d\u22650\u221e) ^ p.toReal \u2202\u03bc) ^ (1 / p.toReal)", "start": [92, 1], "end": [94, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_one_eq_lintegral_nnnorm", "code": "theorem snorm_one_eq_lintegral_nnnorm {f : \u03b1 \u2192 F} : snorm f 1 \u03bc = \u222b\u207b x, \u2016f x\u2016\u208a \u2202\u03bc", "start": [97, 1], "end": [99, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_exponent_top", "code": "@[simp]\ntheorem snorm_exponent_top {f : \u03b1 \u2192 F} : snorm f \u221e \u03bc = snormEssSup f \u03bc", "start": [102, 1], "end": [103, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p", "code": "def Mem\u2112p {\u03b1} {_ : MeasurableSpace \u03b1} (f : \u03b1 \u2192 E) (p : \u211d\u22650\u221e)\n    (\u03bc : Measure \u03b1 := by volume_tac) : Prop :=\n  AEStronglyMeasurable f \u03bc \u2227 snorm f p \u03bc < \u221e", "start": [106, 1], "end": [110, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_def", "code": "theorem mem\u2112p_def {\u03b1} {_ : MeasurableSpace \u03b1} (f : \u03b1 \u2192 E) (p : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) :\n    Mem\u2112p f p \u03bc \u2194 (AEStronglyMeasurable f \u03bc \u2227 snorm f p \u03bc < \u221e)", "start": [114, 1], "end": [116, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.aestronglyMeasurable", "code": "theorem Mem\u2112p.aestronglyMeasurable {f : \u03b1 \u2192 E} {p : \u211d\u22650\u221e} (h : Mem\u2112p f p \u03bc) :\n    AEStronglyMeasurable f \u03bc", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_rpow_nnnorm_eq_rpow_snorm'", "code": "theorem lintegral_rpow_nnnorm_eq_rpow_snorm' {f : \u03b1 \u2192 F} (hq0_lt : 0 < q) :\n    (\u222b\u207b a, (\u2016f a\u2016\u208a : \u211d\u22650\u221e) ^ q \u2202\u03bc) = snorm' f q \u03bc ^ q", "start": [125, 1], "end": [128, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.snorm_lt_top", "code": "theorem Mem\u2112p.snorm_lt_top {f : \u03b1 \u2192 E} (hfp : Mem\u2112p f p \u03bc) : snorm f p \u03bc < \u221e", "start": [135, 1], "end": [136, 8], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.snorm_ne_top", "code": "theorem Mem\u2112p.snorm_ne_top {f : \u03b1 \u2192 E} (hfp : Mem\u2112p f p \u03bc) : snorm f p \u03bc \u2260 \u221e", "start": [139, 1], "end": [140, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_rpow_nnnorm_lt_top_of_snorm'_lt_top", "code": "theorem lintegral_rpow_nnnorm_lt_top_of_snorm'_lt_top {f : \u03b1 \u2192 F} (hq0_lt : 0 < q)\n    (hfq : snorm' f q \u03bc < \u221e) : (\u222b\u207b a, (\u2016f a\u2016\u208a : \u211d\u22650\u221e) ^ q \u2202\u03bc) < \u221e", "start": [143, 1], "end": [146, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_rpow_nnnorm_lt_top_of_snorm_lt_top", "code": "theorem lintegral_rpow_nnnorm_lt_top_of_snorm_lt_top {f : \u03b1 \u2192 F} (hp_ne_zero : p \u2260 0)\n    (hp_ne_top : p \u2260 \u221e) (hfp : snorm f p \u03bc < \u221e) : (\u222b\u207b a, (\u2016f a\u2016\u208a : \u211d\u22650\u221e) ^ p.toReal \u2202\u03bc) < \u221e", "start": [149, 1], "end": [153, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_lt_top_iff_lintegral_rpow_nnnorm_lt_top", "code": "theorem snorm_lt_top_iff_lintegral_rpow_nnnorm_lt_top {f : \u03b1 \u2192 F} (hp_ne_zero : p \u2260 0)\n    (hp_ne_top : p \u2260 \u221e) : snorm f p \u03bc < \u221e \u2194 (\u222b\u207b a, (\u2016f a\u2016\u208a : \u211d\u22650\u221e) ^ p.toReal \u2202\u03bc) < \u221e", "start": [156, 1], "end": [163, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_exponent_zero", "code": "@[simp]\ntheorem snorm'_exponent_zero {f : \u03b1 \u2192 F} : snorm' f 0 \u03bc = 1", "start": [170, 1], "end": [172, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_exponent_zero", "code": "@[simp]\ntheorem snorm_exponent_zero {f : \u03b1 \u2192 F} : snorm f 0 \u03bc = 0", "start": [175, 1], "end": [176, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_zero_iff_aestronglyMeasurable", "code": "theorem mem\u2112p_zero_iff_aestronglyMeasurable {f : \u03b1 \u2192 E} : Mem\u2112p f 0 \u03bc \u2194 AEStronglyMeasurable f \u03bc", "start": [179, 1], "end": [180, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_zero", "code": "@[simp]\ntheorem snorm'_zero (hp0_lt : 0 < q) : snorm' (0 : \u03b1 \u2192 F) q \u03bc = 0", "start": [183, 1], "end": [184, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_zero'", "code": "@[simp]\ntheorem snorm'_zero' (hq0_ne : q \u2260 0) (h\u03bc : \u03bc \u2260 0) : snorm' (0 : \u03b1 \u2192 F) q \u03bc = 0", "start": [187, 1], "end": [191, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_zero", "code": "@[simp]\ntheorem snormEssSup_zero : snormEssSup (0 : \u03b1 \u2192 F) \u03bc = 0", "start": [194, 1], "end": [197, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_zero", "code": "@[simp]\ntheorem snorm_zero : snorm (0 : \u03b1 \u2192 F) p \u03bc = 0", "start": [200, 1], "end": [207, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_zero'", "code": "@[simp]\ntheorem snorm_zero' : snorm (fun _ : \u03b1 => (0 : F)) p \u03bc = 0", "start": [210, 1], "end": [211, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.zero_mem\u2112p", "code": "theorem zero_mem\u2112p : Mem\u2112p (0 : \u03b1 \u2192 E) p \u03bc", "start": [214, 1], "end": [217, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.zero_mem_\u2112p'", "code": "theorem zero_mem_\u2112p' : Mem\u2112p (fun _ : \u03b1 => (0 : E)) p \u03bc", "start": [220, 1], "end": [220, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_measure_zero_of_pos", "code": "theorem snorm'_measure_zero_of_pos {f : \u03b1 \u2192 F} (hq_pos : 0 < q) : snorm' f q (0 : Measure \u03b1) = 0", "start": [225, 1], "end": [226, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_measure_zero_of_exponent_zero", "code": "theorem snorm'_measure_zero_of_exponent_zero {f : \u03b1 \u2192 F} : snorm' f 0 (0 : Measure \u03b1) = 1", "start": [229, 1], "end": [230, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_measure_zero_of_neg", "code": "theorem snorm'_measure_zero_of_neg {f : \u03b1 \u2192 F} (hq_neg : q < 0) : snorm' f q (0 : Measure \u03b1) = \u221e", "start": [233, 1], "end": [234, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_measure_zero", "code": "@[simp]\ntheorem snormEssSup_measure_zero {f : \u03b1 \u2192 F} : snormEssSup f (0 : Measure \u03b1) = 0", "start": [237, 1], "end": [239, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_measure_zero", "code": "@[simp]\ntheorem snorm_measure_zero {f : \u03b1 \u2192 F} : snorm f p (0 : Measure \u03b1) = 0", "start": [242, 1], "end": [249, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_neg", "code": "@[simp]\ntheorem snorm'_neg {f : \u03b1 \u2192 F} : snorm' (-f) q \u03bc = snorm' f q \u03bc", "start": [256, 1], "end": [257, 84], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_neg", "code": "@[simp]\ntheorem snorm_neg {f : \u03b1 \u2192 F} : snorm (-f) p \u03bc = snorm f p \u03bc", "start": [260, 1], "end": [266, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.neg", "code": "theorem Mem\u2112p.neg {f : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) : Mem\u2112p (-f) p \u03bc", "start": [269, 1], "end": [270, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_neg_iff", "code": "theorem mem\u2112p_neg_iff {f : \u03b1 \u2192 E} : Mem\u2112p (-f) p \u03bc \u2194 Mem\u2112p f p \u03bc", "start": [273, 1], "end": [274, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_const", "code": "theorem snorm'_const (c : F) (hq_pos : 0 < q) :\n    snorm' (fun _ : \u03b1 => c) q \u03bc = (\u2016c\u2016\u208a : \u211d\u22650\u221e) * \u03bc Set.univ ^ (1 / q)", "start": [281, 1], "end": [287, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_const'", "code": "theorem snorm'_const' [IsFiniteMeasure \u03bc] (c : F) (hc_ne_zero : c \u2260 0) (hq_ne_zero : q \u2260 0) :\n    snorm' (fun _ : \u03b1 => c) q \u03bc = (\u2016c\u2016\u208a : \u211d\u22650\u221e) * \u03bc Set.univ ^ (1 / q)", "start": [290, 1], "end": [302, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_const", "code": "theorem snormEssSup_const (c : F) (h\u03bc : \u03bc \u2260 0) : snormEssSup (fun _ : \u03b1 => c) \u03bc = (\u2016c\u2016\u208a : \u211d\u22650\u221e)", "start": [305, 1], "end": [306, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_const_of_isProbabilityMeasure", "code": "theorem snorm'_const_of_isProbabilityMeasure (c : F) (hq_pos : 0 < q) [IsProbabilityMeasure \u03bc] :\n    snorm' (fun _ : \u03b1 => c) q \u03bc = (\u2016c\u2016\u208a : \u211d\u22650\u221e)", "start": [309, 1], "end": [310, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_const", "code": "theorem snorm_const (c : F) (h0 : p \u2260 0) (h\u03bc : \u03bc \u2260 0) :\n    snorm (fun _ : \u03b1 => c) p \u03bc = (\u2016c\u2016\u208a : \u211d\u22650\u221e) * \u03bc Set.univ ^ (1 / ENNReal.toReal p)", "start": [313, 1], "end": [317, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_const'", "code": "theorem snorm_const' (c : F) (h0 : p \u2260 0) (h_top : p \u2260 \u221e) :\n    snorm (fun _ : \u03b1 => c) p \u03bc = (\u2016c\u2016\u208a : \u211d\u22650\u221e) * \u03bc Set.univ ^ (1 / ENNReal.toReal p)", "start": [320, 1], "end": [322, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_const_lt_top_iff", "code": "theorem snorm_const_lt_top_iff {p : \u211d\u22650\u221e} {c : F} (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e) :\n    snorm (fun _ : \u03b1 => c) p \u03bc < \u221e \u2194 c = 0 \u2228 \u03bc Set.univ < \u221e", "start": [325, 1], "end": [341, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_const", "code": "theorem mem\u2112p_const (c : E) [IsFiniteMeasure \u03bc] : Mem\u2112p (fun _ : \u03b1 => c) p \u03bc", "start": [344, 1], "end": [353, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_top_const", "code": "theorem mem\u2112p_top_const (c : E) : Mem\u2112p (fun _ : \u03b1 => c) \u221e \u03bc", "start": [356, 1], "end": [361, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_const_iff", "code": "theorem mem\u2112p_const_iff {p : \u211d\u22650\u221e} {c : E} (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e) :\n    Mem\u2112p (fun _ : \u03b1 => c) p \u03bc \u2194 c = 0 \u2228 \u03bc Set.univ < \u221e", "start": [364, 1], "end": [367, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_mono_nnnorm_ae", "code": "theorem snorm'_mono_nnnorm_ae {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 G} (hq : 0 \u2264 q) (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 \u2016g x\u2016\u208a) :\n    snorm' f q \u03bc \u2264 snorm' g q \u03bc", "start": [372, 1], "end": [377, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_mono_ae", "code": "theorem snorm'_mono_ae {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 G} (hq : 0 \u2264 q) (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 \u2016g x\u2016) :\n    snorm' f q \u03bc \u2264 snorm' g q \u03bc", "start": [380, 1], "end": [382, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_congr_nnnorm_ae", "code": "theorem snorm'_congr_nnnorm_ae {f g : \u03b1 \u2192 F} (hfg : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a = \u2016g x\u2016\u208a) :\n    snorm' f q \u03bc = snorm' g q \u03bc", "start": [385, 1], "end": [389, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_congr_norm_ae", "code": "theorem snorm'_congr_norm_ae {f g : \u03b1 \u2192 F} (hfg : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 = \u2016g x\u2016) :\n    snorm' f q \u03bc = snorm' g q \u03bc", "start": [392, 1], "end": [394, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_congr_ae", "code": "theorem snorm'_congr_ae {f g : \u03b1 \u2192 F} (hfg : f =\u1d50[\u03bc] g) : snorm' f q \u03bc = snorm' g q \u03bc", "start": [397, 1], "end": [398, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_congr_ae", "code": "theorem snormEssSup_congr_ae {f g : \u03b1 \u2192 F} (hfg : f =\u1d50[\u03bc] g) : snormEssSup f \u03bc = snormEssSup g \u03bc", "start": [401, 1], "end": [402, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_mono_nnnorm_ae", "code": "theorem snormEssSup_mono_nnnorm_ae {f g : \u03b1 \u2192 F} (hfg : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 \u2016g x\u2016\u208a) :\n    snormEssSup f \u03bc \u2264 snormEssSup g \u03bc", "start": [405, 1], "end": [407, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_mono_nnnorm_ae", "code": "theorem snorm_mono_nnnorm_ae {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 G} (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 \u2016g x\u2016\u208a) :\n    snorm f p \u03bc \u2264 snorm g p \u03bc", "start": [410, 1], "end": [416, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_mono_ae", "code": "theorem snorm_mono_ae {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 G} (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 \u2016g x\u2016) :\n    snorm f p \u03bc \u2264 snorm g p \u03bc", "start": [419, 1], "end": [421, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_mono_ae_real", "code": "theorem snorm_mono_ae_real {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 \u211d} (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 g x) :\n    snorm f p \u03bc \u2264 snorm g p \u03bc", "start": [424, 1], "end": [426, 101], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_mono_nnnorm", "code": "theorem snorm_mono_nnnorm {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 G} (h : \u2200 x, \u2016f x\u2016\u208a \u2264 \u2016g x\u2016\u208a) :\n    snorm f p \u03bc \u2264 snorm g p \u03bc", "start": [429, 1], "end": [431, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_mono", "code": "theorem snorm_mono {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 G} (h : \u2200 x, \u2016f x\u2016 \u2264 \u2016g x\u2016) : snorm f p \u03bc \u2264 snorm g p \u03bc", "start": [434, 1], "end": [435, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_mono_real", "code": "theorem snorm_mono_real {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 \u211d} (h : \u2200 x, \u2016f x\u2016 \u2264 g x) :\n    snorm f p \u03bc \u2264 snorm g p \u03bc", "start": [438, 1], "end": [440, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_le_of_ae_nnnorm_bound", "code": "theorem snormEssSup_le_of_ae_nnnorm_bound {f : \u03b1 \u2192 F} {C : \u211d\u22650} (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 C) :\n    snormEssSup f \u03bc \u2264 C", "start": [443, 1], "end": [445, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_le_of_ae_bound", "code": "theorem snormEssSup_le_of_ae_bound {f : \u03b1 \u2192 F} {C : \u211d} (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 C) :\n    snormEssSup f \u03bc \u2264 ENNReal.ofReal C", "start": [448, 1], "end": [450, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_lt_top_of_ae_nnnorm_bound", "code": "theorem snormEssSup_lt_top_of_ae_nnnorm_bound {f : \u03b1 \u2192 F} {C : \u211d\u22650} (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 C) :\n    snormEssSup f \u03bc < \u221e", "start": [453, 1], "end": [455, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_lt_top_of_ae_bound", "code": "theorem snormEssSup_lt_top_of_ae_bound {f : \u03b1 \u2192 F} {C : \u211d} (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 C) :\n    snormEssSup f \u03bc < \u221e", "start": [458, 1], "end": [460, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_le_of_ae_nnnorm_bound", "code": "theorem snorm_le_of_ae_nnnorm_bound {f : \u03b1 \u2192 F} {C : \u211d\u22650} (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 C) :\n    snorm f p \u03bc \u2264 C \u2022 \u03bc Set.univ ^ p.toReal\u207b\u00b9", "start": [463, 1], "end": [471, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_le_of_ae_bound", "code": "theorem snorm_le_of_ae_bound {f : \u03b1 \u2192 F} {C : \u211d} (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 C) :\n    snorm f p \u03bc \u2264 \u03bc Set.univ ^ p.toReal\u207b\u00b9 * ENNReal.ofReal C", "start": [474, 1], "end": [477, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_congr_nnnorm_ae", "code": "theorem snorm_congr_nnnorm_ae {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 G} (hfg : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a = \u2016g x\u2016\u208a) :\n    snorm f p \u03bc = snorm g p \u03bc", "start": [480, 1], "end": [483, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_congr_norm_ae", "code": "theorem snorm_congr_norm_ae {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 G} (hfg : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 = \u2016g x\u2016) :\n    snorm f p \u03bc = snorm g p \u03bc", "start": [486, 1], "end": [488, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_indicator_sub_indicator", "code": "theorem snorm_indicator_sub_indicator (s t : Set \u03b1) (f : \u03b1 \u2192 E) :\n    snorm (s.indicator f - t.indicator f) p \u03bc = snorm ((s \u2206 t).indicator f) p \u03bc", "start": [491, 1], "end": [494, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_norm", "code": "@[simp]\ntheorem snorm'_norm {f : \u03b1 \u2192 F} : snorm' (fun a => \u2016f a\u2016) q \u03bc = snorm' f q \u03bc", "start": [496, 1], "end": [497, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_norm", "code": "@[simp]\ntheorem snorm_norm (f : \u03b1 \u2192 F) : snorm (fun x => \u2016f x\u2016) p \u03bc = snorm f p \u03bc", "start": [500, 1], "end": [502, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_norm_rpow", "code": "theorem snorm'_norm_rpow (f : \u03b1 \u2192 F) (p q : \u211d) (hq_pos : 0 < q) :\n    snorm' (fun x => \u2016f x\u2016 ^ q) p \u03bc = snorm' f (p * q) \u03bc ^ q", "start": [505, 1], "end": [515, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_norm_rpow", "code": "theorem snorm_norm_rpow (f : \u03b1 \u2192 F) (hq_pos : 0 < q) :\n    snorm (fun x => \u2016f x\u2016 ^ q) p \u03bc = snorm f (p * ENNReal.ofReal q) \u03bc ^ q", "start": [518, 1], "end": [546, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_congr_ae", "code": "theorem snorm_congr_ae {f g : \u03b1 \u2192 F} (hfg : f =\u1d50[\u03bc] g) : snorm f p \u03bc = snorm g p \u03bc", "start": [549, 1], "end": [550, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_congr_ae", "code": "theorem mem\u2112p_congr_ae {f g : \u03b1 \u2192 E} (hfg : f =\u1d50[\u03bc] g) : Mem\u2112p f p \u03bc \u2194 Mem\u2112p g p \u03bc", "start": [553, 1], "end": [554, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.ae_eq", "code": "theorem Mem\u2112p.ae_eq {f g : \u03b1 \u2192 E} (hfg : f =\u1d50[\u03bc] g) (hf_Lp : Mem\u2112p f p \u03bc) : Mem\u2112p g p \u03bc", "start": [557, 1], "end": [558, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.of_le", "code": "theorem Mem\u2112p.of_le {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} (hg : Mem\u2112p g p \u03bc) (hf : AEStronglyMeasurable f \u03bc)\n    (hfg : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 \u2016g x\u2016) : Mem\u2112p f p \u03bc", "start": [561, 1], "end": [563, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.mono", "code": "alias Mem\u2112p.mono := Mem\u2112p.of_le", "start": [566, 1], "end": [566, 32], "kind": "stdtacticaliasalias"}, {"full_name": "MeasureTheory.Mem\u2112p.mono'", "code": "theorem Mem\u2112p.mono' {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 \u211d} (hg : Mem\u2112p g p \u03bc) (hf : AEStronglyMeasurable f \u03bc)\n    (h : \u2200\u1d50 a \u2202\u03bc, \u2016f a\u2016 \u2264 g a) : Mem\u2112p f p \u03bc", "start": [569, 1], "end": [571, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.congr_norm", "code": "theorem Mem\u2112p.congr_norm {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} (hf : Mem\u2112p f p \u03bc) (hg : AEStronglyMeasurable g \u03bc)\n    (h : \u2200\u1d50 a \u2202\u03bc, \u2016f a\u2016 = \u2016g a\u2016) : Mem\u2112p g p \u03bc", "start": [574, 1], "end": [576, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_congr_norm", "code": "theorem mem\u2112p_congr_norm {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} (hf : AEStronglyMeasurable f \u03bc)\n    (hg : AEStronglyMeasurable g \u03bc) (h : \u2200\u1d50 a \u2202\u03bc, \u2016f a\u2016 = \u2016g a\u2016) : Mem\u2112p f p \u03bc \u2194 Mem\u2112p g p \u03bc", "start": [579, 1], "end": [581, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_top_of_bound", "code": "theorem mem\u2112p_top_of_bound {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc) (C : \u211d)\n    (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 C) : Mem\u2112p f \u221e \u03bc", "start": [584, 1], "end": [588, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.of_bound", "code": "theorem Mem\u2112p.of_bound [IsFiniteMeasure \u03bc] {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc) (C : \u211d)\n    (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 C) : Mem\u2112p f p \u03bc", "start": [591, 1], "end": [593, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_mono_measure", "code": "@[mono]\ntheorem snorm'_mono_measure (f : \u03b1 \u2192 F) (h\u03bc\u03bd : \u03bd \u2264 \u03bc) (hq : 0 \u2264 q) :\n    snorm' f q \u03bd \u2264 snorm' f q \u03bc", "start": [596, 1], "end": [602, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_mono_measure", "code": "@[mono]\ntheorem snormEssSup_mono_measure (f : \u03b1 \u2192 F) (h\u03bc\u03bd : \u03bd \u226a \u03bc) : snormEssSup f \u03bd \u2264 snormEssSup f \u03bc", "start": [605, 1], "end": [608, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_mono_measure", "code": "@[mono]\ntheorem snorm_mono_measure (f : \u03b1 \u2192 F) (h\u03bc\u03bd : \u03bd \u2264 \u03bc) : snorm f p \u03bd \u2264 snorm f p \u03bc", "start": [611, 1], "end": [618, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.mono_measure", "code": "theorem Mem\u2112p.mono_measure {f : \u03b1 \u2192 E} (h\u03bc\u03bd : \u03bd \u2264 \u03bc) (hf : Mem\u2112p f p \u03bc) : Mem\u2112p f p \u03bd", "start": [621, 1], "end": [622, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.restrict", "code": "theorem Mem\u2112p.restrict (s : Set \u03b1) {f : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) : Mem\u2112p f p (\u03bc.restrict s)", "start": [625, 1], "end": [626, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_smul_measure", "code": "theorem snorm'_smul_measure {p : \u211d} (hp : 0 \u2264 p) {f : \u03b1 \u2192 F} (c : \u211d\u22650\u221e) :\n    snorm' f p (c \u2022 \u03bc) = c ^ (1 / p) * snorm' f p \u03bc", "start": [629, 1], "end": [632, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_smul_measure", "code": "theorem snormEssSup_smul_measure {f : \u03b1 \u2192 F} {c : \u211d\u22650\u221e} (hc : c \u2260 0) :\n    snormEssSup f (c \u2022 \u03bc) = snormEssSup f \u03bc", "start": [635, 1], "end": [638, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_smul_measure_of_ne_zero_of_ne_top", "code": "private theorem snorm_smul_measure_of_ne_zero_of_ne_top {p : \u211d\u22650\u221e} (hp_ne_zero : p \u2260 0)\n    (hp_ne_top : p \u2260 \u221e) {f : \u03b1 \u2192 F} (c : \u211d\u22650\u221e) :\n    snorm f p (c \u2022 \u03bc) = c ^ (1 / p).toReal \u2022 snorm f p \u03bc", "start": [641, 1], "end": [649, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_smul_measure_of_ne_zero", "code": "theorem snorm_smul_measure_of_ne_zero {p : \u211d\u22650\u221e} {f : \u03b1 \u2192 F} {c : \u211d\u22650\u221e} (hc : c \u2260 0) :\n    snorm f p (c \u2022 \u03bc) = c ^ (1 / p).toReal \u2022 snorm f p \u03bc", "start": [651, 1], "end": [657, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_smul_measure_of_ne_top", "code": "theorem snorm_smul_measure_of_ne_top {p : \u211d\u22650\u221e} (hp_ne_top : p \u2260 \u221e) {f : \u03b1 \u2192 F} (c : \u211d\u22650\u221e) :\n    snorm f p (c \u2022 \u03bc) = c ^ (1 / p).toReal \u2022 snorm f p \u03bc", "start": [660, 1], "end": [664, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_one_smul_measure", "code": "theorem snorm_one_smul_measure {f : \u03b1 \u2192 F} (c : \u211d\u22650\u221e) : snorm f 1 (c \u2022 \u03bc) = c * snorm f 1 \u03bc", "start": [667, 1], "end": [669, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.of_measure_le_smul", "code": "theorem Mem\u2112p.of_measure_le_smul {\u03bc' : Measure \u03b1} (c : \u211d\u22650\u221e) (hc : c \u2260 \u221e) (h\u03bc'_le : \u03bc' \u2264 c \u2022 \u03bc)\n    {f : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) : Mem\u2112p f p \u03bc'", "start": [672, 1], "end": [680, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.smul_measure", "code": "theorem Mem\u2112p.smul_measure {f : \u03b1 \u2192 E} {c : \u211d\u22650\u221e} (hf : Mem\u2112p f p \u03bc) (hc : c \u2260 \u221e) :\n    Mem\u2112p f p (c \u2022 \u03bc)", "start": [683, 1], "end": [685, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_one_add_measure", "code": "theorem snorm_one_add_measure (f : \u03b1 \u2192 F) (\u03bc \u03bd : Measure \u03b1) :\n    snorm f 1 (\u03bc + \u03bd) = snorm f 1 \u03bc + snorm f 1 \u03bd", "start": [688, 1], "end": [691, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_le_add_measure_right", "code": "theorem snorm_le_add_measure_right (f : \u03b1 \u2192 F) (\u03bc \u03bd : Measure \u03b1) {p : \u211d\u22650\u221e} :\n    snorm f p \u03bc \u2264 snorm f p (\u03bc + \u03bd)", "start": [694, 1], "end": [696, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_le_add_measure_left", "code": "theorem snorm_le_add_measure_left (f : \u03b1 \u2192 F) (\u03bc \u03bd : Measure \u03b1) {p : \u211d\u22650\u221e} :\n    snorm f p \u03bd \u2264 snorm f p (\u03bc + \u03bd)", "start": [699, 1], "end": [701, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.left_of_add_measure", "code": "theorem Mem\u2112p.left_of_add_measure {f : \u03b1 \u2192 E} (h : Mem\u2112p f p (\u03bc + \u03bd)) : Mem\u2112p f p \u03bc", "start": [704, 1], "end": [705, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.right_of_add_measure", "code": "theorem Mem\u2112p.right_of_add_measure {f : \u03b1 \u2192 E} (h : Mem\u2112p f p (\u03bc + \u03bd)) : Mem\u2112p f p \u03bd", "start": [708, 1], "end": [709, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.norm", "code": "theorem Mem\u2112p.norm {f : \u03b1 \u2192 E} (h : Mem\u2112p f p \u03bc) : Mem\u2112p (fun x => \u2016f x\u2016) p \u03bc", "start": [712, 1], "end": [713, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_norm_iff", "code": "theorem mem\u2112p_norm_iff {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc) :\n    Mem\u2112p (fun x => \u2016f x\u2016) p \u03bc \u2194 Mem\u2112p f p \u03bc", "start": [716, 1], "end": [718, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_eq_zero_of_ae_zero", "code": "theorem snorm'_eq_zero_of_ae_zero {f : \u03b1 \u2192 F} (hq0_lt : 0 < q) (hf_zero : f =\u1d50[\u03bc] 0) :\n    snorm' f q \u03bc = 0", "start": [721, 1], "end": [722, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_eq_zero_of_ae_zero'", "code": "theorem snorm'_eq_zero_of_ae_zero' (hq0_ne : q \u2260 0) (h\u03bc : \u03bc \u2260 0) {f : \u03b1 \u2192 F} (hf_zero : f =\u1d50[\u03bc] 0) :\n    snorm' f q \u03bc = 0", "start": [725, 1], "end": [726, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_zero_of_snorm'_eq_zero", "code": "theorem ae_eq_zero_of_snorm'_eq_zero {f : \u03b1 \u2192 E} (hq0 : 0 \u2264 q) (hf : AEStronglyMeasurable f \u03bc)\n    (h : snorm' f q \u03bc = 0) : f =\u1d50[\u03bc] 0", "start": [729, 1], "end": [746, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_eq_zero_iff", "code": "theorem snorm'_eq_zero_iff (hq0_lt : 0 < q) {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc) :\n    snorm' f q \u03bc = 0 \u2194 f =\u1d50[\u03bc] 0", "start": [749, 1], "end": [751, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.coe_nnnorm_ae_le_snormEssSup", "code": "theorem coe_nnnorm_ae_le_snormEssSup {_ : MeasurableSpace \u03b1} (f : \u03b1 \u2192 F) (\u03bc : Measure \u03b1) :\n    \u2200\u1d50 x \u2202\u03bc, (\u2016f x\u2016\u208a : \u211d\u22650\u221e) \u2264 snormEssSup f \u03bc", "start": [754, 1], "end": [756, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_eq_zero_iff", "code": "@[simp]\ntheorem snormEssSup_eq_zero_iff {f : \u03b1 \u2192 F} : snormEssSup f \u03bc = 0 \u2194 f =\u1d50[\u03bc] 0", "start": [759, 1], "end": [761, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_eq_zero_iff", "code": "theorem snorm_eq_zero_iff {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc) (h0 : p \u2260 0) :\n    snorm f p \u03bc = 0 \u2194 f =\u1d50[\u03bc] 0", "start": [764, 1], "end": [769, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_add_le", "code": "theorem snorm'_add_le {f g : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc) (hg : AEStronglyMeasurable g \u03bc)\n    (hq1 : 1 \u2264 q) : snorm' (f + g) q \u03bc \u2264 snorm' f q \u03bc + snorm' g q \u03bc", "start": [772, 1], "end": [780, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_add_le_of_le_one", "code": "theorem snorm'_add_le_of_le_one {f g : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc) (hq0 : 0 \u2264 q)\n    (hq1 : q \u2264 1) : snorm' (f + g) q \u03bc \u2264 (2 : \u211d\u22650\u221e) ^ (1 / q - 1) * (snorm' f q \u03bc + snorm' g q \u03bc)", "start": [783, 1], "end": [792, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_add_le", "code": "theorem snormEssSup_add_le {f g : \u03b1 \u2192 F} :\n    snormEssSup (f + g) \u03bc \u2264 snormEssSup f \u03bc + snormEssSup g \u03bc", "start": [795, 1], "end": [799, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_add_le", "code": "theorem snorm_add_le {f g : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc) (hg : AEStronglyMeasurable g \u03bc)\n    (hp1 : 1 \u2264 p) : snorm (f + g) p \u03bc \u2264 snorm f p \u03bc + snorm g p \u03bc", "start": [802, 1], "end": [811, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.LpAddConst", "code": "def LpAddConst (p : \u211d\u22650\u221e) : \u211d\u22650\u221e :=\n  if p \u2208 Set.Ioo (0 : \u211d\u22650\u221e) 1 then (2 : \u211d\u22650\u221e) ^ (1 / p.toReal - 1) else 1", "start": [814, 1], "end": [817, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.LpAddConst_of_one_le", "code": "theorem LpAddConst_of_one_le {p : \u211d\u22650\u221e} (hp : 1 \u2264 p) : LpAddConst p = 1", "start": [820, 1], "end": [823, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.LpAddConst_zero", "code": "theorem LpAddConst_zero : LpAddConst 0 = 1", "start": [826, 1], "end": [829, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.LpAddConst_lt_top", "code": "theorem LpAddConst_lt_top (p : \u211d\u22650\u221e) : LpAddConst p < \u221e", "start": [832, 1], "end": [839, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_add_le'", "code": "theorem snorm_add_le' {f g : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc) (hg : AEStronglyMeasurable g \u03bc)\n    (p : \u211d\u22650\u221e) : snorm (f + g) p \u03bc \u2264 LpAddConst p * (snorm f p \u03bc + snorm g p \u03bc)", "start": [842, 1], "end": [853, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_Lp_half", "code": "theorem exists_Lp_half (p : \u211d\u22650\u221e) {\u03b4 : \u211d\u22650\u221e} (h\u03b4 : \u03b4 \u2260 0) :\n    \u2203 \u03b7 : \u211d\u22650\u221e,\n      0 < \u03b7 \u2227\n        \u2200 (f g : \u03b1 \u2192 E), AEStronglyMeasurable f \u03bc \u2192 AEStronglyMeasurable g \u03bc \u2192\n          snorm f p \u03bc \u2264 \u03b7 \u2192 snorm g p \u03bc \u2264 \u03b7 \u2192 snorm (f + g) p \u03bc < \u03b4", "start": [858, 1], "end": [878, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_sub_le'", "code": "theorem snorm_sub_le' {f g : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc) (hg : AEStronglyMeasurable g \u03bc)\n    (p : \u211d\u22650\u221e) : snorm (f - g) p \u03bc \u2264 LpAddConst p * (snorm f p \u03bc + snorm g p \u03bc)", "start": [883, 1], "end": [885, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_sub_le", "code": "theorem snorm_sub_le {f g : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc) (hg : AEStronglyMeasurable g \u03bc)\n    (hp : 1 \u2264 p) : snorm (f - g) p \u03bc \u2264 snorm f p \u03bc + snorm g p \u03bc", "start": [888, 1], "end": [890, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_add_lt_top", "code": "theorem snorm_add_lt_top {f g : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) (hg : Mem\u2112p g p \u03bc) :\n    snorm (f + g) p \u03bc < \u221e", "start": [893, 1], "end": [900, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_le_snormEssSup", "code": "theorem ae_le_snormEssSup {f : \u03b1 \u2192 F} : \u2200\u1d50 y \u2202\u03bc, \u2016f y\u2016\u208a \u2264 snormEssSup f \u03bc", "start": [903, 1], "end": [904, 15], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.meas_snormEssSup_lt", "code": "theorem meas_snormEssSup_lt {f : \u03b1 \u2192 F} : \u03bc { y | snormEssSup f \u03bc < \u2016f y\u2016\u208a } = 0", "start": [907, 1], "end": [908, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_map_measure", "code": "theorem snormEssSup_map_measure (hg : AEStronglyMeasurable g (Measure.map f \u03bc))\n    (hf : AEMeasurable f \u03bc) : snormEssSup g (Measure.map f \u03bc) = snormEssSup (g \u2218 f) \u03bc", "start": [915, 1], "end": [917, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_map_measure", "code": "theorem snorm_map_measure (hg : AEStronglyMeasurable g (Measure.map f \u03bc)) (hf : AEMeasurable f \u03bc) :\n    snorm g p (Measure.map f \u03bc) = snorm (g \u2218 f) p \u03bc", "start": [920, 1], "end": [929, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_map_measure_iff", "code": "theorem mem\u2112p_map_measure_iff (hg : AEStronglyMeasurable g (Measure.map f \u03bc))\n    (hf : AEMeasurable f \u03bc) : Mem\u2112p g p (Measure.map f \u03bc) \u2194 Mem\u2112p (g \u2218 f) p \u03bc", "start": [932, 1], "end": [934, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.comp_of_map", "code": "theorem Mem\u2112p.comp_of_map (hg : Mem\u2112p g p (Measure.map f \u03bc)) (hf : AEMeasurable f \u03bc) :\n    Mem\u2112p (g \u2218 f) p \u03bc", "start": [937, 1], "end": [939, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_comp_measurePreserving", "code": "theorem snorm_comp_measurePreserving {\u03bd : MeasureTheory.Measure \u03b2} (hg : AEStronglyMeasurable g \u03bd)\n    (hf : MeasurePreserving f \u03bc \u03bd) : snorm (g \u2218 f) p \u03bc = snorm g p \u03bd", "start": [941, 1], "end": [943, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.snorm_compMeasurePreserving", "code": "theorem AEEqFun.snorm_compMeasurePreserving {\u03bd : MeasureTheory.Measure \u03b2} (g : \u03b2 \u2192\u2098[\u03bd] E)\n    (hf : MeasurePreserving f \u03bc \u03bd) :\n    snorm (g.compMeasurePreserving f hf) p \u03bc = snorm g p \u03bd", "start": [945, 1], "end": [949, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.comp_measurePreserving", "code": "theorem Mem\u2112p.comp_measurePreserving {\u03bd : MeasureTheory.Measure \u03b2} (hg : Mem\u2112p g p \u03bd)\n    (hf : MeasurePreserving f \u03bc \u03bd) : Mem\u2112p (g \u2218 f) p \u03bc", "start": [951, 1], "end": [953, 53], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.snormEssSup_map_measure", "code": "theorem _root_.MeasurableEmbedding.snormEssSup_map_measure {g : \u03b2 \u2192 F}\n    (hf : MeasurableEmbedding f) : snormEssSup g (Measure.map f \u03bc) = snormEssSup (g \u2218 f) \u03bc", "start": [955, 1], "end": [957, 24], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.snorm_map_measure", "code": "theorem _root_.MeasurableEmbedding.snorm_map_measure {g : \u03b2 \u2192 F} (hf : MeasurableEmbedding f) :\n    snorm g p (Measure.map f \u03bc) = snorm (g \u2218 f) p \u03bc", "start": [960, 1], "end": [969, 8], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.mem\u2112p_map_measure_iff", "code": "theorem _root_.MeasurableEmbedding.mem\u2112p_map_measure_iff {g : \u03b2 \u2192 F} (hf : MeasurableEmbedding f) :\n    Mem\u2112p g p (Measure.map f \u03bc) \u2194 Mem\u2112p (g \u2218 f) p \u03bc", "start": [972, 1], "end": [974, 73], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.mem\u2112p_map_measure_iff", "code": "theorem _root_.MeasurableEquiv.mem\u2112p_map_measure_iff (f : \u03b1 \u2243\u1d50 \u03b2) {g : \u03b2 \u2192 F} :\n    Mem\u2112p g p (Measure.map f \u03bc) \u2194 Mem\u2112p (g \u2218 f) p \u03bc", "start": [977, 1], "end": [979, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_trim", "code": "theorem snorm'_trim (hm : m \u2264 m0) {f : \u03b1 \u2192 E} (hf : StronglyMeasurable[m] f) :\n    snorm' f q (\u03bd.trim hm) = snorm' f q \u03bd", "start": [986, 1], "end": [993, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.limsup_trim", "code": "theorem limsup_trim (hm : m \u2264 m0) {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable[m] f) :\n    (\u03bd.trim hm).ae.limsup f = \u03bd.ae.limsup f", "start": [996, 1], "end": [1006, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.essSup_trim", "code": "theorem essSup_trim (hm : m \u2264 m0) {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Measurable[m] f) :\n    essSup f (\u03bd.trim hm) = essSup f \u03bd", "start": [1009, 1], "end": [1012, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_trim", "code": "theorem snormEssSup_trim (hm : m \u2264 m0) {f : \u03b1 \u2192 E} (hf : StronglyMeasurable[m] f) :\n    snormEssSup f (\u03bd.trim hm) = snormEssSup f \u03bd", "start": [1015, 1], "end": [1017, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_trim", "code": "theorem snorm_trim (hm : m \u2264 m0) {f : \u03b1 \u2192 E} (hf : StronglyMeasurable[m] f) :\n    snorm f p (\u03bd.trim hm) = snorm f p \u03bd", "start": [1020, 1], "end": [1026, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_trim_ae", "code": "theorem snorm_trim_ae (hm : m \u2264 m0) {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f (\u03bd.trim hm)) :\n    snorm f p (\u03bd.trim hm) = snorm f p \u03bd", "start": [1029, 1], "end": [1032, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_of_mem\u2112p_trim", "code": "theorem mem\u2112p_of_mem\u2112p_trim (hm : m \u2264 m0) {f : \u03b1 \u2192 E} (hf : Mem\u2112p f p (\u03bd.trim hm)) : Mem\u2112p f p \u03bd", "start": [1035, 1], "end": [1037, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_le_snorm'_mul_rpow_measure_univ", "code": "theorem snorm'_le_snorm'_mul_rpow_measure_univ {p q : \u211d} (hp0_lt : 0 < p) (hpq : p \u2264 q) {f : \u03b1 \u2192 E}\n    (hf : AEStronglyMeasurable f \u03bc) :\n    snorm' f p \u03bc \u2264 snorm' f q \u03bc * \u03bc Set.univ ^ (1 / p - 1 / q)", "start": [1042, 1], "end": [1063, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_le_snormEssSup_mul_rpow_measure_univ", "code": "theorem snorm'_le_snormEssSup_mul_rpow_measure_univ (hq_pos : 0 < q) {f : \u03b1 \u2192 F} :\n    snorm' f q \u03bc \u2264 snormEssSup f \u03bc * \u03bc Set.univ ^ (1 / q)", "start": [1066, 1], "end": [1076, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_le_snorm_mul_rpow_measure_univ", "code": "theorem snorm_le_snorm_mul_rpow_measure_univ {p q : \u211d\u22650\u221e} (hpq : p \u2264 q) {f : \u03b1 \u2192 E}\n    (hf : AEStronglyMeasurable f \u03bc) :\n    snorm f p \u03bc \u2264 snorm f q \u03bc * \u03bc Set.univ ^ (1 / p.toReal - 1 / q.toReal)", "start": [1079, 1], "end": [1103, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_le_snorm'_of_exponent_le", "code": "theorem snorm'_le_snorm'_of_exponent_le {m : MeasurableSpace \u03b1} {p q : \u211d} (hp0_lt : 0 < p)\n    (hpq : p \u2264 q) (\u03bc : Measure \u03b1) [IsProbabilityMeasure \u03bc] {f : \u03b1 \u2192 E}\n    (hf : AEStronglyMeasurable f \u03bc) : snorm' f p \u03bc \u2264 snorm' f q \u03bc", "start": [1106, 1], "end": [1110, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_le_snormEssSup", "code": "theorem snorm'_le_snormEssSup (hq_pos : 0 < q) {f : \u03b1 \u2192 F} [IsProbabilityMeasure \u03bc] :\n    snorm' f q \u03bc \u2264 snormEssSup f \u03bc", "start": [1113, 1], "end": [1115, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_le_snorm_of_exponent_le", "code": "theorem snorm_le_snorm_of_exponent_le {p q : \u211d\u22650\u221e} (hpq : p \u2264 q) [IsProbabilityMeasure \u03bc]\n    {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc) : snorm f p \u03bc \u2264 snorm f q \u03bc", "start": [1118, 1], "end": [1120, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_lt_top_of_snorm'_lt_top_of_exponent_le", "code": "theorem snorm'_lt_top_of_snorm'_lt_top_of_exponent_le {p q : \u211d} [IsFiniteMeasure \u03bc] {f : \u03b1 \u2192 E}\n    (hf : AEStronglyMeasurable f \u03bc) (hfq_lt_top : snorm' f q \u03bc < \u221e) (hp_nonneg : 0 \u2264 p)\n    (hpq : p \u2264 q) : snorm' f p \u03bc < \u221e", "start": [1123, 1], "end": [1136, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pow_mul_meas_ge_le_snorm", "code": "theorem pow_mul_meas_ge_le_snorm {f : \u03b1 \u2192 E} (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e)\n    (hf : AEStronglyMeasurable f \u03bc) (\u03b5 : \u211d\u22650\u221e) :\n    (\u03b5 * \u03bc { x | \u03b5 \u2264 (\u2016f x\u2016\u208a : \u211d\u22650\u221e) ^ p.toReal }) ^ (1 / p.toReal) \u2264 snorm f p \u03bc", "start": [1141, 1], "end": [1147, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mul_meas_ge_le_pow_snorm", "code": "theorem mul_meas_ge_le_pow_snorm {f : \u03b1 \u2192 E} (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e)\n    (hf : AEStronglyMeasurable f \u03bc) (\u03b5 : \u211d\u22650\u221e) :\n    \u03b5 * \u03bc { x | \u03b5 \u2264 (\u2016f x\u2016\u208a : \u211d\u22650\u221e) ^ p.toReal } \u2264 snorm f p \u03bc ^ p.toReal", "start": [1150, 1], "end": [1160, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mul_meas_ge_le_pow_snorm'", "code": "theorem mul_meas_ge_le_pow_snorm' {f : \u03b1 \u2192 E} (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e)\n    (hf : AEStronglyMeasurable f \u03bc) (\u03b5 : \u211d\u22650\u221e) :\n    \u03b5 ^ p.toReal * \u03bc { x | \u03b5 \u2264 \u2016f x\u2016\u208a } \u2264 snorm f p \u03bc ^ p.toReal", "start": [1163, 1], "end": [1169, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.meas_ge_le_mul_pow_snorm", "code": "theorem meas_ge_le_mul_pow_snorm {f : \u03b1 \u2192 E} (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e)\n    (hf : AEStronglyMeasurable f \u03bc) {\u03b5 : \u211d\u22650\u221e} (h\u03b5 : \u03b5 \u2260 0) :\n    \u03bc { x | \u03b5 \u2264 \u2016f x\u2016\u208a } \u2264 \u03b5\u207b\u00b9 ^ p.toReal * snorm f p \u03bc ^ p.toReal", "start": [1172, 1], "end": [1181, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.mem\u2112p_of_exponent_le", "code": "theorem Mem\u2112p.mem\u2112p_of_exponent_le {p q : \u211d\u22650\u221e} [IsFiniteMeasure \u03bc] {f : \u03b1 \u2192 E} (hfq : Mem\u2112p f q \u03bc)\n    (hpq : p \u2264 q) : Mem\u2112p f p \u03bc", "start": [1186, 1], "end": [1212, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_sum_le", "code": "theorem snorm'_sum_le {\u03b9} {f : \u03b9 \u2192 \u03b1 \u2192 E} {s : Finset \u03b9}\n    (hfs : \u2200 i, i \u2208 s \u2192 AEStronglyMeasurable (f i) \u03bc) (hq1 : 1 \u2264 q) :\n    snorm' (\u2211 i in s, f i) q \u03bc \u2264 \u2211 i in s, snorm' (f i) q \u03bc", "start": [1218, 1], "end": [1223, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_sum_le", "code": "theorem snorm_sum_le {\u03b9} {f : \u03b9 \u2192 \u03b1 \u2192 E} {s : Finset \u03b9}\n    (hfs : \u2200 i, i \u2208 s \u2192 AEStronglyMeasurable (f i) \u03bc) (hp1 : 1 \u2264 p) :\n    snorm (\u2211 i in s, f i) p \u03bc \u2264 \u2211 i in s, snorm (f i) p \u03bc", "start": [1226, 1], "end": [1231, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.add", "code": "theorem Mem\u2112p.add {f g : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) (hg : Mem\u2112p g p \u03bc) : Mem\u2112p (f + g) p \u03bc", "start": [1234, 1], "end": [1235, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.sub", "code": "theorem Mem\u2112p.sub {f g : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) (hg : Mem\u2112p g p \u03bc) : Mem\u2112p (f - g) p \u03bc", "start": [1238, 1], "end": [1240, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_finset_sum", "code": "theorem mem\u2112p_finset_sum {\u03b9} (s : Finset \u03b9) {f : \u03b9 \u2192 \u03b1 \u2192 E} (hf : \u2200 i \u2208 s, Mem\u2112p (f i) p \u03bc) :\n    Mem\u2112p (fun a => \u2211 i in s, f i a) p \u03bc", "start": [1243, 1], "end": [1251, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_finset_sum'", "code": "theorem mem\u2112p_finset_sum' {\u03b9} (s : Finset \u03b9) {f : \u03b9 \u2192 \u03b1 \u2192 E} (hf : \u2200 i \u2208 s, Mem\u2112p (f i) p \u03bc) :\n    Mem\u2112p (\u2211 i in s, f i) p \u03bc", "start": [1254, 1], "end": [1258, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_le_nnreal_smul_snorm'_of_ae_le_mul", "code": "theorem snorm'_le_nnreal_smul_snorm'_of_ae_le_mul {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 G} {c : \u211d\u22650}\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 c * \u2016g x\u2016\u208a) {p : \u211d} (hp : 0 < p) : snorm' f p \u03bc \u2264 c \u2022 snorm' g p \u03bc", "start": [1265, 1], "end": [1275, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_le_nnreal_smul_snormEssSup_of_ae_le_mul", "code": "theorem snormEssSup_le_nnreal_smul_snormEssSup_of_ae_le_mul {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 G} {c : \u211d\u22650}\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 c * \u2016g x\u2016\u208a) : snormEssSup f \u03bc \u2264 c \u2022 snormEssSup g \u03bc", "start": [1278, 1], "end": [1284, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_le_nnreal_smul_snorm_of_ae_le_mul", "code": "theorem snorm_le_nnreal_smul_snorm_of_ae_le_mul {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 G} {c : \u211d\u22650}\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 c * \u2016g x\u2016\u208a) (p : \u211d\u22650\u221e) : snorm f p \u03bc \u2264 c \u2022 snorm g p \u03bc", "start": [1287, 1], "end": [1295, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.le_mul_iff_eq_zero_of_nonneg_of_neg_of_nonneg", "code": "private theorem le_mul_iff_eq_zero_of_nonneg_of_neg_of_nonneg {\u03b1} [LinearOrderedSemiring \u03b1]\n    {a b c : \u03b1} (ha : 0 \u2264 a) (hb : b < 0) (hc : 0 \u2264 c) : a \u2264 b * c \u2194 a = 0 \u2227 c = 0", "start": [1299, 1], "end": [1307, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_eq_zero_and_zero_of_ae_le_mul_neg", "code": "theorem snorm_eq_zero_and_zero_of_ae_le_mul_neg {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 G} {c : \u211d}\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 c * \u2016g x\u2016) (hc : c < 0) (p : \u211d\u22650\u221e) :\n    snorm f p \u03bc = 0 \u2227 snorm g p \u03bc = 0", "start": [1309, 1], "end": [1317, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_le_mul_snorm_of_ae_le_mul", "code": "theorem snorm_le_mul_snorm_of_ae_le_mul {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 G} {c : \u211d}\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 c * \u2016g x\u2016) (p : \u211d\u22650\u221e) : snorm f p \u03bc \u2264 ENNReal.ofReal c * snorm g p \u03bc", "start": [1320, 1], "end": [1323, 101], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.of_nnnorm_le_mul", "code": "theorem Mem\u2112p.of_nnnorm_le_mul {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {c : \u211d\u22650} (hg : Mem\u2112p g p \u03bc)\n    (hf : AEStronglyMeasurable f \u03bc) (hfg : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 c * \u2016g x\u2016\u208a) : Mem\u2112p f p \u03bc", "start": [1326, 1], "end": [1330, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.of_le_mul", "code": "theorem Mem\u2112p.of_le_mul {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {c : \u211d} (hg : Mem\u2112p g p \u03bc)\n    (hf : AEStronglyMeasurable f \u03bc) (hfg : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 c * \u2016g x\u2016) : Mem\u2112p f p \u03bc", "start": [1333, 1], "end": [1337, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_le_snorm'_mul_snorm'", "code": "theorem snorm'_le_snorm'_mul_snorm' {p q r : \u211d} {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc)\n    {g : \u03b1 \u2192 F} (hg : AEStronglyMeasurable g \u03bc) (b : E \u2192 F \u2192 G)\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016b (f x) (g x)\u2016\u208a \u2264 \u2016f x\u2016\u208a * \u2016g x\u2016\u208a) (hp0_lt : 0 < p) (hpq : p < q)\n    (hpqr : 1 / p = 1 / q + 1 / r) :\n    snorm' (fun x => b (f x) (g x)) p \u03bc \u2264 snorm' f q \u03bc * snorm' g r \u03bc", "start": [1340, 1], "end": [1354, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_le_snorm_top_mul_snorm", "code": "theorem snorm_le_snorm_top_mul_snorm (p : \u211d\u22650\u221e) (f : \u03b1 \u2192 E) {g : \u03b1 \u2192 F}\n    (hg : AEStronglyMeasurable g \u03bc) (b : E \u2192 F \u2192 G)\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016b (f x) (g x)\u2016\u208a \u2264 \u2016f x\u2016\u208a * \u2016g x\u2016\u208a) :\n    snorm (fun x => b (f x) (g x)) p \u03bc \u2264 snorm f \u221e \u03bc * snorm g p \u03bc", "start": [1357, 1], "end": [1398, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_le_snorm_mul_snorm_top", "code": "theorem snorm_le_snorm_mul_snorm_top (p : \u211d\u22650\u221e) {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc)\n    (g : \u03b1 \u2192 F) (b : E \u2192 F \u2192 G) (h : \u2200\u1d50 x \u2202\u03bc, \u2016b (f x) (g x)\u2016\u208a \u2264 \u2016f x\u2016\u208a * \u2016g x\u2016\u208a) :\n    snorm (fun x => b (f x) (g x)) p \u03bc \u2264 snorm f p \u03bc * snorm g \u221e \u03bc", "start": [1401, 1], "end": [1410, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_le_snorm_mul_snorm_of_nnnorm", "code": "theorem snorm_le_snorm_mul_snorm_of_nnnorm {p q r : \u211d\u22650\u221e} {f : \u03b1 \u2192 E}\n    (hf : AEStronglyMeasurable f \u03bc) {g : \u03b1 \u2192 F} (hg : AEStronglyMeasurable g \u03bc) (b : E \u2192 F \u2192 G)\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016b (f x) (g x)\u2016\u208a \u2264 \u2016f x\u2016\u208a * \u2016g x\u2016\u208a) (hpqr : 1 / p = 1 / q + 1 / r) :\n    snorm (fun x => b (f x) (g x)) p \u03bc \u2264 snorm f q \u03bc * snorm g r \u03bc", "start": [1413, 1], "end": [1451, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_le_snorm_mul_snorm'_of_norm", "code": "theorem snorm_le_snorm_mul_snorm'_of_norm {p q r : \u211d\u22650\u221e} {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc)\n    {g : \u03b1 \u2192 F} (hg : AEStronglyMeasurable g \u03bc) (b : E \u2192 F \u2192 G)\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016b (f x) (g x)\u2016 \u2264 \u2016f x\u2016 * \u2016g x\u2016) (hpqr : 1 / p = 1 / q + 1 / r) :\n    snorm (fun x => b (f x) (g x)) p \u03bc \u2264 snorm f q \u03bc * snorm g r \u03bc", "start": [1454, 1], "end": [1460, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_const_smul_le", "code": "theorem snorm'_const_smul_le (c : \ud835\udd5c) (f : \u03b1 \u2192 F) (hq_pos : 0 < q) :\n    snorm' (c \u2022 f) q \u03bc \u2264 \u2016c\u2016\u208a \u2022 snorm' f q \u03bc", "start": [1477, 1], "end": [1480, 11], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_const_smul_le", "code": "theorem snormEssSup_const_smul_le (c : \ud835\udd5c) (f : \u03b1 \u2192 F) :\n    snormEssSup (c \u2022 f) \u03bc \u2264 \u2016c\u2016\u208a \u2022 snormEssSup f \u03bc", "start": [1483, 1], "end": [1486, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_const_smul_le", "code": "theorem snorm_const_smul_le (c : \ud835\udd5c) (f : \u03b1 \u2192 F) : snorm (c \u2022 f) p \u03bc \u2264 \u2016c\u2016\u208a \u2022 snorm f p \u03bc", "start": [1489, 1], "end": [1490, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.const_smul", "code": "theorem Mem\u2112p.const_smul {f : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) (c : \ud835\udd5c) : Mem\u2112p (c \u2022 f) p \u03bc", "start": [1493, 1], "end": [1495, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.const_mul", "code": "theorem Mem\u2112p.const_mul {R} [NormedRing R] {f : \u03b1 \u2192 R} (hf : Mem\u2112p f p \u03bc) (c : R) :\n    Mem\u2112p (fun x => c * f x) p \u03bc", "start": [1498, 1], "end": [1500, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_smul_le_mul_snorm'", "code": "theorem snorm'_smul_le_mul_snorm' {p q r : \u211d} {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc)\n    {\u03c6 : \u03b1 \u2192 \ud835\udd5c} (h\u03c6 : AEStronglyMeasurable \u03c6 \u03bc) (hp0_lt : 0 < p) (hpq : p < q)\n    (hpqr : 1 / p = 1 / q + 1 / r) : snorm' (\u03c6 \u2022 f) p \u03bc \u2264 snorm' \u03c6 q \u03bc * snorm' f r \u03bc", "start": [1503, 1], "end": [1507, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_smul_le_snorm_top_mul_snorm", "code": "theorem snorm_smul_le_snorm_top_mul_snorm (p : \u211d\u22650\u221e) {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc)\n    (\u03c6 : \u03b1 \u2192 \ud835\udd5c) : snorm (\u03c6 \u2022 f) p \u03bc \u2264 snorm \u03c6 \u221e \u03bc * snorm f p \u03bc", "start": [1510, 1], "end": [1513, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_smul_le_snorm_mul_snorm_top", "code": "theorem snorm_smul_le_snorm_mul_snorm_top (p : \u211d\u22650\u221e) (f : \u03b1 \u2192 E) {\u03c6 : \u03b1 \u2192 \ud835\udd5c}\n    (h\u03c6 : AEStronglyMeasurable \u03c6 \u03bc) : snorm (\u03c6 \u2022 f) p \u03bc \u2264 snorm \u03c6 p \u03bc * snorm f \u221e \u03bc", "start": [1516, 1], "end": [1519, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_smul_le_mul_snorm", "code": "theorem snorm_smul_le_mul_snorm {p q r : \u211d\u22650\u221e} {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc)\n    {\u03c6 : \u03b1 \u2192 \ud835\udd5c} (h\u03c6 : AEStronglyMeasurable \u03c6 \u03bc) (hpqr : 1 / p = 1 / q + 1 / r) :\n    snorm (\u03c6 \u2022 f) p \u03bc \u2264 snorm \u03c6 q \u03bc * snorm f r \u03bc", "start": [1522, 1], "end": [1528, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.smul", "code": "theorem Mem\u2112p.smul {p q r : \u211d\u22650\u221e} {f : \u03b1 \u2192 E} {\u03c6 : \u03b1 \u2192 \ud835\udd5c} (hf : Mem\u2112p f r \u03bc) (h\u03c6 : Mem\u2112p \u03c6 q \u03bc)\n    (hpqr : 1 / p = 1 / q + 1 / r) : Mem\u2112p (\u03c6 \u2022 f) p \u03bc", "start": [1531, 1], "end": [1535, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.smul_of_top_right", "code": "theorem Mem\u2112p.smul_of_top_right {p : \u211d\u22650\u221e} {f : \u03b1 \u2192 E} {\u03c6 : \u03b1 \u2192 \ud835\udd5c} (hf : Mem\u2112p f p \u03bc)\n    (h\u03c6 : Mem\u2112p \u03c6 \u221e \u03bc) : Mem\u2112p (\u03c6 \u2022 f) p \u03bc", "start": [1538, 1], "end": [1541, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.smul_of_top_left", "code": "theorem Mem\u2112p.smul_of_top_left {p : \u211d\u22650\u221e} {f : \u03b1 \u2192 E} {\u03c6 : \u03b1 \u2192 \ud835\udd5c} (hf : Mem\u2112p f \u221e \u03bc)\n    (h\u03c6 : Mem\u2112p \u03c6 p \u03bc) : Mem\u2112p (\u03c6 \u2022 f) p \u03bc", "start": [1544, 1], "end": [1547, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm'_const_smul", "code": "theorem snorm'_const_smul {f : \u03b1 \u2192 F} (c : \ud835\udd5c) (hq_pos : 0 < q) :\n    snorm' (c \u2022 f) q \u03bc = \u2016c\u2016\u208a \u2022 snorm' f q \u03bc", "start": [1564, 1], "end": [1570, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_const_smul", "code": "theorem snormEssSup_const_smul (c : \ud835\udd5c) (f : \u03b1 \u2192 F) :\n    snormEssSup (c \u2022 f) \u03bc = (\u2016c\u2016\u208a : \u211d\u22650\u221e) * snormEssSup f \u03bc", "start": [1573, 1], "end": [1575, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_const_smul", "code": "theorem snorm_const_smul (c : \ud835\udd5c) (f : \u03b1 \u2192 F) :\n    snorm (c \u2022 f) p \u03bc = (\u2016c\u2016\u208a : \u211d\u22650\u221e) * snorm f p \u03bc", "start": [1578, 1], "end": [1584, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_indicator_ge_of_bdd_below", "code": "theorem snorm_indicator_ge_of_bdd_below (hp : p \u2260 0) (hp' : p \u2260 \u221e) {f : \u03b1 \u2192 F} (C : \u211d\u22650) {s : Set \u03b1}\n    (hs : MeasurableSet s) (hf : \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 C \u2264 \u2016s.indicator f x\u2016\u208a) :\n    C \u2022 \u03bc s ^ (1 / p.toReal) \u2264 snorm (s.indicator f) p \u03bc", "start": [1589, 1], "end": [1603, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.re", "code": "theorem Mem\u2112p.re (hf : Mem\u2112p f p \u03bc) : Mem\u2112p (fun x => IsROrC.re (f x)) p \u03bc", "start": [1610, 1], "end": [1616, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.im", "code": "theorem Mem\u2112p.im (hf : Mem\u2112p f p \u03bc) : Mem\u2112p (fun x => IsROrC.im (f x)) p \u03bc", "start": [1619, 1], "end": [1625, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_bdd_liminf_atTop_rpow_of_snorm_bdd", "code": "theorem ae_bdd_liminf_atTop_rpow_of_snorm_bdd {p : \u211d\u22650\u221e} {f : \u2115 \u2192 \u03b1 \u2192 E}\n    (hfmeas : \u2200 n, Measurable (f n)) (hbdd : \u2200 n, snorm (f n) p \u03bc \u2264 R) :\n    \u2200\u1d50 x \u2202\u03bc, liminf (fun n => ((\u2016f n x\u2016\u208a : \u211d\u22650\u221e) ^ p.toReal : \u211d\u22650\u221e)) atTop < \u221e", "start": [1634, 1], "end": [1655, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_bdd_liminf_atTop_of_snorm_bdd", "code": "theorem ae_bdd_liminf_atTop_of_snorm_bdd {p : \u211d\u22650\u221e} (hp : p \u2260 0) {f : \u2115 \u2192 \u03b1 \u2192 E}\n    (hfmeas : \u2200 n, Measurable (f n)) (hbdd : \u2200 n, snorm (f n) p \u03bc \u2264 R) :\n    \u2200\u1d50 x \u2202\u03bc, liminf (fun n => (\u2016f n x\u2016\u208a : \u211d\u22650\u221e)) atTop < \u221e", "start": [1658, 1], "end": [1684, 68], "kind": "commanddeclaration"}, {"full_name": "Continuous.mem\u2112p_top_of_hasCompactSupport", "code": "theorem _root_.Continuous.mem\u2112p_top_of_hasCompactSupport\n    {X : Type*} [TopologicalSpace X] [MeasurableSpace X] [OpensMeasurableSpace X]\n    {f : X \u2192 E} (hf : Continuous f) (h'f : HasCompactSupport f) (\u03bc : Measure X) : Mem\u2112p f \u22a4 \u03bc", "start": [1689, 1], "end": [1696, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "imports": ["Mathlib/Analysis/NormedSpace/OperatorNorm.lean", "Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean", "Mathlib/Analysis/Calculus/TangentCone.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HasFDerivAtFilter", "code": "def HasFDerivAtFilter (f : E \u2192 F) (f' : E \u2192L[\ud835\udd5c] F) (x : E) (L : Filter E) :=\n  (fun x' => f x' - f x - f' (x' - x)) =o[L] fun x' => x' - x", "start": [139, 1], "end": [145, 62], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt", "code": "def HasFDerivWithinAt (f : E \u2192 F) (f' : E \u2192L[\ud835\udd5c] F) (s : Set E) (x : E) :=\n  HasFDerivAtFilter f f' x (\ud835\udcdd[s] x)", "start": [148, 1], "end": [151, 36], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt", "code": "def HasFDerivAt (f : E \u2192 F) (f' : E \u2192L[\ud835\udd5c] F) (x : E) :=\n  HasFDerivAtFilter f f' x (\ud835\udcdd x)", "start": [154, 1], "end": [157, 33], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt", "code": "def HasStrictFDerivAt (f : E \u2192 F) (f' : E \u2192L[\ud835\udd5c] F) (x : E) :=\n  (fun p : E \u00d7 E => f p.1 - f p.2 - f' (p.1 - p.2)) =o[\ud835\udcdd (x, x)] fun p : E \u00d7 E => p.1 - p.2", "start": [160, 1], "end": [165, 92], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt", "code": "def DifferentiableWithinAt (f : E \u2192 F) (s : Set E) (x : E) :=\n  \u2203 f' : E \u2192L[\ud835\udd5c] F, HasFDerivWithinAt f f' s x", "start": [170, 1], "end": [173, 47], "kind": "commanddeclaration"}, {"full_name": "DifferentiableAt", "code": "def DifferentiableAt (f : E \u2192 F) (x : E) :=\n  \u2203 f' : E \u2192L[\ud835\udd5c] F, HasFDerivAt f f' x", "start": [176, 1], "end": [179, 39], "kind": "commanddeclaration"}, {"full_name": "fderivWithin", "code": "irreducible_def fderivWithin (f : E \u2192 F) (s : Set E) (x : E) : E \u2192L[\ud835\udd5c] F :=\n  if \ud835\udcdd[s \\ {x}] x = \u22a5 then 0 else\n  if h : \u2203 f', HasFDerivWithinAt f f' s x then Classical.choose h else 0", "start": [182, 1], "end": [187, 73], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "fderiv", "code": "irreducible_def fderiv (f : E \u2192 F) (x : E) : E \u2192L[\ud835\udd5c] F :=\n  if h : \u2203 f', HasFDerivAt f f' x then Classical.choose h else 0", "start": [190, 1], "end": [193, 65], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "DifferentiableOn", "code": "def DifferentiableOn (f : E \u2192 F) (s : Set E) :=\n  \u2200 x \u2208 s, DifferentiableWithinAt \ud835\udd5c f s x", "start": [196, 1], "end": [198, 42], "kind": "commanddeclaration"}, {"full_name": "Differentiable", "code": "def Differentiable (f : E \u2192 F) :=\n  \u2200 x, DifferentiableAt \ud835\udd5c f x", "start": [201, 1], "end": [203, 30], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_zero_of_isolated", "code": "theorem fderivWithin_zero_of_isolated (h : \ud835\udcdd[s \\ {x}] x = \u22a5) : fderivWithin \ud835\udd5c f s x = 0", "start": [220, 1], "end": [221, 30], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_zero_of_nmem_closure", "code": "theorem fderivWithin_zero_of_nmem_closure (h : x \u2209 closure s) : fderivWithin \ud835\udd5c f s x = 0", "start": [223, 1], "end": [227, 46], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_zero_of_not_differentiableWithinAt", "code": "theorem fderivWithin_zero_of_not_differentiableWithinAt (h : \u00acDifferentiableWithinAt \ud835\udd5c f s x) :\n    fderivWithin \ud835\udd5c f s x = 0", "start": [229, 1], "end": [232, 28], "kind": "commanddeclaration"}, {"full_name": "fderiv_zero_of_not_differentiableAt", "code": "theorem fderiv_zero_of_not_differentiableAt (h : \u00acDifferentiableAt \ud835\udd5c f x) : fderiv \ud835\udd5c f x = 0", "start": [235, 1], "end": [237, 22], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.lim", "code": "theorem HasFDerivWithinAt.lim (h : HasFDerivWithinAt f f' s x) {\u03b1 : Type*} (l : Filter \u03b1)\n    {c : \u03b1 \u2192 \ud835\udd5c} {d : \u03b1 \u2192 E} {v : E} (dtop : \u2200\u1da0 n in l, x + d n \u2208 s)\n    (clim : Tendsto (fun n => \u2016c n\u2016) l atTop) (cdlim : Tendsto (fun n => c n \u2022 d n) l (\ud835\udcdd v)) :\n    Tendsto (fun n => c n \u2022 (f (x + d n) - f x)) l (\ud835\udcdd (f' v))", "start": [245, 1], "end": [280, 29], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.unique_on", "code": "theorem HasFDerivWithinAt.unique_on (hf : HasFDerivWithinAt f f' s x)\n    (hg : HasFDerivWithinAt f f\u2081' s x) : EqOn f' f\u2081' (tangentConeAt \ud835\udd5c s x)", "start": [283, 1], "end": [288, 84], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffWithinAt.eq", "code": "theorem UniqueDiffWithinAt.eq (H : UniqueDiffWithinAt \ud835\udd5c s x) (hf : HasFDerivWithinAt f f' s x)\n    (hg : HasFDerivWithinAt f f\u2081' s x) : f' = f\u2081'", "start": [291, 1], "end": [294, 51], "kind": "commanddeclaration"}, {"full_name": "UniqueDiffOn.eq", "code": "theorem UniqueDiffOn.eq (H : UniqueDiffOn \ud835\udd5c s) (hx : x \u2208 s) (h : HasFDerivWithinAt f f' s x)\n    (h\u2081 : HasFDerivWithinAt f f\u2081' s x) : f' = f\u2081'", "start": [297, 1], "end": [299, 19], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAtFilter_iff_tendsto", "code": "theorem hasFDerivAtFilter_iff_tendsto :\n    HasFDerivAtFilter f f' x L \u2194\n      Tendsto (fun x' => \u2016x' - x\u2016\u207b\u00b9 * \u2016f x' - f x - f' (x' - x)\u2016) L (\ud835\udcdd 0)", "start": [309, 1], "end": [317, 50], "kind": "commanddeclaration"}, {"full_name": "hasFDerivWithinAt_iff_tendsto", "code": "theorem hasFDerivWithinAt_iff_tendsto :\n    HasFDerivWithinAt f f' s x \u2194\n      Tendsto (fun x' => \u2016x' - x\u2016\u207b\u00b9 * \u2016f x' - f x - f' (x' - x)\u2016) (\ud835\udcdd[s] x) (\ud835\udcdd 0)", "start": [320, 1], "end": [323, 32], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_iff_tendsto", "code": "theorem hasFDerivAt_iff_tendsto :\n    HasFDerivAt f f' x \u2194 Tendsto (fun x' => \u2016x' - x\u2016\u207b\u00b9 * \u2016f x' - f x - f' (x' - x)\u2016) (\ud835\udcdd x) (\ud835\udcdd 0)", "start": [326, 1], "end": [328, 32], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_iff_isLittleO_nhds_zero", "code": "theorem hasFDerivAt_iff_isLittleO_nhds_zero :\n    HasFDerivAt f f' x \u2194 (fun h : E => f (x + h) - f x - f' h) =o[\ud835\udcdd 0] fun h => h", "start": [331, 1], "end": [334, 17], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.le_of_lip'", "code": "theorem HasFDerivAt.le_of_lip' {f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {x\u2080 : E} (hf : HasFDerivAt f f' x\u2080)\n    {C : \u211d} (hC\u2080 : 0 \u2264 C) (hlip : \u2200\u1da0 x in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016) : \u2016f'\u2016 \u2264 C", "start": [337, 1], "end": [350, 46], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.le_of_lipschitzOn", "code": "theorem HasFDerivAt.le_of_lipschitzOn\n    {f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {x\u2080 : E} (hf : HasFDerivAt f f' x\u2080)\n    {s : Set E} (hs : s \u2208 \ud835\udcdd x\u2080) {C : \u211d\u22650} (hlip : LipschitzOnWith C f s) : \u2016f'\u2016 \u2264 C", "start": [354, 1], "end": [360, 79], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.le_of_lipschitz", "code": "theorem HasFDerivAt.le_of_lipschitz {f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {x\u2080 : E} (hf : HasFDerivAt f f' x\u2080)\n    {C : \u211d\u22650} (hlip : LipschitzWith C f) : \u2016f'\u2016 \u2264 C", "start": [363, 1], "end": [367, 58], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAtFilter.mono", "code": "nonrec theorem HasFDerivAtFilter.mono (h : HasFDerivAtFilter f f' x L\u2082) (hst : L\u2081 \u2264 L\u2082) :\n    HasFDerivAtFilter f f' x L\u2081", "start": [369, 1], "end": [371, 13], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.mono_of_mem", "code": "theorem HasFDerivWithinAt.mono_of_mem (h : HasFDerivWithinAt f f' t x) (hst : t \u2208 \ud835\udcdd[s] x) :\n    HasFDerivWithinAt f f' s x", "start": [374, 1], "end": [376, 38], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.mono", "code": "nonrec theorem HasFDerivWithinAt.mono (h : HasFDerivWithinAt f f' t x) (hst : s \u2286 t) :\n    HasFDerivWithinAt f f' s x", "start": [380, 1], "end": [382, 34], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.hasFDerivAtFilter", "code": "theorem HasFDerivAt.hasFDerivAtFilter (h : HasFDerivAt f f' x) (hL : L \u2264 \ud835\udcdd x) :\n    HasFDerivAtFilter f f' x L", "start": [385, 1], "end": [387, 12], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.hasFDerivWithinAt", "code": "theorem HasFDerivAt.hasFDerivWithinAt (h : HasFDerivAt f f' x) : HasFDerivWithinAt f f' s x", "start": [390, 1], "end": [391, 34], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.differentiableWithinAt", "code": "theorem HasFDerivWithinAt.differentiableWithinAt (h : HasFDerivWithinAt f f' s x) :\n    DifferentiableWithinAt \ud835\udd5c f s x", "start": [394, 1], "end": [396, 10], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.differentiableAt", "code": "theorem HasFDerivAt.differentiableAt (h : HasFDerivAt f f' x) : DifferentiableAt \ud835\udd5c f x", "start": [399, 1], "end": [400, 10], "kind": "commanddeclaration"}, {"full_name": "hasFDerivWithinAt_univ", "code": "@[simp]\ntheorem hasFDerivWithinAt_univ : HasFDerivWithinAt f f' univ x \u2194 HasFDerivAt f f' x", "start": [403, 1], "end": [406, 6], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.hasFDerivAt_of_univ", "code": "alias \u27e8HasFDerivWithinAt.hasFDerivAt_of_univ, _\u27e9 := hasFDerivWithinAt_univ", "start": [409, 1], "end": [409, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "hasFDerivWithinAt_insert", "code": "theorem hasFDerivWithinAt_insert {y : E} :\n    HasFDerivWithinAt f f' (insert y s) x \u2194 HasFDerivWithinAt f f' s x", "start": [412, 1], "end": [419, 59], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.of_insert", "code": "alias \u27e8HasFDerivWithinAt.of_insert, HasFDerivWithinAt.insert'\u27e9 := hasFDerivWithinAt_insert", "start": [422, 1], "end": [422, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "HasFDerivWithinAt.insert'", "code": "alias \u27e8HasFDerivWithinAt.of_insert, HasFDerivWithinAt.insert'\u27e9 := hasFDerivWithinAt_insert", "start": [422, 1], "end": [422, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "HasFDerivWithinAt.insert", "code": "protected theorem HasFDerivWithinAt.insert (h : HasFDerivWithinAt g g' s x) :\n    HasFDerivWithinAt g g' (insert x s) x", "start": [426, 1], "end": [428, 12], "kind": "commanddeclaration"}, {"full_name": "hasFDerivWithinAt_diff_singleton", "code": "theorem hasFDerivWithinAt_diff_singleton (y : E) :\n    HasFDerivWithinAt f f' (s \\ {y}) x \u2194 HasFDerivWithinAt f f' s x", "start": [431, 1], "end": [433, 83], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.isBigO_sub", "code": "theorem HasStrictFDerivAt.isBigO_sub (hf : HasStrictFDerivAt f f' x) :\n    (fun p : E \u00d7 E => f p.1 - f p.2) =O[\ud835\udcdd (x, x)] fun p : E \u00d7 E => p.1 - p.2", "start": [436, 1], "end": [438, 48], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAtFilter.isBigO_sub", "code": "theorem HasFDerivAtFilter.isBigO_sub (h : HasFDerivAtFilter f f' x L) :\n    (fun x' => f x' - f x) =O[L] fun x' => x' - x", "start": [442, 1], "end": [444, 46], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.hasFDerivAt", "code": "protected theorem HasStrictFDerivAt.hasFDerivAt (hf : HasStrictFDerivAt f f' x) :\n    HasFDerivAt f f' x", "start": [448, 1], "end": [451, 87], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.differentiableAt", "code": "protected theorem HasStrictFDerivAt.differentiableAt (hf : HasStrictFDerivAt f f' x) :\n    DifferentiableAt \ud835\udd5c f x", "start": [454, 1], "end": [456, 34], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.exists_lipschitzOnWith_of_nnnorm_lt", "code": "theorem HasStrictFDerivAt.exists_lipschitzOnWith_of_nnnorm_lt (hf : HasStrictFDerivAt f f' x)\n    (K : \u211d\u22650) (hK : \u2016f'\u2016\u208a < K) : \u2203 s \u2208 \ud835\udcdd x, LipschitzOnWith K f s", "start": [459, 1], "end": [467, 99], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.exists_lipschitzOnWith", "code": "theorem HasStrictFDerivAt.exists_lipschitzOnWith (hf : HasStrictFDerivAt f f' x) :\n    \u2203 K, \u2203 s \u2208 \ud835\udcdd x, LipschitzOnWith K f s", "start": [470, 1], "end": [475, 59], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.lim", "code": "theorem HasFDerivAt.lim (hf : HasFDerivAt f f' x) (v : E) {\u03b1 : Type*} {c : \u03b1 \u2192 \ud835\udd5c} {l : Filter \u03b1}\n    (hc : Tendsto (fun n => \u2016c n\u2016) l atTop) :\n    Tendsto (fun n => c n \u2022 (f (x + (c n)\u207b\u00b9 \u2022 v) - f x)) l (\ud835\udcdd (f' v))", "start": [478, 1], "end": [487, 47], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.unique", "code": "theorem HasFDerivAt.unique (h\u2080 : HasFDerivAt f f\u2080' x) (h\u2081 : HasFDerivAt f f\u2081' x) : f\u2080' = f\u2081'", "start": [490, 1], "end": [492, 41], "kind": "commanddeclaration"}, {"full_name": "hasFDerivWithinAt_inter'", "code": "theorem hasFDerivWithinAt_inter' (h : t \u2208 \ud835\udcdd[s] x) :\n    HasFDerivWithinAt f f' (s \u2229 t) x \u2194 HasFDerivWithinAt f f' s x", "start": [495, 1], "end": [497, 54], "kind": "commanddeclaration"}, {"full_name": "hasFDerivWithinAt_inter", "code": "theorem hasFDerivWithinAt_inter (h : t \u2208 \ud835\udcdd x) :\n    HasFDerivWithinAt f f' (s \u2229 t) x \u2194 HasFDerivWithinAt f f' s x", "start": [500, 1], "end": [502, 53], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.union", "code": "theorem HasFDerivWithinAt.union (hs : HasFDerivWithinAt f f' s x)\n    (ht : HasFDerivWithinAt f f' t x) : HasFDerivWithinAt f f' (s \u222a t) x", "start": [505, 1], "end": [508, 18], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.hasFDerivAt", "code": "theorem HasFDerivWithinAt.hasFDerivAt (h : HasFDerivWithinAt f f' s x) (hs : s \u2208 \ud835\udcdd x) :\n    HasFDerivAt f f' x", "start": [511, 1], "end": [513, 80], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.differentiableAt", "code": "theorem DifferentiableWithinAt.differentiableAt (h : DifferentiableWithinAt \ud835\udd5c f s x)\n    (hs : s \u2208 \ud835\udcdd x) : DifferentiableAt \ud835\udd5c f x", "start": [516, 1], "end": [518, 40], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt_of_nhdsWithin_eq_bot", "code": "theorem HasFDerivWithinAt_of_nhdsWithin_eq_bot (h : \ud835\udcdd[s\\{x}] x = \u22a5) :\n    HasFDerivWithinAt f f' s x", "start": [521, 1], "end": [532, 51], "kind": "commanddeclaration"}, {"full_name": "hasFDerivWithinAt_of_nmem_closure", "code": "theorem hasFDerivWithinAt_of_nmem_closure (h : x \u2209 closure s) : HasFDerivWithinAt f f' s x", "start": [534, 1], "end": [538, 72], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.hasFDerivWithinAt", "code": "theorem DifferentiableWithinAt.hasFDerivWithinAt (h : DifferentiableWithinAt \ud835\udd5c f s x) :\n    HasFDerivWithinAt f (fderivWithin \ud835\udd5c f s x) s x", "start": [541, 1], "end": [549, 34], "kind": "commanddeclaration"}, {"full_name": "DifferentiableAt.hasFDerivAt", "code": "theorem DifferentiableAt.hasFDerivAt (h : DifferentiableAt \ud835\udd5c f x) :\n    HasFDerivAt f (fderiv \ud835\udd5c f x) x", "start": [552, 1], "end": [556, 32], "kind": "commanddeclaration"}, {"full_name": "DifferentiableOn.hasFDerivAt", "code": "theorem DifferentiableOn.hasFDerivAt (h : DifferentiableOn \ud835\udd5c f s) (hs : s \u2208 \ud835\udcdd x) :\n    HasFDerivAt f (fderiv \ud835\udd5c f x) x", "start": [559, 1], "end": [561, 63], "kind": "commanddeclaration"}, {"full_name": "DifferentiableOn.differentiableAt", "code": "theorem DifferentiableOn.differentiableAt (h : DifferentiableOn \ud835\udd5c f s) (hs : s \u2208 \ud835\udcdd x) :\n    DifferentiableAt \ud835\udd5c f x", "start": [564, 1], "end": [566, 38], "kind": "commanddeclaration"}, {"full_name": "DifferentiableOn.eventually_differentiableAt", "code": "theorem DifferentiableOn.eventually_differentiableAt (h : DifferentiableOn \ud835\udd5c f s) (hs : s \u2208 \ud835\udcdd x) :\n    \u2200\u1da0 y in \ud835\udcdd x, DifferentiableAt \ud835\udd5c f y", "start": [569, 1], "end": [571, 69], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.fderiv", "code": "protected theorem HasFDerivAt.fderiv (h : HasFDerivAt f f' x) : fderiv \ud835\udd5c f x = f'", "start": [574, 1], "end": [576, 47], "kind": "commanddeclaration"}, {"full_name": "fderiv_eq", "code": "theorem fderiv_eq {f' : E \u2192 E \u2192L[\ud835\udd5c] F} (h : \u2200 x, HasFDerivAt f (f' x) x) : fderiv \ud835\udd5c f = f'", "start": [579, 1], "end": [580, 31], "kind": "commanddeclaration"}, {"full_name": "norm_fderiv_le_of_lip'", "code": "theorem norm_fderiv_le_of_lip' {f : E \u2192 F} {x\u2080 : E}\n    {C : \u211d} (hC\u2080 : 0 \u2264 C) (hlip : \u2200\u1da0 x in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016) :\n    \u2016fderiv \ud835\udd5c f x\u2080\u2016 \u2264 C", "start": [585, 1], "end": [594, 15], "kind": "commanddeclaration"}, {"full_name": "norm_fderiv_le_of_lipschitzOn", "code": "theorem norm_fderiv_le_of_lipschitzOn {f : E \u2192 F} {x\u2080 : E} {s : Set E} (hs : s \u2208 \ud835\udcdd x\u2080)\n    {C : \u211d\u22650} (hlip : LipschitzOnWith C f s) : \u2016fderiv \ud835\udd5c f x\u2080\u2016 \u2264 C", "start": [596, 1], "end": [603, 79], "kind": "commanddeclaration"}, {"full_name": "norm_fderiv_le_of_lipschitz", "code": "theorem norm_fderiv_le_of_lipschitz {f : E \u2192 F} {x\u2080 : E}\n    {C : \u211d\u22650} (hlip : LipschitzWith C f) : \u2016fderiv \ud835\udd5c f x\u2080\u2016 \u2264 C", "start": [606, 1], "end": [611, 69], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.fderivWithin", "code": "protected theorem HasFDerivWithinAt.fderivWithin (h : HasFDerivWithinAt f f' s x)\n    (hxs : UniqueDiffWithinAt \ud835\udd5c s x) : fderivWithin \ud835\udd5c f s x = f'", "start": [615, 1], "end": [617, 61], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.mono", "code": "theorem DifferentiableWithinAt.mono (h : DifferentiableWithinAt \ud835\udd5c f t x) (st : s \u2286 t) :\n    DifferentiableWithinAt \ud835\udd5c f s x", "start": [620, 1], "end": [623, 26], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.mono_of_mem", "code": "theorem DifferentiableWithinAt.mono_of_mem (h : DifferentiableWithinAt \ud835\udd5c f s x) {t : Set E}\n    (hst : s \u2208 \ud835\udcdd[t] x) : DifferentiableWithinAt \ud835\udd5c f t x", "start": [626, 1], "end": [628, 63], "kind": "commanddeclaration"}, {"full_name": "differentiableWithinAt_univ", "code": "theorem differentiableWithinAt_univ : DifferentiableWithinAt \ud835\udd5c f univ x \u2194 DifferentiableAt \ud835\udd5c f x", "start": [631, 1], "end": [632, 82], "kind": "commanddeclaration"}, {"full_name": "differentiableWithinAt_inter", "code": "theorem differentiableWithinAt_inter (ht : t \u2208 \ud835\udcdd x) :\n    DifferentiableWithinAt \ud835\udd5c f (s \u2229 t) x \u2194 DifferentiableWithinAt \ud835\udd5c f s x", "start": [635, 1], "end": [637, 65], "kind": "commanddeclaration"}, {"full_name": "differentiableWithinAt_inter'", "code": "theorem differentiableWithinAt_inter' (ht : t \u2208 \ud835\udcdd[s] x) :\n    DifferentiableWithinAt \ud835\udd5c f (s \u2229 t) x \u2194 DifferentiableWithinAt \ud835\udd5c f s x", "start": [640, 1], "end": [642, 66], "kind": "commanddeclaration"}, {"full_name": "DifferentiableAt.differentiableWithinAt", "code": "theorem DifferentiableAt.differentiableWithinAt (h : DifferentiableAt \ud835\udd5c f x) :\n    DifferentiableWithinAt \ud835\udd5c f s x", "start": [645, 1], "end": [647, 57], "kind": "commanddeclaration"}, {"full_name": "Differentiable.differentiableAt", "code": "theorem Differentiable.differentiableAt (h : Differentiable \ud835\udd5c f) : DifferentiableAt \ud835\udd5c f x", "start": [650, 1], "end": [651, 6], "kind": "commanddeclaration"}, {"full_name": "DifferentiableAt.fderivWithin", "code": "protected theorem DifferentiableAt.fderivWithin (h : DifferentiableAt \ud835\udd5c f x)\n    (hxs : UniqueDiffWithinAt \ud835\udd5c s x) : fderivWithin \ud835\udd5c f s x = fderiv \ud835\udd5c f x", "start": [654, 1], "end": [656, 51], "kind": "commanddeclaration"}, {"full_name": "DifferentiableOn.mono", "code": "theorem DifferentiableOn.mono (h : DifferentiableOn \ud835\udd5c f t) (st : s \u2286 t) : DifferentiableOn \ud835\udd5c f s", "start": [659, 1], "end": [660, 36], "kind": "commanddeclaration"}, {"full_name": "differentiableOn_univ", "code": "theorem differentiableOn_univ : DifferentiableOn \ud835\udd5c f univ \u2194 Differentiable \ud835\udd5c f", "start": [663, 1], "end": [665, 22], "kind": "commanddeclaration"}, {"full_name": "Differentiable.differentiableOn", "code": "theorem Differentiable.differentiableOn (h : Differentiable \ud835\udd5c f) : DifferentiableOn \ud835\udd5c f s", "start": [668, 1], "end": [669, 51], "kind": "commanddeclaration"}, {"full_name": "differentiableOn_of_locally_differentiableOn", "code": "theorem differentiableOn_of_locally_differentiableOn\n    (h : \u2200 x \u2208 s, \u2203 u, IsOpen u \u2227 x \u2208 u \u2227 DifferentiableOn \ud835\udd5c f (s \u2229 u)) :\n    DifferentiableOn \ud835\udd5c f s", "start": [672, 1], "end": [677, 85], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_of_mem", "code": "theorem fderivWithin_of_mem (st : t \u2208 \ud835\udcdd[s] x) (ht : UniqueDiffWithinAt \ud835\udd5c s x)\n    (h : DifferentiableWithinAt \ud835\udd5c f t x) : fderivWithin \ud835\udd5c f s x = fderivWithin \ud835\udd5c f t x", "start": [680, 1], "end": [682, 80], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_subset", "code": "theorem fderivWithin_subset (st : s \u2286 t) (ht : UniqueDiffWithinAt \ud835\udd5c s x)\n    (h : DifferentiableWithinAt \ud835\udd5c f t x) : fderivWithin \ud835\udd5c f s x = fderivWithin \ud835\udd5c f t x", "start": [685, 1], "end": [687, 70], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_inter", "code": "theorem fderivWithin_inter (ht : t \u2208 \ud835\udcdd x) : fderivWithin \ud835\udd5c f (s \u2229 t) x = fderivWithin \ud835\udd5c f s x", "start": [690, 1], "end": [694, 53], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_univ", "code": "@[simp]\ntheorem fderivWithin_univ : fderivWithin \ud835\udd5c f univ = fderiv \ud835\udd5c f", "start": [697, 1], "end": [708, 35], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_of_mem_nhds", "code": "theorem fderivWithin_of_mem_nhds (h : s \u2208 \ud835\udcdd x) : fderivWithin \ud835\udd5c f s x = fderiv \ud835\udd5c f x", "start": [711, 1], "end": [712, 65], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_of_open", "code": "theorem fderivWithin_of_open (hs : IsOpen s) (hx : x \u2208 s) : fderivWithin \ud835\udd5c f s x = fderiv \ud835\udd5c f x", "start": [715, 1], "end": [716, 44], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_eq_fderiv", "code": "theorem fderivWithin_eq_fderiv (hs : UniqueDiffWithinAt \ud835\udd5c s x) (h : DifferentiableAt \ud835\udd5c f x) :\n    fderivWithin \ud835\udd5c f s x = fderiv \ud835\udd5c f x", "start": [719, 1], "end": [722, 72], "kind": "commanddeclaration"}, {"full_name": "fderiv_mem_iff", "code": "theorem fderiv_mem_iff {f : E \u2192 F} {s : Set (E \u2192L[\ud835\udd5c] F)} {x : E} :\n    fderiv \ud835\udd5c f x \u2208 s \u2194\n      DifferentiableAt \ud835\udd5c f x \u2227 fderiv \ud835\udd5c f x \u2208 s \u2228 \u00acDifferentiableAt \ud835\udd5c f x \u2227 (0 : E \u2192L[\ud835\udd5c] F) \u2208 s", "start": [725, 1], "end": [728, 92], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_mem_iff", "code": "theorem fderivWithin_mem_iff {f : E \u2192 F} {t : Set E} {s : Set (E \u2192L[\ud835\udd5c] F)} {x : E} :\n    fderivWithin \ud835\udd5c f t x \u2208 s \u2194\n      DifferentiableWithinAt \ud835\udd5c f t x \u2227 fderivWithin \ud835\udd5c f t x \u2208 s \u2228\n        \u00acDifferentiableWithinAt \ud835\udd5c f t x \u2227 (0 : E \u2192L[\ud835\udd5c] F) \u2208 s", "start": [731, 1], "end": [736, 62], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.hasFDerivWithinAt", "code": "theorem Asymptotics.IsBigO.hasFDerivWithinAt {s : Set E} {x\u2080 : E} {n : \u2115}\n    (h : f =O[\ud835\udcdd[s] x\u2080] fun x => \u2016x - x\u2080\u2016 ^ n) (hx\u2080 : x\u2080 \u2208 s) (hn : 1 < n) :\n    HasFDerivWithinAt f (0 : E \u2192L[\ud835\udd5c] F) s x\u2080", "start": [739, 1], "end": [744, 79], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.hasFDerivAt", "code": "theorem Asymptotics.IsBigO.hasFDerivAt {x\u2080 : E} {n : \u2115} (h : f =O[\ud835\udcdd x\u2080] fun x => \u2016x - x\u2080\u2016 ^ n)\n    (hn : 1 < n) : HasFDerivAt f (0 : E \u2192L[\ud835\udd5c] F) x\u2080", "start": [748, 1], "end": [751, 66], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.isBigO", "code": "nonrec theorem HasFDerivWithinAt.isBigO {f : E \u2192 F} {s : Set E} {x\u2080 : E} {f' : E \u2192L[\ud835\udd5c] F}\n    (h : HasFDerivWithinAt f f' s x\u2080) : (fun x => f x - f x\u2080) =O[\ud835\udcdd[s] x\u2080] fun x => x - x\u2080", "start": [755, 1], "end": [757, 78], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.isBigO", "code": "nonrec theorem HasFDerivAt.isBigO {f : E \u2192 F} {x\u2080 : E} {f' : E \u2192L[\ud835\udd5c] F} (h : HasFDerivAt f f' x\u2080) :\n    (fun x => f x - f x\u2080) =O[\ud835\udcdd x\u2080] fun x => x - x\u2080", "start": [761, 1], "end": [763, 75], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAtFilter.tendsto_nhds", "code": "theorem HasFDerivAtFilter.tendsto_nhds (hL : L \u2264 \ud835\udcdd x) (h : HasFDerivAtFilter f f' x L) :\n    Tendsto f L (\ud835\udcdd (f x))", "start": [774, 1], "end": [782, 83], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.continuousWithinAt", "code": "theorem HasFDerivWithinAt.continuousWithinAt (h : HasFDerivWithinAt f f' s x) :\n    ContinuousWithinAt f s x", "start": [785, 1], "end": [787, 47], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.continuousAt", "code": "theorem HasFDerivAt.continuousAt (h : HasFDerivAt f f' x) : ContinuousAt f x", "start": [790, 1], "end": [791, 42], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.continuousWithinAt", "code": "theorem DifferentiableWithinAt.continuousWithinAt (h : DifferentiableWithinAt \ud835\udd5c f s x) :\n    ContinuousWithinAt f s x", "start": [794, 1], "end": [797, 25], "kind": "commanddeclaration"}, {"full_name": "DifferentiableAt.continuousAt", "code": "theorem DifferentiableAt.continuousAt (h : DifferentiableAt \ud835\udd5c f x) : ContinuousAt f x", "start": [800, 1], "end": [802, 19], "kind": "commanddeclaration"}, {"full_name": "DifferentiableOn.continuousOn", "code": "theorem DifferentiableOn.continuousOn (h : DifferentiableOn \ud835\udd5c f s) : ContinuousOn f s", "start": [805, 1], "end": [806, 30], "kind": "commanddeclaration"}, {"full_name": "Differentiable.continuous", "code": "theorem Differentiable.continuous (h : Differentiable \ud835\udd5c f) : Continuous f", "start": [809, 1], "end": [810, 60], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.continuousAt", "code": "protected theorem HasStrictFDerivAt.continuousAt (hf : HasStrictFDerivAt f f' x) :\n    ContinuousAt f x", "start": [813, 1], "end": [815, 30], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.isBigO_sub_rev", "code": "theorem HasStrictFDerivAt.isBigO_sub_rev {f' : E \u2243L[\ud835\udd5c] F}\n    (hf : HasStrictFDerivAt f (f' : E \u2192L[\ud835\udd5c] F) x) :\n    (fun p : E \u00d7 E => p.1 - p.2) =O[\ud835\udcdd (x, x)] fun p : E \u00d7 E => f p.1 - f p.2", "start": [818, 1], "end": [822, 47], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAtFilter.isBigO_sub_rev", "code": "theorem HasFDerivAtFilter.isBigO_sub_rev (hf : HasFDerivAtFilter f f' x L) {C}\n    (hf' : AntilipschitzWith C f') : (fun x' => x' - x) =O[L] fun x' => f x' - f x", "start": [826, 1], "end": [831, 23], "kind": "commanddeclaration"}, {"full_name": "hasFDerivWithinAt_congr_set'", "code": "theorem hasFDerivWithinAt_congr_set' (y : E) (h : s =\u1da0[\ud835\udcdd[{y}\u1d9c] x] t) :\n    HasFDerivWithinAt f f' s x \u2194 HasFDerivWithinAt f f' t x", "start": [840, 1], "end": [849, 73], "kind": "commanddeclaration"}, {"full_name": "hasFDerivWithinAt_congr_set", "code": "theorem hasFDerivWithinAt_congr_set (h : s =\u1da0[\ud835\udcdd x] t) :\n    HasFDerivWithinAt f f' s x \u2194 HasFDerivWithinAt f f' t x", "start": [852, 1], "end": [854, 62], "kind": "commanddeclaration"}, {"full_name": "differentiableWithinAt_congr_set'", "code": "theorem differentiableWithinAt_congr_set' (y : E) (h : s =\u1da0[\ud835\udcdd[{y}\u1d9c] x] t) :\n    DifferentiableWithinAt \ud835\udd5c f s x \u2194 DifferentiableWithinAt \ud835\udd5c f t x", "start": [857, 1], "end": [859, 57], "kind": "commanddeclaration"}, {"full_name": "differentiableWithinAt_congr_set", "code": "theorem differentiableWithinAt_congr_set (h : s =\u1da0[\ud835\udcdd x] t) :\n    DifferentiableWithinAt \ud835\udd5c f s x \u2194 DifferentiableWithinAt \ud835\udd5c f t x", "start": [862, 1], "end": [864, 54], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_congr_set'", "code": "theorem fderivWithin_congr_set' (y : E) (h : s =\u1da0[\ud835\udcdd[{y}\u1d9c] x] t) :\n    fderivWithin \ud835\udd5c f s x = fderivWithin \ud835\udd5c f t x", "start": [867, 1], "end": [873, 67], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_congr_set", "code": "theorem fderivWithin_congr_set (h : s =\u1da0[\ud835\udcdd x] t) : fderivWithin \ud835\udd5c f s x = fderivWithin \ud835\udd5c f t x", "start": [876, 1], "end": [877, 57], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_eventually_congr_set'", "code": "theorem fderivWithin_eventually_congr_set' (y : E) (h : s =\u1da0[\ud835\udcdd[{y}\u1d9c] x] t) :\n    fderivWithin \ud835\udd5c f s =\u1da0[\ud835\udcdd x] fderivWithin \ud835\udd5c f t", "start": [880, 1], "end": [882, 75], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_eventually_congr_set", "code": "theorem fderivWithin_eventually_congr_set (h : s =\u1da0[\ud835\udcdd x] t) :\n    fderivWithin \ud835\udd5c f s =\u1da0[\ud835\udcdd x] fderivWithin \ud835\udd5c f t", "start": [885, 1], "end": [887, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.hasStrictFDerivAt_iff", "code": "theorem Filter.EventuallyEq.hasStrictFDerivAt_iff (h : f\u2080 =\u1da0[\ud835\udcdd x] f\u2081) (h' : \u2200 y, f\u2080' y = f\u2081' y) :\n    HasStrictFDerivAt f\u2080 f\u2080' x \u2194 HasStrictFDerivAt f\u2081 f\u2081' x", "start": [890, 1], "end": [894, 16], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.congr_fderiv", "code": "theorem HasStrictFDerivAt.congr_fderiv (h : HasStrictFDerivAt f f' x) (h' : f' = g') :\n    HasStrictFDerivAt f g' x", "start": [897, 1], "end": [899, 9], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.congr_fderiv", "code": "theorem HasFDerivAt.congr_fderiv (h : HasFDerivAt f f' x) (h' : f' = g') : HasFDerivAt f g' x", "start": [901, 1], "end": [902, 9], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.congr_fderiv", "code": "theorem HasFDerivWithinAt.congr_fderiv (h : HasFDerivWithinAt f f' s x) (h' : f' = g') :\n    HasFDerivWithinAt f g' s x", "start": [904, 1], "end": [906, 9], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.congr_of_eventuallyEq", "code": "theorem HasStrictFDerivAt.congr_of_eventuallyEq (h : HasStrictFDerivAt f f' x)\n    (h\u2081 : f =\u1da0[\ud835\udcdd x] f\u2081) : HasStrictFDerivAt f\u2081 f' x", "start": [908, 1], "end": [910, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.hasFDerivAtFilter_iff", "code": "theorem Filter.EventuallyEq.hasFDerivAtFilter_iff (h\u2080 : f\u2080 =\u1da0[L] f\u2081) (hx : f\u2080 x = f\u2081 x)\n    (h\u2081 : \u2200 x, f\u2080' x = f\u2081' x) : HasFDerivAtFilter f\u2080 f\u2080' x L \u2194 HasFDerivAtFilter f\u2081 f\u2081' x L", "start": [913, 1], "end": [916, 47], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAtFilter.congr_of_eventuallyEq", "code": "theorem HasFDerivAtFilter.congr_of_eventuallyEq (h : HasFDerivAtFilter f f' x L) (hL : f\u2081 =\u1da0[L] f)\n    (hx : f\u2081 x = f x) : HasFDerivAtFilter f\u2081 f' x L", "start": [919, 1], "end": [921, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.hasFDerivAt_iff", "code": "theorem Filter.EventuallyEq.hasFDerivAt_iff (h : f\u2080 =\u1da0[\ud835\udcdd x] f\u2081) :\n    HasFDerivAt f\u2080 f' x \u2194 HasFDerivAt f\u2081 f' x", "start": [924, 1], "end": [926, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.differentiableAt_iff", "code": "theorem Filter.EventuallyEq.differentiableAt_iff (h : f\u2080 =\u1da0[\ud835\udcdd x] f\u2081) :\n    DifferentiableAt \ud835\udd5c f\u2080 x \u2194 DifferentiableAt \ud835\udd5c f\u2081 x", "start": [929, 1], "end": [931, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.hasFDerivWithinAt_iff", "code": "theorem Filter.EventuallyEq.hasFDerivWithinAt_iff (h : f\u2080 =\u1da0[\ud835\udcdd[s] x] f\u2081) (hx : f\u2080 x = f\u2081 x) :\n    HasFDerivWithinAt f\u2080 f' s x \u2194 HasFDerivWithinAt f\u2081 f' s x", "start": [934, 1], "end": [936, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.hasFDerivWithinAt_iff_of_mem", "code": "theorem Filter.EventuallyEq.hasFDerivWithinAt_iff_of_mem (h : f\u2080 =\u1da0[\ud835\udcdd[s] x] f\u2081) (hx : x \u2208 s) :\n    HasFDerivWithinAt f\u2080 f' s x \u2194 HasFDerivWithinAt f\u2081 f' s x", "start": [939, 1], "end": [941, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.differentiableWithinAt_iff", "code": "theorem Filter.EventuallyEq.differentiableWithinAt_iff (h : f\u2080 =\u1da0[\ud835\udcdd[s] x] f\u2081) (hx : f\u2080 x = f\u2081 x) :\n    DifferentiableWithinAt \ud835\udd5c f\u2080 s x \u2194 DifferentiableWithinAt \ud835\udd5c f\u2081 s x", "start": [944, 1], "end": [946, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.differentiableWithinAt_iff_of_mem", "code": "theorem Filter.EventuallyEq.differentiableWithinAt_iff_of_mem (h : f\u2080 =\u1da0[\ud835\udcdd[s] x] f\u2081) (hx : x \u2208 s) :\n    DifferentiableWithinAt \ud835\udd5c f\u2080 s x \u2194 DifferentiableWithinAt \ud835\udd5c f\u2081 s x", "start": [949, 1], "end": [951, 55], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.congr_mono", "code": "theorem HasFDerivWithinAt.congr_mono (h : HasFDerivWithinAt f f' s x) (ht : EqOn f\u2081 f t)\n    (hx : f\u2081 x = f x) (h\u2081 : t \u2286 s) : HasFDerivWithinAt f\u2081 f' t x", "start": [954, 1], "end": [956, 86], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.congr", "code": "theorem HasFDerivWithinAt.congr (h : HasFDerivWithinAt f f' s x) (hs : EqOn f\u2081 f s)\n    (hx : f\u2081 x = f x) : HasFDerivWithinAt f\u2081 f' s x", "start": [959, 1], "end": [961, 37], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.congr'", "code": "theorem HasFDerivWithinAt.congr' (h : HasFDerivWithinAt f f' s x) (hs : EqOn f\u2081 f s) (hx : x \u2208 s) :\n    HasFDerivWithinAt f\u2081 f' s x", "start": [964, 1], "end": [966, 21], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.congr_of_eventuallyEq", "code": "theorem HasFDerivWithinAt.congr_of_eventuallyEq (h : HasFDerivWithinAt f f' s x)\n    (h\u2081 : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) (hx : f\u2081 x = f x) : HasFDerivWithinAt f\u2081 f' s x", "start": [969, 1], "end": [971, 50], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.congr_of_eventuallyEq", "code": "theorem HasFDerivAt.congr_of_eventuallyEq (h : HasFDerivAt f f' x) (h\u2081 : f\u2081 =\u1da0[\ud835\udcdd x] f) :\n    HasFDerivAt f\u2081 f' x", "start": [974, 1], "end": [976, 72], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.congr_mono", "code": "theorem DifferentiableWithinAt.congr_mono (h : DifferentiableWithinAt \ud835\udd5c f s x) (ht : EqOn f\u2081 f t)\n    (hx : f\u2081 x = f x) (h\u2081 : t \u2286 s) : DifferentiableWithinAt \ud835\udd5c f\u2081 t x", "start": [979, 1], "end": [981, 85], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.congr", "code": "theorem DifferentiableWithinAt.congr (h : DifferentiableWithinAt \ud835\udd5c f s x) (ht : \u2200 x \u2208 s, f\u2081 x = f x)\n    (hx : f\u2081 x = f x) : DifferentiableWithinAt \ud835\udd5c f\u2081 s x", "start": [984, 1], "end": [986, 60], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.congr_of_eventuallyEq", "code": "theorem DifferentiableWithinAt.congr_of_eventuallyEq (h : DifferentiableWithinAt \ud835\udd5c f s x)\n    (h\u2081 : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) (hx : f\u2081 x = f x) : DifferentiableWithinAt \ud835\udd5c f\u2081 s x", "start": [989, 1], "end": [991, 75], "kind": "commanddeclaration"}, {"full_name": "DifferentiableOn.congr_mono", "code": "theorem DifferentiableOn.congr_mono (h : DifferentiableOn \ud835\udd5c f s) (h' : \u2200 x \u2208 t, f\u2081 x = f x)\n    (h\u2081 : t \u2286 s) : DifferentiableOn \ud835\udd5c f\u2081 t", "start": [994, 1], "end": [995, 99], "kind": "commanddeclaration"}, {"full_name": "DifferentiableOn.congr", "code": "theorem DifferentiableOn.congr (h : DifferentiableOn \ud835\udd5c f s) (h' : \u2200 x \u2208 s, f\u2081 x = f x) :\n    DifferentiableOn \ud835\udd5c f\u2081 s", "start": [998, 1], "end": [999, 71], "kind": "commanddeclaration"}, {"full_name": "differentiableOn_congr", "code": "theorem differentiableOn_congr (h' : \u2200 x \u2208 s, f\u2081 x = f x) :\n    DifferentiableOn \ud835\udd5c f\u2081 s \u2194 DifferentiableOn \ud835\udd5c f s", "start": [1002, 1], "end": [1005, 33], "kind": "commanddeclaration"}, {"full_name": "DifferentiableAt.congr_of_eventuallyEq", "code": "theorem DifferentiableAt.congr_of_eventuallyEq (h : DifferentiableAt \ud835\udd5c f x) (hL : f\u2081 =\u1da0[\ud835\udcdd x] f) :\n    DifferentiableAt \ud835\udd5c f\u2081 x", "start": [1008, 1], "end": [1010, 30], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.fderivWithin_congr_mono", "code": "theorem DifferentiableWithinAt.fderivWithin_congr_mono (h : DifferentiableWithinAt \ud835\udd5c f s x)\n    (hs : EqOn f\u2081 f t) (hx : f\u2081 x = f x) (hxt : UniqueDiffWithinAt \ud835\udd5c t x) (h\u2081 : t \u2286 s) :\n    fderivWithin \ud835\udd5c f\u2081 t x = fderivWithin \ud835\udd5c f s x", "start": [1013, 1], "end": [1016, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.fderivWithin_eq", "code": "theorem Filter.EventuallyEq.fderivWithin_eq (hs : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) (hx : f\u2081 x = f x) :\n    fderivWithin \ud835\udd5c f\u2081 s x = fderivWithin \ud835\udd5c f s x", "start": [1019, 1], "end": [1021, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.fderiv_within'", "code": "theorem Filter.EventuallyEq.fderiv_within' (hs : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) (ht : t \u2286 s) :\n    fderivWithin \ud835\udd5c f\u2081 t =\u1da0[\ud835\udcdd[s] x] fderivWithin \ud835\udd5c f t", "start": [1024, 1], "end": [1029, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.fderivWithin", "code": "protected theorem Filter.EventuallyEq.fderivWithin (hs : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) :\n    fderivWithin \ud835\udd5c f\u2081 s =\u1da0[\ud835\udcdd[s] x] fderivWithin \ud835\udd5c f s", "start": [1032, 1], "end": [1034, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.fderivWithin_eq_nhds", "code": "theorem Filter.EventuallyEq.fderivWithin_eq_nhds (h : f\u2081 =\u1da0[\ud835\udcdd x] f) :\n    fderivWithin \ud835\udd5c f\u2081 s x = fderivWithin \ud835\udd5c f s x", "start": [1037, 1], "end": [1039, 68], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_congr", "code": "theorem fderivWithin_congr (hs : EqOn f\u2081 f s) (hx : f\u2081 x = f x) :\n    fderivWithin \ud835\udd5c f\u2081 s x = fderivWithin \ud835\udd5c f s x", "start": [1042, 1], "end": [1044, 64], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_congr'", "code": "theorem fderivWithin_congr' (hs : EqOn f\u2081 f s) (hx : x \u2208 s) :\n    fderivWithin \ud835\udd5c f\u2081 s x = fderivWithin \ud835\udd5c f s x", "start": [1047, 1], "end": [1049, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.fderiv_eq", "code": "theorem Filter.EventuallyEq.fderiv_eq (h : f\u2081 =\u1da0[\ud835\udcdd x] f) : fderiv \ud835\udd5c f\u2081 x = fderiv \ud835\udd5c f x", "start": [1052, 1], "end": [1053, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.fderiv", "code": "protected theorem Filter.EventuallyEq.fderiv (h : f\u2081 =\u1da0[\ud835\udcdd x] f) : fderiv \ud835\udd5c f\u2081 =\u1da0[\ud835\udcdd x] fderiv \ud835\udd5c f", "start": [1056, 1], "end": [1057, 50], "kind": "commanddeclaration"}, {"full_name": "hasStrictFDerivAt_id", "code": "theorem hasStrictFDerivAt_id (x : E) : HasStrictFDerivAt id (id \ud835\udd5c E) x", "start": [1067, 1], "end": [1068, 45], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAtFilter_id", "code": "theorem hasFDerivAtFilter_id (x : E) (L : Filter E) : HasFDerivAtFilter id (id \ud835\udd5c E) x L", "start": [1071, 1], "end": [1072, 45], "kind": "commanddeclaration"}, {"full_name": "hasFDerivWithinAt_id", "code": "theorem hasFDerivWithinAt_id (x : E) (s : Set E) : HasFDerivWithinAt id (id \ud835\udd5c E) s x", "start": [1075, 1], "end": [1076, 27], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_id", "code": "theorem hasFDerivAt_id (x : E) : HasFDerivAt id (id \ud835\udd5c E) x", "start": [1079, 1], "end": [1080, 27], "kind": "commanddeclaration"}, {"full_name": "differentiableAt_id", "code": "@[simp]\ntheorem differentiableAt_id : DifferentiableAt \ud835\udd5c id x", "start": [1083, 1], "end": [1085, 38], "kind": "commanddeclaration"}, {"full_name": "differentiableAt_id'", "code": "@[simp]\ntheorem differentiableAt_id' : DifferentiableAt \ud835\udd5c (fun x => x) x", "start": [1088, 1], "end": [1090, 38], "kind": "commanddeclaration"}, {"full_name": "differentiableWithinAt_id", "code": "theorem differentiableWithinAt_id : DifferentiableWithinAt \ud835\udd5c id s x", "start": [1093, 1], "end": [1094, 45], "kind": "commanddeclaration"}, {"full_name": "differentiable_id", "code": "@[simp]\ntheorem differentiable_id : Differentiable \ud835\udd5c (id : E \u2192 E)", "start": [1097, 1], "end": [1098, 90], "kind": "commanddeclaration"}, {"full_name": "differentiable_id'", "code": "@[simp]\ntheorem differentiable_id' : Differentiable \ud835\udd5c fun x : E => x", "start": [1101, 1], "end": [1102, 93], "kind": "commanddeclaration"}, {"full_name": "differentiableOn_id", "code": "theorem differentiableOn_id : DifferentiableOn \ud835\udd5c id s", "start": [1105, 1], "end": [1106, 37], "kind": "commanddeclaration"}, {"full_name": "fderiv_id", "code": "@[simp]\ntheorem fderiv_id : fderiv \ud835\udd5c id x = id \ud835\udd5c E", "start": [1109, 1], "end": [1111, 40], "kind": "commanddeclaration"}, {"full_name": "fderiv_id'", "code": "@[simp]\ntheorem fderiv_id' : fderiv \ud835\udd5c (fun x : E => x) x = ContinuousLinearMap.id \ud835\udd5c E", "start": [1114, 1], "end": [1116, 12], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_id", "code": "theorem fderivWithin_id (hxs : UniqueDiffWithinAt \ud835\udd5c s x) : fderivWithin \ud835\udd5c id s x = id \ud835\udd5c E", "start": [1119, 1], "end": [1121, 18], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_id'", "code": "theorem fderivWithin_id' (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    fderivWithin \ud835\udd5c (fun x : E => x) s x = ContinuousLinearMap.id \ud835\udd5c E", "start": [1124, 1], "end": [1126, 22], "kind": "commanddeclaration"}, {"full_name": "hasStrictFDerivAt_const", "code": "theorem hasStrictFDerivAt_const (c : F) (x : E) :\n    HasStrictFDerivAt (fun _ => c) (0 : E \u2192L[\ud835\udd5c] F) x", "start": [1136, 1], "end": [1138, 79], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAtFilter_const", "code": "theorem hasFDerivAtFilter_const (c : F) (x : E) (L : Filter E) :\n    HasFDerivAtFilter (fun _ => c) (0 : E \u2192L[\ud835\udd5c] F) x L", "start": [1141, 1], "end": [1143, 79], "kind": "commanddeclaration"}, {"full_name": "hasFDerivWithinAt_const", "code": "theorem hasFDerivWithinAt_const (c : F) (x : E) (s : Set E) :\n    HasFDerivWithinAt (fun _ => c) (0 : E \u2192L[\ud835\udd5c] F) s x", "start": [1146, 1], "end": [1148, 32], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_const", "code": "theorem hasFDerivAt_const (c : F) (x : E) : HasFDerivAt (fun _ => c) (0 : E \u2192L[\ud835\udd5c] F) x", "start": [1151, 1], "end": [1152, 32], "kind": "commanddeclaration"}, {"full_name": "differentiableAt_const", "code": "@[simp]\ntheorem differentiableAt_const (c : F) : DifferentiableAt \ud835\udd5c (fun _ => c) x", "start": [1155, 1], "end": [1157, 29], "kind": "commanddeclaration"}, {"full_name": "differentiableWithinAt_const", "code": "theorem differentiableWithinAt_const (c : F) : DifferentiableWithinAt \ud835\udd5c (fun _ => c) s x", "start": [1160, 1], "end": [1161, 69], "kind": "commanddeclaration"}, {"full_name": "fderiv_const_apply", "code": "theorem fderiv_const_apply (c : F) : fderiv \ud835\udd5c (fun _ => c) x = 0", "start": [1164, 1], "end": [1165, 45], "kind": "commanddeclaration"}, {"full_name": "fderiv_const", "code": "@[simp]\ntheorem fderiv_const (c : F) : (fderiv \ud835\udd5c fun _ : E => c) = 0", "start": [1168, 1], "end": [1172, 6], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_const_apply", "code": "theorem fderivWithin_const_apply (c : F) (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    fderivWithin \ud835\udd5c (fun _ => c) s x = 0", "start": [1175, 1], "end": [1178, 29], "kind": "commanddeclaration"}, {"full_name": "differentiable_const", "code": "@[simp]\ntheorem differentiable_const (c : F) : Differentiable \ud835\udd5c fun _ : E => c", "start": [1181, 1], "end": [1183, 27], "kind": "commanddeclaration"}, {"full_name": "differentiableOn_const", "code": "theorem differentiableOn_const (c : F) : DifferentiableOn \ud835\udd5c (fun _ => c) s", "start": [1186, 1], "end": [1187, 44], "kind": "commanddeclaration"}, {"full_name": "hasFDerivWithinAt_singleton", "code": "theorem hasFDerivWithinAt_singleton (f : E \u2192 F) (x : E) :\n    HasFDerivWithinAt f (0 : E \u2192L[\ud835\udd5c] F) {x} x", "start": [1190, 1], "end": [1193, 46], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_of_subsingleton", "code": "theorem hasFDerivAt_of_subsingleton [h : Subsingleton E] (f : E \u2192 F) (x : E) :\n    HasFDerivAt f (0 : E \u2192L[\ud835\udd5c] F) x", "start": [1196, 1], "end": [1199, 40], "kind": "commanddeclaration"}, {"full_name": "differentiableOn_empty", "code": "theorem differentiableOn_empty : DifferentiableOn \ud835\udd5c f \u2205", "start": [1202, 1], "end": [1202, 79], "kind": "commanddeclaration"}, {"full_name": "differentiableOn_singleton", "code": "theorem differentiableOn_singleton : DifferentiableOn \ud835\udd5c f {x}", "start": [1205, 1], "end": [1206, 71], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.differentiableOn", "code": "theorem Set.Subsingleton.differentiableOn (hs : s.Subsingleton) : DifferentiableOn \ud835\udd5c f s", "start": [1209, 1], "end": [1210, 77], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_zero_of_eventually_const", "code": "theorem hasFDerivAt_zero_of_eventually_const (c : F) (hf : f =\u1da0[\ud835\udcdd x] fun _ => c) :\n    HasFDerivAt f (0 : E \u2192L[\ud835\udd5c] F) x", "start": [1213, 1], "end": [1215, 51], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.of_nmem_tsupport", "code": "theorem HasStrictFDerivAt.of_nmem_tsupport (h : x \u2209 tsupport f) :\n    HasStrictFDerivAt f (0 : E \u2192L[\ud835\udd5c] F) x", "start": [1231, 1], "end": [1234, 73], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.of_nmem_tsupport", "code": "theorem HasFDerivAt.of_nmem_tsupport (h : x \u2209 tsupport f) :\n    HasFDerivAt f (0 : E \u2192L[\ud835\udd5c] F) x", "start": [1236, 1], "end": [1238, 55], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.of_not_mem_tsupport", "code": "theorem HasFDerivWithinAt.of_not_mem_tsupport (h : x \u2209 tsupport f) :\n    HasFDerivWithinAt f (0 : E \u2192L[\ud835\udd5c] F) s x", "start": [1240, 1], "end": [1242, 55], "kind": "commanddeclaration"}, {"full_name": "fderiv_of_not_mem_tsupport", "code": "theorem fderiv_of_not_mem_tsupport (h : x \u2209 tsupport f) : fderiv \ud835\udd5c f x = 0", "start": [1244, 1], "end": [1245, 44], "kind": "commanddeclaration"}, {"full_name": "support_fderiv_subset", "code": "theorem support_fderiv_subset : support (fderiv \ud835\udd5c f) \u2286 tsupport f", "start": [1247, 1], "end": [1249, 37], "kind": "commanddeclaration"}, {"full_name": "tsupport_fderiv_subset", "code": "theorem tsupport_fderiv_subset : tsupport (fderiv \ud835\udd5c f) \u2286 tsupport f", "start": [1252, 1], "end": [1253, 61], "kind": "commanddeclaration"}, {"full_name": "HasCompactSupport.fderiv", "code": "protected theorem HasCompactSupport.fderiv (hf : HasCompactSupport f) :\n    HasCompactSupport (fderiv \ud835\udd5c f)", "start": [1256, 1], "end": [1258, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/Minpoly/Field.lean", "imports": ["Mathlib/FieldTheory/Minpoly/Basic.lean", "Mathlib/Data/Polynomial/FieldDivision.lean", "Mathlib/RingTheory/Algebraic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "minpoly.degree_le_of_ne_zero", "code": "theorem degree_le_of_ne_zero {p : A[X]} (pnz : p \u2260 0) (hp : Polynomial.aeval x p = 0) :\n    degree (minpoly A x) \u2264 degree p", "start": [34, 1], "end": [42, 54], "kind": "commanddeclaration"}, {"full_name": "minpoly.ne_zero_of_finite", "code": "theorem ne_zero_of_finite (e : B) [FiniteDimensional A B] : minpoly A e \u2260 0", "start": [45, 1], "end": [46, 46], "kind": "commanddeclaration"}, {"full_name": "minpoly.unique", "code": "theorem unique {p : A[X]} (pmonic : p.Monic) (hp : Polynomial.aeval x p = 0)\n    (pmin : \u2200 q : A[X], q.Monic \u2192 Polynomial.aeval x q = 0 \u2192 degree p \u2264 degree q) :\n    p = minpoly A x", "start": [49, 1], "end": [63, 86], "kind": "commanddeclaration"}, {"full_name": "minpoly.dvd", "code": "theorem dvd {p : A[X]} (hp : Polynomial.aeval x p = 0) : minpoly A x \u2223 p", "start": [66, 1], "end": [80, 42], "kind": "commanddeclaration"}, {"full_name": "minpoly.dvd_map_of_isScalarTower", "code": "theorem dvd_map_of_isScalarTower (A K : Type*) {R : Type*} [CommRing A] [Field K] [CommRing R]\n    [Algebra A K] [Algebra A R] [Algebra K R] [IsScalarTower A K R] (x : R) :\n    minpoly K x \u2223 (minpoly A x).map (algebraMap A K)", "start": [83, 1], "end": [87, 43], "kind": "commanddeclaration"}, {"full_name": "minpoly.dvd_map_of_isScalarTower'", "code": "theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]\n    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]\n    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :\n    minpoly K (algebraMap S L s) \u2223 map (algebraMap R K) (minpoly R s)", "start": [90, 1], "end": [96, 68], "kind": "commanddeclaration"}, {"full_name": "minpoly.aeval_of_isScalarTower", "code": "theorem aeval_of_isScalarTower (R : Type*) {K T U : Type*} [CommRing R] [Field K] [CommRing T]\n    [Algebra R K] [Algebra K T] [Algebra R T] [IsScalarTower R K T] [CommSemiring U] [Algebra K U]\n    [Algebra R U] [IsScalarTower R K U] (x : T) (y : U)\n    (hy : Polynomial.aeval y (minpoly K x) = 0) : Polynomial.aeval y (minpoly R x) = 0", "start": [99, 1], "end": [106, 50], "kind": "commanddeclaration"}, {"full_name": "minpoly.eq_of_irreducible_of_monic", "code": "theorem eq_of_irreducible_of_monic [Nontrivial B] {p : A[X]} (hp1 : Irreducible p)\n    (hp2 : Polynomial.aeval x p = 0) (hp3 : p.Monic) : p = minpoly A x", "start": [111, 1], "end": [116, 96], "kind": "commanddeclaration"}, {"full_name": "minpoly.eq_of_irreducible", "code": "theorem eq_of_irreducible [Nontrivial B] {p : A[X]} (hp1 : Irreducible p)\n    (hp2 : Polynomial.aeval x p = 0) : p * C p.leadingCoeff\u207b\u00b9 = minpoly A x", "start": [119, 1], "end": [126, 77], "kind": "commanddeclaration"}, {"full_name": "minpoly.add_algebraMap", "code": "theorem add_algebraMap {B : Type*} [CommRing B] [Algebra A B] {x : B} (hx : IsIntegral A x)\n    (a : A) : minpoly A (x + algebraMap A B a) = (minpoly A x).comp (X - C a)", "start": [129, 1], "end": [140, 39], "kind": "commanddeclaration"}, {"full_name": "minpoly.sub_algebraMap", "code": "theorem sub_algebraMap {B : Type*} [CommRing B] [Algebra A B] {x : B} (hx : IsIntegral A x)\n    (a : A) : minpoly A (x - algebraMap A B a) = (minpoly A x).comp (X + C a)", "start": [143, 1], "end": [145, 54], "kind": "commanddeclaration"}, {"full_name": "minpoly.Fintype.subtypeProd", "code": "noncomputable def Fintype.subtypeProd {E : Type*} {X : Set E} (hX : X.Finite) {L : Type*}\n    (F : E \u2192 Multiset L) : Fintype (\u2200 x : X, { l : L // l \u2208 F x }) :=\n  @Pi.fintype _ _ _ (Finite.fintype hX) _", "start": [150, 1], "end": [153, 42], "kind": "commanddeclaration"}, {"full_name": "minpoly.rootsOfMinPolyPiType", "code": "def rootsOfMinPolyPiType (\u03c6 : E \u2192\u2090[F] K)\n    (x : range (FiniteDimensional.finBasis F E : _ \u2192 E)) :\n    { l : K // l \u2208 (minpoly F x.1).aroots K } :=\n  \u27e8\u03c6 x, by\n    rw [mem_roots_map (minpoly.ne_zero_of_finite F x.val),\n      \u2190 aeval_def, aeval_algHom_apply, minpoly.aeval, map_zero]\u27e9", "start": [161, 1], "end": [167, 65], "kind": "commanddeclaration"}, {"full_name": "minpoly.aux_inj_roots_of_min_poly", "code": "theorem aux_inj_roots_of_min_poly : Injective (rootsOfMinPolyPiType F E K)", "start": [170, 1], "end": [175, 35], "kind": "commanddeclaration"}, {"full_name": "minpoly.AlgHom.fintype", "code": "noncomputable instance AlgHom.fintype : Fintype (E \u2192\u2090[F] K) :=\n  @Fintype.ofInjective _ _\n    (Fintype.subtypeProd (finite_range (FiniteDimensional.finBasis F E)) fun e =>\n      (minpoly F e).aroots K)\n    _ (aux_inj_roots_of_min_poly F E K)", "start": [178, 1], "end": [184, 40], "kind": "commanddeclaration"}, {"full_name": "minpoly.eq_X_sub_C", "code": "theorem eq_X_sub_C (a : A) : minpoly A (algebraMap A B a) = X - C a", "start": [191, 1], "end": [194, 60], "kind": "commanddeclaration"}, {"full_name": "minpoly.eq_X_sub_C'", "code": "theorem eq_X_sub_C' (a : A) : minpoly A a = X - C a", "start": [198, 1], "end": [199, 17], "kind": "commanddeclaration"}, {"full_name": "minpoly.zero", "code": "@[simp]\ntheorem zero : minpoly A (0 : B) = X", "start": [205, 1], "end": [208, 100], "kind": "commanddeclaration"}, {"full_name": "minpoly.one", "code": "@[simp]\ntheorem one : minpoly A (1 : B) = X - 1", "start": [211, 1], "end": [214, 79], "kind": "commanddeclaration"}, {"full_name": "minpoly.prime", "code": "theorem prime (hx : IsIntegral A x) : Prime (minpoly A x)", "start": [225, 1], "end": [231, 40], "kind": "commanddeclaration"}, {"full_name": "minpoly.root", "code": "theorem root {x : B} (hx : IsIntegral A x) {y : A} (h : IsRoot (minpoly A x) y) :\n    algebraMap A B y = x", "start": [234, 1], "end": [242, 76], "kind": "commanddeclaration"}, {"full_name": "minpoly.coeff_zero_eq_zero", "code": "@[simp]\ntheorem coeff_zero_eq_zero (hx : IsIntegral A x) : coeff (minpoly A x) 0 = 0 \u2194 x = 0", "start": [245, 1], "end": [254, 9], "kind": "commanddeclaration"}, {"full_name": "minpoly.coeff_zero_ne_zero", "code": "theorem coeff_zero_ne_zero (hx : IsIntegral A x) (h : x \u2260 0) : coeff (minpoly A x) 0 \u2260 0", "start": [257, 1], "end": [260, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/QuotientNilpotent.lean", "imports": ["Mathlib/RingTheory/Ideal/QuotientOperations.lean", "Mathlib/RingTheory/Nilpotent.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ideal.isRadical_iff_quotient_reduced", "code": "theorem Ideal.isRadical_iff_quotient_reduced {R : Type*} [CommRing R] (I : Ideal R) :\n    I.IsRadical \u2194 IsReduced (R \u29f8 I)", "start": [15, 1], "end": [18, 94], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsNilpotent.induction_on", "code": "theorem Ideal.IsNilpotent.induction_on (hI : IsNilpotent I)\n    {P : \u2200 \u2983S : Type _\u2984 [CommRing S], \u2200 _I : Ideal S, Prop}\n    (h\u2081 : \u2200 \u2983S : Type _\u2984 [CommRing S], \u2200 I : Ideal S, I ^ 2 = \u22a5 \u2192 P I)\n    (h\u2082 : \u2200 \u2983S : Type _\u2984 [CommRing S], \u2200 I J : Ideal S, I \u2264 J \u2192 P I \u2192\n      P (J.map (Ideal.Quotient.mk I)) \u2192 P J) :\n    P I", "start": [24, 1], "end": [52, 50], "kind": "commanddeclaration"}, {"full_name": "IsNilpotent.isUnit_quotient_mk_iff", "code": "theorem IsNilpotent.isUnit_quotient_mk_iff {R : Type*} [CommRing R] {I : Ideal R}\n    (hI : IsNilpotent I) {x : R} : IsUnit (Ideal.Quotient.mk I x) \u2194 IsUnit x", "start": [55, 1], "end": [80, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/MvPolynomial/Tower.lean", "imports": ["Mathlib/Algebra/Algebra/Tower.lean", "Mathlib/Data/MvPolynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvPolynomial.aeval_map_algebraMap", "code": "theorem aeval_map_algebraMap (x : \u03c3 \u2192 B) (p : MvPolynomial \u03c3 R) :\n    aeval x (map (algebraMap R A) p) = aeval x p", "start": [38, 1], "end": [40, 74], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_algebraMap_apply", "code": "theorem aeval_algebraMap_apply (x : \u03c3 \u2192 A) (p : MvPolynomial \u03c3 R) :\n    aeval (algebraMap A B \u2218 x) p = algebraMap A B (MvPolynomial.aeval x p)", "start": [53, 1], "end": [58, 28], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_algebraMap_eq_zero_iff", "code": "theorem aeval_algebraMap_eq_zero_iff [NoZeroSMulDivisors A B] [Nontrivial B] (x : \u03c3 \u2192 A)\n    (p : MvPolynomial \u03c3 R) : aeval (algebraMap A B \u2218 x) p = 0 \u2194 aeval x p = 0", "start": [61, 1], "end": [64, 52], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_algebraMap_eq_zero_iff_of_injective", "code": "theorem aeval_algebraMap_eq_zero_iff_of_injective {x : \u03c3 \u2192 A} {p : MvPolynomial \u03c3 R}\n    (h : Function.Injective (algebraMap A B)) : aeval (algebraMap A B \u2218 x) p = 0 \u2194 aeval x p = 0", "start": [67, 1], "end": [69, 72], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mvPolynomial_aeval_coe", "code": "@[simp]\ntheorem mvPolynomial_aeval_coe (S : Subalgebra R A) (x : \u03c3 \u2192 S) (p : MvPolynomial \u03c3 R) :\n    aeval (fun i => (x i : A)) p = aeval x p", "start": [84, 1], "end": [86, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/CategoryTheory/Elementwise.lean", "imports": ["Mathlib/Util/AddRelatedDecl.lean", "Mathlib/CategoryTheory/ConcreteCategory/Basic.lean", "lake-packages/std/Std/Tactic/Lint.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Tactic.Elementwise.forall_congr_forget_Type", "code": "theorem forall_congr_forget_Type (\u03b1 : Type u) (p : \u03b1 \u2192 Prop) :\n    (\u2200 (x : (forget (Type u)).obj \u03b1), p x) \u2194 \u2200 (x : \u03b1), p x", "start": [45, 1], "end": [46, 71], "kind": "commanddeclaration"}, {"full_name": "Tactic.Elementwise.forget_hom_Type", "code": "theorem forget_hom_Type (\u03b1 \u03b2 : Type u) (f : \u03b1 \u27f6 \u03b2) : FunLike.coe f = f", "start": [50, 1], "end": [50, 78], "kind": "commanddeclaration"}, {"full_name": "Tactic.Elementwise.hom_elementwise", "code": "theorem hom_elementwise [Category C] [ConcreteCategory C]\n    {X Y : C} {f g : X \u27f6 Y} (h : f = g) (x : X) : f x = g x", "start": [52, 1], "end": [53, 73], "kind": "commanddeclaration"}, {"full_name": "Tactic.Elementwise.elementwiseThms", "code": "def elementwiseThms : List Name :=\n  [``CategoryTheory.coe_id, ``CategoryTheory.coe_comp, ``CategoryTheory.comp_apply,\n    ``CategoryTheory.id_apply,\n    ``forget_hom_Type, ``forall_congr_forget_Type,\n    ``implies_true]", "start": [57, 1], "end": [65, 20], "kind": "commanddeclaration"}, {"full_name": "Tactic.Elementwise.elementwiseExpr", "code": "def elementwiseExpr (src : Name) (type pf : Expr) (simpSides := true) :\n    MetaM (Expr \u00d7 Option Level) := do\n  let type := (\u2190 instantiateMVars type).cleanupAnnotations\n  forallTelescope type fun fvars type' => do\n    mkHomElementwise type' (mkAppN pf fvars) fun eqPf instConcr? => do\n      let mut eqPf' \u2190 simpType (simpOnlyNames elementwiseThms (config := { decide := false })) eqPf\n      if (\u2190 inferType eqPf') == .const ``True [] then\n        throwError \"elementwise lemma for {src} is trivial after applying ConcreteCategory {\"\"\n          }lemmas, which can be caused by how applications are unfolded. {\"\"\n          }Using elementwise is unnecessary.\"\n      if simpSides then\n        let ctx := { \u2190 Simp.Context.mkDefault with config.decide := false }\n        let (ty', eqPf'') \u2190 simpEq (fun e => return (\u2190 simp e ctx).1) (\u2190 inferType eqPf') eqPf'\n        forallTelescope ty' fun _ ty' => do\n          if let some (_, lhs, rhs) := ty'.eq? then\n            if \u2190 Std.Tactic.Lint.isSimpEq lhs rhs then\n              throwError \"applying simp to both sides reduces elementwise lemma for {src} {\"\"\n                }to the trivial equality {ty'}. {\"\"\n                }Either add `nosimp` or remove the `elementwise` attribute.\"\n        eqPf' \u2190 mkExpectedTypeHint eqPf'' ty'\n      if let some (w, instConcr) := instConcr? then\n        return (\u2190 Meta.mkLambdaFVars (fvars.push instConcr) eqPf', w)\n      else\n        return (\u2190 Meta.mkLambdaFVars fvars eqPf', none)\nwhere\n  \n  extractCatInstance (eqTy : Expr) : MetaM (Expr \u00d7 Expr) := do\n    let some (\u03b1, _, _) := eqTy.cleanupAnnotations.eq? | failure\n    let (``Quiver.Hom, #[_, instQuiv, _, _]) := \u03b1.getAppFnArgs | failure\n    let (``CategoryTheory.CategoryStruct.toQuiver, #[_, instCS]) := instQuiv.getAppFnArgs | failure\n    let (``CategoryTheory.Category.toCategoryStruct, #[C, instC]) := instCS.getAppFnArgs | failure\n    return (C, instC)\n  mkHomElementwise {\u03b1} (eqTy eqPf : Expr) (k : Expr \u2192 Option (Level \u00d7 Expr) \u2192 MetaM \u03b1) :\n      MetaM \u03b1 := do\n    let (C, instC) \u2190 try extractCatInstance eqTy catch _ =>\n      throwError \"elementwise expects equality of morphisms in a category\"\n    if let some eqPf' \u2190 observing? (mkAppM ``hom_elementwise #[eqPf]) then\n      k eqPf' none\n    else\n      let .app (.const ``Category [v, u]) _ \u2190 inferType instC\n        | throwError \"internal error in elementwise\"\n      let w \u2190 mkFreshLevelMVar\n      let cty : Expr := mkApp2 (.const ``ConcreteCategory [w, v, u]) C instC\n      withLocalDecl `inst .instImplicit cty fun cfvar => do\n        let eqPf' \u2190 mkAppM ``hom_elementwise #[eqPf]\n        k eqPf' (some (w, cfvar))", "start": [67, 1], "end": [130, 34], "kind": "commanddeclaration"}, {"full_name": "Tactic.Elementwise.mkUnusedName", "code": "private partial def mkUnusedName (names : List Name) (baseName : Name) : Name :=\n  if not (names.contains baseName) then\n    baseName\n  else\n    let rec loop (i : Nat := 0) : Name :=\n      let w := Name.appendIndexAfter baseName i\n      if names.contains w then\n        loop (i + 1)\n      else\n        w\n    loop 1", "start": [132, 1], "end": [143, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean", "imports": ["Mathlib/CategoryTheory/Limits/Preserves/Shapes/Zero.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.HasKernel", "code": "abbrev HasKernel {X Y : C} (f : X \u27f6 Y) : Prop :=\n  HasLimit (parallelPair f 0)", "start": [65, 1], "end": [67, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasCokernel", "code": "abbrev HasCokernel {X Y : C} (f : X \u27f6 Y) : Prop :=\n  HasColimit (parallelPair f 0)", "start": [70, 1], "end": [72, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.KernelFork", "code": "abbrev KernelFork :=\n  Fork f 0", "start": [79, 1], "end": [81, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.KernelFork.condition", "code": "@[reassoc (attr := simp)]\ntheorem KernelFork.condition (s : KernelFork f) : Fork.\u03b9 s \u226b f = 0", "start": [86, 1], "end": [88, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.KernelFork.app_one", "code": "theorem KernelFork.app_one (s : KernelFork f) : s.\u03c0.app one = 0", "start": [92, 1], "end": [93, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.KernelFork.of\u03b9", "code": "abbrev KernelFork.of\u03b9 {Z : C} (\u03b9 : Z \u27f6 X) (w : \u03b9 \u226b f = 0) : KernelFork f :=\n  Fork.of\u03b9 \u03b9 <| by rw [w, HasZeroMorphisms.comp_zero]", "start": [96, 1], "end": [98, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.KernelFork.\u03b9_of\u03b9", "code": "@[simp]\ntheorem KernelFork.\u03b9_of\u03b9 {X Y P : C} (f : X \u27f6 Y) (\u03b9 : P \u27f6 X) (w : \u03b9 \u226b f = 0) :\n    Fork.\u03b9 (KernelFork.of\u03b9 \u03b9 w) = \u03b9", "start": [101, 1], "end": [103, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isoOf\u03b9", "code": "def isoOf\u03b9 (s : Fork f 0) : s \u2245 Fork.of\u03b9 (Fork.\u03b9 s) (Fork.condition s) :=\n  Cones.ext (Iso.refl _) <| by rintro \u27e8j\u27e9 <;> simp", "start": [110, 1], "end": [112, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.of\u03b9Congr", "code": "def of\u03b9Congr {P : C} {\u03b9 \u03b9' : P \u27f6 X} {w : \u03b9 \u226b f = 0} (h : \u03b9 = \u03b9') :\n    KernelFork.of\u03b9 \u03b9 w \u2245 KernelFork.of\u03b9 \u03b9' (by rw [\u2190 h, w]) :=\n  Cones.ext (Iso.refl _)", "start": [115, 1], "end": [118, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.compNatIso", "code": "def compNatIso {D : Type u'} [Category.{v} D] [HasZeroMorphisms D] (F : C \u2964 D) [IsEquivalence F] :\n    parallelPair f 0 \u22d9 F \u2245 parallelPair (F.map f) 0 :=\n  let app (j :WalkingParallelPair) :\n      (parallelPair f 0 \u22d9 F).obj j \u2245 (parallelPair (F.map f) 0).obj j :=\n    match j with\n    | zero => Iso.refl _\n    | one => Iso.refl _\n  NatIso.ofComponents app <| by rintro \u27e8i\u27e9 \u27e8j\u27e9 <;> intro g <;> cases g <;> simp", "start": [121, 1], "end": [130, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.KernelFork.IsLimit.lift'", "code": "def KernelFork.IsLimit.lift' {s : KernelFork f} (hs : IsLimit s) {W : C} (k : W \u27f6 X)\n    (h : k \u226b f = 0) : { l : W \u27f6 s.pt // l \u226b Fork.\u03b9 s = k } :=\n  \u27e8hs.lift <| KernelFork.of\u03b9 _ h, hs.fac _ _\u27e9", "start": [135, 1], "end": [139, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitAux", "code": "def isLimitAux (t : KernelFork f) (lift : \u2200 s : KernelFork f, s.pt \u27f6 t.pt)\n    (fac : \u2200 s : KernelFork f, lift s \u226b t.\u03b9 = s.\u03b9)\n    (uniq : \u2200 (s : KernelFork f) (m : s.pt \u27f6 t.pt) (_ : m \u226b t.\u03b9 = s.\u03b9), m = lift s) : IsLimit t :=\n  { lift\n    fac := fun s j => by\n      cases j\n      \u00b7 exact fac s\n      \u00b7 simp\n    uniq := fun s m w => uniq s m (w Limits.WalkingParallelPair.zero) }", "start": [142, 1], "end": [152, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.KernelFork.IsLimit.of\u03b9", "code": "def KernelFork.IsLimit.of\u03b9 {W : C} (g : W \u27f6 X) (eq : g \u226b f = 0)\n    (lift : \u2200 {W' : C} (g' : W' \u27f6 X) (_ : g' \u226b f = 0), W' \u27f6 W)\n    (fac : \u2200 {W' : C} (g' : W' \u27f6 X) (eq' : g' \u226b f = 0), lift g' eq' \u226b g = g')\n    (uniq :\n      \u2200 {W' : C} (g' : W' \u27f6 X) (eq' : g' \u226b f = 0) (m : W' \u27f6 W) (_ : m \u226b g = g'), m = lift g' eq') :\n    IsLimit (KernelFork.of\u03b9 g eq) :=\n  isLimitAux _ (fun s => lift s.\u03b9 s.condition) (fun s => fac s.\u03b9 s.condition) fun s =>\n    uniq s.\u03b9 s.condition", "start": [155, 1], "end": [165, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isKernelCompMono", "code": "def isKernelCompMono {c : KernelFork f} (i : IsLimit c) {Z} (g : Y \u27f6 Z) [hg : Mono g] {h : X \u27f6 Z}\n    (hh : h = f \u226b g) : IsLimit (KernelFork.of\u03b9 c.\u03b9 (by simp [hh]) : KernelFork h) :=\n  Fork.IsLimit.mk' _ fun s =>\n    let s' : KernelFork f := Fork.of\u03b9 s.\u03b9 (by rw [\u2190 cancel_mono g]; simp [\u2190 hh, s.condition])\n    let l := KernelFork.IsLimit.lift' i s'.\u03b9 s'.condition\n    \u27e8l.1, l.2, fun hm => by\n      apply Fork.IsLimit.hom_ext i; rw [Fork.\u03b9_of\u03b9] at hm; rw [hm]; exact l.2.symm\u27e9", "start": [168, 1], "end": [175, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isKernelCompMono_lift", "code": "theorem isKernelCompMono_lift {c : KernelFork f} (i : IsLimit c) {Z} (g : Y \u27f6 Z) [hg : Mono g]\n    {h : X \u27f6 Z} (hh : h = f \u226b g) (s : KernelFork h) :\n    (isKernelCompMono i g hh).lift s = i.lift (Fork.of\u03b9 s.\u03b9 (by\n      rw [\u2190 cancel_mono g, Category.assoc, \u2190 hh]\n      simp))", "start": [178, 1], "end": [182, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isKernelOfComp", "code": "def isKernelOfComp {W : C} (g : Y \u27f6 W) (h : X \u27f6 W) {c : KernelFork h} (i : IsLimit c)\n    (hf : c.\u03b9 \u226b f = 0) (hfg : f \u226b g = h) : IsLimit (KernelFork.of\u03b9 c.\u03b9 hf) :=\n  Fork.IsLimit.mk _ (fun s => i.lift (KernelFork.of\u03b9 s.\u03b9 (by simp [\u2190 hfg])))\n    (fun s => by simp only [KernelFork.\u03b9_of\u03b9, Fork.IsLimit.lift_\u03b9]) fun s m h => by\n    apply Fork.IsLimit.hom_ext i; simpa using h", "start": [185, 1], "end": [190, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.KernelFork.IsLimit.ofId", "code": "def KernelFork.IsLimit.ofId {X Y : C} (f : X \u27f6 Y) (hf : f = 0) :\n    IsLimit (KernelFork.of\u03b9 (\ud835\udfd9 X) (show \ud835\udfd9 X \u226b f = 0 by rw [hf, comp_zero])) :=\n  KernelFork.IsLimit.of\u03b9 _ _ (fun x _ => x) (fun _ _ => Category.comp_id _)\n    (fun _ _ _ hb => by simp only [\u2190 hb, Category.comp_id])", "start": [193, 1], "end": [197, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.KernelFork.IsLimit.ofMonoOfIsZero", "code": "def KernelFork.IsLimit.ofMonoOfIsZero {X Y : C} {f : X \u27f6 Y} (c : KernelFork f)\n    (hf : Mono f) (h : IsZero c.pt) : IsLimit c :=\n  isLimitAux _ (fun s => 0) (fun s => by rw [zero_comp, \u2190 cancel_mono f, zero_comp, s.condition])\n    (fun _ _ _ => h.eq_of_tgt _ _)", "start": [199, 1], "end": [203, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.KernelFork.IsLimit.isIso_\u03b9", "code": "lemma KernelFork.IsLimit.isIso_\u03b9 {X Y : C} {f : X \u27f6 Y} (c : KernelFork f)\n    (hc : IsLimit c) (hf : f = 0) : IsIso c.\u03b9 := by\n  let e : c.pt \u2245 X := IsLimit.conePointUniqueUpToIso hc\n    (KernelFork.IsLimit.ofId (f : X \u27f6 Y) hf)\n  have eq : e.inv \u226b c.\u03b9 = \ud835\udfd9 X := Fork.IsLimit.lift_\u03b9 hc\n  haveI : IsIso (e.inv \u226b c.\u03b9) := by\n    rw [eq]\n    infer_instance\n  exact IsIso.of_isIso_comp_left e.inv c.\u03b9", "start": [205, 1], "end": [213, 43], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.kernel", "code": "abbrev kernel (f : X \u27f6 Y) [HasKernel f] : C :=\n  equalizer f 0", "start": [221, 1], "end": [223, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.\u03b9", "code": "abbrev kernel.\u03b9 : kernel f \u27f6 X :=\n  equalizer.\u03b9 f 0", "start": [226, 1], "end": [228, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.equalizer_as_kernel", "code": "@[simp]\ntheorem equalizer_as_kernel : equalizer.\u03b9 f 0 = kernel.\u03b9 f", "start": [231, 1], "end": [232, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.condition", "code": "@[reassoc (attr := simp)]\ntheorem kernel.condition : kernel.\u03b9 f \u226b f = 0", "start": [235, 1], "end": [237, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernelIsKernel", "code": "def kernelIsKernel : IsLimit (Fork.of\u03b9 (kernel.\u03b9 f) ((kernel.condition f).trans comp_zero.symm)) :=\n  IsLimit.ofIsoLimit (limit.isLimit _) (Fork.ext (Iso.refl _) (by aesop_cat))", "start": [240, 1], "end": [242, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.lift", "code": "abbrev kernel.lift {W : C} (k : W \u27f6 X) (h : k \u226b f = 0) : W \u27f6 kernel f :=\n  (kernelIsKernel f).lift (KernelFork.of\u03b9 k h)", "start": [245, 1], "end": [248, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.lift_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem kernel.lift_\u03b9 {W : C} (k : W \u27f6 X) (h : k \u226b f = 0) : kernel.lift f k h \u226b kernel.\u03b9 f = k", "start": [251, 1], "end": [253, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.lift_zero", "code": "@[simp]\ntheorem kernel.lift_zero {W : C} {h} : kernel.lift f (0 : W \u27f6 X) h = 0", "start": [256, 1], "end": [258, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.lift_mono", "code": "instance kernel.lift_mono {W : C} (k : W \u27f6 X) (h : k \u226b f = 0) [Mono k] : Mono (kernel.lift f k h) :=\n  \u27e8fun {Z} g g' w => by\n    replace w := w =\u226b kernel.\u03b9 f\n    simp only [Category.assoc, kernel.lift_\u03b9] at w\n    exact (cancel_mono k).1 w\u27e9", "start": [261, 1], "end": [265, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.lift'", "code": "def kernel.lift' {W : C} (k : W \u27f6 X) (h : k \u226b f = 0) : { l : W \u27f6 kernel f // l \u226b kernel.\u03b9 f = k } :=\n  \u27e8kernel.lift f k h, kernel.lift_\u03b9 _ _ _\u27e9", "start": [268, 1], "end": [271, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.map", "code": "abbrev kernel.map {X' Y' : C} (f' : X' \u27f6 Y') [HasKernel f'] (p : X \u27f6 X') (q : Y \u27f6 Y')\n    (w : f \u226b q = p \u226b f') : kernel f \u27f6 kernel f' :=\n  kernel.lift f' (kernel.\u03b9 f \u226b p) (by simp [\u2190 w])", "start": [274, 1], "end": [277, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.lift_map", "code": "theorem kernel.lift_map {X Y Z X' Y' Z' : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [HasKernel g] (w : f \u226b g = 0)\n    (f' : X' \u27f6 Y') (g' : Y' \u27f6 Z') [HasKernel g'] (w' : f' \u226b g' = 0) (p : X \u27f6 X') (q : Y \u27f6 Y')\n    (r : Z \u27f6 Z') (h\u2081 : f \u226b q = p \u226b f') (h\u2082 : g \u226b r = q \u226b g') :\n    kernel.lift g f w \u226b kernel.map g g' q r h\u2082 = p \u226b kernel.lift g' f' w'", "start": [280, 1], "end": [299, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.mapIso", "code": "@[simps]\ndef kernel.mapIso {X' Y' : C} (f' : X' \u27f6 Y') [HasKernel f'] (p : X \u2245 X') (q : Y \u2245 Y')\n    (w : f \u226b q.hom = p.hom \u226b f') : kernel f \u2245 kernel f' where\n  hom := kernel.map f f' p.hom q.hom w\n  inv :=\n    kernel.map f' f p.inv q.inv\n      (by\n        refine' (cancel_mono q.hom).1 _\n        simp [w])", "start": [302, 1], "end": [311, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.\u03b9_zero_isIso", "code": "instance kernel.\u03b9_zero_isIso : IsIso (kernel.\u03b9 (0 : X \u27f6 Y)) :=\n  equalizer.\u03b9_of_self _", "start": [314, 1], "end": [316, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.eq_zero_of_epi_kernel", "code": "theorem eq_zero_of_epi_kernel [Epi (kernel.\u03b9 f)] : f = 0", "start": [319, 1], "end": [320, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernelZeroIsoSource", "code": "def kernelZeroIsoSource : kernel (0 : X \u27f6 Y) \u2245 X :=\n  equalizer.isoSourceOfSelf 0", "start": [323, 1], "end": [325, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernelZeroIsoSource_hom", "code": "@[simp]\ntheorem kernelZeroIsoSource_hom : kernelZeroIsoSource.hom = kernel.\u03b9 (0 : X \u27f6 Y)", "start": [328, 1], "end": [329, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernelZeroIsoSource_inv", "code": "@[simp]\ntheorem kernelZeroIsoSource_inv :\n    kernelZeroIsoSource.inv = kernel.lift (0 : X \u27f6 Y) (\ud835\udfd9 X) (by simp)", "start": [332, 1], "end": [336, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernelIsoOfEq", "code": "def kernelIsoOfEq {f g : X \u27f6 Y} [HasKernel f] [HasKernel g] (h : f = g) : kernel f \u2245 kernel g :=\n  HasLimit.isoOfNatIso (by rw [h])", "start": [339, 1], "end": [341, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernelIsoOfEq_refl", "code": "@[simp]\ntheorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f)", "start": [344, 1], "end": [347, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernelIsoOfEq_hom_comp_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem kernelIsoOfEq_hom_comp_\u03b9 {f g : X \u27f6 Y} [HasKernel f] [HasKernel g] (h : f = g) :\n    (kernelIsoOfEq h).hom \u226b kernel.\u03b9 g = kernel.\u03b9 f", "start": [351, 1], "end": [354, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernelIsoOfEq_inv_comp_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem kernelIsoOfEq_inv_comp_\u03b9 {f g : X \u27f6 Y} [HasKernel f] [HasKernel g] (h : f = g) :\n    (kernelIsoOfEq h).inv \u226b kernel.\u03b9 _ = kernel.\u03b9 _", "start": [357, 1], "end": [360, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.lift_comp_kernelIsoOfEq_hom", "code": "@[reassoc (attr := simp)]\ntheorem lift_comp_kernelIsoOfEq_hom {Z} {f g : X \u27f6 Y} [HasKernel f] [HasKernel g] (h : f = g)\n    (e : Z \u27f6 X) (he) :\n    kernel.lift _ e he \u226b (kernelIsoOfEq h).hom = kernel.lift _ e (by simp [\u2190 h, he])", "start": [363, 1], "end": [367, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.lift_comp_kernelIsoOfEq_inv", "code": "@[reassoc (attr := simp)]\ntheorem lift_comp_kernelIsoOfEq_inv {Z} {f g : X \u27f6 Y} [HasKernel f] [HasKernel g] (h : f = g)\n    (e : Z \u27f6 X) (he) :\n    kernel.lift _ e he \u226b (kernelIsoOfEq h).inv = kernel.lift _ e (by simp [h, he])", "start": [370, 1], "end": [374, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernelIsoOfEq_trans", "code": "@[simp]\ntheorem kernelIsoOfEq_trans {f g h : X \u27f6 Y} [HasKernel f] [HasKernel g] [HasKernel h] (w\u2081 : f = g)\n    (w\u2082 : g = h) : kernelIsoOfEq w\u2081 \u226a\u226b kernelIsoOfEq w\u2082 = kernelIsoOfEq (w\u2081.trans w\u2082)", "start": [377, 1], "end": [380, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel_not_epi_of_nonzero", "code": "theorem kernel_not_epi_of_nonzero (w : f \u2260 0) : \u00acEpi (kernel.\u03b9 f)", "start": [385, 1], "end": [386, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel_not_iso_of_nonzero", "code": "theorem kernel_not_iso_of_nonzero (w : f \u2260 0) : IsIso (kernel.\u03b9 f) \u2192 False", "start": [389, 1], "end": [392, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasKernel_comp_mono", "code": "instance hasKernel_comp_mono {X Y Z : C} (f : X \u27f6 Y) [HasKernel f] (g : Y \u27f6 Z) [Mono g] :\n    HasKernel (f \u226b g) :=\n  \u27e8\u27e8{   cone := _\n        isLimit := isKernelCompMono (limit.isLimit _) g rfl }\u27e9\u27e9", "start": [395, 1], "end": [398, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernelCompMono", "code": "@[simps]\ndef kernelCompMono {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [HasKernel f] [Mono g] :\n    kernel (f \u226b g) \u2245 kernel f where\n  hom :=\n    kernel.lift _ (kernel.\u03b9 _)\n      (by\n        rw [\u2190 cancel_mono g]\n        simp)\n  inv := kernel.lift _ (kernel.\u03b9 _) (by simp)", "start": [401, 1], "end": [411, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasKernel_iso_comp", "code": "instance hasKernel_iso_comp {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [IsIso f] [HasKernel g] :\n    HasKernel (f \u226b g) where\n  exists_limit :=\n    \u27e8{  cone := KernelFork.of\u03b9 (kernel.\u03b9 g \u226b inv f) (by simp)\n        isLimit := isLimitAux _ (fun s => kernel.lift _ (s.\u03b9 \u226b f) (by aesop_cat))\n            (by aesop_cat) fun s m w => by\n          simp_rw [\u2190 w]\n          apply equalizer.hom_ext\n          simp }\u27e9", "start": [414, 1], "end": [422, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernelIsIsoComp", "code": "@[simps]\ndef kernelIsIsoComp {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [IsIso f] [HasKernel g] :\n    kernel (f \u226b g) \u2245 kernel g where\n  hom := kernel.lift _ (kernel.\u03b9 _ \u226b f) (by simp)\n  inv := kernel.lift _ (kernel.\u03b9 _ \u226b inv f) (by simp)", "start": [425, 1], "end": [431, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.zeroKernelFork", "code": "def kernel.zeroKernelFork : KernelFork f where\n  pt := 0\n  \u03c0 := { app := fun j => 0 }", "start": [442, 1], "end": [445, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.isLimitConeZeroCone", "code": "def kernel.isLimitConeZeroCone [Mono f] : IsLimit (kernel.zeroKernelFork f) :=\n  Fork.IsLimit.mk _ (fun s => 0)\n    (fun s => by\n      erw [zero_comp]\n      refine (zero_of_comp_mono f ?_).symm\n      exact KernelFork.condition _)\n    fun _ _ _ => zero_of_to_zero _", "start": [448, 1], "end": [455, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.ofMono", "code": "def kernel.ofMono [HasKernel f] [Mono f] : kernel f \u2245 0 :=\n  Functor.mapIso (Cones.forget _) <|\n    IsLimit.uniqueUpToIso (limit.isLimit (parallelPair f 0)) (kernel.isLimitConeZeroCone f)", "start": [458, 1], "end": [461, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.\u03b9_of_mono", "code": "theorem kernel.\u03b9_of_mono [HasKernel f] [Mono f] : kernel.\u03b9 f = 0", "start": [464, 1], "end": [466, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.zeroKernelOfCancelZero", "code": "def zeroKernelOfCancelZero {X Y : C} (f : X \u27f6 Y)\n    (hf : \u2200 (Z : C) (g : Z \u27f6 X) (_ : g \u226b f = 0), g = 0) :\n    IsLimit (KernelFork.of\u03b9 (0 : 0 \u27f6 X) (show 0 \u226b f = 0 by simp)) :=\n  Fork.IsLimit.mk _ (fun s => 0) (fun s => by rw [hf _ _ (KernelFork.condition s), zero_comp])\n    fun s m _ => by dsimp; apply HasZeroObject.to_zero_ext", "start": [469, 1], "end": [474, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsKernel.ofCompIso", "code": "def IsKernel.ofCompIso {Z : C} (l : X \u27f6 Z) (i : Z \u2245 Y) (h : l \u226b i.hom = f) {s : KernelFork f}\n    (hs : IsLimit s) :\n    IsLimit\n      (KernelFork.of\u03b9 (Fork.\u03b9 s) <| show Fork.\u03b9 s \u226b l = 0 by simp [\u2190 i.comp_inv_eq.2 h.symm]) :=\n  Fork.IsLimit.mk _ (fun s => hs.lift <| KernelFork.of\u03b9 (Fork.\u03b9 s) <| by simp [\u2190 h])\n    (fun s => by simp) fun s m h => by\n      apply Fork.IsLimit.hom_ext hs\n      simpa using h", "start": [481, 1], "end": [489, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.ofCompIso", "code": "def kernel.ofCompIso [HasKernel f] {Z : C} (l : X \u27f6 Z) (i : Z \u2245 Y) (h : l \u226b i.hom = f) :\n    IsLimit\n      (KernelFork.of\u03b9 (kernel.\u03b9 f) <| show kernel.\u03b9 f \u226b l = 0 by simp [\u2190 i.comp_inv_eq.2 h.symm]) :=\n  IsKernel.ofCompIso f l i h <| limit.isLimit _", "start": [492, 1], "end": [496, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsKernel.isoKernel", "code": "def IsKernel.isoKernel {Z : C} (l : Z \u27f6 X) {s : KernelFork f} (hs : IsLimit s) (i : Z \u2245 s.pt)\n    (h : i.hom \u226b Fork.\u03b9 s = l) : IsLimit (KernelFork.of\u03b9 l <| show l \u226b f = 0 by simp [\u2190 h]) :=\n  IsLimit.ofIsoLimit hs <|\n    Cones.ext i.symm fun j => by\n      cases j\n      \u00b7 exact (Iso.eq_inv_comp i).2 h\n      \u00b7 dsimp; rw[\u2190h]; simp", "start": [499, 1], "end": [507, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.isoKernel", "code": "def kernel.isoKernel [HasKernel f] {Z : C} (l : Z \u27f6 X) (i : Z \u2245 kernel f)\n    (h : i.hom \u226b kernel.\u03b9 f = l) :\n    IsLimit (@KernelFork.of\u03b9 _ _ _ _ _ f _ l <| by simp [\u2190 h]) :=\n  IsKernel.isoKernel f l (limit.isLimit _) i h", "start": [510, 1], "end": [514, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.\u03b9_of_zero", "code": "theorem kernel.\u03b9_of_zero : IsIso (kernel.\u03b9 (0 : X \u27f6 Y))", "start": [523, 1], "end": [525, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork", "code": "abbrev CokernelCofork :=\n  Cofork f 0", "start": [532, 1], "end": [534, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.condition", "code": "@[reassoc (attr := simp)]\ntheorem CokernelCofork.condition (s : CokernelCofork f) : f \u226b s.\u03c0 = 0", "start": [539, 1], "end": [541, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.\u03c0_eq_zero", "code": "theorem CokernelCofork.\u03c0_eq_zero (s : CokernelCofork f) : s.\u03b9.app zero = 0", "start": [545, 1], "end": [546, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.of\u03c0", "code": "abbrev CokernelCofork.of\u03c0 {Z : C} (\u03c0 : Y \u27f6 Z) (w : f \u226b \u03c0 = 0) : CokernelCofork f :=\n  Cofork.of\u03c0 \u03c0 <| by rw [w, zero_comp]", "start": [549, 1], "end": [551, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.\u03c0_of\u03c0", "code": "@[simp]\ntheorem CokernelCofork.\u03c0_of\u03c0 {X Y P : C} (f : X \u27f6 Y) (\u03c0 : Y \u27f6 P) (w : f \u226b \u03c0 = 0) :\n    Cofork.\u03c0 (CokernelCofork.of\u03c0 \u03c0 w) = \u03c0", "start": [554, 1], "end": [557, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isoOf\u03c0", "code": "def isoOf\u03c0 (s : Cofork f 0) : s \u2245 Cofork.of\u03c0 (Cofork.\u03c0 s) (Cofork.condition s) :=\n  Cocones.ext (Iso.refl _) fun j => by cases j <;> aesop_cat", "start": [560, 1], "end": [562, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.of\u03c0Congr", "code": "def of\u03c0Congr {P : C} {\u03c0 \u03c0' : Y \u27f6 P} {w : f \u226b \u03c0 = 0} (h : \u03c0 = \u03c0') :\n    CokernelCofork.of\u03c0 \u03c0 w \u2245 CokernelCofork.of\u03c0 \u03c0' (by rw [\u2190 h, w]) :=\n  Cocones.ext (Iso.refl _) fun j => by cases j <;> aesop_cat", "start": [565, 1], "end": [568, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.IsColimit.desc'", "code": "def CokernelCofork.IsColimit.desc' {s : CokernelCofork f} (hs : IsColimit s) {W : C} (k : Y \u27f6 W)\n    (h : f \u226b k = 0) : { l : s.pt \u27f6 W // Cofork.\u03c0 s \u226b l = k } :=\n  \u27e8hs.desc <| CokernelCofork.of\u03c0 _ h, hs.fac _ _\u27e9", "start": [571, 1], "end": [575, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitAux", "code": "def isColimitAux (t : CokernelCofork f) (desc : \u2200 s : CokernelCofork f, t.pt \u27f6 s.pt)\n    (fac : \u2200 s : CokernelCofork f, t.\u03c0 \u226b desc s = s.\u03c0)\n    (uniq : \u2200 (s : CokernelCofork f) (m : t.pt \u27f6 s.pt) (_ : t.\u03c0 \u226b m = s.\u03c0), m = desc s) :\n    IsColimit t :=\n  { desc\n    fac := fun s j => by\n      cases j\n      \u00b7 simp\n      \u00b7 exact fac s\n    uniq := fun s m w => uniq s m (w Limits.WalkingParallelPair.one) }", "start": [578, 1], "end": [589, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.IsColimit.of\u03c0", "code": "def CokernelCofork.IsColimit.of\u03c0 {Z : C} (g : Y \u27f6 Z) (eq : f \u226b g = 0)\n    (desc : \u2200 {Z' : C} (g' : Y \u27f6 Z') (_ : f \u226b g' = 0), Z \u27f6 Z')\n    (fac : \u2200 {Z' : C} (g' : Y \u27f6 Z') (eq' : f \u226b g' = 0), g \u226b desc g' eq' = g')\n    (uniq :\n      \u2200 {Z' : C} (g' : Y \u27f6 Z') (eq' : f \u226b g' = 0) (m : Z \u27f6 Z') (_ : g \u226b m = g'), m = desc g' eq') :\n    IsColimit (CokernelCofork.of\u03c0 g eq) :=\n  isColimitAux _ (fun s => desc s.\u03c0 s.condition) (fun s => fac s.\u03c0 s.condition) fun s =>\n    uniq s.\u03c0 s.condition", "start": [592, 1], "end": [602, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isCokernelEpiComp", "code": "def isCokernelEpiComp {c : CokernelCofork f} (i : IsColimit c) {W} (g : W \u27f6 X) [hg : Epi g]\n    {h : W \u27f6 Y} (hh : h = g \u226b f) :\n    IsColimit (CokernelCofork.of\u03c0 c.\u03c0 (by rw [hh]; simp) : CokernelCofork h) :=\n  Cofork.IsColimit.mk' _ fun s =>\n    let s' : CokernelCofork f :=\n      Cofork.of\u03c0 s.\u03c0\n        (by\n          apply hg.left_cancellation\n          rw [\u2190 Category.assoc, \u2190 hh, s.condition]\n          simp)\n    let l := CokernelCofork.IsColimit.desc' i s'.\u03c0 s'.condition\n    \u27e8l.1, l.2, fun hm => by\n      apply Cofork.IsColimit.hom_ext i; rw [Cofork.\u03c0_of\u03c0] at hm; rw [hm]; exact l.2.symm\u27e9", "start": [605, 1], "end": [618, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isCokernelEpiComp_desc", "code": "@[simp]\ntheorem isCokernelEpiComp_desc {c : CokernelCofork f} (i : IsColimit c) {W} (g : W \u27f6 X) [hg : Epi g]\n    {h : W \u27f6 Y} (hh : h = g \u226b f) (s : CokernelCofork h) :\n    (isCokernelEpiComp i g hh).desc s =\n      i.desc\n        (Cofork.of\u03c0 s.\u03c0\n          (by\n            rw [\u2190 cancel_epi g, \u2190 Category.assoc, \u2190 hh]\n            simp))", "start": [621, 1], "end": [630, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isCokernelOfComp", "code": "def isCokernelOfComp {W : C} (g : W \u27f6 X) (h : W \u27f6 Y) {c : CokernelCofork h} (i : IsColimit c)\n    (hf : f \u226b c.\u03c0 = 0) (hfg : g \u226b f = h) : IsColimit (CokernelCofork.of\u03c0 c.\u03c0 hf) :=\n  Cofork.IsColimit.mk _ (fun s => i.desc (CokernelCofork.of\u03c0 s.\u03c0 (by simp [\u2190 hfg])))\n    (fun s => by simp only [CokernelCofork.\u03c0_of\u03c0, Cofork.IsColimit.\u03c0_desc]) fun s m h => by\n      apply Cofork.IsColimit.hom_ext i\n      simpa using h", "start": [633, 1], "end": [639, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.IsColimit.ofId", "code": "def CokernelCofork.IsColimit.ofId {X Y : C} (f : X \u27f6 Y) (hf : f = 0) :\n    IsColimit (CokernelCofork.of\u03c0 (\ud835\udfd9 Y) (show f \u226b \ud835\udfd9 Y = 0 by rw [hf, zero_comp])) :=\n  CokernelCofork.IsColimit.of\u03c0 _ _ (fun x _ => x) (fun _ _ => Category.id_comp _)\n    (fun _ _ _ hb => by simp only [\u2190 hb, Category.id_comp])", "start": [642, 1], "end": [646, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.IsColimit.ofEpiOfIsZero", "code": "def CokernelCofork.IsColimit.ofEpiOfIsZero {X Y : C} {f : X \u27f6 Y} (c : CokernelCofork f)\n    (hf : Epi f) (h : IsZero c.pt) : IsColimit c :=\n  isColimitAux _ (fun s => 0) (fun s => by rw [comp_zero, \u2190 cancel_epi f, comp_zero, s.condition])\n    (fun _ _ _ => h.eq_of_src _ _)", "start": [648, 1], "end": [652, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.IsColimit.isIso_\u03c0", "code": "lemma CokernelCofork.IsColimit.isIso_\u03c0 {X Y : C} {f : X \u27f6 Y} (c : CokernelCofork f)\n    (hc : IsColimit c) (hf : f = 0) : IsIso c.\u03c0 := by\n  let e : c.pt \u2245 Y := IsColimit.coconePointUniqueUpToIso hc\n    (CokernelCofork.IsColimit.ofId (f : X \u27f6 Y) hf)\n  have eq : c.\u03c0 \u226b e.hom = \ud835\udfd9 Y := Cofork.IsColimit.\u03c0_desc hc\n  haveI : IsIso (c.\u03c0 \u226b e.hom) := by\n    rw [eq]\n    dsimp\n    infer_instance\n  exact IsIso.of_isIso_comp_right c.\u03c0 e.hom", "start": [654, 1], "end": [663, 44], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.cokernel", "code": "abbrev cokernel : C :=\n  coequalizer f 0", "start": [671, 1], "end": [673, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.\u03c0", "code": "abbrev cokernel.\u03c0 : Y \u27f6 cokernel f :=\n  coequalizer.\u03c0 f 0", "start": [676, 1], "end": [678, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coequalizer_as_cokernel", "code": "@[simp]\ntheorem coequalizer_as_cokernel : coequalizer.\u03c0 f 0 = cokernel.\u03c0 f", "start": [681, 1], "end": [683, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.condition", "code": "@[reassoc (attr := simp)]\ntheorem cokernel.condition : f \u226b cokernel.\u03c0 f = 0", "start": [686, 1], "end": [688, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernelIsCokernel", "code": "def cokernelIsCokernel :\n    IsColimit (Cofork.of\u03c0 (cokernel.\u03c0 f) ((cokernel.condition f).trans zero_comp.symm)) :=\n  IsColimit.ofIsoColimit (colimit.isColimit _) (Cofork.ext (Iso.refl _))", "start": [691, 1], "end": [694, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.desc", "code": "abbrev cokernel.desc {W : C} (k : Y \u27f6 W) (h : f \u226b k = 0) : cokernel f \u27f6 W :=\n  (cokernelIsCokernel f).desc (CokernelCofork.of\u03c0 k h)", "start": [697, 1], "end": [700, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.\u03c0_desc", "code": "@[reassoc (attr := simp)]\ntheorem cokernel.\u03c0_desc {W : C} (k : Y \u27f6 W) (h : f \u226b k = 0) :\n    cokernel.\u03c0 f \u226b cokernel.desc f k h = k", "start": [703, 1], "end": [706, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit_\u03b9_zero_cokernel_desc", "code": "@[reassoc (attr := simp)]\nlemma colimit_\u03b9_zero_cokernel_desc {C : Type*} [Category C]\n    [HasZeroMorphisms C] {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) (h : f \u226b g = 0) [HasCokernel f]:\n    colimit.\u03b9 (parallelPair f 0) WalkingParallelPair.zero \u226b cokernel.desc f g h = 0 := by\n  rw [(colimit.w (parallelPair f 0) WalkingParallelPairHom.left).symm]\n  aesop_cat", "start": [710, 1], "end": [715, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.cokernel.desc_zero", "code": "@[simp]\ntheorem cokernel.desc_zero {W : C} {h} : cokernel.desc f (0 : Y \u27f6 W) h = 0", "start": [717, 1], "end": [719, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.desc_epi", "code": "instance cokernel.desc_epi {W : C} (k : Y \u27f6 W) (h : f \u226b k = 0) [Epi k] :\n    Epi (cokernel.desc f k h) :=\n  \u27e8fun {Z} g g' w => by\n    replace w := cokernel.\u03c0 f \u226b= w\n    simp only [cokernel.\u03c0_desc_assoc] at w\n    exact (cancel_epi k).1 w\u27e9", "start": [722, 1], "end": [727, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.desc'", "code": "def cokernel.desc' {W : C} (k : Y \u27f6 W) (h : f \u226b k = 0) :\n    { l : cokernel f \u27f6 W // cokernel.\u03c0 f \u226b l = k } :=\n  \u27e8cokernel.desc f k h, cokernel.\u03c0_desc _ _ _\u27e9", "start": [730, 1], "end": [734, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.map", "code": "abbrev cokernel.map {X' Y' : C} (f' : X' \u27f6 Y') [HasCokernel f'] (p : X \u27f6 X') (q : Y \u27f6 Y')\n    (w : f \u226b q = p \u226b f') : cokernel f \u27f6 cokernel f' :=\n  cokernel.desc f (q \u226b cokernel.\u03c0 f') (by\n    have : f \u226b q \u226b \u03c0 f' = p \u226b f' \u226b \u03c0 f' := by\n      simp only [\u2190Category.assoc]\n      apply congrArg (\u00b7 \u226b \u03c0 f') w\n    simp [this])", "start": [737, 1], "end": [744, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.map_desc", "code": "theorem cokernel.map_desc {X Y Z X' Y' Z' : C} (f : X \u27f6 Y) [HasCokernel f] (g : Y \u27f6 Z)\n    (w : f \u226b g = 0) (f' : X' \u27f6 Y') [HasCokernel f'] (g' : Y' \u27f6 Z') (w' : f' \u226b g' = 0) (p : X \u27f6 X')\n    (q : Y \u27f6 Y') (r : Z \u27f6 Z') (h\u2081 : f \u226b q = p \u226b f') (h\u2082 : g \u226b r = q \u226b g') :\n    cokernel.map f f' p q h\u2081 \u226b cokernel.desc f' g' w' = cokernel.desc f g w \u226b r", "start": [747, 1], "end": [766, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.mapIso", "code": "@[simps]\ndef cokernel.mapIso {X' Y' : C} (f' : X' \u27f6 Y') [HasCokernel f'] (p : X \u2245 X') (q : Y \u2245 Y')\n    (w : f \u226b q.hom = p.hom \u226b f') : cokernel f \u2245 cokernel f' where\n  hom := cokernel.map f f' p.hom q.hom w\n  inv := cokernel.map f' f p.inv q.inv (by\n          refine' (cancel_mono q.hom).1 _\n          simp [w])", "start": [769, 1], "end": [776, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.\u03c0_zero_isIso", "code": "instance cokernel.\u03c0_zero_isIso : IsIso (cokernel.\u03c0 (0 : X \u27f6 Y)) :=\n  coequalizer.\u03c0_of_self _", "start": [779, 1], "end": [781, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.eq_zero_of_mono_cokernel", "code": "theorem eq_zero_of_mono_cokernel [Mono (cokernel.\u03c0 f)] : f = 0", "start": [784, 1], "end": [785, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernelZeroIsoTarget", "code": "def cokernelZeroIsoTarget : cokernel (0 : X \u27f6 Y) \u2245 Y :=\n  coequalizer.isoTargetOfSelf 0", "start": [788, 1], "end": [790, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernelZeroIsoTarget_hom", "code": "@[simp]\ntheorem cokernelZeroIsoTarget_hom :\n    cokernelZeroIsoTarget.hom = cokernel.desc (0 : X \u27f6 Y) (\ud835\udfd9 Y) (by simp)", "start": [793, 1], "end": [796, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernelZeroIsoTarget_inv", "code": "@[simp]\ntheorem cokernelZeroIsoTarget_inv : cokernelZeroIsoTarget.inv = cokernel.\u03c0 (0 : X \u27f6 Y)", "start": [799, 1], "end": [801, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernelIsoOfEq", "code": "def cokernelIsoOfEq {f g : X \u27f6 Y} [HasCokernel f] [HasCokernel g] (h : f = g) :\n    cokernel f \u2245 cokernel g :=\n  HasColimit.isoOfNatIso (by simp [h]; rfl)", "start": [804, 1], "end": [807, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernelIsoOfEq_refl", "code": "@[simp]\ntheorem cokernelIsoOfEq_refl {h : f = f} : cokernelIsoOfEq h = Iso.refl (cokernel f)", "start": [810, 1], "end": [812, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.\u03c0_comp_cokernelIsoOfEq_hom", "code": "@[reassoc (attr := simp)]\ntheorem \u03c0_comp_cokernelIsoOfEq_hom {f g : X \u27f6 Y} [HasCokernel f] [HasCokernel g] (h : f = g) :\n    cokernel.\u03c0 f \u226b (cokernelIsoOfEq h).hom = cokernel.\u03c0 g", "start": [815, 1], "end": [818, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.\u03c0_comp_cokernelIsoOfEq_inv", "code": "@[reassoc (attr := simp)]\ntheorem \u03c0_comp_cokernelIsoOfEq_inv {f g : X \u27f6 Y} [HasCokernel f] [HasCokernel g] (h : f = g) :\n    cokernel.\u03c0 _ \u226b (cokernelIsoOfEq h).inv = cokernel.\u03c0 _", "start": [821, 1], "end": [824, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernelIsoOfEq_hom_comp_desc", "code": "@[reassoc (attr := simp)]\ntheorem cokernelIsoOfEq_hom_comp_desc {Z} {f g : X \u27f6 Y} [HasCokernel f] [HasCokernel g] (h : f = g)\n    (e : Y \u27f6 Z) (he) :\n    (cokernelIsoOfEq h).hom \u226b cokernel.desc _ e he = cokernel.desc _ e (by simp [h, he])", "start": [827, 1], "end": [831, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernelIsoOfEq_inv_comp_desc", "code": "@[reassoc (attr := simp)]\ntheorem cokernelIsoOfEq_inv_comp_desc {Z} {f g : X \u27f6 Y} [HasCokernel f] [HasCokernel g] (h : f = g)\n    (e : Y \u27f6 Z) (he) :\n    (cokernelIsoOfEq h).inv \u226b cokernel.desc _ e he = cokernel.desc _ e (by simp [\u2190 h, he])", "start": [834, 1], "end": [838, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernelIsoOfEq_trans", "code": "@[simp]\ntheorem cokernelIsoOfEq_trans {f g h : X \u27f6 Y} [HasCokernel f] [HasCokernel g] [HasCokernel h]\n    (w\u2081 : f = g) (w\u2082 : g = h) :\n    cokernelIsoOfEq w\u2081 \u226a\u226b cokernelIsoOfEq w\u2082 = cokernelIsoOfEq (w\u2081.trans w\u2082)", "start": [841, 1], "end": [845, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel_not_mono_of_nonzero", "code": "theorem cokernel_not_mono_of_nonzero (w : f \u2260 0) : \u00acMono (cokernel.\u03c0 f)", "start": [850, 1], "end": [851, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel_not_iso_of_nonzero", "code": "theorem cokernel_not_iso_of_nonzero (w : f \u2260 0) : IsIso (cokernel.\u03c0 f) \u2192 False", "start": [854, 1], "end": [857, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCokernel_comp_iso", "code": "instance hasCokernel_comp_iso {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [HasCokernel f] [IsIso g] :\n    HasCokernel (f \u226b g) where\n  exists_colimit :=\n    \u27e8{  cocone := CokernelCofork.of\u03c0 (inv g \u226b cokernel.\u03c0 f) (by simp)\n        isColimit :=\n          isColimitAux _\n            (fun s =>\n              cokernel.desc _ (g \u226b s.\u03c0) (by rw [\u2190 Category.assoc, CokernelCofork.condition]))\n            (by aesop_cat) fun s m w => by\n            simp_rw [\u2190 w]\n            apply coequalizer.hom_ext\n            simp }\u27e9", "start": [861, 1], "end": [872, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernelCompIsIso", "code": "@[simps]\ndef cokernelCompIsIso {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [HasCokernel f] [IsIso g] :\n    cokernel (f \u226b g) \u2245 cokernel f where\n  hom := cokernel.desc _ (inv g \u226b cokernel.\u03c0 f) (by simp)\n  inv := cokernel.desc _ (g \u226b cokernel.\u03c0 (f \u226b g)) (by rw [\u2190 Category.assoc, cokernel.condition])", "start": [875, 1], "end": [881, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCokernel_epi_comp", "code": "instance hasCokernel_epi_comp {X Y : C} (f : X \u27f6 Y) [HasCokernel f] {W} (g : W \u27f6 X) [Epi g] :\n    HasCokernel (g \u226b f) :=\n  \u27e8\u27e8{   cocone := _\n        isColimit := isCokernelEpiComp (colimit.isColimit _) g rfl }\u27e9\u27e9", "start": [884, 1], "end": [887, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernelEpiComp", "code": "@[simps]\ndef cokernelEpiComp {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [Epi f] [HasCokernel g] :\n    cokernel (f \u226b g) \u2245 cokernel g where\n  hom := cokernel.desc _ (cokernel.\u03c0 g) (by simp)\n  inv :=\n    cokernel.desc _ (cokernel.\u03c0 (f \u226b g))\n      (by\n        rw [\u2190 cancel_epi f, \u2190 Category.assoc]\n        simp)", "start": [890, 1], "end": [900, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.zeroCokernelCofork", "code": "def cokernel.zeroCokernelCofork : CokernelCofork f\n    where\n  pt := 0\n  \u03b9 := { app := fun j => 0 }", "start": [911, 1], "end": [915, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.isColimitCoconeZeroCocone", "code": "def cokernel.isColimitCoconeZeroCocone [Epi f] : IsColimit (cokernel.zeroCokernelCofork f) :=\n  Cofork.IsColimit.mk _ (fun s => 0)\n    (fun s => by\n      erw [zero_comp]\n      refine (zero_of_epi_comp f ?_).symm\n      exact CokernelCofork.condition _)\n    fun _ _ _ => zero_of_from_zero _", "start": [918, 1], "end": [925, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.ofEpi", "code": "def cokernel.ofEpi [HasCokernel f] [Epi f] : cokernel f \u2245 0 :=\n  Functor.mapIso (Cocones.forget _) <|\n    IsColimit.uniqueUpToIso (colimit.isColimit (parallelPair f 0))\n      (cokernel.isColimitCoconeZeroCocone f)", "start": [928, 1], "end": [932, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.\u03c0_of_epi", "code": "theorem cokernel.\u03c0_of_epi [HasCokernel f] [Epi f] : cokernel.\u03c0 f = 0", "start": [935, 1], "end": [937, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MonoFactorisation.kernel_\u03b9_comp", "code": "@[simp]\ntheorem MonoFactorisation.kernel_\u03b9_comp [HasKernel f] (F : MonoFactorisation f) :\n    kernel.\u03b9 f \u226b F.e = 0", "start": [946, 1], "end": [949, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernelImage\u03b9", "code": "@[simps]\ndef cokernelImage\u03b9 {X Y : C} (f : X \u27f6 Y) [HasImage f] [HasCokernel (image.\u03b9 f)] [HasCokernel f]\n    [Epi (factorThruImage f)] : cokernel (image.\u03b9 f) \u2245 cokernel f where\n  hom :=\n    cokernel.desc _ (cokernel.\u03c0 f)\n      (by\n        have w := cokernel.condition f\n        conv at w =>\n          lhs\n          congr\n          rw [\u2190 image.fac f]\n        rw [\u2190 HasZeroMorphisms.comp_zero (Limits.factorThruImage f), Category.assoc,\n          cancel_epi] at w\n        exact w)\n  inv :=\n    cokernel.desc _ (cokernel.\u03c0 _)\n      (by\n        conv =>\n          lhs\n          congr\n          rw [\u2190 image.fac f]\n        rw [Category.assoc, cokernel.condition, HasZeroMorphisms.comp_zero])", "start": [956, 1], "end": [982, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.\u03c0_of_zero", "code": "theorem cokernel.\u03c0_of_zero : IsIso (cokernel.\u03c0 (0 : X \u27f6 Y))", "start": [991, 1], "end": [993, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel.of_cokernel_of_epi", "code": "instance kernel.of_cokernel_of_epi [HasCokernel f] [HasKernel (cokernel.\u03c0 f)] [Epi f] :\n    IsIso (kernel.\u03b9 (cokernel.\u03c0 f)) :=\n  equalizer.\u03b9_of_eq <| cokernel.\u03c0_of_epi f", "start": [1004, 1], "end": [1007, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.of_kernel_of_mono", "code": "instance cokernel.of_kernel_of_mono [HasKernel f] [HasCokernel (kernel.\u03b9 f)] [Mono f] :\n    IsIso (cokernel.\u03c0 (kernel.\u03b9 f)) :=\n  coequalizer.\u03c0_of_eq <| kernel.\u03b9_of_mono f", "start": [1010, 1], "end": [1013, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.zeroCokernelOfZeroCancel", "code": "def zeroCokernelOfZeroCancel {X Y : C} (f : X \u27f6 Y)\n    (hf : \u2200 (Z : C) (g : Y \u27f6 Z) (_ : f \u226b g = 0), g = 0) :\n    IsColimit (CokernelCofork.of\u03c0 (0 : Y \u27f6 0) (show f \u226b 0 = 0 by simp)) :=\n  Cofork.IsColimit.mk _ (fun s => 0)\n    (fun s => by rw [hf _ _ (CokernelCofork.condition s), comp_zero]) fun s m _ => by\n      apply HasZeroObject.from_zero_ext", "start": [1016, 1], "end": [1022, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsCokernel.ofIsoComp", "code": "def IsCokernel.ofIsoComp {Z : C} (l : Z \u27f6 Y) (i : X \u2245 Z) (h : i.hom \u226b l = f) {s : CokernelCofork f}\n    (hs : IsColimit s) :\n    IsColimit\n      (CokernelCofork.of\u03c0 (Cofork.\u03c0 s) <| show l \u226b Cofork.\u03c0 s = 0 by simp [i.eq_inv_comp.2 h]) :=\n  Cofork.IsColimit.mk _ (fun s => hs.desc <| CokernelCofork.of\u03c0 (Cofork.\u03c0 s) <| by simp [\u2190 h])\n    (fun s => by simp) fun s m h => by\n      apply Cofork.IsColimit.hom_ext hs\n      simpa using h", "start": [1029, 1], "end": [1038, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.ofIsoComp", "code": "def cokernel.ofIsoComp [HasCokernel f] {Z : C} (l : Z \u27f6 Y) (i : X \u2245 Z) (h : i.hom \u226b l = f) :\n    IsColimit\n      (CokernelCofork.of\u03c0 (cokernel.\u03c0 f) <|\n        show l \u226b cokernel.\u03c0 f = 0 by simp [i.eq_inv_comp.2 h]) :=\n  IsCokernel.ofIsoComp f l i h <| colimit.isColimit _", "start": [1041, 1], "end": [1047, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsCokernel.cokernelIso", "code": "def IsCokernel.cokernelIso {Z : C} (l : Y \u27f6 Z) {s : CokernelCofork f} (hs : IsColimit s)\n    (i : s.pt \u2245 Z) (h : Cofork.\u03c0 s \u226b i.hom = l) :\n    IsColimit (CokernelCofork.of\u03c0 l <| show f \u226b l = 0 by simp [\u2190 h]) :=\n  IsColimit.ofIsoColimit hs <|\n    Cocones.ext i fun j => by\n      cases j\n      \u00b7 dsimp; rw [\u2190h]; simp\n      \u00b7 exact h", "start": [1050, 1], "end": [1059, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel.cokernelIso", "code": "def cokernel.cokernelIso [HasCokernel f] {Z : C} (l : Y \u27f6 Z) (i : cokernel f \u2245 Z)\n    (h : cokernel.\u03c0 f \u226b i.hom = l) :\n    IsColimit (@CokernelCofork.of\u03c0 _ _ _ _ _ f _ l <| by simp [\u2190 h]) :=\n  IsCokernel.cokernelIso f l (colimit.isColimit _) i h", "start": [1062, 1], "end": [1066, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernelComparison", "code": "def kernelComparison [HasKernel f] [HasKernel (G.map f)] : G.obj (kernel f) \u27f6 kernel (G.map f) :=\n  kernel.lift _ (G.map (kernel.\u03b9 f))\n    (by simp only [\u2190 G.map_comp, kernel.condition, Functor.map_zero])", "start": [1077, 1], "end": [1083, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernelComparison_comp_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem kernelComparison_comp_\u03b9 [HasKernel f] [HasKernel (G.map f)] :\n    kernelComparison f G \u226b kernel.\u03b9 (G.map f) = G.map (kernel.\u03b9 f)", "start": [1086, 1], "end": [1089, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.map_lift_kernelComparison", "code": "@[reassoc (attr := simp)]\ntheorem map_lift_kernelComparison [HasKernel f] [HasKernel (G.map f)] {Z : C} {h : Z \u27f6 X}\n    (w : h \u226b f = 0) :\n    G.map (kernel.lift _ h w) \u226b kernelComparison f G =\n      kernel.lift _ (G.map h) (by simp only [\u2190 G.map_comp, w, Functor.map_zero])", "start": [1092, 1], "end": [1097, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernelComparison_comp_kernel_map", "code": "@[reassoc]\ntheorem kernelComparison_comp_kernel_map {X' Y' : C} [HasKernel f] [HasKernel (G.map f)]\n    (g : X' \u27f6 Y') [HasKernel g] [HasKernel (G.map g)] (p : X \u27f6 X') (q : Y \u27f6 Y')\n    (hpq : f \u226b q = p \u226b g) :\n    kernelComparison f G \u226b\n        kernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [\u2190 G.map_comp, hpq, G.map_comp]) =\n      G.map (kernel.map f g p q hpq) \u226b kernelComparison g G", "start": [1100, 1], "end": [1109, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernelComparison", "code": "def cokernelComparison [HasCokernel f] [HasCokernel (G.map f)] :\n    cokernel (G.map f) \u27f6 G.obj (cokernel f) :=\n  cokernel.desc _ (G.map (coequalizer.\u03c0 _ _))\n    (by simp only [\u2190 G.map_comp, cokernel.condition, Functor.map_zero])", "start": [1112, 1], "end": [1116, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.\u03c0_comp_cokernelComparison", "code": "@[reassoc (attr := simp)]\ntheorem \u03c0_comp_cokernelComparison [HasCokernel f] [HasCokernel (G.map f)] :\n    cokernel.\u03c0 (G.map f) \u226b cokernelComparison f G = G.map (cokernel.\u03c0 _)", "start": [1119, 1], "end": [1122, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernelComparison_map_desc", "code": "@[reassoc (attr := simp)]\ntheorem cokernelComparison_map_desc [HasCokernel f] [HasCokernel (G.map f)] {Z : C} {h : Y \u27f6 Z}\n    (w : f \u226b h = 0) :\n    cokernelComparison f G \u226b G.map (cokernel.desc _ h w) =\n      cokernel.desc _ (G.map h) (by simp only [\u2190 G.map_comp, w, Functor.map_zero])", "start": [1125, 1], "end": [1130, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cokernel_map_comp_cokernelComparison", "code": "@[reassoc]\ntheorem cokernel_map_comp_cokernelComparison {X' Y' : C} [HasCokernel f] [HasCokernel (G.map f)]\n    (g : X' \u27f6 Y') [HasCokernel g] [HasCokernel (G.map g)] (p : X \u27f6 X') (q : Y \u27f6 Y')\n    (hpq : f \u226b q = p \u226b g) :\n    cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [\u2190 G.map_comp, hpq, G.map_comp]) \u226b\n        cokernelComparison _ G =\n      cokernelComparison _ G \u226b G.map (cokernel.map f g p q hpq)", "start": [1133, 1], "end": [1142, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasKernels", "code": "class HasKernels : Prop where\n  has_limit : \u2200 {X Y : C} (f : X \u27f6 Y), HasKernel f := by infer_instance", "start": [1155, 1], "end": [1157, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasCokernels", "code": "class HasCokernels : Prop where\n  has_colimit : \u2200 {X Y : C} (f : X \u27f6 Y), HasCokernel f := by infer_instance", "start": [1160, 1], "end": [1162, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasKernels_of_hasEqualizers", "code": "instance (priority := 100) hasKernels_of_hasEqualizers [HasEqualizers C] : HasKernels C where", "start": [1167, 1], "end": [1167, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCokernels_of_hasCoequalizers", "code": "instance (priority := 100) hasCokernels_of_hasCoequalizers [HasCoequalizers C] : HasCokernels C\n    where", "start": [1170, 1], "end": [1171, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Sites/Grothendieck.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Copy.lean", "Mathlib/CategoryTheory/Category/Preorder.lean", "Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.lean", "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "Mathlib/CategoryTheory/Sites/Sieves.lean"], "premises": [{"full_name": "CategoryTheory.GrothendieckTopology", "code": "structure GrothendieckTopology where\n  \n  sieves : \u2200 X : C, Set (Sieve X)\n  \n  top_mem' : \u2200 X, \u22a4 \u2208 sieves X\n  \n  pullback_stable' : \u2200 \u2983X Y : C\u2984 \u2983S : Sieve X\u2984 (f : Y \u27f6 X), S \u2208 sieves X \u2192 S.pullback f \u2208 sieves Y\n  \n  transitive' :\n    \u2200 \u2983X\u2984 \u2983S : Sieve X\u2984 (_ : S \u2208 sieves X) (R : Sieve X),\n      (\u2200 \u2983Y\u2984 \u2983f : Y \u27f6 X\u2984, S f \u2192 R.pullback f \u2208 sieves Y) \u2192 R \u2208 sieves X", "start": [61, 1], "end": [86, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.ext", "code": "@[ext]\ntheorem ext {J\u2081 J\u2082 : GrothendieckTopology C} (h : (J\u2081 : \u2200 X : C, Set (Sieve X)) = J\u2082) :\n    J\u2081 = J\u2082", "start": [99, 1], "end": [108, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.top_mem", "code": "@[simp]\ntheorem top_mem (X : C) : \u22a4 \u2208 J X", "start": [120, 1], "end": [122, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.pullback_stable", "code": "@[simp]\ntheorem pullback_stable (f : Y \u27f6 X) (hS : S \u2208 J X) : S.pullback f \u2208 J Y", "start": [126, 1], "end": [128, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.transitive", "code": "theorem transitive (hS : S \u2208 J X) (R : Sieve X) (h : \u2200 \u2983Y\u2984 \u2983f : Y \u27f6 X\u2984, S f \u2192 R.pullback f \u2208 J Y) :\n    R \u2208 J X", "start": [131, 1], "end": [133, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.covering_of_eq_top", "code": "theorem covering_of_eq_top : S = \u22a4 \u2192 S \u2208 J X", "start": [136, 1], "end": [136, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.superset_covering", "code": "theorem superset_covering (Hss : S \u2264 R) (sjx : S \u2208 J X) : R \u2208 J X", "start": [139, 1], "end": [149, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.intersection_covering", "code": "theorem intersection_covering (rj : R \u2208 J X) (sj : S \u2208 J X) : R \u2293 S \u2208 J X", "start": [152, 1], "end": [161, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.intersection_covering_iff", "code": "@[simp]\ntheorem intersection_covering_iff : R \u2293 S \u2208 J X \u2194 R \u2208 J X \u2227 S \u2208 J X", "start": [164, 1], "end": [167, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.bind_covering", "code": "theorem bind_covering {S : Sieve X} {R : \u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, S f \u2192 Sieve Y} (hS : S \u2208 J X)\n    (hR : \u2200 \u2983Y\u2984 \u2983f : Y \u27f6 X\u2984 (H : S f), R H \u2208 J Y) : Sieve.bind S R \u2208 J X", "start": [170, 1], "end": [172, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Covers", "code": "def Covers (S : Sieve X) (f : Y \u27f6 X) : Prop :=\n  S.pullback f \u2208 J Y", "start": [175, 1], "end": [179, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.covers_iff", "code": "theorem covers_iff (S : Sieve X) (f : Y \u27f6 X) : J.Covers S f \u2194 S.pullback f \u2208 J Y", "start": [182, 1], "end": [183, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.covering_iff_covers_id", "code": "theorem covering_iff_covers_id (S : Sieve X) : S \u2208 J X \u2194 J.Covers S (\ud835\udfd9 X)", "start": [186, 1], "end": [186, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.arrow_max", "code": "theorem arrow_max (f : Y \u27f6 X) (S : Sieve X) (hf : S f) : J.Covers S f", "start": [189, 1], "end": [192, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.arrow_stable", "code": "theorem arrow_stable (f : Y \u27f6 X) (S : Sieve X) (h : J.Covers S f) {Z : C} (g : Z \u27f6 Y) :\n    J.Covers S (g \u226b f)", "start": [195, 1], "end": [199, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.arrow_trans", "code": "theorem arrow_trans (f : Y \u27f6 X) (S R : Sieve X) (h : J.Covers S f) :\n    (\u2200 {Z : C} (g : Z \u27f6 X), S g \u2192 J.Covers R g) \u2192 J.Covers R f", "start": [202, 1], "end": [211, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.arrow_intersect", "code": "theorem arrow_intersect (f : Y \u27f6 X) (S R : Sieve X) (hS : J.Covers S f) (hR : J.Covers R f) :\n    J.Covers (S \u2293 R) f", "start": [214, 1], "end": [215, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.trivial", "code": "def trivial : GrothendieckTopology C where\n  sieves X := {\u22a4}\n  top_mem' X := rfl\n  pullback_stable' X Y S f hf := by\n    rw [Set.mem_singleton_iff] at hf \u22a2\n    simp [hf]\n  transitive' X S hS R hR := by\n    rw [Set.mem_singleton_iff, \u2190 Sieve.id_mem_iff_eq_top] at hS\n    simpa using hR hS", "start": [220, 1], "end": [234, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.discrete", "code": "def discrete : GrothendieckTopology C\n    where\n  sieves X := Set.univ\n  top_mem' := by simp\n  pullback_stable' X Y f := by simp\n  transitive' := by simp", "start": [237, 1], "end": [246, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.trivial_covering", "code": "theorem trivial_covering : S \u2208 trivial C X \u2194 S = \u22a4", "start": [251, 1], "end": [252, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.instLEGrothendieckTopology", "code": "instance instLEGrothendieckTopology : LE (GrothendieckTopology C) where\n  le J\u2081 J\u2082 := (J\u2081 : \u2200 X : C, Set (Sieve X)) \u2264 (J\u2082 : \u2200 X : C, Set (Sieve X))", "start": [255, 1], "end": [257, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.le_def", "code": "theorem le_def {J\u2081 J\u2082 : GrothendieckTopology C} : J\u2081 \u2264 J\u2082 \u2194 (J\u2081 : \u2200 X : C, Set (Sieve X)) \u2264 J\u2082", "start": [259, 1], "end": [260, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.isGLB_sInf", "code": "theorem isGLB_sInf (s : Set (GrothendieckTopology C)) : IsGLB s (sInf s)", "start": [285, 1], "end": [290, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.trivial_eq_bot", "code": "@[simp]\ntheorem trivial_eq_bot : trivial C = \u22a5", "start": [315, 1], "end": [317, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.discrete_eq_top", "code": "@[simp]\ntheorem discrete_eq_top : discrete C = \u22a4", "start": [320, 1], "end": [322, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.bot_covering", "code": "@[simp]\ntheorem bot_covering : S \u2208 (\u22a5 : GrothendieckTopology C) X \u2194 S = \u22a4", "start": [325, 1], "end": [327, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.top_covering", "code": "@[simp]\ntheorem top_covering : S \u2208 (\u22a4 : GrothendieckTopology C) X", "start": [330, 1], "end": [332, 5], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.bot_covers", "code": "theorem bot_covers (S : Sieve X) (f : Y \u27f6 X) : (\u22a5 : GrothendieckTopology C).Covers S f \u2194 S f", "start": [335, 1], "end": [336, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.top_covers", "code": "@[simp]\ntheorem top_covers (S : Sieve X) (f : Y \u27f6 X) : (\u22a4 : GrothendieckTopology C).Covers S f", "start": [339, 1], "end": [341, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.dense", "code": "def dense : GrothendieckTopology C\n    where\n  sieves X S := \u2200 {Y : C} (f : Y \u27f6 X), \u2203 (Z : _) (g : Z \u27f6 Y), S (g \u226b f)\n  top_mem' X Y f := \u27e8Y, \ud835\udfd9 Y, \u27e8\u27e9\u27e9\n  pullback_stable' := by\n    intro X Y S h H Z f\n    rcases H (f \u226b h) with \u27e8W, g, H'\u27e9\n    exact \u27e8W, g, by simpa\u27e9\n  transitive' := by\n    intro X S H\u2081 R H\u2082 Y f\n    rcases H\u2081 f with \u27e8Z, g, H\u2083\u27e9\n    rcases H\u2082 H\u2083 (\ud835\udfd9 Z) with \u27e8W, h, H\u2084\u27e9\n    exact \u27e8W, h \u226b g, by simpa using H\u2084\u27e9", "start": [344, 1], "end": [360, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.dense_covering", "code": "theorem dense_covering : S \u2208 dense X \u2194 \u2200 {Y} (f : Y \u27f6 X), \u2203 (Z : _) (g : Z \u27f6 Y), S (g \u226b f)", "start": [363, 1], "end": [364, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.RightOreCondition", "code": "def RightOreCondition (C : Type u) [Category.{v} C] : Prop :=\n  \u2200 {X Y Z : C} (yx : Y \u27f6 X) (zx : Z \u27f6 X), \u2203 (W : _) (wy : W \u27f6 Y) (wz : W \u27f6 Z), wy \u226b yx = wz \u226b zx", "start": [367, 1], "end": [373, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.right_ore_of_pullbacks", "code": "theorem right_ore_of_pullbacks [Limits.HasPullbacks C] : RightOreCondition C", "start": [376, 1], "end": [377, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.atomic", "code": "def atomic (hro : RightOreCondition C) : GrothendieckTopology C\n    where\n  sieves X S := \u2203 (Y : _) (f : Y \u27f6 X), S f\n  top_mem' X := \u27e8_, \ud835\udfd9 _, \u27e8\u27e9\u27e9\n  pullback_stable' := by\n    rintro X Y S h \u27e8Z, f, hf\u27e9\n    rcases hro h f with \u27e8W, g, k, comm\u27e9\n    refine' \u27e8_, g, _\u27e9\n    simp [comm, hf]\n  transitive' := by\n    rintro X S \u27e8Y, f, hf\u27e9 R h\n    rcases h hf with \u27e8Z, g, hg\u27e9\n    exact \u27e8_, _, hg\u27e9", "start": [380, 1], "end": [397, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover", "code": "def Cover (X : C) : Type max u v :=\n  { S : Sieve X // S \u2208 J X }", "start": [401, 1], "end": [405, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.sieve", "code": "def sieve (S : J.Cover X) : Sieve X := S.1", "start": [428, 1], "end": [429, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.condition", "code": "theorem condition (S : J.Cover X) : S.sieve \u2208 J X", "start": [453, 1], "end": [454, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.ext", "code": "@[ext]\ntheorem ext (S T : J.Cover X) (h : \u2200 \u2983Y\u2984 (f : Y \u27f6 X), S f \u2194 T f) : S = T", "start": [457, 1], "end": [459, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Arrow", "code": "@[ext]\nstructure Arrow (S : J.Cover X) where\n  \n  Y : C\n  \n  f : Y \u27f6 X\n  \n  hf : S f", "start": [479, 1], "end": [488, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Relation", "code": "@[ext]\nstructure Relation (S : J.Cover X) where\n  \n  Y\u2081 : C\n  \n  Y\u2082 : C\n  \n  Z : C\n  \n  g\u2081 : Z \u27f6 Y\u2081\n  \n  g\u2082 : Z \u27f6 Y\u2082\n  \n  f\u2081 : Y\u2081 \u27f6 X\n  \n  f\u2082 : Y\u2082 \u27f6 X\n  \n  h\u2081 : S f\u2081\n  \n  h\u2082 : S f\u2082\n  \n  w : g\u2081 \u226b f\u2081 = g\u2082 \u226b f\u2082", "start": [491, 1], "end": [514, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Arrow.map", "code": "@[simps]\ndef Arrow.map {S T : J.Cover X} (I : S.Arrow) (f : S \u27f6 T) : T.Arrow :=\n  \u27e8I.Y, I.f, f.le _ I.hf\u27e9", "start": [519, 1], "end": [522, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Relation.map", "code": "@[simps]\ndef Relation.map {S T : J.Cover X} (I : S.Relation) (f : S \u27f6 T) : T.Relation :=\n  \u27e8_, _, _, I.g\u2081, I.g\u2082, I.f\u2081, I.f\u2082, f.le _ I.h\u2081, f.le _ I.h\u2082, I.w\u27e9", "start": [525, 1], "end": [528, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Relation.fst", "code": "@[simps]\ndef Relation.fst {S : J.Cover X} (I : S.Relation) : S.Arrow :=\n  \u27e8I.Y\u2081, I.f\u2081, I.h\u2081\u27e9", "start": [531, 1], "end": [535, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Relation.snd", "code": "@[simps]\ndef Relation.snd {S : J.Cover X} (I : S.Relation) : S.Arrow :=\n  \u27e8I.Y\u2082, I.f\u2082, I.h\u2082\u27e9", "start": [538, 1], "end": [542, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Relation.map_fst", "code": "@[simp]\ntheorem Relation.map_fst {S T : J.Cover X} (I : S.Relation) (f : S \u27f6 T) :\n    I.fst.map f = (I.map f).fst", "start": [545, 1], "end": [548, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Relation.map_snd", "code": "@[simp]\ntheorem Relation.map_snd {S T : J.Cover X} (I : S.Relation) (f : S \u27f6 T) :\n    I.snd.map f = (I.map f).snd", "start": [551, 1], "end": [554, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.pullback", "code": "def pullback (S : J.Cover X) (f : Y \u27f6 X) : J.Cover Y :=\n  \u27e8Sieve.pullback f S.sieve, J.pullback_stable _ S.condition\u27e9", "start": [557, 1], "end": [559, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Arrow.base", "code": "@[simps]\ndef Arrow.base {f : Y \u27f6 X} {S : J.Cover X} (I : (S.pullback f).Arrow) : S.Arrow :=\n  \u27e8I.Y, I.f \u226b f, I.hf\u27e9", "start": [562, 1], "end": [565, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Relation.base", "code": "@[simps]\ndef Relation.base {f : Y \u27f6 X} {S : J.Cover X} (I : (S.pullback f).Relation) : S.Relation :=\n  \u27e8_, _, _, I.g\u2081, I.g\u2082, I.f\u2081 \u226b f, I.f\u2082 \u226b f, I.h\u2081, I.h\u2082, by simp [reassoc_of% I.w]\u27e9", "start": [568, 1], "end": [571, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Relation.base_fst", "code": "@[simp]\ntheorem Relation.base_fst {f : Y \u27f6 X} {S : J.Cover X} (I : (S.pullback f).Relation) :\n    I.fst.base = I.base.fst", "start": [574, 1], "end": [577, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Relation.base_snd", "code": "@[simp]\ntheorem Relation.base_snd {f : Y \u27f6 X} {S : J.Cover X} (I : (S.pullback f).Relation) :\n    I.snd.base = I.base.snd", "start": [580, 1], "end": [583, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.coe_pullback", "code": "@[simp]\ntheorem coe_pullback {Z : C} (f : Y \u27f6 X) (g : Z \u27f6 Y) (S : J.Cover X) :\n    (S.pullback f) g \u2194 S (g \u226b f)", "start": [586, 1], "end": [589, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.pullbackId", "code": "def pullbackId (S : J.Cover X) : S.pullback (\ud835\udfd9 X) \u2245 S :=\n  eqToIso <| Cover.ext _ _ fun Y f => by simp", "start": [592, 1], "end": [594, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.pullbackComp", "code": "def pullbackComp {X Y Z : C} (S : J.Cover X) (f : Z \u27f6 Y) (g : Y \u27f6 X) :\n    S.pullback (f \u226b g) \u2245 (S.pullback g).pullback f :=\n  eqToIso <| Cover.ext _ _ fun Y f => by simp", "start": [597, 1], "end": [600, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.bind", "code": "def bind {X : C} (S : J.Cover X) (T : \u2200 I : S.Arrow, J.Cover I.Y) : J.Cover X :=\n  \u27e8Sieve.bind S.sieve fun Y f hf => (T \u27e8Y, f, hf\u27e9).sieve,\n    J.bind_covering S.condition fun _ _ _ => (T _).condition\u27e9", "start": [603, 1], "end": [606, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.bindToBase", "code": "def bindToBase {X : C} (S : J.Cover X) (T : \u2200 I : S.Arrow, J.Cover I.Y) : S.bind T \u27f6 S :=\n  homOfLE <| by\n    rintro Y f \u27e8Z, e1, e2, h1, _, h3\u27e9\n    rw [\u2190 h3]\n    apply Sieve.downward_closed\n    exact h1", "start": [609, 1], "end": [615, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Arrow.middle", "code": "noncomputable def Arrow.middle {X : C} {S : J.Cover X} {T : \u2200 I : S.Arrow, J.Cover I.Y}\n    (I : (S.bind T).Arrow) : C :=\n  I.hf.choose", "start": [618, 1], "end": [622, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Arrow.toMiddleHom", "code": "noncomputable def Arrow.toMiddleHom {X : C} {S : J.Cover X} {T : \u2200 I : S.Arrow, J.Cover I.Y}\n    (I : (S.bind T).Arrow) : I.Y \u27f6 I.middle :=\n  I.hf.choose_spec.choose", "start": [625, 1], "end": [629, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Arrow.fromMiddleHom", "code": "noncomputable def Arrow.fromMiddleHom {X : C} {S : J.Cover X} {T : \u2200 I : S.Arrow, J.Cover I.Y}\n    (I : (S.bind T).Arrow) : I.middle \u27f6 X :=\n  I.hf.choose_spec.choose_spec.choose", "start": [632, 1], "end": [636, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Arrow.from_middle_condition", "code": "theorem Arrow.from_middle_condition {X : C} {S : J.Cover X} {T : \u2200 I : S.Arrow, J.Cover I.Y}\n    (I : (S.bind T).Arrow) : S I.fromMiddleHom", "start": [639, 1], "end": [641, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Arrow.fromMiddle", "code": "noncomputable def Arrow.fromMiddle {X : C} {S : J.Cover X} {T : \u2200 I : S.Arrow, J.Cover I.Y}\n    (I : (S.bind T).Arrow) : S.Arrow :=\n  \u27e8_, I.fromMiddleHom, I.from_middle_condition\u27e9", "start": [644, 1], "end": [648, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Arrow.to_middle_condition", "code": "theorem Arrow.to_middle_condition {X : C} {S : J.Cover X} {T : \u2200 I : S.Arrow, J.Cover I.Y}\n    (I : (S.bind T).Arrow) : (T I.fromMiddle) I.toMiddleHom", "start": [651, 1], "end": [653, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Arrow.toMiddle", "code": "noncomputable def Arrow.toMiddle {X : C} {S : J.Cover X} {T : \u2200 I : S.Arrow, J.Cover I.Y}\n    (I : (S.bind T).Arrow) : (T I.fromMiddle).Arrow :=\n  \u27e8_, I.toMiddleHom, I.to_middle_condition\u27e9", "start": [656, 1], "end": [660, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.Arrow.middle_spec", "code": "theorem Arrow.middle_spec {X : C} {S : J.Cover X} {T : \u2200 I : S.Arrow, J.Cover I.Y}\n    (I : (S.bind T).Arrow) : I.toMiddleHom \u226b I.fromMiddleHom = I.f", "start": [663, 1], "end": [665, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.index", "code": "def index {D : Type u\u2081} [Category.{v\u2081} D] (S : J.Cover X) (P : C\u1d52\u1d56 \u2964 D) :\n    Limits.MulticospanIndex D where\n  L := S.Arrow\n  R := S.Relation\n  fstTo I := I.fst\n  sndTo I := I.snd\n  left I := P.obj (Opposite.op I.Y)\n  right I := P.obj (Opposite.op I.Z)\n  fst I := P.map I.g\u2081.op\n  snd I := P.map I.g\u2082.op", "start": [670, 1], "end": [680, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.multifork", "code": "abbrev multifork {D : Type u\u2081} [Category.{v\u2081} D] (S : J.Cover X) (P : C\u1d52\u1d56 \u2964 D) :\n    Limits.Multifork (S.index P) :=\n  Limits.Multifork.of\u03b9 _ (P.obj (Opposite.op X)) (fun I => P.map I.f.op)\n    (by\n      intro I\n      dsimp [index]\n      simp only [\u2190 P.map_comp, \u2190 op_comp, I.w])", "start": [683, 1], "end": [694, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Cover.toMultiequalizer", "code": "noncomputable abbrev toMultiequalizer {D : Type u\u2081} [Category.{v\u2081} D] (S : J.Cover X)\n    (P : C\u1d52\u1d56 \u2964 D) [Limits.HasMultiequalizer (S.index P)] :\n    P.obj (Opposite.op X) \u27f6 Limits.multiequalizer (S.index P) :=\n  Limits.Multiequalizer.lift _ _ (fun I => P.map I.f.op)\n    (by\n      intro I\n      dsimp only [index, Relation.fst, Relation.snd]\n      simp only [\u2190 P.map_comp, \u2190 op_comp, I.w])", "start": [697, 1], "end": [707, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.pullback", "code": "@[simps obj]\ndef pullback (f : Y \u27f6 X) : J.Cover X \u2964 J.Cover Y\n    where\n  obj S := S.pullback f\n  map f := (Sieve.pullback_monotone _ f.le).hom", "start": [712, 1], "end": [717, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.pullbackId", "code": "def pullbackId (X : C) : J.pullback (\ud835\udfd9 X) \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents fun S => S.pullbackId", "start": [720, 1], "end": [722, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.pullbackComp", "code": "def pullbackComp {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    J.pullback (f \u226b g) \u2245 J.pullback g \u22d9 J.pullback f :=\n  NatIso.ofComponents fun S => S.pullbackComp f g", "start": [725, 1], "end": [729, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Types.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Images.lean", "Mathlib/Logic/UnivLE.lean", "Mathlib/Data/TypeMax.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Filtered/Basic.lean"], "premises": [{"full_name": "CategoryTheory.Limits.Types.coneOfSection", "code": "def coneOfSection {s} (hs : s \u2208 F.sections) : Cone F where\n  pt := PUnit\n  \u03c0 :=\n  { app := fun j _ \u21a6 s j,\n    naturality := fun i j f \u21a6 by ext; exact (hs f).symm }", "start": [38, 1], "end": [44, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.sectionOfCone", "code": "def sectionOfCone (c : Cone F) (x : c.pt) : F.sections :=\n  \u27e8fun j \u21a6 c.\u03c0.app j x, fun f \u21a6 congr_fun (c.\u03c0.naturality f).symm x\u27e9", "start": [46, 1], "end": [49, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.isLimit_iff", "code": "theorem isLimit_iff (c : Cone F) :\n    Nonempty (IsLimit c) \u2194 \u2200 s \u2208 F.sections, \u2203! x : c.pt, \u2200 i, c.\u03c0.app i x = s i", "start": [51, 1], "end": [59, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.isLimitEquivSections", "code": "noncomputable def isLimitEquivSections {c : Cone F} (t : IsLimit c) :\n    c.pt \u2243 F.sections where\n  toFun := sectionOfCone c\n  invFun s := t.lift (coneOfSection s.2) \u27e8\u27e9\n  left_inv x := (congr_fun (t.uniq (coneOfSection _) (fun _ \u21a6 x) fun _ \u21a6 rfl) \u27e8\u27e9).symm\n  right_inv s := Subtype.ext (funext fun j \u21a6 congr_fun (t.fac (coneOfSection s.2) j) \u27e8\u27e9)", "start": [61, 1], "end": [69, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.isLimitEquivSections_apply", "code": "@[simp]\ntheorem isLimitEquivSections_apply {c : Cone F} (t : IsLimit c) (j : J)\n    (x : c.pt) : (isLimitEquivSections t x : \u2200 j, F.obj j) j = c.\u03c0.app j x", "start": [72, 1], "end": [74, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.isLimitEquivSections_symm_apply", "code": "@[simp]\ntheorem isLimitEquivSections_symm_apply {c : Cone F} (t : IsLimit c)\n    (x : F.sections) (j : J) :\n    c.\u03c0.app j ((isLimitEquivSections t).symm x) = (x : \u2200 j, F.obj j) j", "start": [77, 1], "end": [81, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.UnivLE.limitCone", "code": "@[simps]\nnoncomputable def limitCone (F : J \u2964 Type u) : Cone F where\n  pt := Shrink F.sections\n  \u03c0 :=\n    { app := fun j u => ((equivShrink _).symm u).val j\n      naturality := fun j j' f => by\n        funext x\n        simp }", "start": [106, 1], "end": [116, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.UnivLE.limitCone_pt_ext", "code": "@[ext]\nlemma limitCone_pt_ext (F : J \u2964 Type u) {x y : (limitCone F).pt}\n    (w : (equivShrink _).symm x = (equivShrink _).symm y) : x = y := by\n  aesop", "start": [118, 1], "end": [121, 8], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.Types.UnivLE.limitConeIsLimit", "code": "@[simps]\nnoncomputable def limitConeIsLimit (F : J \u2964 Type u) : IsLimit (limitCone.{v, u} F) where\n  lift s v := (equivShrink _)\n    { val := fun j => s.\u03c0.app j v\n      property := fun f => congr_fun (Cone.w s f) _ }\n  uniq := fun _ _ w => by\n    ext x j\n    simpa using congr_fun (w j) x", "start": [123, 1], "end": [131, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.limitCone", "code": "@[simps]\nnoncomputable def limitCone (F : J \u2964 TypeMax.{v, u}) : Cone F where\n  pt := F.sections\n  \u03c0 :=\n    { app := fun j u => u.val j\n      naturality := fun j j' f => by\n        funext x\n        simp }", "start": [139, 1], "end": [149, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.limitConeIsLimit", "code": "@[simps]\nnoncomputable def limitConeIsLimit (F : J \u2964 TypeMax.{v, u}) : IsLimit (limitCone.{v, u} F) where\n  lift s v :=\n    { val := fun j => s.\u03c0.app j v\n      property := fun f => congr_fun (Cone.w s f) _ }\n  uniq := fun _ _ w => by\n    funext x\n    apply Subtype.ext\n    funext j\n    exact congr_fun (w j) x", "start": [152, 1], "end": [162, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.hasLimitsOfSize", "code": "instance (priority := 1300) hasLimitsOfSize : HasLimitsOfSize.{v} (Type u) where\n  has_limits_of_shape _ :=\n    { has_limit := fun F =>\n        HasLimit.mk\n          { cone := UnivLE.limitCone.{v, u} F\n            isLimit := UnivLE.limitConeIsLimit F } }", "start": [179, 1], "end": [191, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.hasLimit", "code": "instance hasLimit (F : J \u2964 Type u) : HasLimit F :=\n  (Types.hasLimitsOfSize.{v, u}.has_limits_of_shape J).has_limit F", "start": [194, 1], "end": [195, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.limitEquivSections", "code": "noncomputable def limitEquivSections (F : J \u2964 Type u) :\n    (@limit _ _ _ _ F (hasLimit.{v, u} F) : Type u) \u2243 F.sections :=\n  isLimitEquivSections.{v, u} (limit.isLimit F)", "start": [197, 1], "end": [202, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.limitEquivSections_apply", "code": "@[simp]\ntheorem limitEquivSections_apply (F : J \u2964 Type u) (x : limit F) (j : J) :\n    ((limitEquivSections.{v, u} F) x : \u2200 j, F.obj j) j = limit.\u03c0 F j x", "start": [205, 1], "end": [208, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.limitEquivSections_symm_apply", "code": "@[simp]\ntheorem limitEquivSections_symm_apply (F : J \u2964 Type u) (x : F.sections) (j : J) :\n    limit.\u03c0 F j ((limitEquivSections.{v, u} F).symm x) = (x : \u2200 j, F.obj j) j", "start": [211, 1], "end": [214, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Limit.mk", "code": "noncomputable def Limit.mk (F : J \u2964 Type u) (x : \u2200 j, F.obj j)\n    (h : \u2200 (j j') (f : j \u27f6 j'), F.map f (x j) = x j') : (limit F : Type u) :=\n  (limitEquivSections.{v, u} F).symm \u27e8x, h _ _\u27e9", "start": [226, 1], "end": [231, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Limit.\u03c0_mk", "code": "@[simp]\ntheorem Limit.\u03c0_mk (F : J \u2964 Type u) (x : \u2200 j, F.obj j)\n    (h : \u2200 (j j') (f : j \u27f6 j'), F.map f (x j) = x j') (j) :\n      limit.\u03c0 F j (Limit.mk.{v, u} F x h) = x j", "start": [234, 1], "end": [239, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.limit_ext", "code": "@[ext]\ntheorem limit_ext (F : J \u2964 Type u) (x y : limit F)\n    (w : \u2200 j, limit.\u03c0 F j x = limit.\u03c0 F j y) : x = y", "start": [252, 1], "end": [257, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.limit_ext'", "code": "@[ext]\ntheorem limit_ext' (F : J \u2964 Type v) (x y : limit F) (w : \u2200 j, limit.\u03c0 F j x = limit.\u03c0 F j y) :\n    x = y", "start": [260, 1], "end": [263, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.limit_ext_iff", "code": "theorem limit_ext_iff (F : J \u2964 Type u) (x y : limit F) :\n    x = y \u2194 \u2200 j, limit.\u03c0 F j x = limit.\u03c0 F j y", "start": [266, 1], "end": [268, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.limit_ext_iff'", "code": "theorem limit_ext_iff' (F : J \u2964 Type v) (x y : limit F) :\n    x = y \u2194 \u2200 j, limit.\u03c0 F j x = limit.\u03c0 F j y", "start": [271, 1], "end": [273, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Limit.w_apply", "code": "theorem Limit.w_apply {F : J \u2964 Type u} {j j' : J} {x : limit F} (f : j \u27f6 j') :\n    F.map f (limit.\u03c0 F j x) = limit.\u03c0 F j' x", "start": [281, 1], "end": [283, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Limit.lift_\u03c0_apply", "code": "theorem Limit.lift_\u03c0_apply (F : J \u2964 Type u) (s : Cone F) (j : J) (x : s.pt) :\n    limit.\u03c0 F j (limit.lift F s x) = s.\u03c0.app j x", "start": [287, 1], "end": [289, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Limit.map_\u03c0_apply", "code": "theorem Limit.map_\u03c0_apply {F G : J \u2964 Type u} (\u03b1 : F \u27f6 G) (j : J) (x : limit F) :\n    limit.\u03c0 G j (limMap \u03b1 x) = \u03b1.app j (limit.\u03c0 F j x)", "start": [293, 1], "end": [295, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Limit.w_apply'", "code": "@[simp]\ntheorem Limit.w_apply' {F : J \u2964 Type v} {j j' : J} {x : limit F} (f : j \u27f6 j') :\n    F.map f (limit.\u03c0 F j x) = limit.\u03c0 F j' x", "start": [298, 1], "end": [301, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Limit.lift_\u03c0_apply'", "code": "@[simp]\ntheorem Limit.lift_\u03c0_apply' (F : J \u2964 Type v) (s : Cone F) (j : J) (x : s.pt) :\n    limit.\u03c0 F j (limit.lift F s x) = s.\u03c0.app j x", "start": [304, 1], "end": [307, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Limit.map_\u03c0_apply'", "code": "@[simp]\ntheorem Limit.map_\u03c0_apply' {F G : J \u2964 Type v} (\u03b1 : F \u27f6 G) (j : J) (x : limit F) :\n    limit.\u03c0 G j (limMap \u03b1 x) = \u03b1.app j (limit.\u03c0 F j x)", "start": [310, 1], "end": [313, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Quot.Rel", "code": "def Quot.Rel (F : J \u2964 TypeMax.{v, u}) : (\u03a3 j, F.obj j) \u2192 (\u03a3 j, F.obj j) \u2192 Prop := fun p p' =>\n  \u2203 f : p.1 \u27f6 p'.1, p'.2 = F.map f p.2", "start": [333, 1], "end": [338, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Quot", "code": "def Quot (F : J \u2964 TypeMax.{v, u}) : TypeMax.{v, u} :=\n  _root_.Quot (Quot.Rel.{v, u} F)", "start": [342, 1], "end": [347, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.colimitCocone", "code": "def colimitCocone (F : J \u2964 TypeMax.{v, u}) : Cocone F where\n  pt := Quot.{v, u} F\n  \u03b9 :=\n    { app := fun j x => Quot.mk _ \u27e8j, x\u27e9\n      naturality := fun _ _ f => funext fun _ => Eq.symm (Quot.sound \u27e8f, rfl\u27e9) }", "start": [350, 1], "end": [357, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.colimitCoconeIsColimit", "code": "def colimitCoconeIsColimit (F : J \u2964 TypeMax.{v, u}) : IsColimit (colimitCocone.{v, u} F) where\n  desc s :=\n    Quot.lift (fun p : \u03a3j, F.obj j => s.\u03b9.app p.1 p.2) fun \u27e8j, x\u27e9 \u27e8j', x'\u27e9 \u27e8f, hf\u27e9 => by\n      dsimp at hf\n      rw [hf]\n      exact (congr_fun (Cocone.w s f) x).symm\n  uniq s m hm := by\n    funext x\n    induction' x using Quot.ind with x\n    exact congr_fun (hm x.1) x.2", "start": [362, 1], "end": [372, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.hasColimitsOfSize", "code": "instance hasColimitsOfSize : HasColimitsOfSize.{v} TypeMax.{v, u} where\n  has_colimits_of_shape _ :=\n    { has_colimit := fun F =>\n        HasColimit.mk\n          { cocone := colimitCocone.{v, u} F\n            isColimit := colimitCoconeIsColimit F } }", "start": [375, 1], "end": [384, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.hasColimit", "code": "instance hasColimit (F : J \u2964 TypeMax.{v, u}) : HasColimit F :=\n  (Types.hasColimitsOfSize.{v, u}.has_colimits_of_shape J).has_colimit F", "start": [390, 1], "end": [391, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.hasColimit'", "code": "instance hasColimit' (F : J \u2964 Type v) : HasColimit F :=\n  hasColimit.{v, v} F", "start": [393, 1], "end": [394, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.colimitEquivQuot", "code": "noncomputable def colimitEquivQuot (F : J \u2964 TypeMax.{v, u}) : colimit F \u2243 Quot.{v, u} F :=\n  (IsColimit.coconePointUniqueUpToIso (colimit.isColimit F) (colimitCoconeIsColimit F)).toEquiv", "start": [396, 1], "end": [400, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.colimitEquivQuot_symm_apply", "code": "@[simp]\ntheorem colimitEquivQuot_symm_apply (F : J \u2964 TypeMax.{v, u}) (j : J) (x : F.obj j) :\n    (colimitEquivQuot.{v, u} F).symm (Quot.mk _ \u27e8j, x\u27e9) = colimit.\u03b9 F j x", "start": [403, 1], "end": [406, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.colimitEquivQuot_apply", "code": "@[simp]\ntheorem colimitEquivQuot_apply (F : J \u2964 TypeMax.{v, u}) (j : J) (x : F.obj j) :\n    (colimitEquivQuot.{v, u} F) (colimit.\u03b9 F j x) = Quot.mk _ \u27e8j, x\u27e9", "start": [409, 1], "end": [413, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Colimit.w_apply", "code": "theorem Colimit.w_apply {F : J \u2964 TypeMax.{v, u}} {j j' : J} {x : F.obj j} (f : j \u27f6 j') :\n    colimit.\u03b9 F j' (F.map f x) = colimit.\u03b9 F j x", "start": [417, 1], "end": [419, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Colimit.\u03b9_desc_apply", "code": "theorem Colimit.\u03b9_desc_apply (F : J \u2964 TypeMax.{v, u}) (s : Cocone F) (j : J) (x : F.obj j) :\n    colimit.desc F s (colimit.\u03b9 F j x) = s.\u03b9.app j x", "start": [423, 1], "end": [425, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Colimit.\u03b9_map_apply", "code": "theorem Colimit.\u03b9_map_apply {F G : J \u2964 TypeMax.{v, u}} (\u03b1 : F \u27f6 G) (j : J) (x : F.obj j) :\n    colim.{v, v}.map \u03b1 (colimit.\u03b9 F j x) = colimit.\u03b9 G j (\u03b1.app j x)", "start": [429, 1], "end": [431, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Colimit.w_apply'", "code": "@[simp]\ntheorem Colimit.w_apply' {F : J \u2964 Type v} {j j' : J} {x : F.obj j} (f : j \u27f6 j') :\n    colimit.\u03b9 F j' (F.map f x) = colimit.\u03b9 F j x", "start": [434, 1], "end": [437, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Colimit.\u03b9_desc_apply'", "code": "@[simp]\ntheorem Colimit.\u03b9_desc_apply' (F : J \u2964 Type v) (s : Cocone F) (j : J) (x : F.obj j) :\n    colimit.desc F s (colimit.\u03b9 F j x) = s.\u03b9.app j x", "start": [440, 1], "end": [443, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Colimit.\u03b9_map_apply'", "code": "@[simp]\ntheorem Colimit.\u03b9_map_apply' {F G : J \u2964 Type v} (\u03b1 : F \u27f6 G) (j : J) (x) :\n    colim.map \u03b1 (colimit.\u03b9 F j x) = colimit.\u03b9 G j (\u03b1.app j x)", "start": [446, 1], "end": [449, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.colimit_sound", "code": "theorem colimit_sound {F : J \u2964 TypeMax.{v, u}} {j j' : J} {x : F.obj j} {x' : F.obj j'} (f : j \u27f6 j')\n    (w : F.map f x = x') : colimit.\u03b9 F j x = colimit.\u03b9 F j' x'", "start": [452, 1], "end": [454, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.colimit_sound'", "code": "theorem colimit_sound' {F : J \u2964 TypeMax.{v, u}} {j j' : J} {x : F.obj j} {x' : F.obj j'} {j'' : J}\n    (f : j \u27f6 j'') (f' : j' \u27f6 j'') (w : F.map f x = F.map f' x') :\n    colimit.\u03b9 F j x = colimit.\u03b9 F j' x'", "start": [457, 1], "end": [461, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.colimit_eq", "code": "theorem colimit_eq {F : J \u2964 TypeMax.{v, u}} {j j' : J} {x : F.obj j} {x' : F.obj j'}\n    (w : colimit.\u03b9 F j x = colimit.\u03b9 F j' x') :\n      EqvGen (Quot.Rel.{v, u} F) \u27e8j, x\u27e9 \u27e8j', x'\u27e9", "start": [464, 1], "end": [468, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.jointly_surjective", "code": "theorem jointly_surjective (F : J \u2964 TypeMax.{v, u}) {t : Cocone F} (h : IsColimit t) (x : t.pt) :\n    \u2203 j y, t.\u03b9.app j y = x", "start": [471, 1], "end": [480, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.jointly_surjective'", "code": "theorem jointly_surjective' {F : J \u2964 TypeMax.{v, u}} (x : colimit F) :\n    \u2203 j y, colimit.\u03b9 F j y = x", "start": [483, 1], "end": [486, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.FilteredColimit.Rel", "code": "protected def Rel (x y : \u03a3 j, F.obj j) : Prop :=\n  \u2203 (k : _) (f : x.1 \u27f6 k) (g : y.1 \u27f6 k), F.map f x.2 = F.map g y.2", "start": [496, 1], "end": [504, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.FilteredColimit.rel_of_quot_rel", "code": "theorem rel_of_quot_rel (x y : \u03a3 j, F.obj j) :\n    Quot.Rel.{v, u} F x y \u2192 FilteredColimit.Rel.{v, u} F x y", "start": [507, 1], "end": [509, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.FilteredColimit.eqvGen_quot_rel_of_rel", "code": "theorem eqvGen_quot_rel_of_rel (x y : \u03a3 j, F.obj j) :\n    FilteredColimit.Rel.{v, u} F x y \u2192 EqvGen (Quot.Rel.{v, u} F) x y", "start": [512, 1], "end": [516, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.FilteredColimit.isColimitOf", "code": "noncomputable def isColimitOf (t : Cocone F) (hsurj : \u2200 x : t.pt, \u2203 i xi, x = t.\u03b9.app i xi)\n    (hinj :\n      \u2200 i j xi xj,\n        t.\u03b9.app i xi = t.\u03b9.app j xj \u2192 \u2203 (k : _) (f : i \u27f6 k) (g : j \u27f6 k), F.map f xi = F.map g xj) :\n    IsColimit t := by\n  apply IsColimit.ofIsoColimit (colimit.isColimit F)\n  refine' Cocones.ext (Equiv.toIso (Equiv.ofBijective _ _)) _\n  \u00b7 exact colimit.desc F t\n  \u00b7 constructor\n    \u00b7 show Function.Injective _\n      intro a b h\n      rcases jointly_surjective.{v, u} F (colimit.isColimit F) a with \u27e8i, xi, rfl\u27e9\n      rcases jointly_surjective.{v, u} F (colimit.isColimit F) b with \u27e8j, xj, rfl\u27e9\n      replace h : (colimit.\u03b9 F i \u226b colimit.desc F t) xi = (colimit.\u03b9 F j \u226b colimit.desc F t) xj := h\n      rw [colimit.\u03b9_desc, colimit.\u03b9_desc] at h\n      rcases hinj i j xi xj h with \u27e8k, f, g, h'\u27e9\n      change colimit.\u03b9 F i xi = colimit.\u03b9 F j xj\n      rw [\u2190 colimit.w F f, \u2190 colimit.w F g]\n      change colimit.\u03b9 F k (F.map f xi) = colimit.\u03b9 F k (F.map g xj)\n      rw [h']\n    \u00b7 show Function.Surjective _\n      intro x\n      rcases hsurj x with \u27e8i, xi, rfl\u27e9\n      use colimit.\u03b9 F i xi\n      apply Colimit.\u03b9_desc_apply.{v, u}\n  \u00b7 intro j\n    apply colimit.\u03b9_desc", "start": [521, 1], "end": [550, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.FilteredColimit.rel_equiv", "code": "protected theorem rel_equiv : _root_.Equivalence (FilteredColimit.Rel.{v, u} F) where", "start": [555, 1], "end": [569, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.FilteredColimit.rel_eq_eqvGen_quot_rel", "code": "protected theorem rel_eq_eqvGen_quot_rel :\n    FilteredColimit.Rel.{v, u} F = EqvGen (Quot.Rel.{v, u} F)", "start": [572, 1], "end": [578, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff_aux", "code": "theorem colimit_eq_iff_aux {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    (colimitCocone.{v, u} F).\u03b9.app i xi = (colimitCocone.{v, u} F).\u03b9.app j xj \u2194\n      FilteredColimit.Rel.{v, u} F \u27e8i, xi\u27e9 \u27e8j, xj\u27e9", "start": [581, 1], "end": [585, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.FilteredColimit.isColimit_eq_iff", "code": "theorem isColimit_eq_iff {t : Cocone F} (ht : IsColimit t) {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    t.\u03b9.app i xi = t.\u03b9.app j xj \u2194 \u2203 (k : _) (f : i \u27f6 k) (g : j \u27f6 k), F.map f xi = F.map g xj", "start": [588, 1], "end": [595, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.FilteredColimit.colimit_eq_iff", "code": "theorem colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :\n    colimit.\u03b9 F i xi = colimit.\u03b9 F j xj \u2194\n      \u2203 (k : _) (f : i \u27f6 k) (g : j \u27f6 k), F.map f xi = F.map g xj", "start": [598, 1], "end": [601, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Image", "code": "def Image : Type u :=\n  Set.range f", "start": [611, 1], "end": [613, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Image.\u03b9", "code": "def Image.\u03b9 : Image f \u27f6 \u03b2 :=\n  Subtype.val", "start": [618, 1], "end": [620, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Image.lift", "code": "noncomputable def Image.lift (F' : MonoFactorisation f) : Image f \u27f6 F'.I :=\n  (fun x => F'.e (Classical.indefiniteDescription _ x.2).1 : Image f \u2192 F'.I)", "start": [628, 1], "end": [630, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.Image.lift_fac", "code": "theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' \u226b F'.m = Image.\u03b9 f", "start": [633, 1], "end": [637, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.monoFactorisation", "code": "def monoFactorisation : MonoFactorisation f where\n  I := Image f\n  m := Image.\u03b9 f\n  e := Set.rangeFactorization f", "start": [642, 1], "end": [646, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.isImage", "code": "noncomputable def isImage : IsImage (monoFactorisation f) where\n  lift := Image.lift\n  lift_fac := Image.lift_fac", "start": [649, 1], "end": [652, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/FunctorCategory.lean", "imports": ["Mathlib/CategoryTheory/Limits/Preserves/Limits.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.limit.lift_\u03c0_app", "code": "@[reassoc (attr := simp)]\ntheorem limit.lift_\u03c0_app (H : J \u2964 K \u2964 C) [HasLimit H] (c : Cone H) (j : J) (k : K) :\n    (limit.lift H c).app k \u226b (limit.\u03c0 H j).app k = (c.\u03c0.app j).app k", "start": [36, 1], "end": [39, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit.\u03b9_desc_app", "code": "@[reassoc (attr := simp)]\ntheorem colimit.\u03b9_desc_app (H : J \u2964 K \u2964 C) [HasColimit H] (c : Cocone H) (j : J) (k : K) :\n    (colimit.\u03b9 H j).app k \u226b (colimit.desc H c).app k = (c.\u03b9.app j).app k", "start": [42, 1], "end": [45, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.evaluationJointlyReflectsLimits", "code": "def evaluationJointlyReflectsLimits {F : J \u2964 K \u2964 C} (c : Cone F)\n    (t : \u2200 k : K, IsLimit (((evaluation K C).obj k).mapCone c)) : IsLimit c\n    where\n  lift s :=\n    { app := fun k => (t k).lift \u27e8s.pt.obj k, whiskerRight s.\u03c0 ((evaluation K C).obj k)\u27e9\n      naturality := fun X Y f =>\n        (t Y).hom_ext fun j => by\n          rw [assoc, (t Y).fac _ j]\n          simpa using\n            ((t X).fac_assoc \u27e8s.pt.obj X, whiskerRight s.\u03c0 ((evaluation K C).obj X)\u27e9 j _).symm }\n  fac s j := by ext k; exact (t k).fac _ j\n  uniq s m w := by\n    ext x\n    exact (t x).hom_ext fun j =>\n      (congr_app (w j) x).trans\n        ((t x).fac \u27e8s.pt.obj _, whiskerRight s.\u03c0 ((evaluation K C).obj _)\u27e9 j).symm", "start": [48, 1], "end": [67, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.combineCones", "code": "@[simps]\ndef combineCones (F : J \u2964 K \u2964 C) (c : \u2200 k : K, LimitCone (F.flip.obj k)) : Cone F\n    where\n  pt :=\n    { obj := fun k => (c k).cone.pt\n      map := fun {k\u2081} {k\u2082} f => (c k\u2082).isLimit.lift \u27e8_, (c k\u2081).cone.\u03c0 \u226b F.flip.map f\u27e9\n      map_id := fun k =>\n        (c k).isLimit.hom_ext fun j => by\n          dsimp\n          simp\n      map_comp := fun {k\u2081} {k\u2082} {k\u2083} f\u2081 f\u2082 => (c k\u2083).isLimit.hom_ext fun j => by simp }\n  \u03c0 :=\n    { app := fun j => { app := fun k => (c k).cone.\u03c0.app j }\n      naturality := fun j\u2081 j\u2082 g => by ext k; exact (c k).cone.\u03c0.naturality g }", "start": [70, 1], "end": [88, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.evaluateCombinedCones", "code": "def evaluateCombinedCones (F : J \u2964 K \u2964 C) (c : \u2200 k : K, LimitCone (F.flip.obj k)) (k : K) :\n    ((evaluation K C).obj k).mapCone (combineCones F c) \u2245 (c k).cone :=\n  Cones.ext (Iso.refl _)", "start": [91, 1], "end": [94, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.combinedIsLimit", "code": "def combinedIsLimit (F : J \u2964 K \u2964 C) (c : \u2200 k : K, LimitCone (F.flip.obj k)) :\n    IsLimit (combineCones F c) :=\n  evaluationJointlyReflectsLimits _ fun k =>\n    (c k).isLimit.ofIsoLimit (evaluateCombinedCones F c k).symm", "start": [97, 1], "end": [101, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.evaluationJointlyReflectsColimits", "code": "def evaluationJointlyReflectsColimits {F : J \u2964 K \u2964 C} (c : Cocone F)\n    (t : \u2200 k : K, IsColimit (((evaluation K C).obj k).mapCocone c)) : IsColimit c\n    where\n  desc s :=\n    { app := fun k => (t k).desc \u27e8s.pt.obj k, whiskerRight s.\u03b9 ((evaluation K C).obj k)\u27e9\n      naturality := fun X Y f =>\n        (t X).hom_ext fun j => by\n          rw [(t X).fac_assoc _ j]\n          erw [\u2190 (c.\u03b9.app j).naturality_assoc f]\n          erw [(t Y).fac \u27e8s.pt.obj _, whiskerRight s.\u03b9 _\u27e9 j]\n          dsimp\n          simp }\n  fac s j := by ext k; exact (t k).fac _ j\n  uniq s m w := by\n    ext x\n    exact (t x).hom_ext fun j =>\n      (congr_app (w j) x).trans\n        ((t x).fac \u27e8s.pt.obj _, whiskerRight s.\u03b9 ((evaluation K C).obj _)\u27e9 j).symm", "start": [104, 1], "end": [125, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.combineCocones", "code": "@[simps]\ndef combineCocones (F : J \u2964 K \u2964 C) (c : \u2200 k : K, ColimitCocone (F.flip.obj k)) : Cocone F\n    where\n  pt :=\n    { obj := fun k => (c k).cocone.pt\n      map := fun {k\u2081} {k\u2082} f => (c k\u2081).isColimit.desc \u27e8_, F.flip.map f \u226b (c k\u2082).cocone.\u03b9\u27e9\n      map_id := fun k =>\n        (c k).isColimit.hom_ext fun j => by\n          dsimp\n          simp\n      map_comp := fun {k\u2081} {k\u2082} {k\u2083} f\u2081 f\u2082 => (c k\u2081).isColimit.hom_ext fun j => by simp }\n  \u03b9 :=\n    { app := fun j => { app := fun k => (c k).cocone.\u03b9.app j }\n      naturality := fun j\u2081 j\u2082 g => by ext k; exact (c k).cocone.\u03b9.naturality g }", "start": [128, 1], "end": [147, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.evaluateCombinedCocones", "code": "def evaluateCombinedCocones (F : J \u2964 K \u2964 C) (c : \u2200 k : K, ColimitCocone (F.flip.obj k)) (k : K) :\n    ((evaluation K C).obj k).mapCocone (combineCocones F c) \u2245 (c k).cocone :=\n  Cocones.ext (Iso.refl _)", "start": [150, 1], "end": [153, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.combinedIsColimit", "code": "def combinedIsColimit (F : J \u2964 K \u2964 C) (c : \u2200 k : K, ColimitCocone (F.flip.obj k)) :\n    IsColimit (combineCocones F c) :=\n  evaluationJointlyReflectsColimits _ fun k =>\n    (c k).isColimit.ofIsoColimit (evaluateCombinedCocones F c k).symm", "start": [156, 1], "end": [160, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.functorCategoryHasLimitsOfShape", "code": "instance functorCategoryHasLimitsOfShape [HasLimitsOfShape J C] : HasLimitsOfShape J (K \u2964 C) where\n  has_limit F :=\n    HasLimit.mk\n      { cone := combineCones F fun _ => getLimitCone _\n        isLimit := combinedIsLimit _ _ }", "start": [165, 1], "end": [169, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.functorCategoryHasColimitsOfShape", "code": "instance functorCategoryHasColimitsOfShape [HasColimitsOfShape J C] : HasColimitsOfShape J (K \u2964 C)\n    where\n  has_colimit _ :=\n    HasColimit.mk\n      { cocone := combineCocones _ fun _ => getColimitCocone _\n        isColimit := combinedIsColimit _ _ }", "start": [172, 1], "end": [177, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.functorCategoryHasLimitsOfSize", "code": "instance functorCategoryHasLimitsOfSize [HasLimitsOfSize.{v\u2081, u\u2081} C] :\n    HasLimitsOfSize.{v\u2081, u\u2081} (K \u2964 C) where\n  has_limits_of_shape := fun _ _ => inferInstance", "start": [181, 1], "end": [183, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.functorCategoryHasColimitsOfSize", "code": "instance functorCategoryHasColimitsOfSize [HasColimitsOfSize.{v\u2081, u\u2081} C] :\n    HasColimitsOfSize.{v\u2081, u\u2081} (K \u2964 C) where\n  has_colimits_of_shape := fun _ _ => inferInstance", "start": [187, 1], "end": [189, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.evaluationPreservesLimitsOfShape", "code": "instance evaluationPreservesLimitsOfShape [HasLimitsOfShape J C] (k : K) :\n    PreservesLimitsOfShape J ((evaluation K C).obj k) where\n  preservesLimit {F} := by\n    let X : (k:K) \u2192 LimitCone (Prefunctor.obj (Functor.flip F).toPrefunctor k) :=\n      fun k => getLimitCone (Prefunctor.obj (Functor.flip F).toPrefunctor k)\n    exact preservesLimitOfPreservesLimitCone (combinedIsLimit _ _) <|\n      IsLimit.ofIsoLimit (limit.isLimit _) (evaluateCombinedCones F X k).symm", "start": [192, 1], "end": [199, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitObjIsoLimitCompEvaluation", "code": "def limitObjIsoLimitCompEvaluation [HasLimitsOfShape J C] (F : J \u2964 K \u2964 C) (k : K) :\n    (limit F).obj k \u2245 limit (F \u22d9 (evaluation K C).obj k) :=\n  preservesLimitIso ((evaluation K C).obj k) F", "start": [202, 1], "end": [207, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitObjIsoLimitCompEvaluation_hom_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem limitObjIsoLimitCompEvaluation_hom_\u03c0 [HasLimitsOfShape J C] (F : J \u2964 K \u2964 C) (j : J)\n    (k : K) :\n    (limitObjIsoLimitCompEvaluation F k).hom \u226b limit.\u03c0 (F \u22d9 (evaluation K C).obj k) j =\n      (limit.\u03c0 F j).app k", "start": [210, 1], "end": [216, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitObjIsoLimitCompEvaluation_inv_\u03c0_app", "code": "@[reassoc (attr := simp)]\ntheorem limitObjIsoLimitCompEvaluation_inv_\u03c0_app [HasLimitsOfShape J C] (F : J \u2964 K \u2964 C) (j : J)\n    (k : K) :\n    (limitObjIsoLimitCompEvaluation F k).inv \u226b (limit.\u03c0 F j).app k =\n      limit.\u03c0 (F \u22d9 (evaluation K C).obj k) j", "start": [219, 1], "end": [226, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit_map_limitObjIsoLimitCompEvaluation_hom", "code": "@[reassoc (attr := simp)]\ntheorem limit_map_limitObjIsoLimitCompEvaluation_hom [HasLimitsOfShape J C] {i j : K}\n    (F : J \u2964 K \u2964 C) (f : i \u27f6 j) : (limit F).map f \u226b (limitObjIsoLimitCompEvaluation _ _).hom =\n    (limitObjIsoLimitCompEvaluation _ _).hom \u226b limMap (whiskerLeft _ ((evaluation _ _).map f))", "start": [229, 1], "end": [235, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitObjIsoLimitCompEvaluation_inv_limit_map", "code": "@[reassoc (attr := simp)]\ntheorem limitObjIsoLimitCompEvaluation_inv_limit_map [HasLimitsOfShape J C] {i j : K}\n    (F : J \u2964 K \u2964 C) (f : i \u27f6 j) : (limitObjIsoLimitCompEvaluation _ _).inv \u226b (limit F).map f =\n    limMap (whiskerLeft _ ((evaluation _ _).map f)) \u226b (limitObjIsoLimitCompEvaluation _ _).inv", "start": [238, 1], "end": [243, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limit_obj_ext", "code": "@[ext]\ntheorem limit_obj_ext {H : J \u2964 K \u2964 C} [HasLimitsOfShape J C] {k : K} {W : C}\n    {f g : W \u27f6 (limit H).obj k}\n    (w : \u2200 j, f \u226b (Limits.limit.\u03c0 H j).app k = g \u226b (Limits.limit.\u03c0 H j).app k) : f = g", "start": [246, 1], "end": [252, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.evaluationPreservesColimitsOfShape", "code": "instance evaluationPreservesColimitsOfShape [HasColimitsOfShape J C] (k : K) :\n    PreservesColimitsOfShape J ((evaluation K C).obj k) where\n  preservesColimit {F} := by\n    let X : (k:K) \u2192 ColimitCocone (Prefunctor.obj (Functor.flip F).toPrefunctor k) :=\n      fun k => getColimitCocone (Prefunctor.obj (Functor.flip F).toPrefunctor k)\n    refine preservesColimitOfPreservesColimitCocone (combinedIsColimit _ _) <|\n      IsColimit.ofIsoColimit (colimit.isColimit _) (evaluateCombinedCocones F X k).symm", "start": [255, 1], "end": [262, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation", "code": "def colimitObjIsoColimitCompEvaluation [HasColimitsOfShape J C] (F : J \u2964 K \u2964 C) (k : K) :\n    (colimit F).obj k \u2245 colimit (F \u22d9 (evaluation K C).obj k) :=\n  preservesColimitIso ((evaluation K C).obj k) F", "start": [265, 1], "end": [270, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation_\u03b9_inv", "code": "@[reassoc (attr := simp)]\ntheorem colimitObjIsoColimitCompEvaluation_\u03b9_inv [HasColimitsOfShape J C] (F : J \u2964 K \u2964 C) (j : J)\n    (k : K) :\n    colimit.\u03b9 (F \u22d9 (evaluation K C).obj k) j \u226b (colimitObjIsoColimitCompEvaluation F k).inv =\n      (colimit.\u03b9 F j).app k", "start": [273, 1], "end": [279, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation_\u03b9_app_hom", "code": "@[reassoc (attr := simp)]\ntheorem colimitObjIsoColimitCompEvaluation_\u03b9_app_hom [HasColimitsOfShape J C] (F : J \u2964 K \u2964 C)\n    (j : J) (k : K) :\n    (colimit.\u03b9 F j).app k \u226b (colimitObjIsoColimitCompEvaluation F k).hom =\n      colimit.\u03b9 (F \u22d9 (evaluation K C).obj k) j", "start": [282, 1], "end": [289, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation_inv_colimit_map", "code": "@[reassoc (attr := simp)]\ntheorem colimitObjIsoColimitCompEvaluation_inv_colimit_map [HasColimitsOfShape J C] (F : J \u2964 K \u2964 C)\n    {i j : K} (f : i \u27f6 j) :\n    (colimitObjIsoColimitCompEvaluation _ _).inv \u226b (colimit F).map f =\n      colimMap (whiskerLeft _ ((evaluation _ _).map f)) \u226b\n        (colimitObjIsoColimitCompEvaluation _ _).inv", "start": [292, 1], "end": [300, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit_map_colimitObjIsoColimitCompEvaluation_hom", "code": "@[reassoc (attr := simp)]\ntheorem colimit_map_colimitObjIsoColimitCompEvaluation_hom [HasColimitsOfShape J C] (F : J \u2964 K \u2964 C)\n    {i j : K} (f : i \u27f6 j) :\n    (colimit F).map f \u226b (colimitObjIsoColimitCompEvaluation _ _).hom =\n      (colimitObjIsoColimitCompEvaluation _ _).hom \u226b\n        colimMap (whiskerLeft _ ((evaluation _ _).map f))", "start": [303, 1], "end": [310, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimit_obj_ext", "code": "@[ext]\ntheorem colimit_obj_ext {H : J \u2964 K \u2964 C} [HasColimitsOfShape J C] {k : K} {W : C}\n    {f g : (colimit H).obj k \u27f6 W} (w : \u2200 j, (colimit.\u03b9 H j).app k \u226b f = (colimit.\u03b9 H j).app k \u226b g) :\n    f = g", "start": [313, 1], "end": [319, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.evaluationPreservesLimits", "code": "instance evaluationPreservesLimits [HasLimits C] (k : K) :\n    PreservesLimits ((evaluation K C).obj k) where\n  preservesLimitsOfShape {J} \ud835\udca5 := by skip; infer_instance", "start": [322, 1], "end": [324, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitOfEvaluation", "code": "def preservesLimitOfEvaluation (F : D \u2964 K \u2964 C) (G : J \u2964 D)\n    (H : \u2200 k : K, PreservesLimit G (F \u22d9 (evaluation K C).obj k : D \u2964 C)) : PreservesLimit G F :=\n  \u27e8fun {c} hc => by\n    apply evaluationJointlyReflectsLimits\n    intro X\n    haveI := H X\n    change IsLimit ((F \u22d9 (evaluation K C).obj X).mapCone c)\n    exact PreservesLimit.preserves hc\u27e9", "start": [327, 1], "end": [335, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOfShapeOfEvaluation", "code": "def preservesLimitsOfShapeOfEvaluation (F : D \u2964 K \u2964 C) (J : Type*) [Category J]\n    (_ : \u2200 k : K, PreservesLimitsOfShape J (F \u22d9 (evaluation K C).obj k)) :\n    PreservesLimitsOfShape J F :=\n  \u27e8fun {G} => preservesLimitOfEvaluation F G fun _ => PreservesLimitsOfShape.preservesLimit\u27e9", "start": [338, 1], "end": [342, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOfEvaluation", "code": "def preservesLimitsOfEvaluation (F : D \u2964 K \u2964 C)\n    (_ : \u2200 k : K, PreservesLimitsOfSize.{w', w} (F \u22d9 (evaluation K C).obj k)) :\n    PreservesLimitsOfSize.{w', w} F :=\n  \u27e8fun {L} _ =>\n    preservesLimitsOfShapeOfEvaluation F L fun _ => PreservesLimitsOfSize.preservesLimitsOfShape\u27e9", "start": [345, 1], "end": [350, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsConst", "code": "instance preservesLimitsConst : PreservesLimitsOfSize.{w', w} (const D : C \u2964 _) :=\n  preservesLimitsOfEvaluation _ fun _ =>\n    preservesLimitsOfNatIso <| Iso.symm <| constCompEvaluationObj _ _", "start": [353, 1], "end": [356, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.evaluationPreservesColimits", "code": "instance evaluationPreservesColimits [HasColimits C] (k : K) :\n    PreservesColimits ((evaluation K C).obj k) where\n  preservesColimitsOfShape := by skip; infer_instance", "start": [359, 1], "end": [361, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitOfEvaluation", "code": "def preservesColimitOfEvaluation (F : D \u2964 K \u2964 C) (G : J \u2964 D)\n    (H : \u2200 k, PreservesColimit G (F \u22d9 (evaluation K C).obj k)) : PreservesColimit G F :=\n  \u27e8fun {c} hc => by\n    apply evaluationJointlyReflectsColimits\n    intro X\n    haveI := H X\n    change IsColimit ((F \u22d9 (evaluation K C).obj X).mapCocone c)\n    exact PreservesColimit.preserves hc\u27e9", "start": [364, 1], "end": [372, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsOfShapeOfEvaluation", "code": "def preservesColimitsOfShapeOfEvaluation (F : D \u2964 K \u2964 C) (J : Type*) [Category J]\n    (_ : \u2200 k : K, PreservesColimitsOfShape J (F \u22d9 (evaluation K C).obj k)) :\n    PreservesColimitsOfShape J F :=\n  \u27e8fun {G} => preservesColimitOfEvaluation F G fun _ => PreservesColimitsOfShape.preservesColimit\u27e9", "start": [375, 1], "end": [379, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsOfEvaluation", "code": "def preservesColimitsOfEvaluation (F : D \u2964 K \u2964 C)\n    (_ : \u2200 k : K, PreservesColimitsOfSize.{w', w} (F \u22d9 (evaluation K C).obj k)) :\n    PreservesColimitsOfSize.{w', w} F :=\n  \u27e8fun {L} _ =>\n    preservesColimitsOfShapeOfEvaluation F L fun _ =>\n      PreservesColimitsOfSize.preservesColimitsOfShape\u27e9", "start": [382, 1], "end": [388, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsConst", "code": "instance preservesColimitsConst : PreservesColimitsOfSize.{w', w} (const D : C \u2964 _) :=\n  preservesColimitsOfEvaluation _ fun _ =>\n    preservesColimitsOfNatIso <| Iso.symm <| constCompEvaluationObj _ _", "start": [391, 1], "end": [394, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitIsoFlipCompLim", "code": "@[simps!]\ndef limitIsoFlipCompLim [HasLimitsOfShape J C] (F : J \u2964 K \u2964 C) : limit F \u2245 F.flip \u22d9 lim :=\n  NatIso.ofComponents (limitObjIsoLimitCompEvaluation F)", "start": [399, 1], "end": [403, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitFlipIsoCompLim", "code": "@[simps!]\ndef limitFlipIsoCompLim [HasLimitsOfShape J C] (F : K \u2964 J \u2964 C) : limit F.flip \u2245 F \u22d9 lim :=\n  let f := fun k =>\n    limitObjIsoLimitCompEvaluation F.flip k \u226a\u226b HasLimit.isoOfNatIso (flipCompEvaluation _ _)\n  NatIso.ofComponents f", "start": [406, 1], "end": [411, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitIsoSwapCompLim", "code": "@[simps!]\ndef limitIsoSwapCompLim [HasLimitsOfShape J C] (G : J \u2964 K \u2964 C) :\n    limit G \u2245 curry.obj (Prod.swap K J \u22d9 uncurry.obj G) \u22d9 lim :=\n  limitIsoFlipCompLim G \u226a\u226b isoWhiskerRight (flipIsoCurrySwapUncurry _) _", "start": [414, 1], "end": [420, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimitIsoFlipCompColim", "code": "@[simps!]\ndef colimitIsoFlipCompColim [HasColimitsOfShape J C] (F : J \u2964 K \u2964 C) : colimit F \u2245 F.flip \u22d9 colim :=\n  NatIso.ofComponents (colimitObjIsoColimitCompEvaluation F)", "start": [423, 1], "end": [427, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimitFlipIsoCompColim", "code": "@[simps!]\ndef colimitFlipIsoCompColim [HasColimitsOfShape J C] (F : K \u2964 J \u2964 C) : colimit F.flip \u2245 F \u22d9 colim :=\n  let f := fun k =>\n      colimitObjIsoColimitCompEvaluation _ _ \u226a\u226b HasColimit.isoOfNatIso (flipCompEvaluation _ _)\n  NatIso.ofComponents f", "start": [430, 1], "end": [435, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.colimitIsoSwapCompColim", "code": "@[simps!]\ndef colimitIsoSwapCompColim [HasColimitsOfShape J C] (G : J \u2964 K \u2964 C) :\n    colimit G \u2245 curry.obj (Prod.swap K J \u22d9 uncurry.obj G) \u22d9 colim :=\n  colimitIsoFlipCompColim G \u226a\u226b isoWhiskerRight (flipIsoCurrySwapUncurry _) _", "start": [438, 1], "end": [444, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Elements.lean", "imports": ["Mathlib/CategoryTheory/Groupoid.lean", "Mathlib/CategoryTheory/StructuredArrow.lean", "Mathlib/CategoryTheory/PUnit.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.Elements", "code": "def Functor.Elements (F : C \u2964 Type w) :=\n  \u03a3c : C, F.obj c", "start": [43, 1], "end": [47, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.Elements.ext", "code": "lemma Functor.Elements.ext {F : C \u2964 Type w} (x y : F.Elements) (h\u2081 : x.fst = y.fst)\n    (h\u2082 : F.map (eqToHom h\u2081) x.snd = y.snd) : x = y := by\n  cases x\n  cases y\n  cases h\u2081\n  simp only [eqToHom_refl, FunctorToTypes.map_id_apply] at h\u2082\n  simp [h\u2082]", "start": [51, 1], "end": [57, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.categoryOfElements", "code": "instance categoryOfElements (F : C \u2964 Type w) : Category.{v} F.Elements where\n  Hom p q := { f : p.1 \u27f6 q.1 // (F.map f) p.2 = q.2 }\n  id p := \u27e8\ud835\udfd9 p.1, by aesop_cat\u27e9\n  comp {X Y Z} f g := \u27e8f.val \u226b g.val, by simp [f.2, g.2]\u27e9", "start": [59, 1], "end": [65, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.ext", "code": "@[ext]\ntheorem ext (F : C \u2964 Type w) {x y : F.Elements} (f g : x \u27f6 y) (w : f.val = g.val) : f = g", "start": [70, 1], "end": [72, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.comp_val", "code": "@[simp]\ntheorem comp_val {F : C \u2964 Type w} {p q r : F.Elements} {f : p \u27f6 q} {g : q \u27f6 r} :\n    (f \u226b g).val = f.val \u226b g.val", "start": [75, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.id_val", "code": "@[simp]\ntheorem id_val {F : C \u2964 Type w} {p : F.Elements} : (\ud835\udfd9 p : p \u27f6 p).val = \ud835\udfd9 p.1", "start": [81, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.groupoidOfElements", "code": "instance groupoidOfElements {G : Type u} [Groupoid.{v} G] (F : G \u2964 Type w) :\n    Groupoid F.Elements\n    where\n  inv {p q} f :=\n    \u27e8Groupoid.inv f.val,\n      calc\n        F.map (Groupoid.inv f.val) q.2 = F.map (Groupoid.inv f.val) (F.map f.val p.2) := by rw [f.2]\n        _ = (F.map f.val \u226b F.map (Groupoid.inv f.val)) p.2 := rfl\n        _ = p.2 := by\n          rw [\u2190 F.map_comp]\n          simp\n        \u27e9\n  inv_comp _ := by\n    ext\n    simp\n  comp_inv _ := by\n    ext\n    simp", "start": [88, 1], "end": [105, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.\u03c0", "code": "@[simps]\ndef \u03c0 : F.Elements \u2964 C where\n  obj X := X.1\n  map f := f.val", "start": [112, 1], "end": [116, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.map", "code": "@[simps]\ndef map {F\u2081 F\u2082 : C \u2964 Type w} (\u03b1 : F\u2081 \u27f6 F\u2082) : F\u2081.Elements \u2964 F\u2082.Elements\n    where\n  obj t := \u27e8t.1, \u03b1.app t.1 t.2\u27e9\n  map {t\u2081 t\u2082} k := \u27e8k.1, by simpa [\u2190 k.2] using (FunctorToTypes.naturality _ _ \u03b1 k.1 t\u2081.2).symm\u27e9", "start": [119, 1], "end": [125, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.map_\u03c0", "code": "@[simp]\ntheorem map_\u03c0 {F\u2081 F\u2082 : C \u2964 Type w} (\u03b1 : F\u2081 \u27f6 F\u2082) : map \u03b1 \u22d9 \u03c0 F\u2082 = \u03c0 F\u2081", "start": [128, 1], "end": [130, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.toStructuredArrow", "code": "def toStructuredArrow : F.Elements \u2964 StructuredArrow PUnit F where\n  obj X := StructuredArrow.mk fun _ => X.2\n  map {X Y} f := StructuredArrow.homMk f.val (by funext; simp [f.2])", "start": [133, 1], "end": [136, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.toStructuredArrow_obj", "code": "@[simp]\ntheorem toStructuredArrow_obj (X) :\n    (toStructuredArrow F).obj X =\n      { left := \u27e8\u27e8\u27e9\u27e9\n        right := X.1\n        hom := fun _ => X.2 }", "start": [139, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.to_comma_map_right", "code": "@[simp]\ntheorem to_comma_map_right {X Y} (f : X \u27f6 Y) : ((toStructuredArrow F).map f).right = f.val", "start": [148, 1], "end": [150, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.fromStructuredArrow", "code": "def fromStructuredArrow : StructuredArrow PUnit F \u2964 F.Elements where\n  obj X := \u27e8X.right, X.hom PUnit.unit\u27e9\n  map f := \u27e8f.right, congr_fun f.w.symm PUnit.unit\u27e9", "start": [153, 1], "end": [156, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.fromStructuredArrow_obj", "code": "@[simp]\ntheorem fromStructuredArrow_obj (X) : (fromStructuredArrow F).obj X = \u27e8X.right, X.hom PUnit.unit\u27e9", "start": [159, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.fromStructuredArrow_map", "code": "@[simp]\ntheorem fromStructuredArrow_map {X Y} (f : X \u27f6 Y) :\n    (fromStructuredArrow F).map f = \u27e8f.right, congr_fun f.w.symm PUnit.unit\u27e9", "start": [164, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.structuredArrowEquivalence", "code": "@[simps! functor_obj functor_map inverse_obj inverse_map unitIso_hom\n  unitIso_inv counitIso_hom counitIso_inv]\ndef structuredArrowEquivalence : F.Elements \u224c StructuredArrow PUnit F :=\n  Equivalence.mk (toStructuredArrow F) (fromStructuredArrow F)\n    (NatIso.ofComponents fun X => eqToIso (by aesop_cat))\n    (NatIso.ofComponents fun X => StructuredArrow.isoMk (Iso.refl _))", "start": [170, 1], "end": [177, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.toCostructuredArrow", "code": "@[simps]\ndef toCostructuredArrow (F : C\u1d52\u1d56 \u2964 Type v) : F.Elements\u1d52\u1d56 \u2964 CostructuredArrow yoneda F\n    where\n  obj X := CostructuredArrow.mk ((yonedaSections (unop (unop X).fst) F).inv (ULift.up (unop X).2))\n  map f := by\n    fapply CostructuredArrow.homMk\n    \u00b7 exact f.unop.val.unop\n    \u00b7 ext Z y\n      dsimp\n      simp only [FunctorToTypes.map_comp_apply, \u2190 f.unop.2]", "start": [182, 1], "end": [194, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.fromCostructuredArrow", "code": "@[simps]\ndef fromCostructuredArrow (F : C\u1d52\u1d56 \u2964 Type v) : (CostructuredArrow yoneda F)\u1d52\u1d56 \u2964 F.Elements where\n  obj X := \u27e8op (unop X).1, yonedaEquiv.1 (unop X).3\u27e9\n  map {X Y} f :=\n    \u27e8f.unop.1.op, by\n      convert (congr_fun ((unop X).hom.naturality f.unop.left.op) (\ud835\udfd9 _)).symm\n      simp only [Equiv.toFun_as_coe, Quiver.Hom.unop_op, yonedaEquiv_apply, types_comp_apply,\n        Category.comp_id, yoneda_obj_map]\n      have : yoneda.map f.unop.left \u226b (unop X).hom = (unop Y).hom := by\n        convert f.unop.3\n      erw [\u2190 this]\n      simp only [yoneda_map_app, FunctorToTypes.comp]\n      erw [Category.id_comp]\u27e9", "start": [197, 1], "end": [212, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.fromCostructuredArrow_obj_mk", "code": "@[simp]\ntheorem fromCostructuredArrow_obj_mk (F : C\u1d52\u1d56 \u2964 Type v) {X : C} (f : yoneda.obj X \u27f6 F) :\n    (fromCostructuredArrow F).obj (op (CostructuredArrow.mk f)) = \u27e8op X, yonedaEquiv.1 f\u27e9", "start": [215, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.from_toCostructuredArrow_eq", "code": "theorem from_toCostructuredArrow_eq (F : C\u1d52\u1d56 \u2964 Type v) :\n    (toCostructuredArrow F).rightOp \u22d9 fromCostructuredArrow F = \ud835\udfed _", "start": [221, 1], "end": [233, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.to_fromCostructuredArrow_eq", "code": "theorem to_fromCostructuredArrow_eq (F : C\u1d52\u1d56 \u2964 Type v) :\n    (fromCostructuredArrow F).rightOp \u22d9 toCostructuredArrow F = \ud835\udfed _", "start": [236, 1], "end": [251, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence", "code": "@[simps! functor_obj functor_map inverse_obj inverse_map unitIso_inv counitIso_hom counitIso_inv]\ndef costructuredArrowYonedaEquivalence (F : C\u1d52\u1d56 \u2964 Type v) :\n    F.Elements\u1d52\u1d56 \u224c CostructuredArrow yoneda F :=\n  Equivalence.mk (toCostructuredArrow F) (fromCostructuredArrow F).rightOp\n    (NatIso.op (eqToIso (from_toCostructuredArrow_eq F))) (eqToIso <| to_fromCostructuredArrow_eq F)", "start": [254, 1], "end": [259, 101], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryOfElements.costructuredArrow_yoneda_equivalence_naturality", "code": "theorem costructuredArrow_yoneda_equivalence_naturality {F\u2081 F\u2082 : C\u1d52\u1d56 \u2964 Type v} (\u03b1 : F\u2081 \u27f6 F\u2082) :\n    (map \u03b1).op \u22d9 toCostructuredArrow F\u2082 = toCostructuredArrow F\u2081 \u22d9 CostructuredArrow.map \u03b1", "start": [267, 1], "end": [280, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/KanExtension.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "Mathlib/CategoryTheory/StructuredArrow.lean", "Mathlib/CategoryTheory/PUnit.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Ran.diagram", "code": "abbrev diagram (F : S \u2964 D) (x : L) : StructuredArrow x \u03b9 \u2964 D :=\n  StructuredArrow.proj x \u03b9 \u22d9 F", "start": [52, 1], "end": [54, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Ran.cone", "code": "@[simp]\ndef cone {F : S \u2964 D} {G : L \u2964 D} (x : L) (f : \u03b9 \u22d9 G \u27f6 F) : Cone (diagram \u03b9 F x)\n    where\n  pt := G.obj x\n  \u03c0 :=\n    { app := fun i => G.map i.hom \u226b f.app i.right\n      naturality := by\n        rintro \u27e8\u27e8il\u27e9, ir, i\u27e9 \u27e8\u27e8jl\u27e9, jr, j\u27e9 \u27e8\u27e8\u27e8fl\u27e9\u27e9, fr, ff\u27e9\n        dsimp at *\n        dsimp at ff\n        simp only [Category.id_comp, Category.assoc] at *\n        rw [ff]\n        have := f.naturality\n        aesop_cat }", "start": [60, 1], "end": [74, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Ran.loc", "code": "@[simps]\ndef loc (F : S \u2964 D) [h : \u2200 x, HasLimit (diagram \u03b9 F x)] : L \u2964 D\n    where\n  obj x := limit (diagram \u03b9 F x)\n  map {X Y} f :=\n    haveI : HasLimit <| StructuredArrow.map f \u22d9 diagram \u03b9 F X := h Y\n    limit.pre (diagram \u03b9 F X) (StructuredArrow.map f)\n  map_id := by\n    intro l\n    haveI : HasLimit (StructuredArrow.map (\ud835\udfd9 _) \u22d9 diagram \u03b9 F l) := h _\n    dsimp\n    ext j\n    simp only [Category.id_comp, limit.pre_\u03c0]\n    congr 1\n    simp\n  map_comp := by\n    intro x y z f g\n    apply limit.hom_ext\n    intro j\n    haveI : HasLimit (StructuredArrow.map f \u22d9 diagram \u03b9 F _) := h _\n    haveI : HasLimit (StructuredArrow.map g \u22d9 diagram \u03b9 F _) := h _\n    haveI : HasLimit (StructuredArrow.map (f \u226b g) \u22d9 diagram \u03b9 F _) := h _\n    haveI : HasLimit (StructuredArrow.map g \u22d9 StructuredArrow.map f \u22d9 diagram \u03b9 F _) := h _\n    haveI : HasLimit ((StructuredArrow.map g \u22d9 StructuredArrow.map f) \u22d9 diagram \u03b9 F _) := h _\n    erw [limit.pre_pre, limit.pre_\u03c0, limit.pre_\u03c0]\n    congr 1\n    aesop_cat", "start": [80, 1], "end": [109, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Ran.equiv", "code": "@[simps]\ndef equiv (F : S \u2964 D) [h : \u2200 x, HasLimit (diagram \u03b9 F x)] (G : L \u2964 D) :\n    (G \u27f6 loc \u03b9 F) \u2243 (((whiskeringLeft _ _ _).obj \u03b9).obj G \u27f6 F)\n    where\n  toFun f :=\n    { app := fun x => f.app _ \u226b limit.\u03c0 (diagram \u03b9 F (\u03b9.obj x)) (StructuredArrow.mk (\ud835\udfd9 _))\n      naturality := by\n        intro x y ff\n        dsimp only [whiskeringLeft]\n        simp only [Functor.comp_map, NatTrans.naturality_assoc, loc_map, Category.assoc]\n        congr 1\n        haveI : HasLimit (StructuredArrow.map (\u03b9.map ff) \u22d9 diagram \u03b9 F (\u03b9.obj x)) := h _\n        erw [limit.pre_\u03c0]\n        let t : StructuredArrow.mk (\ud835\udfd9 (\u03b9.obj x)) \u27f6\n          (StructuredArrow.map (\u03b9.map ff)).obj (StructuredArrow.mk (\ud835\udfd9 (\u03b9.obj y))) :=\n          StructuredArrow.homMk ff ?_\n        convert (limit.w (diagram \u03b9 F (\u03b9.obj x)) t).symm using 1\n        simp }\n  invFun f :=\n    { app := fun x => limit.lift (diagram \u03b9 F x) (cone _ f)\n      naturality := by\n        intro x y ff\n        apply limit.hom_ext\n        intros j\n        haveI : HasLimit (StructuredArrow.map ff \u22d9 diagram \u03b9 F x) := h _\n        erw [limit.lift_pre, limit.lift_\u03c0, Category.assoc, limit.lift_\u03c0 (cone _ f) j]\n        simp }\n  left_inv := by\n    intro x\n    ext k\n    apply limit.hom_ext\n    intros j\n    dsimp only [cone]\n    rw [limit.lift_\u03c0]\n    simp only [NatTrans.naturality_assoc, loc_map]\n    haveI : HasLimit (StructuredArrow.map j.hom \u22d9 diagram \u03b9 F k) := h _\n    erw [limit.pre_\u03c0]\n    congr\n    rcases j with \u27e8\u27e8\u27e9, _, _\u27e9\n    aesop_cat\n  right_inv := by aesop_cat", "start": [113, 1], "end": [154, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ran", "code": "@[simps!]\ndef ran [\u2200 X, HasLimitsOfShape (StructuredArrow X \u03b9) D] : (S \u2964 D) \u2964 L \u2964 D :=\n  Adjunction.rightAdjointOfEquiv (fun F G => (Ran.equiv \u03b9 G F).symm) (by {\n    intros X' X Y f g\n    ext t\n    apply limit.hom_ext\n    intros j\n    dsimp [Ran.equiv]\n    simp })", "start": [160, 1], "end": [170, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Ran.adjunction", "code": "def adjunction [\u2200 X, HasLimitsOfShape (StructuredArrow X \u03b9) D] :\n    (whiskeringLeft _ _ D).obj \u03b9 \u22a3 ran \u03b9 :=\n  Adjunction.adjunctionOfEquivRight _ _", "start": [178, 1], "end": [181, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Ran.reflective", "code": "theorem reflective [Full \u03b9] [Faithful \u03b9] [\u2200 X, HasLimitsOfShape (StructuredArrow X \u03b9) D] :\n    IsIso (adjunction D \u03b9).counit", "start": [185, 1], "end": [198, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Lan.diagram", "code": "abbrev diagram (F : S \u2964 D) (x : L) : CostructuredArrow \u03b9 x \u2964 D :=\n  CostructuredArrow.proj \u03b9 x \u22d9 F", "start": [208, 1], "end": [210, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Lan.cocone", "code": "@[simp]\ndef cocone {F : S \u2964 D} {G : L \u2964 D} (x : L) (f : F \u27f6 \u03b9 \u22d9 G) : Cocone (diagram \u03b9 F x)\n    where\n  pt := G.obj x\n  \u03b9 :=\n    { app := fun i => f.app i.left \u226b G.map i.hom\n      naturality := by\n        rintro \u27e8ir, \u27e8il\u27e9, i\u27e9 \u27e8jl, \u27e8jr\u27e9, j\u27e9 \u27e8fl, \u27e8\u27e8fl\u27e9\u27e9, ff\u27e9\n        dsimp at *\n        simp only [Functor.comp_map, Category.comp_id, NatTrans.naturality_assoc]\n        rw [\u2190 G.map_comp, ff]\n        aesop_cat }", "start": [216, 1], "end": [228, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Lan.loc", "code": "@[simps]\ndef loc (F : S \u2964 D) [I : \u2200 x, HasColimit (diagram \u03b9 F x)] : L \u2964 D\n    where\n  obj x := colimit (diagram \u03b9 F x)\n  map {x y} f :=\n    haveI : HasColimit (CostructuredArrow.map f \u22d9 diagram \u03b9 F y) := I _\n    colimit.pre (diagram \u03b9 F y) (CostructuredArrow.map f)\n  map_id := by\n    intro l\n    dsimp\n    haveI : HasColimit (CostructuredArrow.map (\ud835\udfd9 l) \u22d9 diagram \u03b9 F l) := I _\n    ext j\n    erw [colimit.\u03b9_pre, Category.comp_id]\n    congr 1\n    simp\n  map_comp := by\n    intro x y z f g\n    dsimp\n    haveI : HasColimit (CostructuredArrow.map (f \u226b g) \u22d9 diagram \u03b9 F z) := I _\n    ext j\n    let ff : CostructuredArrow \u03b9 _ \u2964 _ := CostructuredArrow.map f\n    let gg : CostructuredArrow \u03b9 _ \u2964 _ := CostructuredArrow.map g\n    let dd := diagram \u03b9 F z\n    haveI : HasColimit (ff \u22d9 gg \u22d9 dd) := I _\n    haveI : HasColimit ((ff \u22d9 gg) \u22d9 dd) := I _\n    haveI : HasColimit (gg \u22d9 dd) := I _\n    change _ = colimit.\u03b9 ((ff \u22d9 gg) \u22d9 dd) j \u226b _ \u226b _\n    erw [colimit.pre_pre dd gg ff, colimit.\u03b9_pre, colimit.\u03b9_pre]\n    congr 1\n    simp", "start": [234, 1], "end": [266, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Lan.equiv", "code": "@[simps]\ndef equiv (F : S \u2964 D) [I : \u2200 x, HasColimit (diagram \u03b9 F x)] (G : L \u2964 D) :\n    (loc \u03b9 F \u27f6 G) \u2243 (F \u27f6 ((whiskeringLeft _ _ _).obj \u03b9).obj G)\n    where\n  toFun f :=\n    { app := fun x => colimit.\u03b9 (diagram \u03b9 F (\u03b9.obj x)) (CostructuredArrow.mk (\ud835\udfd9 _)) \u226b f.app _\n      naturality := by\n        intro x y ff\n        dsimp only [whiskeringLeft]\n        simp only [Functor.comp_map, Category.assoc]\n        rw [\u2190 f.naturality (\u03b9.map ff), \u2190 Category.assoc, \u2190 Category.assoc]\n        let fff : CostructuredArrow \u03b9 _ \u2964 _ := CostructuredArrow.map (\u03b9.map ff)\n        haveI : HasColimit (fff \u22d9 diagram \u03b9 F (\u03b9.obj y)) := I _\n        erw [colimit.\u03b9_pre (diagram \u03b9 F (\u03b9.obj y)) fff (CostructuredArrow.mk (\ud835\udfd9 _))]\n        let xx : CostructuredArrow \u03b9 (\u03b9.obj y) := CostructuredArrow.mk (\u03b9.map ff)\n        let yy : CostructuredArrow \u03b9 (\u03b9.obj y) := CostructuredArrow.mk (\ud835\udfd9 _)\n        let fff : xx \u27f6 yy :=\n          CostructuredArrow.homMk ff\n            (by\n              simp only [CostructuredArrow.mk_hom_eq_self]\n              erw [Category.comp_id])\n        erw [colimit.w (diagram \u03b9 F (\u03b9.obj y)) fff]\n        congr\n        simp }\n  invFun f :=\n    { app := fun x => colimit.desc (diagram \u03b9 F x) (cocone _ f)\n      naturality := by\n        intro x y ff\n        apply colimit.hom_ext\n        intros j\n        haveI : HasColimit (CostructuredArrow.map ff \u22d9 diagram \u03b9 F y) := I _\n        erw [colimit.pre_desc, \u2190 Category.assoc, colimit.\u03b9_desc, colimit.\u03b9_desc]\n        simp }\n  left_inv := by\n    intros x\n    dsimp\n    ext k\n    dsimp\n    apply colimit.hom_ext\n    intros j\n    rw [colimit.\u03b9_desc]\n    dsimp only [cocone]\n    rw [Category.assoc, \u2190 x.naturality j.hom, \u2190 Category.assoc]\n    congr 1\n    dsimp [loc]\n    haveI : HasColimit (CostructuredArrow.map j.hom \u22d9 diagram \u03b9 F k) := I _\n    erw [colimit.\u03b9_pre (diagram \u03b9 F k) (CostructuredArrow.map j.hom)]\n    congr\n    rcases j with \u27e8_, \u27e8\u27e9, _\u27e9\n    simp only [CostructuredArrow.map_mk, Category.id_comp]\n    rfl\n  right_inv := by aesop_cat", "start": [270, 1], "end": [323, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.lan", "code": "@[simps!]\ndef lan [\u2200 X, HasColimitsOfShape (CostructuredArrow \u03b9 X) D] : (S \u2964 D) \u2964 L \u2964 D :=\n  Adjunction.leftAdjointOfEquiv (fun F G => Lan.equiv \u03b9 F G) (by {\n    intros X' X Y f g\n    ext\n    simp [Lan.equiv]\n    erw [Equiv.coe_fn_mk, Equiv.coe_fn_mk]\n    simp })", "start": [335, 1], "end": [344, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Lan.adjunction", "code": "def adjunction [\u2200 X, HasColimitsOfShape (CostructuredArrow \u03b9 X) D] :\n    lan \u03b9 \u22a3 (whiskeringLeft _ _ D).obj \u03b9 :=\n  Adjunction.adjunctionOfEquivLeft _ _", "start": [352, 1], "end": [355, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Lan.coreflective", "code": "theorem coreflective [Full \u03b9] [Faithful \u03b9] [\u2200 X, HasColimitsOfShape (CostructuredArrow \u03b9 X) D] :\n    IsIso (adjunction D \u03b9).unit", "start": [359, 1], "end": [372, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.lean", "imports": ["Mathlib/CategoryTheory/FinCategory.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "Mathlib/CategoryTheory/Limits/Shapes/WidePullbacks.lean", "Mathlib/Data/Fintype/Option.lean", "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean"], "premises": [{"full_name": "CategoryTheory.Limits.HasFiniteLimits", "code": "class HasFiniteLimits : Prop where\n  \n  out (J : Type) [\ud835\udca5 : SmallCategory J] [@FinCategory J \ud835\udca5] : @HasLimitsOfShape J \ud835\udca5 C _", "start": [34, 1], "end": [42, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits", "code": "instance (priority := 100) hasLimitsOfShape_of_hasFiniteLimits (J : Type w) [SmallCategory J]\n    [FinCategory J] [HasFiniteLimits C] : HasLimitsOfShape J C := by\n  apply @hasLimitsOfShape_of_equivalence _ _ _ _ _ _ (FinCategory.equivAsType J) ?_\n  apply HasFiniteLimits.out", "start": [45, 1], "end": [48, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteLimits_of_hasLimitsOfSize", "code": "instance (priority := 100) hasFiniteLimits_of_hasLimitsOfSize [HasLimitsOfSize.{v', u'} C] :\n    HasFiniteLimits C where\n  out := fun J hJ hJ' =>\n    haveI := hasLimitsOfSizeShrink.{0, 0} C\n    let F := @FinCategory.equivAsType J (@FinCategory.fintypeObj J hJ hJ') hJ hJ'\n    @hasLimitsOfShape_of_equivalence (@FinCategory.AsType J (@FinCategory.fintypeObj J hJ hJ'))\n    (@FinCategory.categoryAsType J (@FinCategory.fintypeObj J hJ hJ') hJ hJ') _ _ J hJ F _", "start": [51, 1], "end": [57, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteLimits_of_hasLimits", "code": "instance (priority := 100) hasFiniteLimits_of_hasLimits [HasLimits C] : HasFiniteLimits C :=\n  inferInstance", "start": [60, 1], "end": [62, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteLimits_of_hasFiniteLimits_of_size", "code": "theorem hasFiniteLimits_of_hasFiniteLimits_of_size\n    (h : \u2200 (J : Type w) {\ud835\udca5 : SmallCategory J} (_ : @FinCategory J \ud835\udca5), HasLimitsOfShape J C) :\n    HasFiniteLimits C where", "start": [65, 1], "end": [78, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasFiniteColimits", "code": "class HasFiniteColimits : Prop where\n  \n  out (J : Type) [\ud835\udca5 : SmallCategory J] [@FinCategory J \ud835\udca5] : @HasColimitsOfShape J \ud835\udca5 C _", "start": [84, 1], "end": [92, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimitsOfShape_of_hasFiniteColimits", "code": "instance (priority := 100) hasColimitsOfShape_of_hasFiniteColimits (J : Type w) [SmallCategory J]\n    [FinCategory J] [HasFiniteColimits C] : HasColimitsOfShape J C := by\n  refine @hasColimitsOfShape_of_equivalence _ _ _ _ _ _ (FinCategory.equivAsType J) ?_\n  apply HasFiniteColimits.out", "start": [95, 1], "end": [98, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteColimits_of_hasColimitsOfSize", "code": "instance (priority := 100) hasFiniteColimits_of_hasColimitsOfSize [HasColimitsOfSize.{v', u'} C] :\n    HasFiniteColimits C where\n  out := fun J hJ hJ' =>\n    haveI := hasColimitsOfSize_shrink.{0, 0} C\n    let F := @FinCategory.equivAsType J (@FinCategory.fintypeObj J hJ hJ') hJ hJ'\n    @hasColimitsOfShape_of_equivalence (@FinCategory.AsType J (@FinCategory.fintypeObj J hJ hJ'))\n    (@FinCategory.categoryAsType J (@FinCategory.fintypeObj J hJ hJ') hJ hJ') _ _ J hJ F _", "start": [101, 1], "end": [107, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteColimits_of_hasFiniteColimits_of_size", "code": "theorem hasFiniteColimits_of_hasFiniteColimits_of_size\n    (h : \u2200 (J : Type w) {\ud835\udca5 : SmallCategory J} (_ : @FinCategory J \ud835\udca5), HasColimitsOfShape J C) :\n    HasFiniteColimits C where", "start": [110, 1], "end": [123, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.fintypeWalkingParallelPair", "code": "instance fintypeWalkingParallelPair : Fintype WalkingParallelPair where\n  elems := [WalkingParallelPair.zero, WalkingParallelPair.one].toFinset\n  complete x := by cases x <;> simp", "start": [130, 1], "end": [132, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.instFintypeWalkingParallelPairHom", "code": "instance instFintypeWalkingParallelPairHom (j j' : WalkingParallelPair) :\n    Fintype (WalkingParallelPairHom j j') where\n  elems :=\n    WalkingParallelPair.recOn j\n      (WalkingParallelPair.recOn j' [WalkingParallelPairHom.id zero].toFinset\n        [left, right].toFinset)\n      (WalkingParallelPair.recOn j' \u2205 [WalkingParallelPairHom.id one].toFinset)\n  complete := by\n    rintro (_|_) <;> simp\n    \u00b7 cases j <;> simp", "start": [137, 1], "end": [146, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.fintypeObj", "code": "instance fintypeObj [Fintype J] : Fintype (WidePullbackShape J) := by\n  rw [WidePullbackShape]\n  infer_instance", "start": [166, 1], "end": [168, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.fintypeHom", "code": "instance fintypeHom (j j' : WidePullbackShape J) : Fintype (j \u27f6 j')\n    where\n  elems := by\n    cases' j' with j'\n    \u00b7 cases' j with j\n      \u00b7 exact {Hom.id none}\n      \u00b7 exact {Hom.term j}\n    \u00b7 by_cases some j' = j\n      \u00b7 rw [h]\n        exact {Hom.id j}\n      \u00b7 exact \u2205\n  complete := by\n    rintro (_|_)\n    \u00b7 cases j <;> simp\n    \u00b7 simp", "start": [171, 1], "end": [185, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape.fintypeObj", "code": "instance fintypeObj [Fintype J] : Fintype (WidePushoutShape J) := by\n  rw [WidePushoutShape]; infer_instance", "start": [192, 1], "end": [193, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WidePushoutShape.fintypeHom", "code": "instance fintypeHom (j j' : WidePushoutShape J) : Fintype (j \u27f6 j') where\n  elems := by\n    cases' j with j\n    \u00b7 cases' j' with j'\n      \u00b7 exact {Hom.id none}\n      \u00b7 exact {Hom.init j'}\n    \u00b7 by_cases some j = j'\n      \u00b7 rw [h]\n        exact {Hom.id j'}\n      \u00b7 exact \u2205\n  complete := by\n    rintro (_|_)\n    \u00b7 cases j <;> simp\n    \u00b7 simp", "start": [196, 1], "end": [209, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.finCategoryWidePullback", "code": "instance finCategoryWidePullback [Fintype J] : FinCategory (WidePullbackShape J) where\n  fintypeHom := WidePullbackShape.fintypeHom", "start": [214, 1], "end": [215, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.finCategoryWidePushout", "code": "instance finCategoryWidePushout [Fintype J] : FinCategory (WidePushoutShape J) where\n  fintypeHom := WidePushoutShape.fintypeHom", "start": [218, 1], "end": [219, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasFiniteWidePullbacks", "code": "class HasFiniteWidePullbacks : Prop where\n  \n  out (J : Type) [Fintype J] : HasLimitsOfShape (WidePullbackShape J) C", "start": [224, 1], "end": [229, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitsOfShape_widePullbackShape", "code": "instance hasLimitsOfShape_widePullbackShape (J : Type) [Finite J] [HasFiniteWidePullbacks C] :\n    HasLimitsOfShape (WidePullbackShape J) C := by\n  cases nonempty_fintype J\n  haveI := @HasFiniteWidePullbacks.out C _ _ J\n  infer_instance", "start": [232, 1], "end": [236, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasFiniteWidePushouts", "code": "class HasFiniteWidePushouts : Prop where\n  \n  out (J : Type) [Fintype J] : HasColimitsOfShape (WidePushoutShape J) C", "start": [239, 1], "end": [244, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimitsOfShape_widePushoutShape", "code": "instance hasColimitsOfShape_widePushoutShape (J : Type) [Finite J] [HasFiniteWidePushouts C] :\n    HasColimitsOfShape (WidePushoutShape J) C := by\n  cases nonempty_fintype J\n  haveI := @HasFiniteWidePushouts.out C _ _ J\n  infer_instance", "start": [247, 1], "end": [251, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteWidePullbacks_of_hasFiniteLimits", "code": "theorem hasFiniteWidePullbacks_of_hasFiniteLimits [HasFiniteLimits C] : HasFiniteWidePullbacks C", "start": [254, 1], "end": [258, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteWidePushouts_of_has_finite_limits", "code": "theorem hasFiniteWidePushouts_of_has_finite_limits [HasFiniteColimits C] :\n    HasFiniteWidePushouts C", "start": [261, 1], "end": [266, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.fintypeWalkingPair", "code": "instance fintypeWalkingPair : Fintype WalkingPair where\n  elems := {WalkingPair.left, WalkingPair.right}\n  complete x := by cases x <;> simp", "start": [269, 1], "end": [271, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Subobject/MonoOver.lean", "imports": ["Mathlib/CategoryTheory/Limits/Over.lean", "Mathlib/CategoryTheory/Limits/Shapes/Images.lean", "Mathlib/CategoryTheory/Adjunction/Reflective.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.MonoOver", "code": "def MonoOver (X : C) :=\n  FullSubcategory fun f : Over X => Mono f.hom", "start": [49, 1], "end": [55, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.mk'", "code": "@[simps]\ndef mk' {X A : C} (f : A \u27f6 X) [hf : Mono f] : MonoOver X where\n  obj := Over.mk f\n  property := hf", "start": [63, 1], "end": [67, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.forget", "code": "def forget (X : C) : MonoOver X \u2964 Over X :=\n  fullSubcategoryInclusion _", "start": [70, 1], "end": [72, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.forget_obj_left", "code": "@[simp]\ntheorem forget_obj_left {f} : ((forget X).obj f).left = (f : C)", "start": [77, 1], "end": [79, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.mk'_coe'", "code": "@[simp]\ntheorem mk'_coe' {X A : C} (f : A \u27f6 X) [Mono f] : (mk' f : C) = A", "start": [82, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.arrow", "code": "abbrev arrow (f : MonoOver X) : (f : C) \u27f6 X :=\n  ((forget X).obj f).hom", "start": [87, 1], "end": [89, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.mk'_arrow", "code": "@[simp]\ntheorem mk'_arrow {X A : C} (f : A \u27f6 X) [Mono f] : (mk' f).arrow = f", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.forget_obj_hom", "code": "@[simp]\ntheorem forget_obj_hom {f} : ((forget X).obj f).hom = f.arrow", "start": [97, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.mono", "code": "instance mono (f : MonoOver X) : Mono f.arrow :=\n  f.property", "start": [108, 1], "end": [109, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.isThin", "code": "instance isThin {X : C} : Quiver.IsThin (MonoOver X) := fun f g =>\n  \u27e8by\n    intro h\u2081 h\u2082\n    apply Over.OverMorphism.ext\n    erw [\u2190 cancel_mono g.arrow, Over.w h\u2081, Over.w h\u2082]\u27e9", "start": [112, 1], "end": [118, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.w", "code": "@[reassoc]\ntheorem w {f g : MonoOver X} (k : f \u27f6 g) : k.left \u226b g.arrow = f.arrow", "start": [121, 1], "end": [123, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.homMk", "code": "abbrev homMk {f g : MonoOver X} (h : f.obj.left \u27f6 g.obj.left)\n    (w : h \u226b g.arrow = f.arrow := by aesop_cat) : f \u27f6 g :=\n  Over.homMk h w", "start": [126, 1], "end": [129, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.isoMk", "code": "@[simps]\ndef isoMk {f g : MonoOver X} (h : f.obj.left \u2245 g.obj.left)\n    (w : h.hom \u226b g.arrow = f.arrow := by aesop_cat) : f \u2245 g where\n  hom := homMk h.hom w\n  inv := homMk h.inv (by rw [h.inv_comp_eq, w])", "start": [132, 1], "end": [137, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.mk'ArrowIso", "code": "@[simp]\ndef mk'ArrowIso {X : C} (f : MonoOver X) : mk' f.arrow \u2245 f :=\n  isoMk (Iso.refl _)", "start": [140, 1], "end": [144, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.lift", "code": "@[simps]\ndef lift {Y : D} (F : Over Y \u2964 Over X)\n    (h : \u2200 f : MonoOver Y, Mono (F.obj ((MonoOver.forget Y).obj f)).hom) :\n    MonoOver Y \u2964 MonoOver X where\n  obj f := \u27e8_, h f\u27e9\n  map k := (MonoOver.forget X).preimage ((MonoOver.forget Y \u22d9 F).map k)", "start": [147, 1], "end": [155, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.liftIso", "code": "def liftIso {Y : D} {F\u2081 F\u2082 : Over Y \u2964 Over X} (h\u2081 h\u2082) (i : F\u2081 \u2245 F\u2082) : lift F\u2081 h\u2081 \u2245 lift F\u2082 h\u2082 :=\n  fullyFaithfulCancelRight (MonoOver.forget X) (isoWhiskerLeft (MonoOver.forget Y) i)", "start": [158, 1], "end": [161, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.liftComp", "code": "def liftComp {X Z : C} {Y : D} (F : Over X \u2964 Over Y) (G : Over Y \u2964 Over Z) (h\u2081 h\u2082) :\n    lift F h\u2081 \u22d9 lift G h\u2082 \u2245 lift (F \u22d9 G) fun f => h\u2082 \u27e8_, h\u2081 f\u27e9 :=\n  fullyFaithfulCancelRight (MonoOver.forget _) (Iso.refl _)", "start": [164, 1], "end": [167, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.liftId", "code": "def liftId : (lift (\ud835\udfed (Over X)) fun f => f.2) \u2245 \ud835\udfed _ :=\n  fullyFaithfulCancelRight (MonoOver.forget _) (Iso.refl _)", "start": [170, 1], "end": [172, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.lift_comm", "code": "@[simp]\ntheorem lift_comm (F : Over Y \u2964 Over X)\n    (h : \u2200 f : MonoOver Y, Mono (F.obj ((MonoOver.forget Y).obj f)).hom) :\n    lift F h \u22d9 MonoOver.forget X = MonoOver.forget Y \u22d9 F", "start": [175, 1], "end": [179, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.lift_obj_arrow", "code": "@[simp]\ntheorem lift_obj_arrow {Y : D} (F : Over Y \u2964 Over X)\n    (h : \u2200 f : MonoOver Y, Mono (F.obj ((MonoOver.forget Y).obj f)).hom) (f : MonoOver Y) :\n    ((lift F h).obj f).arrow = (F.obj ((forget Y).obj f)).hom", "start": [182, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.slice", "code": "def slice {A : C} {f : Over A}\n    (h\u2081 : \u2200 (g : MonoOver f),\n    Mono ((Over.iteratedSliceEquiv f).functor.obj ((forget f).obj g)).hom)\n    (h\u2082 : \u2200 (g : MonoOver f.left),\n    Mono ((Over.iteratedSliceEquiv f).inverse.obj ((forget f.left).obj g)).hom) :\n  MonoOver f \u224c MonoOver f.left where\n  functor := MonoOver.lift f.iteratedSliceEquiv.functor h\u2081\n  inverse := MonoOver.lift f.iteratedSliceEquiv.inverse h\u2082\n  unitIso :=\n    MonoOver.liftId.symm \u226a\u226b\n      MonoOver.liftIso _ _ f.iteratedSliceEquiv.unitIso \u226a\u226b (MonoOver.liftComp _ _ _ _).symm\n  counitIso :=\n    MonoOver.liftComp _ _ _ _ \u226a\u226b\n      MonoOver.liftIso _ _ f.iteratedSliceEquiv.counitIso \u226a\u226b MonoOver.liftId", "start": [189, 1], "end": [205, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.pullback", "code": "def pullback (f : X \u27f6 Y) : MonoOver Y \u2964 MonoOver X :=\n  MonoOver.lift (Over.pullback f) (fun g => by\n    haveI : Mono ((forget Y).obj g).hom := (inferInstance : Mono g.arrow)\n    apply pullback.snd_of_mono)", "start": [212, 1], "end": [217, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.pullbackComp", "code": "def pullbackComp (f : X \u27f6 Y) (g : Y \u27f6 Z) : pullback (f \u226b g) \u2245 pullback g \u22d9 pullback f :=\n  liftIso _ _ (Over.pullbackComp _ _) \u226a\u226b (liftComp _ _ _ _).symm", "start": [220, 1], "end": [222, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.pullbackId", "code": "def pullbackId : pullback (\ud835\udfd9 X) \u2245 \ud835\udfed _ :=\n  liftIso _ _ Over.pullbackId \u226a\u226b liftId", "start": [225, 1], "end": [227, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.pullback_obj_left", "code": "@[simp]\ntheorem pullback_obj_left (f : X \u27f6 Y) (g : MonoOver Y) :\n    ((pullback f).obj g : C) = Limits.pullback g.arrow f", "start": [230, 1], "end": [233, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.pullback_obj_arrow", "code": "@[simp]\ntheorem pullback_obj_arrow (f : X \u27f6 Y) (g : MonoOver Y) :\n    ((pullback f).obj g).arrow = pullback.snd", "start": [236, 1], "end": [239, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.map", "code": "def map (f : X \u27f6 Y) [Mono f] : MonoOver X \u2964 MonoOver Y :=\n  lift (Over.map f) fun g => by apply mono_comp g.arrow f", "start": [248, 1], "end": [252, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.mapComp", "code": "def mapComp (f : X \u27f6 Y) (g : Y \u27f6 Z) [Mono f] [Mono g] : map (f \u226b g) \u2245 map f \u22d9 map g :=\n  liftIso _ _ (Over.mapComp _ _) \u226a\u226b (liftComp _ _ _ _).symm", "start": [255, 1], "end": [257, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.mapId", "code": "def mapId : map (\ud835\udfd9 X) \u2245 \ud835\udfed _ :=\n  liftIso _ _ Over.mapId \u226a\u226b liftId", "start": [260, 1], "end": [262, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.map_obj_left", "code": "@[simp]\ntheorem map_obj_left (f : X \u27f6 Y) [Mono f] (g : MonoOver X) : ((map f).obj g : C) = g.obj.left", "start": [265, 1], "end": [267, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.map_obj_arrow", "code": "@[simp]\ntheorem map_obj_arrow (f : X \u27f6 Y) [Mono f] (g : MonoOver X) : ((map f).obj g).arrow = g.arrow \u226b f", "start": [270, 1], "end": [272, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.fullMap", "code": "instance fullMap (f : X \u27f6 Y) [Mono f] : Full (map f) where\n  preimage {g h} e := by\n    refine' homMk e.left _\n    rw [\u2190 cancel_mono f, assoc]\n    apply w e", "start": [275, 1], "end": [279, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.faithful_map", "code": "instance faithful_map (f : X \u27f6 Y) [Mono f] : Faithful (map f) where", "start": [282, 1], "end": [282, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.mapIso", "code": "@[simps]\ndef mapIso {A B : C} (e : A \u2245 B) : MonoOver A \u224c MonoOver B where\n  functor := map e.hom\n  inverse := map e.inv\n  unitIso := ((mapComp _ _).symm \u226a\u226b eqToIso (by simp) \u226a\u226b mapId).symm\n  counitIso := (mapComp _ _).symm \u226a\u226b eqToIso (by simp) \u226a\u226b mapId", "start": [285, 1], "end": [292, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.congr", "code": "@[simps]\ndef congr (e : C \u224c D) : MonoOver X \u224c MonoOver (e.functor.obj X) where\n  functor :=\n    lift (Over.post e.functor) fun f => by\n      dsimp\n      infer_instance\n  inverse :=\n    (lift (Over.post e.inverse) fun f => by\n        dsimp\n        infer_instance) \u22d9\n      (mapIso (e.unitIso.symm.app X)).functor\n  unitIso := NatIso.ofComponents fun Y => isoMk (e.unitIso.app Y)\n  counitIso := NatIso.ofComponents fun Y => isoMk (e.counitIso.app Y)", "start": [299, 1], "end": [313, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.mapPullbackAdj", "code": "def mapPullbackAdj (f : X \u27f6 Y) [Mono f] : map f \u22a3 pullback f :=\n  Adjunction.restrictFullyFaithful (forget X) (forget Y) (Over.mapPullbackAdj f) (Iso.refl _)\n    (Iso.refl _)", "start": [322, 1], "end": [325, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.pullbackMapSelf", "code": "def pullbackMapSelf (f : X \u27f6 Y) [Mono f] : map f \u22d9 pullback f \u2245 \ud835\udfed _ :=\n  (asIso (MonoOver.mapPullbackAdj f).unit).symm", "start": [328, 1], "end": [330, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.imageMonoOver", "code": "def imageMonoOver (f : X \u27f6 Y) [HasImage f] : MonoOver Y :=\n  MonoOver.mk' (image.\u03b9 f)", "start": [341, 1], "end": [344, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.imageMonoOver_arrow", "code": "@[simp]\ntheorem imageMonoOver_arrow (f : X \u27f6 Y) [HasImage f] : (imageMonoOver f).arrow = image.\u03b9 f", "start": [347, 1], "end": [349, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.image", "code": "@[simps]\ndef image : Over X \u2964 MonoOver X where\n  obj f := imageMonoOver f.hom\n  map {f g} k := by\n    apply (forget X).preimage _\n    apply Over.homMk _ _\n    refine'\n      image.lift\n        { I := Limits.image _\n          m := image.\u03b9 g.hom\n          e := k.left \u226b factorThruImage g.hom }\n    apply image.lift_fac", "start": [358, 1], "end": [371, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.imageForgetAdj", "code": "def imageForgetAdj : image \u22a3 forget X :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun f g =>\n        { toFun := fun k => by\n            apply Over.homMk (factorThruImage f.hom \u226b k.left) _\n            change (factorThruImage f.hom \u226b k.left) \u226b _ = f.hom\n            rw [assoc, Over.w k]\n            apply image.fac\n          invFun := fun k => by\n            refine' Over.homMk _ _\n            refine'\n              image.lift\n                { I := g.obj.left\n                  m := g.arrow\n                  e := k.left\n                  fac := Over.w k }\n            apply image.lift_fac\n          left_inv := fun k => Subsingleton.elim _ _\n          right_inv := fun k => by\n            ext1\n            change factorThruImage _ \u226b image.lift _ = _\n            rw [\u2190 cancel_mono g.arrow, assoc, image.lift_fac, image.fac f.hom]\n            exact (Over.w k).symm } }", "start": [374, 1], "end": [399, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.reflective", "code": "instance reflective : Reflective (forget X) where", "start": [406, 1], "end": [406, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.forgetImage", "code": "def forgetImage : forget X \u22d9 image \u2245 \ud835\udfed (MonoOver X) :=\n  asIso (Adjunction.counit imageForgetAdj)", "start": [409, 1], "end": [413, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.exists", "code": "def \u00abexists\u00bb (f : X \u27f6 Y) : MonoOver X \u2964 MonoOver Y :=\n  forget _ \u22d9 Over.map f \u22d9 image", "start": [422, 1], "end": [426, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.faithful_exists", "code": "instance faithful_exists (f : X \u27f6 Y) : Faithful (\u00abexists\u00bb f) where", "start": [429, 1], "end": [429, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.existsIsoMap", "code": "def existsIsoMap (f : X \u27f6 Y) [Mono f] : \u00abexists\u00bb f \u2245 map f :=\n  NatIso.ofComponents (by\n    intro Z\n    suffices (forget _).obj ((\u00abexists\u00bb f).obj Z) \u2245 (forget _).obj ((map f).obj Z) by\n      apply (forget _).preimageIso this\n    apply Over.isoMk _ _\n    apply imageMonoIsoSource (Z.arrow \u226b f)\n    apply imageMonoIsoSource_hom_self)", "start": [432, 1], "end": [441, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoOver.existsPullbackAdj", "code": "def existsPullbackAdj (f : X \u27f6 Y) [HasPullbacks C] : \u00abexists\u00bb f \u22a3 pullback f :=\n  Adjunction.restrictFullyFaithful (forget X) (\ud835\udfed _) ((Over.mapPullbackAdj f).comp imageForgetAdj)\n    (Iso.refl _) (Iso.refl _)", "start": [444, 1], "end": [447, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Functor.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/Category.lean", "Mathlib/CategoryTheory/Products/Basic.lean", "Mathlib/CategoryTheory/Adjunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.LaxMonoidalFunctor", "code": "structure LaxMonoidalFunctor extends C \u2964 D where\n  \n  \u03b5 : \ud835\udfd9_ D \u27f6 obj (\ud835\udfd9_ C)\n  \n  \u03bc : \u2200 X Y : C, obj X \u2297 obj Y \u27f6 obj (X \u2297 Y)\n  \u03bc_natural :\n    \u2200 {X Y X' Y' : C} (f : X \u27f6 Y) (g : X' \u27f6 Y'),\n      (map f \u2297 map g) \u226b \u03bc Y Y' = \u03bc X X' \u226b map (f \u2297 g) := by\n    aesop_cat\n  \n  associativity :\n    \u2200 X Y Z : C,\n      (\u03bc X Y \u2297 \ud835\udfd9 (obj Z)) \u226b \u03bc (X \u2297 Y) Z \u226b map (\u03b1_ X Y Z).hom =\n        (\u03b1_ (obj X) (obj Y) (obj Z)).hom \u226b (\ud835\udfd9 (obj X) \u2297 \u03bc Y Z) \u226b \u03bc X (Y \u2297 Z) := by\n    aesop_cat\n  left_unitality : \u2200 X : C, (\u03bb_ (obj X)).hom = (\u03b5 \u2297 \ud835\udfd9 (obj X)) \u226b \u03bc (\ud835\udfd9_ C) X \u226b map (\u03bb_ X).hom :=\n    by aesop_cat\n  right_unitality : \u2200 X : C, (\u03c1_ (obj X)).hom = (\ud835\udfd9 (obj X) \u2297 \u03b5) \u226b \u03bc X (\ud835\udfd9_ C) \u226b map (\u03c1_ X).hom :=\n    by aesop_cat", "start": [64, 1], "end": [86, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LaxMonoidalFunctor.left_unitality_inv", "code": "@[reassoc (attr := simp)]\ntheorem LaxMonoidalFunctor.left_unitality_inv (F : LaxMonoidalFunctor C D) (X : C) :\n    (\u03bb_ (F.obj X)).inv \u226b (F.\u03b5 \u2297 \ud835\udfd9 (F.obj X)) \u226b F.\u03bc (\ud835\udfd9_ C) X = F.map (\u03bb_ X).inv", "start": [113, 1], "end": [117, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LaxMonoidalFunctor.right_unitality_inv", "code": "@[reassoc (attr := simp)]\ntheorem LaxMonoidalFunctor.right_unitality_inv (F : LaxMonoidalFunctor C D) (X : C) :\n    (\u03c1_ (F.obj X)).inv \u226b (\ud835\udfd9 (F.obj X) \u2297 F.\u03b5) \u226b F.\u03bc X (\ud835\udfd9_ C) = F.map (\u03c1_ X).inv", "start": [121, 1], "end": [125, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LaxMonoidalFunctor.associativity_inv", "code": "@[reassoc (attr := simp)]\ntheorem LaxMonoidalFunctor.associativity_inv (F : LaxMonoidalFunctor C D) (X Y Z : C) :\n    (\ud835\udfd9 (F.obj X) \u2297 F.\u03bc Y Z) \u226b F.\u03bc X (Y \u2297 Z) \u226b F.map (\u03b1_ X Y Z).inv =\n      (\u03b1_ (F.obj X) (F.obj Y) (F.obj Z)).inv \u226b (F.\u03bc X Y \u2297 \ud835\udfd9 (F.obj Z)) \u226b F.\u03bc (X \u2297 Y) Z", "start": [129, 1], "end": [134, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor", "code": "structure MonoidalFunctor extends LaxMonoidalFunctor.{v\u2081, v\u2082} C D where\n  \u03b5_isIso : IsIso \u03b5 := by infer_instance\n  \u03bc_isIso : \u2200 X Y : C, IsIso (\u03bc X Y) := by infer_instance", "start": [139, 1], "end": [146, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.\u03b5Iso", "code": "noncomputable def MonoidalFunctor.\u03b5Iso (F : MonoidalFunctor.{v\u2081, v\u2082} C D) :\n    tensorUnit D \u2245 F.obj (tensorUnit C) :=\n  asIso F.\u03b5", "start": [156, 1], "end": [160, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.\u03bcIso", "code": "noncomputable def MonoidalFunctor.\u03bcIso (F : MonoidalFunctor.{v\u2081, v\u2082} C D) (X Y : C) :\n    F.obj X \u2297 F.obj Y \u2245 F.obj (X \u2297 Y) :=\n  asIso (F.\u03bc X Y)", "start": [163, 1], "end": [167, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LaxMonoidalFunctor.id", "code": "@[simps]\ndef id : LaxMonoidalFunctor.{v\u2081, v\u2081} C C :=\n  { \ud835\udfed C with\n    \u03b5 := \ud835\udfd9 _\n    \u03bc := fun X Y => \ud835\udfd9 _ }", "start": [178, 1], "end": [183, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.map_tensor", "code": "theorem map_tensor {X Y X' Y' : C} (f : X \u27f6 Y) (g : X' \u27f6 Y') :\n    F.map (f \u2297 g) = inv (F.\u03bc X X') \u226b (F.map f \u2297 F.map g) \u226b F.\u03bc Y Y'", "start": [201, 1], "end": [202, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.map_leftUnitor", "code": "theorem map_leftUnitor (X : C) :\n    F.map (\u03bb_ X).hom = inv (F.\u03bc (\ud835\udfd9_ C) X) \u226b (inv F.\u03b5 \u2297 \ud835\udfd9 (F.obj X)) \u226b (\u03bb_ (F.obj X)).hom", "start": [205, 1], "end": [211, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.map_rightUnitor", "code": "theorem map_rightUnitor (X : C) :\n    F.map (\u03c1_ X).hom = inv (F.\u03bc X (\ud835\udfd9_ C)) \u226b (\ud835\udfd9 (F.obj X) \u2297 inv F.\u03b5) \u226b (\u03c1_ (F.obj X)).hom", "start": [214, 1], "end": [220, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.\u03bcNatIso", "code": "noncomputable def \u03bcNatIso :\n    Functor.prod F.toFunctor F.toFunctor \u22d9 tensor D \u2245 tensor C \u22d9 F.toFunctor :=\n  NatIso.ofComponents\n    (by\n      intros\n      apply F.\u03bcIso)\n    (by\n      intros\n      apply F.toLaxMonoidalFunctor.\u03bc_natural)", "start": [223, 1], "end": [232, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.\u03bcIso_hom", "code": "@[simp]\ntheorem \u03bcIso_hom (X Y : C) : (F.\u03bcIso X Y).hom = F.\u03bc X Y", "start": [235, 1], "end": [237, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.\u03bc_inv_hom_id", "code": "@[reassoc (attr := simp)]\ntheorem \u03bc_inv_hom_id (X Y : C) : (F.\u03bcIso X Y).inv \u226b F.\u03bc X Y = \ud835\udfd9 _", "start": [241, 1], "end": [243, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.\u03bc_hom_inv_id", "code": "@[simp]\ntheorem \u03bc_hom_inv_id (X Y : C) : F.\u03bc X Y \u226b (F.\u03bcIso X Y).inv = \ud835\udfd9 _", "start": [246, 1], "end": [248, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.\u03b5Iso_hom", "code": "@[simp]\ntheorem \u03b5Iso_hom : F.\u03b5Iso.hom = F.\u03b5", "start": [251, 1], "end": [253, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.\u03b5_inv_hom_id", "code": "@[reassoc (attr := simp)]\ntheorem \u03b5_inv_hom_id : F.\u03b5Iso.inv \u226b F.\u03b5 = \ud835\udfd9 _", "start": [257, 1], "end": [259, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.\u03b5_hom_inv_id", "code": "@[simp]\ntheorem \u03b5_hom_inv_id : F.\u03b5 \u226b F.\u03b5Iso.inv = \ud835\udfd9 _", "start": [262, 1], "end": [264, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.commTensorLeft", "code": "@[simps!]\nnoncomputable def commTensorLeft (X : C) :\n    F.toFunctor \u22d9 tensorLeft (F.toFunctor.obj X) \u2245 tensorLeft X \u22d9 F.toFunctor :=\n  NatIso.ofComponents (fun Y => F.\u03bcIso X Y) @fun Y Z f => by\n    convert F.\u03bc_natural (\ud835\udfd9 X) f using 2\n    simp", "start": [267, 1], "end": [273, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.commTensorRight", "code": "@[simps!]\nnoncomputable def commTensorRight (X : C) :\n    F.toFunctor \u22d9 tensorRight (F.toFunctor.obj X) \u2245 tensorRight X \u22d9 F.toFunctor :=\n  NatIso.ofComponents (fun Y => F.\u03bcIso Y X) @fun Y Z f => by\n    convert F.\u03bc_natural f (\ud835\udfd9 X) using 2\n    simp", "start": [276, 1], "end": [282, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.id", "code": "@[simps]\ndef id : MonoidalFunctor.{v\u2081, v\u2081} C C :=\n  { \ud835\udfed C with\n    \u03b5 := \ud835\udfd9 _\n    \u03bc := fun X Y => \ud835\udfd9 _ }", "start": [291, 1], "end": [296, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LaxMonoidalFunctor.comp", "code": "@[simps]\ndef comp : LaxMonoidalFunctor.{v\u2081, v\u2083} C E :=\n  { F.toFunctor \u22d9 G.toFunctor with\n    \u03b5 := G.\u03b5 \u226b G.map F.\u03b5\n    \u03bc := fun X Y => G.\u03bc (F.obj X) (F.obj Y) \u226b G.map (F.\u03bc X Y)\n    \u03bc_natural := @fun _ _ _ _ f g => by\n      simp only [Functor.comp_map, assoc]\n      rw [\u2190 Category.assoc, LaxMonoidalFunctor.\u03bc_natural, Category.assoc, \u2190 map_comp, \u2190 map_comp,\n        \u2190 LaxMonoidalFunctor.\u03bc_natural]\n    associativity := fun X Y Z => by\n      dsimp\n      rw [id_tensor_comp]\n      slice_rhs 3 4 => rw [\u2190 G.toFunctor.map_id, G.\u03bc_natural]\n      slice_rhs 1 3 => rw [\u2190 G.associativity]\n      rw [comp_tensor_id]\n      slice_lhs 2 3 => rw [\u2190 G.toFunctor.map_id, G.\u03bc_natural]\n      rw [Category.assoc, Category.assoc, Category.assoc, Category.assoc, Category.assoc, \u2190\n        G.toFunctor.map_comp, \u2190 G.toFunctor.map_comp, \u2190 G.toFunctor.map_comp, \u2190\n        G.toFunctor.map_comp, F.associativity]\n    left_unitality := fun X => by\n      dsimp\n      rw [G.left_unitality, comp_tensor_id, Category.assoc, Category.assoc]\n      apply congr_arg\n      rw [F.left_unitality, map_comp, \u2190 NatTrans.id_app, \u2190 Category.assoc, \u2190\n        LaxMonoidalFunctor.\u03bc_natural, NatTrans.id_app, map_id, \u2190 Category.assoc, map_comp]\n    right_unitality := fun X => by\n      dsimp\n      rw [G.right_unitality, id_tensor_comp, Category.assoc, Category.assoc]\n      apply congr_arg\n      rw [F.right_unitality, map_comp, \u2190 NatTrans.id_app, \u2190 Category.assoc, \u2190\n        LaxMonoidalFunctor.\u03bc_natural, NatTrans.id_app, map_id, \u2190 Category.assoc, map_comp] }", "start": [317, 1], "end": [348, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LaxMonoidalFunctor.prod", "code": "@[simps]\ndef prod : LaxMonoidalFunctor (B \u00d7 D) (C \u00d7 E) :=\n  { F.toFunctor.prod G.toFunctor with\n    \u03b5 := (\u03b5 F, \u03b5 G)\n    \u03bc := fun X Y => (\u03bc F X.1 Y.1, \u03bc G X.2 Y.2) }", "start": [366, 1], "end": [371, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.diag", "code": "@[simps]\ndef diag : MonoidalFunctor C (C \u00d7 C) :=\n  { Functor.diag C with\n    \u03b5 := \ud835\udfd9 _\n    \u03bc := fun X Y => \ud835\udfd9 _ }", "start": [380, 1], "end": [385, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LaxMonoidalFunctor.prod'", "code": "def prod' : LaxMonoidalFunctor C (D \u00d7 E) :=\n  (MonoidalFunctor.diag C).toLaxMonoidalFunctor \u2297\u22d9 F.prod G", "start": [394, 1], "end": [397, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LaxMonoidalFunctor.prod'_toFunctor", "code": "@[simp]\ntheorem prod'_toFunctor : (F.prod' G).toFunctor = F.toFunctor.prod' G.toFunctor", "start": [400, 1], "end": [402, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LaxMonoidalFunctor.prod'_\u03b5", "code": "@[simp]\ntheorem prod'_\u03b5 : (F.prod' G).\u03b5 = (F.\u03b5, G.\u03b5)", "start": [405, 1], "end": [408, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LaxMonoidalFunctor.prod'_\u03bc", "code": "@[simp]\ntheorem prod'_\u03bc (X Y : C) : (F.prod' G).\u03bc X Y = (F.\u03bc X Y, G.\u03bc X Y)", "start": [411, 1], "end": [414, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.comp", "code": "@[simps]\ndef comp : MonoidalFunctor.{v\u2081, v\u2083} C E :=\n  {\n    F.toLaxMonoidalFunctor.comp\n      G.toLaxMonoidalFunctor with\n    \u03b5_isIso := by\n      dsimp\n      infer_instance\n    \u03bc_isIso := by\n      dsimp\n      infer_instance }", "start": [423, 1], "end": [434, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.prod", "code": "@[simps]\ndef prod : MonoidalFunctor (B \u00d7 D) (C \u00d7 E) :=\n  {\n    F.toLaxMonoidalFunctor.prod\n      G.toLaxMonoidalFunctor with\n    \u03b5_isIso := (isIso_prod_iff C E).mpr \u27e8\u03b5_isIso F, \u03b5_isIso G\u27e9\n    \u03bc_isIso := fun X Y => (isIso_prod_iff C E).mpr \u27e8\u03bc_isIso F X.1 Y.1, \u03bc_isIso G X.2 Y.2\u27e9 }", "start": [452, 1], "end": [459, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.prod'", "code": "def prod' : MonoidalFunctor C (D \u00d7 E) :=\n  diag C \u2297\u22d9 F.prod G", "start": [468, 1], "end": [471, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalFunctor.prod'_toLaxMonoidalFunctor", "code": "@[simp]\ntheorem prod'_toLaxMonoidalFunctor :\n    (F.prod' G).toLaxMonoidalFunctor = F.toLaxMonoidalFunctor.prod' G.toLaxMonoidalFunctor", "start": [474, 1], "end": [477, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalAdjoint", "code": "@[simps]\nnoncomputable def monoidalAdjoint (F : MonoidalFunctor C D) {G : D \u2964 C} (h : F.toFunctor \u22a3 G) :\n    LaxMonoidalFunctor D C where\n  toFunctor := G\n  \u03b5 := h.homEquiv _ _ (inv F.\u03b5)\n  \u03bc X Y := h.homEquiv _ (X \u2297 Y) (inv (F.\u03bc (G.obj X) (G.obj Y)) \u226b (h.counit.app X \u2297 h.counit.app Y))\n  \u03bc_natural := @fun X Y X' Y' f g => by\n    rw [\u2190 h.homEquiv_naturality_left, \u2190 h.homEquiv_naturality_right, Equiv.apply_eq_iff_eq, assoc,\n      IsIso.eq_inv_comp, \u2190 F.toLaxMonoidalFunctor.\u03bc_natural_assoc, IsIso.hom_inv_id_assoc, \u2190\n      tensor_comp, Adjunction.counit_naturality, Adjunction.counit_naturality, tensor_comp]\n  associativity X Y Z := by\n    dsimp only\n    rw [\u2190 h.homEquiv_naturality_right, \u2190 h.homEquiv_naturality_left, \u2190\n      h.homEquiv_naturality_left, \u2190 h.homEquiv_naturality_left, Equiv.apply_eq_iff_eq, \u2190\n      cancel_epi (F.toLaxMonoidalFunctor.\u03bc (G.obj X \u2297 G.obj Y) (G.obj Z)), \u2190\n      cancel_epi (F.toLaxMonoidalFunctor.\u03bc (G.obj X) (G.obj Y) \u2297 \ud835\udfd9 (F.obj (G.obj Z))),\n      F.toLaxMonoidalFunctor.associativity_assoc (G.obj X) (G.obj Y) (G.obj Z), \u2190\n      F.toLaxMonoidalFunctor.\u03bc_natural_assoc, assoc, IsIso.hom_inv_id_assoc, \u2190\n      F.toLaxMonoidalFunctor.\u03bc_natural_assoc, IsIso.hom_inv_id_assoc, \u2190 tensor_comp, \u2190\n      tensor_comp, id_comp, Functor.map_id, Functor.map_id, id_comp, \u2190 tensor_comp_assoc, \u2190\n      tensor_comp_assoc, id_comp, id_comp, h.homEquiv_unit, h.homEquiv_unit, Functor.map_comp,\n      assoc, assoc, h.counit_naturality, h.left_triangle_components_assoc, Functor.map_comp,\n      assoc, h.counit_naturality, h.left_triangle_components_assoc]\n    simp\n  left_unitality X := by\n    rw [\u2190 h.homEquiv_naturality_right, \u2190 h.homEquiv_naturality_left, \u2190 Equiv.symm_apply_eq,\n      h.homEquiv_counit, F.map_leftUnitor, h.homEquiv_unit, assoc, assoc, assoc, F.map_tensor,\n      assoc, assoc, IsIso.hom_inv_id_assoc, \u2190 tensor_comp_assoc, Functor.map_id, id_comp,\n      Functor.map_comp, assoc, h.counit_naturality, h.left_triangle_components_assoc, \u2190\n      leftUnitor_naturality, \u2190 tensor_comp_assoc, id_comp, comp_id]\n    simp\n  right_unitality X := by\n    rw [\u2190 h.homEquiv_naturality_right, \u2190 h.homEquiv_naturality_left, \u2190 Equiv.symm_apply_eq,\n      h.homEquiv_counit, F.map_rightUnitor, assoc, assoc, \u2190 rightUnitor_naturality, \u2190\n      tensor_comp_assoc, comp_id, id_comp, h.homEquiv_unit, F.map_tensor, assoc, assoc, assoc,\n      IsIso.hom_inv_id_assoc, Functor.map_comp, Functor.map_id, \u2190 tensor_comp_assoc, assoc,\n      h.counit_naturality, h.left_triangle_components_assoc, id_comp]\n    simp", "start": [482, 1], "end": [522, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalInverse", "code": "@[simps]\nnoncomputable def monoidalInverse (F : MonoidalFunctor C D) [IsEquivalence F.toFunctor] :\n    MonoidalFunctor D C\n    where\n  toLaxMonoidalFunctor := monoidalAdjoint F (asEquivalence _).toAdjunction\n  \u03b5_isIso := by\n    dsimp [Equivalence.toAdjunction]\n    infer_instance\n  \u03bc_isIso X Y := by\n    dsimp [Equivalence.toAdjunction]\n    infer_instance", "start": [525, 1], "end": [536, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/ConcreteCategory/BundledHom.lean", "imports": ["Mathlib/CategoryTheory/ConcreteCategory/Bundled.lean", "Mathlib/CategoryTheory/ConcreteCategory/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.BundledHom", "code": "structure BundledHom where\n  \n  toFun : \u2200 {\u03b1 \u03b2 : Type u} (I\u03b1 : c \u03b1) (I\u03b2 : c \u03b2), hom I\u03b1 I\u03b2 \u2192 \u03b1 \u2192 \u03b2\n  \n  id : \u2200 {\u03b1 : Type u} (I : c \u03b1), hom I I\n  \n  comp : \u2200 {\u03b1 \u03b2 \u03b3 : Type u} (I\u03b1 : c \u03b1) (I\u03b2 : c \u03b2) (I\u03b3 : c \u03b3), hom I\u03b2 I\u03b3 \u2192 hom I\u03b1 I\u03b2 \u2192 hom I\u03b1 I\u03b3\n  \n  hom_ext : \u2200 {\u03b1 \u03b2 : Type u} (I\u03b1 : c \u03b1) (I\u03b2 : c \u03b2), Function.Injective (toFun I\u03b1 I\u03b2) := by\n   aesop_cat\n  \n  id_toFun : \u2200 {\u03b1 : Type u} (I : c \u03b1), toFun I I (id I) = _root_.id := by aesop_cat\n  \n  comp_toFun :\n    \u2200 {\u03b1 \u03b2 \u03b3 : Type u} (I\u03b1 : c \u03b1) (I\u03b2 : c \u03b2) (I\u03b3 : c \u03b3) (f : hom I\u03b1 I\u03b2) (g : hom I\u03b2 I\u03b3),\n      toFun I\u03b1 I\u03b3 (comp I\u03b1 I\u03b2 I\u03b3 g f) = toFun I\u03b2 I\u03b3 g \u2218 toFun I\u03b1 I\u03b2 f := by\n   aesop_cat", "start": [28, 1], "end": [46, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.BundledHom.category", "code": "instance category : Category (Bundled c) := by\n  refine' { Hom := fun X Y => @hom X Y X.str Y.str\n            id := fun X => @BundledHom.id c hom \ud835\udc9e X X.str\n            comp := @fun X Y Z f g => @BundledHom.comp c hom \ud835\udc9e X Y Z X.str Y.str Z.str g f\n            comp_id := _\n            id_comp := _\n            assoc := _ } <;> intros <;> apply \ud835\udc9e.hom_ext <;>\n    aesop_cat", "start": [61, 1], "end": [73, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.BundledHom.concreteCategory", "code": "instance concreteCategory : ConcreteCategory.{u} (Bundled c)\n    where\n  forget :=\n    { obj := fun X => X\n      map := @fun X Y f => \ud835\udc9e.toFun X.str Y.str f\n      map_id := fun X => \ud835\udc9e.id_toFun X.str\n      map_comp := fun f g => by dsimp; erw [\ud835\udc9e.comp_toFun];rfl }\n  forget_faithful := { map_injective := by (intros; apply \ud835\udc9e.hom_ext) }", "start": [76, 1], "end": [84, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.BundledHom.mkHasForget\u2082", "code": "def mkHasForget\u2082 {d : Type u \u2192 Type u} {hom_d : \u2200 \u2983\u03b1 \u03b2 : Type u\u2984 (_ : d \u03b1) (_ : d \u03b2), Type u}\n    [BundledHom hom_d] (obj : \u2200 \u2983\u03b1\u2984, c \u03b1 \u2192 d \u03b1)\n    (map : \u2200 {X Y : Bundled c}, (X \u27f6 Y) \u2192 (Bundled.map @obj X \u27f6 (Bundled.map @obj Y)))\n    (h_map : \u2200 {X Y : Bundled c} (f : X \u27f6 Y), \u21d1map f = \u21d1f) :\n    HasForget\u2082 (Bundled c) (Bundled d) :=\n  HasForget\u2082.mk' (Bundled.map @obj) (fun _ => rfl) map (by\n    intros X Y f\n    rw [heq_eq_eq, forget_map_eq_coe, forget_map_eq_coe, h_map f])", "start": [91, 1], "end": [99, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.BundledHom.MapHom", "code": "@[reducible]\ndef MapHom (F : \u2200 {\u03b1}, d \u03b1 \u2192 c \u03b1) : \u2200 \u2983\u03b1 \u03b2 : Type u\u2984 (_ : d \u03b1) (_ : d \u03b2), Type u :=\n  fun _ _ i\u03b1 i\u03b2 => hom (F i\u03b1) (F i\u03b2)", "start": [111, 1], "end": [117, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.BundledHom.map", "code": "def map (F : \u2200 {\u03b1}, d \u03b1 \u2192 c \u03b1) : BundledHom (MapHom hom @F)\n    where\n  toFun \u03b1 \u03b2 {i\u03b1} {i\u03b2} f := \ud835\udc9e.toFun (F i\u03b1) (F i\u03b2) f\n  id \u03b1 {i\u03b1} := \ud835\udc9e.id (F i\u03b1)\n  comp := @fun \u03b1 \u03b2 \u03b3 i\u03b1 i\u03b2 i\u03b3 f g => \ud835\udc9e.comp (F i\u03b1) (F i\u03b2) (F i\u03b3) f g\n  hom_ext := @fun \u03b1 \u03b2 i\u03b1 i\u03b2 f g h => \ud835\udc9e.hom_ext (F i\u03b1) (F i\u03b2) h", "start": [122, 1], "end": [130, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.BundledHom.ParentProjection", "code": "class ParentProjection (F : \u2200 {\u03b1}, d \u03b1 \u2192 c \u03b1) : Prop", "start": [138, 1], "end": [145, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.BundledHom.bundledHomOfParentProjection", "code": "@[nolint unusedArguments]\ninstance bundledHomOfParentProjection (F : \u2200 {\u03b1}, d \u03b1 \u2192 c \u03b1) [ParentProjection @F] :\n    BundledHom (MapHom hom @F) :=\n  map hom @F", "start": [151, 1], "end": [154, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.BundledHom.forget\u2082", "code": "instance forget\u2082 (F : \u2200 {\u03b1}, d \u03b1 \u2192 c \u03b1) [ParentProjection @F] :\n    HasForget\u2082 (Bundled d) (Bundled c) where\n  forget\u2082 :=\n    { obj := fun X => \u27e8X, F X.2\u27e9\n      map := @fun X Y f => f }", "start": [157, 1], "end": [161, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.BundledHom.forget\u2082Full", "code": "instance forget\u2082Full (F : \u2200 {\u03b1}, d \u03b1 \u2192 c \u03b1) [ParentProjection @F] :\n    Full (CategoryTheory.forget\u2082 (Bundled d) (Bundled c)) where preimage X Y {f} := f", "start": [164, 1], "end": [165, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/LpSpace.lean", "imports": ["Mathlib/Analysis/Normed/Group/Hom.lean", "Mathlib/MeasureTheory/Function/LpSeminorm.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/MeasureTheory/Measure/OpenPos.lean", "Mathlib/Topology/ContinuousFunction/Compact.lean"], "premises": [{"full_name": "MeasureTheory.snorm_aeeqFun", "code": "@[simp]\ntheorem snorm_aeeqFun {\u03b1 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} [NormedAddCommGroup E]\n    {p : \u211d\u22650\u221e} {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc) :\n    snorm (AEEqFun.mk f hf) p \u03bc = snorm f p \u03bc", "start": [85, 1], "end": [89, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.snorm_mk_lt_top", "code": "theorem Mem\u2112p.snorm_mk_lt_top {\u03b1 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}\n    [NormedAddCommGroup E] {p : \u211d\u22650\u221e} {f : \u03b1 \u2192 E} (hfp : Mem\u2112p f p \u03bc) :\n    snorm (AEEqFun.mk f hfp.1) p \u03bc < \u221e", "start": [92, 1], "end": [94, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp", "code": "def Lp {\u03b1} (E : Type*) {m : MeasurableSpace \u03b1} [NormedAddCommGroup E] (p : \u211d\u22650\u221e)\n    (\u03bc : Measure \u03b1 := by volume_tac) : AddSubgroup (\u03b1 \u2192\u2098[\u03bc] E) where\n  carrier := { f | snorm f p \u03bc < \u221e }\n  zero_mem' := by simp [snorm_congr_ae AEEqFun.coeFn_zero, snorm_zero]\n  add_mem' {f g} hf hg := by\n    simp [snorm_congr_ae (AEEqFun.coeFn_add f g),\n      snorm_add_lt_top \u27e8f.aestronglyMeasurable, hf\u27e9 \u27e8g.aestronglyMeasurable, hg\u27e9]\n  neg_mem' {f} hf := by rwa [Set.mem_setOf_eq, snorm_congr_ae (AEEqFun.coeFn_neg f), snorm_neg]", "start": [97, 1], "end": [105, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.toLp", "code": "def toLp (f : \u03b1 \u2192 E) (h_mem_\u2112p : Mem\u2112p f p \u03bc) : Lp E p \u03bc :=\n  \u27e8AEEqFun.mk f h_mem_\u2112p.1, h_mem_\u2112p.snorm_mk_lt_top\u27e9", "start": [114, 1], "end": [116, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.coeFn_toLp", "code": "theorem coeFn_toLp {f : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) : hf.toLp f =\u1d50[\u03bc] f", "start": [119, 1], "end": [120, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.toLp_congr", "code": "theorem toLp_congr {f g : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) (hg : Mem\u2112p g p \u03bc) (hfg : f =\u1d50[\u03bc] g) :\n    hf.toLp f = hg.toLp g", "start": [123, 1], "end": [124, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.toLp_eq_toLp_iff", "code": "@[simp]\ntheorem toLp_eq_toLp_iff {f g : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) (hg : Mem\u2112p g p \u03bc) :\n    hf.toLp f = hg.toLp g \u2194 f =\u1d50[\u03bc] g", "start": [127, 1], "end": [129, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.toLp_zero", "code": "@[simp]\ntheorem toLp_zero (h : Mem\u2112p (0 : \u03b1 \u2192 E) p \u03bc) : h.toLp 0 = 0", "start": [132, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.toLp_add", "code": "theorem toLp_add {f g : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) (hg : Mem\u2112p g p \u03bc) :\n    (hf.add hg).toLp (f + g) = hf.toLp f + hg.toLp g", "start": [137, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.toLp_neg", "code": "theorem toLp_neg {f : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) : hf.neg.toLp (-f) = -hf.toLp f", "start": [142, 1], "end": [143, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.toLp_sub", "code": "theorem toLp_sub {f g : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) (hg : Mem\u2112p g p \u03bc) :\n    (hf.sub hg).toLp (f - g) = hf.toLp f - hg.toLp g", "start": [146, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.instCoeFun", "code": "instance instCoeFun : CoeFun (Lp E p \u03bc) (fun _ => \u03b1 \u2192 E) :=\n  \u27e8fun f => ((f : \u03b1 \u2192\u2098[\u03bc] E) : \u03b1 \u2192 E)\u27e9", "start": [155, 1], "end": [156, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.ext", "code": "@[ext high]\ntheorem ext {f g : Lp E p \u03bc} (h : f =\u1d50[\u03bc] g) : f = g", "start": [159, 1], "end": [164, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.ext_iff", "code": "theorem ext_iff {f g : Lp E p \u03bc} : f = g \u2194 f =\u1d50[\u03bc] g", "start": [167, 1], "end": [168, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.mem_Lp_iff_snorm_lt_top", "code": "theorem mem_Lp_iff_snorm_lt_top {f : \u03b1 \u2192\u2098[\u03bc] E} : f \u2208 Lp E p \u03bc \u2194 snorm f p \u03bc < \u221e", "start": [171, 1], "end": [171, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.mem_Lp_iff_mem\u2112p", "code": "theorem mem_Lp_iff_mem\u2112p {f : \u03b1 \u2192\u2098[\u03bc] E} : f \u2208 Lp E p \u03bc \u2194 Mem\u2112p f p \u03bc", "start": [174, 1], "end": [175, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.antitone", "code": "protected theorem antitone [IsFiniteMeasure \u03bc] {p q : \u211d\u22650\u221e} (hpq : p \u2264 q) : Lp E q \u03bc \u2264 Lp E p \u03bc", "start": [178, 1], "end": [179, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coeFn_mk", "code": "@[simp]\ntheorem coeFn_mk {f : \u03b1 \u2192\u2098[\u03bc] E} (hf : snorm f p \u03bc < \u221e) : ((\u27e8f, hf\u27e9 : Lp E p \u03bc) : \u03b1 \u2192 E) = f", "start": [182, 1], "end": [184, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coe_mk", "code": "theorem coe_mk {f : \u03b1 \u2192\u2098[\u03bc] E} (hf : snorm f p \u03bc < \u221e) : ((\u27e8f, hf\u27e9 : Lp E p \u03bc) : \u03b1 \u2192\u2098[\u03bc] E) = f", "start": [188, 1], "end": [189, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.toLp_coeFn", "code": "@[simp]\ntheorem toLp_coeFn (f : Lp E p \u03bc) (hf : Mem\u2112p f p \u03bc) : hf.toLp f = f", "start": [192, 1], "end": [195, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.snorm_lt_top", "code": "theorem snorm_lt_top (f : Lp E p \u03bc) : snorm f p \u03bc < \u221e", "start": [198, 1], "end": [199, 9], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.snorm_ne_top", "code": "theorem snorm_ne_top (f : Lp E p \u03bc) : snorm f p \u03bc \u2260 \u221e", "start": [202, 1], "end": [203, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.stronglyMeasurable", "code": "@[measurability]\nprotected theorem stronglyMeasurable (f : Lp E p \u03bc) : StronglyMeasurable f", "start": [206, 1], "end": [208, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.aestronglyMeasurable", "code": "@[measurability]\nprotected theorem aestronglyMeasurable (f : Lp E p \u03bc) : AEStronglyMeasurable f \u03bc", "start": [211, 1], "end": [213, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.mem\u2112p", "code": "protected theorem mem\u2112p (f : Lp E p \u03bc) : Mem\u2112p f p \u03bc", "start": [216, 1], "end": [217, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coeFn_zero", "code": "theorem coeFn_zero : \u21d1(0 : Lp E p \u03bc) =\u1d50[\u03bc] 0", "start": [222, 1], "end": [223, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coeFn_neg", "code": "theorem coeFn_neg (f : Lp E p \u03bc) : \u21d1(-f) =\u1d50[\u03bc] -f", "start": [228, 1], "end": [229, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coeFn_add", "code": "theorem coeFn_add (f g : Lp E p \u03bc) : \u21d1(f + g) =\u1d50[\u03bc] f + g", "start": [232, 1], "end": [233, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coeFn_sub", "code": "theorem coeFn_sub (f g : Lp E p \u03bc) : \u21d1(f - g) =\u1d50[\u03bc] f - g", "start": [236, 1], "end": [237, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.const_mem_Lp", "code": "theorem const_mem_Lp (\u03b1) {_ : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) (c : E) [IsFiniteMeasure \u03bc] :\n    @AEEqFun.const \u03b1 _ _ \u03bc _ c \u2208 Lp E p \u03bc", "start": [240, 1], "end": [242, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.instNorm", "code": "instance instNorm : Norm (Lp E p \u03bc) where norm f := ENNReal.toReal (snorm f p \u03bc)", "start": [245, 1], "end": [245, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.instNNNorm", "code": "instance instNNNorm : NNNorm (Lp E p \u03bc) where nnnorm f := \u27e8\u2016f\u2016, ENNReal.toReal_nonneg\u27e9", "start": [250, 1], "end": [250, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.instDist", "code": "instance instDist : Dist (Lp E p \u03bc) where dist f g := \u2016f - g\u2016", "start": [253, 1], "end": [253, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.instEDist", "code": "instance instEDist : EDist (Lp E p \u03bc) where edist f g := snorm (\u21d1f - \u21d1g) p \u03bc", "start": [256, 1], "end": [256, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.norm_def", "code": "theorem norm_def (f : Lp E p \u03bc) : \u2016f\u2016 = ENNReal.toReal (snorm f p \u03bc)", "start": [259, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.nnnorm_def", "code": "theorem nnnorm_def (f : Lp E p \u03bc) : \u2016f\u2016\u208a = ENNReal.toNNReal (snorm f p \u03bc)", "start": [263, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coe_nnnorm", "code": "@[simp, norm_cast]\nprotected theorem coe_nnnorm (f : Lp E p \u03bc) : (\u2016f\u2016\u208a : \u211d) = \u2016f\u2016", "start": [267, 1], "end": [269, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.nnnorm_coe_ennreal", "code": "@[simp, norm_cast]\ntheorem nnnorm_coe_ennreal (f : Lp E p \u03bc) : (\u2016f\u2016\u208a : \u211d\u22650\u221e) = snorm f p \u03bc", "start": [272, 1], "end": [274, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.norm_toLp", "code": "@[simp]\ntheorem norm_toLp (f : \u03b1 \u2192 E) (hf : Mem\u2112p f p \u03bc) : \u2016hf.toLp f\u2016 = ENNReal.toReal (snorm f p \u03bc)", "start": [276, 1], "end": [278, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.nnnorm_toLp", "code": "@[simp]\ntheorem nnnorm_toLp (f : \u03b1 \u2192 E) (hf : Mem\u2112p f p \u03bc) :\n    \u2016hf.toLp f\u2016\u208a = ENNReal.toNNReal (snorm f p \u03bc)", "start": [281, 1], "end": [284, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coe_nnnorm_toLp", "code": "theorem coe_nnnorm_toLp {f : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) : (\u2016hf.toLp f\u2016\u208a : \u211d\u22650\u221e) = snorm f p \u03bc", "start": [287, 1], "end": [288, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.dist_def", "code": "theorem dist_def (f g : Lp E p \u03bc) : dist f g = (snorm (\u21d1f - \u21d1g) p \u03bc).toReal", "start": [290, 1], "end": [293, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.edist_def", "code": "theorem edist_def (f g : Lp E p \u03bc) : edist f g = snorm (\u21d1f - \u21d1g) p \u03bc", "start": [296, 1], "end": [297, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.edist_dist", "code": "protected theorem edist_dist (f g : Lp E p \u03bc) : edist f g = .ofReal (dist f g)", "start": [300, 1], "end": [302, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.dist_edist", "code": "protected theorem dist_edist (f g : Lp E p \u03bc) : dist f g = (edist f g).toReal", "start": [304, 1], "end": [305, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.edist_toLp_toLp", "code": "@[simp]\ntheorem edist_toLp_toLp (f g : \u03b1 \u2192 E) (hf : Mem\u2112p f p \u03bc) (hg : Mem\u2112p g p \u03bc) :\n    edist (hf.toLp f) (hg.toLp g) = snorm (f - g) p \u03bc", "start": [307, 1], "end": [311, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.edist_toLp_zero", "code": "@[simp]\ntheorem edist_toLp_zero (f : \u03b1 \u2192 E) (hf : Mem\u2112p f p \u03bc) : edist (hf.toLp f) 0 = snorm f p \u03bc", "start": [314, 1], "end": [317, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.nnnorm_zero", "code": "@[simp]\ntheorem nnnorm_zero : \u2016(0 : Lp E p \u03bc)\u2016\u208a = 0", "start": [320, 1], "end": [324, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.norm_zero", "code": "@[simp]\ntheorem norm_zero : \u2016(0 : Lp E p \u03bc)\u2016 = 0", "start": [327, 1], "end": [329, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.norm_measure_zero", "code": "@[simp]\ntheorem norm_measure_zero (f : Lp E p (0 : MeasureTheory.Measure \u03b1)) : \u2016f\u2016 = 0", "start": [332, 1], "end": [334, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.norm_exponent_zero", "code": "@[simp] theorem norm_exponent_zero (f : Lp E 0 \u03bc) : \u2016f\u2016 = 0", "start": [336, 1], "end": [336, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.nnnorm_eq_zero_iff", "code": "theorem nnnorm_eq_zero_iff {f : Lp E p \u03bc} (hp : 0 < p) : \u2016f\u2016\u208a = 0 \u2194 f = 0", "start": [338, 1], "end": [346, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.norm_eq_zero_iff", "code": "theorem norm_eq_zero_iff {f : Lp E p \u03bc} (hp : 0 < p) : \u2016f\u2016 = 0 \u2194 f = 0", "start": [349, 1], "end": [350, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.eq_zero_iff_ae_eq_zero", "code": "theorem eq_zero_iff_ae_eq_zero {f : Lp E p \u03bc} : f = 0 \u2194 f =\u1d50[\u03bc] 0", "start": [353, 1], "end": [354, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.nnnorm_neg", "code": "@[simp]\ntheorem nnnorm_neg (f : Lp E p \u03bc) : \u2016-f\u2016\u208a = \u2016f\u2016\u208a", "start": [357, 1], "end": [359, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.norm_neg", "code": "@[simp]\ntheorem norm_neg (f : Lp E p \u03bc) : \u2016-f\u2016 = \u2016f\u2016", "start": [362, 1], "end": [364, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.nnnorm_le_mul_nnnorm_of_ae_le_mul", "code": "theorem nnnorm_le_mul_nnnorm_of_ae_le_mul {c : \u211d\u22650} {f : Lp E p \u03bc} {g : Lp F p \u03bc}\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 c * \u2016g x\u2016\u208a) : \u2016f\u2016\u208a \u2264 c * \u2016g\u2016\u208a", "start": [367, 1], "end": [374, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.norm_le_mul_norm_of_ae_le_mul", "code": "theorem norm_le_mul_norm_of_ae_le_mul {c : \u211d} {f : Lp E p \u03bc} {g : Lp F p \u03bc}\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 c * \u2016g x\u2016) : \u2016f\u2016 \u2264 c * \u2016g\u2016", "start": [377, 1], "end": [384, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.norm_le_norm_of_ae_le", "code": "theorem norm_le_norm_of_ae_le {f : Lp E p \u03bc} {g : Lp F p \u03bc} (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 \u2016g x\u2016) :\n    \u2016f\u2016 \u2264 \u2016g\u2016", "start": [387, 1], "end": [390, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.mem_Lp_of_nnnorm_ae_le_mul", "code": "theorem mem_Lp_of_nnnorm_ae_le_mul {c : \u211d\u22650} {f : \u03b1 \u2192\u2098[\u03bc] E} {g : Lp F p \u03bc}\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 c * \u2016g x\u2016\u208a) : f \u2208 Lp E p \u03bc", "start": [393, 1], "end": [395, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.mem_Lp_of_ae_le_mul", "code": "theorem mem_Lp_of_ae_le_mul {c : \u211d} {f : \u03b1 \u2192\u2098[\u03bc] E} {g : Lp F p \u03bc}\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 c * \u2016g x\u2016) : f \u2208 Lp E p \u03bc", "start": [398, 1], "end": [400, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.mem_Lp_of_nnnorm_ae_le", "code": "theorem mem_Lp_of_nnnorm_ae_le {f : \u03b1 \u2192\u2098[\u03bc] E} {g : Lp F p \u03bc} (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 \u2016g x\u2016\u208a) :\n    f \u2208 Lp E p \u03bc", "start": [403, 1], "end": [405, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.mem_Lp_of_ae_le", "code": "theorem mem_Lp_of_ae_le {f : \u03b1 \u2192\u2098[\u03bc] E} {g : Lp F p \u03bc} (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 \u2016g x\u2016) :\n    f \u2208 Lp E p \u03bc", "start": [408, 1], "end": [410, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.mem_Lp_of_ae_nnnorm_bound", "code": "theorem mem_Lp_of_ae_nnnorm_bound [IsFiniteMeasure \u03bc] {f : \u03b1 \u2192\u2098[\u03bc] E} (C : \u211d\u22650)\n    (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 C) : f \u2208 Lp E p \u03bc", "start": [413, 1], "end": [415, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.mem_Lp_of_ae_bound", "code": "theorem mem_Lp_of_ae_bound [IsFiniteMeasure \u03bc] {f : \u03b1 \u2192\u2098[\u03bc] E} (C : \u211d) (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 C) :\n    f \u2208 Lp E p \u03bc", "start": [418, 1], "end": [420, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.nnnorm_le_of_ae_bound", "code": "theorem nnnorm_le_of_ae_bound [IsFiniteMeasure \u03bc] {f : Lp E p \u03bc} {C : \u211d\u22650}\n    (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u208a \u2264 C) : \u2016f\u2016\u208a \u2264 measureUnivNNReal \u03bc ^ p.toReal\u207b\u00b9 * C", "start": [423, 1], "end": [432, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.norm_le_of_ae_bound", "code": "theorem norm_le_of_ae_bound [IsFiniteMeasure \u03bc] {f : Lp E p \u03bc} {C : \u211d} (hC : 0 \u2264 C)\n    (hfC : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 C) : \u2016f\u2016 \u2264 measureUnivNNReal \u03bc ^ p.toReal\u207b\u00b9 * C", "start": [435, 1], "end": [439, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.instNormedAddCommGroup", "code": "instance instNormedAddCommGroup [hp : Fact (1 \u2264 p)] : NormedAddCommGroup (Lp E p \u03bc) :=\n  { AddGroupNorm.toNormedAddCommGroup\n      { toFun := (norm : Lp E p \u03bc \u2192 \u211d)\n        map_zero' := norm_zero\n        neg' := by simp\n        add_le' := fun f g => by\n          suffices (\u2016f + g\u2016\u208a : \u211d\u22650\u221e) \u2264 \u2016f\u2016\u208a + \u2016g\u2016\u208a by exact_mod_cast this\n          simp only [Lp.nnnorm_coe_ennreal]\n          exact (snorm_congr_ae (AEEqFun.coeFn_add _ _)).trans_le\n            (snorm_add_le (Lp.aestronglyMeasurable _) (Lp.aestronglyMeasurable _) hp.out)\n        eq_zero_of_map_eq_zero' := fun f =>\n          (norm_eq_zero_iff <| zero_lt_one.trans_le hp.1).1 } with\n    edist := edist\n    edist_dist := Lp.edist_dist }", "start": [442, 1], "end": [455, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.const_smul_mem_Lp", "code": "theorem const_smul_mem_Lp (c : \ud835\udd5c) (f : Lp E p \u03bc) : c \u2022 (f : \u03b1 \u2192\u2098[\u03bc] E) \u2208 Lp E p \u03bc", "start": [473, 1], "end": [477, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.LpSubmodule", "code": "def LpSubmodule : Submodule \ud835\udd5c (\u03b1 \u2192\u2098[\u03bc] E) :=\n  { Lp E p \u03bc with smul_mem' := fun c f hf => by simpa using const_smul_mem_Lp c \u27e8f, hf\u27e9 }", "start": [482, 1], "end": [485, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coe_LpSubmodule", "code": "theorem coe_LpSubmodule : (LpSubmodule E p \u03bc \ud835\udd5c).toAddSubgroup = Lp E p \u03bc", "start": [490, 1], "end": [491, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.instModule", "code": "instance instModule : Module \ud835\udd5c (Lp E p \u03bc) :=\n  { (LpSubmodule E p \u03bc \ud835\udd5c).module with }", "start": [494, 1], "end": [495, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coeFn_smul", "code": "theorem coeFn_smul (c : \ud835\udd5c) (f : Lp E p \u03bc) : \u21d1(c \u2022 f) =\u1d50[\u03bc] c \u2022 \u21d1f", "start": [498, 1], "end": [499, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.instIsCentralScalar", "code": "instance instIsCentralScalar [Module \ud835\udd5c\u1d50\u1d52\u1d56 E] [BoundedSMul \ud835\udd5c\u1d50\u1d52\u1d56 E] [IsCentralScalar \ud835\udd5c E] :\n    IsCentralScalar \ud835\udd5c (Lp E p \u03bc) where\n  op_smul_eq_smul k f := Subtype.ext <| op_smul_eq_smul k (f : \u03b1 \u2192\u2098[\u03bc] E)", "start": [502, 1], "end": [504, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.instSMulCommClass", "code": "instance instSMulCommClass [SMulCommClass \ud835\udd5c \ud835\udd5c' E] : SMulCommClass \ud835\udd5c \ud835\udd5c' (Lp E p \u03bc) where\n  smul_comm k k' f := Subtype.ext <| smul_comm k k' (f : \u03b1 \u2192\u2098[\u03bc] E)", "start": [507, 1], "end": [508, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.instIsScalarTower", "code": "instance instIsScalarTower [SMul \ud835\udd5c \ud835\udd5c'] [IsScalarTower \ud835\udd5c \ud835\udd5c' E] : IsScalarTower \ud835\udd5c \ud835\udd5c' (Lp E p \u03bc) where\n  smul_assoc k k' f := Subtype.ext <| smul_assoc k k' (f : \u03b1 \u2192\u2098[\u03bc] E)", "start": [511, 1], "end": [512, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.instBoundedSMul", "code": "instance instBoundedSMul [Fact (1 \u2264 p)] : BoundedSMul \ud835\udd5c (Lp E p \u03bc) :=\n  BoundedSMul.of_norm_smul_le fun r f => by\n    suffices (\u2016r \u2022 f\u2016\u208a : \u211d\u22650\u221e) \u2264 \u2016r\u2016\u208a * \u2016f\u2016\u208a by exact_mod_cast this\n    rw [nnnorm_def, nnnorm_def, ENNReal.coe_toNNReal (Lp.snorm_ne_top _),\n      snorm_congr_ae (coeFn_smul _ _), ENNReal.coe_toNNReal (Lp.snorm_ne_top _)]\n    exact snorm_const_smul_le r f", "start": [514, 1], "end": [520, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.instNormedSpace", "code": "instance instNormedSpace [Fact (1 \u2264 p)] : NormedSpace \ud835\udd5c (Lp E p \u03bc) where\n  norm_smul_le _ _ := norm_smul_le _ _", "start": [529, 1], "end": [530, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.toLp_const_smul", "code": "theorem toLp_const_smul {f : \u03b1 \u2192 E} (c : \ud835\udd5c) (hf : Mem\u2112p f p \u03bc) :\n    (hf.const_smul c).toLp (c \u2022 f) = c \u2022 hf.toLp f", "start": [541, 1], "end": [543, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_indicator_le", "code": "theorem snormEssSup_indicator_le (s : Set \u03b1) (f : \u03b1 \u2192 G) :\n    snormEssSup (s.indicator f) \u03bc \u2264 snormEssSup f \u03bc", "start": [561, 1], "end": [565, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_indicator_const_le", "code": "theorem snormEssSup_indicator_const_le (s : Set \u03b1) (c : G) :\n    snormEssSup (s.indicator fun _ : \u03b1 => c) \u03bc \u2264 \u2016c\u2016\u208a", "start": [568, 1], "end": [573, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_indicator_const_eq", "code": "theorem snormEssSup_indicator_const_eq (s : Set \u03b1) (c : G) (h\u03bcs : \u03bc s \u2260 0) :\n    snormEssSup (s.indicator fun _ : \u03b1 => c) \u03bc = \u2016c\u2016\u208a", "start": [576, 1], "end": [583, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_indicator_le", "code": "theorem snorm_indicator_le (f : \u03b1 \u2192 E) {s : Set \u03b1} :\n    snorm (s.indicator f) p \u03bc \u2264 snorm f p \u03bc", "start": [586, 1], "end": [591, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_indicator_const\u2080", "code": "theorem snorm_indicator_const\u2080 {c : G} (hs : NullMeasurableSet s \u03bc) (hp : p \u2260 0) (hp_top : p \u2260 \u221e) :\n    snorm (s.indicator fun _ => c) p \u03bc = \u2016c\u2016\u208a * \u03bc s ^ (1 / p.toReal)", "start": [594, 1], "end": [608, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_indicator_const", "code": "theorem snorm_indicator_const {c : G} (hs : MeasurableSet s) (hp : p \u2260 0) (hp_top : p \u2260 \u221e) :\n    snorm (s.indicator fun _ => c) p \u03bc = \u2016c\u2016\u208a * \u03bc s ^ (1 / p.toReal)", "start": [610, 1], "end": [612, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_indicator_const'", "code": "theorem snorm_indicator_const' {c : G} (hs : MeasurableSet s) (h\u03bcs : \u03bc s \u2260 0) (hp : p \u2260 0) :\n    snorm (s.indicator fun _ => c) p \u03bc = \u2016c\u2016\u208a * \u03bc s ^ (1 / p.toReal)", "start": [615, 1], "end": [619, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_indicator_const_le", "code": "theorem snorm_indicator_const_le (c : G) (p : \u211d\u22650\u221e) :\n    snorm (s.indicator fun _ => c) p \u03bc \u2264 \u2016c\u2016\u208a * \u03bc s ^ (1 / p.toReal)", "start": [622, 1], "end": [635, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.indicator", "code": "theorem Mem\u2112p.indicator (hs : MeasurableSet s) (hf : Mem\u2112p f p \u03bc) : Mem\u2112p (s.indicator f) p \u03bc", "start": [638, 1], "end": [639, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snormEssSup_indicator_eq_snormEssSup_restrict", "code": "theorem snormEssSup_indicator_eq_snormEssSup_restrict {f : \u03b1 \u2192 F} (hs : MeasurableSet s) :\n    snormEssSup (s.indicator f) \u03bc = snormEssSup f (\u03bc.restrict s)", "start": [642, 1], "end": [654, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_indicator_eq_snorm_restrict", "code": "theorem snorm_indicator_eq_snorm_restrict {f : \u03b1 \u2192 F} (hs : MeasurableSet s) :\n    snorm (s.indicator f) p \u03bc = snorm f p (\u03bc.restrict s)", "start": [657, 1], "end": [674, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_indicator_iff_restrict", "code": "theorem mem\u2112p_indicator_iff_restrict (hs : MeasurableSet s) :\n    Mem\u2112p (s.indicator f) p \u03bc \u2194 Mem\u2112p f p (\u03bc.restrict s)", "start": [677, 1], "end": [679, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.mem\u2112p_of_exponent_le_of_measure_support_ne_top", "code": "theorem Mem\u2112p.mem\u2112p_of_exponent_le_of_measure_support_ne_top\n    {p q : \u211d\u22650\u221e} {f : \u03b1 \u2192 E} (hfq : Mem\u2112p f q \u03bc) {s : Set \u03b1} (hf : \u2200 x, x \u2209 s \u2192 f x = 0)\n    (hs : \u03bc s \u2260 \u221e) (hpq : p \u2264 q) : Mem\u2112p f p \u03bc", "start": [682, 1], "end": [694, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_indicator_const", "code": "theorem mem\u2112p_indicator_const (p : \u211d\u22650\u221e) (hs : MeasurableSet s) (c : E) (h\u03bcsc : c = 0 \u2228 \u03bc s \u2260 \u221e) :\n    Mem\u2112p (s.indicator fun _ => c) p \u03bc", "start": [696, 1], "end": [702, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_snorm_indicator_le", "code": "theorem exists_snorm_indicator_le (hp : p \u2260 \u221e) (c : E) {\u03b5 : \u211d\u22650\u221e} (h\u03b5 : \u03b5 \u2260 0) :\n    \u2203 \u03b7 : \u211d\u22650, 0 < \u03b7 \u2227 \u2200 s : Set \u03b1, \u03bc s \u2264 \u03b7 \u2192 snorm (s.indicator fun _ => c) p \u03bc \u2264 \u03b5", "start": [705, 1], "end": [732, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.indicatorConstLp", "code": "def indicatorConstLp (p : \u211d\u22650\u221e) (hs : MeasurableSet s) (h\u03bcs : \u03bc s \u2260 \u221e) (c : E) : Lp E p \u03bc :=\n  Mem\u2112p.toLp (s.indicator fun _ => c) (mem\u2112p_indicator_const p hs c (Or.inr h\u03bcs))", "start": [743, 1], "end": [745, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.indicatorConstLp_coeFn", "code": "theorem indicatorConstLp_coeFn : \u21d1(indicatorConstLp p hs h\u03bcs c) =\u1d50[\u03bc] s.indicator fun _ => c", "start": [748, 1], "end": [749, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.indicatorConstLp_coeFn_mem", "code": "theorem indicatorConstLp_coeFn_mem : \u2200\u1d50 x : \u03b1 \u2202\u03bc, x \u2208 s \u2192 indicatorConstLp p hs h\u03bcs c x = c", "start": [752, 1], "end": [753, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.indicatorConstLp_coeFn_nmem", "code": "theorem indicatorConstLp_coeFn_nmem : \u2200\u1d50 x : \u03b1 \u2202\u03bc, x \u2209 s \u2192 indicatorConstLp p hs h\u03bcs c x = 0", "start": [756, 1], "end": [757, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.norm_indicatorConstLp", "code": "theorem norm_indicatorConstLp (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e) :\n    \u2016indicatorConstLp p hs h\u03bcs c\u2016 = \u2016c\u2016 * (\u03bc s).toReal ^ (1 / p.toReal)", "start": [760, 1], "end": [764, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.norm_indicatorConstLp_top", "code": "theorem norm_indicatorConstLp_top (h\u03bcs_ne_zero : \u03bc s \u2260 0) :\n    \u2016indicatorConstLp \u221e hs h\u03bcs c\u2016 = \u2016c\u2016", "start": [767, 1], "end": [771, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.norm_indicatorConstLp'", "code": "theorem norm_indicatorConstLp' (hp_pos : p \u2260 0) (h\u03bcs_pos : \u03bc s \u2260 0) :\n    \u2016indicatorConstLp p hs h\u03bcs c\u2016 = \u2016c\u2016 * (\u03bc s).toReal ^ (1 / p.toReal)", "start": [774, 1], "end": [779, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.norm_indicatorConstLp_le", "code": "theorem norm_indicatorConstLp_le :\n    \u2016indicatorConstLp p hs h\u03bcs c\u2016 \u2264 \u2016c\u2016 * (\u03bc s).toReal ^ (1 / p.toReal)", "start": [782, 1], "end": [789, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.edist_indicatorConstLp_eq_nnnorm", "code": "theorem edist_indicatorConstLp_eq_nnnorm {t : Set \u03b1} (ht : MeasurableSet t) (h\u03bct : \u03bc t \u2260 \u221e) :\n    edist (indicatorConstLp p hs h\u03bcs c) (indicatorConstLp p ht h\u03bct c) =\n      \u2016indicatorConstLp p (hs.symmDiff ht) (measure_symmDiff_ne_top h\u03bcs h\u03bct) c\u2016\u208a", "start": [791, 1], "end": [795, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.dist_indicatorConstLp_eq_norm", "code": "theorem dist_indicatorConstLp_eq_norm {t : Set \u03b1} (ht : MeasurableSet t) (h\u03bct : \u03bc t \u2260 \u221e) :\n    dist (indicatorConstLp p hs h\u03bcs c) (indicatorConstLp p ht h\u03bct c) =\n      \u2016indicatorConstLp p (hs.symmDiff ht) (measure_symmDiff_ne_top h\u03bcs h\u03bct) c\u2016", "start": [797, 1], "end": [800, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.indicatorConstLp_empty", "code": "@[simp]\ntheorem indicatorConstLp_empty :\n    indicatorConstLp p MeasurableSet.empty (by simp : \u03bc \u2205 \u2260 \u221e) c = 0", "start": [802, 1], "end": [807, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_add_of_disjoint", "code": "theorem mem\u2112p_add_of_disjoint {f g : \u03b1 \u2192 E} (h : Disjoint (support f) (support g))\n    (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    Mem\u2112p (f + g) p \u03bc \u2194 Mem\u2112p f p \u03bc \u2227 Mem\u2112p g p \u03bc", "start": [810, 1], "end": [816, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.indicatorConstLp_disjoint_union", "code": "theorem indicatorConstLp_disjoint_union {s t : Set \u03b1} (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h\u03bcs : \u03bc s \u2260 \u221e) (h\u03bct : \u03bc t \u2260 \u221e) (hst : s \u2229 t = \u2205) (c : E) :\n    indicatorConstLp p (hs.union ht) (measure_union_ne_top h\u03bcs h\u03bct) c =\n      indicatorConstLp p hs h\u03bcs c + indicatorConstLp p ht h\u03bct c", "start": [819, 1], "end": [829, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.const", "code": "protected def Lp.const : E \u2192+ Lp E p \u03bc where\n  toFun c := \u27e8AEEqFun.const \u03b1 c, const_mem_Lp \u03b1 \u03bc c\u27e9\n  map_zero' := rfl\n  map_add' _ _ := rfl", "start": [839, 1], "end": [843, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coeFn_const", "code": "lemma Lp.coeFn_const : Lp.const p \u03bc c =\u1d50[\u03bc] Function.const \u03b1 c :=\n  AEEqFun.coeFn_const \u03b1 c", "start": [845, 1], "end": [846, 26], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.Lp.const_val", "code": "@[simp] lemma Lp.const_val : (Lp.const p \u03bc c).1 = AEEqFun.const \u03b1 c := rfl", "start": [848, 1], "end": [848, 75], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.Mem\u2112p.toLp_const", "code": "@[simp]\nlemma Mem\u2112p.toLp_const : Mem\u2112p.toLp _ (mem\u2112p_const c) = Lp.const p \u03bc c := rfl", "start": [850, 1], "end": [851, 78], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.indicatorConstLp_univ", "code": "@[simp]\nlemma indicatorConstLp_univ :\n    indicatorConstLp p .univ (measure_ne_top \u03bc _) c = Lp.const p \u03bc c := by\n  rw [\u2190 Mem\u2112p.toLp_const, indicatorConstLp]\n  simp only [Set.indicator_univ, Function.const]", "start": [853, 1], "end": [857, 49], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.Lp.norm_const", "code": "theorem Lp.norm_const [NeZero \u03bc] (hp_zero : p \u2260 0) :\n    \u2016Lp.const p \u03bc c\u2016 = \u2016c\u2016 * (\u03bc Set.univ).toReal ^ (1 / p.toReal)", "start": [859, 1], "end": [863, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.norm_const'", "code": "theorem Lp.norm_const' (hp_zero : p \u2260 0) (hp_top : p \u2260 \u221e) :\n    \u2016Lp.const p \u03bc c\u2016 = \u2016c\u2016 * (\u03bc Set.univ).toReal ^ (1 / p.toReal)", "start": [865, 1], "end": [868, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.norm_const_le", "code": "theorem Lp.norm_const_le : \u2016Lp.const p \u03bc c\u2016 \u2264 \u2016c\u2016 * (\u03bc Set.univ).toReal ^ (1 / p.toReal)", "start": [870, 1], "end": [872, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.const\u2097", "code": "@[simps] protected def Lp.const\u2097 (\ud835\udd5c : Type*) [NormedRing \ud835\udd5c] [Module \ud835\udd5c E] [BoundedSMul \ud835\udd5c E] :\n    E \u2192\u2097[\ud835\udd5c] Lp E p \u03bc where\n  toFun := Lp.const p \u03bc\n  map_add' := map_add _\n  map_smul' _ _ := rfl", "start": [874, 1], "end": [879, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.constL", "code": "@[simps! apply]\nprotected def Lp.constL (\ud835\udd5c : Type*) [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] [Fact (1 \u2264 p)] :\n    E \u2192L[\ud835\udd5c] Lp E p \u03bc :=\n  (Lp.const\u2097 p \u03bc \ud835\udd5c).mkContinuous ((\u03bc Set.univ).toReal ^ (1 / p.toReal)) <| fun _ \u21a6\n    (Lp.norm_const_le _ _ _).trans_eq (mul_comm _ _)", "start": [881, 1], "end": [885, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.norm_constL_le", "code": "theorem Lp.norm_constL_le (\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E]\n    [Fact (1 \u2264 p)] :\n    \u2016(Lp.constL p \u03bc \ud835\udd5c : E \u2192L[\ud835\udd5c] Lp E p \u03bc)\u2016 \u2264 (\u03bc Set.univ).toReal ^ (1 / p.toReal)", "start": [887, 1], "end": [890, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.norm_rpow_div", "code": "theorem Mem\u2112p.norm_rpow_div {f : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) (q : \u211d\u22650\u221e) :\n    Mem\u2112p (fun x : \u03b1 => \u2016f x\u2016 ^ q.toReal) (p / q) \u03bc", "start": [894, 1], "end": [909, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_norm_rpow_iff", "code": "theorem mem\u2112p_norm_rpow_iff {q : \u211d\u22650\u221e} {f : \u03b1 \u2192 E} (hf : AEStronglyMeasurable f \u03bc) (q_zero : q \u2260 0)\n    (q_top : q \u2260 \u221e) : Mem\u2112p (fun x : \u03b1 => \u2016f x\u2016 ^ q.toReal) (p / q) \u03bc \u2194 Mem\u2112p f p \u03bc", "start": [912, 1], "end": [922, 15], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.norm_rpow", "code": "theorem Mem\u2112p.norm_rpow {f : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e) :\n    Mem\u2112p (fun x : \u03b1 => \u2016f x\u2016 ^ p.toReal) 1 \u03bc", "start": [925, 1], "end": [928, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEEqFun.compMeasurePreserving_mem_Lp", "code": "theorem AEEqFun.compMeasurePreserving_mem_Lp {\u03b2 : Type*} [MeasurableSpace \u03b2]\n    {\u03bcb : MeasureTheory.Measure \u03b2} {g : \u03b2 \u2192\u2098[\u03bcb] E} (hg : g \u2208 Lp E p \u03bcb) {f : \u03b1 \u2192 \u03b2}\n    (hf : MeasurePreserving f \u03bc \u03bcb) :\n    g.compMeasurePreserving f hf \u2208 Lp E p \u03bc", "start": [931, 1], "end": [936, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.compMeasurePreserving", "code": "def compMeasurePreserving (f : \u03b1 \u2192 \u03b2) (hf : MeasurePreserving f \u03bc \u03bcb) :\n    Lp E p \u03bcb \u2192+ Lp E p \u03bc where\n  toFun g := \u27e8g.1.compMeasurePreserving f hf, g.1.compMeasurePreserving_mem_Lp g.2 hf\u27e9\n  map_zero' := rfl\n  map_add' := by rintro \u27e8\u27e8_\u27e9, _\u27e9 \u27e8\u27e8_\u27e9, _\u27e9; rfl", "start": [944, 1], "end": [949, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.compMeasurePreserving_val", "code": "@[simp]\ntheorem compMeasurePreserving_val (g : Lp E p \u03bcb) (hf : MeasurePreserving f \u03bc \u03bcb) :\n    (compMeasurePreserving f hf g).1 = g.1.compMeasurePreserving f hf", "start": [951, 1], "end": [954, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coeFn_compMeasurePreserving", "code": "theorem coeFn_compMeasurePreserving (g : Lp E p \u03bcb) (hf : MeasurePreserving f \u03bc \u03bcb) :\n    compMeasurePreserving f hf g =\u1d50[\u03bc] g \u2218 f", "start": [956, 1], "end": [958, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.norm_compMeasurePreserving", "code": "@[simp]\ntheorem norm_compMeasurePreserving (g : Lp E p \u03bcb) (hf : MeasurePreserving f \u03bc \u03bcb) :\n    \u2016compMeasurePreserving f hf g\u2016 = \u2016g\u2016", "start": [960, 1], "end": [963, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.compMeasurePreserving\u2097", "code": "@[simps]\ndef compMeasurePreserving\u2097 (f : \u03b1 \u2192 \u03b2) (hf : MeasurePreserving f \u03bc \u03bcb) :\n    Lp E p \u03bcb \u2192\u2097[\ud835\udd5c] Lp E p \u03bc where\n  __ := compMeasurePreserving f hf\n  map_smul' c g := by rcases g with \u27e8\u27e8_\u27e9, _\u27e9; rfl", "start": [967, 1], "end": [972, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.compMeasurePreserving\u2097\u1d62", "code": "@[simps!]\ndef compMeasurePreserving\u2097\u1d62 [Fact (1 \u2264 p)] (f : \u03b1 \u2192 \u03b2) (hf : MeasurePreserving f \u03bc \u03bcb) :\n    Lp E p \u03bcb \u2192\u2097\u1d62[\ud835\udd5c] Lp E p \u03bc where\n  toLinearMap := compMeasurePreserving\u2097 \ud835\udd5c f hf\n  norm_map' := (norm_compMeasurePreserving \u00b7 hf)", "start": [974, 1], "end": [979, 49], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.comp_mem\u2112p", "code": "theorem LipschitzWith.comp_mem\u2112p {\u03b1 E F} {K} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}\n    [NormedAddCommGroup E] [NormedAddCommGroup F] {f : \u03b1 \u2192 E} {g : E \u2192 F} (hg : LipschitzWith K g)\n    (g0 : g 0 = 0) (hL : Mem\u2112p f p \u03bc) : Mem\u2112p (g \u2218 f) p \u03bc", "start": [1000, 1], "end": [1006, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.of_comp_antilipschitzWith", "code": "theorem MeasureTheory.Mem\u2112p.of_comp_antilipschitzWith {\u03b1 E F} {K'} [MeasurableSpace \u03b1]\n    {\u03bc : Measure \u03b1} [NormedAddCommGroup E] [NormedAddCommGroup F] {f : \u03b1 \u2192 E} {g : E \u2192 F}\n    (hL : Mem\u2112p (g \u2218 f) p \u03bc) (hg : UniformContinuous g) (hg' : AntilipschitzWith K' g)\n    (g0 : g 0 = 0) : Mem\u2112p f p \u03bc", "start": [1009, 1], "end": [1020, 55], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.mem\u2112p_comp_iff_of_antilipschitz", "code": "theorem mem\u2112p_comp_iff_of_antilipschitz {\u03b1 E F} {K K'} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}\n    [NormedAddCommGroup E] [NormedAddCommGroup F] {f : \u03b1 \u2192 E} {g : E \u2192 F} (hg : LipschitzWith K g)\n    (hg' : AntilipschitzWith K' g) (g0 : g 0 = 0) : Mem\u2112p (g \u2218 f) p \u03bc \u2194 Mem\u2112p f p \u03bc", "start": [1025, 1], "end": [1028, 98], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.compLp", "code": "def compLp (hg : LipschitzWith c g) (g0 : g 0 = 0) (f : Lp E p \u03bc) : Lp F p \u03bc :=\n  \u27e8AEEqFun.comp g hg.continuous (f : \u03b1 \u2192\u2098[\u03bc] E), by\n    suffices \u2200\u1d50 x \u2202\u03bc, \u2016AEEqFun.comp g hg.continuous (f : \u03b1 \u2192\u2098[\u03bc] E) x\u2016 \u2264 c * \u2016f x\u2016 from\n      Lp.mem_Lp_of_ae_le_mul this\n    filter_upwards [AEEqFun.coeFn_comp g hg.continuous (f : \u03b1 \u2192\u2098[\u03bc] E)] with a ha\n    simp only [ha]\n    rw [\u2190 dist_zero_right, \u2190 dist_zero_right, \u2190 g0]\n    exact hg.dist_le_mul (f a) 0\u27e9", "start": [1031, 1], "end": [1040, 34], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.coeFn_compLp", "code": "theorem coeFn_compLp (hg : LipschitzWith c g) (g0 : g 0 = 0) (f : Lp E p \u03bc) :\n    hg.compLp g0 f =\u1d50[\u03bc] g \u2218 f", "start": [1043, 1], "end": [1045, 39], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.compLp_zero", "code": "@[simp]\ntheorem compLp_zero (hg : LipschitzWith c g) (g0 : g 0 = 0) : hg.compLp g0 (0 : Lp E p \u03bc) = 0", "start": [1048, 1], "end": [1053, 57], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.norm_compLp_sub_le", "code": "theorem norm_compLp_sub_le (hg : LipschitzWith c g) (g0 : g 0 = 0) (f f' : Lp E p \u03bc) :\n    \u2016hg.compLp g0 f - hg.compLp g0 f'\u2016 \u2264 c * \u2016f - f'\u2016", "start": [1056, 1], "end": [1062, 36], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.norm_compLp_le", "code": "theorem norm_compLp_le (hg : LipschitzWith c g) (g0 : g 0 = 0) (f : Lp E p \u03bc) :\n    \u2016hg.compLp g0 f\u2016 \u2264 c * \u2016f\u2016", "start": [1065, 1], "end": [1066, 78], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.lipschitzWith_compLp", "code": "theorem lipschitzWith_compLp [Fact (1 \u2264 p)] (hg : LipschitzWith c g) (g0 : g 0 = 0) :\n    LipschitzWith c (hg.compLp g0 : Lp E p \u03bc \u2192 Lp F p \u03bc)", "start": [1069, 1], "end": [1071, 85], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.continuous_compLp", "code": "theorem continuous_compLp [Fact (1 \u2264 p)] (hg : LipschitzWith c g) (g0 : g 0 = 0) :\n    Continuous (hg.compLp g0 : Lp E p \u03bc \u2192 Lp F p \u03bc)", "start": [1074, 1], "end": [1076, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compLp", "code": "def compLp (L : E \u2192L[\ud835\udd5c] F) (f : Lp E p \u03bc) : Lp F p \u03bc :=\n  L.lipschitz.compLp (map_zero L) f", "start": [1085, 1], "end": [1087, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coeFn_compLp", "code": "theorem coeFn_compLp (L : E \u2192L[\ud835\udd5c] F) (f : Lp E p \u03bc) : \u2200\u1d50 a \u2202\u03bc, (L.compLp f) a = L (f a)", "start": [1090, 1], "end": [1091, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coeFn_compLp'", "code": "theorem coeFn_compLp' (L : E \u2192L[\ud835\udd5c] F) (f : Lp E p \u03bc) : L.compLp f =\u1d50[\u03bc] fun a => L (f a)", "start": [1094, 1], "end": [1095, 19], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.comp_mem\u2112p", "code": "theorem comp_mem\u2112p (L : E \u2192L[\ud835\udd5c] F) (f : Lp E p \u03bc) : Mem\u2112p (L \u2218 f) p \u03bc", "start": [1098, 1], "end": [1099, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.comp_mem\u2112p'", "code": "theorem comp_mem\u2112p' (L : E \u2192L[\ud835\udd5c] F) {f : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) : Mem\u2112p (L \u2218 f) p \u03bc", "start": [1102, 1], "end": [1103, 75], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.ofReal", "code": "theorem _root_.MeasureTheory.Mem\u2112p.ofReal {f : \u03b1 \u2192 \u211d} (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (fun x => (f x : K)) p \u03bc", "start": [1110, 1], "end": [1112, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem\u2112p_re_im_iff", "code": "theorem _root_.MeasureTheory.mem\u2112p_re_im_iff {f : \u03b1 \u2192 K} :\n    Mem\u2112p (fun x => IsROrC.re (f x)) p \u03bc \u2227 Mem\u2112p (fun x => IsROrC.im (f x)) p \u03bc \u2194 Mem\u2112p f p \u03bc", "start": [1115, 1], "end": [1121, 48], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.add_compLp", "code": "theorem add_compLp (L L' : E \u2192L[\ud835\udd5c] F) (f : Lp E p \u03bc) :\n    (L + L').compLp f = L.compLp f + L'.compLp f", "start": [1126, 1], "end": [1134, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.smul_compLp", "code": "theorem smul_compLp {\ud835\udd5c'} [NormedRing \ud835\udd5c'] [Module \ud835\udd5c' F] [BoundedSMul \ud835\udd5c' F] [SMulCommClass \ud835\udd5c \ud835\udd5c' F]\n    (c : \ud835\udd5c') (L : E \u2192L[\ud835\udd5c] F) (f : Lp E p \u03bc) : (c \u2022 L).compLp f = c \u2022 L.compLp f", "start": [1137, 1], "end": [1143, 49], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_compLp_le", "code": "theorem norm_compLp_le (L : E \u2192L[\ud835\udd5c] F) (f : Lp E p \u03bc) : \u2016L.compLp f\u2016 \u2264 \u2016L\u2016 * \u2016f\u2016", "start": [1146, 1], "end": [1147, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compLp\u2097", "code": "def compLp\u2097 (L : E \u2192L[\ud835\udd5c] F) : Lp E p \u03bc \u2192\u2097[\ud835\udd5c] Lp F p \u03bc where\n  toFun f := L.compLp f\n  map_add' f g := by\n    ext1\n    filter_upwards [Lp.coeFn_add f g, coeFn_compLp L (f + g), coeFn_compLp L f,\n      coeFn_compLp L g, Lp.coeFn_add (L.compLp f) (L.compLp g)]\n    intro a ha1 ha2 ha3 ha4 ha5\n    simp only [ha1, ha2, ha3, ha4, ha5, map_add, Pi.add_apply]\n  map_smul' c f := by\n    dsimp\n    ext1\n    filter_upwards [Lp.coeFn_smul c f, coeFn_compLp L (c \u2022 f), Lp.coeFn_smul c (L.compLp f),\n      coeFn_compLp L f] with _ ha1 ha2 ha3 ha4\n    simp only [ha1, ha2, ha3, ha4, SMulHomClass.map_smul, Pi.smul_apply]", "start": [1152, 1], "end": [1166, 73], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compLpL", "code": "def compLpL [Fact (1 \u2264 p)] (L : E \u2192L[\ud835\udd5c] F) : Lp E p \u03bc \u2192L[\ud835\udd5c] Lp F p \u03bc :=\n  LinearMap.mkContinuous (L.compLp\u2097 p \u03bc) \u2016L\u2016 L.norm_compLp_le", "start": [1169, 1], "end": [1177, 62], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coeFn_compLpL", "code": "theorem coeFn_compLpL [Fact (1 \u2264 p)] (L : E \u2192L[\ud835\udd5c] F) (f : Lp E p \u03bc) :\n    L.compLpL p \u03bc f =\u1d50[\u03bc] fun a => L (f a)", "start": [1182, 1], "end": [1184, 19], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.add_compLpL", "code": "theorem add_compLpL [Fact (1 \u2264 p)] (L L' : E \u2192L[\ud835\udd5c] F) :\n    (L + L').compLpL p \u03bc = L.compLpL p \u03bc + L'.compLpL p \u03bc", "start": [1187, 1], "end": [1188, 96], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.smul_compLpL", "code": "theorem smul_compLpL [Fact (1 \u2264 p)] {\ud835\udd5c'} [NormedRing \ud835\udd5c'] [Module \ud835\udd5c' F] [BoundedSMul \ud835\udd5c' F]\n    [SMulCommClass \ud835\udd5c \ud835\udd5c' F] (c : \ud835\udd5c') (L : E \u2192L[\ud835\udd5c] F) : (c \u2022 L).compLpL p \u03bc = c \u2022 L.compLpL p \u03bc", "start": [1191, 1], "end": [1193, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.norm_compLpL_le", "code": "theorem norm_compLpL_le [Fact (1 \u2264 p)] (L : E \u2192L[\ud835\udd5c] F) : \u2016L.compLpL p \u03bc\u2016 \u2264 \u2016L\u2016", "start": [1196, 1], "end": [1197, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.indicatorConstLp_eq_toSpanSingleton_compLp", "code": "theorem indicatorConstLp_eq_toSpanSingleton_compLp {s : Set \u03b1} [NormedSpace \u211d F]\n    (hs : MeasurableSet s) (h\u03bcs : \u03bc s \u2260 \u221e) (x : F) :\n    indicatorConstLp 2 hs h\u03bcs x =\n      (ContinuousLinearMap.toSpanSingleton \u211d x).compLp (indicatorConstLp 2 hs h\u03bcs (1 : \u211d))", "start": [1204, 1], "end": [1218, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.lipschitzWith_pos_part", "code": "theorem lipschitzWith_pos_part : LipschitzWith 1 fun x : \u211d => max x 0", "start": [1225, 1], "end": [1226, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.pos_part", "code": "theorem _root_.MeasureTheory.Mem\u2112p.pos_part {f : \u03b1 \u2192 \u211d} (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (fun x => max (f x) 0) p \u03bc", "start": [1229, 1], "end": [1231, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.neg_part", "code": "theorem _root_.MeasureTheory.Mem\u2112p.neg_part {f : \u03b1 \u2192 \u211d} (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (fun x => max (-f x) 0) p \u03bc", "start": [1234, 1], "end": [1236, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.posPart", "code": "def posPart (f : Lp \u211d p \u03bc) : Lp \u211d p \u03bc :=\n  lipschitzWith_pos_part.compLp (max_eq_right le_rfl) f", "start": [1239, 1], "end": [1241, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.negPart", "code": "def negPart (f : Lp \u211d p \u03bc) : Lp \u211d p \u03bc :=\n  posPart (-f)", "start": [1244, 1], "end": [1246, 15], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coe_posPart", "code": "@[norm_cast]\ntheorem coe_posPart (f : Lp \u211d p \u03bc) : (posPart f : \u03b1 \u2192\u2098[\u03bc] \u211d) = (f : \u03b1 \u2192\u2098[\u03bc] \u211d).posPart", "start": [1249, 1], "end": [1251, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coeFn_posPart", "code": "theorem coeFn_posPart (f : Lp \u211d p \u03bc) : \u21d1(posPart f) =\u1d50[\u03bc] fun a => max (f a) 0", "start": [1254, 1], "end": [1255, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coeFn_negPart_eq_max", "code": "theorem coeFn_negPart_eq_max (f : Lp \u211d p \u03bc) : \u2200\u1d50 a \u2202\u03bc, negPart f a = max (-f a) 0", "start": [1258, 1], "end": [1261, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.coeFn_negPart", "code": "theorem coeFn_negPart (f : Lp \u211d p \u03bc) : \u2200\u1d50 a \u2202\u03bc, negPart f a = -min (f a) 0", "start": [1264, 1], "end": [1265, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.continuous_posPart", "code": "theorem continuous_posPart [Fact (1 \u2264 p)] : Continuous fun f : Lp \u211d p \u03bc => posPart f", "start": [1268, 1], "end": [1269, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.continuous_negPart", "code": "theorem continuous_negPart [Fact (1 \u2264 p)] : Continuous fun f : Lp \u211d p \u03bc => negPart f", "start": [1272, 1], "end": [1274, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.snorm'_lim_eq_lintegral_liminf", "code": "theorem snorm'_lim_eq_lintegral_liminf {\u03b9} [Nonempty \u03b9] [LinearOrder \u03b9] {f : \u03b9 \u2192 \u03b1 \u2192 G} {p : \u211d}\n    (hp_nonneg : 0 \u2264 p) {f_lim : \u03b1 \u2192 G}\n    (h_lim : \u2200\u1d50 x : \u03b1 \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (f_lim x))) :\n    snorm' f_lim p \u03bc = (\u222b\u207b a, atTop.liminf fun m => (\u2016f m a\u2016\u208a : \u211d\u22650\u221e) ^ p \u2202\u03bc) ^ (1 / p)", "start": [1298, 1], "end": [1310, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.snorm'_lim_le_liminf_snorm'", "code": "theorem snorm'_lim_le_liminf_snorm' {E} [NormedAddCommGroup E] {f : \u2115 \u2192 \u03b1 \u2192 E} {p : \u211d}\n    (hp_pos : 0 < p) (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc) {f_lim : \u03b1 \u2192 E}\n    (h_lim : \u2200\u1d50 x : \u03b1 \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (f_lim x))) :\n    snorm' f_lim p \u03bc \u2264 atTop.liminf fun n => snorm' (f n) p \u03bc", "start": [1313, 1], "end": [1327, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.snorm_exponent_top_lim_eq_essSup_liminf", "code": "theorem snorm_exponent_top_lim_eq_essSup_liminf {\u03b9} [Nonempty \u03b9] [LinearOrder \u03b9] {f : \u03b9 \u2192 \u03b1 \u2192 G}\n    {f_lim : \u03b1 \u2192 G} (h_lim : \u2200\u1d50 x : \u03b1 \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (f_lim x))) :\n    snorm f_lim \u221e \u03bc = essSup (fun x => atTop.liminf fun m => (\u2016f m x\u2016\u208a : \u211d\u22650\u221e)) \u03bc", "start": [1330, 1], "end": [1338, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.snorm_exponent_top_lim_le_liminf_snorm_exponent_top", "code": "theorem snorm_exponent_top_lim_le_liminf_snorm_exponent_top {\u03b9} [Nonempty \u03b9] [Countable \u03b9]\n    [LinearOrder \u03b9] {f : \u03b9 \u2192 \u03b1 \u2192 F} {f_lim : \u03b1 \u2192 F}\n    (h_lim : \u2200\u1d50 x : \u03b1 \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (f_lim x))) :\n    snorm f_lim \u221e \u03bc \u2264 atTop.liminf fun n => snorm (f n) \u221e \u03bc", "start": [1341, 1], "end": [1347, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.snorm_lim_le_liminf_snorm", "code": "theorem snorm_lim_le_liminf_snorm {E} [NormedAddCommGroup E] {f : \u2115 \u2192 \u03b1 \u2192 E}\n    (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc) (f_lim : \u03b1 \u2192 E)\n    (h_lim : \u2200\u1d50 x : \u03b1 \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (f_lim x))) :\n    snorm f_lim p \u03bc \u2264 atTop.liminf fun n => snorm (f n) p \u03bc", "start": [1350, 1], "end": [1361, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.tendsto_Lp_iff_tendsto_\u2112p'", "code": "theorem tendsto_Lp_iff_tendsto_\u2112p' {\u03b9} {fi : Filter \u03b9} [Fact (1 \u2264 p)] (f : \u03b9 \u2192 Lp E p \u03bc)\n    (f_lim : Lp E p \u03bc) :\n    fi.Tendsto f (\ud835\udcdd f_lim) \u2194 fi.Tendsto (fun n => snorm (\u21d1(f n) - \u21d1f_lim) p \u03bc) (\ud835\udcdd 0)", "start": [1367, 1], "end": [1374, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.tendsto_Lp_iff_tendsto_\u2112p", "code": "theorem tendsto_Lp_iff_tendsto_\u2112p {\u03b9} {fi : Filter \u03b9} [Fact (1 \u2264 p)] (f : \u03b9 \u2192 Lp E p \u03bc)\n    (f_lim : \u03b1 \u2192 E) (f_lim_\u2112p : Mem\u2112p f_lim p \u03bc) :\n    fi.Tendsto f (\ud835\udcdd (f_lim_\u2112p.toLp f_lim)) \u2194\n      fi.Tendsto (fun n => snorm (\u21d1(f n) - f_lim) p \u03bc) (\ud835\udcdd 0)", "start": [1377, 1], "end": [1386, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.tendsto_Lp_iff_tendsto_\u2112p''", "code": "theorem tendsto_Lp_iff_tendsto_\u2112p'' {\u03b9} {fi : Filter \u03b9} [Fact (1 \u2264 p)] (f : \u03b9 \u2192 \u03b1 \u2192 E)\n    (f_\u2112p : \u2200 n, Mem\u2112p (f n) p \u03bc) (f_lim : \u03b1 \u2192 E) (f_lim_\u2112p : Mem\u2112p f_lim p \u03bc) :\n    fi.Tendsto (fun n => (f_\u2112p n).toLp (f n)) (\ud835\udcdd (f_lim_\u2112p.toLp f_lim)) \u2194\n      fi.Tendsto (fun n => snorm (f n - f_lim) p \u03bc) (\ud835\udcdd 0)", "start": [1389, 1], "end": [1399, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.tendsto_Lp_of_tendsto_\u2112p", "code": "theorem tendsto_Lp_of_tendsto_\u2112p {\u03b9} {fi : Filter \u03b9} [Fact (1 \u2264 p)] {f : \u03b9 \u2192 Lp E p \u03bc}\n    (f_lim : \u03b1 \u2192 E) (f_lim_\u2112p : Mem\u2112p f_lim p \u03bc)\n    (h_tendsto : fi.Tendsto (fun n => snorm (\u21d1(f n) - f_lim) p \u03bc) (\ud835\udcdd 0)) :\n    fi.Tendsto f (\ud835\udcdd (f_lim_\u2112p.toLp f_lim))", "start": [1402, 1], "end": [1406, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.cauchySeq_Lp_iff_cauchySeq_\u2112p", "code": "theorem cauchySeq_Lp_iff_cauchySeq_\u2112p {\u03b9} [Nonempty \u03b9] [SemilatticeSup \u03b9] [hp : Fact (1 \u2264 p)]\n    (f : \u03b9 \u2192 Lp E p \u03bc) :\n    CauchySeq f \u2194 Tendsto (fun n : \u03b9 \u00d7 \u03b9 => snorm (\u21d1(f n.fst) - \u21d1(f n.snd)) p \u03bc) atTop (\ud835\udcdd 0)", "start": [1409, 1], "end": [1415, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.completeSpace_lp_of_cauchy_complete_\u2112p", "code": "theorem completeSpace_lp_of_cauchy_complete_\u2112p [hp : Fact (1 \u2264 p)]\n    (H :\n      \u2200 (f : \u2115 \u2192 \u03b1 \u2192 E) (hf : \u2200 n, Mem\u2112p (f n) p \u03bc) (B : \u2115 \u2192 \u211d\u22650\u221e) (hB : \u2211' i, B i < \u221e)\n        (h_cau : \u2200 N n m : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 snorm (f n - f m) p \u03bc < B N),\n        \u2203 (f_lim : \u03b1 \u2192 E), Mem\u2112p f_lim p \u03bc \u2227\n          atTop.Tendsto (fun n => snorm (f n - f_lim) p \u03bc) (\ud835\udcdd 0)) :\n    CompleteSpace (Lp E p \u03bc)", "start": [1418, 1], "end": [1451, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.snorm'_sum_norm_sub_le_tsum_of_cauchy_snorm'", "code": "private theorem snorm'_sum_norm_sub_le_tsum_of_cauchy_snorm' {f : \u2115 \u2192 \u03b1 \u2192 E}\n    (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc) {p : \u211d} (hp1 : 1 \u2264 p) {B : \u2115 \u2192 \u211d\u22650\u221e}\n    (h_cau : \u2200 N n m : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 snorm' (f n - f m) p \u03bc < B N) (n : \u2115) :\n    snorm' (fun x => \u2211 i in Finset.range (n + 1), \u2016f (i + 1) x - f i x\u2016) p \u03bc \u2264 \u2211' i, B i", "start": [1457, 1], "end": [1471, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.lintegral_rpow_sum_coe_nnnorm_sub_le_rpow_tsum", "code": "private theorem lintegral_rpow_sum_coe_nnnorm_sub_le_rpow_tsum\n    {f : \u2115 \u2192 \u03b1 \u2192 E} {p : \u211d} (hp1 : 1 \u2264 p) {B : \u2115 \u2192 \u211d\u22650\u221e} (n : \u2115)\n    (hn : snorm' (fun x => \u2211 i in Finset.range (n + 1), \u2016f (i + 1) x - f i x\u2016) p \u03bc \u2264 \u2211' i, B i) :\n    (\u222b\u207b a, (\u2211 i in Finset.range (n + 1), \u2016f (i + 1) a - f i a\u2016\u208a : \u211d\u22650\u221e) ^ p \u2202\u03bc) \u2264\n      (\u2211' i, B i) ^ p", "start": [1473, 1], "end": [1495, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.lintegral_rpow_tsum_coe_nnnorm_sub_le_tsum", "code": "private theorem lintegral_rpow_tsum_coe_nnnorm_sub_le_tsum {f : \u2115 \u2192 \u03b1 \u2192 E}\n    (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc) {p : \u211d} (hp1 : 1 \u2264 p) {B : \u2115 \u2192 \u211d\u22650\u221e}\n    (h :\n      \u2200 n,\n        (\u222b\u207b a, (\u2211 i in Finset.range (n + 1), \u2016f (i + 1) a - f i a\u2016\u208a : \u211d\u22650\u221e) ^ p \u2202\u03bc) \u2264\n          (\u2211' i, B i) ^ p) :\n    (\u222b\u207b a, (\u2211' i, \u2016f (i + 1) a - f i a\u2016\u208a : \u211d\u22650\u221e) ^ p \u2202\u03bc) ^ (1 / p) \u2264 \u2211' i, B i", "start": [1497, 1], "end": [1529, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.tsum_nnnorm_sub_ae_lt_top", "code": "private theorem tsum_nnnorm_sub_ae_lt_top {f : \u2115 \u2192 \u03b1 \u2192 E} (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc)\n    {p : \u211d} (hp1 : 1 \u2264 p) {B : \u2115 \u2192 \u211d\u22650\u221e} (hB : \u2211' i, B i \u2260 \u221e)\n    (h : (\u222b\u207b a, (\u2211' i, \u2016f (i + 1) a - f i a\u2016\u208a : \u211d\u22650\u221e) ^ p \u2202\u03bc) ^ (1 / p) \u2264 \u2211' i, B i) :\n    \u2200\u1d50 x \u2202\u03bc, (\u2211' i, \u2016f (i + 1) x - f i x\u2016\u208a : \u211d\u22650\u221e) < \u221e", "start": [1531, 1], "end": [1545, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.ae_tendsto_of_cauchy_snorm'", "code": "theorem ae_tendsto_of_cauchy_snorm' [CompleteSpace E] {f : \u2115 \u2192 \u03b1 \u2192 E} {p : \u211d}\n    (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc) (hp1 : 1 \u2264 p) {B : \u2115 \u2192 \u211d\u22650\u221e} (hB : \u2211' i, B i \u2260 \u221e)\n    (h_cau : \u2200 N n m : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 snorm' (f n - f m) p \u03bc < B N) :\n    \u2200\u1d50 x \u2202\u03bc, \u2203 l : E, atTop.Tendsto (fun n => f n x) (\ud835\udcdd l)", "start": [1547, 1], "end": [1587, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.ae_tendsto_of_cauchy_snorm", "code": "theorem ae_tendsto_of_cauchy_snorm [CompleteSpace E] {f : \u2115 \u2192 \u03b1 \u2192 E}\n    (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc) (hp : 1 \u2264 p) {B : \u2115 \u2192 \u211d\u22650\u221e} (hB : \u2211' i, B i \u2260 \u221e)\n    (h_cau : \u2200 N n m : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 snorm (f n - f m) p \u03bc < B N) :\n    \u2200\u1d50 x \u2202\u03bc, \u2203 l : E, atTop.Tendsto (fun n => f n x) (\ud835\udcdd l)", "start": [1590, 1], "end": [1619, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.cauchy_tendsto_of_tendsto", "code": "theorem cauchy_tendsto_of_tendsto {f : \u2115 \u2192 \u03b1 \u2192 E} (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc)\n    (f_lim : \u03b1 \u2192 E) {B : \u2115 \u2192 \u211d\u22650\u221e} (hB : \u2211' i, B i \u2260 \u221e)\n    (h_cau : \u2200 N n m : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 snorm (f n - f m) p \u03bc < B N)\n    (h_lim : \u2200\u1d50 x : \u03b1 \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (f_lim x))) :\n    atTop.Tendsto (fun n => snorm (f n - f_lim) p \u03bc) (\ud835\udcdd 0)", "start": [1622, 1], "end": [1643, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.mem\u2112p_of_cauchy_tendsto", "code": "theorem mem\u2112p_of_cauchy_tendsto (hp : 1 \u2264 p) {f : \u2115 \u2192 \u03b1 \u2192 E} (hf : \u2200 n, Mem\u2112p (f n) p \u03bc)\n    (f_lim : \u03b1 \u2192 E) (h_lim_meas : AEStronglyMeasurable f_lim \u03bc)\n    (h_tendsto : atTop.Tendsto (fun n => snorm (f n - f_lim) p \u03bc) (\ud835\udcdd 0)) : Mem\u2112p f_lim p \u03bc", "start": [1646, 1], "end": [1661, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.cauchy_complete_\u2112p", "code": "theorem cauchy_complete_\u2112p [CompleteSpace E] (hp : 1 \u2264 p) {f : \u2115 \u2192 \u03b1 \u2192 E}\n    (hf : \u2200 n, Mem\u2112p (f n) p \u03bc) {B : \u2115 \u2192 \u211d\u22650\u221e} (hB : \u2211' i, B i \u2260 \u221e)\n    (h_cau : \u2200 N n m : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 snorm (f n - f m) p \u03bc < B N) :\n    \u2203 (f_lim : \u03b1 \u2192 E), Mem\u2112p f_lim p \u03bc \u2227\n      atTop.Tendsto (fun n => snorm (f n - f_lim) p \u03bc) (\ud835\udcdd 0)", "start": [1664, 1], "end": [1678, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.instCompleteSpace", "code": "instance instCompleteSpace [CompleteSpace E] [hp : Fact (1 \u2264 p)] : CompleteSpace (Lp E p \u03bc) :=\n  completeSpace_lp_of_cauchy_complete_\u2112p fun _f hf _B hB h_cau =>\n    cauchy_complete_\u2112p hp.elim hf hB.ne h_cau", "start": [1683, 1], "end": [1685, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.boundedContinuousFunction", "code": "def MeasureTheory.Lp.boundedContinuousFunction : AddSubgroup (Lp E p \u03bc) :=\n  AddSubgroup.addSubgroupOf\n    ((ContinuousMap.toAEEqFunAddHom \u03bc).comp (toContinuousMapAddHom \u03b1 E)).range (Lp E p \u03bc)", "start": [1707, 1], "end": [1711, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.mem_boundedContinuousFunction_iff", "code": "theorem MeasureTheory.Lp.mem_boundedContinuousFunction_iff {f : Lp E p \u03bc} :\n    f \u2208 MeasureTheory.Lp.boundedContinuousFunction E p \u03bc \u2194\n      \u2203 f\u2080 : \u03b1 \u2192\u1d47 E, f\u2080.toContinuousMap.toAEEqFun \u03bc = (f : \u03b1 \u2192\u2098[\u03bc] E)", "start": [1716, 1], "end": [1721, 32], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.mem_Lp", "code": "theorem mem_Lp (f : \u03b1 \u2192\u1d47 E) : f.toContinuousMap.toAEEqFun \u03bc \u2208 Lp E p \u03bc", "start": [1728, 1], "end": [1732, 39], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.Lp_nnnorm_le", "code": "theorem Lp_nnnorm_le (f : \u03b1 \u2192\u1d47 E) :\n    \u2016(\u27e8f.toContinuousMap.toAEEqFun \u03bc, mem_Lp f\u27e9 : Lp E p \u03bc)\u2016\u208a \u2264\n      measureUnivNNReal \u03bc ^ p.toReal\u207b\u00b9 * \u2016f\u2016\u208a", "start": [1735, 1], "end": [1744, 39], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.Lp_norm_le", "code": "theorem Lp_norm_le (f : \u03b1 \u2192\u1d47 E) :\n    \u2016(\u27e8f.toContinuousMap.toAEEqFun \u03bc, mem_Lp f\u27e9 : Lp E p \u03bc)\u2016 \u2264\n      measureUnivNNReal \u03bc ^ p.toReal\u207b\u00b9 * \u2016f\u2016", "start": [1747, 1], "end": [1752, 17], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.toLpHom", "code": "def toLpHom [Fact (1 \u2264 p)] : NormedAddGroupHom (\u03b1 \u2192\u1d47 E) (Lp E p \u03bc) :=\n  { AddMonoidHom.codRestrict ((ContinuousMap.toAEEqFunAddHom \u03bc).comp (toContinuousMapAddHom \u03b1 E))\n      (Lp E p \u03bc) mem_Lp with\n    bound' := \u27e8_, Lp_norm_le\u27e9 }", "start": [1757, 1], "end": [1762, 32], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.range_toLpHom", "code": "theorem range_toLpHom [Fact (1 \u2264 p)] :\n    ((toLpHom p \u03bc).range : AddSubgroup (Lp E p \u03bc)) =\n      MeasureTheory.Lp.boundedContinuousFunction E p \u03bc", "start": [1765, 1], "end": [1771, 60], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.toLp", "code": "def toLp [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] : (\u03b1 \u2192\u1d47 E) \u2192L[\ud835\udd5c] Lp E p \u03bc :=\n  LinearMap.mkContinuous\n    (LinearMap.codRestrict (Lp.LpSubmodule E p \u03bc \ud835\udd5c)\n      ((ContinuousMap.toAEEqFunLinearMap \u03bc).comp (toContinuousMapLinearMap \u03b1 E \ud835\udd5c)) mem_Lp)\n    _ Lp_norm_le", "start": [1776, 1], "end": [1782, 17], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.coeFn_toLp", "code": "theorem coeFn_toLp [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] (f : \u03b1 \u2192\u1d47 E) :\n    toLp (E := E) p \u03bc \ud835\udd5c f =\u1d50[\u03bc] f", "start": [1785, 1], "end": [1787, 23], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.range_toLp", "code": "theorem range_toLp [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] :\n    (LinearMap.range (toLp p \u03bc \ud835\udd5c : (\u03b1 \u2192\u1d47 E) \u2192L[\ud835\udd5c] Lp E p \u03bc)).toAddSubgroup =\n      MeasureTheory.Lp.boundedContinuousFunction E p \u03bc", "start": [1792, 1], "end": [1795, 20], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.toLp_norm_le", "code": "theorem toLp_norm_le [NontriviallyNormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] :\n    \u2016(toLp p \u03bc \ud835\udd5c : (\u03b1 \u2192\u1d47 E) \u2192L[\ud835\udd5c] Lp E p \u03bc)\u2016 \u2264 measureUnivNNReal \u03bc ^ p.toReal\u207b\u00b9", "start": [1800, 1], "end": [1802, 83], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.toLp_inj", "code": "theorem toLp_inj {f g : \u03b1 \u2192\u1d47 E} [\u03bc.IsOpenPosMeasure] [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] :\n    toLp (E := E) p \u03bc \ud835\udd5c f = toLp (E := E) p \u03bc \ud835\udd5c g \u2194 f = g", "start": [1805, 1], "end": [1810, 9], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.toLp_injective", "code": "theorem toLp_injective [\u03bc.IsOpenPosMeasure] [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] :\n    Function.Injective (\u21d1(toLp p \u03bc \ud835\udd5c : (\u03b1 \u2192\u1d47 E) \u2192L[\ud835\udd5c] Lp E p \u03bc))", "start": [1813, 1], "end": [1815, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.toLp", "code": "def toLp [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] : C(\u03b1, E) \u2192L[\ud835\udd5c] Lp E p \u03bc :=\n  (BoundedContinuousFunction.toLp p \u03bc \ud835\udd5c).comp\n    (linearIsometryBoundedOfCompact \u03b1 E \ud835\udd5c).toLinearIsometry.toContinuousLinearMap", "start": [1826, 1], "end": [1832, 82], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.range_toLp", "code": "theorem range_toLp [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] :\n    (LinearMap.range (toLp p \u03bc \ud835\udd5c : C(\u03b1, E) \u2192L[\ud835\udd5c] Lp E p \u03bc)).toAddSubgroup =\n      MeasureTheory.Lp.boundedContinuousFunction E p \u03bc", "start": [1837, 1], "end": [1844, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coeFn_toLp", "code": "theorem coeFn_toLp [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] (f : C(\u03b1, E)) :\n    toLp (E := E) p \u03bc \ud835\udd5c f =\u1d50[\u03bc] f", "start": [1849, 1], "end": [1851, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.toLp_def", "code": "theorem toLp_def [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] (f : C(\u03b1, E)) :\n    toLp (E := E) p \u03bc \ud835\udd5c f =\n      BoundedContinuousFunction.toLp (E := E) p \u03bc \ud835\udd5c (linearIsometryBoundedOfCompact \u03b1 E \ud835\udd5c f)", "start": [1854, 1], "end": [1857, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.toLp_comp_toContinuousMap", "code": "@[simp]\ntheorem toLp_comp_toContinuousMap [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] (f : \u03b1 \u2192\u1d47 E) :\n    toLp (E := E) p \u03bc \ud835\udd5c f.toContinuousMap = BoundedContinuousFunction.toLp (E := E) p \u03bc \ud835\udd5c f", "start": [1860, 1], "end": [1863, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_toLp", "code": "@[simp]\ntheorem coe_toLp [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] (f : C(\u03b1, E)) :\n    (toLp (E := E) p \u03bc \ud835\udd5c f : \u03b1 \u2192\u2098[\u03bc] E) = f.toAEEqFun \u03bc", "start": [1866, 1], "end": [1869, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.toLp_injective", "code": "theorem toLp_injective [\u03bc.IsOpenPosMeasure] [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] :\n    Function.Injective (\u21d1(toLp p \u03bc \ud835\udd5c : C(\u03b1, E) \u2192L[\ud835\udd5c] Lp E p \u03bc))", "start": [1872, 1], "end": [1874, 101], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.toLp_inj", "code": "theorem toLp_inj {f g : C(\u03b1, E)} [\u03bc.IsOpenPosMeasure] [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] :\n    toLp (E := E) p \u03bc \ud835\udd5c f = toLp (E := E) p \u03bc \ud835\udd5c g \u2194 f = g", "start": [1877, 1], "end": [1879, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.hasSum_of_hasSum_Lp", "code": "theorem hasSum_of_hasSum_Lp {\u03b2 : Type*} [\u03bc.IsOpenPosMeasure] [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E]\n    {g : \u03b2 \u2192 C(\u03b1, E)} {f : C(\u03b1, E)} (hg : Summable g)\n    (hg2 : HasSum (toLp (E := E) p \u03bc \ud835\udd5c \u2218 g) (toLp (E := E) p \u03bc \ud835\udd5c f)) : HasSum g f", "start": [1884, 1], "end": [1890, 82], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.toLp_norm_eq_toLp_norm_coe", "code": "theorem toLp_norm_eq_toLp_norm_coe :\n    \u2016(toLp p \u03bc \ud835\udd5c : C(\u03b1, E) \u2192L[\ud835\udd5c] Lp E p \u03bc)\u2016 =\n      \u2016(BoundedContinuousFunction.toLp p \u03bc \ud835\udd5c : (\u03b1 \u2192\u1d47 E) \u2192L[\ud835\udd5c] Lp E p \u03bc)\u2016", "start": [1895, 1], "end": [1898, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.toLp_norm_le", "code": "theorem toLp_norm_le :\n    \u2016(toLp p \u03bc \ud835\udd5c : C(\u03b1, E) \u2192L[\ud835\udd5c] Lp E p \u03bc)\u2016 \u2264 measureUnivNNReal \u03bc ^ p.toReal\u207b\u00b9", "start": [1901, 1], "end": [1905, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.pow_mul_meas_ge_le_norm", "code": "theorem pow_mul_meas_ge_le_norm (f : Lp E p \u03bc) (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e) (\u03b5 : \u211d\u22650\u221e) :\n    (\u03b5 * \u03bc { x | \u03b5 \u2264 (\u2016f x\u2016\u208a : \u211d\u22650\u221e) ^ p.toReal }) ^ (1 / p.toReal) \u2264 ENNReal.ofReal \u2016f\u2016", "start": [1916, 1], "end": [1919, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.mul_meas_ge_le_pow_norm", "code": "theorem mul_meas_ge_le_pow_norm (f : Lp E p \u03bc) (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e) (\u03b5 : \u211d\u22650\u221e) :\n    \u03b5 * \u03bc { x | \u03b5 \u2264 (\u2016f x\u2016\u208a : \u211d\u22650\u221e) ^ p.toReal } \u2264 ENNReal.ofReal \u2016f\u2016 ^ p.toReal", "start": [1922, 1], "end": [1925, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.mul_meas_ge_le_pow_norm'", "code": "theorem mul_meas_ge_le_pow_norm' (f : Lp E p \u03bc) (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e)\n    (\u03b5 : \u211d\u22650\u221e) : \u03b5 ^ p.toReal * \u03bc { x | \u03b5 \u2264 \u2016f x\u2016\u208a } \u2264 ENNReal.ofReal \u2016f\u2016 ^ p.toReal", "start": [1928, 1], "end": [1932, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Lp.meas_ge_le_mul_pow_norm", "code": "theorem meas_ge_le_mul_pow_norm (f : Lp E p \u03bc) (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e) {\u03b5 : \u211d\u22650\u221e}\n    (h\u03b5 : \u03b5 \u2260 0) : \u03bc { x | \u03b5 \u2264 \u2016f x\u2016\u208a } \u2264 \u03b5\u207b\u00b9 ^ p.toReal * ENNReal.ofReal \u2016f\u2016 ^ p.toReal", "start": [1935, 1], "end": [1938, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/FDeriv/Linear.lean", "imports": ["Mathlib/Analysis/NormedSpace/BoundedLinearMaps.lean", "Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousLinearMap.hasStrictFDerivAt", "code": "protected theorem ContinuousLinearMap.hasStrictFDerivAt {x : E} : HasStrictFDerivAt e e x", "start": [62, 1], "end": [63, 78], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.hasFDerivAtFilter", "code": "protected theorem ContinuousLinearMap.hasFDerivAtFilter : HasFDerivAtFilter e e x L", "start": [66, 1], "end": [67, 78], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.hasFDerivWithinAt", "code": "protected theorem ContinuousLinearMap.hasFDerivWithinAt : HasFDerivWithinAt e e s x", "start": [70, 1], "end": [71, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.hasFDerivAt", "code": "protected theorem ContinuousLinearMap.hasFDerivAt : HasFDerivAt e e x", "start": [74, 1], "end": [75, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.differentiableAt", "code": "@[simp]\nprotected theorem ContinuousLinearMap.differentiableAt : DifferentiableAt \ud835\udd5c e x", "start": [78, 1], "end": [80, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.differentiableWithinAt", "code": "protected theorem ContinuousLinearMap.differentiableWithinAt : DifferentiableWithinAt \ud835\udd5c e s x", "start": [83, 1], "end": [84, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.fderiv", "code": "@[simp]\nprotected theorem ContinuousLinearMap.fderiv : fderiv \ud835\udd5c e x = e", "start": [87, 1], "end": [89, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.fderivWithin", "code": "protected theorem ContinuousLinearMap.fderivWithin (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    fderivWithin \ud835\udd5c e s x = e", "start": [92, 1], "end": [95, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.differentiable", "code": "@[simp]\nprotected theorem ContinuousLinearMap.differentiable : Differentiable \ud835\udd5c e", "start": [98, 1], "end": [100, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.differentiableOn", "code": "protected theorem ContinuousLinearMap.differentiableOn : DifferentiableOn \ud835\udd5c e s", "start": [103, 1], "end": [104, 36], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.hasFDerivAtFilter", "code": "theorem IsBoundedLinearMap.hasFDerivAtFilter (h : IsBoundedLinearMap \ud835\udd5c f) :\n    HasFDerivAtFilter f h.toContinuousLinearMap x L", "start": [107, 1], "end": [109, 44], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.hasFDerivWithinAt", "code": "theorem IsBoundedLinearMap.hasFDerivWithinAt (h : IsBoundedLinearMap \ud835\udd5c f) :\n    HasFDerivWithinAt f h.toContinuousLinearMap s x", "start": [112, 1], "end": [114, 22], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.hasFDerivAt", "code": "theorem IsBoundedLinearMap.hasFDerivAt (h : IsBoundedLinearMap \ud835\udd5c f) :\n    HasFDerivAt f h.toContinuousLinearMap x", "start": [117, 1], "end": [119, 22], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.differentiableAt", "code": "theorem IsBoundedLinearMap.differentiableAt (h : IsBoundedLinearMap \ud835\udd5c f) : DifferentiableAt \ud835\udd5c f x", "start": [122, 1], "end": [123, 33], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.differentiableWithinAt", "code": "theorem IsBoundedLinearMap.differentiableWithinAt (h : IsBoundedLinearMap \ud835\udd5c f) :\n    DifferentiableWithinAt \ud835\udd5c f s x", "start": [126, 1], "end": [128, 44], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.fderiv", "code": "theorem IsBoundedLinearMap.fderiv (h : IsBoundedLinearMap \ud835\udd5c f) :\n    fderiv \ud835\udd5c f x = h.toContinuousLinearMap", "start": [131, 1], "end": [133, 35], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.fderivWithin", "code": "theorem IsBoundedLinearMap.fderivWithin (h : IsBoundedLinearMap \ud835\udd5c f)\n    (hxs : UniqueDiffWithinAt \ud835\udd5c s x) : fderivWithin \ud835\udd5c f s x = h.toContinuousLinearMap", "start": [136, 1], "end": [139, 17], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.differentiable", "code": "theorem IsBoundedLinearMap.differentiable (h : IsBoundedLinearMap \ud835\udd5c f) : Differentiable \ud835\udd5c f", "start": [142, 1], "end": [143, 30], "kind": "commanddeclaration"}, {"full_name": "IsBoundedLinearMap.differentiableOn", "code": "theorem IsBoundedLinearMap.differentiableOn (h : IsBoundedLinearMap \ud835\udd5c f) : DifferentiableOn \ud835\udd5c f s", "start": [146, 1], "end": [147, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/FDeriv/Comp.lean", "imports": ["Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HasFDerivAtFilter.comp", "code": "theorem HasFDerivAtFilter.comp {g : F \u2192 G} {g' : F \u2192L[\ud835\udd5c] G} {L' : Filter F}\n    (hg : HasFDerivAtFilter g g' (f x) L') (hf : HasFDerivAtFilter f f' x L) (hL : Tendsto f L L') :\n    HasFDerivAtFilter (g \u2218 f) (g'.comp f') x L", "start": [62, 1], "end": [68, 7], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.comp", "code": "theorem HasFDerivWithinAt.comp {g : F \u2192 G} {g' : F \u2192L[\ud835\udd5c] G} {t : Set F}\n    (hg : HasFDerivWithinAt g g' t (f x)) (hf : HasFDerivWithinAt f f' s x) (hst : MapsTo f s t) :\n    HasFDerivWithinAt (g \u2218 f) (g'.comp f') s x", "start": [87, 1], "end": [90, 81], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.comp_hasFDerivWithinAt", "code": "theorem HasFDerivAt.comp_hasFDerivWithinAt {g : F \u2192 G} {g' : F \u2192L[\ud835\udd5c] G}\n    (hg : HasFDerivAt g g' (f x)) (hf : HasFDerivWithinAt f f' s x) :\n    HasFDerivWithinAt (g \u2218 f) (g'.comp f') s x", "start": [93, 1], "end": [96, 37], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.comp_of_mem", "code": "theorem HasFDerivWithinAt.comp_of_mem {g : F \u2192 G} {g' : F \u2192L[\ud835\udd5c] G} {t : Set F}\n    (hg : HasFDerivWithinAt g g' t (f x)) (hf : HasFDerivWithinAt f f' s x)\n    (hst : Tendsto f (\ud835\udcdd[s] x) (\ud835\udcdd[t] f x)) : HasFDerivWithinAt (g \u2218 f) (g'.comp f') s x", "start": [99, 1], "end": [102, 37], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.comp", "code": "theorem HasFDerivAt.comp {g : F \u2192 G} {g' : F \u2192L[\ud835\udd5c] G} (hg : HasFDerivAt g g' (f x))\n    (hf : HasFDerivAt f f' x) : HasFDerivAt (g \u2218 f) (g'.comp f') x", "start": [105, 1], "end": [108, 49], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.comp", "code": "theorem DifferentiableWithinAt.comp {g : F \u2192 G} {t : Set F}\n    (hg : DifferentiableWithinAt \ud835\udd5c g t (f x)) (hf : DifferentiableWithinAt \ud835\udd5c f s x)\n    (h : MapsTo f s t) : DifferentiableWithinAt \ud835\udd5c (g \u2218 f) s x", "start": [111, 1], "end": [114, 78], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.comp'", "code": "theorem DifferentiableWithinAt.comp' {g : F \u2192 G} {t : Set F}\n    (hg : DifferentiableWithinAt \ud835\udd5c g t (f x)) (hf : DifferentiableWithinAt \ud835\udd5c f s x) :\n    DifferentiableWithinAt \ud835\udd5c (g \u2218 f) (s \u2229 f \u207b\u00b9' t) x", "start": [117, 1], "end": [120, 71], "kind": "commanddeclaration"}, {"full_name": "DifferentiableAt.comp", "code": "theorem DifferentiableAt.comp {g : F \u2192 G} (hg : DifferentiableAt \ud835\udd5c g (f x))\n    (hf : DifferentiableAt \ud835\udd5c f x) : DifferentiableAt \ud835\udd5c (g \u2218 f) x", "start": [123, 1], "end": [125, 58], "kind": "commanddeclaration"}, {"full_name": "DifferentiableAt.comp_differentiableWithinAt", "code": "theorem DifferentiableAt.comp_differentiableWithinAt {g : F \u2192 G} (hg : DifferentiableAt \ud835\udd5c g (f x))\n    (hf : DifferentiableWithinAt \ud835\udd5c f s x) : DifferentiableWithinAt \ud835\udd5c (g \u2218 f) s x", "start": [128, 1], "end": [130, 56], "kind": "commanddeclaration"}, {"full_name": "fderivWithin.comp", "code": "theorem fderivWithin.comp {g : F \u2192 G} {t : Set F} (hg : DifferentiableWithinAt \ud835\udd5c g t (f x))\n    (hf : DifferentiableWithinAt \ud835\udd5c f s x) (h : MapsTo f s t) (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    fderivWithin \ud835\udd5c (g \u2218 f) s x = (fderivWithin \ud835\udd5c g t (f x)).comp (fderivWithin \ud835\udd5c f s x)", "start": [133, 1], "end": [136, 72], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_fderivWithin", "code": "theorem fderivWithin_fderivWithin {g : F \u2192 G} {f : E \u2192 F} {x : E} {y : F} {s : Set E} {t : Set F}\n    (hg : DifferentiableWithinAt \ud835\udd5c g t y) (hf : DifferentiableWithinAt \ud835\udd5c f s x) (h : MapsTo f s t)\n    (hxs : UniqueDiffWithinAt \ud835\udd5c s x) (hy : f x = y) (v : E) :\n    fderivWithin \ud835\udd5c g t y (fderivWithin \ud835\udd5c f s x v) = fderivWithin \ud835\udd5c (g \u2218 f) s x v", "start": [139, 1], "end": [146, 71], "kind": "commanddeclaration"}, {"full_name": "fderivWithin.comp\u2083", "code": "theorem fderivWithin.comp\u2083 {g' : G \u2192 G'} {g : F \u2192 G} {t : Set F} {u : Set G} {y : F} {y' : G}\n    (hg' : DifferentiableWithinAt \ud835\udd5c g' u y') (hg : DifferentiableWithinAt \ud835\udd5c g t y)\n    (hf : DifferentiableWithinAt \ud835\udd5c f s x) (h2g : MapsTo g t u) (h2f : MapsTo f s t) (h3g : g y = y')\n    (h3f : f x = y) (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    fderivWithin \ud835\udd5c (g' \u2218 g \u2218 f) s x =\n      (fderivWithin \ud835\udd5c g' u y').comp ((fderivWithin \ud835\udd5c g t y).comp (fderivWithin \ud835\udd5c f s x))", "start": [149, 1], "end": [159, 35], "kind": "commanddeclaration"}, {"full_name": "fderiv.comp", "code": "theorem fderiv.comp {g : F \u2192 G} (hg : DifferentiableAt \ud835\udd5c g (f x)) (hf : DifferentiableAt \ud835\udd5c f x) :\n    fderiv \ud835\udd5c (g \u2218 f) x = (fderiv \ud835\udd5c g (f x)).comp (fderiv \ud835\udd5c f x)", "start": [162, 1], "end": [164, 48], "kind": "commanddeclaration"}, {"full_name": "fderiv.comp_fderivWithin", "code": "theorem fderiv.comp_fderivWithin {g : F \u2192 G} (hg : DifferentiableAt \ud835\udd5c g (f x))\n    (hf : DifferentiableWithinAt \ud835\udd5c f s x) (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    fderivWithin \ud835\udd5c (g \u2218 f) s x = (fderiv \ud835\udd5c g (f x)).comp (fderivWithin \ud835\udd5c f s x)", "start": [167, 1], "end": [170, 82], "kind": "commanddeclaration"}, {"full_name": "DifferentiableOn.comp", "code": "theorem DifferentiableOn.comp {g : F \u2192 G} {t : Set F} (hg : DifferentiableOn \ud835\udd5c g t)\n    (hf : DifferentiableOn \ud835\udd5c f s) (st : MapsTo f s t) : DifferentiableOn \ud835\udd5c (g \u2218 f) s", "start": [173, 1], "end": [175, 76], "kind": "commanddeclaration"}, {"full_name": "Differentiable.comp", "code": "theorem Differentiable.comp {g : F \u2192 G} (hg : Differentiable \ud835\udd5c g) (hf : Differentiable \ud835\udd5c f) :\n    Differentiable \ud835\udd5c (g \u2218 f)", "start": [178, 1], "end": [180, 53], "kind": "commanddeclaration"}, {"full_name": "Differentiable.comp_differentiableOn", "code": "theorem Differentiable.comp_differentiableOn {g : F \u2192 G} (hg : Differentiable \ud835\udd5c g)\n    (hf : DifferentiableOn \ud835\udd5c f s) : DifferentiableOn \ud835\udd5c (g \u2218 f) s", "start": [183, 1], "end": [185, 48], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.comp", "code": "protected theorem HasStrictFDerivAt.comp {g : F \u2192 G} {g' : F \u2192L[\ud835\udd5c] G}\n    (hg : HasStrictFDerivAt g g' (f x)) (hf : HasStrictFDerivAt f f' x) :\n    HasStrictFDerivAt (fun x => g (f x)) (g'.comp f') x", "start": [188, 1], "end": [194, 88], "kind": "commanddeclaration"}, {"full_name": "Differentiable.iterate", "code": "protected theorem Differentiable.iterate {f : E \u2192 E} (hf : Differentiable \ud835\udd5c f) (n : \u2115) :\n    Differentiable \ud835\udd5c f^[n]", "start": [197, 1], "end": [199, 57], "kind": "commanddeclaration"}, {"full_name": "DifferentiableOn.iterate", "code": "protected theorem DifferentiableOn.iterate {f : E \u2192 E} (hf : DifferentiableOn \ud835\udd5c f s)\n    (hs : MapsTo f s s) (n : \u2115) : DifferentiableOn \ud835\udd5c f^[n] s", "start": [202, 1], "end": [204, 62], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAtFilter.iterate", "code": "protected theorem HasFDerivAtFilter.iterate {f : E \u2192 E} {f' : E \u2192L[\ud835\udd5c] E}\n    (hf : HasFDerivAtFilter f f' x L) (hL : Tendsto f L L) (hx : f x = x) (n : \u2115) :\n    HasFDerivAtFilter f^[n] (f' ^ n) x L", "start": [209, 1], "end": [216, 27], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.iterate", "code": "protected theorem HasFDerivAt.iterate {f : E \u2192 E} {f' : E \u2192L[\ud835\udd5c] E} (hf : HasFDerivAt f f' x)\n    (hx : f x = x) (n : \u2115) : HasFDerivAt f^[n] (f' ^ n) x", "start": [219, 1], "end": [224, 16], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.iterate", "code": "protected theorem HasFDerivWithinAt.iterate {f : E \u2192 E} {f' : E \u2192L[\ud835\udd5c] E}\n    (hf : HasFDerivWithinAt f f' s x) (hx : f x = x) (hs : MapsTo f s s) (n : \u2115) :\n    HasFDerivWithinAt f^[n] (f' ^ n) s x", "start": [227, 1], "end": [233, 78], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.iterate", "code": "protected theorem HasStrictFDerivAt.iterate {f : E \u2192 E} {f' : E \u2192L[\ud835\udd5c] E}\n    (hf : HasStrictFDerivAt f f' x) (hx : f x = x) (n : \u2115) :\n    HasStrictFDerivAt f^[n] (f' ^ n) x", "start": [236, 1], "end": [243, 24], "kind": "commanddeclaration"}, {"full_name": "DifferentiableAt.iterate", "code": "protected theorem DifferentiableAt.iterate {f : E \u2192 E} (hf : DifferentiableAt \ud835\udd5c f x) (hx : f x = x)\n    (n : \u2115) : DifferentiableAt \ud835\udd5c f^[n] x", "start": [246, 1], "end": [248, 49], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.iterate", "code": "protected theorem DifferentiableWithinAt.iterate {f : E \u2192 E} (hf : DifferentiableWithinAt \ud835\udd5c f s x)\n    (hx : f x = x) (hs : MapsTo f s s) (n : \u2115) : DifferentiableWithinAt \ud835\udd5c f^[n] s x", "start": [251, 1], "end": [253, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/PowerBasis.lean", "imports": ["Mathlib/FieldTheory/Minpoly/Field.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PowerBasis", "code": "structure PowerBasis (R S : Type*) [CommRing R] [Ring S] [Algebra R S] where\n  gen : S\n  dim : \u2115\n  basis : Basis (Fin dim) R S\n  basis_eq_pow : \u2200 (i), basis i = gen ^ (i : \u2115)", "start": [54, 1], "end": [66, 48], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.coe_basis", "code": "@[simp]\ntheorem coe_basis (pb : PowerBasis R S) : \u21d1pb.basis = fun i : Fin pb.dim => pb.gen ^ (i : \u2115)", "start": [75, 1], "end": [77, 25], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.finiteDimensional", "code": "theorem finiteDimensional [Algebra K S] (pb : PowerBasis K S) : FiniteDimensional K S", "start": [80, 1], "end": [82, 46], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.finrank", "code": "theorem finrank [Algebra K S] (pb : PowerBasis K S) : FiniteDimensional.finrank K S = pb.dim", "start": [85, 1], "end": [86, 74], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.mem_span_pow'", "code": "theorem mem_span_pow' {x y : S} {d : \u2115} :\n    y \u2208 Submodule.span R (Set.range fun i : Fin d => x ^ (i : \u2115)) \u2194\n      \u2203 f : R[X], f.degree < d \u2227 y = aeval x f", "start": [89, 1], "end": [102, 16], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.mem_span_pow", "code": "theorem mem_span_pow {x y : S} {d : \u2115} (hd : d \u2260 0) :\n    y \u2208 Submodule.span R (Set.range fun i : Fin d => x ^ (i : \u2115)) \u2194\n      \u2203 f : R[X], f.natDegree < d \u2227 y = aeval x f", "start": [105, 1], "end": [116, 76], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.dim_ne_zero", "code": "theorem dim_ne_zero [Nontrivial S] (pb : PowerBasis R S) : pb.dim \u2260 0", "start": [119, 1], "end": [120, 93], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.dim_pos", "code": "theorem dim_pos [Nontrivial S] (pb : PowerBasis R S) : 0 < pb.dim", "start": [123, 1], "end": [124, 36], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.exists_eq_aeval", "code": "theorem exists_eq_aeval [Nontrivial S] (pb : PowerBasis R S) (y : S) :\n    \u2203 f : R[X], f.natDegree < pb.dim \u2227 y = aeval pb.gen f", "start": [127, 1], "end": [129, 72], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.exists_eq_aeval'", "code": "theorem exists_eq_aeval' (pb : PowerBasis R S) (y : S) : \u2203 f : R[X], y = aeval pb.gen f", "start": [132, 1], "end": [135, 16], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.algHom_ext", "code": "theorem algHom_ext {S' : Type*} [Semiring S'] [Algebra R S'] (pb : PowerBasis R S)\n    \u2983f g : S \u2192\u2090[R] S'\u2984 (h : f pb.gen = g pb.gen) : f = g", "start": [138, 1], "end": [142, 75], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.minpolyGen", "code": "noncomputable def minpolyGen (pb : PowerBasis A S) : A[X] :=\n  X ^ pb.dim - \u2211 i : Fin pb.dim, C (pb.basis.repr (pb.gen ^ pb.dim) i) * X ^ (i : \u2115)", "start": [151, 1], "end": [153, 85], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.aeval_minpolyGen", "code": "theorem aeval_minpolyGen (pb : PowerBasis A S) : aeval pb.gen (minpolyGen pb) = 0", "start": [156, 1], "end": [161, 72], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.minpolyGen_monic", "code": "theorem minpolyGen_monic (pb : PowerBasis A S) : Monic (minpolyGen pb)", "start": [164, 1], "end": [168, 28], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.dim_le_natDegree_of_root", "code": "theorem dim_le_natDegree_of_root (pb : PowerBasis A S) {p : A[X]} (ne_zero : p \u2260 0)\n    (root : aeval pb.gen p = 0) : pb.dim \u2264 p.natDegree", "start": [171, 1], "end": [178, 33], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.dim_le_degree_of_root", "code": "theorem dim_le_degree_of_root (h : PowerBasis A S) {p : A[X]} (ne_zero : p \u2260 0)\n    (root : aeval h.gen p = 0) : \u2191h.dim \u2264 p.degree", "start": [181, 1], "end": [184, 71], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.degree_minpolyGen", "code": "theorem degree_minpolyGen [Nontrivial A] (pb : PowerBasis A S) :\n    degree (minpolyGen pb) = pb.dim", "start": [187, 1], "end": [191, 26], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.natDegree_minpolyGen", "code": "theorem natDegree_minpolyGen [Nontrivial A] (pb : PowerBasis A S) :\n    natDegree (minpolyGen pb) = pb.dim", "start": [194, 1], "end": [196, 54], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.minpolyGen_eq", "code": "@[simp]\ntheorem minpolyGen_eq (pb : PowerBasis A S) : pb.minpolyGen = minpoly A pb.gen", "start": [199, 1], "end": [204, 77], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.isIntegral_gen", "code": "theorem isIntegral_gen (pb : PowerBasis A S) : IsIntegral A pb.gen", "start": [207, 1], "end": [208, 60], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.degree_minpoly", "code": "@[simp]\ntheorem degree_minpoly [Nontrivial A] (pb : PowerBasis A S) : degree (minpoly A pb.gen) = pb.dim", "start": [211, 1], "end": [213, 45], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.natDegree_minpoly", "code": "@[simp]\ntheorem natDegree_minpoly [Nontrivial A] (pb : PowerBasis A S) :\n    (minpoly A pb.gen).natDegree = pb.dim", "start": [216, 1], "end": [218, 91], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.leftMulMatrix", "code": "protected theorem leftMulMatrix (pb : PowerBasis A S) : Algebra.leftMulMatrix pb.basis pb.gen =\n    @Matrix.of (Fin pb.dim) (Fin pb.dim) _ fun i j =>\n      if \u2191j + 1 = pb.dim then -pb.minpolyGen.coeff \u2191i else if (i : \u2115) = j + 1 then 1 else 0", "start": [221, 1], "end": [238, 24], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.constr_pow_aeval", "code": "theorem constr_pow_aeval (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0)\n    (f : A[X]) : pb.basis.constr A (fun i => y ^ (i : \u2115)) (aeval pb.gen f) = aeval y f", "start": [247, 1], "end": [264, 70], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.constr_pow_gen", "code": "theorem constr_pow_gen (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0) :\n    pb.basis.constr A (fun i => y ^ (i : \u2115)) pb.gen = y", "start": [267, 1], "end": [269, 52], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.constr_pow_algebraMap", "code": "theorem constr_pow_algebraMap (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0)\n    (x : A) : pb.basis.constr A (fun i => y ^ (i : \u2115)) (algebraMap A S x) = algebraMap A S' x", "start": [272, 1], "end": [274, 56], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.constr_pow_mul", "code": "theorem constr_pow_mul (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0)\n    (x x' : S) : pb.basis.constr A (fun i => y ^ (i : \u2115)) (x * x') =\n      pb.basis.constr A (fun i => y ^ (i : \u2115)) x * pb.basis.constr A (fun i => y ^ (i : \u2115)) x'", "start": [277, 1], "end": [282, 50], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.lift", "code": "noncomputable def lift (pb : PowerBasis A S) (y : S') (hy : aeval y (minpoly A pb.gen) = 0) :\n    S \u2192\u2090[A] S' :=\n  { pb.basis.constr A fun i => y ^ (i : \u2115) with\n    map_one' := by convert pb.constr_pow_algebraMap hy 1 using 2 <;> rw [RingHom.map_one]\n    map_zero' := by convert pb.constr_pow_algebraMap hy 0 using 2 <;> rw [RingHom.map_zero]\n    map_mul' := pb.constr_pow_mul hy\n    commutes' := pb.constr_pow_algebraMap hy }", "start": [285, 1], "end": [296, 47], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.lift_gen", "code": "@[simp]\ntheorem lift_gen (pb : PowerBasis A S) (y : S') (hy : aeval y (minpoly A pb.gen) = 0) :\n    pb.lift y hy pb.gen = y", "start": [299, 1], "end": [302, 23], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.lift_aeval", "code": "@[simp]\ntheorem lift_aeval (pb : PowerBasis A S) (y : S') (hy : aeval y (minpoly A pb.gen) = 0) (f : A[X]) :\n    pb.lift y hy (aeval pb.gen f) = aeval y f", "start": [305, 1], "end": [308, 27], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.liftEquiv", "code": "@[simps]\nnoncomputable def liftEquiv (pb : PowerBasis A S) :\n    (S \u2192\u2090[A] S') \u2243 { y : S' // aeval y (minpoly A pb.gen) = 0 } where\n  toFun f := \u27e8f pb.gen, by rw [aeval_algHom_apply, minpoly.aeval, f.map_zero]\u27e9\n  invFun y := pb.lift y y.2\n  left_inv f := pb.algHom_ext <| lift_gen _ _ _\n  right_inv y := Subtype.ext <| lift_gen _ _ y.prop", "start": [311, 1], "end": [324, 52], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.liftEquiv'", "code": "@[simps! (config := { fullyApplied := false })]\nnoncomputable def liftEquiv' (pb : PowerBasis A S) :\n    (S \u2192\u2090[A] B) \u2243 { y : B // y \u2208 (minpoly A pb.gen).aroots B } :=\n  pb.liftEquiv.trans ((Equiv.refl _).subtypeEquiv fun x => by\n    rw [Equiv.refl_apply, mem_roots_iff_aeval_eq_zero]\n    \u00b7 simp\n    \u00b7 exact map_monic_ne_zero (minpoly.monic pb.isIntegral_gen))", "start": [327, 1], "end": [335, 65], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.AlgHom.fintype", "code": "noncomputable def AlgHom.fintype (pb : PowerBasis A S) : Fintype (S \u2192\u2090[A] B) :=\n  letI := Classical.decEq B\n  Fintype.ofEquiv _ pb.liftEquiv'.symm", "start": [338, 1], "end": [342, 39], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.equivOfRoot", "code": "@[simps! (config := { isSimp := false }) apply]\nnoncomputable def equivOfRoot (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h\u2081 : aeval pb.gen (minpoly A pb'.gen) = 0) (h\u2082 : aeval pb'.gen (minpoly A pb.gen) = 0) :\n    S \u2243\u2090[A] S' :=\n  AlgEquiv.ofAlgHom (pb.lift pb'.gen h\u2082) (pb'.lift pb.gen h\u2081)\n    (by\n      ext x\n      obtain \u27e8f, hf, rfl\u27e9 := pb'.exists_eq_aeval' x\n      simp)\n    (by\n      ext x\n      obtain \u27e8f, hf, rfl\u27e9 := pb.exists_eq_aeval' x\n      simp)", "start": [345, 1], "end": [363, 12], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.equivOfRoot_aeval", "code": "@[simp]\ntheorem equivOfRoot_aeval (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h\u2081 : aeval pb.gen (minpoly A pb'.gen) = 0) (h\u2082 : aeval pb'.gen (minpoly A pb.gen) = 0)\n    (f : A[X]) : pb.equivOfRoot pb' h\u2081 h\u2082 (aeval pb.gen f) = aeval pb'.gen f", "start": [366, 1], "end": [370, 23], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.equivOfRoot_gen", "code": "@[simp]\ntheorem equivOfRoot_gen (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h\u2081 : aeval pb.gen (minpoly A pb'.gen) = 0) (h\u2082 : aeval pb'.gen (minpoly A pb.gen) = 0) :\n    pb.equivOfRoot pb' h\u2081 h\u2082 pb.gen = pb'.gen", "start": [373, 1], "end": [377, 19], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.equivOfRoot_symm", "code": "@[simp]\ntheorem equivOfRoot_symm (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h\u2081 : aeval pb.gen (minpoly A pb'.gen) = 0) (h\u2082 : aeval pb'.gen (minpoly A pb.gen) = 0) :\n    (pb.equivOfRoot pb' h\u2081 h\u2082).symm = pb'.equivOfRoot pb h\u2082 h\u2081", "start": [380, 1], "end": [384, 6], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.equivOfMinpoly", "code": "@[simps! (config := { isSimp := false }) apply]\nnoncomputable def equivOfMinpoly (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h : minpoly A pb.gen = minpoly A pb'.gen) : S \u2243\u2090[A] S' :=\n  pb.equivOfRoot pb' (h \u25b8 minpoly.aeval _ _) (h.symm \u25b8 minpoly.aeval _ _)", "start": [387, 1], "end": [396, 74], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.equivOfMinpoly_aeval", "code": "@[simp]\ntheorem equivOfMinpoly_aeval (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h : minpoly A pb.gen = minpoly A pb'.gen) (f : A[X]) :\n    pb.equivOfMinpoly pb' h (aeval pb.gen f) = aeval pb'.gen f", "start": [399, 1], "end": [403, 33], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.equivOfMinpoly_gen", "code": "@[simp]\ntheorem equivOfMinpoly_gen (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h : minpoly A pb.gen = minpoly A pb'.gen) : pb.equivOfMinpoly pb' h pb.gen = pb'.gen", "start": [406, 1], "end": [409, 29], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.equivOfMinpoly_symm", "code": "@[simp]\ntheorem equivOfMinpoly_symm (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h : minpoly A pb.gen = minpoly A pb'.gen) :\n    (pb.equivOfMinpoly pb' h).symm = pb'.equivOfMinpoly pb h.symm", "start": [412, 1], "end": [416, 6], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_pow", "code": "theorem linearIndependent_pow [Algebra K S] (x : S) :\n    LinearIndependent K fun i : Fin (minpoly K x).natDegree => x ^ (i : \u2115)", "start": [425, 1], "end": [440, 54], "kind": "commanddeclaration"}, {"full_name": "IsIntegral.mem_span_pow", "code": "theorem IsIntegral.mem_span_pow [Nontrivial R] {x y : S} (hx : IsIntegral R x)\n    (hy : \u2203 f : R[X], y = aeval x f) :\n    y \u2208 Submodule.span R (Set.range fun i : Fin (minpoly R x).natDegree => x ^ (i : \u2115))", "start": [443, 1], "end": [451, 75], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.map", "code": "@[simps dim gen basis]\nnoncomputable def map (pb : PowerBasis R S) (e : S \u2243\u2090[R] S') : PowerBasis R S' where\n  dim := pb.dim\n  basis := pb.basis.map e.toLinearEquiv\n  gen := e pb.gen\n  basis_eq_pow i := by rw [Basis.map_apply, pb.basis_eq_pow, e.toLinearEquiv_apply, e.map_pow]", "start": [460, 1], "end": [466, 95], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.minpolyGen_map", "code": "theorem minpolyGen_map (pb : PowerBasis A S) (e : S \u2243\u2090[A] S') :\n    (pb.map e).minpolyGen = pb.minpolyGen", "start": [472, 1], "end": [478, 46], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.equivOfRoot_map", "code": "@[simp]\ntheorem equivOfRoot_map (pb : PowerBasis A S) (e : S \u2243\u2090[A] S') (h\u2081 h\u2082) :\n    pb.equivOfRoot (pb.map e) h\u2081 h\u2082 = e", "start": [481, 1], "end": [486, 24], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.equivOfMinpoly_map", "code": "@[simp]\ntheorem equivOfMinpoly_map (pb : PowerBasis A S) (e : S \u2243\u2090[A] S')\n    (h : minpoly A pb.gen = minpoly A (pb.map e).gen) : pb.equivOfMinpoly (pb.map e) h = e", "start": [489, 1], "end": [492, 27], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.adjoin_gen_eq_top", "code": "theorem adjoin_gen_eq_top (B : PowerBasis R S) : adjoin R ({B.gen} : Set S) = \u22a4", "start": [501, 1], "end": [505, 69], "kind": "commanddeclaration"}, {"full_name": "PowerBasis.adjoin_eq_top_of_gen_mem_adjoin", "code": "theorem adjoin_eq_top_of_gen_mem_adjoin {B : PowerBasis R S} {x : S}\n    (hx : B.gen \u2208 adjoin R ({x} : Set S)) : adjoin R ({x} : Set S) = \u22a4", "start": [508, 1], "end": [512, 12], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/QuotientNoetherian.lean", "imports": ["Mathlib/RingTheory/Noetherian.lean", "Mathlib/RingTheory/QuotientNilpotent.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ideal.Quotient.isNoetherianRing", "code": "instance Ideal.Quotient.isNoetherianRing {R : Type*} [CommRing R] [IsNoetherianRing R]\n    (I : Ideal R) : IsNoetherianRing (R \u29f8 I) :=\n  isNoetherianRing_iff.mpr <| isNoetherian_of_tower R <| Submodule.Quotient.isNoetherian _", "start": [15, 1], "end": [17, 91], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/FinitePresentation.lean", "imports": ["Mathlib/RingTheory/FiniteType.lean", "Mathlib/RingTheory/MvPolynomial/Tower.lean", "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Algebra.FinitePresentation", "code": "def Algebra.FinitePresentation [CommSemiring R] [Semiring A] [Algebra R A] : Prop :=\n  \u2203 (n : \u2115) (f : MvPolynomial (Fin n) R \u2192\u2090[R] A), Surjective f \u2227 f.toRingHom.ker.FG", "start": [41, 1], "end": [44, 84], "kind": "commanddeclaration"}, {"full_name": "Algebra.FiniteType.of_finitePresentation", "code": "theorem of_finitePresentation : FinitePresentation R A \u2192 FiniteType R A", "start": [55, 1], "end": [59, 21], "kind": "commanddeclaration"}, {"full_name": "Algebra.FinitePresentation.of_finiteType", "code": "theorem of_finiteType [IsNoetherianRing R] : FiniteType R A \u2194 FinitePresentation R A", "start": [68, 1], "end": [79, 15], "kind": "commanddeclaration"}, {"full_name": "Algebra.FinitePresentation.equiv", "code": "theorem equiv (hfp : FinitePresentation R A) (e : A \u2243\u2090[R] B) : FinitePresentation R B", "start": [82, 1], "end": [99, 80], "kind": "commanddeclaration"}, {"full_name": "Algebra.FinitePresentation.mvPolynomial", "code": "protected theorem mvPolynomial (\u03b9 : Type u_2) [Finite \u03b9] :\n    FinitePresentation R (MvPolynomial \u03b9 R)", "start": [104, 1], "end": [111, 86], "kind": "commanddeclaration"}, {"full_name": "Algebra.FinitePresentation.self", "code": "theorem self : FinitePresentation R R", "start": [114, 1], "end": [117, 89], "kind": "commanddeclaration"}, {"full_name": "Algebra.FinitePresentation.polynomial", "code": "theorem polynomial : FinitePresentation R R[X]", "start": [120, 1], "end": [123, 80], "kind": "commanddeclaration"}, {"full_name": "Algebra.FinitePresentation.quotient", "code": "protected theorem quotient {I : Ideal A} (h : I.FG) (hfp : FinitePresentation R A) :\n    FinitePresentation R (A \u29f8 I)", "start": [128, 1], "end": [136, 13], "kind": "commanddeclaration"}, {"full_name": "Algebra.FinitePresentation.of_surjective", "code": "theorem of_surjective {f : A \u2192\u2090[R] B} (hf : Function.Surjective f) (hker : f.toRingHom.ker.FG)\n    (hfp : FinitePresentation R A) : FinitePresentation R B", "start": [139, 1], "end": [143, 71], "kind": "commanddeclaration"}, {"full_name": "Algebra.FinitePresentation.iff", "code": "theorem iff :\n    FinitePresentation R A \u2194\n      \u2203 (n : _) (I : Ideal (MvPolynomial (Fin n) R)) (_ : (_ \u29f8 I) \u2243\u2090[R] A), I.FG", "start": [146, 1], "end": [153, 71], "kind": "commanddeclaration"}, {"full_name": "Algebra.FinitePresentation.iff_quotient_mvPolynomial'", "code": "theorem iff_quotient_mvPolynomial' :\n    FinitePresentation R A \u2194\n      \u2203 (\u03b9 : Type*) (_ : Fintype \u03b9) (f : MvPolynomial \u03b9 R \u2192\u2090[R] A),\n        Surjective f \u2227 f.toRingHom.ker.FG", "start": [156, 1], "end": [179, 27], "kind": "commanddeclaration"}, {"full_name": "Algebra.FinitePresentation.mvPolynomial_of_finitePresentation", "code": "theorem mvPolynomial_of_finitePresentation (hfp : FinitePresentation.{w\u2081, w\u2082} R A)\n    (\u03b9 : Type v) [Finite \u03b9] :\n    FinitePresentation.{w\u2081, max v w\u2082} R (MvPolynomial \u03b9 A)", "start": [186, 1], "end": [207, 36], "kind": "commanddeclaration"}, {"full_name": "Algebra.FinitePresentation.trans", "code": "theorem trans [Algebra A B] [IsScalarTower R A B] (hfpA : FinitePresentation R A)\n    (hfpB : FinitePresentation A B) : FinitePresentation R B", "start": [210, 1], "end": [215, 95], "kind": "commanddeclaration"}, {"full_name": "Algebra.FinitePresentation.of_restrict_scalars_finitePresentation", "code": "theorem of_restrict_scalars_finitePresentation [Algebra A B] [IsScalarTower R A B]\n    (hRB : FinitePresentation.{w\u2081, w\u2083} R B) [hRA : FiniteType R A] :\n    FinitePresentation.{w\u2082, w\u2083} A B", "start": [222, 1], "end": [306, 36], "kind": "commanddeclaration"}, {"full_name": "Algebra.FinitePresentation.ker_fg_of_mvPolynomial", "code": "theorem ker_fg_of_mvPolynomial {n : \u2115} (f : MvPolynomial (Fin n) R \u2192\u2090[R] A)\n    (hf : Function.Surjective f) (hfp : FinitePresentation R A) : f.toRingHom.ker.FG", "start": [310, 1], "end": [381, 36], "kind": "commanddeclaration"}, {"full_name": "Algebra.FinitePresentation.ker_fG_of_surjective", "code": "theorem ker_fG_of_surjective (f : A \u2192\u2090[R] B) (hf : Function.Surjective f)\n    (hRA : FinitePresentation R A) (hRB : FinitePresentation R B) : f.toRingHom.ker.FG", "start": [384, 1], "end": [391, 96], "kind": "commanddeclaration"}, {"full_name": "RingHom.FinitePresentation", "code": "def FinitePresentation (f : A \u2192+* B) : Prop :=\n  @Algebra.FinitePresentation A B _ _ f.toAlgebra", "start": [404, 1], "end": [407, 50], "kind": "commanddeclaration"}, {"full_name": "RingHom.FiniteType.of_finitePresentation", "code": "theorem of_finitePresentation {f : A \u2192+* B} (hf : f.FinitePresentation) : f.FiniteType", "start": [412, 1], "end": [413, 67], "kind": "commanddeclaration"}, {"full_name": "RingHom.FinitePresentation.id", "code": "theorem id : FinitePresentation (RingHom.id A)", "start": [422, 1], "end": [423, 36], "kind": "commanddeclaration"}, {"full_name": "RingHom.FinitePresentation.comp_surjective", "code": "theorem comp_surjective {f : A \u2192+* B} {g : B \u2192+* C} (hf : f.FinitePresentation) (hg : Surjective g)\n    (hker : g.ker.FG) : (g.comp f).FinitePresentation", "start": [428, 1], "end": [437, 15], "kind": "commanddeclaration"}, {"full_name": "RingHom.FinitePresentation.of_surjective", "code": "theorem of_surjective (f : A \u2192+* B) (hf : Surjective f) (hker : f.ker.FG) :\n    f.FinitePresentation", "start": [440, 1], "end": [443, 39], "kind": "commanddeclaration"}, {"full_name": "RingHom.FinitePresentation.of_finiteType", "code": "theorem of_finiteType [IsNoetherianRing A] {f : A \u2192+* B} : f.FiniteType \u2194 f.FinitePresentation", "start": [446, 1], "end": [447, 66], "kind": "commanddeclaration"}, {"full_name": "RingHom.FinitePresentation.comp", "code": "theorem comp {g : B \u2192+* C} {f : A \u2192+* B} (hg : g.FinitePresentation) (hf : f.FinitePresentation) :\n    (g.comp f).FinitePresentation", "start": [450, 1], "end": [458, 41], "kind": "commanddeclaration"}, {"full_name": "RingHom.FinitePresentation.of_comp_finiteType", "code": "theorem of_comp_finiteType (f : A \u2192+* B) {g : B \u2192+* C} (hg : (g.comp f).FinitePresentation)\n    (hf : f.FiniteType) : g.FinitePresentation", "start": [461, 1], "end": [469, 83], "kind": "commanddeclaration"}, {"full_name": "AlgHom.FinitePresentation", "code": "def FinitePresentation (f : A \u2192\u2090[R] B) : Prop :=\n  f.toRingHom.FinitePresentation", "start": [484, 1], "end": [487, 33], "kind": "commanddeclaration"}, {"full_name": "AlgHom.FiniteType.of_finitePresentation", "code": "theorem of_finitePresentation {f : A \u2192\u2090[R] B} (hf : f.FinitePresentation) : f.FiniteType", "start": [492, 1], "end": [493, 46], "kind": "commanddeclaration"}, {"full_name": "AlgHom.FinitePresentation.id", "code": "theorem id : FinitePresentation (AlgHom.id R A)", "start": [502, 1], "end": [503, 34], "kind": "commanddeclaration"}, {"full_name": "AlgHom.FinitePresentation.comp", "code": "theorem comp {g : B \u2192\u2090[R] C} {f : A \u2192\u2090[R] B} (hg : g.FinitePresentation)\n    (hf : f.FinitePresentation) : (g.comp f).FinitePresentation", "start": [508, 1], "end": [510, 40], "kind": "commanddeclaration"}, {"full_name": "AlgHom.FinitePresentation.comp_surjective", "code": "theorem comp_surjective {f : A \u2192\u2090[R] B} {g : B \u2192\u2090[R] C} (hf : f.FinitePresentation)\n    (hg : Surjective g) (hker : g.toRingHom.ker.FG) : (g.comp f).FinitePresentation", "start": [513, 1], "end": [515, 56], "kind": "commanddeclaration"}, {"full_name": "AlgHom.FinitePresentation.of_surjective", "code": "theorem of_surjective (f : A \u2192\u2090[R] B) (hf : Surjective f) (hker : f.toRingHom.ker.FG) :\n    f.FinitePresentation", "start": [518, 1], "end": [521, 61], "kind": "commanddeclaration"}, {"full_name": "AlgHom.FinitePresentation.of_finiteType", "code": "theorem of_finiteType [IsNoetherianRing A] {f : A \u2192\u2090[R] B} : f.FiniteType \u2194 f.FinitePresentation", "start": [524, 1], "end": [525, 43], "kind": "commanddeclaration"}, {"full_name": "AlgHom.FinitePresentation.of_comp_finiteType", "code": "nonrec theorem of_comp_finiteType (f : A \u2192\u2090[R] B) {g : B \u2192\u2090[R] C}\n    (h : (g.comp f).FinitePresentation) (h' : f.FiniteType) : g.FinitePresentation", "start": [528, 1], "end": [530, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Lifts.lean", "imports": ["Mathlib/Data/Polynomial/Monic.lean", "Mathlib/Data/Polynomial/AlgebraMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.lifts", "code": "def lifts (f : R \u2192+* S) : Subsemiring S[X] :=\n  RingHom.rangeS (mapRingHom f)", "start": [56, 1], "end": [58, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_lifts", "code": "theorem mem_lifts (p : S[X]) : p \u2208 lifts f \u2194 \u2203 q : R[X], map f q = p", "start": [61, 1], "end": [62, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.lifts_iff_set_range", "code": "theorem lifts_iff_set_range (p : S[X]) : p \u2208 lifts f \u2194 p \u2208 Set.range (map f)", "start": [65, 1], "end": [66, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.lifts_iff_ringHom_rangeS", "code": "theorem lifts_iff_ringHom_rangeS (p : S[X]) : p \u2208 lifts f \u2194 p \u2208 (mapRingHom f).rangeS", "start": [69, 1], "end": [70, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.lifts_iff_coeff_lifts", "code": "theorem lifts_iff_coeff_lifts (p : S[X]) : p \u2208 lifts f \u2194 \u2200 n : \u2115, p.coeff n \u2208 Set.range f", "start": [73, 1], "end": [75, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_mem_lifts", "code": "theorem C_mem_lifts (f : R \u2192+* S) (r : R) : C (f r) \u2208 lifts f", "start": [78, 1], "end": [82, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C'_mem_lifts", "code": "theorem C'_mem_lifts {f : R \u2192+* S} {s : S} (h : s \u2208 Set.range f) : C s \u2208 lifts f", "start": [86, 1], "end": [91, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_mem_lifts", "code": "theorem X_mem_lifts (f : R \u2192+* S) : (X : S[X]) \u2208 lifts f", "start": [95, 1], "end": [99, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_pow_mem_lifts", "code": "theorem X_pow_mem_lifts (f : R \u2192+* S) (n : \u2115) : (X ^ n : S[X]) \u2208 lifts f", "start": [103, 1], "end": [107, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.base_mul_mem_lifts", "code": "theorem base_mul_mem_lifts {p : S[X]} (r : R) (hp : p \u2208 lifts f) : C (f r) * p \u2208 lifts f", "start": [111, 1], "end": [116, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_mem_lifts", "code": "theorem monomial_mem_lifts {s : S} (n : \u2115) (h : s \u2208 Set.range f) : monomial n s \u2208 lifts f", "start": [119, 1], "end": [124, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.erase_mem_lifts", "code": "theorem erase_mem_lifts {p : S[X]} (n : \u2115) (h : p \u2208 lifts f) : p.erase n \u2208 lifts f", "start": [127, 1], "end": [136, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_mem_lifts_and_degree_eq", "code": "theorem monomial_mem_lifts_and_degree_eq {s : S} {n : \u2115} (hl : monomial n s \u2208 lifts f) :\n    \u2203 q : R[X], map f q = monomial n s \u2227 q.degree = (monomial n s).degree", "start": [141, 1], "end": [162, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_lifts_and_degree_eq", "code": "theorem mem_lifts_and_degree_eq {p : S[X]} (hlifts : p \u2208 lifts f) :\n    \u2203 q : R[X], map f q = p \u2227 q.degree = p.degree", "start": [165, 1], "end": [202, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.lifts_and_degree_eq_and_monic", "code": "theorem lifts_and_degree_eq_and_monic [Nontrivial S] {p : S[X]} (hlifts : p \u2208 lifts f)\n    (hp : p.Monic) : \u2203 q : R[X], map f q = p \u2227 q.degree = p.degree \u2227 q.Monic", "start": [209, 1], "end": [230, 93], "kind": "commanddeclaration"}, {"full_name": "Polynomial.lifts_and_natDegree_eq_and_monic", "code": "theorem lifts_and_natDegree_eq_and_monic {p : S[X]} (hlifts : p \u2208 lifts f) (hp : p.Monic) :\n    \u2203 q : R[X], map f q = p \u2227 q.natDegree = p.natDegree \u2227 q.Monic", "start": [233, 1], "end": [239, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.liftsRing", "code": "def liftsRing (f : R \u2192+* S) : Subring S[X] :=\n  RingHom.range (mapRingHom f)", "start": [250, 1], "end": [252, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.lifts_iff_liftsRing", "code": "theorem lifts_iff_liftsRing (p : S[X]) : p \u2208 lifts f \u2194 p \u2208 liftsRing f", "start": [255, 1], "end": [258, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mapAlg", "code": "def mapAlg (R : Type u) [CommSemiring R] (S : Type v) [Semiring S] [Algebra R S] :\n    R[X] \u2192\u2090[R] S[X] :=\n  @aeval _ S[X] _ _ _ (X : S[X])", "start": [267, 1], "end": [270, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mapAlg_eq_map", "code": "theorem mapAlg_eq_map (p : R[X]) : mapAlg R S p = map (algebraMap R S) p", "start": [273, 1], "end": [276, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_lifts_iff_mem_alg", "code": "theorem mem_lifts_iff_mem_alg (R : Type u) [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S]\n    (p : S[X]) : p \u2208 lifts (algebraMap R S) \u2194 p \u2208 AlgHom.range (@mapAlg R _ S _ _)", "start": [279, 1], "end": [282, 89], "kind": "commanddeclaration"}, {"full_name": "Polynomial.smul_mem_lifts", "code": "theorem smul_mem_lifts {p : S[X]} (r : R) (hp : p \u2208 lifts (algebraMap R S)) :\n    r \u2022 p \u2208 lifts (algebraMap R S)", "start": [285, 1], "end": [289, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Elementwise.lean", "imports": ["Mathlib/Tactic/CategoryTheory/Elementwise.lean", "Mathlib/CategoryTheory/ConcreteCategory/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/CategoryTheory/Preadditive/Basic.lean", "imports": ["Mathlib/CategoryTheory/Endomorphism.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Algebra/Hom/Group/Defs.lean", "Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean"], "premises": [{"full_name": "CategoryTheory.Preadditive", "code": "class Preadditive where\n  homGroup : \u2200 P Q : C, AddCommGroup (P \u27f6 Q) := by infer_instance\n  add_comp : \u2200 (P Q R : C) (f f' : P \u27f6 Q) (g : Q \u27f6 R), (f + f') \u226b g = f \u226b g + f' \u226b g := by\n    aesop_cat\n  comp_add : \u2200 (P Q R : C) (f : P \u27f6 Q) (g g' : Q \u27f6 R), f \u226b (g + g') = f \u226b g + f \u226b g' := by\n    aesop_cat", "start": [58, 1], "end": [65, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.inducedCategory", "code": "instance inducedCategory : Preadditive.{v} (InducedCategory C F) where\n  homGroup P Q := @Preadditive.homGroup C _ _ (F P) (F Q)\n  add_comp _ _ _ _ _ _ := add_comp _ _ _ _ _ _\n  comp_add _ _ _ _ _ _ := comp_add _ _ _ _ _ _", "start": [102, 1], "end": [105, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.fullSubcategory", "code": "instance fullSubcategory (Z : C \u2192 Prop) : Preadditive.{v} (FullSubcategory Z) where\n  homGroup P Q := @Preadditive.homGroup C _ _ P.obj Q.obj\n  add_comp _ _ _ _ _ _ := add_comp _ _ _ _ _ _\n  comp_add _ _ _ _ _ _ := comp_add _ _ _ _ _ _", "start": [110, 1], "end": [113, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.leftComp", "code": "def leftComp {P Q : C} (R : C) (f : P \u27f6 Q) : (Q \u27f6 R) \u2192+ (P \u27f6 R) :=\n  mk' (fun g => f \u226b g) fun g g' => by simp", "start": [120, 1], "end": [122, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.rightComp", "code": "def rightComp (P : C) {Q R : C} (g : Q \u27f6 R) : (P \u27f6 Q) \u2192+ (P \u27f6 R) :=\n  mk' (fun f => f \u226b g) fun f f' => by simp", "start": [125, 1], "end": [127, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.compHom", "code": "def compHom : (P \u27f6 Q) \u2192+ (Q \u27f6 R) \u2192+ (P \u27f6 R) :=\n  AddMonoidHom.mk' (fun f => leftComp _ f) fun f\u2081 f\u2082 =>\n    AddMonoidHom.ext fun g => (rightComp _ g).map_add f\u2081 f\u2082", "start": [132, 1], "end": [135, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.sub_comp", "code": "@[reassoc, simp]\ntheorem sub_comp : (f - f') \u226b g = f \u226b g - f' \u226b g", "start": [139, 1], "end": [141, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.comp_sub", "code": "@[reassoc, simp]\ntheorem comp_sub : f \u226b (g - g') = f \u226b g - f \u226b g'", "start": [145, 1], "end": [147, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.neg_comp", "code": "@[reassoc, simp]\ntheorem neg_comp : (-f) \u226b g = -f \u226b g", "start": [151, 1], "end": [153, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.comp_neg", "code": "@[reassoc, simp]\ntheorem comp_neg : f \u226b (-g) = -f \u226b g", "start": [157, 1], "end": [159, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.neg_comp_neg", "code": "@[reassoc]\ntheorem neg_comp_neg : (-f) \u226b (-g) = f \u226b g", "start": [162, 1], "end": [163, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.nsmul_comp", "code": "theorem nsmul_comp (n : \u2115) : (n \u2022 f) \u226b g = n \u2022 f \u226b g", "start": [166, 1], "end": [167, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.comp_nsmul", "code": "theorem comp_nsmul (n : \u2115) : f \u226b (n \u2022 g) = n \u2022 f \u226b g", "start": [170, 1], "end": [171, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.zsmul_comp", "code": "theorem zsmul_comp (n : \u2124) : (n \u2022 f) \u226b g = n \u2022 f \u226b g", "start": [174, 1], "end": [175, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.comp_zsmul", "code": "theorem comp_zsmul (n : \u2124) : f \u226b (n \u2022 g) = n \u2022 f \u226b g", "start": [178, 1], "end": [179, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.comp_sum", "code": "@[reassoc]\ntheorem comp_sum {P Q R : C} {J : Type*} (s : Finset J) (f : P \u27f6 Q) (g : J \u2192 (Q \u27f6 R)) :\n    (f \u226b \u2211 j in s, g j) = \u2211 j in s, f \u226b g j", "start": [182, 1], "end": [185, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.sum_comp", "code": "@[reassoc]\ntheorem sum_comp {P Q R : C} {J : Type*} (s : Finset J) (f : J \u2192 (P \u27f6 Q)) (g : Q \u27f6 R) :\n    (\u2211 j in s, f j) \u226b g = \u2211 j in s, f j \u226b g", "start": [188, 1], "end": [191, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.preadditiveHasZeroMorphisms", "code": "instance (priority := 100) preadditiveHasZeroMorphisms : HasZeroMorphisms C where\n  Zero := inferInstance\n  comp_zero f R := show leftComp R f 0 = 0 from map_zero _\n  zero_comp P _ _ f := show rightComp P f 0 = 0 from map_zero _", "start": [200, 1], "end": [203, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.moduleEndRight", "code": "instance moduleEndRight {X Y : C} : Module (End Y) (X \u27f6 Y) where\n  smul_add _ _ _ := add_comp _ _ _ _ _ _\n  smul_zero _ := zero_comp\n  add_smul _ _ _ := comp_add _ _ _ _ _ _\n  zero_smul _ := comp_zero", "start": [223, 1], "end": [227, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.mono_of_cancel_zero", "code": "theorem mono_of_cancel_zero {Q R : C} (f : Q \u27f6 R) (h : \u2200 {P : C} (g : P \u27f6 Q), g \u226b f = 0 \u2192 g = 0) :\n    Mono f where", "start": [230, 1], "end": [233, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.mono_iff_cancel_zero", "code": "theorem mono_iff_cancel_zero {Q R : C} (f : Q \u27f6 R) :\n    Mono f \u2194 \u2200 (P : C) (g : P \u27f6 Q), g \u226b f = 0 \u2192 g = 0", "start": [236, 1], "end": [238, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.mono_of_kernel_zero", "code": "theorem mono_of_kernel_zero {X Y : C} {f : X \u27f6 Y} [HasLimit (parallelPair f 0)]\n    (w : kernel.\u03b9 f = 0) : Mono f", "start": [241, 1], "end": [243, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.mono_of_isZero_kernel'", "code": "lemma mono_of_isZero_kernel' {X Y : C} {f : X \u27f6 Y} (c : KernelFork f) (hc : IsLimit c)\n    (h : IsZero c.pt) : Mono f := mono_of_cancel_zero _ (fun g hg => by\n  obtain \u27e8a, ha\u27e9 := KernelFork.IsLimit.lift' hc _ hg\n  rw [\u2190 ha, h.eq_of_tgt a 0, Limits.zero_comp])", "start": [246, 1], "end": [249, 48], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Preadditive.mono_of_isZero_kernel", "code": "lemma mono_of_isZero_kernel {X Y : C} (f : X \u27f6 Y) [HasKernel f] (h : IsZero (kernel f)) :\n    Mono f :=\n  mono_of_isZero_kernel' _ (kernelIsKernel _) h", "start": [251, 1], "end": [253, 48], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Preadditive.epi_of_cancel_zero", "code": "theorem epi_of_cancel_zero {P Q : C} (f : P \u27f6 Q) (h : \u2200 {R : C} (g : Q \u27f6 R), f \u226b g = 0 \u2192 g = 0) :\n    Epi f", "start": [255, 1], "end": [258, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.epi_iff_cancel_zero", "code": "theorem epi_iff_cancel_zero {P Q : C} (f : P \u27f6 Q) :\n    Epi f \u2194 \u2200 (R : C) (g : Q \u27f6 R), f \u226b g = 0 \u2192 g = 0", "start": [261, 1], "end": [263, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.epi_of_cokernel_zero", "code": "theorem epi_of_cokernel_zero {X Y : C} {f : X \u27f6 Y} [HasColimit (parallelPair f 0)]\n    (w : cokernel.\u03c0 f = 0) : Epi f", "start": [266, 1], "end": [268, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.epi_of_isZero_cokernel'", "code": "lemma epi_of_isZero_cokernel' {X Y : C} {f : X \u27f6 Y} (c : CokernelCofork f) (hc : IsColimit c)\n    (h : IsZero c.pt) : Epi f := epi_of_cancel_zero _ (fun g hg => by\n  obtain \u27e8a, ha\u27e9 := CokernelCofork.IsColimit.desc' hc _ hg\n  rw [\u2190 ha, h.eq_of_src a 0, Limits.comp_zero])", "start": [271, 1], "end": [274, 48], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Preadditive.epi_of_isZero_cokernel", "code": "lemma epi_of_isZero_cokernel {X Y : C} (f : X \u27f6 Y) [HasCokernel f] (h : IsZero (cokernel f)) :\n    Epi f :=\n  epi_of_isZero_cokernel' _ (cokernelIsCokernel _) h", "start": [276, 1], "end": [278, 53], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Preadditive.IsIso.comp_left_eq_zero", "code": "@[simp]\ntheorem comp_left_eq_zero [IsIso f] : f \u226b g = 0 \u2194 g = 0", "start": [282, 1], "end": [284, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.IsIso.comp_right_eq_zero", "code": "@[simp]\ntheorem comp_right_eq_zero [IsIso g] : f \u226b g = 0 \u2194 f = 0", "start": [287, 1], "end": [289, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.mono_of_kernel_iso_zero", "code": "theorem mono_of_kernel_iso_zero {X Y : C} {f : X \u27f6 Y} [HasLimit (parallelPair f 0)]\n    (w : kernel f \u2245 0) : Mono f", "start": [298, 1], "end": [300, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.epi_of_cokernel_iso_zero", "code": "theorem epi_of_cokernel_iso_zero {X Y : C} {f : X \u27f6 Y} [HasColimit (parallelPair f 0)]\n    (w : cokernel f \u2245 0) : Epi f", "start": [303, 1], "end": [305, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.forkOfKernelFork", "code": "@[simps! pt]\ndef forkOfKernelFork (c : KernelFork (f - g)) : Fork f g :=\n  Fork.of\u03b9 c.\u03b9 <| by rw [\u2190 sub_eq_zero, \u2190 comp_sub, c.condition]", "start": [318, 1], "end": [321, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.forkOfKernelFork_\u03b9", "code": "@[simp]\ntheorem forkOfKernelFork_\u03b9 (c : KernelFork (f - g)) : (forkOfKernelFork c).\u03b9 = c.\u03b9", "start": [324, 1], "end": [326, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.kernelForkOfFork", "code": "def kernelForkOfFork (c : Fork f g) : KernelFork (f - g) :=\n  Fork.of\u03b9 c.\u03b9 <| by rw [comp_sub, comp_zero, sub_eq_zero, c.condition]", "start": [329, 1], "end": [331, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.kernelForkOfFork_\u03b9", "code": "@[simp]\ntheorem kernelForkOfFork_\u03b9 (c : Fork f g) : (kernelForkOfFork c).\u03b9 = c.\u03b9", "start": [334, 1], "end": [336, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.kernelForkOfFork_of\u03b9", "code": "@[simp]\ntheorem kernelForkOfFork_of\u03b9 {P : C} (\u03b9 : P \u27f6 X) (w : \u03b9 \u226b f = \u03b9 \u226b g) :\n    kernelForkOfFork (Fork.of\u03b9 \u03b9 w) = KernelFork.of\u03b9 \u03b9 (by simp [w])", "start": [339, 1], "end": [342, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.isLimitForkOfKernelFork", "code": "def isLimitForkOfKernelFork {c : KernelFork (f - g)} (i : IsLimit c) :\n    IsLimit (forkOfKernelFork c) :=\n  Fork.IsLimit.mk' _ fun s =>\n    \u27e8i.lift (kernelForkOfFork s), i.fac _ _, fun h => by apply Fork.IsLimit.hom_ext i; aesop_cat\u27e9", "start": [345, 1], "end": [349, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.isLimitForkOfKernelFork_lift", "code": "@[simp]\ntheorem isLimitForkOfKernelFork_lift {c : KernelFork (f - g)} (i : IsLimit c) (s : Fork f g) :\n    (isLimitForkOfKernelFork i).lift s = i.lift (kernelForkOfFork s)", "start": [352, 1], "end": [355, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.isLimitKernelForkOfFork", "code": "def isLimitKernelForkOfFork {c : Fork f g} (i : IsLimit c) : IsLimit (kernelForkOfFork c) :=\n  Fork.IsLimit.mk' _ fun s =>\n    \u27e8i.lift (forkOfKernelFork s), i.fac _ _, fun h => by apply Fork.IsLimit.hom_ext i; aesop_cat\u27e9", "start": [358, 1], "end": [361, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.hasEqualizer_of_hasKernel", "code": "theorem hasEqualizer_of_hasKernel [HasKernel (f - g)] : HasEqualizer f g", "start": [366, 1], "end": [370, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.hasKernel_of_hasEqualizer", "code": "theorem hasKernel_of_hasEqualizer [HasEqualizer f g] : HasKernel (f - g)", "start": [373, 1], "end": [377, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.coforkOfCokernelCofork", "code": "@[simps! pt]\ndef coforkOfCokernelCofork (c : CokernelCofork (f - g)) : Cofork f g :=\n  Cofork.of\u03c0 c.\u03c0 <| by rw [\u2190 sub_eq_zero, \u2190 sub_comp, c.condition]", "start": [382, 1], "end": [385, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.coforkOfCokernelCofork_\u03c0", "code": "@[simp]\ntheorem coforkOfCokernelCofork_\u03c0 (c : CokernelCofork (f - g)) :\n    (coforkOfCokernelCofork c).\u03c0 = c.\u03c0", "start": [388, 1], "end": [391, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.cokernelCoforkOfCofork", "code": "def cokernelCoforkOfCofork (c : Cofork f g) : CokernelCofork (f - g) :=\n  Cofork.of\u03c0 c.\u03c0 <| by rw [sub_comp, zero_comp, sub_eq_zero, c.condition]", "start": [394, 1], "end": [396, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.cokernelCoforkOfCofork_\u03c0", "code": "@[simp]\ntheorem cokernelCoforkOfCofork_\u03c0 (c : Cofork f g) : (cokernelCoforkOfCofork c).\u03c0 = c.\u03c0", "start": [399, 1], "end": [401, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.cokernelCoforkOfCofork_of\u03c0", "code": "@[simp]\ntheorem cokernelCoforkOfCofork_of\u03c0 {P : C} (\u03c0 : Y \u27f6 P) (w : f \u226b \u03c0 = g \u226b \u03c0) :\n    cokernelCoforkOfCofork (Cofork.of\u03c0 \u03c0 w) = CokernelCofork.of\u03c0 \u03c0 (by simp [w])", "start": [404, 1], "end": [407, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.isColimitCoforkOfCokernelCofork", "code": "def isColimitCoforkOfCokernelCofork {c : CokernelCofork (f - g)} (i : IsColimit c) :\n    IsColimit (coforkOfCokernelCofork c) :=\n  Cofork.IsColimit.mk' _ fun s =>\n    \u27e8i.desc (cokernelCoforkOfCofork s), i.fac _ _, fun h => by\n      apply Cofork.IsColimit.hom_ext i; aesop_cat\u27e9", "start": [410, 1], "end": [415, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.isColimitCoforkOfCokernelCofork_desc", "code": "@[simp]\ntheorem isColimitCoforkOfCokernelCofork_desc {c : CokernelCofork (f - g)} (i : IsColimit c)\n    (s : Cofork f g) :\n    (isColimitCoforkOfCokernelCofork i).desc s = i.desc (cokernelCoforkOfCofork s)", "start": [418, 1], "end": [422, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.isColimitCokernelCoforkOfCofork", "code": "def isColimitCokernelCoforkOfCofork {c : Cofork f g} (i : IsColimit c) :\n    IsColimit (cokernelCoforkOfCofork c) :=\n  Cofork.IsColimit.mk' _ fun s =>\n    \u27e8i.desc (coforkOfCokernelCofork s), i.fac _ _, fun h => by\n      apply Cofork.IsColimit.hom_ext i; aesop_cat\u27e9", "start": [425, 1], "end": [430, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.hasCoequalizer_of_hasCokernel", "code": "theorem hasCoequalizer_of_hasCokernel [HasCokernel (f - g)] : HasCoequalizer f g", "start": [435, 1], "end": [439, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.hasCokernel_of_hasCoequalizer", "code": "theorem hasCokernel_of_hasCoequalizer [HasCoequalizer f g] : HasCokernel (f - g)", "start": [442, 1], "end": [446, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.hasEqualizers_of_hasKernels", "code": "theorem hasEqualizers_of_hasKernels [HasKernels C] : HasEqualizers C", "start": [451, 1], "end": [453, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.hasCoequalizers_of_hasCokernels", "code": "theorem hasCoequalizers_of_hasCokernels [HasCokernels C] : HasCoequalizers C", "start": [456, 1], "end": [459, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.smul_iso_hom", "code": "@[simp]\nlemma smul_iso_hom (a : Units \u2124) (e : X \u2245 Y) : (a \u2022 e).hom = (a : \u2124) \u2022 e.hom := rfl", "start": [477, 1], "end": [478, 84], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Preadditive.smul_iso_inv", "code": "@[simp]\nlemma smul_iso_inv (a : Units \u2124) (e : X \u2245 Y) : (a \u2022 e).inv = ((a\u207b\u00b9 : Units \u2124) : \u2124) \u2022 e.inv := rfl", "start": [480, 1], "end": [481, 98], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Preadditive.neg_iso_hom", "code": "@[simp]\nlemma neg_iso_hom (e : X \u2245 Y) : (-e).hom = -e.hom := rfl", "start": [488, 1], "end": [489, 57], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Preadditive.neg_iso_inv", "code": "@[simp]\nlemma neg_iso_inv (e : X \u2245 Y) : (-e).inv = -e.inv := rfl", "start": [491, 1], "end": [492, 57], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/CategoryTheory/Sites/Pretopology.lean", "imports": ["Mathlib/CategoryTheory/Sites/Grothendieck.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Pretopology", "code": "@[ext]\nstructure Pretopology where\n  coverings : \u2200 X : C, Set (Presieve X)\n  has_isos : \u2200 \u2983X Y\u2984 (f : Y \u27f6 X) [IsIso f], Presieve.singleton f \u2208 coverings X\n  pullbacks : \u2200 \u2983X Y\u2984 (f : Y \u27f6 X) (S), S \u2208 coverings X \u2192 pullbackArrows f S \u2208 coverings Y\n  Transitive :\n    \u2200 \u2983X : C\u2984 (S : Presieve X) (Ti : \u2200 \u2983Y\u2984 (f : Y \u27f6 X), S f \u2192 Presieve Y),\n      S \u2208 coverings X \u2192 (\u2200 \u2983Y\u2984 (f) (H : S f), Ti f H \u2208 coverings Y) \u2192 S.bind Ti \u2208 coverings X", "start": [46, 1], "end": [70, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretopology.LE", "code": "instance LE : LE (Pretopology C) where\n  le K\u2081 K\u2082 := (K\u2081 : \u2200 X : C, Set (Presieve X)) \u2264 K\u2082", "start": [80, 1], "end": [81, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretopology.le_def", "code": "theorem le_def {K\u2081 K\u2082 : Pretopology C} : K\u2081 \u2264 K\u2082 \u2194 (K\u2081 : \u2200 X : C, Set (Presieve X)) \u2264 K\u2082", "start": [83, 1], "end": [84, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretopology.toGrothendieck", "code": "def toGrothendieck (K : Pretopology C) : GrothendieckTopology C where\n  sieves X S := \u2203 R \u2208 K X, R \u2264 (S : Presieve _)\n  top_mem' X := \u27e8Presieve.singleton (\ud835\udfd9 _), K.has_isos _, fun _ _ _ => \u27e8\u27e9\u27e9\n  pullback_stable' X Y S g := by\n    rintro \u27e8R, hR, RS\u27e9\n    refine' \u27e8_, K.pullbacks g _ hR, _\u27e9\n    rw [\u2190 Sieve.sets_iff_generate, Sieve.pullbackArrows_comm]\n    apply Sieve.pullback_monotone\n    rwa [Sieve.giGenerate.gc]\n  transitive' := by\n    rintro X S \u27e8R', hR', RS\u27e9 R t\n    choose t\u2081 t\u2082 t\u2083 using t\n    refine' \u27e8_, K.Transitive _ _ hR' fun _ f hf => t\u2082 (RS _ hf), _\u27e9\n    rintro Y _ \u27e8Z, g, f, hg, hf, rfl\u27e9\n    apply t\u2083 (RS _ hg) _ hf", "start": [106, 1], "end": [125, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretopology.mem_toGrothendieck", "code": "theorem mem_toGrothendieck (K : Pretopology C) (X S) :\n    S \u2208 toGrothendieck C K X \u2194 \u2203 R \u2208 K X, R \u2264 (S : Presieve X)", "start": [128, 1], "end": [130, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretopology.ofGrothendieck", "code": "def ofGrothendieck (J : GrothendieckTopology C) : Pretopology C where\n  coverings X R := Sieve.generate R \u2208 J X\n  has_isos X Y f i := J.covering_of_eq_top (by simp)\n  pullbacks X Y f R hR := by\n    simp only [Set.mem_def, Sieve.pullbackArrows_comm]\n    apply J.pullback_stable f hR\n  Transitive X S Ti hS hTi := by\n    apply J.transitive hS\n    intro Y f\n    rintro \u27e8Z, g, f, hf, rfl\u27e9\n    rw [Sieve.pullback_comp]\n    apply J.pullback_stable g\n    apply J.superset_covering _ (hTi _ hf)\n    rintro Y g \u27e8W, h, g, hg, rfl\u27e9\n    exact \u27e8_, h, _, \u27e8_, _, _, hf, hg, rfl\u27e9, by simp\u27e9", "start": [133, 1], "end": [151, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretopology.gi", "code": "def gi : GaloisInsertion (toGrothendieck C) (ofGrothendieck C) where\n  gc K J := by\n    constructor\n    \u00b7 intro h X R hR\n      exact h _ \u27e8_, hR, Sieve.le_generate R\u27e9\n    \u00b7 rintro h X S \u27e8R, hR, RS\u27e9\n      apply J.superset_covering _ (h _ hR)\n      rwa [Sieve.giGenerate.gc]\n  le_l_u J X S hS := \u27e8S, J.superset_covering (Sieve.le_generate S.arrows) hS, le_rfl\u27e9\n  choice x _ := toGrothendieck C x\n  choice_eq _ _ := rfl", "start": [154, 1], "end": [165, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretopology.trivial", "code": "def trivial : Pretopology C where\n  coverings X S := \u2203 (Y : _) (f : Y \u27f6 X) (_ : IsIso f), S = Presieve.singleton f\n  has_isos X Y f i := \u27e8_, _, i, rfl\u27e9\n  pullbacks X Y f S := by\n    rintro \u27e8Z, g, i, rfl\u27e9\n    refine' \u27e8pullback g f, pullback.snd, _, _\u27e9\n    \u00b7 refine' \u27e8\u27e8pullback.lift (f \u226b inv g) (\ud835\udfd9 _) (by simp), \u27e8_, by aesop_cat\u27e9\u27e9\u27e9\n      ext\n      \u00b7 rw [assoc, pullback.lift_fst, \u2190 pullback.condition_assoc]\n        simp\n      \u00b7 simp\n    \u00b7 apply pullback_singleton\n  Transitive := by\n    rintro X S Ti \u27e8Z, g, i, rfl\u27e9 hS\n    rcases hS g (singleton_self g) with \u27e8Y, f, i, hTi\u27e9\n    refine' \u27e8_, f \u226b g, _, _\u27e9\n    \u00b7 infer_instance\n    apply funext\n    rintro W\n    apply Set.ext\n    rintro k\n    constructor\n    \u00b7 rintro \u27e8V, h, k, \u27e8_\u27e9, hh, rfl\u27e9\n      rw [hTi] at hh\n      cases hh\n      apply singleton.mk\n    \u00b7 rintro \u27e8_\u27e9\n      refine' bind_comp g singleton.mk _\n      rw [hTi]\n      apply singleton.mk", "start": [168, 1], "end": [204, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretopology.toGrothendieck_bot", "code": "theorem toGrothendieck_bot : toGrothendieck C \u22a5 = \u22a5", "start": [213, 1], "end": [215, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/Types.lean", "imports": ["Mathlib/CategoryTheory/ConcreteCategory/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Types.lean", "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "Mathlib/Tactic/CategoryTheory/Elementwise.lean", "Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "Mathlib/CategoryTheory/Limits/Shapes/Products.lean"], "premises": [{"full_name": "CategoryTheory.Limits.Types.pi_lift_\u03c0_apply", "code": "@[simp 1001]\ntheorem pi_lift_\u03c0_apply [UnivLE.{v, u}] {\u03b2 : Type v} (f : \u03b2 \u2192 Type u) {P : Type u}\n    (s : \u2200 b, P \u27f6 f b) (b : \u03b2) (x : P) :\n    (Pi.\u03c0 f b : (piObj f) \u2192 f b) (@Pi.lift \u03b2 _ _ f _ P s x) = s b x", "start": [55, 1], "end": [60, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.pi_lift_\u03c0_apply'", "code": "theorem pi_lift_\u03c0_apply' {\u03b2 : Type v} (f : \u03b2 \u2192 Type v) {P : Type v}\n    (s : \u2200 b, P \u27f6 f b) (b : \u03b2) (x : P) :\n    (Pi.\u03c0 f b : (piObj f) \u2192 f b) (@Pi.lift \u03b2 _ _ f _ P s x) = s b x", "start": [63, 1], "end": [68, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.pi_map_\u03c0_apply", "code": "@[simp 1001]\ntheorem pi_map_\u03c0_apply [UnivLE.{v, u}] {\u03b2 : Type v} {f g : \u03b2 \u2192 Type u}\n    (\u03b1 : \u2200 j, f j \u27f6 g j) (b : \u03b2) (x) :\n    (Pi.\u03c0 g b : \u220f g \u2192 g b) (Pi.map \u03b1 x) = \u03b1 b ((Pi.\u03c0 f b : \u220f f \u2192 f b) x)", "start": [71, 1], "end": [76, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.pi_map_\u03c0_apply'", "code": "theorem pi_map_\u03c0_apply' {\u03b2 : Type v} {f g : \u03b2 \u2192 Type v} (\u03b1 : \u2200 j, f j \u27f6 g j) (b : \u03b2) (x) :\n    (Pi.\u03c0 g b : \u220f g \u2192 g b) (Pi.map \u03b1 x) = \u03b1 b ((Pi.\u03c0 f b : \u220f f \u2192 f b) x)", "start": [79, 1], "end": [83, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.terminalLimitCone", "code": "def terminalLimitCone : Limits.LimitCone (Functor.empty (Type u)) where\n  cone :=\n    { pt := PUnit\n      \u03c0 := (Functor.uniqueFromEmpty _).hom }\n  isLimit :=\n    { lift := fun _ _ => PUnit.unit\n      fac := fun _ => by rintro \u27e8\u27e8\u27e9\u27e9\n      uniq := fun _ _ _ => by\n        funext\n        apply Subsingleton.elim }", "start": [86, 1], "end": [97, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.terminalIso", "code": "noncomputable def terminalIso : \u22a4_ Type u \u2245 PUnit :=\n  limit.isoLimitCone terminalLimitCone.{u, 0}", "start": [100, 1], "end": [102, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.isTerminalPunit", "code": "noncomputable def isTerminalPunit : IsTerminal (PUnit : Type u) :=\n  terminalIsTerminal.ofIso terminalIso", "start": [105, 1], "end": [107, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.isTerminalEquivUnique", "code": "noncomputable def isTerminalEquivUnique (X : Type u) : IsTerminal X \u2243 Unique X :=\n  equivOfSubsingletonOfSubsingleton\n    (fun h => ((Iso.toEquiv (terminalIsoIsTerminal h).symm).unique))\n    (fun _ => IsTerminal.ofIso terminalIsTerminal (Equiv.toIso (Equiv.equivOfUnique _ _)))", "start": [121, 1], "end": [125, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.isTerminalEquivIsoPUnit", "code": "noncomputable def isTerminalEquivIsoPUnit (X : Type u) : IsTerminal X \u2243 (X \u2245 PUnit) := by\n  calc\n    IsTerminal X \u2243 Unique X := isTerminalEquivUnique _\n    _ \u2243 (X \u2243 PUnit.{u + 1}) := uniqueEquivEquivUnique _ _\n    _ \u2243 (X \u2245 PUnit) := equivEquivIso", "start": [127, 1], "end": [132, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.initialColimitCocone", "code": "def initialColimitCocone : Limits.ColimitCocone (Functor.empty (Type u)) where\n  cocone :=\n    { pt := PEmpty\n      \u03b9 := (Functor.uniqueFromEmpty _).inv }\n  isColimit :=\n    { desc := fun _ => by rintro \u27e8\u27e9\n      fac := fun _ => by rintro \u27e8\u27e8\u27e9\u27e9\n      uniq := fun _ _ _ => by funext x; cases x }", "start": [134, 1], "end": [143, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.initialIso", "code": "noncomputable def initialIso : \u22a5_ Type u \u2245 PEmpty :=\n  colimit.isoColimitCocone initialColimitCocone.{u, 0}", "start": [146, 1], "end": [148, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.isInitialPunit", "code": "noncomputable def isInitialPunit : IsInitial (PEmpty : Type u) :=\n  initialIsInitial.ofIso initialIso", "start": [151, 1], "end": [153, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryProductCone", "code": "@[simps! pt]\ndef binaryProductCone (X Y : Type u) : BinaryFan X Y :=\n  BinaryFan.mk _root_.Prod.fst _root_.Prod.snd", "start": [160, 1], "end": [163, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryProductCone_fst", "code": "@[simp]\ntheorem binaryProductCone_fst (X Y : Type u) : (binaryProductCone X Y).fst = _root_.Prod.fst", "start": [166, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryProductCone_snd", "code": "@[simp]\ntheorem binaryProductCone_snd (X Y : Type u) : (binaryProductCone X Y).snd = _root_.Prod.snd", "start": [171, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryProductLimit", "code": "@[simps]\ndef binaryProductLimit (X Y : Type u) : IsLimit (binaryProductCone X Y) where\n  lift (s : BinaryFan X Y) x := (s.fst x, s.snd x)\n  fac _ j := Discrete.recOn j fun j => WalkingPair.casesOn j rfl rfl\n  uniq _ _ w := funext fun x => Prod.ext (congr_fun (w \u27e8left\u27e9) x) (congr_fun (w \u27e8right\u27e9) x)", "start": [176, 1], "end": [181, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryProductLimitCone", "code": "@[simps]\ndef binaryProductLimitCone (X Y : Type u) : Limits.LimitCone (pair X Y) :=\n  \u27e8_, binaryProductLimit X Y\u27e9", "start": [184, 1], "end": [189, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryProductIso", "code": "noncomputable def binaryProductIso (X Y : Type u) : Limits.prod X Y \u2245 X \u00d7 Y :=\n  limit.isoLimitCone (binaryProductLimitCone X Y)", "start": [192, 1], "end": [194, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryProductIso_hom_comp_fst", "code": "@[elementwise (attr := simp)]\ntheorem binaryProductIso_hom_comp_fst (X Y : Type u) :\n    (binaryProductIso X Y).hom \u226b _root_.Prod.fst = Limits.prod.fst", "start": [197, 1], "end": [200, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryProductIso_hom_comp_snd", "code": "@[elementwise (attr := simp)]\ntheorem binaryProductIso_hom_comp_snd (X Y : Type u) :\n    (binaryProductIso X Y).hom \u226b _root_.Prod.snd = Limits.prod.snd", "start": [203, 1], "end": [206, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryProductIso_inv_comp_fst", "code": "@[elementwise (attr := simp)]\ntheorem binaryProductIso_inv_comp_fst (X Y : Type u) :\n    (binaryProductIso X Y).inv \u226b Limits.prod.fst = _root_.Prod.fst", "start": [209, 1], "end": [212, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryProductIso_inv_comp_snd", "code": "@[elementwise (attr := simp)]\ntheorem binaryProductIso_inv_comp_snd (X Y : Type u) :\n    (binaryProductIso X Y).inv \u226b Limits.prod.snd = _root_.Prod.snd", "start": [215, 1], "end": [218, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryProductFunctor", "code": "@[simps]\ndef binaryProductFunctor : Type u \u2964 Type u \u2964 Type u where\n  obj X :=\n    { obj := fun Y => X \u00d7 Y\n      map := fun { Y\u2081 Y\u2082} f => (binaryProductLimit X Y\u2082).lift\n        (BinaryFan.mk _root_.Prod.fst (_root_.Prod.snd \u226b f)) }\n  map {X\u2081 X\u2082} f :=\n    { app := fun Y =>\n      (binaryProductLimit X\u2082 Y).lift (BinaryFan.mk (_root_.Prod.fst \u226b f) _root_.Prod.snd) }", "start": [224, 1], "end": [233, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryProductIsoProd", "code": "noncomputable def binaryProductIsoProd : binaryProductFunctor \u2245 (prod.functor : Type u \u2964 _) := by\n  refine' NatIso.ofComponents (fun X => _) (fun _ => _)\n  \u00b7 refine' NatIso.ofComponents (fun Y => _) (fun _ => _)\n    \u00b7 exact ((limit.isLimit _).conePointUniqueUpToIso (binaryProductLimit X Y)).symm\n    \u00b7 apply Limits.prod.hom_ext <;> simp <;> rfl\n  \u00b7 ext : 2\n    apply Limits.prod.hom_ext <;> simp <;> rfl", "start": [236, 1], "end": [245, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryCoproductCocone", "code": "@[simps!]\ndef binaryCoproductCocone (X Y : Type u) : Cocone (pair X Y) :=\n  BinaryCofan.mk Sum.inl Sum.inr", "start": [248, 1], "end": [251, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryCoproductColimit", "code": "@[simps]\ndef binaryCoproductColimit (X Y : Type u) : IsColimit (binaryCoproductCocone X Y) where\n  desc := fun s : BinaryCofan X Y => Sum.elim s.inl s.inr\n  fac _ j := Discrete.recOn j fun j => WalkingPair.casesOn j rfl rfl\n  uniq _ _ w := funext fun x => Sum.casesOn x (congr_fun (w \u27e8left\u27e9)) (congr_fun (w \u27e8right\u27e9))", "start": [254, 1], "end": [259, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryCoproductColimitCocone", "code": "def binaryCoproductColimitCocone (X Y : Type u) : Limits.ColimitCocone (pair X Y) :=\n  \u27e8_, binaryCoproductColimit X Y\u27e9", "start": [262, 1], "end": [266, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryCoproductIso", "code": "noncomputable def binaryCoproductIso (X Y : Type u) : Limits.coprod X Y \u2245 Sum X Y :=\n  colimit.isoColimitCocone (binaryCoproductColimitCocone X Y)", "start": [269, 1], "end": [271, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_hom", "code": "@[elementwise (attr := simp)]\ntheorem binaryCoproductIso_inl_comp_hom (X Y : Type u) :\n    Limits.coprod.inl \u226b (binaryCoproductIso X Y).hom = Sum.inl", "start": [276, 1], "end": [279, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_hom", "code": "@[elementwise (attr := simp)]\ntheorem binaryCoproductIso_inr_comp_hom (X Y : Type u) :\n    Limits.coprod.inr \u226b (binaryCoproductIso X Y).hom = Sum.inr", "start": [282, 1], "end": [285, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_inv", "code": "@[elementwise (attr := simp)]\ntheorem binaryCoproductIso_inl_comp_inv (X Y : Type u) :\n    \u21be(Sum.inl : X \u27f6 Sum X Y) \u226b (binaryCoproductIso X Y).inv = Limits.coprod.inl", "start": [288, 1], "end": [291, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_inv", "code": "@[elementwise (attr := simp)]\ntheorem binaryCoproductIso_inr_comp_inv (X Y : Type u) :\n    \u21be(Sum.inr : Y \u27f6 Sum X Y) \u226b (binaryCoproductIso X Y).inv = Limits.coprod.inr", "start": [294, 1], "end": [297, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.binaryCofan_isColimit_iff", "code": "theorem binaryCofan_isColimit_iff {X Y : Type u} (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) \u2194\n      Injective c.inl \u2227 Injective c.inr \u2227 IsCompl (Set.range c.inl) (Set.range c.inr)", "start": [302, 1], "end": [347, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.isCoprodOfMono", "code": "noncomputable def isCoprodOfMono {X Y : Type u} (f : X \u27f6 Y) [Mono f] :\n    IsColimit (BinaryCofan.mk f (Subtype.val : \u2191(Set.range f)\u1d9c \u2192 Y)) := by\n  apply Nonempty.some\n  rw [binaryCofan_isColimit_iff]\n  refine' \u27e8(mono_iff_injective f).mp inferInstance, Subtype.val_injective, _\u27e9\n  symm\n  rw [\u2190 eq_compl_iff_isCompl]\n  exact Subtype.range_val", "start": [350, 1], "end": [358, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.productLimitCone", "code": "def productLimitCone {J : Type v} (F : J \u2192 TypeMax.{v, u}) :\n    Limits.LimitCone (Discrete.functor F) where\n  cone :=\n    { pt := \u2200 j, F j\n      \u03c0 := Discrete.natTrans (fun \u27e8j\u27e9 f => f j) }\n  isLimit :=\n    { lift := fun s x j => s.\u03c0.app \u27e8j\u27e9 x\n      uniq := fun s m w => funext fun x => funext fun j => (congr_fun (w \u27e8j\u27e9) x : _) }", "start": [361, 1], "end": [371, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.productIso", "code": "noncomputable def productIso {J : Type v} (F : J \u2192 TypeMax.{v, u}) : \u220f F \u2245 \u2200 j, F j :=\n  limit.isoLimitCone (productLimitCone.{v, u} F)", "start": [374, 1], "end": [376, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.productIso_hom_comp_eval", "code": "@[simp]\ntheorem productIso_hom_comp_eval {J : Type v} (F : J \u2192 TypeMax.{v, u}) (j : J) :\n    ((productIso.{v, u} F).hom \u226b fun f => f j) = Pi.\u03c0 F j", "start": [381, 1], "end": [384, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.productIso_hom_comp_eval_apply", "code": "@[simp]\ntheorem productIso_hom_comp_eval_apply {J : Type v} (F : J \u2192 TypeMax.{v, u}) (j : J) (x) :\n    ((productIso.{v, u} F).hom x) j = Pi.\u03c0 F j x", "start": [387, 1], "end": [390, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.productIso_inv_comp_\u03c0", "code": "@[elementwise (attr := simp)]\ntheorem productIso_inv_comp_\u03c0 {J : Type v} (F : J \u2192 TypeMax.{v, u}) (j : J) :\n    (productIso.{v, u} F).inv \u226b Pi.\u03c0 F j = fun f => f j", "start": [393, 1], "end": [396, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.UnivLE.productLimitCone", "code": "noncomputable def productLimitCone {J : Type v} (F : J \u2192 Type u) [UnivLE.{v, u}] :\n    Limits.LimitCone (Discrete.functor F) where\n  cone :=\n    { pt := Shrink (\u2200 j, F j)\n      \u03c0 := Discrete.natTrans (fun \u27e8j\u27e9 f => (equivShrink _).symm f j) }\n  isLimit :=\n    { lift := fun s x => (equivShrink _) (fun j => s.\u03c0.app \u27e8j\u27e9 x)\n      uniq := fun s m w => funext fun x => Shrink.ext <| funext fun j => by\n        simpa using (congr_fun (w \u27e8j\u27e9) x : _) }", "start": [401, 1], "end": [412, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.UnivLE.productIso", "code": "noncomputable def productIso {J : Type v} (F : J \u2192 Type u) [UnivLE.{v, u}] :\n    (\u220f F : Type u) \u2245 Shrink.{u} (\u2200 j, F j) :=\n  limit.isoLimitCone (productLimitCone.{v, u} F)", "start": [414, 1], "end": [418, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.UnivLE.productIso_hom_comp_eval", "code": "@[simp]\ntheorem productIso_hom_comp_eval {J : Type v} (F : J \u2192 Type u) [UnivLE.{v, u}] (j : J) :\n    ((productIso.{v, u} F).hom \u226b fun f => (equivShrink _).symm f j) = Pi.\u03c0 F j", "start": [420, 1], "end": [423, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.UnivLE.productIso_hom_comp_eval_apply", "code": "@[simp]\ntheorem productIso_hom_comp_eval_apply {J : Type v} (F : J \u2192 Type u) [UnivLE.{v, u}] (j : J) (x) :\n    (equivShrink _).symm ((productIso F).hom x) j = Pi.\u03c0 F j x", "start": [427, 1], "end": [430, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.UnivLE.productIso_inv_comp_\u03c0", "code": "@[elementwise (attr := simp)]\ntheorem productIso_inv_comp_\u03c0 {J : Type v} (F : J \u2192 Type u) [UnivLE.{v, u}] (j : J) :\n    (productIso.{v, u} F).inv \u226b Pi.\u03c0 F j = fun f => ((equivShrink _).symm f) j", "start": [432, 1], "end": [435, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.coproductColimitCocone", "code": "def coproductColimitCocone {J : Type u} (F : J \u2192 Type u) :\n    Limits.ColimitCocone (Discrete.functor F) where\n  cocone :=\n    { pt := \u03a3j, F j\n      \u03b9 := Discrete.natTrans (fun \u27e8j\u27e9 x => \u27e8j, x\u27e9)}\n  isColimit :=\n    { desc := fun s x => s.\u03b9.app \u27e8x.1\u27e9 x.2\n      uniq := fun s m w => by\n        funext \u27e8j, x\u27e9\n        exact congr_fun (w \u27e8j\u27e9) x }", "start": [439, 1], "end": [450, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.coproductIso", "code": "noncomputable def coproductIso {J : Type u} (F : J \u2192 Type u) : \u2210 F \u2245 \u03a3j, F j :=\n  colimit.isoColimitCocone (coproductColimitCocone F)", "start": [453, 1], "end": [455, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.coproductIso_\u03b9_comp_hom", "code": "@[elementwise (attr := simp)]\ntheorem coproductIso_\u03b9_comp_hom {J : Type u} (F : J \u2192 Type u) (j : J) :\n    Sigma.\u03b9 F j \u226b (coproductIso F).hom = fun x : F j => (\u27e8j, x\u27e9 : \u03a3j, F j)", "start": [458, 1], "end": [461, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.coproductIso_mk_comp_inv", "code": "theorem coproductIso_mk_comp_inv {J : Type u} (F : J \u2192 Type u) (j : J) :\n    (\u21befun x : F j => (\u27e8j, x\u27e9 : \u03a3j, F j)) \u226b (coproductIso F).inv = Sigma.\u03b9 F j", "start": [466, 1], "end": [468, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.typeEqualizerOfUnique", "code": "noncomputable def typeEqualizerOfUnique (t : \u2200 y : Y, g y = h y \u2192 \u2203! x : X, f x = y) :\n    IsLimit (Fork.of\u03b9 _ w) :=\n  Fork.IsLimit.mk' _ fun s => by\n    refine' \u27e8fun i => _, _, _\u27e9\n    \u00b7 apply Classical.choose (t (s.\u03b9 i) _)\n      apply congr_fun s.condition i\n    \u00b7 funext i\n      exact (Classical.choose_spec (t (s.\u03b9 i) (congr_fun s.condition i))).1\n    \u00b7 intro m hm\n      funext i\n      exact (Classical.choose_spec (t (s.\u03b9 i) (congr_fun s.condition i))).2 _ (congr_fun hm i)", "start": [475, 1], "end": [490, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.unique_of_type_equalizer", "code": "theorem unique_of_type_equalizer (t : IsLimit (Fork.of\u03b9 _ w)) (y : Y) (hy : g y = h y) :\n    \u2203! x : X, f x = y", "start": [493, 1], "end": [504, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.type_equalizer_iff_unique", "code": "theorem type_equalizer_iff_unique :\n    Nonempty (IsLimit (Fork.of\u03b9 _ w)) \u2194 \u2200 y : Y, g y = h y \u2192 \u2203! x : X, f x = y", "start": [507, 1], "end": [510, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.equalizerLimit", "code": "def equalizerLimit : Limits.LimitCone (parallelPair g h) where\n  cone := Fork.of\u03b9 (Subtype.val : { x : Y // g x = h x } \u2192 Y) (funext Subtype.prop)\n  isLimit :=\n    Fork.IsLimit.mk' _ fun s =>\n      \u27e8fun i => \u27e8s.\u03b9 i, by apply congr_fun s.condition i\u27e9, rfl, fun hm =>\n        funext fun x => Subtype.ext (congr_fun hm x)\u27e9", "start": [513, 1], "end": [519, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.equalizerIso", "code": "noncomputable def equalizerIso : equalizer g h \u2245 { x : Y // g x = h x } :=\n  limit.isoLimitCone equalizerLimit", "start": [524, 1], "end": [526, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.equalizerIso_hom_comp_subtype", "code": "@[simp]\ntheorem equalizerIso_hom_comp_subtype : (equalizerIso g h).hom \u226b Subtype.val = equalizer.\u03b9 g h", "start": [530, 1], "end": [532, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.equalizerIso_inv_comp_\u03b9", "code": "@[elementwise (attr := simp)]\ntheorem equalizerIso_inv_comp_\u03b9 : (equalizerIso g h).inv \u226b equalizer.\u03b9 g h = Subtype.val", "start": [535, 1], "end": [537, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.CoequalizerRel", "code": "inductive CoequalizerRel : Y \u2192 Y \u2192 Prop\n  | Rel (x : X) : CoequalizerRel (f x) (g x)", "start": [546, 1], "end": [548, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.coequalizerColimit", "code": "def coequalizerColimit : Limits.ColimitCocone (parallelPair f g) where\n  cocone :=\n    Cofork.of\u03c0 (Quot.mk (CoequalizerRel f g)) (funext fun x => Quot.sound (CoequalizerRel.Rel x))\n  isColimit :=\n    Cofork.IsColimit.mk _\n      (fun s => Quot.lift s.\u03c0\n        (fun a b (h : CoequalizerRel f g a b) => by\n          cases h\n          apply congr_fun s.condition))\n      (fun s => rfl)\n      (fun s m hm => funext (fun x => Quot.inductionOn x (congr_fun hm)))", "start": [551, 1], "end": [564, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.coequalizer_preimage_image_eq_of_preimage_eq", "code": "theorem coequalizer_preimage_image_eq_of_preimage_eq (\u03c0 : Y \u27f6 Z) (e : f \u226b \u03c0 = g \u226b \u03c0)\n    (h : IsColimit (Cofork.of\u03c0 \u03c0 e)) (U : Set Y) (H : f \u207b\u00b9' U = g \u207b\u00b9' U) : \u03c0 \u207b\u00b9' (\u03c0 '' U) = U", "start": [567, 1], "end": [594, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.coequalizerIso", "code": "noncomputable def coequalizerIso : coequalizer f g \u2245 _root_.Quot (CoequalizerRel f g) :=\n  colimit.isoColimitCocone (coequalizerColimit f g)", "start": [597, 1], "end": [599, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.coequalizerIso_\u03c0_comp_hom", "code": "@[elementwise (attr := simp)]\ntheorem coequalizerIso_\u03c0_comp_hom :\n    coequalizer.\u03c0 f g \u226b (coequalizerIso f g).hom = Quot.mk (CoequalizerRel f g)", "start": [602, 1], "end": [605, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.coequalizerIso_quot_comp_inv", "code": "@[simp]\ntheorem coequalizerIso_quot_comp_inv :\n    \u21beQuot.mk (CoequalizerRel f g) \u226b (coequalizerIso f g).inv = coequalizer.\u03c0 f g", "start": [609, 1], "end": [612, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.PullbackObj", "code": "abbrev PullbackObj : Type u :=\n  { p : X \u00d7 Y // f p.1 = g p.2 }", "start": [637, 1], "end": [641, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.pullbackCone", "code": "abbrev pullbackCone : Limits.PullbackCone f g :=\n  PullbackCone.mk (fun p : PullbackObj f g => p.1.1) (fun p => p.1.2) (funext fun p => p.2)", "start": [648, 1], "end": [652, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.pullbackLimitCone", "code": "@[simps]\ndef pullbackLimitCone (f : X \u27f6 Z) (g : Y \u27f6 Z) : Limits.LimitCone (cospan f g) where\n  cone := pullbackCone f g\n  isLimit :=\n    PullbackCone.isLimitAux _ (fun s x => \u27e8\u27e8s.fst x, s.snd x\u27e9, congr_fun s.condition x\u27e9)\n      (by aesop) (by aesop) fun s m w =>\n      funext fun x =>\n        Subtype.ext <|\n          Prod.ext (congr_fun (w WalkingCospan.left) x) (congr_fun (w WalkingCospan.right) x)", "start": [655, 1], "end": [666, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.pullbackConeIsoPullback", "code": "noncomputable def pullbackConeIsoPullback : limit.cone (cospan f g) \u2245 pullbackCone f g :=\n  (limit.isLimit _).uniqueUpToIso (pullbackLimitCone f g).isLimit", "start": [669, 1], "end": [673, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.pullbackIsoPullback", "code": "noncomputable def pullbackIsoPullback : pullback f g \u2245 PullbackObj f g :=\n  (Cones.forget _).mapIso <| pullbackConeIsoPullback f g", "start": [676, 1], "end": [680, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.pullbackIsoPullback_hom_fst", "code": "@[simp]\ntheorem pullbackIsoPullback_hom_fst (p : pullback f g) :\n    ((pullbackIsoPullback f g).hom p : X \u00d7 Y).fst = (pullback.fst : _ \u27f6 X) p", "start": [683, 1], "end": [686, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.pullbackIsoPullback_hom_snd", "code": "@[simp]\ntheorem pullbackIsoPullback_hom_snd (p : pullback f g) :\n    ((pullbackIsoPullback f g).hom p : X \u00d7 Y).snd = (pullback.snd : _ \u27f6 Y) p", "start": [689, 1], "end": [692, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.pullbackIsoPullback_inv_fst", "code": "@[simp]\ntheorem pullbackIsoPullback_inv_fst :\n    (pullbackIsoPullback f g).inv \u226b pullback.fst = fun p => (p.1 : X \u00d7 Y).fst", "start": [695, 1], "end": [698, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Types.pullbackIsoPullback_inv_snd", "code": "@[simp]\ntheorem pullbackIsoPullback_inv_snd :\n    (pullbackIsoPullback f g).inv \u226b pullback.snd = fun p => (p.1 : X \u00d7 Y).snd", "start": [701, 1], "end": [704, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/SplitCoequalizer.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.IsSplitCoequalizer", "code": "structure IsSplitCoequalizer {Z : C} (\u03c0 : Y \u27f6 Z) where\n  \n  rightSection : Z \u27f6 Y\n  \n  leftSection : Y \u27f6 X\n  \n  condition : f \u226b \u03c0 = g \u226b \u03c0\n  \n  rightSection_\u03c0 : rightSection \u226b \u03c0 = \ud835\udfd9 Z\n  \n  leftSection_bottom : leftSection \u226b g = \ud835\udfd9 Y\n  \n  leftSection_top : leftSection \u226b f = \u03c0 \u226b rightSection", "start": [45, 1], "end": [74, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSplitCoequalizer.map", "code": "@[simps]\ndef IsSplitCoequalizer.map {Z : C} {\u03c0 : Y \u27f6 Z} (q : IsSplitCoequalizer f g \u03c0) (F : C \u2964 D) :\n    IsSplitCoequalizer (F.map f) (F.map g) (F.map \u03c0)\n    where\n  rightSection := F.map q.rightSection\n  leftSection := F.map q.leftSection\n  condition := by rw [\u2190 F.map_comp, q.condition, F.map_comp]\n  rightSection_\u03c0 := by rw [\u2190 F.map_comp, q.rightSection_\u03c0, F.map_id]\n  leftSection_bottom := by rw [\u2190 F.map_comp, q.leftSection_bottom, F.map_id]\n  leftSection_top := by rw [\u2190 F.map_comp, q.leftSection_top, F.map_comp]", "start": [93, 1], "end": [103, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSplitCoequalizer.asCofork", "code": "@[simps! pt]\ndef IsSplitCoequalizer.asCofork {Z : C} {h : Y \u27f6 Z} (t : IsSplitCoequalizer f g h) :\n    Cofork f g := Cofork.of\u03c0 h t.condition", "start": [110, 1], "end": [113, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSplitCoequalizer.asCofork_\u03c0", "code": "@[simp]\ntheorem IsSplitCoequalizer.asCofork_\u03c0 {Z : C} {h : Y \u27f6 Z} (t : IsSplitCoequalizer f g h) :\n    t.asCofork.\u03c0 = h", "start": [116, 1], "end": [118, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSplitCoequalizer.isCoequalizer", "code": "def IsSplitCoequalizer.isCoequalizer {Z : C} {h : Y \u27f6 Z} (t : IsSplitCoequalizer f g h) :\n    IsColimit t.asCofork :=\n  Cofork.IsColimit.mk' _ fun s =>\n    \u27e8t.rightSection \u226b s.\u03c0, by\n      dsimp\n      rw [\u2190 t.leftSection_top_assoc, s.condition, t.leftSection_bottom_assoc], fun hm => by\n      simp [\u2190 hm]\u27e9", "start": [121, 1], "end": [131, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasSplitCoequalizer", "code": "class HasSplitCoequalizer : Prop where\n  \n  splittable : \u2203 (Z : C) (h : Y \u27f6 Z), Nonempty (IsSplitCoequalizer f g h)", "start": [138, 1], "end": [144, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.IsSplitPair", "code": "abbrev Functor.IsSplitPair : Prop :=\n  HasSplitCoequalizer (G.map f) (G.map g)", "start": [147, 1], "end": [152, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasSplitCoequalizer.coequalizerOfSplit", "code": "noncomputable def HasSplitCoequalizer.coequalizerOfSplit [HasSplitCoequalizer f g] : C :=\n  (@splittable _ _ _ _ f g).choose", "start": [155, 1], "end": [157, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasSplitCoequalizer.coequalizer\u03c0", "code": "noncomputable def HasSplitCoequalizer.coequalizer\u03c0 [HasSplitCoequalizer f g] :\n    Y \u27f6 HasSplitCoequalizer.coequalizerOfSplit f g :=\n  (@splittable _ _ _ _ f g).choose_spec.choose", "start": [160, 1], "end": [163, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasSplitCoequalizer.isSplitCoequalizer", "code": "noncomputable def HasSplitCoequalizer.isSplitCoequalizer [HasSplitCoequalizer f g] :\n    IsSplitCoequalizer f g (HasSplitCoequalizer.coequalizer\u03c0 f g) :=\n  Classical.choice (@splittable _ _ _ _ f g).choose_spec.choose_spec", "start": [166, 1], "end": [169, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.map_is_split_pair", "code": "instance map_is_split_pair [HasSplitCoequalizer f g] : HasSplitCoequalizer (G.map f) (G.map g) where\n  splittable :=\n    \u27e8_, _, \u27e8IsSplitCoequalizer.map (HasSplitCoequalizer.isSplitCoequalizer f g) _\u27e9\u27e9", "start": [172, 1], "end": [175, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoequalizer_of_hasSplitCoequalizer", "code": "instance (priority := 1) hasCoequalizer_of_hasSplitCoequalizer [HasSplitCoequalizer f g] :\n    HasCoequalizer f g :=\n  HasColimit.mk \u27e8_, (HasSplitCoequalizer.isSplitCoequalizer f g).isCoequalizer\u27e9", "start": [180, 1], "end": [183, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Yoneda.lean", "imports": ["Mathlib/CategoryTheory/Limits/FunctorCategory.lean", "Mathlib/Util/AssertExists.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Coyoneda.colimitCocone", "code": "@[simps]\ndef colimitCocone (X : C\u1d52\u1d56) : Cocone (coyoneda.obj X) where\n  pt := PUnit\n  \u03b9 := { app := by aesop_cat }", "start": [30, 1], "end": [35, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Coyoneda.colimitCoconeIsColimit", "code": "@[simps]\ndef colimitCoconeIsColimit (X : C\u1d52\u1d56) : IsColimit (colimitCocone X)\n    where\n  desc s _ := s.\u03b9.app (unop X) (\ud835\udfd9 _)\n  fac s Y := by\n    funext f\n    convert congr_fun (s.w f).symm (\ud835\udfd9 (unop X))\n    simp only [coyoneda_obj_obj, Functor.const_obj_obj, types_comp_apply,\n      coyoneda_obj_map, Category.id_comp]\n  uniq s m w := by\n    apply funext; rintro \u27e8\u27e9\n    dsimp\n    rw [\u2190 w]\n    simp", "start": [38, 1], "end": [53, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Coyoneda.colimitCoyonedaIso", "code": "noncomputable def colimitCoyonedaIso (X : C\u1d52\u1d56) : colimit (coyoneda.obj X) \u2245 PUnit := by\n  apply colimit.isoColimitCocone\n    { cocone := _\n      isColimit := colimitCoconeIsColimit X }", "start": [61, 1], "end": [66, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaPreservesLimits", "code": "instance yonedaPreservesLimits (X : C) : PreservesLimits (yoneda.obj X) where\n  preservesLimitsOfShape {J} \ud835\udca5 :=\n    { preservesLimit := fun {K} =>\n        { preserves := fun {c} t =>\n            { lift := fun s x =>\n                Quiver.Hom.unop (t.lift \u27e8op X, fun j => (s.\u03c0.app j x).op, fun j\u2081 j\u2082 \u03b1 => by\n                  simp [\u2190 s.w \u03b1]\u27e9)\n              fac := fun s j => funext fun x => Quiver.Hom.op_inj (t.fac _ _)\n              uniq := fun s m w =>\n                funext fun x => by\n                  refine Quiver.Hom.op_inj (t.uniq \u27e8op X, _, _\u27e9 _ fun j => ?_)\n                  exact Quiver.Hom.unop_inj (congrFun (w j) x) } } }", "start": [75, 1], "end": [87, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coyonedaPreservesLimits", "code": "instance coyonedaPreservesLimits (X : C\u1d52\u1d56) : PreservesLimits (coyoneda.obj X) where\n  preservesLimitsOfShape {J} \ud835\udca5 :=\n    { preservesLimit := fun {K} =>\n        { preserves := fun {c} t =>\n            { lift := fun s x =>\n                t.lift\n                  \u27e8unop X, fun j => s.\u03c0.app j x, fun j\u2081 j\u2082 \u03b1 => by\n                    dsimp\n                    simp [\u2190 s.w \u03b1]\u27e9\n              fac := fun s j => funext fun x => t.fac _ _\n              uniq := fun s m w =>\n                funext fun x => by\n                  refine' t.uniq \u27e8unop X, _\u27e9 _ fun j => _\n                  exact congrFun (w j) x } } }", "start": [90, 1], "end": [105, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaJointlyReflectsLimits", "code": "def yonedaJointlyReflectsLimits (J : Type w) [SmallCategory J] (K : J \u2964 C\u1d52\u1d56) (c : Cone K)\n    (t : \u2200 X : C, IsLimit ((yoneda.obj X).mapCone c)) : IsLimit c :=\n  let s' : \u2200 s : Cone K, Cone (K \u22d9 yoneda.obj s.pt.unop) := fun s =>\n    \u27e8PUnit, fun j _ => (s.\u03c0.app j).unop, fun j\u2081 j\u2082 \u03b1 =>\n      funext fun _ => Quiver.Hom.op_inj (s.w \u03b1).symm\u27e9\n  { lift := fun s => ((t s.pt.unop).lift (s' s) PUnit.unit).op\n    fac := fun s j => Quiver.Hom.unop_inj (congr_fun ((t s.pt.unop).fac (s' s) j) PUnit.unit)\n    uniq := fun s m w => by\n      apply Quiver.Hom.unop_inj\n      suffices (fun _ : PUnit => m.unop) = (t s.pt.unop).lift (s' s) by\n        apply congr_fun this PUnit.unit\n      apply (t _).uniq (s' s) _ fun j => _\n      intro j\n      funext\n      exact Quiver.Hom.op_inj (w j) }", "start": [108, 1], "end": [123, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coyonedaJointlyReflectsLimits", "code": "def coyonedaJointlyReflectsLimits (J : Type w) [SmallCategory J] (K : J \u2964 C) (c : Cone K)\n    (t : \u2200 X : C\u1d52\u1d56, IsLimit ((coyoneda.obj X).mapCone c)) : IsLimit c :=\n  let s' : \u2200 s : Cone K, Cone (K \u22d9 coyoneda.obj (op s.pt)) := fun s =>\n    \u27e8PUnit, fun j _ => s.\u03c0.app j, fun j\u2081 j\u2082 \u03b1 => funext fun _ => (s.w \u03b1).symm\u27e9\n  { lift := fun s => (t (op s.pt)).lift (s' s) PUnit.unit\n    fac := fun s j => congr_fun ((t _).fac (s' s) j) PUnit.unit\n    uniq := fun s m w => by\n      suffices (fun _ : PUnit => m) = (t _).lift (s' s) by apply congr_fun this PUnit.unit\n      apply (t _).uniq (s' s) _ fun j => _\n      intro j\n      funext\n      exact w j }", "start": [126, 1], "end": [138, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaFunctorPreservesLimits", "code": "instance yonedaFunctorPreservesLimits : PreservesLimits (@yoneda D _) := by\n  apply preservesLimitsOfEvaluation\n  intro K\n  change PreservesLimits (coyoneda.obj K)\n  infer_instance", "start": [143, 1], "end": [147, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coyonedaFunctorPreservesLimits", "code": "instance coyonedaFunctorPreservesLimits : PreservesLimits (@coyoneda D _) := by\n  apply preservesLimitsOfEvaluation\n  intro K\n  change PreservesLimits (yoneda.obj K)\n  infer_instance", "start": [150, 1], "end": [154, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaFunctorReflectsLimits", "code": "instance yonedaFunctorReflectsLimits : ReflectsLimits (@yoneda D _) :=\n  Limits.fullyFaithfulReflectsLimits _", "start": [157, 1], "end": [158, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coyonedaFunctorReflectsLimits", "code": "instance coyonedaFunctorReflectsLimits : ReflectsLimits (@coyoneda D _) :=\n  Limits.fullyFaithfulReflectsLimits _", "start": [161, 1], "end": [162, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Preserves/Shapes/BinaryProducts.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "Mathlib/CategoryTheory/Limits/Preserves/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.isLimitMapConeBinaryFanEquiv", "code": "def isLimitMapConeBinaryFanEquiv :\n    IsLimit (G.mapCone (BinaryFan.mk f g)) \u2243 IsLimit (BinaryFan.mk (G.map f) (G.map g)) :=\n  (IsLimit.postcomposeHomEquiv (diagramIsoPair _) _).symm.trans\n    (IsLimit.equivIsoLimit\n      (Cones.ext (Iso.refl _)\n        (by rintro (_ | _) <;> simp)))", "start": [40, 1], "end": [49, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.mapIsLimitOfPreservesOfIsLimit", "code": "def mapIsLimitOfPreservesOfIsLimit [PreservesLimit (pair X Y) G] (l : IsLimit (BinaryFan.mk f g)) :\n    IsLimit (BinaryFan.mk (G.map f) (G.map g)) :=\n  isLimitMapConeBinaryFanEquiv G f g (PreservesLimit.preserves l)", "start": [52, 1], "end": [55, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitOfReflectsOfMapIsLimit", "code": "def isLimitOfReflectsOfMapIsLimit [ReflectsLimit (pair X Y) G]\n    (l : IsLimit (BinaryFan.mk (G.map f) (G.map g))) : IsLimit (BinaryFan.mk f g) :=\n  ReflectsLimit.reflects ((isLimitMapConeBinaryFanEquiv G f g).symm l)", "start": [58, 1], "end": [61, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitOfHasBinaryProductOfPreservesLimit", "code": "def isLimitOfHasBinaryProductOfPreservesLimit [PreservesLimit (pair X Y) G] :\n    IsLimit (BinaryFan.mk (G.map (Limits.prod.fst : X \u2a2f Y \u27f6 X)) (G.map Limits.prod.snd)) :=\n  mapIsLimitOfPreservesOfIsLimit G _ _ (prodIsProd X Y)", "start": [66, 1], "end": [71, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesLimitPair.ofIsoProdComparison", "code": "def PreservesLimitPair.ofIsoProdComparison [i : IsIso (prodComparison G X Y)] :\n    PreservesLimit (pair X Y) G := by\n  apply preservesLimitOfPreservesLimitCone (prodIsProd X Y)\n  apply (isLimitMapConeBinaryFanEquiv _ _ _).symm _\n  refine @IsLimit.ofPointIso _ _ _ _ _ _ _ (limit.isLimit (pair (G.obj X) (G.obj Y))) ?_\n  apply i", "start": [76, 1], "end": [84, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesLimitPair.iso", "code": "def PreservesLimitPair.iso : G.obj (X \u2a2f Y) \u2245 G.obj X \u2a2f G.obj Y :=\n  IsLimit.conePointUniqueUpToIso (isLimitOfHasBinaryProductOfPreservesLimit G X Y) (limit.isLimit _)", "start": [89, 1], "end": [93, 101], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesLimitPair.iso_hom", "code": "@[simp]\ntheorem PreservesLimitPair.iso_hom : (PreservesLimitPair.iso G X Y).hom = prodComparison G X Y", "start": [96, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitMapCoconeBinaryCofanEquiv", "code": "def isColimitMapCoconeBinaryCofanEquiv :\n    IsColimit (Functor.mapCocone G (BinaryCofan.mk f g))\n    \u2243 IsColimit (BinaryCofan.mk (G.map f) (G.map g)) :=\n  (IsColimit.precomposeHomEquiv (diagramIsoPair _).symm _).symm.trans\n    (IsColimit.equivIsoColimit\n      (Cocones.ext (Iso.refl _)\n        (by rintro (_ | _) <;> simp)))", "start": [111, 1], "end": [121, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.mapIsColimitOfPreservesOfIsColimit", "code": "def mapIsColimitOfPreservesOfIsColimit [PreservesColimit (pair X Y) G]\n    (l : IsColimit (BinaryCofan.mk f g)) : IsColimit (BinaryCofan.mk (G.map f) (G.map g)) :=\n  isColimitMapCoconeBinaryCofanEquiv G f g (PreservesColimit.preserves l)", "start": [124, 1], "end": [127, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitOfReflectsOfMapIsColimit", "code": "def isColimitOfReflectsOfMapIsColimit [ReflectsColimit (pair X Y) G]\n    (l : IsColimit (BinaryCofan.mk (G.map f) (G.map g))) : IsColimit (BinaryCofan.mk f g) :=\n  ReflectsColimit.reflects ((isColimitMapCoconeBinaryCofanEquiv G f g).symm l)", "start": [130, 1], "end": [133, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitOfHasBinaryCoproductOfPreservesColimit", "code": "def isColimitOfHasBinaryCoproductOfPreservesColimit [PreservesColimit (pair X Y) G] :\n    IsColimit (BinaryCofan.mk (G.map (Limits.coprod.inl : X \u27f6 X \u2a3f Y)) (G.map Limits.coprod.inr)) :=\n  mapIsColimitOfPreservesOfIsColimit G _ _ (coprodIsCoprod X Y)", "start": [138, 1], "end": [144, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesColimitPair.ofIsoCoprodComparison", "code": "def PreservesColimitPair.ofIsoCoprodComparison [i : IsIso (coprodComparison G X Y)] :\n    PreservesColimit (pair X Y) G := by\n  apply preservesColimitOfPreservesColimitCocone (coprodIsCoprod X Y)\n  apply (isColimitMapCoconeBinaryCofanEquiv _ _ _).symm _\n  refine @IsColimit.ofPointIso _ _ _ _ _ _ _ (colimit.isColimit (pair (G.obj X) (G.obj Y))) ?_\n  apply i", "start": [149, 1], "end": [157, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesColimitPair.iso", "code": "def PreservesColimitPair.iso : G.obj X \u2a3f G.obj Y \u2245 G.obj (X \u2a3f Y) :=\n  IsColimit.coconePointUniqueUpToIso (colimit.isColimit _)\n    (isColimitOfHasBinaryCoproductOfPreservesColimit G X Y)", "start": [162, 1], "end": [168, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesColimitPair.iso_hom", "code": "@[simp]\ntheorem PreservesColimitPair.iso_hom :\n    (PreservesColimitPair.iso G X Y).hom = coprodComparison G X Y", "start": [171, 1], "end": [173, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Presheaf.lean", "imports": ["Mathlib/CategoryTheory/Limits/FunctorCategory.lean", "Mathlib/CategoryTheory/Adjunction/Opposites.lean", "Mathlib/CategoryTheory/Limits/KanExtension.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Elements.lean", "Mathlib/CategoryTheory/Limits/Types.lean", "Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "Mathlib/CategoryTheory/Adjunction/Limits.lean"], "premises": [{"full_name": "CategoryTheory.ColimitAdj.restrictedYoneda", "code": "@[simps!]\ndef restrictedYoneda : \u2130 \u2964 C\u1d52\u1d56 \u2964 Type u\u2081 :=\n  yoneda \u22d9 (whiskeringLeft _ _ (Type u\u2081)).obj (Functor.op A)", "start": [64, 1], "end": [74, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ColimitAdj.restrictedYonedaYoneda", "code": "def restrictedYonedaYoneda : restrictedYoneda (yoneda : C \u2964 C\u1d52\u1d56 \u2964 Type u\u2081) \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents fun P =>\n    NatIso.ofComponents (fun X => yonedaSectionsSmall X.unop _) @ fun X Y f =>\n      funext fun x => by\n        dsimp\n        have : x.app X (CategoryStruct.id (Opposite.unop X)) =\n            (x.app X (\ud835\udfd9 (Opposite.unop X))) := rfl\n        rw [this]\n        rw [\u2190 FunctorToTypes.naturality _ _ x f (\ud835\udfd9 _)]\n        simp only [id_comp, Functor.op_obj, Opposite.unop_op, yoneda_obj_map, comp_id]", "start": [77, 1], "end": [90, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ColimitAdj.restrictYonedaHomEquiv", "code": "def restrictYonedaHomEquiv (P : C\u1d52\u1d56 \u2964 Type u\u2081) (E : \u2130)\n    {c : Cocone ((CategoryOfElements.\u03c0 P).leftOp \u22d9 A)} (t : IsColimit c) :\n    (c.pt \u27f6 E) \u2243 (P \u27f6 (restrictedYoneda A).obj E) :=\n  ((uliftTrivial _).symm \u226a\u226b t.homIso' E).toEquiv.trans\n    { toFun := fun k =>\n        { app := fun c p => k.1 (Opposite.op \u27e8_, p\u27e9)\n          naturality := fun c c' f =>\n            funext fun p =>\n              (k.2\n                  (Quiver.Hom.op \u27e8f, rfl\u27e9 :\n                    (Opposite.op \u27e8c', P.map f p\u27e9 : P.Elements\u1d52\u1d56) \u27f6 Opposite.op \u27e8c, p\u27e9)).symm }\n      invFun := fun \u03c4 =>\n        { val := fun p => \u03c4.app p.unop.1 p.unop.2\n          property := @fun p p' f => by\n            simp_rw [\u2190 f.unop.2]\n            apply (congr_fun (\u03c4.naturality f.unop.1) p'.unop.2).symm }\n      left_inv := by\n        rintro \u27e8k\u2081, k\u2082\u27e9\n        ext\n        dsimp\n        congr 1\n      right_inv := by\n        rintro \u27e8_, _\u27e9\n        rfl }", "start": [93, 1], "end": [120, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ColimitAdj.restrictYonedaHomEquiv_natural", "code": "theorem restrictYonedaHomEquiv_natural (P : C\u1d52\u1d56 \u2964 Type u\u2081) (E\u2081 E\u2082 : \u2130) (g : E\u2081 \u27f6 E\u2082) {c : Cocone _}\n    (t : IsColimit c) (k : c.pt \u27f6 E\u2081) :\n    restrictYonedaHomEquiv A P E\u2082 t (k \u226b g) =\n      restrictYonedaHomEquiv A P E\u2081 t k \u226b (restrictedYoneda A).map g", "start": [123, 1], "end": [131, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ColimitAdj.extendAlongYoneda", "code": "noncomputable def extendAlongYoneda : (C\u1d52\u1d56 \u2964 Type u\u2081) \u2964 \u2130 :=\n  Adjunction.leftAdjointOfEquiv (fun P E => restrictYonedaHomEquiv A P E (colimit.isColimit _))\n    fun P E E' g => restrictYonedaHomEquiv_natural A P E E' g _", "start": [136, 1], "end": [143, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ColimitAdj.extendAlongYoneda_obj", "code": "@[simp]\ntheorem extendAlongYoneda_obj (P : C\u1d52\u1d56 \u2964 Type u\u2081) :\n    (extendAlongYoneda A).obj P = colimit ((CategoryOfElements.\u03c0 P).leftOp \u22d9 A)", "start": [146, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ColimitAdj.extendAlongYoneda_obj.hom_ext", "code": "@[ext] lemma extendAlongYoneda_obj.hom_ext {P : C\u1d52\u1d56 \u2964 Type u\u2081}\n    {f f' : (extendAlongYoneda A).obj P \u27f6 X}\n    (w : \u2200 j, colimit.\u03b9 ((CategoryOfElements.\u03c0 P).leftOp \u22d9 A) j \u226b f =\n      colimit.\u03b9 ((CategoryOfElements.\u03c0 P).leftOp \u22d9 A) j \u226b f') : f = f' :=\nCategoryTheory.Limits.colimit.hom_ext w", "start": [157, 1], "end": [161, 40], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ColimitAdj.extendAlongYoneda_map", "code": "theorem extendAlongYoneda_map {X Y : C\u1d52\u1d56 \u2964 Type u\u2081} (f : X \u27f6 Y) :\n    (extendAlongYoneda A).map f =\n      colimit.pre ((CategoryOfElements.\u03c0 Y).leftOp \u22d9 A) (CategoryOfElements.map f).op", "start": [163, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ColimitAdj.yonedaAdjunction", "code": "noncomputable def yonedaAdjunction : extendAlongYoneda A \u22a3 restrictedYoneda A :=\n  Adjunction.adjunctionOfEquivLeft _ _", "start": [183, 1], "end": [188, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ColimitAdj.Elements.initial", "code": "def Elements.initial (A : C) : (yoneda.obj A).Elements :=\n  \u27e8Opposite.op A, \ud835\udfd9 _\u27e9", "start": [191, 1], "end": [196, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ColimitAdj.isInitial", "code": "def isInitial (A : C) : IsInitial (Elements.initial A) where\n  desc s := \u27e8s.pt.2.op, comp_id _\u27e9\n  uniq s m _ := by\n    simp_rw [\u2190 m.2]\n    dsimp [Elements.initial]\n    simp\n  fac := by rintro s \u27e8\u27e8\u27e9\u27e9", "start": [199, 1], "end": [207, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ColimitAdj.isExtensionAlongYoneda", "code": "noncomputable def isExtensionAlongYoneda :\n    (yoneda : C \u2964 C\u1d52\u1d56 \u2964 Type u\u2081) \u22d9 extendAlongYoneda A \u2245 A :=\n  NatIso.ofComponents\n    (fun X =>\n      (colimit.isColimit _).coconePointUniqueUpToIso\n        (colimitOfDiagramTerminal (terminalOpOfInitial (isInitial _)) _))\n    (by\n      intro X Y f\n      change (colimit.desc _ _ \u226b _) = colimit.desc _ _ \u226b _\n      ext\n      rw [colimit.\u03b9_desc_assoc, colimit.\u03b9_desc_assoc]\n      change (colimit.\u03b9 _ _ \u226b \ud835\udfd9 _) \u226b colimit.desc _ _ = _\n      rw [comp_id, colimit.\u03b9_desc]\n      dsimp\n      rw [\u2190 A.map_comp]\n      congr 1)", "start": [210, 1], "end": [235, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ColimitAdj.extendAlongYonedaIsoKanApp", "code": "@[simps]\nnoncomputable def extendAlongYonedaIsoKanApp (X) :\n    (extendAlongYoneda A).obj X \u2245 ((lan yoneda : (_ \u2964 \u2130) \u2964 _).obj A).obj X :=\n  let eq := CategoryOfElements.costructuredArrowYonedaEquivalence X\n  { hom := colimit.pre (Lan.diagram (yoneda : C \u2964 _ \u2964 Type u\u2081) A X) eq.functor\n    inv := colimit.pre ((CategoryOfElements.\u03c0 X).leftOp \u22d9 A) eq.inverse\n    hom_inv_id := by\n      erw [colimit.pre_pre ((CategoryOfElements.\u03c0 X).leftOp \u22d9 A) eq.inverse]\n      trans colimit.pre ((CategoryOfElements.\u03c0 X).leftOp \u22d9 A) (\ud835\udfed _)\n      congr\n      \u00b7 exact congr_arg Functor.op (CategoryOfElements.from_toCostructuredArrow_eq X)\n      \u00b7 ext\n        simp only [colimit.\u03b9_pre]\n        erw [Category.comp_id]\n        congr\n    inv_hom_id := by\n      erw [colimit.pre_pre (Lan.diagram (yoneda : C \u2964 _ \u2964 Type u\u2081) A X) eq.functor]\n      trans colimit.pre (Lan.diagram (yoneda : C \u2964 _ \u2964 Type u\u2081) A X) (\ud835\udfed _)\n      congr\n      \u00b7 exact CategoryOfElements.to_fromCostructuredArrow_eq X\n      \u00b7 ext\n        simp only [colimit.\u03b9_pre]\n        erw [Category.comp_id]\n        congr }", "start": [242, 1], "end": [268, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ColimitAdj.extendAlongYonedaIsoKan", "code": "@[simps!]\nnoncomputable def extendAlongYonedaIsoKan :\n    extendAlongYoneda A \u2245 (lan yoneda : (_ \u2964 \u2130) \u2964 _).obj A :=\n  NatIso.ofComponents (extendAlongYonedaIsoKanApp A) (by\n    intro X Y f; simp\n    rw [extendAlongYoneda_map]\n    erw [colimit.pre_pre (Lan.diagram (yoneda : C \u2964 _ \u2964 Type u\u2081) A Y) (CostructuredArrow.map f)]\n    erw [colimit.pre_pre (Lan.diagram (yoneda : C \u2964 _ \u2964 Type u\u2081) A Y)\n        (CategoryOfElements.costructuredArrowYonedaEquivalence Y).functor]\n    congr 1\n    apply CategoryOfElements.costructuredArrow_yoneda_equivalence_naturality)", "start": [272, 1], "end": [284, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ColimitAdj.extendOfCompYonedaIsoLan", "code": "noncomputable def extendOfCompYonedaIsoLan {D : Type u\u2081} [SmallCategory D] (F : C \u2964 D) :\n    extendAlongYoneda (F \u22d9 yoneda) \u2245 lan F.op :=\n  Adjunction.natIsoOfRightAdjointNatIso (yonedaAdjunction (F \u22d9 yoneda))\n    (Lan.adjunction (Type u\u2081) F.op)\n    (isoWhiskerRight curriedYonedaLemma' ((whiskeringLeft C\u1d52\u1d56 D\u1d52\u1d56 (Type u\u2081)).obj F.op : _))", "start": [288, 1], "end": [293, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.compYonedaIsoYonedaCompLan", "code": "@[simps!]\nnoncomputable def compYonedaIsoYonedaCompLan {D : Type u\u2081} [SmallCategory D] (F : C \u2964 D) :\n    F \u22d9 yoneda \u2245 yoneda \u22d9 lan F.op :=\n  (isExtensionAlongYoneda (F \u22d9 yoneda)).symm \u226a\u226b isoWhiskerLeft yoneda (extendOfCompYonedaIsoLan F)", "start": [304, 1], "end": [308, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.extendAlongYonedaYoneda", "code": "noncomputable def extendAlongYonedaYoneda : extendAlongYoneda (yoneda : C \u2964 _) \u2245 \ud835\udfed _ :=\n  Adjunction.natIsoOfRightAdjointNatIso (yonedaAdjunction _) Adjunction.id restrictedYonedaYoneda", "start": [312, 1], "end": [316, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.functorToRepresentables", "code": "def functorToRepresentables (P : C\u1d52\u1d56 \u2964 Type u\u2081) : P.Elements\u1d52\u1d56 \u2964 C\u1d52\u1d56 \u2964 Type u\u2081 :=\n  (CategoryOfElements.\u03c0 P).leftOp \u22d9 yoneda", "start": [320, 1], "end": [325, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coconeOfRepresentable", "code": "noncomputable def coconeOfRepresentable (P : C\u1d52\u1d56 \u2964 Type u\u2081) : Cocone (functorToRepresentables P) :=\n  Cocone.extend (colimit.cocone _) (extendAlongYonedaYoneda.hom.app P)", "start": [328, 1], "end": [335, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coconeOfRepresentable_pt", "code": "@[simp]\ntheorem coconeOfRepresentable_pt (P : C\u1d52\u1d56 \u2964 Type u\u2081) : (coconeOfRepresentable P).pt = P", "start": [338, 1], "end": [340, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coconeOfRepresentable_\u03b9_app", "code": "theorem coconeOfRepresentable_\u03b9_app (P : C\u1d52\u1d56 \u2964 Type u\u2081) (j : P.Elements\u1d52\u1d56) :\n    (coconeOfRepresentable P).\u03b9.app j = (yonedaSectionsSmall _ _).inv j.unop.2", "start": [345, 1], "end": [348, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coconeOfRepresentable_naturality", "code": "theorem coconeOfRepresentable_naturality {P\u2081 P\u2082 : C\u1d52\u1d56 \u2964 Type u\u2081} (\u03b1 : P\u2081 \u27f6 P\u2082) (j : P\u2081.Elements\u1d52\u1d56) :\n    (coconeOfRepresentable P\u2081).\u03b9.app j \u226b \u03b1 =\n      (coconeOfRepresentable P\u2082).\u03b9.app ((CategoryOfElements.map \u03b1).op.obj j)", "start": [351, 1], "end": [356, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.colimitOfRepresentable", "code": "noncomputable def colimitOfRepresentable (P : C\u1d52\u1d56 \u2964 Type u\u2081) :\n    IsColimit (coconeOfRepresentable P) := by\n  suffices IsIso (IsColimit.desc (colimit.isColimit (functorToRepresentables P))\n    (coconeOfRepresentable P)) by\n    apply IsColimit.ofPointIso (colimit.isColimit (functorToRepresentables P))\n  change IsIso (colimit.desc _ (Cocone.extend _ _))\n  rw [colimit.desc_extend, colimit.desc_cocone]\n  infer_instance", "start": [359, 1], "end": [375, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.natIsoOfNatIsoOnRepresentables", "code": "noncomputable def natIsoOfNatIsoOnRepresentables (L\u2081 L\u2082 : (C\u1d52\u1d56 \u2964 Type u\u2081) \u2964 \u2130)\n    [PreservesColimits L\u2081] [PreservesColimits L\u2082] (h : yoneda \u22d9 L\u2081 \u2245 yoneda \u22d9 L\u2082) : L\u2081 \u2245 L\u2082 := by\n  apply NatIso.ofComponents _ _\n  \u00b7 intro P\n    refine'\n      (isColimitOfPreserves L\u2081 (colimitOfRepresentable P)).coconePointsIsoOfNatIso\n        (isColimitOfPreserves L\u2082 (colimitOfRepresentable P)) _\n    apply Functor.associator _ _ _ \u226a\u226b _\n    exact isoWhiskerLeft (CategoryOfElements.\u03c0 P).leftOp h\n  \u00b7 intro P\u2081 P\u2082 f\n    apply (isColimitOfPreserves L\u2081 (colimitOfRepresentable P\u2081)).hom_ext\n    intro j\n    dsimp only [id.def, IsColimit.comp_coconePointsIsoOfNatIso_hom, isoWhiskerLeft_hom]\n    have :\n      (L\u2081.mapCocone (coconeOfRepresentable P\u2081)).\u03b9.app j \u226b L\u2081.map f =\n        (L\u2081.mapCocone (coconeOfRepresentable P\u2082)).\u03b9.app\n          ((CategoryOfElements.map f).op.obj j) := by\n      dsimp\n      rw [\u2190 L\u2081.map_comp, coconeOfRepresentable_naturality]\n      rfl\n    erw [reassoc_of% this, IsColimit.\u03b9_map_assoc, IsColimit.\u03b9_map]\n    dsimp\n    rw [\u2190 L\u2082.map_comp, coconeOfRepresentable_naturality]\n    rfl", "start": [378, 1], "end": [404, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uniqueExtensionAlongYoneda", "code": "noncomputable def uniqueExtensionAlongYoneda (L : (C\u1d52\u1d56 \u2964 Type u\u2081) \u2964 \u2130) (hL : yoneda \u22d9 L \u2245 A)\n    [PreservesColimits L] : L \u2245 extendAlongYoneda A :=\n  natIsoOfNatIsoOnRepresentables _ _ (hL \u226a\u226b (isExtensionAlongYoneda _).symm)", "start": [409, 1], "end": [417, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isLeftAdjointOfPreservesColimitsAux", "code": "noncomputable def isLeftAdjointOfPreservesColimitsAux (L : (C\u1d52\u1d56 \u2964 Type u\u2081) \u2964 \u2130)\n    [PreservesColimits L] : IsLeftAdjoint L where\n  right := restrictedYoneda (yoneda \u22d9 L)\n  adj := (yonedaAdjunction _).ofNatIsoLeft (uniqueExtensionAlongYoneda _ L (Iso.refl _)).symm", "start": [420, 1], "end": [426, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isLeftAdjointOfPreservesColimits", "code": "noncomputable def isLeftAdjointOfPreservesColimits (L : (C \u2964 Type u\u2081) \u2964 \u2130) [PreservesColimits L] :\n    IsLeftAdjoint L :=\n  let e : _ \u2964 Type u\u2081 \u224c _ \u2964 Type u\u2081 := (opOpEquivalence C).congrLeft\n  let _ := isLeftAdjointOfPreservesColimitsAux (e.functor \u22d9 L : _)\n  Adjunction.leftAdjointOfNatIso (e.invFunIdAssoc _)", "start": [429, 1], "end": [436, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.tautologicalCocone", "code": "@[simps]\ndef tautologicalCocone : Cocone (CostructuredArrow.proj yoneda P \u22d9 yoneda) where\n  pt := P\n  \u03b9 := { app := fun X => X.hom }", "start": [445, 1], "end": [452, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isColimitTautologicalCocone", "code": "def isColimitTautologicalCocone : IsColimit (tautologicalCocone P) where\n  desc := fun s => by\n    refine' \u27e8fun X t => yonedaEquiv (s.\u03b9.app (CostructuredArrow.mk (yonedaEquiv.symm t))), _\u27e9\n    intros X Y f\n    ext t\n    dsimp\n    erw [yonedaEquiv_naturality', yonedaEquiv_symm_map]\n    simpa using (s.\u03b9.naturality\n      (CostructuredArrow.homMk' (CostructuredArrow.mk (yonedaEquiv.symm t)) f.unop)).symm\n  fac := by\n    intro s t\n    dsimp\n    apply yonedaEquiv.injective\n    rw [yonedaEquiv_comp]\n    dsimp only\n    erw [Equiv.symm_apply_apply]\n    rfl\n  uniq := by\n    intro s j h\n    ext V x\n    obtain \u27e8t, rfl\u27e9 := yonedaEquiv.surjective x\n    dsimp\n    erw [Equiv.symm_apply_apply, \u2190 yonedaEquiv_comp']\n    exact congr_arg _ (h (CostructuredArrow.mk t))", "start": [454, 1], "end": [482, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/FiniteProducts.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Products.lean", "Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.HasFiniteProducts", "code": "class HasFiniteProducts : Prop where\n  \n  out (n : \u2115) : HasLimitsOfShape (Discrete (Fin n)) C", "start": [28, 1], "end": [36, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteProducts_of_hasFiniteLimits", "code": "instance (priority := 10) hasFiniteProducts_of_hasFiniteLimits [HasFiniteLimits C] :\n    HasFiniteProducts C :=\n  \u27e8fun _ => inferInstance\u27e9", "start": [39, 1], "end": [42, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitsOfShape_discrete", "code": "instance hasLimitsOfShape_discrete [HasFiniteProducts C] (\u03b9 : Type w) [Finite \u03b9] :\n    HasLimitsOfShape (Discrete \u03b9) C := by\n  rcases Finite.exists_equiv_fin \u03b9 with \u27e8n, \u27e8e\u27e9\u27e9\n  haveI : HasLimitsOfShape (Discrete (Fin n)) C := HasFiniteProducts.out n\n  exact hasLimitsOfShape_of_equivalence (Discrete.equivalence e.symm)", "start": [45, 1], "end": [49, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteProducts_of_hasProducts", "code": "theorem hasFiniteProducts_of_hasProducts [HasProducts.{w} C] : HasFiniteProducts C", "start": [56, 1], "end": [59, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasFiniteCoproducts", "code": "class HasFiniteCoproducts : Prop where\n  \n  out (n : \u2115) : HasColimitsOfShape (Discrete (Fin n)) C", "start": [62, 1], "end": [70, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimitsOfShape_discrete", "code": "instance hasColimitsOfShape_discrete [HasFiniteCoproducts C] (\u03b9 : Type w) [Finite \u03b9] :\n    HasColimitsOfShape (Discrete \u03b9) C := by\n  rcases Finite.exists_equiv_fin \u03b9 with \u27e8n, \u27e8e\u27e9\u27e9\n  haveI : HasColimitsOfShape (Discrete (Fin n)) C := HasFiniteCoproducts.out n\n  exact hasColimitsOfShape_of_equivalence (Discrete.equivalence e.symm)", "start": [75, 1], "end": [79, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteCoproducts_of_hasFiniteColimits", "code": "instance (priority := 10) hasFiniteCoproducts_of_hasFiniteColimits [HasFiniteColimits C] :\n    HasFiniteCoproducts C :=\n  \u27e8fun J => by infer_instance\u27e9", "start": [82, 1], "end": [85, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteCoproducts_of_hasCoproducts", "code": "theorem hasFiniteCoproducts_of_hasCoproducts [HasCoproducts.{w} C] : HasFiniteCoproducts C", "start": [88, 1], "end": [91, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/RegularMono.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/StrongEpi.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "Mathlib/Lean/Expr/Basic.lean", "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean"], "premises": [{"full_name": "CategoryTheory.RegularMono", "code": "class RegularMono (f : X \u27f6 Y) where\n  \n  Z : C \n  left : Y \u27f6 Z\n  \n  right : Y \u27f6 Z\n  \n  w : f \u226b left = f \u226b right := by aesop_cat\n  \n  isLimit : IsLimit (Fork.of\u03b9 f w)", "start": [43, 1], "end": [54, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.RegularMono.mono", "code": "instance (priority := 100) RegularMono.mono (f : X \u27f6 Y) [RegularMono f] : Mono f :=\n  mono_of_isLimit_fork RegularMono.isLimit", "start": [59, 1], "end": [61, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.equalizerRegular", "code": "instance equalizerRegular (g h : X \u27f6 Y) [HasLimit (parallelPair g h)] :\n    RegularMono (equalizer.\u03b9 g h) where\n  Z := Y\n  left := g\n  right := h\n  w := equalizer.condition g h\n  isLimit :=\n    Fork.IsLimit.mk _ (fun s => limit.lift _ s) (by simp) fun s m w => by\n      apply equalizer.hom_ext\n      simp [\u2190 w]", "start": [64, 1], "end": [73, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.RegularMono.ofIsSplitMono", "code": "instance (priority := 100) RegularMono.ofIsSplitMono (f : X \u27f6 Y) [IsSplitMono f] :\n    RegularMono f where\n  Z := Y\n  left := \ud835\udfd9 Y\n  right := retraction f \u226b f\n  isLimit := isSplitMonoEqualizes f", "start": [76, 1], "end": [82, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.RegularMono.lift'", "code": "def RegularMono.lift' {W : C} (f : X \u27f6 Y) [RegularMono f] (k : W \u27f6 Y)\n    (h : k \u226b (RegularMono.left : Y \u27f6 @RegularMono.Z _ _ _ _ f _) = k \u226b RegularMono.right) :\n    { l : W \u27f6 X // l \u226b f = k } :=\n  Fork.IsLimit.lift' RegularMono.isLimit _ h", "start": [85, 1], "end": [90, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.regularOfIsPullbackSndOfRegular", "code": "def regularOfIsPullbackSndOfRegular {P Q R S : C} {f : P \u27f6 Q} {g : P \u27f6 R} {h : Q \u27f6 S} {k : R \u27f6 S}\n    [hr : RegularMono h] (comm : f \u226b h = g \u226b k) (t : IsLimit (PullbackCone.mk _ _ comm)) :\n    RegularMono g where\n  Z := hr.Z\n  left := k \u226b hr.left\n  right := k \u226b hr.right\n  w := by\n    repeat (rw [\u2190 Category.assoc, \u2190 eq_whisker comm])\n    simp only [Category.assoc, hr.w]\n  isLimit := by\n    apply Fork.IsLimit.mk' _ _\n    intro s\n    have l\u2081 : (Fork.\u03b9 s \u226b k) \u226b RegularMono.left = (Fork.\u03b9 s \u226b k) \u226b hr.right := by\n      rw [Category.assoc, s.condition, Category.assoc]\n    obtain \u27e8l, hl\u27e9 := Fork.IsLimit.lift' hr.isLimit _ l\u2081\n    obtain \u27e8p, _, hp\u2082\u27e9 := PullbackCone.IsLimit.lift' t _ _ hl\n    refine' \u27e8p, hp\u2082, _\u27e9\n    intro m w\n    have z : m \u226b g = p \u226b g := w.trans hp\u2082.symm\n    apply t.hom_ext\n    apply (PullbackCone.mk f g comm).equalizer_ext\n    \u00b7 erw [\u2190 cancel_mono h, Category.assoc, Category.assoc, comm]\n      simp only [\u2190 Category.assoc, eq_whisker z]\n    \u00b7 exact z", "start": [93, 1], "end": [121, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.regularOfIsPullbackFstOfRegular", "code": "def regularOfIsPullbackFstOfRegular {P Q R S : C} {f : P \u27f6 Q} {g : P \u27f6 R} {h : Q \u27f6 S} {k : R \u27f6 S}\n    [RegularMono k] (comm : f \u226b h = g \u226b k) (t : IsLimit (PullbackCone.mk _ _ comm)) :\n    RegularMono f :=\n  regularOfIsPullbackSndOfRegular comm.symm (PullbackCone.flipIsLimit t)", "start": [124, 1], "end": [132, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.strongMono_of_regularMono", "code": "instance (priority := 100) strongMono_of_regularMono (f : X \u27f6 Y) [RegularMono f] : StrongMono f :=\n  StrongMono.mk' (by\n      intro A B z hz u v sq\n      have : v \u226b (RegularMono.left : Y \u27f6 RegularMono.Z f) = v \u226b RegularMono.right := by\n        apply (cancel_epi z).1\n        repeat (rw [\u2190 Category.assoc, \u2190 eq_whisker sq.w])\n        simp only [Category.assoc, RegularMono.w]\n      obtain \u27e8t, ht\u27e9 := RegularMono.lift' _ _ this\n      refine' CommSq.HasLift.mk' \u27e8t, (cancel_mono f).1 _, ht\u27e9\n      simp only [Arrow.mk_hom, Arrow.homMk'_left, Category.assoc, ht, sq.w])", "start": [135, 1], "end": [144, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_of_regularMono_of_epi", "code": "theorem isIso_of_regularMono_of_epi (f : X \u27f6 Y) [RegularMono f] [Epi f] : IsIso f", "start": [147, 1], "end": [149, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.RegularMonoCategory", "code": "class RegularMonoCategory where\n  \n  regularMonoOfMono : \u2200 {X Y : C} (f : X \u27f6 Y) [Mono f], RegularMono f", "start": [156, 1], "end": [159, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.regularMonoOfMono", "code": "def regularMonoOfMono [RegularMonoCategory C] (f : X \u27f6 Y) [Mono f] : RegularMono f :=\n  RegularMonoCategory.regularMonoOfMono _", "start": [164, 1], "end": [167, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.regularMonoCategoryOfSplitMonoCategory", "code": "instance (priority := 100) regularMonoCategoryOfSplitMonoCategory [SplitMonoCategory C] :\n    RegularMonoCategory C where\n  regularMonoOfMono f _ := by\n    haveI := isSplitMono_of_mono f\n    infer_instance", "start": [170, 1], "end": [174, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.strongMonoCategory_of_regularMonoCategory", "code": "instance (priority := 100) strongMonoCategory_of_regularMonoCategory [RegularMonoCategory C] :\n    StrongMonoCategory C where\n  strongMono_of_mono f _ := by\n    haveI := regularMonoOfMono f\n    infer_instance", "start": [177, 1], "end": [181, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.RegularEpi", "code": "class RegularEpi (f : X \u27f6 Y) where\n  \n  W : C \n  (left right : W \u27f6 X)\n  \n  w : left \u226b f = right \u226b f := by aesop_cat\n  \n  isColimit : IsColimit (Cofork.of\u03c0 f w)", "start": [184, 1], "end": [193, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.RegularEpi.epi", "code": "instance (priority := 100) RegularEpi.epi (f : X \u27f6 Y) [RegularEpi f] : Epi f :=\n  epi_of_isColimit_cofork RegularEpi.isColimit", "start": [198, 1], "end": [200, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coequalizerRegular", "code": "instance coequalizerRegular (g h : X \u27f6 Y) [HasColimit (parallelPair g h)] :\n    RegularEpi (coequalizer.\u03c0 g h) where\n  W := X\n  left := g\n  right := h\n  w := coequalizer.condition g h\n  isColimit :=\n    Cofork.IsColimit.mk _ (fun s => colimit.desc _ s) (by simp) fun s m w => by\n      apply coequalizer.hom_ext\n      simp [\u2190 w]", "start": [203, 1], "end": [212, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.RegularEpi.ofSplitEpi", "code": "instance (priority := 100) RegularEpi.ofSplitEpi (f : X \u27f6 Y) [IsSplitEpi f] : RegularEpi f\n    where\n  W := X\n  left := \ud835\udfd9 X\n  right := f \u226b section_ f\n  isColimit := isSplitEpiCoequalizes f", "start": [215, 1], "end": [221, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.RegularEpi.desc'", "code": "def RegularEpi.desc' {W : C} (f : X \u27f6 Y) [RegularEpi f] (k : X \u27f6 W)\n    (h : (RegularEpi.left : RegularEpi.W f \u27f6 X) \u226b k = RegularEpi.right \u226b k) :\n    { l : Y \u27f6 W // f \u226b l = k } :=\n  Cofork.IsColimit.desc' RegularEpi.isColimit _ h", "start": [224, 1], "end": [229, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.regularOfIsPushoutSndOfRegular", "code": "def regularOfIsPushoutSndOfRegular {P Q R S : C} {f : P \u27f6 Q} {g : P \u27f6 R} {h : Q \u27f6 S} {k : R \u27f6 S}\n    [gr : RegularEpi g] (comm : f \u226b h = g \u226b k) (t : IsColimit (PushoutCocone.mk _ _ comm)) :\n    RegularEpi h where\n  W := gr.W\n  left := gr.left \u226b f\n  right := gr.right \u226b f\n  w := by rw [Category.assoc, Category.assoc, comm]; simp only [\u2190 Category.assoc, eq_whisker gr.w]\n  isColimit := by\n    apply Cofork.IsColimit.mk' _ _\n    intro s\n    have l\u2081 : gr.left \u226b f \u226b s.\u03c0 = gr.right \u226b f \u226b s.\u03c0 := by\n      rw [\u2190 Category.assoc, \u2190 Category.assoc, s.condition]\n    obtain \u27e8l, hl\u27e9 := Cofork.IsColimit.desc' gr.isColimit (f \u226b Cofork.\u03c0 s) l\u2081\n    obtain \u27e8p, hp\u2081, _\u27e9 := PushoutCocone.IsColimit.desc' t _ _ hl.symm\n    refine' \u27e8p, hp\u2081, _\u27e9\n    intro m w\n    have z := w.trans hp\u2081.symm\n    apply t.hom_ext\n    apply (PushoutCocone.mk _ _ comm).coequalizer_ext\n    \u00b7 exact z\n    \u00b7 erw [\u2190 cancel_epi g, \u2190 Category.assoc, \u2190 eq_whisker comm]\n      erw [\u2190 Category.assoc, \u2190 eq_whisker comm]\n      dsimp at z; simp only [Category.assoc, z]", "start": [232, 1], "end": [259, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.regularOfIsPushoutFstOfRegular", "code": "def regularOfIsPushoutFstOfRegular {P Q R S : C} {f : P \u27f6 Q} {g : P \u27f6 R} {h : Q \u27f6 S} {k : R \u27f6 S}\n    [RegularEpi f] (comm : f \u226b h = g \u226b k) (t : IsColimit (PushoutCocone.mk _ _ comm)) :\n    RegularEpi k :=\n  regularOfIsPushoutSndOfRegular comm.symm (PushoutCocone.flipIsColimit t)", "start": [262, 1], "end": [270, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.strongEpi_of_regularEpi", "code": "instance (priority := 100) strongEpi_of_regularEpi (f : X \u27f6 Y) [RegularEpi f] : StrongEpi f :=\n  StrongEpi.mk'\n    (by\n      intro A B z hz u v sq\n      have : (RegularEpi.left : RegularEpi.W f \u27f6 X) \u226b u = RegularEpi.right \u226b u := by\n        apply (cancel_mono z).1\n        simp only [Category.assoc, sq.w, RegularEpi.w_assoc]\n      obtain \u27e8t, ht\u27e9 := RegularEpi.desc' f u this\n      exact\n        CommSq.HasLift.mk'\n          \u27e8t, ht,\n            (cancel_epi f).1\n              (by simp only [\u2190 Category.assoc, ht, \u2190 sq.w, Arrow.mk_hom, Arrow.homMk'_right])\u27e9)", "start": [273, 1], "end": [285, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_of_regularEpi_of_mono", "code": "theorem isIso_of_regularEpi_of_mono (f : X \u27f6 Y) [RegularEpi f] [Mono f] : IsIso f", "start": [288, 1], "end": [290, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.RegularEpiCategory", "code": "class RegularEpiCategory where\n  \n  regularEpiOfEpi : \u2200 {X Y : C} (f : X \u27f6 Y) [Epi f], RegularEpi f", "start": [297, 1], "end": [300, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.regularEpiOfEpi", "code": "def regularEpiOfEpi [RegularEpiCategory C] (f : X \u27f6 Y) [Epi f] : RegularEpi f :=\n  RegularEpiCategory.regularEpiOfEpi _", "start": [305, 1], "end": [308, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.regularEpiCategoryOfSplitEpiCategory", "code": "instance (priority := 100) regularEpiCategoryOfSplitEpiCategory [SplitEpiCategory C] :\n    RegularEpiCategory C where\n  regularEpiOfEpi f _ := by\n    haveI := isSplitEpi_of_epi f\n    infer_instance", "start": [311, 1], "end": [315, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.strongEpiCategory_of_regularEpiCategory", "code": "instance (priority := 100) strongEpiCategory_of_regularEpiCategory [RegularEpiCategory C] :\n    StrongEpiCategory C where\n  strongEpi_of_epi f _ := by\n    haveI := regularEpiOfEpi f\n    infer_instance", "start": [318, 1], "end": [322, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Subobject/Basic.lean", "imports": ["Mathlib/CategoryTheory/Subobject/MonoOver.lean", "Mathlib/CategoryTheory/Skeletal.lean", "Mathlib/CategoryTheory/ConcreteCategory/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/ApplyFun.lean", "Mathlib/Tactic/CategoryTheory/Elementwise.lean"], "premises": [{"full_name": "CategoryTheory.Subobject", "code": "def Subobject (X : C) :=\n  ThinSkeleton (MonoOver X)", "start": [96, 1], "end": [99, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.mk", "code": "def mk {X A : C} (f : A \u27f6 X) [Mono f] : Subobject X :=\n  (toThinSkeleton _).obj (MonoOver.mk' f)", "start": [110, 1], "end": [112, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ind", "code": "protected theorem ind {X : C} (p : Subobject X \u2192 Prop)\n    (h : \u2200 \u2983A : C\u2984 (f : A \u27f6 X) [Mono f], p (Subobject.mk f)) (P : Subobject X) : p P", "start": [119, 1], "end": [123, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ind\u2082", "code": "protected theorem ind\u2082 {X : C} (p : Subobject X \u2192 Subobject X \u2192 Prop)\n    (h : \u2200 \u2983A B : C\u2984 (f : A \u27f6 X) (g : B \u27f6 X) [Mono f] [Mono g],\n      p (Subobject.mk f) (Subobject.mk g))\n    (P Q : Subobject X) : p P Q", "start": [126, 1], "end": [132, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.lift", "code": "protected def lift {\u03b1 : Sort*} {X : C} (F : \u2200 \u2983A : C\u2984 (f : A \u27f6 X) [Mono f], \u03b1)\n    (h :\n      \u2200 \u2983A B : C\u2984 (f : A \u27f6 X) (g : B \u27f6 X) [Mono f] [Mono g] (i : A \u2245 B),\n        i.hom \u226b g = f \u2192 F f = F g) :\n    Subobject X \u2192 \u03b1 := fun P =>\n  Quotient.liftOn' P (fun m => F m.arrow) fun m n \u27e8i\u27e9 =>\n    h m.arrow n.arrow ((MonoOver.forget X \u22d9 Over.forget X).mapIso i) (Over.w i.hom)", "start": [137, 1], "end": [145, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.lift_mk", "code": "@[simp]\nprotected theorem lift_mk {\u03b1 : Sort*} {X : C} (F : \u2200 \u2983A : C\u2984 (f : A \u27f6 X) [Mono f], \u03b1) {h A}\n    (f : A \u27f6 X) [Mono f] : Subobject.lift F h (Subobject.mk f) = F f", "start": [148, 1], "end": [151, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.equivMonoOver", "code": "noncomputable def equivMonoOver (X : C) : Subobject X \u224c MonoOver X :=\n  ThinSkeleton.equivalence _", "start": [154, 1], "end": [158, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.representative", "code": "noncomputable def representative {X : C} : Subobject X \u2964 MonoOver X :=\n  (equivMonoOver X).functor", "start": [161, 1], "end": [164, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.representativeIso", "code": "noncomputable def representativeIso {X : C} (A : MonoOver X) :\n    representative.obj ((toThinSkeleton _).obj A) \u2245 A :=\n  (equivMonoOver X).counitIso.app A", "start": [167, 1], "end": [173, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.underlying", "code": "noncomputable def underlying {X : C} : Subobject X \u2964 C :=\n  representative \u22d9 MonoOver.forget _ \u22d9 Over.forget _", "start": [176, 1], "end": [181, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.underlyingIso", "code": "noncomputable def underlyingIso {X Y : C} (f : X \u27f6 Y) [Mono f] : (Subobject.mk f : C) \u2245 X :=\n  (MonoOver.forget _ \u22d9 Over.forget _).mapIso (representativeIso (MonoOver.mk' f))", "start": [192, 1], "end": [197, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.arrow", "code": "noncomputable def arrow {X : C} (Y : Subobject X) : (Y : C) \u27f6 X :=\n  (representative.obj Y).obj.hom", "start": [200, 1], "end": [203, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.arrow_mono", "code": "instance arrow_mono {X : C} (Y : Subobject X) : Mono Y.arrow :=\n  (representative.obj Y).property", "start": [206, 1], "end": [207, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.arrow_congr", "code": "@[simp]\ntheorem arrow_congr {A : C} (X Y : Subobject A) (h : X = Y) :\n    eqToHom (congr_arg (fun X : Subobject A => (X : C)) h) \u226b Y.arrow = X.arrow", "start": [210, 1], "end": [214, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.representative_coe", "code": "@[simp]\ntheorem representative_coe (Y : Subobject X) : (representative.obj Y : C) = (Y : C)", "start": [217, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.representative_arrow", "code": "@[simp]\ntheorem representative_arrow (Y : Subobject X) : (representative.obj Y).arrow = Y.arrow", "start": [222, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.underlying_arrow", "code": "@[reassoc (attr := simp)]\ntheorem underlying_arrow {X : C} {Y Z : Subobject X} (f : Y \u27f6 Z) :\n    underlying.map f \u226b arrow Z = arrow Y", "start": [227, 1], "end": [230, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.underlyingIso_arrow", "code": "@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem underlyingIso_arrow {X Y : C} (f : X \u27f6 Y) [Mono f] :\n    (underlyingIso f).inv \u226b (Subobject.mk f).arrow = f", "start": [233, 1], "end": [236, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.underlyingIso_hom_comp_eq_mk", "code": "@[reassoc (attr := simp)]\ntheorem underlyingIso_hom_comp_eq_mk {X Y : C} (f : X \u27f6 Y) [Mono f] :\n    (underlyingIso f).hom \u226b f = (mk f).arrow", "start": [239, 1], "end": [242, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.eq_of_comp_arrow_eq", "code": "@[ext]\ntheorem eq_of_comp_arrow_eq {X Y : C} {P : Subobject Y} {f g : X \u27f6 P}\n    (h : f \u226b P.arrow = g \u226b P.arrow) : f = g", "start": [245, 1], "end": [250, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.mk_le_mk_of_comm", "code": "theorem mk_le_mk_of_comm {B A\u2081 A\u2082 : C} {f\u2081 : A\u2081 \u27f6 B} {f\u2082 : A\u2082 \u27f6 B} [Mono f\u2081] [Mono f\u2082] (g : A\u2081 \u27f6 A\u2082)\n    (w : g \u226b f\u2082 = f\u2081) : mk f\u2081 \u2264 mk f\u2082", "start": [253, 1], "end": [255, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.mk_arrow", "code": "@[simp]\ntheorem mk_arrow (P : Subobject X) : mk P.arrow = P", "start": [258, 1], "end": [262, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.le_of_comm", "code": "theorem le_of_comm {B : C} {X Y : Subobject B} (f : (X : C) \u27f6 (Y : C)) (w : f \u226b Y.arrow = X.arrow) :\n    X \u2264 Y", "start": [265, 1], "end": [267, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.le_mk_of_comm", "code": "theorem le_mk_of_comm {B A : C} {X : Subobject B} {f : A \u27f6 B} [Mono f] (g : (X : C) \u27f6 A)\n    (w : g \u226b f = X.arrow) : X \u2264 mk f", "start": [270, 1], "end": [272, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.mk_le_of_comm", "code": "theorem mk_le_of_comm {B A : C} {X : Subobject B} {f : A \u27f6 B} [Mono f] (g : A \u27f6 (X : C))\n    (w : g \u226b X.arrow = f) : mk f \u2264 X", "start": [275, 1], "end": [277, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.eq_of_comm", "code": "@[ext]\ntheorem eq_of_comm {B : C} {X Y : Subobject B} (f : (X : C) \u2245 (Y : C))\n    (w : f.hom \u226b Y.arrow = X.arrow) : X = Y", "start": [280, 1], "end": [285, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.eq_mk_of_comm", "code": "theorem eq_mk_of_comm {B A : C} {X : Subobject B} (f : A \u27f6 B) [Mono f] (i : (X : C) \u2245 A)\n    (w : i.hom \u226b f = X.arrow) : X = mk f", "start": [289, 1], "end": [293, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.mk_eq_of_comm", "code": "theorem mk_eq_of_comm {B A : C} {X : Subobject B} (f : A \u27f6 B) [Mono f] (i : A \u2245 (X : C))\n    (w : i.hom \u226b X.arrow = f) : mk f = X", "start": [297, 1], "end": [301, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.mk_eq_mk_of_comm", "code": "theorem mk_eq_mk_of_comm {B A\u2081 A\u2082 : C} (f : A\u2081 \u27f6 B) (g : A\u2082 \u27f6 B) [Mono f] [Mono g] (i : A\u2081 \u2245 A\u2082)\n    (w : i.hom \u226b g = f) : mk f = mk g", "start": [305, 1], "end": [309, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofLE", "code": "def ofLE {B : C} (X Y : Subobject B) (h : X \u2264 Y) : (X : C) \u27f6 (Y : C) :=\n  underlying.map <| h.hom", "start": [315, 1], "end": [317, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofLE_arrow", "code": "@[reassoc (attr := simp)]\ntheorem ofLE_arrow {B : C} {X Y : Subobject B} (h : X \u2264 Y) : ofLE X Y h \u226b Y.arrow = X.arrow", "start": [320, 1], "end": [322, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofLE_mk_le_mk_of_comm", "code": "theorem ofLE_mk_le_mk_of_comm {B A\u2081 A\u2082 : C} {f\u2081 : A\u2081 \u27f6 B} {f\u2082 : A\u2082 \u27f6 B} [Mono f\u2081] [Mono f\u2082]\n    (g : A\u2081 \u27f6 A\u2082) (w : g \u226b f\u2082 = f\u2081) :\n    ofLE _ _ (mk_le_mk_of_comm g w) = (underlyingIso _).hom \u226b g \u226b (underlyingIso _).inv", "start": [332, 1], "end": [336, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofLEMk", "code": "def ofLEMk {B A : C} (X : Subobject B) (f : A \u27f6 B) [Mono f] (h : X \u2264 mk f) : (X : C) \u27f6 A :=\n  ofLE X (mk f) h \u226b (underlyingIso f).hom", "start": [339, 1], "end": [341, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofLEMk_comp", "code": "@[simp]\ntheorem ofLEMk_comp {B A : C} {X : Subobject B} {f : A \u27f6 B} [Mono f] (h : X \u2264 mk f) :\n    ofLEMk X f h \u226b f = X.arrow", "start": [349, 1], "end": [351, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofMkLE", "code": "def ofMkLE {B A : C} (f : A \u27f6 B) [Mono f] (X : Subobject B) (h : mk f \u2264 X) : A \u27f6 (X : C) :=\n  (underlyingIso f).inv \u226b ofLE (mk f) X h", "start": [354, 1], "end": [356, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofMkLE_arrow", "code": "@[simp]\ntheorem ofMkLE_arrow {B A : C} {f : A \u27f6 B} [Mono f] {X : Subobject B} (h : mk f \u2264 X) :\n    ofMkLE f X h \u226b X.arrow = f", "start": [364, 1], "end": [366, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofMkLEMk", "code": "def ofMkLEMk {B A\u2081 A\u2082 : C} (f : A\u2081 \u27f6 B) (g : A\u2082 \u27f6 B) [Mono f] [Mono g] (h : mk f \u2264 mk g) :\n    A\u2081 \u27f6 A\u2082 :=\n  (underlyingIso f).inv \u226b ofLE (mk f) (mk g) h \u226b (underlyingIso g).hom", "start": [369, 1], "end": [372, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofMkLEMk_comp", "code": "@[simp]\ntheorem ofMkLEMk_comp {B A\u2081 A\u2082 : C} {f : A\u2081 \u27f6 B} {g : A\u2082 \u27f6 B} [Mono f] [Mono g] (h : mk f \u2264 mk g) :\n    ofMkLEMk f g h \u226b g = f", "start": [380, 1], "end": [382, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofLE_comp_ofLE", "code": "@[reassoc (attr := simp)]\ntheorem ofLE_comp_ofLE {B : C} (X Y Z : Subobject B) (h\u2081 : X \u2264 Y) (h\u2082 : Y \u2264 Z) :\n    ofLE X Y h\u2081 \u226b ofLE Y Z h\u2082 = ofLE X Z (h\u2081.trans h\u2082)", "start": [385, 1], "end": [389, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofLE_comp_ofLEMk", "code": "@[reassoc (attr := simp)]\ntheorem ofLE_comp_ofLEMk {B A : C} (X Y : Subobject B) (f : A \u27f6 B) [Mono f] (h\u2081 : X \u2264 Y)\n    (h\u2082 : Y \u2264 mk f) : ofLE X Y h\u2081 \u226b ofLEMk Y f h\u2082 = ofLEMk X f (h\u2081.trans h\u2082)", "start": [392, 1], "end": [396, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofLEMk_comp_ofMkLE", "code": "@[reassoc (attr := simp)]\ntheorem ofLEMk_comp_ofMkLE {B A : C} (X : Subobject B) (f : A \u27f6 B) [Mono f] (Y : Subobject B)\n    (h\u2081 : X \u2264 mk f) (h\u2082 : mk f \u2264 Y) : ofLEMk X f h\u2081 \u226b ofMkLE f Y h\u2082 = ofLE X Y (h\u2081.trans h\u2082)", "start": [399, 1], "end": [403, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofLEMk_comp_ofMkLEMk", "code": "@[reassoc (attr := simp)]\ntheorem ofLEMk_comp_ofMkLEMk {B A\u2081 A\u2082 : C} (X : Subobject B) (f : A\u2081 \u27f6 B) [Mono f] (g : A\u2082 \u27f6 B)\n    [Mono g] (h\u2081 : X \u2264 mk f) (h\u2082 : mk f \u2264 mk g) :\n    ofLEMk X f h\u2081 \u226b ofMkLEMk f g h\u2082 = ofLEMk X g (h\u2081.trans h\u2082)", "start": [406, 1], "end": [412, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofMkLE_comp_ofLE", "code": "@[reassoc (attr := simp)]\ntheorem ofMkLE_comp_ofLE {B A\u2081 : C} (f : A\u2081 \u27f6 B) [Mono f] (X Y : Subobject B) (h\u2081 : mk f \u2264 X)\n    (h\u2082 : X \u2264 Y) : ofMkLE f X h\u2081 \u226b ofLE X Y h\u2082 = ofMkLE f Y (h\u2081.trans h\u2082)", "start": [415, 1], "end": [420, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofMkLE_comp_ofLEMk", "code": "@[reassoc (attr := simp)]\ntheorem ofMkLE_comp_ofLEMk {B A\u2081 A\u2082 : C} (f : A\u2081 \u27f6 B) [Mono f] (X : Subobject B) (g : A\u2082 \u27f6 B)\n    [Mono g] (h\u2081 : mk f \u2264 X) (h\u2082 : X \u2264 mk g) :\n    ofMkLE f X h\u2081 \u226b ofLEMk X g h\u2082 = ofMkLEMk f g (h\u2081.trans h\u2082)", "start": [423, 1], "end": [428, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLE", "code": "@[reassoc (attr := simp)]\ntheorem ofMkLEMk_comp_ofMkLE {B A\u2081 A\u2082 : C} (f : A\u2081 \u27f6 B) [Mono f] (g : A\u2082 \u27f6 B) [Mono g]\n    (X : Subobject B) (h\u2081 : mk f \u2264 mk g) (h\u2082 : mk g \u2264 X) :\n    ofMkLEMk f g h\u2081 \u226b ofMkLE g X h\u2082 = ofMkLE f X (h\u2081.trans h\u2082)", "start": [431, 1], "end": [437, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofMkLEMk_comp_ofMkLEMk", "code": "@[reassoc (attr := simp)]\ntheorem ofMkLEMk_comp_ofMkLEMk {B A\u2081 A\u2082 A\u2083 : C} (f : A\u2081 \u27f6 B) [Mono f] (g : A\u2082 \u27f6 B) [Mono g]\n    (h : A\u2083 \u27f6 B) [Mono h] (h\u2081 : mk f \u2264 mk g) (h\u2082 : mk g \u2264 mk h) :\n    ofMkLEMk f g h\u2081 \u226b ofMkLEMk g h h\u2082 = ofMkLEMk f h (h\u2081.trans h\u2082)", "start": [440, 1], "end": [446, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofLE_refl", "code": "@[simp]\ntheorem ofLE_refl {B : C} (X : Subobject B) : ofLE X X le_rfl = \ud835\udfd9 _", "start": [449, 1], "end": [452, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.ofMkLEMk_refl", "code": "@[simp]\ntheorem ofMkLEMk_refl {B A\u2081 : C} (f : A\u2081 \u27f6 B) [Mono f] : ofMkLEMk f f le_rfl = \ud835\udfd9 _", "start": [455, 1], "end": [458, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.isoOfEq", "code": "@[simps]\ndef isoOfEq {B : C} (X Y : Subobject B) (h : X = Y) : (X : C) \u2245 (Y : C) where\n  hom := ofLE _ _ h.le\n  inv := ofLE _ _ h.ge", "start": [462, 1], "end": [467, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.isoOfEqMk", "code": "@[simps]\ndef isoOfEqMk {B A : C} (X : Subobject B) (f : A \u27f6 B) [Mono f] (h : X = mk f) : (X : C) \u2245 A where\n  hom := ofLEMk X f h.le\n  inv := ofMkLE f X h.ge", "start": [470, 1], "end": [474, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.isoOfMkEq", "code": "@[simps]\ndef isoOfMkEq {B A : C} (f : A \u27f6 B) [Mono f] (X : Subobject B) (h : mk f = X) : A \u2245 (X : C) where\n  hom := ofMkLE f X h.le\n  inv := ofLEMk X f h.ge", "start": [477, 1], "end": [481, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.isoOfMkEqMk", "code": "@[simps]\ndef isoOfMkEqMk {B A\u2081 A\u2082 : C} (f : A\u2081 \u27f6 B) (g : A\u2082 \u27f6 B) [Mono f] [Mono g] (h : mk f = mk g) :\n    A\u2081 \u2245 A\u2082 where\n  hom := ofMkLEMk f g h.le\n  inv := ofMkLEMk g f h.ge", "start": [484, 1], "end": [489, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.lower", "code": "def lower {Y : D} (F : MonoOver X \u2964 MonoOver Y) : Subobject X \u2964 Subobject Y :=\n  ThinSkeleton.map F", "start": [498, 1], "end": [501, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.lower_iso", "code": "theorem lower_iso (F\u2081 F\u2082 : MonoOver X \u2964 MonoOver Y) (h : F\u2081 \u2245 F\u2082) : lower F\u2081 = lower F\u2082", "start": [504, 1], "end": [508, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.lower\u2082", "code": "def lower\u2082 (F : MonoOver X \u2964 MonoOver Y \u2964 MonoOver Z) : Subobject X \u2964 Subobject Y \u2964 Subobject Z :=\n  ThinSkeleton.map\u2082 F", "start": [511, 1], "end": [513, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.lower_comm", "code": "@[simp]\ntheorem lower_comm (F : MonoOver Y \u2964 MonoOver X) :\n    toThinSkeleton _ \u22d9 lower F = F \u22d9 toThinSkeleton _", "start": [516, 1], "end": [519, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.lowerAdjunction", "code": "def lowerAdjunction {A : C} {B : D} {L : MonoOver A \u2964 MonoOver B} {R : MonoOver B \u2964 MonoOver A}\n    (h : L \u22a3 R) : lower L \u22a3 lower R :=\n  ThinSkeleton.lowerAdjunction _ _ h", "start": [522, 1], "end": [526, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.lowerEquivalence", "code": "@[simps]\ndef lowerEquivalence {A : C} {B : D} (e : MonoOver A \u224c MonoOver B) : Subobject A \u224c Subobject B where\n  functor := lower e.functor\n  inverse := lower e.inverse\n  unitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.unitIso\n    \u00b7 exact ThinSkeleton.map_id_eq.symm\n    \u00b7 exact (ThinSkeleton.map_comp_eq _ _).symm\n  counitIso := by\n    apply eqToIso\n    convert ThinSkeleton.map_iso_eq e.counitIso\n    \u00b7 exact (ThinSkeleton.map_comp_eq _ _).symm\n    \u00b7 exact ThinSkeleton.map_id_eq.symm", "start": [529, 1], "end": [544, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.pullback", "code": "def pullback (f : X \u27f6 Y) : Subobject Y \u2964 Subobject X :=\n  lower (MonoOver.pullback f)", "start": [551, 1], "end": [554, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.pullback_id", "code": "theorem pullback_id (x : Subobject X) : (pullback (\ud835\udfd9 X)).obj x = x", "start": [557, 1], "end": [559, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.pullback_comp", "code": "theorem pullback_comp (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : Subobject Z) :\n    (pullback (f \u226b g)).obj x = (pullback f).obj ((pullback g).obj x)", "start": [562, 1], "end": [565, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.map", "code": "def map (f : X \u27f6 Y) [Mono f] : Subobject X \u2964 Subobject Y :=\n  lower (MonoOver.map f)", "start": [574, 1], "end": [578, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.map_id", "code": "theorem map_id (x : Subobject X) : (map (\ud835\udfd9 X)).obj x = x", "start": [581, 1], "end": [583, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.map_comp", "code": "theorem map_comp (f : X \u27f6 Y) (g : Y \u27f6 Z) [Mono f] [Mono g] (x : Subobject X) :\n    (map (f \u226b g)).obj x = (map g).obj ((map f).obj x)", "start": [586, 1], "end": [589, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.mapIso", "code": "def mapIso {A B : C} (e : A \u2245 B) : Subobject A \u224c Subobject B :=\n  lowerEquivalence (MonoOver.mapIso e)", "start": [592, 1], "end": [594, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.mapIsoToOrderIso", "code": "def mapIsoToOrderIso (e : X \u2245 Y) : Subobject X \u2243o Subobject Y where\n  toFun := (map e.hom).obj\n  invFun := (map e.inv).obj\n  left_inv g := by simp_rw [\u2190 map_comp, e.hom_inv_id, map_id]\n  right_inv g := by simp_rw [\u2190 map_comp, e.inv_hom_id, map_id]\n  map_rel_iff' {A B} := by\n    dsimp\n    constructor\n    \u00b7 intro h\n      apply_fun (map e.inv).obj at h\n      \u00b7 simpa only [\u2190 map_comp, e.hom_inv_id, map_id] using h\n      \u00b7 apply Functor.monotone\n    \u00b7 intro h\n      apply_fun (map e.hom).obj at h\n      \u00b7 exact h\n      \u00b7 apply Functor.monotone", "start": [600, 1], "end": [617, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.mapIsoToOrderIso_apply", "code": "@[simp]\ntheorem mapIsoToOrderIso_apply (e : X \u2245 Y) (P : Subobject X) :\n    mapIsoToOrderIso e P = (map e.hom).obj P", "start": [620, 1], "end": [623, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.mapIsoToOrderIso_symm_apply", "code": "@[simp]\ntheorem mapIsoToOrderIso_symm_apply (e : X \u2245 Y) (Q : Subobject Y) :\n    (mapIsoToOrderIso e).symm Q = (map e.inv).obj Q", "start": [626, 1], "end": [629, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.mapPullbackAdj", "code": "def mapPullbackAdj [HasPullbacks C] (f : X \u27f6 Y) [Mono f] : map f \u22a3 pullback f :=\n  lowerAdjunction (MonoOver.mapPullbackAdj f)", "start": [632, 1], "end": [635, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.pullback_map_self", "code": "@[simp]\ntheorem pullback_map_self [HasPullbacks C] (f : X \u27f6 Y) [Mono f] (g : Subobject X) :\n    (pullback f).obj ((map f).obj g) = g", "start": [638, 1], "end": [642, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.map_pullback", "code": "theorem map_pullback [HasPullbacks C] {X Y Z W : C} {f : X \u27f6 Y} {g : X \u27f6 Z} {h : Y \u27f6 W} {k : Z \u27f6 W}\n    [Mono h] [Mono g] (comm : f \u226b h = g \u226b k) (t : IsLimit (PullbackCone.mk f g comm))\n    (p : Subobject Y) : (map g).obj ((pullback f).obj p) = (pullback k).obj ((map h).obj p)", "start": [645, 1], "end": [663, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.exists", "code": "def \u00abexists\u00bb (f : X \u27f6 Y) : Subobject X \u2964 Subobject Y :=\n  lower (MonoOver.exists f)", "start": [672, 1], "end": [681, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.exists_iso_map", "code": "theorem exists_iso_map (f : X \u27f6 Y) [Mono f] : \u00abexists\u00bb f = map f", "start": [684, 1], "end": [687, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.existsPullbackAdj", "code": "def existsPullbackAdj (f : X \u27f6 Y) [HasPullbacks C] : \u00abexists\u00bb f \u22a3 pullback f :=\n  lowerAdjunction (MonoOver.existsPullbackAdj f)", "start": [690, 1], "end": [694, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/NaturalTransformation.lean", "imports": ["Mathlib/CategoryTheory/FullSubcategory.lean", "Mathlib/CategoryTheory/Monoidal/Functor.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.MonoidalNatTrans", "code": "@[ext]\nstructure MonoidalNatTrans (F G : LaxMonoidalFunctor C D) extends\n  NatTrans F.toFunctor G.toFunctor where\n  \n  unit : F.\u03b5 \u226b app (\ud835\udfd9_ C) = G.\u03b5 := by aesop_cat\n  \n  tensor : \u2200 X Y, F.\u03bc _ _ \u226b app (X \u2297 Y) = (app X \u2297 app Y) \u226b G.\u03bc _ _ := by aesop_cat", "start": [37, 1], "end": [47, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalNatTrans.id", "code": "@[simps!]\ndef id (F : LaxMonoidalFunctor C D) : MonoidalNatTrans F F :=\n  { \ud835\udfd9 F.toFunctor with }", "start": [64, 1], "end": [67, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalNatTrans.vcomp", "code": "@[simps!]\ndef vcomp {F G H : LaxMonoidalFunctor C D} (\u03b1 : MonoidalNatTrans F G) (\u03b2 : MonoidalNatTrans G H) :\n    MonoidalNatTrans F H :=\n  { NatTrans.vcomp \u03b1.toNatTrans \u03b2.toNatTrans with }", "start": [73, 1], "end": [77, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalNatTrans.categoryLaxMonoidalFunctor", "code": "instance categoryLaxMonoidalFunctor : Category (LaxMonoidalFunctor C D) where\n  Hom := MonoidalNatTrans\n  id := id\n  comp \u03b1 \u03b2 := vcomp \u03b1 \u03b2", "start": [80, 1], "end": [83, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalNatTrans.comp_toNatTrans_lax", "code": "@[simp]\ntheorem comp_toNatTrans_lax {F G H : LaxMonoidalFunctor C D} {\u03b1 : F \u27f6 G} {\u03b2 : G \u27f6 H} :\n    (\u03b1 \u226b \u03b2).toNatTrans = @CategoryStruct.comp (C \u2964 D) _ _ _ _ \u03b1.toNatTrans \u03b2.toNatTrans", "start": [86, 1], "end": [89, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalNatTrans.categoryMonoidalFunctor", "code": "instance categoryMonoidalFunctor : Category (MonoidalFunctor C D) :=\n  InducedCategory.category MonoidalFunctor.toLaxMonoidalFunctor", "start": [92, 1], "end": [93, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalNatTrans.ext'", "code": "@[ext]\nlemma ext' {F G : LaxMonoidalFunctor C D} {\u03b1 \u03b2 : F \u27f6 G} (w : \u2200 X : C, \u03b1.app X = \u03b2.app X) : \u03b1 = \u03b2 :=\n  MonoidalNatTrans.ext _ _ (funext w)", "start": [97, 1], "end": [99, 38], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.MonoidalNatTrans.comp_toNatTrans", "code": "@[simp]\ntheorem comp_toNatTrans {F G H : MonoidalFunctor C D} {\u03b1 : F \u27f6 G} {\u03b2 : G \u27f6 H} :\n    (\u03b1 \u226b \u03b2).toNatTrans = @CategoryStruct.comp (C \u2964 D) _ _ _ _ \u03b1.toNatTrans \u03b2.toNatTrans", "start": [101, 1], "end": [104, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalNatTrans.hcomp", "code": "@[simps]\ndef hcomp {F G : LaxMonoidalFunctor C D} {H K : LaxMonoidalFunctor D E} (\u03b1 : MonoidalNatTrans F G)\n    (\u03b2 : MonoidalNatTrans H K) : MonoidalNatTrans (F \u2297\u22d9 H) (G \u2297\u22d9 K) :=\n  { NatTrans.hcomp \u03b1.toNatTrans \u03b2.toNatTrans with\n    unit := by\n      dsimp; simp\n      conv_lhs => rw [\u2190 K.toFunctor.map_comp, \u03b1.unit]\n    tensor := fun X Y => by\n      dsimp; simp\n      conv_lhs => rw [\u2190 K.toFunctor.map_comp, \u03b1.tensor, K.toFunctor.map_comp] }", "start": [109, 1], "end": [119, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalNatTrans.prod", "code": "@[simps]\ndef prod {F G : LaxMonoidalFunctor C D} {H K : LaxMonoidalFunctor C E} (\u03b1 : MonoidalNatTrans F G)\n    (\u03b2 : MonoidalNatTrans H K) : MonoidalNatTrans (F.prod' H) (G.prod' K) where\n  app X := (\u03b1.app X, \u03b2.app X)", "start": [126, 1], "end": [130, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalNatIso.ofComponents", "code": "def ofComponents (app : \u2200 X : C, F.obj X \u2245 G.obj X)\n    (naturality' : \u2200 {X Y : C} (f : X \u27f6 Y), F.map f \u226b (app Y).hom = (app X).hom \u226b G.map f)\n    (unit' : F.\u03b5 \u226b (app (\ud835\udfd9_ C)).hom = G.\u03b5)\n    (tensor' : \u2200 X Y, F.\u03bc X Y \u226b (app (X \u2297 Y)).hom = ((app X).hom \u2297 (app Y).hom) \u226b G.\u03bc X Y) :\n    F \u2245 G where\n  hom := { app := fun X => (app X).hom }\n  inv := {\n    (NatIso.ofComponents app @naturality').inv with\n    app := fun X => (app X).inv\n    unit := by\n      dsimp\n      rw [\u2190 unit', assoc, Iso.hom_inv_id, comp_id]\n    tensor := fun X Y => by\n      dsimp\n      rw [Iso.comp_inv_eq, assoc, tensor', \u2190 tensor_comp_assoc,\n        Iso.inv_hom_id, Iso.inv_hom_id, tensor_id, id_comp] }", "start": [141, 1], "end": [158, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalNatIso.ofComponents.hom_app", "code": "@[simp]\ntheorem ofComponents.hom_app (app : \u2200 X : C, F.obj X \u2245 G.obj X) (naturality) (unit) (tensor) (X) :\n    (ofComponents app naturality unit tensor).hom.app X = (app X).hom", "start": [161, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalNatIso.ofComponents.inv_app", "code": "@[simp]\ntheorem ofComponents.inv_app (app : \u2200 X : C, F.obj X \u2245 G.obj X) (naturality) (unit) (tensor) (X) :\n    (ofComponents app naturality unit tensor).inv.app X = (app X).inv", "start": [167, 1], "end": [169, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalNatIso.isIso_of_isIso_app", "code": "instance isIso_of_isIso_app (\u03b1 : F \u27f6 G) [\u2200 X : C, IsIso (\u03b1.app X)] : IsIso \u03b1 :=\n  \u27e8(IsIso.of_iso\n        (ofComponents (fun X => asIso (\u03b1.app X)) (fun f => \u03b1.toNatTrans.naturality f) \u03b1.unit\n          \u03b1.tensor)).1\u27e9", "start": [172, 1], "end": [175, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalUnit", "code": "@[simps! toNatTrans] def monoidalUnit (F : MonoidalFunctor C D) [IsEquivalence F.toFunctor] :\n    LaxMonoidalFunctor.id C \u27f6 F.toLaxMonoidalFunctor \u2297\u22d9 (monoidalInverse F).toLaxMonoidalFunctor :=\n  let e := F.toFunctor.asEquivalence\n  { toNatTrans := e.unit\n    tensor := fun X Y => by\n      dsimp\n      simp only [Adjunction.homEquiv_unit, Adjunction.homEquiv_naturality_right,\n        id_comp, assoc]\n      simp only [\u2190 Functor.map_comp, assoc]\n      erw [e.counit_app_functor, e.counit_app_functor,\n        F.toLaxMonoidalFunctor.\u03bc_natural, IsIso.inv_hom_id_assoc]\n      simp only [CategoryTheory.IsEquivalence.inv_fun_map]\n      slice_rhs 2 3 => erw [Iso.hom_inv_id_app]\n      dsimp\n      simp only [CategoryTheory.Category.id_comp]\n      slice_rhs 1 2 =>\n        rw [\u2190 tensor_comp, Iso.hom_inv_id_app, Iso.hom_inv_id_app]\n        dsimp\n        rw [tensor_id]\n      simp }", "start": [182, 1], "end": [204, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalCounit", "code": "@[simps! toNatTrans] def monoidalCounit (F : MonoidalFunctor C D) [IsEquivalence F.toFunctor] :\n    (monoidalInverse F).toLaxMonoidalFunctor \u2297\u22d9 F.toLaxMonoidalFunctor \u27f6 LaxMonoidalFunctor.id D :=\n  let e := F.toFunctor.asEquivalence\n  { toNatTrans := e.counit\n    unit := by\n      dsimp\n      simp only [comp_id, assoc, Functor.map_inv, Functor.map_comp,\n        NatIso.inv_inv_app, IsIso.inv_comp, IsEquivalence.fun_inv_map, Adjunction.homEquiv_unit]\n      erw [e.counit_app_functor, \u2190 e.functor.map_comp_assoc, Iso.hom_inv_id_app]\n      dsimp; simp\n    tensor := fun X Y => by\n      dsimp\n      simp only [Adjunction.homEquiv_unit, Adjunction.homEquiv_naturality_right, assoc,\n        comp_id, Functor.map_comp]\n      simp only [IsEquivalence.fun_inv_map]\n      erw [e.counit_app_functor]\n      simp only [assoc]\n      erw [\u2190 e.functor.map_comp_assoc]\n      simp only [CategoryTheory.Iso.inv_hom_id_app, CategoryTheory.Iso.inv_hom_id_app_assoc]\n      erw [Iso.hom_inv_id_app, CategoryTheory.Functor.map_id]\n      simp only [id_comp, CategoryTheory.Iso.inv_hom_id_app,\n        CategoryTheory.IsIso.hom_inv_id_assoc]\n      erw [comp_id] }", "start": [212, 1], "end": [236, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Category/Preord.lean", "imports": ["Mathlib/CategoryTheory/Category/Cat.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Category/Preorder.lean", "Mathlib/Order/Hom/Basic.lean", "Mathlib/CategoryTheory/ConcreteCategory/BundledHom.lean"], "premises": [{"full_name": "Preord", "code": "def Preord :=\n  Bundled Preorder", "start": [24, 1], "end": [26, 19], "kind": "commanddeclaration"}, {"full_name": "Preord.of", "code": "def of (\u03b1 : Type*) [Preorder \u03b1] : Preord :=\n  Bundled.of \u03b1", "start": [47, 1], "end": [49, 15], "kind": "commanddeclaration"}, {"full_name": "Preord.coe_of", "code": "@[simp]\ntheorem coe_of (\u03b1 : Type*) [Preorder \u03b1] : \u21a5(of \u03b1) = \u03b1", "start": [53, 1], "end": [55, 6], "kind": "commanddeclaration"}, {"full_name": "Preord.Iso.mk", "code": "@[simps]\ndef Iso.mk {\u03b1 \u03b2 : Preord.{u}} (e : \u03b1 \u2243o \u03b2) : \u03b1 \u2245 \u03b2 where\n  hom := (e : OrderHom \u03b1 \u03b2)\n  inv := (e.symm : OrderHom \u03b2 \u03b1)\n  hom_inv_id := by\n    ext x\n    exact e.symm_apply_apply x\n  inv_hom_id := by\n    ext x\n    exact e.apply_symm_apply x", "start": [65, 1], "end": [75, 31], "kind": "commanddeclaration"}, {"full_name": "Preord.dual", "code": "@[simps]\ndef dual : Preord \u2964 Preord where\n  obj X := of X\u1d52\u1d48\n  map := OrderHom.dual", "start": [79, 1], "end": [83, 23], "kind": "commanddeclaration"}, {"full_name": "Preord.dualEquiv", "code": "@[simps functor inverse]\ndef dualEquiv : Preord \u224c Preord where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X", "start": [87, 1], "end": [93, 74], "kind": "commanddeclaration"}, {"full_name": "preordToCat", "code": "@[simps]\ndef preordToCat : Preord.{u} \u2964 Cat where\n  obj X := Cat.of X.1\n  map f := f.monotone.functor", "start": [99, 1], "end": [104, 30], "kind": "commanddeclaration"}]}
