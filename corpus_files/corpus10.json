{"path": "Mathlib/Data/Matrix/Hadamard.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Trace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.hadamard", "code": "def hadamard [Mul \u03b1] (A : Matrix m n \u03b1) (B : Matrix m n \u03b1) : Matrix m n \u03b1 :=\n  of fun i j => A i j * B i j", "start": [43, 1], "end": [46, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.hadamard_apply", "code": "@[simp]\ntheorem hadamard_apply [Mul \u03b1] (A : Matrix m n \u03b1) (B : Matrix m n \u03b1) (i j) :\n    hadamard A B i j = A i j * B i j", "start": [50, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.hadamard_comm", "code": "theorem hadamard_comm [CommSemigroup \u03b1] : A \u2299 B = B \u2299 A", "start": [64, 1], "end": [65, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.hadamard_assoc", "code": "theorem hadamard_assoc [Semigroup \u03b1] : A \u2299 B \u2299 C = A \u2299 (B \u2299 C)", "start": [69, 1], "end": [70, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.hadamard_add", "code": "theorem hadamard_add [Distrib \u03b1] : A \u2299 (B + C) = A \u2299 B + A \u2299 C", "start": [74, 1], "end": [75, 36], "kind": "commanddeclaration"}, {"full_name": "Matrix.add_hadamard", "code": "theorem add_hadamard [Distrib \u03b1] : (B + C) \u2299 A = B \u2299 A + C \u2299 A", "start": [78, 1], "end": [79, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_hadamard", "code": "@[simp]\ntheorem smul_hadamard [Mul \u03b1] [SMul R \u03b1] [IsScalarTower R \u03b1 \u03b1] (k : R) : (k \u2022 A) \u2299 B = k \u2022 A \u2299 B", "start": [85, 1], "end": [87, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.hadamard_smul", "code": "@[simp]\ntheorem hadamard_smul [Mul \u03b1] [SMul R \u03b1] [SMulCommClass R \u03b1 \u03b1] (k : R) : A \u2299 (k \u2022 B) = k \u2022 A \u2299 B", "start": [90, 1], "end": [92, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.hadamard_zero", "code": "@[simp]\ntheorem hadamard_zero : A \u2299 (0 : Matrix m n \u03b1) = 0", "start": [101, 1], "end": [103, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.zero_hadamard", "code": "@[simp]\ntheorem zero_hadamard : (0 : Matrix m n \u03b1) \u2299 A = 0", "start": [106, 1], "end": [108, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.hadamard_one", "code": "theorem hadamard_one : M \u2299 (1 : Matrix n n \u03b1) = diagonal fun i => M i i", "start": [119, 1], "end": [121, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_hadamard", "code": "theorem one_hadamard : (1 : Matrix n n \u03b1) \u2299 M = diagonal fun i => M i i", "start": [124, 1], "end": [126, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_hadamard_diagonal", "code": "theorem diagonal_hadamard_diagonal (v : n \u2192 \u03b1) (w : n \u2192 \u03b1) :\n    diagonal v \u2299 diagonal w = diagonal (v * w)", "start": [135, 1], "end": [137, 76], "kind": "commanddeclaration"}, {"full_name": "Matrix.sum_hadamard_eq", "code": "theorem sum_hadamard_eq : (\u2211 i : m, \u2211 j : n, (A \u2299 B) i j) = trace (A * B\u1d40)", "start": [148, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_vecMul_hadamard", "code": "theorem dotProduct_vecMul_hadamard [DecidableEq m] [DecidableEq n] (v : m \u2192 \u03b1) (w : n \u2192 \u03b1) :\n    dotProduct (vecMul v (A \u2299 B)) w = trace (diagonal v * A * (B * diagonal w)\u1d40)", "start": [152, 1], "end": [155, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Array/Lemmas.lean", "imports": ["Mathlib/Data/Fin/Basic.lean", "Mathlib/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Data/Equiv/Functor.lean", "imports": ["Mathlib/Control/Basic.lean", "Mathlib/Logic/Equiv/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Functor.map_equiv", "code": "def map_equiv (h : \u03b1 \u2243 \u03b2) : f \u03b1 \u2243 f \u03b2 where\n  toFun    := map h\n  invFun   := map h.symm\n  left_inv x := by simp [map_map]\n  right_inv x := by simp [map_map]", "start": [29, 1], "end": [34, 35], "kind": "commanddeclaration"}, {"full_name": "Functor.map_equiv_apply", "code": "@[simp]\nlemma map_equiv_apply (h : \u03b1 \u2243 \u03b2) (x : f \u03b1) : (map_equiv f h : f \u03b1 \u2243 f \u03b2) x = map h x := rfl", "start": [36, 1], "end": [37, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Functor.map_equiv_symm_apply", "code": "@[simp]\nlemma map_equiv_symm_apply (h : \u03b1 \u2243 \u03b2) (y : f \u03b2) :\n    (map_equiv f h : f \u03b1 \u2243 f \u03b2).symm y = map h.symm y := rfl", "start": [39, 1], "end": [41, 61], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Algebra/Category/BoolRing.lean", "imports": ["Mathlib/Order/Category/BoolAlg.lean", "Mathlib/Algebra/Category/Ring/Basic.lean", "Mathlib/Algebra/Ring/BooleanRing.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "BoolRing", "code": "def BoolRing :=\n  Bundled BooleanRing", "start": [28, 1], "end": [30, 22], "kind": "commanddeclaration"}, {"full_name": "BoolRing.of", "code": "def of (\u03b1 : Type*) [BooleanRing \u03b1] : BoolRing :=\n  Bundled.of \u03b1", "start": [41, 1], "end": [43, 15], "kind": "commanddeclaration"}, {"full_name": "BoolRing.coe_of", "code": "@[simp]\ntheorem coe_of (\u03b1 : Type*) [BooleanRing \u03b1] : \u21a5(of \u03b1) = \u03b1", "start": [46, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "BoolRing.hasForgetToCommRing", "code": "instance hasForgetToCommRing : HasForget\u2082 BoolRing CommRingCat :=\n  BundledHom.forget\u2082 _ _", "start": [70, 1], "end": [71, 25], "kind": "commanddeclaration"}, {"full_name": "BoolRing.Iso.mk", "code": "@[simps]\ndef Iso.mk {\u03b1 \u03b2 : BoolRing.{u}} (e : \u03b1 \u2243+* \u03b2) : \u03b1 \u2245 \u03b2 where\n  hom := (e : RingHom _ _)\n  inv := (e.symm : RingHom _ _)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _", "start": [74, 1], "end": [80, 51], "kind": "commanddeclaration"}, {"full_name": "BoolRing.hasForgetToBoolAlg", "code": "@[simps]\ninstance BoolRing.hasForgetToBoolAlg : HasForget\u2082 BoolRing BoolAlg where\n  forget\u2082 :=\n    { obj := fun X => BoolAlg.of (AsBoolAlg X)\n      map := fun {X Y} => RingHom.asBoolAlg }", "start": [87, 1], "end": [91, 46], "kind": "commanddeclaration"}, {"full_name": "BoolAlg.hasForgetToBoolRing", "code": "@[simps]\ninstance BoolAlg.hasForgetToBoolRing : HasForget\u2082 BoolAlg BoolRing where\n  forget\u2082 :=\n    { obj := fun X => BoolRing.of (AsBoolRing X)\n      map := fun {X Y} => BoundedLatticeHom.asBoolRing }", "start": [99, 1], "end": [103, 57], "kind": "commanddeclaration"}, {"full_name": "boolRingCatEquivBoolAlg", "code": "@[simps functor inverse]\ndef boolRingCatEquivBoolAlg : BoolRing \u224c BoolAlg where\n  functor := forget\u2082 BoolRing BoolAlg\n  inverse := forget\u2082 BoolAlg BoolRing\n  unitIso := NatIso.ofComponents (fun X => BoolRing.Iso.mk <|\n    (RingEquiv.asBoolRingAsBoolAlg X).symm) fun {X Y} f => rfl\n  counitIso := NatIso.ofComponents (fun X => BoolAlg.Iso.mk <|\n    OrderIso.asBoolAlgAsBoolRing X) fun {X Y} f => rfl", "start": [106, 1], "end": [114, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Sups.lean", "imports": ["Mathlib/Data/Set/Sups.lean", "Mathlib/Data/Finset/NAry.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.hasSups", "code": "protected def hasSups : HasSups (Finset \u03b1) :=\n  \u27e8image\u2082 (\u00b7 \u2294 \u00b7)\u27e9", "start": [46, 1], "end": [48, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_sups", "code": "@[simp]\ntheorem mem_sups : c \u2208 s \u22bb t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, a \u2294 b = c", "start": [57, 1], "end": [58, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_sups", "code": "@[simp, norm_cast]\ntheorem coe_sups : (\u2191(s \u22bb t) : Set \u03b1) = \u2191s \u22bb \u2191t", "start": [63, 1], "end": [65, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.card_sups_le", "code": "theorem card_sups_le : (s \u22bb t).card \u2264 s.card * t.card", "start": [68, 1], "end": [69, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.card_sups_iff", "code": "theorem card_sups_iff :\n    (s \u22bb t).card = s.card * t.card \u2194 (s \u00d7\u02e2 t : Set (\u03b1 \u00d7 \u03b1)).InjOn fun x => x.1 \u2294 x.2", "start": [72, 1], "end": [74, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_mem_sups", "code": "theorem sup_mem_sups : a \u2208 s \u2192 b \u2208 t \u2192 a \u2294 b \u2208 s \u22bb t", "start": [79, 1], "end": [80, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_subset", "code": "theorem sups_subset : s\u2081 \u2286 s\u2082 \u2192 t\u2081 \u2286 t\u2082 \u2192 s\u2081 \u22bb t\u2081 \u2286 s\u2082 \u22bb t\u2082", "start": [83, 1], "end": [84, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_subset_left", "code": "theorem sups_subset_left : t\u2081 \u2286 t\u2082 \u2192 s \u22bb t\u2081 \u2286 s \u22bb t\u2082", "start": [87, 1], "end": [88, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_subset_right", "code": "theorem sups_subset_right : s\u2081 \u2286 s\u2082 \u2192 s\u2081 \u22bb t \u2286 s\u2082 \u22bb t", "start": [91, 1], "end": [92, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.image_subset_sups_left", "code": "theorem image_subset_sups_left : b \u2208 t \u2192 (s.image fun a => a \u2294 b) \u2286 s \u22bb t", "start": [95, 1], "end": [96, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.image_subset_sups_right", "code": "theorem image_subset_sups_right : a \u2208 s \u2192 t.image (a \u2294 \u00b7) \u2286 s \u22bb t", "start": [99, 1], "end": [100, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.forall_sups_iff", "code": "theorem forall_sups_iff {p : \u03b1 \u2192 Prop} : (\u2200 c \u2208 s \u22bb t, p c) \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, p (a \u2294 b)", "start": [103, 1], "end": [104, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_subset_iff", "code": "@[simp]\ntheorem sups_subset_iff : s \u22bb t \u2286 u \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2294 b \u2208 u", "start": [107, 1], "end": [109, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_nonempty", "code": "@[simp]\ntheorem sups_nonempty : (s \u22bb t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [112, 1], "end": [114, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.sups", "code": "protected theorem Nonempty.sups : s.Nonempty \u2192 t.Nonempty \u2192 (s \u22bb t).Nonempty", "start": [117, 1], "end": [118, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_sups_left", "code": "theorem Nonempty.of_sups_left : (s \u22bb t).Nonempty \u2192 s.Nonempty", "start": [121, 1], "end": [122, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_sups_right", "code": "theorem Nonempty.of_sups_right : (s \u22bb t).Nonempty \u2192 t.Nonempty", "start": [125, 1], "end": [126, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_sups", "code": "@[simp]\ntheorem empty_sups : \u2205 \u22bb t = \u2205", "start": [129, 1], "end": [131, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_empty", "code": "@[simp]\ntheorem sups_empty : s \u22bb \u2205 = \u2205", "start": [134, 1], "end": [136, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_eq_empty", "code": "@[simp]\ntheorem sups_eq_empty : s \u22bb t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [139, 1], "end": [141, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_sups", "code": "@[simp]\ntheorem singleton_sups : {a} \u22bb t = t.image fun b => a \u2294 b", "start": [144, 1], "end": [146, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_singleton", "code": "@[simp]\ntheorem sups_singleton : s \u22bb {b} = s.image fun a => a \u2294 b", "start": [149, 1], "end": [151, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_sups_singleton", "code": "theorem singleton_sups_singleton : ({a} \u22bb {b} : Finset \u03b1) = {a \u2294 b}", "start": [154, 1], "end": [155, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_union_left", "code": "theorem sups_union_left : (s\u2081 \u222a s\u2082) \u22bb t = s\u2081 \u22bb t \u222a s\u2082 \u22bb t", "start": [158, 1], "end": [159, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_union_right", "code": "theorem sups_union_right : s \u22bb (t\u2081 \u222a t\u2082) = s \u22bb t\u2081 \u222a s \u22bb t\u2082", "start": [162, 1], "end": [163, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_inter_subset_left", "code": "theorem sups_inter_subset_left : (s\u2081 \u2229 s\u2082) \u22bb t \u2286 s\u2081 \u22bb t \u2229 s\u2082 \u22bb t", "start": [166, 1], "end": [167, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_inter_subset_right", "code": "theorem sups_inter_subset_right : s \u22bb (t\u2081 \u2229 t\u2082) \u2286 s \u22bb t\u2081 \u2229 s \u22bb t\u2082", "start": [170, 1], "end": [171, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_sups", "code": "theorem subset_sups {s t : Set \u03b1} :\n    \u2191u \u2286 s \u22bb t \u2192 \u2203 s' t' : Finset \u03b1, \u2191s' \u2286 s \u2227 \u2191t' \u2286 t \u2227 u \u2286 s' \u22bb t'", "start": [174, 1], "end": [176, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.image_sups", "code": "lemma image_sups (f : F) (s t : Finset \u03b1) : image f (s \u22bb t) = image f s \u22bb image f t :=\n  image_image\u2082_distrib $ map_sup f", "start": [179, 1], "end": [180, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.map_sups", "code": "lemma map_sups (f : F) (hf) (s t : Finset \u03b1) :\n    map \u27e8f, hf\u27e9 (s \u22bb t) = map \u27e8f, hf\u27e9 s \u22bb map \u27e8f, hf\u27e9 t := by\n  simpa [map_eq_image] using image_sups f s t", "start": [182, 1], "end": [184, 46], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.subset_sups_self", "code": "lemma subset_sups_self : s \u2286 s \u22bb s := fun _a ha \u21a6 mem_sups.2 \u27e8_, ha, _, ha, sup_idem\u27e9", "start": [186, 1], "end": [186, 86], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.sups_subset_self", "code": "lemma sups_subset_self : s \u22bb s \u2286 s \u2194 SupClosed (s : Set \u03b1) := sups_subset_iff", "start": [187, 1], "end": [187, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.sups_eq_self", "code": "@[simp] lemma sups_eq_self : s \u22bb s = s \u2194 SupClosed (s : Set \u03b1) := by simp [\u2190coe_inj]", "start": [188, 1], "end": [188, 85], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.filter_sups_le", "code": "lemma filter_sups_le [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (s t : Finset \u03b1) (a : \u03b1) :\n    (s \u22bb t).filter (\u00b7 \u2264 a) = s.filter (\u00b7 \u2264 a) \u22bb t.filter (\u00b7 \u2264 a) := by\n  simp only [\u2190coe_inj, coe_filter, coe_sups, \u2190mem_coe, Set.sep_sups_le]", "start": [190, 1], "end": [192, 72], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.biUnion_image_sup_left", "code": "theorem biUnion_image_sup_left : (s.biUnion fun a => t.image <| (\u00b7 \u2294 \u00b7) a) = s \u22bb t", "start": [196, 1], "end": [197, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_image_sup_right", "code": "theorem biUnion_image_sup_right : (t.biUnion fun b => s.image fun a => a \u2294 b) = s \u22bb t", "start": [200, 1], "end": [201, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.image_sup_product", "code": "theorem image_sup_product (s t : Finset \u03b1) : (s \u00d7\u02e2 t).image (uncurry (\u00b7 \u2294 \u00b7)) = s \u22bb t", "start": [205, 1], "end": [206, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_assoc", "code": "theorem sups_assoc : s \u22bb t \u22bb u = s \u22bb (t \u22bb u)", "start": [209, 1], "end": [210, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_comm", "code": "theorem sups_comm : s \u22bb t = t \u22bb s", "start": [213, 1], "end": [214, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_left_comm", "code": "theorem sups_left_comm : s \u22bb (t \u22bb u) = t \u22bb (s \u22bb u)", "start": [217, 1], "end": [218, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_right_comm", "code": "theorem sups_right_comm : s \u22bb t \u22bb u = s \u22bb u \u22bb t", "start": [221, 1], "end": [222, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_sups_sups_comm", "code": "theorem sups_sups_sups_comm : s \u22bb t \u22bb (u \u22bb v) = s \u22bb u \u22bb (t \u22bb v)", "start": [225, 1], "end": [226, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.hasInfs", "code": "protected def hasInfs : HasInfs (Finset \u03b1) :=\n  \u27e8image\u2082 (\u00b7 \u2293 \u00b7)\u27e9", "start": [234, 1], "end": [236, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_infs", "code": "@[simp]\ntheorem mem_infs : c \u2208 s \u22bc t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, a \u2293 b = c", "start": [245, 1], "end": [246, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_infs", "code": "@[simp, norm_cast]\ntheorem coe_infs : (\u2191(s \u22bc t) : Set \u03b1) = \u2191s \u22bc \u2191t", "start": [251, 1], "end": [253, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.card_infs_le", "code": "theorem card_infs_le : (s \u22bc t).card \u2264 s.card * t.card", "start": [256, 1], "end": [257, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.card_infs_iff", "code": "theorem card_infs_iff :\n    (s \u22bc t).card = s.card * t.card \u2194 (s \u00d7\u02e2 t : Set (\u03b1 \u00d7 \u03b1)).InjOn fun x => x.1 \u2293 x.2", "start": [260, 1], "end": [262, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_mem_infs", "code": "theorem inf_mem_infs : a \u2208 s \u2192 b \u2208 t \u2192 a \u2293 b \u2208 s \u22bc t", "start": [267, 1], "end": [268, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_subset", "code": "theorem infs_subset : s\u2081 \u2286 s\u2082 \u2192 t\u2081 \u2286 t\u2082 \u2192 s\u2081 \u22bc t\u2081 \u2286 s\u2082 \u22bc t\u2082", "start": [271, 1], "end": [272, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_subset_left", "code": "theorem infs_subset_left : t\u2081 \u2286 t\u2082 \u2192 s \u22bc t\u2081 \u2286 s \u22bc t\u2082", "start": [275, 1], "end": [276, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_subset_right", "code": "theorem infs_subset_right : s\u2081 \u2286 s\u2082 \u2192 s\u2081 \u22bc t \u2286 s\u2082 \u22bc t", "start": [279, 1], "end": [280, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.image_subset_infs_left", "code": "theorem image_subset_infs_left : b \u2208 t \u2192 (s.image fun a => a \u2293 b) \u2286 s \u22bc t", "start": [283, 1], "end": [284, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.image_subset_infs_right", "code": "theorem image_subset_infs_right : a \u2208 s \u2192 t.image (a \u2293 \u00b7) \u2286 s \u22bc t", "start": [287, 1], "end": [288, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.forall_infs_iff", "code": "theorem forall_infs_iff {p : \u03b1 \u2192 Prop} : (\u2200 c \u2208 s \u22bc t, p c) \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, p (a \u2293 b)", "start": [291, 1], "end": [292, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_subset_iff", "code": "@[simp]\ntheorem infs_subset_iff : s \u22bc t \u2286 u \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2293 b \u2208 u", "start": [295, 1], "end": [297, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_nonempty", "code": "@[simp]\ntheorem infs_nonempty : (s \u22bc t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [300, 1], "end": [302, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.infs", "code": "protected theorem Nonempty.infs : s.Nonempty \u2192 t.Nonempty \u2192 (s \u22bc t).Nonempty", "start": [305, 1], "end": [306, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_infs_left", "code": "theorem Nonempty.of_infs_left : (s \u22bc t).Nonempty \u2192 s.Nonempty", "start": [309, 1], "end": [310, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_infs_right", "code": "theorem Nonempty.of_infs_right : (s \u22bc t).Nonempty \u2192 t.Nonempty", "start": [313, 1], "end": [314, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_infs", "code": "@[simp]\ntheorem empty_infs : \u2205 \u22bc t = \u2205", "start": [317, 1], "end": [319, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_empty", "code": "@[simp]\ntheorem infs_empty : s \u22bc \u2205 = \u2205", "start": [322, 1], "end": [324, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_eq_empty", "code": "@[simp]\ntheorem infs_eq_empty : s \u22bc t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [327, 1], "end": [329, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_infs", "code": "@[simp]\ntheorem singleton_infs : {a} \u22bc t = t.image fun b => a \u2293 b", "start": [332, 1], "end": [334, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_singleton", "code": "@[simp]\ntheorem infs_singleton : s \u22bc {b} = s.image fun a => a \u2293 b", "start": [337, 1], "end": [339, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_infs_singleton", "code": "theorem singleton_infs_singleton : ({a} \u22bc {b} : Finset \u03b1) = {a \u2293 b}", "start": [342, 1], "end": [343, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_union_left", "code": "theorem infs_union_left : (s\u2081 \u222a s\u2082) \u22bc t = s\u2081 \u22bc t \u222a s\u2082 \u22bc t", "start": [346, 1], "end": [347, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_union_right", "code": "theorem infs_union_right : s \u22bc (t\u2081 \u222a t\u2082) = s \u22bc t\u2081 \u222a s \u22bc t\u2082", "start": [350, 1], "end": [351, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_inter_subset_left", "code": "theorem infs_inter_subset_left : (s\u2081 \u2229 s\u2082) \u22bc t \u2286 s\u2081 \u22bc t \u2229 s\u2082 \u22bc t", "start": [354, 1], "end": [355, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_inter_subset_right", "code": "theorem infs_inter_subset_right : s \u22bc (t\u2081 \u2229 t\u2082) \u2286 s \u22bc t\u2081 \u2229 s \u22bc t\u2082", "start": [358, 1], "end": [359, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_infs", "code": "theorem subset_infs {s t : Set \u03b1} :\n    \u2191u \u2286 s \u22bc t \u2192 \u2203 s' t' : Finset \u03b1, \u2191s' \u2286 s \u2227 \u2191t' \u2286 t \u2227 u \u2286 s' \u22bc t'", "start": [362, 1], "end": [364, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.image_infs", "code": "lemma image_infs (f : F) (s t : Finset \u03b1) : image f (s \u22bc t) = image f s \u22bc image f t :=\n  image_image\u2082_distrib $ map_inf f", "start": [367, 1], "end": [368, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.map_infs", "code": "lemma map_infs (f : F) (hf) (s t : Finset \u03b1) :\n    map \u27e8f, hf\u27e9 (s \u22bc t) = map \u27e8f, hf\u27e9 s \u22bc map \u27e8f, hf\u27e9 t := by\n  simpa [map_eq_image] using image_infs f s t", "start": [370, 1], "end": [372, 46], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.subset_infs_self", "code": "lemma subset_infs_self : s \u2286 s \u22bc s := fun _a ha \u21a6 mem_infs.2 \u27e8_, ha, _, ha, inf_idem\u27e9", "start": [374, 1], "end": [374, 86], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.infs_self_subset", "code": "lemma infs_self_subset : s \u22bc s \u2286 s \u2194 InfClosed (s : Set \u03b1) := infs_subset_iff", "start": [375, 1], "end": [375, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.infs_self", "code": "@[simp] lemma infs_self : s \u22bc s = s \u2194 InfClosed (s : Set \u03b1) := by simp [\u2190coe_inj]", "start": [376, 1], "end": [376, 82], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.filter_infs_le", "code": "lemma filter_infs_le [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (s t : Finset \u03b1) (a : \u03b1) :\n    (s \u22bc t).filter (a \u2264 \u00b7) = s.filter (a \u2264 \u00b7) \u22bc t.filter (a \u2264 \u00b7) := by\n  simp only [\u2190coe_inj, coe_filter, coe_infs, \u2190mem_coe, Set.sep_infs_le]", "start": [378, 1], "end": [380, 72], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.biUnion_image_inf_left", "code": "theorem biUnion_image_inf_left : (s.biUnion fun a => t.image <| (\u00b7 \u2293 \u00b7) a) = s \u22bc t", "start": [384, 1], "end": [385, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_image_inf_right", "code": "theorem biUnion_image_inf_right : (t.biUnion fun b => s.image fun a => a \u2293 b) = s \u22bc t", "start": [388, 1], "end": [389, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.image_inf_product", "code": "theorem image_inf_product (s t : Finset \u03b1) : (s \u00d7\u02e2 t).image (uncurry (\u00b7 \u2293 \u00b7)) = s \u22bc t", "start": [393, 1], "end": [394, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_assoc", "code": "theorem infs_assoc : s \u22bc t \u22bc u = s \u22bc (t \u22bc u)", "start": [397, 1], "end": [398, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_comm", "code": "theorem infs_comm : s \u22bc t = t \u22bc s", "start": [401, 1], "end": [402, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_left_comm", "code": "theorem infs_left_comm : s \u22bc (t \u22bc u) = t \u22bc (s \u22bc u)", "start": [405, 1], "end": [406, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_right_comm", "code": "theorem infs_right_comm : s \u22bc t \u22bc u = s \u22bc u \u22bc t", "start": [409, 1], "end": [410, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_infs_infs_comm", "code": "theorem infs_infs_infs_comm : s \u22bc t \u22bc (u \u22bc v) = s \u22bc u \u22bc (t \u22bc v)", "start": [413, 1], "end": [414, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.powerset_union", "code": "@[simp] lemma powerset_union (s t : Finset \u03b1) : (s \u222a t).powerset = s.powerset \u22bb t.powerset := by\n  ext u\n  simp only [mem_sups, mem_powerset, le_eq_subset, sup_eq_union]\n  refine \u27e8fun h \u21a6 \u27e8_, inter_subset_left _ u, _, inter_subset_left _ u, ?_\u27e9, ?_\u27e9\n  \u00b7 rwa [\u2190inter_distrib_right, inter_eq_right]\n  \u00b7 rintro \u27e8v, hv, w, hw, rfl\u27e9\n    exact union_subset_union hv hw", "start": [421, 1], "end": [427, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.powerset_inter", "code": "@[simp] lemma powerset_inter (s t : Finset \u03b1) : (s \u2229 t).powerset = s.powerset \u22bc t.powerset := by\n  ext u\n  simp only [mem_infs, mem_powerset, le_eq_subset, inf_eq_inter]\n  refine \u27e8fun h \u21a6 \u27e8_, inter_subset_left _ u, _, inter_subset_left _ u, ?_\u27e9, ?_\u27e9\n  \u00b7 rwa [\u2190inter_inter_distrib_right, inter_eq_right]\n  \u00b7 rintro \u27e8v, hv, w, hw, rfl\u27e9\n    exact inter_subset_inter hv hw", "start": [429, 1], "end": [435, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.sups_infs_subset_left", "code": "theorem sups_infs_subset_left : s \u22bb t \u22bc u \u2286 (s \u22bb t) \u22bc (s \u22bb u)", "start": [441, 1], "end": [442, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.sups_infs_subset_right", "code": "theorem sups_infs_subset_right : t \u22bc u \u22bb s \u2286 (t \u22bb s) \u22bc (u \u22bb s)", "start": [445, 1], "end": [446, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_sups_subset_left", "code": "theorem infs_sups_subset_left : s \u22bc (t \u22bb u) \u2286 s \u22bc t \u22bb s \u22bc u", "start": [449, 1], "end": [450, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.infs_sups_subset_right", "code": "theorem infs_sups_subset_right : (t \u22bb u) \u22bc s \u2286 t \u22bc s \u22bb u \u22bc s", "start": [453, 1], "end": [454, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups", "code": "def disjSups : Finset \u03b1 :=\n  ((s \u00d7\u02e2 t).filter fun ab : \u03b1 \u00d7 \u03b1 => Disjoint ab.1 ab.2).image fun ab => ab.1 \u2294 ab.2", "start": [463, 1], "end": [466, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_disjSups", "code": "@[simp]\ntheorem mem_disjSups : c \u2208 s \u25cb t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, Disjoint a b \u2227 a \u2294 b = c", "start": [476, 1], "end": [478, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_subset_sups", "code": "theorem disjSups_subset_sups : s \u25cb t \u2286 s \u22bb t", "start": [481, 1], "end": [483, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.card_disjSups_le", "code": "theorem card_disjSups_le : (s \u25cb t).card \u2264 s.card * t.card", "start": [488, 1], "end": [489, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_subset", "code": "theorem disjSups_subset (hs : s\u2081 \u2286 s\u2082) (ht : t\u2081 \u2286 t\u2082) : s\u2081 \u25cb t\u2081 \u2286 s\u2082 \u25cb t\u2082", "start": [494, 1], "end": [495, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_subset_left", "code": "theorem disjSups_subset_left (ht : t\u2081 \u2286 t\u2082) : s \u25cb t\u2081 \u2286 s \u25cb t\u2082", "start": [498, 1], "end": [499, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_subset_right", "code": "theorem disjSups_subset_right (hs : s\u2081 \u2286 s\u2082) : s\u2081 \u25cb t \u2286 s\u2082 \u25cb t", "start": [502, 1], "end": [503, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.forall_disjSups_iff", "code": "theorem forall_disjSups_iff {p : \u03b1 \u2192 Prop} :\n    (\u2200 c \u2208 s \u25cb t, p c) \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, Disjoint a b \u2192 p (a \u2294 b)", "start": [506, 1], "end": [511, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_subset_iff", "code": "@[simp]\ntheorem disjSups_subset_iff : s \u25cb t \u2286 u \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, Disjoint a b \u2192 a \u2294 b \u2208 u", "start": [514, 1], "end": [516, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_disjSups_left", "code": "theorem Nonempty.of_disjSups_left : (s \u25cb t).Nonempty \u2192 s.Nonempty", "start": [519, 1], "end": [521, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_disjSups_right", "code": "theorem Nonempty.of_disjSups_right : (s \u25cb t).Nonempty \u2192 t.Nonempty", "start": [524, 1], "end": [526, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_empty_left", "code": "@[simp]\ntheorem disjSups_empty_left : \u2205 \u25cb t = \u2205", "start": [529, 1], "end": [530, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_empty_right", "code": "@[simp]\ntheorem disjSups_empty_right : s \u25cb \u2205 = \u2205", "start": [533, 1], "end": [534, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_singleton", "code": "theorem disjSups_singleton : ({a} \u25cb {b} : Finset \u03b1) = if Disjoint a b then {a \u2294 b} else \u2205", "start": [537, 1], "end": [538, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_union_left", "code": "theorem disjSups_union_left : (s\u2081 \u222a s\u2082) \u25cb t = s\u2081 \u25cb t \u222a s\u2082 \u25cb t", "start": [541, 1], "end": [542, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_union_right", "code": "theorem disjSups_union_right : s \u25cb (t\u2081 \u222a t\u2082) = s \u25cb t\u2081 \u222a s \u25cb t\u2082", "start": [545, 1], "end": [546, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_inter_subset_left", "code": "theorem disjSups_inter_subset_left : (s\u2081 \u2229 s\u2082) \u25cb t \u2286 s\u2081 \u25cb t \u2229 s\u2082 \u25cb t", "start": [549, 1], "end": [550, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_inter_subset_right", "code": "theorem disjSups_inter_subset_right : s \u25cb (t\u2081 \u2229 t\u2082) \u2286 s \u25cb t\u2081 \u2229 s \u25cb t\u2082", "start": [553, 1], "end": [554, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_comm", "code": "theorem disjSups_comm : s \u25cb t = t \u25cb s", "start": [559, 1], "end": [567, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_assoc", "code": "theorem disjSups_assoc : \u2200 s t u : Finset \u03b1, s \u25cb t \u25cb u = s \u25cb (t \u25cb u)", "start": [578, 1], "end": [583, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_left_comm", "code": "theorem disjSups_left_comm : s \u25cb (t \u25cb u) = t \u25cb (s \u25cb u)", "start": [586, 1], "end": [587, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_right_comm", "code": "theorem disjSups_right_comm : s \u25cb t \u25cb u = s \u25cb u \u25cb t", "start": [590, 1], "end": [590, 98], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSups_disjSups_disjSups_comm", "code": "theorem disjSups_disjSups_disjSups_comm : s \u25cb t \u25cb (u \u25cb v) = s \u25cb u \u25cb (t \u25cb v)", "start": [593, 1], "end": [594, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Interval.lean", "imports": ["Mathlib/Data/Finset/LocallyFinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.Icc_eq_filter_powerset", "code": "theorem Icc_eq_filter_powerset : Icc s t = t.powerset.filter ((\u00b7 \u2286 \u00b7) s)", "start": [54, 1], "end": [55, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_eq_filter_ssubsets", "code": "theorem Ico_eq_filter_ssubsets : Ico s t = t.ssubsets.filter ((\u00b7 \u2286 \u00b7) s)", "start": [58, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_eq_filter_powerset", "code": "theorem Ioc_eq_filter_powerset : Ioc s t = t.powerset.filter ((\u00b7 \u2282 \u00b7) s)", "start": [62, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_eq_filter_ssubsets", "code": "theorem Ioo_eq_filter_ssubsets : Ioo s t = t.ssubsets.filter ((\u00b7 \u2282 \u00b7) s)", "start": [66, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.Iic_eq_powerset", "code": "theorem Iic_eq_powerset : Iic s = s.powerset", "start": [70, 1], "end": [71, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.Iio_eq_ssubsets", "code": "theorem Iio_eq_ssubsets : Iio s = s.ssubsets", "start": [74, 1], "end": [75, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_eq_image_powerset", "code": "theorem Icc_eq_image_powerset (h : s \u2286 t) : Icc s t = (t \\ s).powerset.image ((\u00b7 \u222a \u00b7) s)", "start": [80, 1], "end": [87, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_eq_image_ssubsets", "code": "theorem Ico_eq_image_ssubsets (h : s \u2286 t) : Ico s t = (t \\ s).ssubsets.image ((\u00b7 \u222a \u00b7) s)", "start": [90, 1], "end": [97, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.card_Icc_finset", "code": "theorem card_Icc_finset (h : s \u2286 t) : (Icc s t).card = 2 ^ (t.card - s.card)", "start": [100, 1], "end": [106, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.card_Ico_finset", "code": "theorem card_Ico_finset (h : s \u2286 t) : (Ico s t).card = 2 ^ (t.card - s.card) - 1", "start": [109, 1], "end": [111, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.card_Ioc_finset", "code": "theorem card_Ioc_finset (h : s \u2286 t) : (Ioc s t).card = 2 ^ (t.card - s.card) - 1", "start": [114, 1], "end": [116, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.card_Ioo_finset", "code": "theorem card_Ioo_finset (h : s \u2286 t) : (Ioo s t).card = 2 ^ (t.card - s.card) - 2", "start": [119, 1], "end": [121, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.card_Iic_finset", "code": "theorem card_Iic_finset : (Iic s).card = 2 ^ s.card", "start": [124, 1], "end": [125, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.card_Iio_finset", "code": "theorem card_Iio_finset : (Iio s).card = 2 ^ s.card - 1", "start": [128, 1], "end": [130, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.covby_cons", "code": "lemma covby_cons {i : \u03b1} (hi : i \u2209 s) : s \u22d6 cons i s hi :=\n  Covby.of_image \u27e8\u27e8((\u2191) : Finset \u03b1 \u2192 Set \u03b1), coe_injective\u27e9, coe_subset\u27e9 <| by\n    simp only [RelEmbedding.coe_mk, Function.Embedding.coeFn_mk, coe_cons, mem_coe]\n    exact_mod_cast Set.covby_insert (show i \u2209 (s : Set \u03b1) from hi)", "start": [139, 1], "end": [142, 67], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.covby_iff", "code": "lemma covby_iff : s \u22d6 t \u2194 \u2203 i : \u03b1, \u2203 hi : i \u2209 s, t = cons i s hi := by\n  constructor\n  \u00b7 intro hst\n    obtain \u27e8i, hi, his\u27e9 := ssubset_iff_exists_cons_subset.mp hst.1\n    exact \u27e8i, hi, .symm <| eq_of_le_of_not_lt his <| hst.2 <| ssubset_cons hi\u27e9\n  \u00b7 rintro \u27e8i, hi, rfl\u27e9\n    exact covby_cons hi", "start": [144, 1], "end": [150, 24], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.monotone_iff", "code": "theorem monotone_iff {\u03b2 : Type*} [Preorder \u03b2] (f : Finset \u03b1 \u2192 \u03b2) :\n    Monotone f \u2194 \u2200 s : Finset \u03b1, \u2200 {i} (hi : i \u2209 s), f s \u2264 f (cons i s hi)", "start": [152, 1], "end": [158, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.strictMono_iff", "code": "theorem strictMono_iff {\u03b2 : Type*} [Preorder \u03b2] (f : Finset \u03b1 \u2192 \u03b2) :\n    StrictMono f \u2194 \u2200 s : Finset \u03b1, \u2200 {i} (hi : i \u2209 s), f s < f (cons i s hi)", "start": [160, 1], "end": [166, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.antitone_iff", "code": "theorem antitone_iff {\u03b2 : Type*} [Preorder \u03b2] (f : Finset \u03b1 \u2192 \u03b2) :\n    Antitone f \u2194 \u2200 s : Finset \u03b1, \u2200 {i} (hi : i \u2209 s), f (cons i s hi) \u2264 f s", "start": [168, 1], "end": [172, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.strictAnti_iff", "code": "theorem strictAnti_iff {\u03b2 : Type*} [Preorder \u03b2] (f : Finset \u03b1 \u2192 \u03b2) :\n    StrictAnti f \u2194 \u2200 s : Finset \u03b1, \u2200 {i} (hi : i \u2209 s), f (cons i s hi) < f s", "start": [174, 1], "end": [178, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.covby_insert", "code": "lemma covby_insert {i : \u03b1} (hi : i \u2209 s) : s \u22d6 insert i s := by\n  simpa using covby_cons hi", "start": [186, 1], "end": [187, 28], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.covby_iff'", "code": "lemma covby_iff' : s \u22d6 t \u2194 \u2203 i : \u03b1, i \u2209 s \u2227 t = insert i s := by\n  simp [covby_iff]", "start": [189, 1], "end": [190, 19], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.monotone_iff'", "code": "theorem monotone_iff' {\u03b2 : Type*} [Preorder \u03b2] (f : Finset \u03b1 \u2192 \u03b2) :\n    Monotone f \u2194 \u2200 s : Finset \u03b1, \u2200 {i} (_hi : i \u2209 s), f s \u2264 f (insert i s)", "start": [192, 1], "end": [196, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.strictMono_iff'", "code": "theorem strictMono_iff' {\u03b2 : Type*} [Preorder \u03b2] (f : Finset \u03b1 \u2192 \u03b2) :\n    StrictMono f \u2194 \u2200 s : Finset \u03b1, \u2200 {i} (_hi : i \u2209 s), f s < f (insert i s)", "start": [198, 1], "end": [202, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.antitone_iff'", "code": "theorem antitone_iff' {\u03b2 : Type*} [Preorder \u03b2] (f : Finset \u03b1 \u2192 \u03b2) :\n    Antitone f \u2194 \u2200 s : Finset \u03b1, \u2200 {i} (_hi : i \u2209 s), f (insert i s) \u2264 f s", "start": [204, 1], "end": [208, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.strictAnti_iff'", "code": "theorem strictAnti_iff' {\u03b2 : Type*} [Preorder \u03b2] (f : Finset \u03b1 \u2192 \u03b2) :\n    StrictAnti f \u2194 \u2200 s : Finset \u03b1, \u2200 {i} (_hi : i \u2209 s), f (insert i s) < f s", "start": [210, 1], "end": [214, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Sites/Adjunction.lean", "imports": ["Mathlib/CategoryTheory/Adjunction/Whiskering.lean", "Mathlib/CategoryTheory/Sites/Sheafification.lean", "Mathlib/CategoryTheory/Sites/Whiskering.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.sheafForget", "code": "abbrev sheafForget : Sheaf J D \u2964 SheafOfTypes J :=\n  sheafCompose J (forget D) \u22d9 (sheafEquivSheafOfTypes J).functor", "start": [38, 1], "end": [41, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sheaf.composeAndSheafify", "code": "abbrev composeAndSheafify (G : E \u2964 D) : Sheaf J E \u2964 Sheaf J D :=\n  sheafToPresheaf J E \u22d9 (whiskeringRight _ _ _).obj G \u22d9 presheafToSheaf J D", "start": [54, 1], "end": [57, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sheaf.composeEquiv", "code": "@[simps]\ndef composeEquiv (adj : G \u22a3 F) (X : Sheaf J E) (Y : Sheaf J D) :\n    ((composeAndSheafify J G).obj X \u27f6 Y) \u2243 (X \u27f6 (sheafCompose J F).obj Y) :=\n  let A := adj.whiskerRight C\u1d52\u1d56\n  { toFun := fun \u03b7 => \u27e8A.homEquiv _ _ (J.toSheafify _ \u226b \u03b7.val)\u27e9\n    invFun := fun \u03b3 => \u27e8J.sheafifyLift ((A.homEquiv _ _).symm ((sheafToPresheaf _ _).map \u03b3)) Y.2\u27e9\n    left_inv := by\n      intro \u03b7\n      ext1\n      dsimp\n      symm\n      apply J.sheafifyLift_unique\n      rw [Equiv.symm_apply_apply]\n    right_inv := by\n      intro \u03b3\n      ext1\n      dsimp\n      erw [J.toSheafify_sheafifyLift, Equiv.apply_symm_apply] }", "start": [61, 1], "end": [80, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sheaf.adjunction", "code": "@[simps! unit_app_val counit_app_val]\ndef adjunction (adj : G \u22a3 F) : composeAndSheafify J G \u22a3 sheafCompose J F :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := composeEquiv J adj\n      homEquiv_naturality_left_symm := fun f g => by\n        ext1\n        dsimp [composeEquiv]\n        rw [sheafifyMap_sheafifyLift]\n        erw [Adjunction.homEquiv_naturality_left_symm]\n        rw [whiskeringRight_obj_map]\n        rfl\n      homEquiv_naturality_right := fun f g => by\n        ext\n        dsimp [composeEquiv]\n        erw [Adjunction.homEquiv_unit, Adjunction.homEquiv_unit]\n        dsimp\n        simp }", "start": [88, 1], "end": [107, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sheaf.composeAndSheafifyFromTypes", "code": "abbrev composeAndSheafifyFromTypes (G : Type max v u \u2964 D) : SheafOfTypes J \u2964 Sheaf J D :=\n  (sheafEquivSheafOfTypes J).inverse \u22d9 composeAndSheafify _ G", "start": [116, 1], "end": [118, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sheaf.adjunctionToTypes", "code": "def adjunctionToTypes {G : Type max v u \u2964 D} (adj : G \u22a3 forget D) :\n    composeAndSheafifyFromTypes J G \u22a3 sheafForget J :=\n  (sheafEquivSheafOfTypes J).symm.toAdjunction.comp (adjunction J adj)", "start": [122, 1], "end": [126, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sheaf.adjunctionToTypes_unit_app_val", "code": "@[simp]\ntheorem adjunctionToTypes_unit_app_val {G : Type max v u \u2964 D} (adj : G \u22a3 forget D)\n    (Y : SheafOfTypes J) :\n    ((adjunctionToTypes J adj).unit.app Y).val =\n      (adj.whiskerRight _).unit.app ((sheafOfTypesToPresheaf J).obj Y) \u226b\n        whiskerRight (J.toSheafify _) (forget D)", "start": [130, 1], "end": [138, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sheaf.adjunctionToTypes_counit_app_val", "code": "@[simp]\ntheorem adjunctionToTypes_counit_app_val {G : Type max v u \u2964 D} (adj : G \u22a3 forget D)\n    (X : Sheaf J D) :\n    ((adjunctionToTypes J adj).counit.app X).val =\n      J.sheafifyLift ((Functor.associator _ _ _).hom \u226b (adj.whiskerRight _).counit.app _) X.2", "start": [142, 1], "end": [155, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Bool/Count.lean", "imports": ["Mathlib/Data/List/Chain.lean", "Mathlib/Data/Nat/Parity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.count_not_add_count", "code": "@[simp]\ntheorem count_not_add_count (l : List Bool) (b : Bool) : count (!b) l + count b l = length l", "start": [23, 1], "end": [29, 37], "kind": "commanddeclaration"}, {"full_name": "List.count_add_count_not", "code": "@[simp]\ntheorem count_add_count_not (l : List Bool) (b : Bool) : count b l + count (!b) l = length l", "start": [32, 1], "end": [34, 37], "kind": "commanddeclaration"}, {"full_name": "List.count_false_add_count_true", "code": "@[simp]\ntheorem count_false_add_count_true (l : List Bool) : count false l + count true l = length l", "start": [37, 1], "end": [39, 29], "kind": "commanddeclaration"}, {"full_name": "List.count_true_add_count_false", "code": "@[simp]\ntheorem count_true_add_count_false (l : List Bool) : count true l + count false l = length l", "start": [42, 1], "end": [44, 30], "kind": "commanddeclaration"}, {"full_name": "List.Chain.count_not", "code": "theorem Chain.count_not :\n    \u2200 {b : Bool} {l : List Bool}, Chain (\u00b7 \u2260 \u00b7) b l \u2192 count (!b) l = count b l + length l % 2", "start": [47, 1], "end": [53, 96], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.count_not_eq_count", "code": "theorem count_not_eq_count (hl : Chain' (\u00b7 \u2260 \u00b7) l) (h2 : Even (length l)) (b : Bool) :\n    count (!b) l = count b l", "start": [60, 1], "end": [71, 73], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.count_false_eq_count_true", "code": "theorem count_false_eq_count_true (hl : Chain' (\u00b7 \u2260 \u00b7) l) (h2 : Even (length l)) :\n    count false l = count true l", "start": [74, 1], "end": [76, 32], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.count_not_le_count_add_one", "code": "theorem count_not_le_count_add_one (hl : Chain' (\u00b7 \u2260 \u00b7) l) (b : Bool) :\n    count (!b) l \u2264 count b l + 1", "start": [79, 1], "end": [87, 51], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.count_false_le_count_true_add_one", "code": "theorem count_false_le_count_true_add_one (hl : Chain' (\u00b7 \u2260 \u00b7) l) :\n    count false l \u2264 count true l + 1", "start": [90, 1], "end": [92, 37], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.count_true_le_count_false_add_one", "code": "theorem count_true_le_count_false_add_one (hl : Chain' (\u00b7 \u2260 \u00b7) l) :\n    count true l \u2264 count false l + 1", "start": [95, 1], "end": [97, 38], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.two_mul_count_bool_of_even", "code": "theorem two_mul_count_bool_of_even (hl : Chain' (\u00b7 \u2260 \u00b7) l) (h2 : Even (length l)) (b : Bool) :\n    2 * count b l = length l", "start": [100, 1], "end": [102, 68], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.two_mul_count_bool_eq_ite", "code": "theorem two_mul_count_bool_eq_ite (hl : Chain' (\u00b7 \u2260 \u00b7) l) (b : Bool) :\n    2 * count b l =\n      if Even (length l) then length l else\n      if Option.some b == l.head? then length l + 1 else length l - 1", "start": [105, 1], "end": [117, 65], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.length_sub_one_le_two_mul_count_bool", "code": "theorem length_sub_one_le_two_mul_count_bool (hl : Chain' (\u00b7 \u2260 \u00b7) l) (b : Bool) :\n    length l - 1 \u2264 2 * count b l", "start": [120, 1], "end": [123, 54], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.length_div_two_le_count_bool", "code": "theorem length_div_two_le_count_bool (hl : Chain' (\u00b7 \u2260 \u00b7) l) (b : Bool) :\n    length l / 2 \u2264 count b l", "start": [126, 1], "end": [129, 50], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.two_mul_count_bool_le_length_add_one", "code": "theorem two_mul_count_bool_le_length_add_one (hl : Chain' (\u00b7 \u2260 \u00b7) l) (b : Bool) :\n    2 * count b l \u2264 length l + 1", "start": [132, 1], "end": [135, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Complex/UnitDisc/Basic.lean", "imports": ["Mathlib/Analysis/NormedSpace/BallAction.lean", "Mathlib/Analysis/Complex/Circle.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.UnitDisc", "code": "def UnitDisc : Type :=\n  ball (0 : \u2102) 1 deriving TopologicalSpace", "start": [27, 1], "end": [29, 43], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.instCommSemigroup", "code": "instance instCommSemigroup : CommSemigroup UnitDisc := by unfold UnitDisc; infer_instance", "start": [37, 1], "end": [37, 90], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.instHasDistribNeg", "code": "instance instHasDistribNeg : HasDistribNeg UnitDisc := by unfold UnitDisc; infer_instance", "start": [38, 1], "end": [38, 90], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.instCoe", "code": "instance instCoe : Coe UnitDisc \u2102 := \u27e8Subtype.val\u27e9", "start": [39, 1], "end": [39, 51], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.coe_injective", "code": "theorem coe_injective : Injective ((\u2191) : \ud835\udd3b \u2192 \u2102)", "start": [41, 1], "end": [42, 24], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.abs_lt_one", "code": "theorem abs_lt_one (z : \ud835\udd3b) : abs (z : \u2102) < 1", "start": [45, 1], "end": [46, 26], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.abs_ne_one", "code": "theorem abs_ne_one (z : \ud835\udd3b) : abs (z : \u2102) \u2260 1", "start": [49, 1], "end": [50, 18], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.normSq_lt_one", "code": "theorem normSq_lt_one (z : \ud835\udd3b) : normSq z < 1", "start": [53, 1], "end": [55, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.coe_ne_one", "code": "theorem coe_ne_one (z : \ud835\udd3b) : (z : \u2102) \u2260 1", "start": [58, 1], "end": [59, 58], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.coe_ne_neg_one", "code": "theorem coe_ne_neg_one (z : \ud835\udd3b) : (z : \u2102) \u2260 -1", "start": [62, 1], "end": [65, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.one_add_coe_ne_zero", "code": "theorem one_add_coe_ne_zero (z : \ud835\udd3b) : (1 + z : \u2102) \u2260 0", "start": [68, 1], "end": [69, 52], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (z w : \ud835\udd3b) : \u2191(z * w) = (z * w : \u2102)", "start": [72, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.mk", "code": "def mk (z : \u2102) (hz : abs z < 1) : \ud835\udd3b :=\n  \u27e8z, mem_ball_zero_iff.2 hz\u27e9", "start": [77, 1], "end": [80, 30], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.coe_mk", "code": "@[simp]\ntheorem coe_mk (z : \u2102) (hz : abs z < 1) : (mk z hz : \u2102) = z", "start": [83, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.mk_coe", "code": "@[simp]\ntheorem mk_coe (z : \ud835\udd3b) (hz : abs (z : \u2102) < 1 := z.abs_lt_one) : mk z hz = z", "start": [88, 1], "end": [90, 18], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.mk_neg", "code": "@[simp]\ntheorem mk_neg (z : \u2102) (hz : abs (-z) < 1) : mk (-z) hz = -mk z (abs.map_neg z \u25b8 hz)", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.coe_zero", "code": "@[simp]\ntheorem coe_zero : ((0 : \ud835\udd3b) : \u2102) = 0", "start": [104, 1], "end": [106, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.coe_eq_zero", "code": "@[simp]\ntheorem coe_eq_zero {z : \ud835\udd3b} : (z : \u2102) = 0 \u2194 z = 0", "start": [109, 1], "end": [111, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.circleAction", "code": "instance circleAction : MulAction circle \ud835\udd3b :=\n  mulActionSphereBall", "start": [117, 1], "end": [118, 22], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.isScalarTower_circle_circle", "code": "instance isScalarTower_circle_circle : IsScalarTower circle circle \ud835\udd3b :=\n  isScalarTower_sphere_sphere_ball", "start": [121, 1], "end": [122, 35], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.isScalarTower_circle", "code": "instance isScalarTower_circle : IsScalarTower circle \ud835\udd3b \ud835\udd3b :=\n  isScalarTower_sphere_ball_ball", "start": [125, 1], "end": [126, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.instSMulCommClass_circle", "code": "instance instSMulCommClass_circle : SMulCommClass circle \ud835\udd3b \ud835\udd3b :=\n  instSMulCommClass_sphere_ball_ball", "start": [129, 1], "end": [130, 37], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.instSMulCommClass_circle'", "code": "instance instSMulCommClass_circle' : SMulCommClass \ud835\udd3b circle \ud835\udd3b :=\n  SMulCommClass.symm _ _ _", "start": [133, 1], "end": [134, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.coe_smul_circle", "code": "@[simp, norm_cast]\ntheorem coe_smul_circle (z : circle) (w : \ud835\udd3b) : \u2191(z \u2022 w) = (z * w : \u2102)", "start": [137, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.closedBallAction", "code": "instance closedBallAction : MulAction (closedBall (0 : \u2102) 1) \ud835\udd3b :=\n  mulActionClosedBallBall", "start": [142, 1], "end": [143, 26], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.isScalarTower_closedBall_closedBall", "code": "instance isScalarTower_closedBall_closedBall :\n    IsScalarTower (closedBall (0 : \u2102) 1) (closedBall (0 : \u2102) 1) \ud835\udd3b :=\n  isScalarTower_closedBall_closedBall_ball", "start": [146, 1], "end": [148, 43], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.isScalarTower_closedBall", "code": "instance isScalarTower_closedBall : IsScalarTower (closedBall (0 : \u2102) 1) \ud835\udd3b \ud835\udd3b :=\n  isScalarTower_closedBall_ball_ball", "start": [151, 1], "end": [152, 37], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.instSMulCommClass_closedBall", "code": "instance instSMulCommClass_closedBall : SMulCommClass (closedBall (0 : \u2102) 1) \ud835\udd3b \ud835\udd3b :=\n  \u27e8fun _ _ _ => Subtype.ext <| mul_left_comm _ _ _\u27e9", "start": [155, 1], "end": [156, 52], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.instSMulCommClass_closedBall'", "code": "instance instSMulCommClass_closedBall' : SMulCommClass \ud835\udd3b (closedBall (0 : \u2102) 1) \ud835\udd3b :=\n  SMulCommClass.symm _ _ _", "start": [159, 1], "end": [160, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.instSMulCommClass_circle_closedBall", "code": "instance instSMulCommClass_circle_closedBall : SMulCommClass circle (closedBall (0 : \u2102) 1) \ud835\udd3b :=\n  instSMulCommClass_sphere_closedBall_ball", "start": [163, 1], "end": [164, 43], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.instSMulCommClass_closedBall_circle", "code": "instance instSMulCommClass_closedBall_circle : SMulCommClass (closedBall (0 : \u2102) 1) circle \ud835\udd3b :=\n  SMulCommClass.symm _ _ _", "start": [167, 1], "end": [168, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.coe_smul_closedBall", "code": "@[simp, norm_cast]\ntheorem coe_smul_closedBall (z : closedBall (0 : \u2102) 1) (w : \ud835\udd3b) : \u2191(z \u2022 w) = (z * w : \u2102)", "start": [171, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.re", "code": "def re (z : \ud835\udd3b) : \u211d :=\n  Complex.re z", "start": [176, 1], "end": [178, 15], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.im", "code": "def im (z : \ud835\udd3b) : \u211d :=\n  Complex.im z", "start": [181, 1], "end": [183, 15], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.re_coe", "code": "@[simp, norm_cast]\ntheorem re_coe (z : \ud835\udd3b) : (z : \u2102).re = z.re", "start": [186, 1], "end": [188, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.im_coe", "code": "@[simp, norm_cast]\ntheorem im_coe (z : \ud835\udd3b) : (z : \u2102).im = z.im", "start": [191, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.re_neg", "code": "@[simp]\ntheorem re_neg (z : \ud835\udd3b) : (-z).re = -z.re", "start": [196, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.im_neg", "code": "@[simp]\ntheorem im_neg (z : \ud835\udd3b) : (-z).im = -z.im", "start": [201, 1], "end": [203, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.conj", "code": "def conj (z : \ud835\udd3b) : \ud835\udd3b :=\n  mk (conj' \u2191z) <| (abs_conj z).symm \u25b8 z.abs_lt_one", "start": [206, 1], "end": [208, 52], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.coe_conj", "code": "@[simp]\ntheorem coe_conj (z : \ud835\udd3b) : (z.conj : \u2102) = conj' \u2191z", "start": [213, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.conj_zero", "code": "@[simp]\ntheorem conj_zero : conj 0 = 0", "start": [218, 1], "end": [220, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.conj_conj", "code": "@[simp]\ntheorem conj_conj (z : \ud835\udd3b) : conj (conj z) = z", "start": [223, 1], "end": [225, 45], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.conj_neg", "code": "@[simp]\ntheorem conj_neg (z : \ud835\udd3b) : (-z).conj = -z.conj", "start": [228, 1], "end": [230, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.re_conj", "code": "@[simp]\ntheorem re_conj (z : \ud835\udd3b) : z.conj.re = z.re", "start": [233, 1], "end": [235, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.im_conj", "code": "@[simp]\ntheorem im_conj (z : \ud835\udd3b) : z.conj.im = -z.im", "start": [238, 1], "end": [240, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.UnitDisc.conj_mul", "code": "@[simp]\ntheorem conj_mul (z w : \ud835\udd3b) : (z * w).conj = z.conj * w.conj", "start": [243, 1], "end": [245, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/FiniteAbelian.lean", "imports": ["Mathlib/Data/ZMod/Quotient.lean", "Mathlib/Algebra/Module/PID.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Module.finite_of_fg_torsion", "code": "theorem finite_of_fg_torsion [AddCommGroup M] [Module \u2124 M] [Module.Finite \u2124 M]\n    (hM : Module.IsTorsion \u2124 M) : _root_.Finite M", "start": [31, 1], "end": [40, 41], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.equiv_free_prod_directSum_zmod", "code": "theorem equiv_free_prod_directSum_zmod [hG : AddGroup.FG G] :\n    \u2203 (n : \u2115) (\u03b9 : Type) (_ : Fintype \u03b9) (p : \u03b9 \u2192 \u2115) (_ : \u2200 i, Nat.Prime <| p i) (e : \u03b9 \u2192 \u2115),\n      Nonempty <| G \u2243+ (Fin n \u2192\u2080 \u2124) \u00d7 \u2a01 i : \u03b9, ZMod (p i ^ e i)", "start": [51, 1], "end": [66, 69], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.equiv_directSum_zmod_of_fintype", "code": "theorem equiv_directSum_zmod_of_fintype [Finite G] :\n    \u2203 (\u03b9 : Type) (_ : Fintype \u03b9) (p : \u03b9 \u2192 \u2115) (_ : \u2200 i, Nat.Prime <| p i) (e : \u03b9 \u2192 \u2115),\n      Nonempty <| G \u2243+ \u2a01 i : \u03b9, ZMod (p i ^ e i)", "start": [69, 1], "end": [83, 69], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.finite_of_fg_torsion", "code": "theorem finite_of_fg_torsion [hG' : AddGroup.FG G] (hG : AddMonoid.IsTorsion G) : Finite G", "start": [86, 1], "end": [88, 48], "kind": "commanddeclaration"}, {"full_name": "CommGroup.finite_of_fg_torsion", "code": "theorem finite_of_fg_torsion [CommGroup G] [Group.FG G] (hG : Monoid.IsTorsion G) : Finite G", "start": [95, 1], "end": [96, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Sheaves/Skyscraper.lean", "imports": ["Mathlib/Topology/Sheaves/PUnit.lean", "Mathlib/Topology/Sheaves/Functors.lean", "Mathlib/Topology/Sheaves/Stalks.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "skyscraperPresheaf", "code": "@[simps]\ndef skyscraperPresheaf : Presheaf C X where\n  obj U := if p\u2080 \u2208 unop U then A else terminal C\n  map {U V} i :=\n    if h : p\u2080 \u2208 unop V then eqToHom <| by dsimp; erw [if_pos h, if_pos (leOfHom i.unop h)]\n    else ((if_neg h).symm.ndrec terminalIsTerminal).from _\n  map_id U :=\n    (em (p\u2080 \u2208 U.unop)).elim (fun h => dif_pos h) fun h =>\n      ((if_neg h).symm.ndrec terminalIsTerminal).hom_ext _ _\n  map_comp {U V W} iVU iWV := by\n    by_cases hW : p\u2080 \u2208 unop W\n    \u00b7 have hV : p\u2080 \u2208 unop V := leOfHom iWV.unop hW\n      simp only [dif_pos hW, dif_pos hV, eqToHom_trans]\n    \u00b7 dsimp; rw [dif_neg hW]; apply ((if_neg hW).symm.ndrec terminalIsTerminal).hom_ext", "start": [48, 1], "end": [65, 88], "kind": "commanddeclaration"}, {"full_name": "skyscraperPresheaf_eq_pushforward", "code": "theorem skyscraperPresheaf_eq_pushforward\n    [hd : \u2200 U : Opens (TopCat.of PUnit.{u + 1}), Decidable (PUnit.unit \u2208 U)] :\n    skyscraperPresheaf p\u2080 A =\n      ContinuousMap.const (TopCat.of PUnit) p\u2080 _*\n        skyscraperPresheaf (X := TopCat.of PUnit) PUnit.unit A", "start": [68, 1], "end": [74, 26], "kind": "commanddeclaration"}, {"full_name": "SkyscraperPresheafFunctor.map'", "code": "@[simps]\ndef SkyscraperPresheafFunctor.map' {a b : C} (f : a \u27f6 b) :\n    skyscraperPresheaf p\u2080 a \u27f6 skyscraperPresheaf p\u2080 b where\n  app U :=\n    if h : p\u2080 \u2208 U.unop then eqToHom (if_pos h) \u226b f \u226b eqToHom (if_pos h).symm\n    else ((if_neg h).symm.ndrec terminalIsTerminal).from _\n  naturality U V i := by\n    simp only [skyscraperPresheaf_map]; by_cases hV : p\u2080 \u2208 V.unop\n    \u00b7 have hU : p\u2080 \u2208 U.unop := leOfHom i.unop hV; split_ifs <;>\n      simp only [eqToHom_trans_assoc, Category.assoc, eqToHom_trans]\n    \u00b7 apply ((if_neg hV).symm.ndrec terminalIsTerminal).hom_ext", "start": [77, 1], "end": [91, 64], "kind": "commanddeclaration"}, {"full_name": "SkyscraperPresheafFunctor.map'_id", "code": "theorem SkyscraperPresheafFunctor.map'_id {a : C} :\n    SkyscraperPresheafFunctor.map' p\u2080 (\ud835\udfd9 a) = \ud835\udfd9 _", "start": [94, 1], "end": [99, 91], "kind": "commanddeclaration"}, {"full_name": "SkyscraperPresheafFunctor.map'_comp", "code": "theorem SkyscraperPresheafFunctor.map'_comp {a b c : C} (f : a \u27f6 b) (g : b \u27f6 c) :\n    SkyscraperPresheafFunctor.map' p\u2080 (f \u226b g) =\n      SkyscraperPresheafFunctor.map' p\u2080 f \u226b SkyscraperPresheafFunctor.map' p\u2080 g", "start": [102, 1], "end": [111, 33], "kind": "commanddeclaration"}, {"full_name": "skyscraperPresheafFunctor", "code": "@[simps]\ndef skyscraperPresheafFunctor : C \u2964 Presheaf C X where\n  obj := skyscraperPresheaf p\u2080\n  map := SkyscraperPresheafFunctor.map' p\u2080\n  map_id _ := SkyscraperPresheafFunctor.map'_id p\u2080\n  map_comp := SkyscraperPresheafFunctor.map'_comp p\u2080", "start": [114, 1], "end": [123, 53], "kind": "commanddeclaration"}, {"full_name": "skyscraperPresheafCoconeOfSpecializes", "code": "@[simps]\ndef skyscraperPresheafCoconeOfSpecializes {y : X} (h : p\u2080 \u2933 y) :\n    Cocone ((OpenNhds.inclusion y).op \u22d9 skyscraperPresheaf p\u2080 A) where\n  pt := A\n  \u03b9 :=\n    { app := fun U => eqToHom <| if_pos <| h.mem_open U.unop.1.2 U.unop.2\n      naturality := fun U V inc => by\n        change dite _ _ _ \u226b _ = _; rw [dif_pos]\n        swap \u00b7 exact h.mem_open V.unop.1.2 V.unop.2\n        \u00b7 erw [Category.comp_id, eqToHom_trans] }", "start": [134, 1], "end": [146, 50], "kind": "commanddeclaration"}, {"full_name": "skyscraperPresheafCoconeIsColimitOfSpecializes", "code": "noncomputable def skyscraperPresheafCoconeIsColimitOfSpecializes {y : X} (h : p\u2080 \u2933 y) :\n    IsColimit (skyscraperPresheafCoconeOfSpecializes p\u2080 A h) where\n  desc c := eqToHom (if_pos trivial).symm \u226b c.\u03b9.app (op \u22a4)\n  fac c U := by\n    dsimp rw [\u2190 c.w (homOfLE <| (le_top : unop U \u2264 _)).op]\n    change _ \u226b _ \u226b dite _ _ _ \u226b _ = _\n    rw [dif_pos]\n    \u00b7 simp only [skyscraperPresheafCoconeOfSpecializes_\u03b9_app, eqToHom_trans_assoc,\n        eqToHom_refl, Category.id_comp, unop_op, op_unop]\n    \u00b7 exact h.mem_open U.unop.1.2 U.unop.2\n  uniq c f h := by\n    dsimp rw [\u2190 h, skyscraperPresheafCoconeOfSpecializes_\u03b9_app, eqToHom_trans_assoc, eqToHom_refl,\n      Category.id_comp]", "start": [149, 1], "end": [167, 24], "kind": "commanddeclaration"}, {"full_name": "skyscraperPresheafStalkOfSpecializes", "code": "noncomputable def skyscraperPresheafStalkOfSpecializes [HasColimits C] {y : X} (h : p\u2080 \u2933 y) :\n    (skyscraperPresheaf p\u2080 A).stalk y \u2245 A :=\n  colimit.isoColimitCocone \u27e8_, skyscraperPresheafCoconeIsColimitOfSpecializes p\u2080 A h\u27e9", "start": [170, 1], "end": [174, 86], "kind": "commanddeclaration"}, {"full_name": "skyscraperPresheafCocone", "code": "@[simps]\ndef skyscraperPresheafCocone (y : X) : Cocone ((OpenNhds.inclusion y).op \u22d9 skyscraperPresheaf p\u2080 A)\n    where\n  pt := terminal C\n  \u03b9 :=\n    { app := fun _ => terminal.from _\n      naturality := fun _ _ _ => terminalIsTerminal.hom_ext _ _ }", "start": [177, 1], "end": [185, 66], "kind": "commanddeclaration"}, {"full_name": "skyscraperPresheafCoconeIsColimitOfNotSpecializes", "code": "noncomputable def skyscraperPresheafCoconeIsColimitOfNotSpecializes {y : X} (h : \u00acp\u2080 \u2933 y) :\n    IsColimit (skyscraperPresheafCocone p\u2080 A y) :=\n  let h1 : \u2203 U : OpenNhds y, p\u2080 \u2209 U.1 :=\n    let \u27e8U, ho, h\u2080, hy\u27e9 := not_specializes_iff_exists_open.mp h\n    \u27e8\u27e8\u27e8U, ho\u27e9, h\u2080\u27e9, hy\u27e9\n  { desc := fun c => eqToHom (if_neg h1.choose_spec).symm \u226b c.\u03b9.app (op h1.choose)\n    fac := fun c U => by\n      change _ = c.\u03b9.app (op U.unop)\n      simp only [\u2190 c.w (homOfLE <| @inf_le_left _ _ h1.choose U.unop).op, \u2190\n        c.w (homOfLE <| @inf_le_right _ _ h1.choose U.unop).op, \u2190 Category.assoc]\n      congr 1\n      refine' ((if_neg _).symm.ndrec terminalIsTerminal).hom_ext _ _\n      exact fun h => h1.choose_spec h.1\n    uniq := fun c f H => by\n      dsimp rw [\u2190 Category.id_comp f, \u2190 H, \u2190 Category.assoc]\n      congr 1; apply terminalIsTerminal.hom_ext }", "start": [188, 1], "end": [208, 50], "kind": "commanddeclaration"}, {"full_name": "skyscraperPresheafStalkOfNotSpecializes", "code": "noncomputable def skyscraperPresheafStalkOfNotSpecializes [HasColimits C] {y : X} (h : \u00acp\u2080 \u2933 y) :\n    (skyscraperPresheaf p\u2080 A).stalk y \u2245 terminal C :=\n  colimit.isoColimitCocone \u27e8_, skyscraperPresheafCoconeIsColimitOfNotSpecializes _ A h\u27e9", "start": [211, 1], "end": [216, 88], "kind": "commanddeclaration"}, {"full_name": "skyscraperPresheafStalkOfNotSpecializesIsTerminal", "code": "def skyscraperPresheafStalkOfNotSpecializesIsTerminal [HasColimits C] {y : X} (h : \u00acp\u2080 \u2933 y) :\n    IsTerminal ((skyscraperPresheaf p\u2080 A).stalk y) :=\n  IsTerminal.ofIso terminalIsTerminal <| (skyscraperPresheafStalkOfNotSpecializes _ _ h).symm", "start": [219, 1], "end": [223, 94], "kind": "commanddeclaration"}, {"full_name": "skyscraperPresheaf_isSheaf", "code": "theorem skyscraperPresheaf_isSheaf : (skyscraperPresheaf p\u2080 A).IsSheaf", "start": [226, 1], "end": [234, 50], "kind": "commanddeclaration"}, {"full_name": "skyscraperSheaf", "code": "def skyscraperSheaf : Sheaf C X :=\n  \u27e8skyscraperPresheaf p\u2080 A, skyscraperPresheaf_isSheaf _ _\u27e9", "start": [237, 1], "end": [242, 60], "kind": "commanddeclaration"}, {"full_name": "skyscraperSheafFunctor", "code": "def skyscraperSheafFunctor : C \u2964 Sheaf C X where\n  obj c := skyscraperSheaf p\u2080 c\n  map f := Sheaf.Hom.mk <| (skyscraperPresheafFunctor p\u2080).map f\n  map_id _ := Sheaf.Hom.ext _ _ <| (skyscraperPresheafFunctor p\u2080).map_id _\n  map_comp _ _ := Sheaf.Hom.ext _ _ <| (skyscraperPresheafFunctor p\u2080).map_comp _ _", "start": [245, 1], "end": [253, 83], "kind": "commanddeclaration"}, {"full_name": "StalkSkyscraperPresheafAdjunctionAuxs.toSkyscraperPresheaf", "code": "@[simps]\ndef toSkyscraperPresheaf {\ud835\udcd5 : Presheaf C X} {c : C} (f : \ud835\udcd5.stalk p\u2080 \u27f6 c) :\n    \ud835\udcd5 \u27f6 skyscraperPresheaf p\u2080 c where\n  app U :=\n    if h : p\u2080 \u2208 U.unop then \ud835\udcd5.germ \u27e8p\u2080, h\u27e9 \u226b f \u226b eqToHom (if_pos h).symm\n    else ((if_neg h).symm.ndrec terminalIsTerminal).from _\n  naturality U V inc := by\n    dsimp; by_cases hV : p\u2080 \u2208 V.unop\n    \u00b7 have hU : p\u2080 \u2208 U.unop := leOfHom inc.unop hV; split_ifs\n      erw [\u2190 Category.assoc, \ud835\udcd5.germ_res inc.unop, Category.assoc, Category.assoc, eqToHom_trans]\n      aesop_cat\n    \u00b7 split_ifs; apply ((if_neg hV).symm.ndrec terminalIsTerminal).hom_ext; aesop_cat", "start": [260, 1], "end": [277, 86], "kind": "commanddeclaration"}, {"full_name": "StalkSkyscraperPresheafAdjunctionAuxs.fromStalk", "code": "def fromStalk {\ud835\udcd5 : Presheaf C X} {c : C} (f : \ud835\udcd5 \u27f6 skyscraperPresheaf p\u2080 c) : \ud835\udcd5.stalk p\u2080 \u27f6 c :=\n  let \u03c7 : Cocone ((OpenNhds.inclusion p\u2080).op \u22d9 \ud835\udcd5) :=\n    Cocone.mk c <|\n      { app := fun U => f.app (op U.unop.1) \u226b eqToHom (if_pos U.unop.2)\n        naturality := fun U V inc => by\n          dsimp\n          erw [Category.comp_id, \u2190 Category.assoc, comp_eqToHom_iff, Category.assoc,\n            eqToHom_trans, f.naturality, skyscraperPresheaf_map]\n          dsimp only [skyscraperPresheaf_obj, unop_op, Eq.ndrec]\n          have hV : p\u2080 \u2208 (OpenNhds.inclusion p\u2080).obj V.unop := V.unop.2; split_ifs <;>\n          simp only [comp_eqToHom_iff, Category.assoc, eqToHom_trans, eqToHom_refl,\n            Category.comp_id] <;> rfl }\n  colimit.desc _ \u03c7", "start": [280, 1], "end": [296, 19], "kind": "commanddeclaration"}, {"full_name": "StalkSkyscraperPresheafAdjunctionAuxs.to_skyscraper_fromStalk", "code": "theorem to_skyscraper_fromStalk {\ud835\udcd5 : Presheaf C X} {c : C} (f : \ud835\udcd5 \u27f6 skyscraperPresheaf p\u2080 c) :\n    toSkyscraperPresheaf p\u2080 (fromStalk _ f) = f", "start": [299, 1], "end": [309, 95], "kind": "commanddeclaration"}, {"full_name": "StalkSkyscraperPresheafAdjunctionAuxs.fromStalk_to_skyscraper", "code": "theorem fromStalk_to_skyscraper {\ud835\udcd5 : Presheaf C X} {c : C} (f : \ud835\udcd5.stalk p\u2080 \u27f6 c) :\n    fromStalk p\u2080 (toSkyscraperPresheaf _ f) = f", "start": [312, 1], "end": [318, 12], "kind": "commanddeclaration"}, {"full_name": "StalkSkyscraperPresheafAdjunctionAuxs.unit", "code": "@[simps]\nprotected def unit : \ud835\udfed (Presheaf C X) \u27f6 Presheaf.stalkFunctor C p\u2080 \u22d9 skyscraperPresheafFunctor p\u2080\n    where\n  app \ud835\udcd5 := toSkyscraperPresheaf _ <| \ud835\udfd9 _\n  naturality \ud835\udcd5 \ud835\udcd6 f := by\n    ext U; dsimp\n    rw [NatTrans.comp_app, toSkyscraperPresheaf_app, NatTrans.comp_app, toSkyscraperPresheaf_app]\n    dsimp only [skyscraperPresheaf_obj, unop_op, Eq.ndrec, SkyscraperPresheafFunctor.map'_app]\n    split_ifs with h\n    \u00b7 simp only [Category.id_comp, \u2190 Category.assoc]; rw [comp_eqToHom_iff]\n      simp only [Category.assoc, eqToHom_trans, eqToHom_refl, Category.comp_id]\n      erw [colimit.\u03b9_map]; rfl\n    \u00b7 apply ((if_neg h).symm.ndrec terminalIsTerminal).hom_ext", "start": [321, 1], "end": [336, 63], "kind": "commanddeclaration"}, {"full_name": "StalkSkyscraperPresheafAdjunctionAuxs.counit", "code": "@[simps]\nprotected def counit :\n    skyscraperPresheafFunctor p\u2080 \u22d9 (Presheaf.stalkFunctor C p\u2080 : Presheaf C X \u2964 C) \u27f6 \ud835\udfed C where\n  app c := (skyscraperPresheafStalkOfSpecializes p\u2080 c specializes_rfl).hom\n  naturality x y f := colimit.hom_ext fun U => by\n    erw [\u2190 Category.assoc, colimit.\u03b9_map, colimit.isoColimitCocone_\u03b9_hom_assoc,\n      skyscraperPresheafCoconeOfSpecializes_\u03b9_app (h := specializes_rfl), Category.assoc,\n      colimit.\u03b9_desc, whiskeringLeft_obj_map, whiskerLeft_app, SkyscraperPresheafFunctor.map'_app,\n      dif_pos U.unop.2, skyscraperPresheafCoconeOfSpecializes_\u03b9_app (h := specializes_rfl),\n      comp_eqToHom_iff, Category.assoc, eqToHom_comp_iff, \u2190 Category.assoc, eqToHom_trans,\n      eqToHom_refl, Category.id_comp, comp_eqToHom_iff, Category.assoc, eqToHom_trans, eqToHom_refl,\n      Category.comp_id, CategoryTheory.Functor.id_map]", "start": [339, 1], "end": [352, 55], "kind": "commanddeclaration"}, {"full_name": "skyscraperPresheafStalkAdjunction", "code": "def skyscraperPresheafStalkAdjunction [HasColimits C] :\n    (Presheaf.stalkFunctor C p\u2080 : Presheaf C X \u2964 C) \u22a3 skyscraperPresheafFunctor p\u2080 where\n  homEquiv c \ud835\udcd5 :=\n    { toFun := toSkyscraperPresheaf _\n      invFun := fromStalk _\n      left_inv := fromStalk_to_skyscraper _\n      right_inv := to_skyscraper_fromStalk _ }\n  unit := StalkSkyscraperPresheafAdjunctionAuxs.unit _\n  counit := StalkSkyscraperPresheafAdjunctionAuxs.counit _\n  homEquiv_unit {\ud835\udcd5} c \u03b1 := by\n    ext U;\n    rw [NatTrans.comp_app]\n    simp only [Equiv.coe_fn_mk, toSkyscraperPresheaf_app, SkyscraperPresheafFunctor.map'_app,\n      skyscraperPresheafFunctor_map, unit_app]\n    split_ifs with h\n    \u00b7 erw [Category.id_comp, \u2190 Category.assoc, comp_eqToHom_iff, Category.assoc, Category.assoc,\n        Category.assoc, Category.assoc, eqToHom_trans, eqToHom_refl, Category.comp_id, \u2190\n        Category.assoc _ _ \u03b1, eqToHom_trans, eqToHom_refl, Category.id_comp]\n    \u00b7 apply ((if_neg h).symm.ndrec terminalIsTerminal).hom_ext\n  homEquiv_counit {\ud835\udcd5} c \u03b1 := by\n    dsimp; ext U; simp only [Equiv.coe_fn_symm_mk, counit_app]\n    erw [colimit.\u03b9_desc, \u2190 Category.assoc, colimit.\u03b9_map, whiskerLeft_app, Category.assoc,\n      colimit.\u03b9_desc]\n    rfl", "start": [361, 1], "end": [388, 8], "kind": "commanddeclaration"}, {"full_name": "stalkSkyscraperSheafAdjunction", "code": "def stalkSkyscraperSheafAdjunction [HasColimits C] :\n    Sheaf.forget C X \u22d9 Presheaf.stalkFunctor _ p\u2080 \u22a3 skyscraperSheafFunctor p\u2080 where\n  homEquiv \ud835\udcd5 c :=\n    \u27e8fun f => \u27e8toSkyscraperPresheaf p\u2080 f\u27e9, fun g => fromStalk p\u2080 g.1, fromStalk_to_skyscraper p\u2080,\n      fun g => Sheaf.Hom.ext _ _ <| to_skyscraper_fromStalk _ _\u27e9\n  unit :=\n    { app := fun \ud835\udcd5 => \u27e8(StalkSkyscraperPresheafAdjunctionAuxs.unit p\u2080).app \ud835\udcd5.1\u27e9\n      naturality := fun \ud835\udcd0 \ud835\udcd1 f => Sheaf.Hom.ext _ _ <| by\n        apply (StalkSkyscraperPresheafAdjunctionAuxs.unit p\u2080).naturality }\n  counit := StalkSkyscraperPresheafAdjunctionAuxs.counit p\u2080\n  homEquiv_unit {\ud835\udcd0} c f := Sheaf.Hom.ext _ _ (skyscraperPresheafStalkAdjunction p\u2080).homEquiv_unit\n  homEquiv_counit {\ud835\udcd0} c f := (skyscraperPresheafStalkAdjunction p\u2080).homEquiv_counit", "start": [397, 1], "end": [412, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/RingHom/Integral.lean", "imports": ["Mathlib/RingTheory/IntegralClosure.lean", "Mathlib/RingTheory/RingHomProperties.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RingHom.isIntegral_stableUnderComposition", "code": "theorem isIntegral_stableUnderComposition : StableUnderComposition fun f => f.IsIntegral", "start": [24, 1], "end": [25, 59], "kind": "commanddeclaration"}, {"full_name": "RingHom.isIntegral_respectsIso", "code": "theorem isIntegral_respectsIso : RespectsIso fun f => f.IsIntegral", "start": [28, 1], "end": [32, 32], "kind": "commanddeclaration"}, {"full_name": "RingHom.isIntegral_stableUnderBaseChange", "code": "theorem isIntegral_stableUnderBaseChange : StableUnderBaseChange fun f => f.IsIntegral", "start": [35, 1], "end": [41, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Stirling.lean", "imports": ["Mathlib/Data/Real/Pi/Wallis.lean", "Mathlib/Analysis/PSeries.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Stirling.stirlingSeq", "code": "noncomputable def stirlingSeq (n : \u2115) : \u211d :=\n  n ! / (Real.sqrt (2 * n) * (n / exp 1) ^ n)", "start": [49, 1], "end": [53, 46], "kind": "commanddeclaration"}, {"full_name": "Stirling.stirlingSeq_zero", "code": "@[simp]\ntheorem stirlingSeq_zero : stirlingSeq 0 = 0", "start": [56, 1], "end": [59, 14], "kind": "commanddeclaration"}, {"full_name": "Stirling.stirlingSeq_one", "code": "@[simp]\ntheorem stirlingSeq_one : stirlingSeq 1 = exp 1 / Real.sqrt 2", "start": [62, 1], "end": [64, 88], "kind": "commanddeclaration"}, {"full_name": "Stirling.log_stirlingSeq_formula", "code": "theorem log_stirlingSeq_formula (n : \u2115) :\n    log (stirlingSeq n) = Real.log n ! - 1 / 2 * Real.log (2 * n) - n * log (n / exp 1)", "start": [67, 1], "end": [72, 21], "kind": "commanddeclaration"}, {"full_name": "Stirling.log_stirlingSeq_diff_hasSum", "code": "theorem log_stirlingSeq_diff_hasSum (m : \u2115) :\n    HasSum (fun k : \u2115 => \u21911 / (\u21912 * \u2191(k + 1) + \u21911) * (((1:\u211d)/(\u21912 * \u2191(m + 1) + \u21911)) ^ 2) ^ \u2191(k + 1))\n      (log (stirlingSeq (m + 1)) - log (stirlingSeq (m + 2)))", "start": [76, 1], "end": [98, 9], "kind": "commanddeclaration"}, {"full_name": "Stirling.log_stirlingSeq'_antitone", "code": "theorem log_stirlingSeq'_antitone : Antitone (Real.log \u2218 stirlingSeq \u2218 succ)", "start": [101, 1], "end": [104, 83], "kind": "commanddeclaration"}, {"full_name": "Stirling.log_stirlingSeq_diff_le_geo_sum", "code": "theorem log_stirlingSeq_diff_le_geo_sum (n : \u2115) :\n    log (stirlingSeq (n + 1)) - log (stirlingSeq (n + 2)) \u2264\n      ((1:\u211d) / (2 * \u2191(n + 1) + 1)) ^ 2 / (\u21911 - ((1:\u211d) / (2 * \u2191(n + 1) + 1)) ^ 2)", "start": [107, 1], "end": [125, 56], "kind": "commanddeclaration"}, {"full_name": "Stirling.log_stirlingSeq_sub_log_stirlingSeq_succ", "code": "theorem log_stirlingSeq_sub_log_stirlingSeq_succ (n : \u2115) :\n    log (stirlingSeq (n + 1)) - log (stirlingSeq (n + 2)) \u2264 1 / (4 * (\u2191(n + 1):\u211d) ^ 2)", "start": [128, 1], "end": [145, 11], "kind": "commanddeclaration"}, {"full_name": "Stirling.log_stirlingSeq_bounded_aux", "code": "theorem log_stirlingSeq_bounded_aux :\n    \u2203 c : \u211d, \u2200 n : \u2115, log (stirlingSeq 1) - log (stirlingSeq (n + 1)) \u2264 c", "start": [148, 1], "end": [169, 67], "kind": "commanddeclaration"}, {"full_name": "Stirling.log_stirlingSeq_bounded_by_constant", "code": "theorem log_stirlingSeq_bounded_by_constant : \u2203 c, \u2200 n : \u2115, c \u2264 log (stirlingSeq (n + 1))", "start": [172, 1], "end": [175, 65], "kind": "commanddeclaration"}, {"full_name": "Stirling.stirlingSeq'_pos", "code": "theorem stirlingSeq'_pos (n : \u2115) : 0 < stirlingSeq (n + 1)", "start": [178, 1], "end": [179, 96], "kind": "commanddeclaration"}, {"full_name": "Stirling.stirlingSeq'_bounded_by_pos_constant", "code": "theorem stirlingSeq'_bounded_by_pos_constant : \u2203 a, 0 < a \u2227 \u2200 n : \u2115, a \u2264 stirlingSeq (n + 1)", "start": [182, 1], "end": [188, 12], "kind": "commanddeclaration"}, {"full_name": "Stirling.stirlingSeq'_antitone", "code": "theorem stirlingSeq'_antitone : Antitone (stirlingSeq \u2218 succ)", "start": [191, 1], "end": [193, 90], "kind": "commanddeclaration"}, {"full_name": "Stirling.stirlingSeq_has_pos_limit_a", "code": "theorem stirlingSeq_has_pos_limit_a : \u2203 a : \u211d, 0 < a \u2227 Tendsto stirlingSeq atTop (\ud835\udcdd a)", "start": [196, 1], "end": [202, 59], "kind": "commanddeclaration"}, {"full_name": "Stirling.tendsto_self_div_two_mul_self_add_one", "code": "theorem tendsto_self_div_two_mul_self_add_one :\n    Tendsto (fun n : \u2115 => (n : \u211d) / (2 * n + 1)) atTop (\ud835\udcdd (1 / 2))", "start": [211, 1], "end": [221, 83], "kind": "commanddeclaration"}, {"full_name": "Stirling.stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq", "code": "theorem stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq (n : \u2115) (hn : n \u2260 0) :\n    stirlingSeq n ^ 4 / stirlingSeq (2 * n) ^ 2 * (n / (2 * n + 1)) = Wallis.W n", "start": [224, 1], "end": [234, 19], "kind": "commanddeclaration"}, {"full_name": "Stirling.second_wallis_limit", "code": "theorem second_wallis_limit (a : \u211d) (hane : a \u2260 0) (ha : Tendsto stirlingSeq atTop (\ud835\udcdd a)) :\n    Tendsto Wallis.W atTop (\ud835\udcdd (a ^ 2 / 2))", "start": [237, 1], "end": [249, 68], "kind": "commanddeclaration"}, {"full_name": "Stirling.tendsto_stirlingSeq_sqrt_pi", "code": "theorem tendsto_stirlingSeq_sqrt_pi : Tendsto (fun n : \u2115 => stirlingSeq n) atTop (\ud835\udcdd (sqrt \u03c0))", "start": [252, 1], "end": [257, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Preadditive/EilenbergMoore.lean", "imports": ["Mathlib/CategoryTheory/Monad/Algebra.lean", "Mathlib/CategoryTheory/Preadditive/Basic.lean", "Mathlib/CategoryTheory/Preadditive/AdditiveFunctor.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Monad.algebraPreadditive", "code": "@[simps]\ninstance Monad.algebraPreadditive : Preadditive (Monad.Algebra T) where\n  homGroup F G :=\n    { add := fun \u03b1 \u03b2 =>\n        { f := \u03b1.f + \u03b2.f\n          h := by simp only [Functor.map_add, add_comp, Monad.Algebra.Hom.h, comp_add] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n \u03b1 =>\n        { f := n \u2022 \u03b1.f\n          h := by rw [Functor.map_nsmul, nsmul_comp, Monad.Algebra.Hom.h, comp_nsmul] }\n      neg := fun \u03b1 =>\n        { f := -\u03b1.f\n          h := by simp only [Functor.map_neg, neg_comp, Monad.Algebra.Hom.h, comp_neg] }\n      sub := fun \u03b1 \u03b2 =>\n        { f := \u03b1.f - \u03b2.f\n          h := by simp only [Functor.map_sub, sub_comp, Monad.Algebra.Hom.h, comp_sub] }\n      zsmul := fun r \u03b1 =>\n        { f := r \u2022 \u03b1.f\n          h := by rw [Functor.map_zsmul, zsmul_comp, Monad.Algebra.Hom.h, comp_zsmul] }\n      add_assoc := by\n        intros\n        ext\n        apply add_assoc\n      zero_add := by\n        intros\n        ext\n        apply zero_add\n      add_zero := by\n        intros\n        ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        ext\n        dsimp\n        simp only [coe_nat_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        ext\n        simp only [negSucc_zsmul, neg_inj, nsmul_eq_smul_cast \u2124]\n      add_left_neg := by\n        intros\n        ext\n        apply add_left_neg\n      add_comm := by\n        intros\n        ext\n        apply add_comm }\n  add_comp := by\n    intros\n    ext\n    apply add_comp\n  comp_add := by\n    intros\n    ext\n    apply comp_add", "start": [30, 1], "end": [105, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.forget_additive", "code": "instance Monad.forget_additive : (Monad.forget T).Additive where", "start": [108, 1], "end": [108, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comonad.coalgebraPreadditive", "code": "@[simps]\ninstance Comonad.coalgebraPreadditive : Preadditive (Comonad.Coalgebra U) where\n  homGroup F G :=\n    { add := fun \u03b1 \u03b2 =>\n        { f := \u03b1.f + \u03b2.f\n          h := by simp only [Functor.map_add, comp_add, Comonad.Coalgebra.Hom.h, add_comp] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, comp_zero, zero_comp] }\n      nsmul := fun n \u03b1 =>\n        { f := n \u2022 \u03b1.f\n          h := by rw [Functor.map_nsmul, comp_nsmul, Comonad.Coalgebra.Hom.h, nsmul_comp] }\n      neg := fun \u03b1 =>\n        { f := -\u03b1.f\n          h := by simp only [Functor.map_neg, comp_neg, Comonad.Coalgebra.Hom.h, neg_comp] }\n      sub := fun \u03b1 \u03b2 =>\n        { f := \u03b1.f - \u03b2.f\n          h := by simp only [Functor.map_sub, comp_sub, Comonad.Coalgebra.Hom.h, sub_comp] }\n      zsmul := fun r \u03b1 =>\n        { f := r \u2022 \u03b1.f\n          h := by rw [Functor.map_zsmul, comp_zsmul, Comonad.Coalgebra.Hom.h, zsmul_comp] }\n      add_assoc := by\n        intros\n        ext\n        apply add_assoc\n      zero_add := by\n        intros\n        ext\n        apply zero_add\n      add_zero := by\n        intros\n        ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        ext\n        dsimp\n        simp only [coe_nat_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        ext\n        simp only [negSucc_zsmul, neg_inj, nsmul_eq_smul_cast \u2124]\n      add_left_neg := by\n        intros\n        ext\n        apply add_left_neg\n      add_comm := by\n        intros\n        ext\n        apply add_comm }\n  add_comp := by\n    intros\n    ext\n    apply add_comp\n  comp_add := by\n    intros\n    ext\n    apply comp_add", "start": [113, 1], "end": [188, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comonad.forget_additive", "code": "instance Comonad.forget_additive : (Comonad.forget U).Additive where", "start": [191, 1], "end": [191, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Dynamics/Ergodic/Function.lean", "imports": ["Mathlib/MeasureTheory/Function/AEEqFun.lean", "Mathlib/Dynamics/Ergodic/Ergodic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "QuasiErgodic.ae_eq_const_of_ae_eq_comp_of_ae_range\u2080", "code": "theorem QuasiErgodic.ae_eq_const_of_ae_eq_comp_of_ae_range\u2080 [Nonempty X] [MeasurableSpace X]\n    {s : Set X} [HasCountableSeparatingOn X MeasurableSet s] {f : \u03b1 \u2192 \u03b1} {g : \u03b1 \u2192 X}\n    (h : QuasiErgodic f \u03bc) (hs : \u2200\u1d50 x \u2202\u03bc, g x \u2208 s) (hgm : NullMeasurable g \u03bc)\n    (hg_eq : g \u2218 f =\u1d50[\u03bc] g) :\n    \u2203 c, g =\u1d50[\u03bc] const \u03b1 c", "start": [23, 1], "end": [35, 55], "kind": "commanddeclaration"}, {"full_name": "PreErgodic.ae_eq_const_of_ae_eq_comp", "code": "theorem PreErgodic.ae_eq_const_of_ae_eq_comp (h : PreErgodic f \u03bc) (hgm : Measurable g)\n    (hg_eq : g \u2218 f = g) : \u2203 c, g =\u1d50[\u03bc] const \u03b1 c", "start": [42, 1], "end": [49, 82], "kind": "commanddeclaration"}, {"full_name": "QuasiErgodic.ae_eq_const_of_ae_eq_comp\u2080", "code": "theorem QuasiErgodic.ae_eq_const_of_ae_eq_comp\u2080 (h : QuasiErgodic f \u03bc) (hgm : NullMeasurable g \u03bc)\n    (hg_eq : g \u2218 f =\u1d50[\u03bc] g) : \u2203 c, g =\u1d50[\u03bc] const \u03b1 c", "start": [51, 1], "end": [57, 74], "kind": "commanddeclaration"}, {"full_name": "Ergodic.ae_eq_const_of_ae_eq_comp\u2080", "code": "theorem Ergodic.ae_eq_const_of_ae_eq_comp\u2080 (h : Ergodic f \u03bc) (hgm : NullMeasurable g \u03bc)\n    (hg_eq : g \u2218 f =\u1d50[\u03bc] g) : \u2203 c, g =\u1d50[\u03bc] const \u03b1 c", "start": [59, 1], "end": [65, 54], "kind": "commanddeclaration"}, {"full_name": "QuasiErgodic.ae_eq_const_of_ae_eq_comp_ae", "code": "theorem ae_eq_const_of_ae_eq_comp_ae {g : \u03b1 \u2192 X} (h : QuasiErgodic f \u03bc)\n    (hgm : AEStronglyMeasurable g \u03bc) (hg_eq : g \u2218 f =\u1d50[\u03bc] g) : \u2203 c, g =\u1d50[\u03bc] const \u03b1 c", "start": [73, 1], "end": [82, 91], "kind": "commanddeclaration"}, {"full_name": "QuasiErgodic.eq_const_of_compQuasiMeasurePreserving_eq", "code": "theorem eq_const_of_compQuasiMeasurePreserving_eq (h : QuasiErgodic f \u03bc) {g : \u03b1 \u2192\u2098[\u03bc] X}\n    (hg_eq : g.compQuasiMeasurePreserving f h.1 = g) : \u2203 c, g = .const \u03b1 c", "start": [84, 1], "end": [89, 62], "kind": "commanddeclaration"}, {"full_name": "Ergodic.ae_eq_const_of_ae_eq_comp_ae", "code": "theorem ae_eq_const_of_ae_eq_comp_ae {g : \u03b1 \u2192 X} (h : Ergodic f \u03bc) (hgm : AEStronglyMeasurable g \u03bc)\n    (hg_eq : g \u2218 f =\u1d50[\u03bc] g) : \u2203 c, g =\u1d50[\u03bc] const \u03b1 c", "start": [95, 1], "end": [101, 56], "kind": "commanddeclaration"}, {"full_name": "Ergodic.eq_const_of_compMeasurePreserving_eq", "code": "theorem eq_const_of_compMeasurePreserving_eq (h : Ergodic f \u03bc) {g : \u03b1 \u2192\u2098[\u03bc] X}\n    (hg_eq : g.compMeasurePreserving f h.1 = g) : \u2203 c, g = .const \u03b1 c", "start": [103, 1], "end": [105, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/Fold.lean", "imports": ["Mathlib/CategoryTheory/Endomorphism.lean", "Mathlib/CategoryTheory/Category/KleisliCat.lean", "Mathlib/Control/Traversable/Lemmas.lean", "Mathlib/Algebra/Group/Opposite.lean", "Mathlib/CategoryTheory/Types.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/FreeMonoid/Basic.lean", "Mathlib/Control/Traversable/Instances.lean"], "premises": [{"full_name": "Monoid.Foldl", "code": "@[reducible]\ndef Foldl (\u03b1 : Type u) : Type u :=\n  (End \u03b1)\u1d50\u1d52\u1d56", "start": [67, 1], "end": [109, 13], "kind": "commanddeclaration"}, {"full_name": "Monoid.Foldl.mk", "code": "def Foldl.mk (f : \u03b1 \u2192 \u03b1) : Foldl \u03b1 :=\n  op f", "start": [112, 1], "end": [113, 7], "kind": "commanddeclaration"}, {"full_name": "Monoid.Foldl.get", "code": "def Foldl.get (x : Foldl \u03b1) : \u03b1 \u2192 \u03b1 :=\n  unop x", "start": [116, 1], "end": [117, 9], "kind": "commanddeclaration"}, {"full_name": "Monoid.Foldl.ofFreeMonoid", "code": "@[simps]\ndef Foldl.ofFreeMonoid (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) : FreeMonoid \u03b1 \u2192* Monoid.Foldl \u03b2\n    where\n  toFun xs := op <| flip (List.foldl f) (FreeMonoid.toList xs)\n  map_one' := rfl\n  map_mul' := by\n    intros; simp only [FreeMonoid.toList_mul, flip, unop_op, List.foldl_append, op_inj]; rfl", "start": [120, 1], "end": [126, 93], "kind": "commanddeclaration"}, {"full_name": "Monoid.Foldr", "code": "@[reducible]\ndef Foldr (\u03b1 : Type u) : Type u :=\n  End \u03b1", "start": [129, 1], "end": [131, 8], "kind": "commanddeclaration"}, {"full_name": "Monoid.Foldr.mk", "code": "def Foldr.mk (f : \u03b1 \u2192 \u03b1) : Foldr \u03b1 :=\n  f", "start": [134, 1], "end": [135, 4], "kind": "commanddeclaration"}, {"full_name": "Monoid.Foldr.get", "code": "def Foldr.get (x : Foldr \u03b1) : \u03b1 \u2192 \u03b1 :=\n  x", "start": [138, 1], "end": [139, 4], "kind": "commanddeclaration"}, {"full_name": "Monoid.Foldr.ofFreeMonoid", "code": "@[simps]\ndef Foldr.ofFreeMonoid (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) : FreeMonoid \u03b1 \u2192* Monoid.Foldr \u03b2\n    where\n  toFun xs := flip (List.foldr f) (FreeMonoid.toList xs)\n  map_one' := rfl\n  map_mul' _ _ := funext fun _ => List.foldr_append _ _ _ _", "start": [142, 1], "end": [147, 60], "kind": "commanddeclaration"}, {"full_name": "Monoid.foldlM", "code": "@[reducible]\ndef foldlM (m : Type u \u2192 Type u) [Monad m] (\u03b1 : Type u) : Type u :=\n  MulOpposite <| End <| KleisliCat.mk m \u03b1", "start": [150, 1], "end": [152, 42], "kind": "commanddeclaration"}, {"full_name": "Monoid.foldlM.mk", "code": "def foldlM.mk (f : \u03b1 \u2192 m \u03b1) : foldlM m \u03b1 :=\n  op f", "start": [155, 1], "end": [156, 7], "kind": "commanddeclaration"}, {"full_name": "Monoid.foldlM.get", "code": "def foldlM.get (x : foldlM m \u03b1) : \u03b1 \u2192 m \u03b1 :=\n  unop x", "start": [159, 1], "end": [160, 9], "kind": "commanddeclaration"}, {"full_name": "Monoid.foldlM.ofFreeMonoid", "code": "@[simps]\ndef foldlM.ofFreeMonoid [LawfulMonad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) : FreeMonoid \u03b1 \u2192* Monoid.foldlM m \u03b2\n    where\n  toFun xs := op <| flip (List.foldlM f) (FreeMonoid.toList xs)\n  map_one' := rfl\n  map_mul' := by intros; apply unop_injective; funext; apply List.foldlM_append", "start": [163, 1], "end": [168, 80], "kind": "commanddeclaration"}, {"full_name": "Monoid.foldrM", "code": "@[reducible]\ndef foldrM (m : Type u \u2192 Type u) [Monad m] (\u03b1 : Type u) : Type u :=\n  End <| KleisliCat.mk m \u03b1", "start": [171, 1], "end": [173, 27], "kind": "commanddeclaration"}, {"full_name": "Monoid.foldrM.mk", "code": "def foldrM.mk (f : \u03b1 \u2192 m \u03b1) : foldrM m \u03b1 :=\n  f", "start": [176, 1], "end": [177, 4], "kind": "commanddeclaration"}, {"full_name": "Monoid.foldrM.get", "code": "def foldrM.get (x : foldrM m \u03b1) : \u03b1 \u2192 m \u03b1 :=\n  x", "start": [180, 1], "end": [181, 4], "kind": "commanddeclaration"}, {"full_name": "Monoid.foldrM.ofFreeMonoid", "code": "@[simps]\ndef foldrM.ofFreeMonoid [LawfulMonad m] (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) : FreeMonoid \u03b1 \u2192* Monoid.foldrM m \u03b2\n    where\n  toFun xs := flip (List.foldrM f) (FreeMonoid.toList xs)\n  map_one' := rfl\n  map_mul' := by intros; funext; apply List.foldrM_append", "start": [184, 1], "end": [189, 58], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldMap", "code": "def foldMap {\u03b1 \u03c9} [One \u03c9] [Mul \u03c9] (f : \u03b1 \u2192 \u03c9) : t \u03b1 \u2192 \u03c9 :=\n  traverse (Const.mk' \u2218 f)", "start": [202, 1], "end": [203, 27], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldl", "code": "def foldl (f : \u03b1 \u2192 \u03b2 \u2192 \u03b1) (x : \u03b1) (xs : t \u03b2) : \u03b1 :=\n  (foldMap (Foldl.mk \u2218 flip f) xs).get x", "start": [206, 1], "end": [207, 41], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldr", "code": "def foldr (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (x : \u03b2) (xs : t \u03b1) : \u03b2 :=\n  (foldMap (Foldr.mk \u2218 f) xs).get x", "start": [210, 1], "end": [211, 36], "kind": "commanddeclaration"}, {"full_name": "Traversable.toList", "code": "def toList : t \u03b1 \u2192 List \u03b1 :=\n  List.reverse \u2218 foldl (flip List.cons) []", "start": [214, 1], "end": [231, 43], "kind": "commanddeclaration"}, {"full_name": "Traversable.length", "code": "def length (xs : t \u03b1) : \u2115 :=\n  down <| foldl (fun l _ => up <| l.down + 1) (up 0) xs", "start": [234, 1], "end": [235, 56], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldlm", "code": "def foldlm (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b1) (x : \u03b1) (xs : t \u03b2) : m \u03b1 :=\n  (foldMap (foldlM.mk \u2218 flip f) xs).get x", "start": [240, 1], "end": [241, 42], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldrm", "code": "def foldrm (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (x : \u03b2) (xs : t \u03b1) : m \u03b2 :=\n  (foldMap (foldrM.mk \u2218 f) xs).get x", "start": [244, 1], "end": [245, 37], "kind": "commanddeclaration"}, {"full_name": "Traversable.mapFold", "code": "def mapFold [Monoid \u03b1] [Monoid \u03b2] (f : \u03b1 \u2192* \u03b2) : ApplicativeTransformation (Const \u03b1) (Const \u03b2)\n    where\n  app _ := f\n  preserves_seq' := by intros; simp only [Seq.seq, map_mul]\n  preserves_pure' := by intros; simp only [map_one, pure]", "start": [256, 1], "end": [260, 58], "kind": "commanddeclaration"}, {"full_name": "Traversable.Free.map_eq_map", "code": "theorem Free.map_eq_map (f : \u03b1 \u2192 \u03b2) (xs : List \u03b1) :\n    f <$> xs = (FreeMonoid.toList (FreeMonoid.map f (FreeMonoid.ofList xs)))", "start": [263, 1], "end": [265, 6], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldl.unop_ofFreeMonoid", "code": "theorem foldl.unop_ofFreeMonoid (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (xs : FreeMonoid \u03b1) (a : \u03b2) :\n    unop (Foldl.ofFreeMonoid f xs) a = List.foldl f a (FreeMonoid.toList xs)", "start": [268, 1], "end": [270, 6], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldMap_hom", "code": "theorem foldMap_hom [Monoid \u03b1] [Monoid \u03b2] (f : \u03b1 \u2192* \u03b2) (g : \u03b3 \u2192 \u03b1) (x : t \u03b3) :\n    f (foldMap g x) = foldMap (f \u2218 g) x", "start": [279, 1], "end": [285, 33], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldMap_hom_free", "code": "theorem foldMap_hom_free [Monoid \u03b2] (f : FreeMonoid \u03b1 \u2192* \u03b2) (x : t \u03b1) :\n    f (foldMap FreeMonoid.of x) = foldMap (f \u2218 FreeMonoid.of) x", "start": [288, 1], "end": [290, 20], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldl.ofFreeMonoid_comp_of", "code": "@[simp]\ntheorem foldl.ofFreeMonoid_comp_of (f : \u03b1 \u2192 \u03b2 \u2192 \u03b1) :\n    Foldl.ofFreeMonoid f \u2218 FreeMonoid.of = Foldl.mk \u2218 flip f", "start": [305, 1], "end": [308, 6], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldr.ofFreeMonoid_comp_of", "code": "@[simp]\ntheorem foldr.ofFreeMonoid_comp_of (f : \u03b2 \u2192 \u03b1 \u2192 \u03b1) :\n    Foldr.ofFreeMonoid f \u2218 FreeMonoid.of = Foldr.mk \u2218 f", "start": [311, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldlm.ofFreeMonoid_comp_of", "code": "@[simp]\ntheorem foldlm.ofFreeMonoid_comp_of {m} [Monad m] [LawfulMonad m] (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b1) :\n    foldlM.ofFreeMonoid f \u2218 FreeMonoid.of = foldlM.mk \u2218 flip f", "start": [317, 1], "end": [322, 6], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldrm.ofFreeMonoid_comp_of", "code": "@[simp]\ntheorem foldrm.ofFreeMonoid_comp_of {m} [Monad m] [LawfulMonad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b1) :\n    foldrM.ofFreeMonoid f \u2218 FreeMonoid.of = foldrM.mk \u2218 f", "start": [325, 1], "end": [329, 55], "kind": "commanddeclaration"}, {"full_name": "Traversable.toList_spec", "code": "theorem toList_spec (xs : t \u03b1) : toList xs = FreeMonoid.toList (foldMap FreeMonoid.of xs)", "start": [332, 1], "end": [345, 36], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldMap_map", "code": "theorem foldMap_map [Monoid \u03b3] (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) (xs : t \u03b1) :\n    foldMap g (f <$> xs) = foldMap (g \u2218 f) xs", "start": [348, 1], "end": [349, 101], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldl_toList", "code": "theorem foldl_toList (f : \u03b1 \u2192 \u03b2 \u2192 \u03b1) (xs : t \u03b2) (x : \u03b1) :\n    foldl f x xs = List.foldl f x (toList xs)", "start": [352, 1], "end": [356, 30], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldr_toList", "code": "theorem foldr_toList (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (xs : t \u03b1) (x : \u03b2) :\n    foldr f x xs = List.foldr f x (toList xs)", "start": [359, 1], "end": [363, 32], "kind": "commanddeclaration"}, {"full_name": "Traversable.toList_map", "code": "theorem toList_map (f : \u03b1 \u2192 \u03b2) (xs : t \u03b1) : toList (f <$> xs) = f <$> toList xs", "start": [366, 1], "end": [368, 32], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldl_map", "code": "@[simp]\ntheorem foldl_map (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b3 \u2192 \u03b1) (a : \u03b1) (l : t \u03b2) :\n    foldl f a (g <$> l) = foldl (fun x y => f x (g y)) a l", "start": [371, 1], "end": [374, 48], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldr_map", "code": "@[simp]\ntheorem foldr_map (g : \u03b2 \u2192 \u03b3) (f : \u03b3 \u2192 \u03b1 \u2192 \u03b1) (a : \u03b1) (l : t \u03b2) :\n    foldr f a (g <$> l) = foldr (f \u2218 g) a l", "start": [377, 1], "end": [379, 96], "kind": "commanddeclaration"}, {"full_name": "Traversable.toList_eq_self", "code": "@[simp]\ntheorem toList_eq_self {xs : List \u03b1} : toList xs = xs", "start": [382, 1], "end": [387, 49], "kind": "commanddeclaration"}, {"full_name": "Traversable.length_toList", "code": "theorem length_toList {xs : t \u03b1} : length xs = List.length (toList xs)", "start": [390, 1], "end": [398, 20], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldlm_toList", "code": "theorem foldlm_toList {f : \u03b1 \u2192 \u03b2 \u2192 m \u03b1} {x : \u03b1} {xs : t \u03b2} :\n    foldlm f x xs = List.foldlM f x (toList xs)", "start": [403, 1], "end": [409, 84], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldrm_toList", "code": "theorem foldrm_toList (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (x : \u03b2) (xs : t \u03b1) :\n    foldrm f x xs = List.foldrM f x (toList xs)", "start": [412, 1], "end": [416, 71], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldlm_map", "code": "@[simp]\ntheorem foldlm_map (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b3 \u2192 m \u03b1) (a : \u03b1) (l : t \u03b2) :\n    foldlm f a (g <$> l) = foldlm (fun x y => f x (g y)) a l", "start": [419, 1], "end": [422, 49], "kind": "commanddeclaration"}, {"full_name": "Traversable.foldrm_map", "code": "@[simp]\ntheorem foldrm_map (g : \u03b2 \u2192 \u03b3) (f : \u03b3 \u2192 \u03b1 \u2192 m \u03b1) (a : \u03b1) (l : t \u03b2) :\n    foldrm f a (g <$> l) = foldrm (f \u2218 g) a l", "start": [425, 1], "end": [427, 99], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Monoid/ToMulBot.lean", "imports": ["Mathlib/Algebra/Order/Monoid/TypeTags.lean", "Mathlib/Algebra/Order/Monoid/WithTop.lean", "Mathlib/Algebra/Order/WithZero.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WithZero.toMulBot", "code": "def toMulBot : WithZero (Multiplicative \u03b1) \u2243* Multiplicative (WithBot \u03b1) :=\n  MulEquiv.refl _", "start": [26, 1], "end": [29, 18], "kind": "commanddeclaration"}, {"full_name": "WithZero.toMulBot_zero", "code": "@[simp]\ntheorem toMulBot_zero : toMulBot (0 : WithZero (Multiplicative \u03b1)) = Multiplicative.ofAdd \u22a5", "start": [32, 1], "end": [34, 6], "kind": "commanddeclaration"}, {"full_name": "WithZero.toMulBot_coe", "code": "@[simp]\ntheorem toMulBot_coe (x : Multiplicative \u03b1) :\n    toMulBot \u2191x = Multiplicative.ofAdd (Multiplicative.toAdd x : WithBot \u03b1)", "start": [37, 1], "end": [40, 6], "kind": "commanddeclaration"}, {"full_name": "WithZero.toMulBot_symm_bot", "code": "@[simp]\ntheorem toMulBot_symm_bot : toMulBot.symm (Multiplicative.ofAdd (\u22a5 : WithBot \u03b1)) = 0", "start": [43, 1], "end": [45, 6], "kind": "commanddeclaration"}, {"full_name": "WithZero.toMulBot_coe_ofAdd", "code": "@[simp]\ntheorem toMulBot_coe_ofAdd (x : \u03b1) :\n    toMulBot.symm (Multiplicative.ofAdd (x : WithBot \u03b1)) = Multiplicative.ofAdd x", "start": [48, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "WithZero.toMulBot_strictMono", "code": "theorem toMulBot_strictMono : StrictMono (@toMulBot \u03b1 _)", "start": [56, 1], "end": [56, 74], "kind": "commanddeclaration"}, {"full_name": "WithZero.toMulBot_le", "code": "@[simp]\ntheorem toMulBot_le : toMulBot a \u2264 toMulBot b \u2194 a \u2264 b", "start": [59, 1], "end": [61, 10], "kind": "commanddeclaration"}, {"full_name": "WithZero.toMulBot_lt", "code": "@[simp]\ntheorem toMulBot_lt : toMulBot a < toMulBot b \u2194 a < b", "start": [64, 1], "end": [66, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/GroupCat/Images.lean", "imports": ["Mathlib/Algebra/Category/GroupCat/Abelian.lean", "Mathlib/CategoryTheory/Limits/Shapes/Images.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddCommGroupCat.image", "code": "def image : AddCommGroupCat :=\n  AddCommGroupCat.of (AddMonoidHom.range f)", "start": [38, 1], "end": [40, 44], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.image.\u03b9", "code": "def image.\u03b9 : image f \u27f6 H :=\n  f.range.subtype", "start": [43, 1], "end": [45, 18], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.factorThruImage", "code": "def factorThruImage : G \u27f6 image f :=\n  f.rangeRestrict", "start": [51, 1], "end": [53, 18], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.image.fac", "code": "theorem image.fac : factorThruImage f \u226b image.\u03b9 f = f", "start": [56, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.image.lift", "code": "noncomputable def image.lift (F' : MonoFactorisation f) : image f \u27f6 F'.I where\n  toFun := (fun x => F'.e (Classical.indefiniteDescription _ x.2).1 : image f \u2192 F'.I)\n  map_zero' := by\n    haveI := F'.m_mono\n    apply injective_of_mono F'.m\n    change (F'.e \u226b F'.m) _ = _\n    rw [F'.fac, AddMonoidHom.map_zero]\n    exact (Classical.indefiniteDescription (fun y => f y = 0) _).2\n  map_add' := by\n    intro x y\n    haveI := F'.m_mono\n    apply injective_of_mono F'.m\n    rw [AddMonoidHom.map_add]\n    change (F'.e \u226b F'.m) _ = (F'.e \u226b F'.m) _ + (F'.e \u226b F'.m) _\n    rw [F'.fac]\n    rw [(Classical.indefiniteDescription (fun z => f z = _) _).2]\n    rw [(Classical.indefiniteDescription (fun z => f z = _) _).2]\n    rw [(Classical.indefiniteDescription (fun z => f z = _) _).2]\n    rfl", "start": [65, 1], "end": [84, 8], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.image.lift_fac", "code": "theorem image.lift_fac (F' : MonoFactorisation f) : image.lift F' \u226b F'.m = image.\u03b9 f", "start": [87, 1], "end": [91, 6], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.monoFactorisation", "code": "def monoFactorisation : MonoFactorisation f where\n  I := image f\n  m := image.\u03b9 f\n  e := factorThruImage f", "start": [96, 1], "end": [100, 25], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.isImage", "code": "noncomputable def isImage : IsImage (monoFactorisation f) where\n  lift := image.lift\n  lift_fac := image.lift_fac", "start": [103, 1], "end": [107, 29], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.imageIsoRange", "code": "noncomputable def imageIsoRange {G H : AddCommGroupCat.{0}} (f : G \u27f6 H) :\n    Limits.image f \u2245 AddCommGroupCat.of f.range :=\n  IsImage.isoExt (Image.isImage f) (isImage f)", "start": [110, 1], "end": [115, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Small/Module.lean", "imports": ["Mathlib/Logic/Small/Ring.lean", "Mathlib/Logic/Small/Group.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "linearEquivShrink", "code": "def linearEquivShrink (\u03b1 \u03b2) [Semiring \u03b1] [AddCommMonoid \u03b2] [Module \u03b1 \u03b2] [Small \u03b2] :\n    \u03b2 \u2243\u2097[\u03b1] Shrink \u03b2 :=\n  ((equivShrink \u03b2).symm.linearEquiv \u03b1).symm", "start": [20, 1], "end": [23, 44], "kind": "commanddeclaration"}, {"full_name": "algEquivShrink", "code": "def algEquivShrink (\u03b1 \u03b2) [CommSemiring \u03b1] [Semiring \u03b2] [Algebra \u03b1 \u03b2] [Small \u03b2] :\n    \u03b2 \u2243\u2090[\u03b1] Shrink \u03b2 :=\n  ((equivShrink \u03b2).symm.algEquiv \u03b1).symm", "start": [28, 1], "end": [31, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/TensorProduct/Prod.lean", "imports": ["Mathlib/LinearAlgebra/TensorProduct.lean", "Mathlib/LinearAlgebra/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TensorProduct.prodRight", "code": "def prodRight : M\u2081 \u2297[R] (M\u2082 \u00d7 M\u2083) \u2243\u2097[R] ((M\u2081 \u2297[R] M\u2082) \u00d7 (M\u2081 \u2297[R] M\u2083)) :=\n  LinearEquiv.ofLinear\n    (lift <|\n      LinearMap.prodMapLinear R M\u2082 M\u2083 (M\u2081 \u2297[R] M\u2082) (M\u2081 \u2297[R] M\u2083) R\n        \u2218\u2097 LinearMap.prod (mk _ _ _) (mk _ _ _))\n    (LinearMap.coprod\n      (LinearMap.lTensor _ <| LinearMap.inl _ _ _)\n      (LinearMap.lTensor _ <| LinearMap.inr _ _ _))\n    (by ext <;> simp)\n    (by ext <;> simp)", "start": [32, 1], "end": [42, 22], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.prodRight_tmul", "code": "@[simp] theorem prodRight_tmul (m\u2081 : M\u2081) (m\u2082 : M\u2082) (m\u2083 : M\u2083) :\n    prodRight R M\u2081 M\u2082 M\u2083 (m\u2081 \u2297\u209c (m\u2082, m\u2083)) = (m\u2081 \u2297\u209c m\u2082, m\u2081 \u2297\u209c m\u2083)", "start": [44, 1], "end": [46, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.prodRight_symm_tmul", "code": "@[simp] theorem prodRight_symm_tmul (m\u2081 : M\u2081) (m\u2082 : M\u2082) (m\u2083 : M\u2083) :\n    (prodRight R M\u2081 M\u2082 M\u2083).symm (m\u2081 \u2297\u209c m\u2082, m\u2081 \u2297\u209c m\u2083) = (m\u2081 \u2297\u209c (m\u2082, m\u2083))", "start": [48, 1], "end": [50, 40], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.prodLeft", "code": "def prodLeft : (M\u2081 \u00d7 M\u2082) \u2297[R] M\u2083 \u2243\u2097[R] ((M\u2081 \u2297[R] M\u2083) \u00d7 (M\u2082 \u2297[R] M\u2083)) :=\n  TensorProduct.comm _ _ _\n    \u226a\u226b\u2097 TensorProduct.prodRight R _ _ _\n    \u226a\u226b\u2097 (TensorProduct.comm R _ _).prod (TensorProduct.comm R _ _)", "start": [52, 1], "end": [56, 67], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.prodLeft_tmul", "code": "@[simp] theorem prodLeft_tmul (m\u2081 : M\u2081) (m\u2082 : M\u2082) (m\u2083 : M\u2083) :\n    prodLeft R M\u2081 M\u2082 M\u2083 ((m\u2081, m\u2082) \u2297\u209c m\u2083) = (m\u2081 \u2297\u209c m\u2083, m\u2082 \u2297\u209c m\u2083)", "start": [58, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.prodLeft_symm_tmul", "code": "@[simp] theorem prodLeft_symm_tmul (m\u2081 : M\u2081) (m\u2082 : M\u2082) (m\u2083 : M\u2083) :\n    (prodLeft R M\u2081 M\u2082 M\u2083).symm (m\u2081 \u2297\u209c m\u2083, m\u2082 \u2297\u209c m\u2083) = ((m\u2081, m\u2082) \u2297\u209c m\u2083)", "start": [62, 1], "end": [64, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rbtree/Insert.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Probability/StrongLaw.lean", "imports": ["Mathlib/Analysis/SpecificLimits/FloorPow.lean", "Mathlib/Probability/IdentDistrib.lean", "Mathlib/Analysis/PSeries.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/MeasureTheory/Integral/IntervalIntegral.lean", "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean"], "premises": [{"full_name": "ProbabilityTheory.truncation", "code": "def truncation (f : \u03b1 \u2192 \u211d) (A : \u211d) :=\n  indicator (Set.Ioc (-A) A) id \u2218 f", "start": [77, 1], "end": [79, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.truncation", "code": "theorem _root_.MeasureTheory.AEStronglyMeasurable.truncation (hf : AEStronglyMeasurable f \u03bc)\n    {A : \u211d} : AEStronglyMeasurable (truncation f A) \u03bc", "start": [84, 1], "end": [87, 81], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.abs_truncation_le_bound", "code": "theorem abs_truncation_le_bound (f : \u03b1 \u2192 \u211d) (A : \u211d) (x : \u03b1) : |truncation f A x| \u2264 |A|", "start": [90, 1], "end": [94, 22], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.truncation_zero", "code": "@[simp]\ntheorem truncation_zero (f : \u03b1 \u2192 \u211d) : truncation f 0 = 0", "start": [97, 1], "end": [98, 86], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.abs_truncation_le_abs_self", "code": "theorem abs_truncation_le_abs_self (f : \u03b1 \u2192 \u211d) (A : \u211d) (x : \u03b1) : |truncation f A x| \u2264 |f x|", "start": [101, 1], "end": [105, 22], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.truncation_eq_self", "code": "theorem truncation_eq_self {f : \u03b1 \u2192 \u211d} {A : \u211d} {x : \u03b1} (h : |f x| < A) :\n    truncation f A x = f x", "start": [108, 1], "end": [113, 43], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.truncation_eq_of_nonneg", "code": "theorem truncation_eq_of_nonneg {f : \u03b1 \u2192 \u211d} {A : \u211d} (h : \u2200 x, 0 \u2264 f x) :\n    truncation f A = indicator (Set.Ioc 0 A) id \u2218 f", "start": [116, 1], "end": [125, 81], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.truncation_nonneg", "code": "theorem truncation_nonneg {f : \u03b1 \u2192 \u211d} (A : \u211d) {x : \u03b1} (h : 0 \u2264 f x) : 0 \u2264 truncation f A x", "start": [128, 1], "end": [129, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.mem\u2112p_truncation", "code": "theorem _root_.MeasureTheory.AEStronglyMeasurable.mem\u2112p_truncation [IsFiniteMeasure \u03bc]\n    (hf : AEStronglyMeasurable f \u03bc) {A : \u211d} {p : \u211d\u22650\u221e} : Mem\u2112p (truncation f A) p \u03bc", "start": [132, 1], "end": [134, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.integrable_truncation", "code": "theorem _root_.MeasureTheory.AEStronglyMeasurable.integrable_truncation [IsFiniteMeasure \u03bc]\n    (hf : AEStronglyMeasurable f \u03bc) {A : \u211d} : Integrable (truncation f A) \u03bc", "start": [137, 1], "end": [139, 61], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.moment_truncation_eq_intervalIntegral", "code": "theorem moment_truncation_eq_intervalIntegral (hf : AEStronglyMeasurable f \u03bc) {A : \u211d} (hA : 0 \u2264 A)\n    {n : \u2115} (hn : n \u2260 0) : \u222b x, truncation f A x ^ n \u2202\u03bc = \u222b y in -A..A, y ^ n \u2202Measure.map f \u03bc", "start": [142, 1], "end": [150, 73], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.moment_truncation_eq_intervalIntegral_of_nonneg", "code": "theorem moment_truncation_eq_intervalIntegral_of_nonneg (hf : AEStronglyMeasurable f \u03bc) {A : \u211d}\n    {n : \u2115} (hn : n \u2260 0) (h'f : 0 \u2264 f) :\n    \u222b x, truncation f A x ^ n \u2202\u03bc = \u222b y in (0)..A, y ^ n \u2202Measure.map f \u03bc", "start": [153, 1], "end": [177, 75], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.integral_truncation_eq_intervalIntegral", "code": "theorem integral_truncation_eq_intervalIntegral (hf : AEStronglyMeasurable f \u03bc) {A : \u211d}\n    (hA : 0 \u2264 A) : \u222b x, truncation f A x \u2202\u03bc = \u222b y in -A..A, y \u2202Measure.map f \u03bc", "start": [180, 1], "end": [182, 70], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.integral_truncation_eq_intervalIntegral_of_nonneg", "code": "theorem integral_truncation_eq_intervalIntegral_of_nonneg (hf : AEStronglyMeasurable f \u03bc) {A : \u211d}\n    (h'f : 0 \u2264 f) : \u222b x, truncation f A x \u2202\u03bc = \u222b y in (0)..A, y \u2202Measure.map f \u03bc", "start": [185, 1], "end": [187, 81], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.integral_truncation_le_integral_of_nonneg", "code": "theorem integral_truncation_le_integral_of_nonneg (hf : Integrable f \u03bc) (h'f : 0 \u2264 f) {A : \u211d} :\n    \u222b x, truncation f A x \u2202\u03bc \u2264 \u222b x, f x \u2202\u03bc", "start": [190, 1], "end": [198, 39], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.tendsto_integral_truncation", "code": "theorem tendsto_integral_truncation {f : \u03b1 \u2192 \u211d} (hf : Integrable f \u03bc) :\n    Tendsto (fun A => \u222b x, truncation f A x \u2202\u03bc) atTop (\ud835\udcdd (\u222b x, f x \u2202\u03bc))", "start": [201, 1], "end": [215, 39], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.truncation", "code": "theorem IdentDistrib.truncation {\u03b2 : Type*} [MeasurableSpace \u03b2] {\u03bd : Measure \u03b2} {f : \u03b1 \u2192 \u211d}\n    {g : \u03b2 \u2192 \u211d} (h : IdentDistrib f g \u03bc \u03bd) {A : \u211d} :\n    IdentDistrib (truncation f A) (truncation g A) \u03bc \u03bd", "start": [218, 1], "end": [221, 53], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.sum_prob_mem_Ioc_le", "code": "theorem sum_prob_mem_Ioc_le {X : \u03a9 \u2192 \u211d} (hint : Integrable X) (hnonneg : 0 \u2264 X) {K : \u2115} {N : \u2115}\n    (hKN : K \u2264 N) :\n    \u2211 j in range K, \u2119 {\u03c9 | X \u03c9 \u2208 Set.Ioc (j : \u211d) N} \u2264 ENNReal.ofReal (\ud835\udd3c[X] + 1)", "start": [232, 1], "end": [311, 64], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.tsum_prob_mem_Ioi_lt_top", "code": "theorem tsum_prob_mem_Ioi_lt_top {X : \u03a9 \u2192 \u211d} (hint : Integrable X) (hnonneg : 0 \u2264 X) :\n    (\u2211' j : \u2115, \u2119 {\u03c9 | X \u03c9 \u2208 Set.Ioi (j : \u211d)}) < \u221e", "start": [314, 1], "end": [336, 44], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.sum_variance_truncation_le", "code": "theorem sum_variance_truncation_le {X : \u03a9 \u2192 \u211d} (hint : Integrable X) (hnonneg : 0 \u2264 X) (K : \u2115) :\n    \u2211 j in range K, ((j : \u211d) ^ 2)\u207b\u00b9 * \ud835\udd3c[truncation X j ^ 2] \u2264 2 * \ud835\udd3c[X]", "start": [339, 1], "end": [400, 80], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.strong_law_aux1", "code": "theorem strong_law_aux1 {c : \u211d} (c_one : 1 < c) {\u03b5 : \u211d} (\u03b5pos : 0 < \u03b5) : \u2200\u1d50 \u03c9, \u2200\u1da0 n : \u2115 in atTop,\n    |\u2211 i in range \u230ac ^ n\u230b\u208a, truncation (X i) i \u03c9 - \ud835\udd3c[\u2211 i in range \u230ac ^ n\u230b\u208a, truncation (X i) i]| <\n    \u03b5 * \u230ac ^ n\u230b\u208a", "start": [416, 1], "end": [522, 36], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.strong_law_aux2", "code": "theorem strong_law_aux2 {c : \u211d} (c_one : 1 < c) :\n    \u2200\u1d50 \u03c9, (fun n : \u2115 => \u2211 i in range \u230ac ^ n\u230b\u208a, truncation (X i) i \u03c9 -\n      \ud835\udd3c[\u2211 i in range \u230ac ^ n\u230b\u208a, truncation (X i) i]) =o[atTop] fun n : \u2115 => (\u230ac ^ n\u230b\u208a : \u211d)", "start": [528, 1], "end": [540, 75], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.strong_law_aux3", "code": "theorem strong_law_aux3 :\n    (fun n => \ud835\udd3c[\u2211 i in range n, truncation (X i) i] - n * \ud835\udd3c[X 0]) =o[atTop] ((\u2191) : \u2115 \u2192 \u211d)", "start": [543, 1], "end": [555, 70], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.strong_law_aux4", "code": "theorem strong_law_aux4 {c : \u211d} (c_one : 1 < c) :\n    \u2200\u1d50 \u03c9, (fun n : \u2115 => \u2211 i in range \u230ac ^ n\u230b\u208a, truncation (X i) i \u03c9 - \u230ac ^ n\u230b\u208a * \ud835\udd3c[X 0]) =o[atTop]\n    fun n : \u2115 => (\u230ac ^ n\u230b\u208a : \u211d)", "start": [562, 1], "end": [570, 7], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.strong_law_aux5", "code": "theorem strong_law_aux5 :\n    \u2200\u1d50 \u03c9, (fun n : \u2115 => \u2211 i in range n, truncation (X i) i \u03c9 - \u2211 i in range n, X i \u03c9) =o[atTop]\n    fun n : \u2115 => (n : \u211d)", "start": [573, 1], "end": [598, 23], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.strong_law_aux6", "code": "theorem strong_law_aux6 {c : \u211d} (c_one : 1 < c) :\n    \u2200\u1d50 \u03c9, Tendsto (fun n : \u2115 => (\u2211 i in range \u230ac ^ n\u230b\u208a, X i \u03c9) / \u230ac ^ n\u230b\u208a) atTop (\ud835\udcdd \ud835\udd3c[X 0])", "start": [604, 1], "end": [621, 35], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.strong_law_aux7", "code": "theorem strong_law_aux7 :\n    \u2200\u1d50 \u03c9, Tendsto (fun n : \u2115 => (\u2211 i in range n, X i \u03c9) / n) atTop (\ud835\udcdd \ud835\udd3c[X 0])", "start": [624, 1], "end": [640, 13], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.strong_law_ae_real", "code": "theorem strong_law_ae_real (X : \u2115 \u2192 \u03a9 \u2192 \u211d) (hint : Integrable (X 0))\n    (hindep : Pairwise fun i j => IndepFun (X i) (X j)) (hident : \u2200 i, IdentDistrib (X i) (X 0)) :\n    \u2200\u1d50 \u03c9, Tendsto (fun n : \u2115 => (\u2211 i in range n, X i \u03c9) / n) atTop (\ud835\udcdd \ud835\udd3c[X 0])", "start": [645, 1], "end": [667, 27], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.strong_law_ae_simpleFunc_comp", "code": "lemma strong_law_ae_simpleFunc_comp (X : \u2115 \u2192 \u03a9 \u2192 E) (h' : Measurable (X 0))\n    (hindep : Pairwise (fun i j \u21a6 IndepFun (X i) (X j))) (hident : \u2200 i, IdentDistrib (X i) (X 0))\n    (\u03c6 : SimpleFunc E E) : \u2200\u1d50 \u03c9,\n      Tendsto (fun n : \u2115 \u21a6 (n : \u211d) \u207b\u00b9 \u2022 (\u2211 i in range n, \u03c6 (X i \u03c9))) atTop (\ud835\udcdd \ud835\udd3c[\u03c6 \u2218 (X 0)]) := by\n  classical\n  refine SimpleFunc.induction (P := fun \u03c8 \u21a6 \u2200\u1d50 \u03c9,\n    Tendsto (fun n : \u2115 \u21a6 (n : \u211d) \u207b\u00b9 \u2022 (\u2211 i in range n, \u03c8 (X i \u03c9))) atTop (\ud835\udcdd \ud835\udd3c[\u03c8 \u2218 (X 0)])) ?_ ?_ \u03c6\n  \u00b7 intro c s hs\n    simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,\n      SimpleFunc.coe_zero, piecewise_eq_indicator, Function.comp_apply]\n    let F : E \u2192 \u211d := indicator s 1\n    have F_meas : Measurable F := (measurable_indicator_const_iff 1).2 hs\n    let Y : \u2115 \u2192 \u03a9 \u2192 \u211d := fun n \u21a6 F \u2218 (X n)\n    have : \u2200\u1d50 (\u03c9 : \u03a9), Tendsto (fun (n : \u2115) \u21a6 (n : \u211d)\u207b\u00b9 \u2022 \u2211 i in Finset.range n, Y i \u03c9)\n        atTop (\ud835\udcdd \ud835\udd3c[Y 0]) := by\n      simp only [Pi.const_one, smul_eq_mul, \u2190 div_eq_inv_mul]\n      apply strong_law_ae_real\n      \u00b7 exact SimpleFunc.integrable_of_isFiniteMeasure\n          ((SimpleFunc.piecewise s hs (SimpleFunc.const _ (1 : \u211d))\n            (SimpleFunc.const _ (0 : \u211d))).comp (X 0) h')\n      \u00b7 exact fun i j hij \u21a6 IndepFun.comp (hindep hij) F_meas F_meas\n      \u00b7 exact fun i \u21a6 (hident i).comp F_meas\n    filter_upwards [this] with \u03c9 h\u03c9\n    have I : indicator s (Function.const E c) = (fun x \u21a6 (indicator s (1 : E \u2192 \u211d) x) \u2022 c) := by\n      ext\n      rw [\u2190 indicator_smul_const_apply]\n      congr! 1\n      ext\n      simp\n    simp only [I, integral_smul_const]\n    convert Tendsto.smul_const h\u03c9 c using 1\n    simp [\u2190 sum_smul, smul_smul]\n  \u00b7 rintro \u03c6 \u03c8 - h\u03c6 h\u03c8\n    filter_upwards [h\u03c6, h\u03c8] with \u03c9 h\u03c9\u03c6 h\u03c9\u03c8\n    convert h\u03c9\u03c6.add h\u03c9\u03c8 using 1\n    \u00b7 simp [sum_add_distrib]\n    \u00b7 congr 1\n      rw [\u2190 integral_add]\n      \u00b7 rfl\n      \u00b7 exact (\u03c6.comp (X 0) h').integrable_of_isFiniteMeasure\n      \u00b7 exact (\u03c8.comp (X 0) h').integrable_of_isFiniteMeasure", "start": [680, 1], "end": [725, 62], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.strong_law_ae_of_measurable", "code": "lemma strong_law_ae_of_measurable\n    (X : \u2115 \u2192 \u03a9 \u2192 E) (hint : Integrable (X 0)) (h' : StronglyMeasurable (X 0))\n    (hindep : Pairwise (fun i j \u21a6 IndepFun (X i) (X j))) (hident : \u2200 i, IdentDistrib (X i) (X 0)) :\n    \u2200\u1d50 \u03c9, Tendsto (fun n : \u2115 \u21a6 (n : \u211d) \u207b\u00b9 \u2022 (\u2211 i in range n, X i \u03c9)) atTop (\ud835\udcdd \ud835\udd3c[X 0]) := by\n  \n  let s : Set E := Set.range (X 0) \u222a {0}\n  have zero_s : 0 \u2208 s := by simp\n  have : SeparableSpace s := h'.separableSpace_range_union_singleton\n  have : Nonempty s := \u27e80, zero_s\u27e9\n  let \u03c6 : \u2115 \u2192 SimpleFunc E E :=\n    SimpleFunc.nearestPt (fun k => Nat.casesOn k 0 ((\u2191) \u2218 denseSeq s) : \u2115 \u2192 E)\n  let Y : \u2115 \u2192 \u2115 \u2192 \u03a9 \u2192 E := fun k i \u21a6 (\u03c6 k) \u2218 (X i)\n  have A : \u2200\u1d50 \u03c9, \u2200 k,\n      Tendsto (fun n : \u2115 \u21a6 (n : \u211d) \u207b\u00b9 \u2022 (\u2211 i in range n, Y k i \u03c9)) atTop (\ud835\udcdd \ud835\udd3c[Y k 0]) :=\n    ae_all_iff.2 (fun k \u21a6 strong_law_ae_simpleFunc_comp X h'.measurable hindep hident (\u03c6 k))\n  have B : \u2200\u1d50 \u03c9, \u2200 k, Tendsto (fun n : \u2115 \u21a6 (\u2211 i in range n, \u2016(X i - Y k i) \u03c9\u2016) / n)\n        atTop (\ud835\udcdd \ud835\udd3c[(fun \u03c9 \u21a6 \u2016(X 0 - Y k 0) \u03c9\u2016)]) := by\n    apply ae_all_iff.2 (fun k \u21a6 ?_)\n    let G : \u2115 \u2192 E \u2192 \u211d := fun k x \u21a6 \u2016x - \u03c6 k x\u2016\n    have G_meas : \u2200 k, Measurable (G k) :=\n      fun k \u21a6 (measurable_id.sub_stronglyMeasurable (\u03c6 k).stronglyMeasurable).norm\n    have I : \u2200 k i, (fun \u03c9 \u21a6 \u2016(X i - Y k i) \u03c9\u2016) = (G k) \u2218 (X i) := fun k i \u21a6 rfl\n    apply strong_law_ae_real (fun i \u03c9 \u21a6 \u2016(X i - Y k i) \u03c9\u2016)\n    \u00b7 exact (hint.sub ((\u03c6 k).comp (X 0) h'.measurable).integrable_of_isFiniteMeasure).norm\n    \u00b7 simp_rw [I]\n      intro i j hij\n      exact (hindep hij).comp (G_meas k) (G_meas k)\n    \u00b7 intro i\n      simp_rw [I]\n      apply (hident i).comp (G_meas k)\n  filter_upwards [A, B] with \u03c9 h\u03c9 h'\u03c9\n  rw [tendsto_iff_norm_sub_tendsto_zero, tendsto_order]\n  refine \u27e8fun c hc \u21a6 eventually_of_forall (fun n \u21a6 hc.trans_le (norm_nonneg _)), ?_\u27e9\n  intro \u03b5 (\u03b5pos : 0 < \u03b5)\n  obtain \u27e8\u03b4, \u03b4pos, h\u03b4\u27e9 : \u2203 \u03b4, 0 < \u03b4 \u2227 \u03b4 + \u03b4 + \u03b4 < \u03b5 := \u27e8\u03b5/4, by positivity, by linarith\u27e9\n  obtain \u27e8k, hk\u27e9 : \u2203 k, \u222b \u03c9, \u2016(X 0 - Y k 0) \u03c9\u2016 < \u03b4 := by\n    simp_rw [Pi.sub_apply, norm_sub_rev (X 0 _)]\n    exact ((tendsto_order.1 (tendsto_integral_norm_approxOn_sub h'.measurable hint)).2 \u03b4\n      \u03b4pos).exists\n  have : \u2016\ud835\udd3c[Y k 0] - \ud835\udd3c[X 0]\u2016 < \u03b4 := by\n    rw [norm_sub_rev, \u2190 integral_sub hint]\n    \u00b7 exact (norm_integral_le_integral_norm _).trans_lt hk\n    \u00b7 exact ((\u03c6 k).comp (X 0) h'.measurable).integrable_of_isFiniteMeasure\n  have I : \u2200\u1da0 n in atTop, (\u2211 i in range n, \u2016(X i - Y k i) \u03c9\u2016) / n < \u03b4 :=\n    (tendsto_order.1 (h'\u03c9 k)).2 \u03b4 hk\n  have J : \u2200\u1da0 (n : \u2115) in atTop, \u2016(n : \u211d) \u207b\u00b9 \u2022 (\u2211 i in range n, Y k i \u03c9) - \ud835\udd3c[Y k 0]\u2016 < \u03b4 := by\n    specialize h\u03c9 k\n    rw [tendsto_iff_norm_sub_tendsto_zero] at h\u03c9\n    exact (tendsto_order.1 h\u03c9).2 \u03b4 \u03b4pos\n  filter_upwards [I, J] with n hn h'n\n  calc\n  \u2016(n : \u211d)\u207b\u00b9 \u2022 \u2211 i in Finset.range n, X i \u03c9 - \ud835\udd3c[X 0]\u2016\n    = \u2016(n : \u211d)\u207b\u00b9 \u2022 \u2211 i in Finset.range n, (X i \u03c9 - Y k i \u03c9) +\n        ((n : \u211d)\u207b\u00b9 \u2022 \u2211 i in Finset.range n, Y k i \u03c9 - \ud835\udd3c[Y k 0]) + (\ud835\udd3c[Y k 0] - \ud835\udd3c[X 0])\u2016 := by\n      congr\n      simp only [Function.comp_apply, sum_sub_distrib, smul_sub]\n      abel\n  _ \u2264 \u2016(n : \u211d)\u207b\u00b9 \u2022 \u2211 i in Finset.range n, (X i \u03c9 - Y k i \u03c9)\u2016 +\n        \u2016(n : \u211d)\u207b\u00b9 \u2022 \u2211 i in Finset.range n, Y k i \u03c9 - \ud835\udd3c[Y k 0]\u2016 + \u2016\ud835\udd3c[Y k 0] - \ud835\udd3c[X 0]\u2016 :=\n      norm_add\u2083_le _ _ _\n  _ \u2264 (\u2211 i in Finset.range n, \u2016X i \u03c9 - Y k i \u03c9\u2016) / n + \u03b4 + \u03b4 := by\n      gcongr\n      simp only [Function.comp_apply, norm_smul, norm_inv, IsROrC.norm_natCast,\n        div_eq_inv_mul, inv_pos, Nat.cast_pos, inv_lt_zero]\n      gcongr\n      exact norm_sum_le _ _\n  _ \u2264 \u03b4 + \u03b4 + \u03b4 := by\n      gcongr\n      exact hn.le\n  _ < \u03b5 := h\u03b4", "start": [727, 1], "end": [813, 14], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.strong_law_ae", "code": "theorem strong_law_ae\n    (X : \u2115 \u2192 \u03a9 \u2192 E) (hint : Integrable (X 0))\n    (hindep : Pairwise (fun i j \u21a6 IndepFun (X i) (X j))) (hident : \u2200 i, IdentDistrib (X i) (X 0)) :\n    \u2200\u1d50 \u03c9, Tendsto (fun n : \u2115 \u21a6 (n : \u211d) \u207b\u00b9 \u2022 (\u2211 i in range n, X i \u03c9)) atTop (\ud835\udcdd \ud835\udd3c[X 0])", "start": [815, 1], "end": [839, 20], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.strong_law_Lp", "code": "theorem strong_law_Lp {p : \u211d\u22650\u221e} (hp : 1 \u2264 p) (hp' : p \u2260 \u221e) (X : \u2115 \u2192 \u03a9 \u2192 E) (h\u2112p : Mem\u2112p (X 0) p)\n    (hindep : Pairwise fun i j => IndepFun (X i) (X j)) (hident : \u2200 i, IdentDistrib (X i) (X 0)) :\n    Tendsto (fun (n : \u2115) => snorm (fun \u03c9 => (n : \u211d) \u207b\u00b9 \u2022 (\u2211 i in range n, X i \u03c9) - \ud835\udd3c[X 0]) p \u2119)\n      atTop (\ud835\udcdd 0)", "start": [849, 1], "end": [871, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/MazurUlam.lean", "imports": ["Mathlib/Analysis/NormedSpace/AffineIsometry.lean", "Mathlib/Topology/Instances/RealVectorSpace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsometryEquiv.midpoint_fixed", "code": "theorem midpoint_fixed {x y : PE} :\n    \u2200 e : PE \u2243\u1d62 PE, e x = x \u2192 e y = y \u2192 e (midpoint \u211d x y) = midpoint \u211d x y", "start": [42, 1], "end": [84, 35], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.map_midpoint", "code": "theorem map_midpoint (f : PE \u2243\u1d62 PF) (x y : PE) : f (midpoint \u211d x y) = midpoint \u211d (f x) (f y)", "start": [87, 1], "end": [97, 96], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.toRealLinearIsometryEquivOfMapZero", "code": "def toRealLinearIsometryEquivOfMapZero (f : E \u2243\u1d62 F) (h0 : f 0 = 0) : E \u2243\u2097\u1d62[\u211d] F :=\n  { (AddMonoidHom.ofMapMidpoint \u211d \u211d f h0 f.map_midpoint).toRealLinearMap f.continuous, f with\n    norm_map' := fun x => show \u2016f x\u2016 = \u2016x\u2016 by simp only [\u2190 dist_zero_right, \u2190 h0, f.dist_eq] }", "start": [106, 1], "end": [110, 95], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.coe_toRealLinearIsometryEquivOfMapZero", "code": "@[simp]\ntheorem coe_toRealLinearIsometryEquivOfMapZero (f : E \u2243\u1d62 F) (h0 : f 0 = 0) :\n    \u21d1(f.toRealLinearIsometryEquivOfMapZero h0) = f", "start": [113, 1], "end": [116, 6], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.coe_toRealLinearIsometryEquivOfMapZero_symm", "code": "@[simp]\ntheorem coe_toRealLinearIsometryEquivOfMapZero_symm (f : E \u2243\u1d62 F) (h0 : f 0 = 0) :\n    \u21d1(f.toRealLinearIsometryEquivOfMapZero h0).symm = f.symm", "start": [119, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.toRealLinearIsometryEquiv", "code": "def toRealLinearIsometryEquiv (f : E \u2243\u1d62 F) : E \u2243\u2097\u1d62[\u211d] F :=\n  (f.trans (IsometryEquiv.addRight (f 0)).symm).toRealLinearIsometryEquivOfMapZero\n    (by simpa only [sub_eq_add_neg] using sub_self (f 0))", "start": [125, 1], "end": [129, 58], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.toRealLinearIsometryEquiv_apply", "code": "@[simp]\ntheorem toRealLinearIsometryEquiv_apply (f : E \u2243\u1d62 F) (x : E) :\n    (f.toRealLinearIsometryEquiv : E \u2192 F) x = f x - f 0", "start": [132, 1], "end": [135, 36], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.toRealLinearIsometryEquiv_symm_apply", "code": "@[simp]\ntheorem toRealLinearIsometryEquiv_symm_apply (f : E \u2243\u1d62 F) (y : F) :\n    (f.toRealLinearIsometryEquiv.symm : F \u2192 E) y = f.symm (y + f 0)", "start": [138, 1], "end": [141, 6], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.toRealAffineIsometryEquiv", "code": "def toRealAffineIsometryEquiv (f : PE \u2243\u1d62 PF) : PE \u2243\u1d43\u2071[\u211d] PF :=\n  AffineIsometryEquiv.mk' f\n    ((vaddConst (Classical.arbitrary PE)).trans <|\n        f.trans (vaddConst (f <| Classical.arbitrary PE)).symm).toRealLinearIsometryEquiv\n    (Classical.arbitrary PE) fun p => by simp", "start": [144, 1], "end": [150, 46], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.coeFn_toRealAffineIsometryEquiv", "code": "@[simp]\ntheorem coeFn_toRealAffineIsometryEquiv (f : PE \u2243\u1d62 PF) : \u21d1f.toRealAffineIsometryEquiv = f", "start": [153, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.coe_toRealAffineIsometryEquiv", "code": "@[simp]\ntheorem coe_toRealAffineIsometryEquiv (f : PE \u2243\u1d62 PF) :\n    f.toRealAffineIsometryEquiv.toIsometryEquiv = f", "start": [158, 1], "end": [162, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/LucasLehmer.lean", "imports": ["Mathlib/Tactic/IntervalCases.lean", "Mathlib/GroupTheory/OrderOfElement.lean", "Mathlib/Data/ZMod/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Fintype.lean", "Mathlib/Data/PNat/Interval.lean", "Mathlib/Data/Nat/Parity.lean"], "premises": [{"full_name": "mersenne", "code": "def mersenne (p : \u2115) : \u2115 :=\n  2 ^ p - 1", "start": [41, 1], "end": [43, 12], "kind": "commanddeclaration"}, {"full_name": "mersenne_pos", "code": "theorem mersenne_pos {p : \u2115} (h : 0 < p) : 0 < mersenne p", "start": [46, 1], "end": [50, 92], "kind": "commanddeclaration"}, {"full_name": "one_lt_mersenne", "code": "theorem one_lt_mersenne {p : \u2115} (hp : 1 < p) : 1 < mersenne p", "start": [53, 1], "end": [56, 58], "kind": "commanddeclaration"}, {"full_name": "succ_mersenne", "code": "@[simp]\ntheorem succ_mersenne (k : \u2115) : mersenne k + 1 = 2 ^ k", "start": [58, 1], "end": [61, 45], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.s", "code": "def s : \u2115 \u2192 \u2124\n  | 0 => 4\n  | i + 1 => s i ^ 2 - 2", "start": [79, 1], "end": [82, 25], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.sZMod", "code": "def sZMod (p : \u2115) : \u2115 \u2192 ZMod (2 ^ p - 1)\n  | 0 => 4\n  | i + 1 => sZMod p i ^ 2 - 2", "start": [85, 1], "end": [88, 31], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.sMod", "code": "def sMod (p : \u2115) : \u2115 \u2192 \u2124\n  | 0 => 4 % (2 ^ p - 1)\n  | i + 1 => (sMod p i ^ 2 - 2) % (2 ^ p - 1)", "start": [91, 1], "end": [94, 46], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.mersenne_int_pos", "code": "theorem mersenne_int_pos {p : \u2115} (hp : 0 < p) : (0 : \u2124) < 2 ^ p - 1", "start": [97, 1], "end": [98, 57], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.mersenne_int_ne_zero", "code": "theorem mersenne_int_ne_zero (p : \u2115) (w : 0 < p) : (2 ^ p - 1 : \u2124) \u2260 0", "start": [100, 1], "end": [101, 27], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.sMod_nonneg", "code": "theorem sMod_nonneg (p : \u2115) (w : 0 < p) (i : \u2115) : 0 \u2264 sMod p i", "start": [104, 1], "end": [108, 35], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.sMod_mod", "code": "theorem sMod_mod (p i : \u2115) : sMod p i % (2 ^ p - 1) = sMod p i", "start": [111, 1], "end": [111, 93], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.sMod_lt", "code": "theorem sMod_lt (p : \u2115) (w : 0 < p) (i : \u2115) : sMod p i < 2 ^ p - 1", "start": [114, 1], "end": [117, 46], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.sZMod_eq_s", "code": "theorem sZMod_eq_s (p' : \u2115) (i : \u2115) : sZMod (p' + 2) i = (s i : ZMod (2 ^ (p' + 2) - 1))", "start": [120, 1], "end": [124, 34], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.Int.coe_nat_pow_pred", "code": "theorem Int.coe_nat_pow_pred (b p : \u2115) (w : 0 < b) : ((b ^ p - 1 : \u2115) : \u2124) = (b : \u2124) ^ p - 1", "start": [128, 1], "end": [130, 12], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.Int.coe_nat_two_pow_pred", "code": "theorem Int.coe_nat_two_pow_pred (p : \u2115) : ((2 ^ p - 1 : \u2115) : \u2124) = (2 ^ p - 1 : \u2124)", "start": [133, 1], "end": [134, 39], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.sZMod_eq_sMod", "code": "theorem sZMod_eq_sMod (p : \u2115) (i : \u2115) : sZMod p i = (sMod p i : ZMod (2 ^ p - 1))", "start": [137, 1], "end": [138, 83], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.lucasLehmerResidue", "code": "def lucasLehmerResidue (p : \u2115) : ZMod (2 ^ p - 1) :=\n  sZMod p (p - 2)", "start": [141, 1], "end": [143, 18], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.residue_eq_zero_iff_sMod_eq_zero", "code": "theorem residue_eq_zero_iff_sMod_eq_zero (p : \u2115) (w : 1 < p) :\n    lucasLehmerResidue p = 0 \u2194 sMod p (p - 2) = 0", "start": [146, 1], "end": [160, 9], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.LucasLehmerTest", "code": "def LucasLehmerTest (p : \u2115) : Prop :=\n  lucasLehmerResidue p = 0", "start": [163, 1], "end": [167, 27], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.q", "code": "def q (p : \u2115) : \u2115+ :=\n  \u27e8Nat.minFac (mersenne p), Nat.minFac_pos (mersenne p)\u27e9", "start": [177, 1], "end": [179, 57], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X", "code": "def X (q : \u2115+) : Type :=\n  ZMod q \u00d7 ZMod q", "start": [187, 1], "end": [189, 18], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.ext", "code": "@[ext]\ntheorem ext {x y : X q} (h\u2081 : x.1 = y.1) (h\u2082 : x.2 = y.2) : x = y", "start": [202, 1], "end": [204, 26], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.zero_fst", "code": "@[simp] theorem zero_fst : (0 : X q).1 = 0", "start": [208, 1], "end": [208, 50], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.zero_snd", "code": "@[simp] theorem zero_snd : (0 : X q).2 = 0", "start": [209, 1], "end": [209, 50], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.add_fst", "code": "@[simp]\ntheorem add_fst (x y : X q) : (x + y).1 = x.1 + y.1", "start": [211, 1], "end": [213, 6], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.add_snd", "code": "@[simp]\ntheorem add_snd (x y : X q) : (x + y).2 = x.2 + y.2", "start": [217, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.neg_fst", "code": "@[simp]\ntheorem neg_fst (x : X q) : (-x).1 = -x.1", "start": [223, 1], "end": [225, 6], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.neg_snd", "code": "@[simp]\ntheorem neg_snd (x : X q) : (-x).2 = -x.2", "start": [229, 1], "end": [231, 6], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.mul_fst", "code": "@[simp]\ntheorem mul_fst (x y : X q) : (x * y).1 = x.1 * y.1 + 3 * x.2 * y.2", "start": [237, 1], "end": [239, 6], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.mul_snd", "code": "@[simp]\ntheorem mul_snd (x y : X q) : (x * y).2 = x.1 * y.2 + x.2 * y.1", "start": [243, 1], "end": [245, 6], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.one_fst", "code": "@[simp]\ntheorem one_fst : (1 : X q).1 = 1", "start": [251, 1], "end": [253, 6], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.one_snd", "code": "@[simp]\ntheorem one_snd : (1 : X q).2 = 0", "start": [257, 1], "end": [259, 6], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.nat_coe_fst", "code": "@[simp] theorem nat_coe_fst (n : \u2115) : (n : X q).fst = (n : ZMod q)", "start": [277, 1], "end": [277, 74], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.nat_coe_snd", "code": "@[simp] theorem nat_coe_snd (n : \u2115) : (n : X q).snd = (0 : ZMod q)", "start": [281, 1], "end": [281, 74], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.ofNat_fst", "code": "@[simp] theorem ofNat_fst (n : \u2115) [n.AtLeastTwo] :\n    (no_index (OfNat.ofNat n) : X q).fst = OfNat.ofNat n", "start": [285, 1], "end": [287, 6], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.ofNat_snd", "code": "@[simp] theorem ofNat_snd (n : \u2115) [n.AtLeastTwo] :\n    (no_index (OfNat.ofNat n) : X q).snd = 0", "start": [289, 1], "end": [291, 6], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.left_distrib", "code": "theorem left_distrib (x y z : X q) : x * (y + z) = x * y + x * z", "start": [302, 1], "end": [303, 25], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.right_distrib", "code": "theorem right_distrib (x y z : X q) : (x + y) * z = x * z + y * z", "start": [307, 1], "end": [308, 25], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.int_coe_fst", "code": "@[simp]\ntheorem int_coe_fst (n : \u2124) : (n : X q).fst = (n : ZMod q)", "start": [327, 1], "end": [329, 6], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.int_coe_snd", "code": "@[simp]\ntheorem int_coe_snd (n : \u2124) : (n : X q).snd = (0 : ZMod q)", "start": [333, 1], "end": [335, 6], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.coe_mul", "code": "@[norm_cast]\ntheorem coe_mul (n m : \u2124) : ((n * m : \u2124) : X q) = (n : X q) * (m : X q)", "start": [339, 1], "end": [340, 91], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.coe_nat", "code": "@[norm_cast]\ntheorem coe_nat (n : \u2115) : ((n : \u2124) : X q) = (n : X q)", "start": [344, 1], "end": [345, 73], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.card_eq", "code": "theorem card_eq : Fintype.card (X q) = q ^ 2", "start": [349, 1], "end": [352, 42], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.card_units_lt", "code": "nonrec theorem card_units_lt (w : 1 < q) : Fintype.card (X q)\u02e3 < q ^ 2", "start": [356, 1], "end": [360, 15], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.\u03c9", "code": "def \u03c9 : X q := (2, 1)", "start": [364, 1], "end": [365, 22], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.\u03c9b", "code": "def \u03c9b : X q := (2, -1)", "start": [369, 1], "end": [370, 24], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.\u03c9_mul_\u03c9b", "code": "theorem \u03c9_mul_\u03c9b (q : \u2115+) : (\u03c9 : X q) * \u03c9b = 1", "start": [374, 1], "end": [376, 21], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.\u03c9b_mul_\u03c9", "code": "theorem \u03c9b_mul_\u03c9 (q : \u2115+) : (\u03c9b : X q) * \u03c9 = 1", "start": [380, 1], "end": [381, 26], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.X.closed_form", "code": "theorem closed_form (i : \u2115) : (s i : X q) = (\u03c9 : X q) ^ 2 ^ i + (\u03c9b : X q) ^ 2 ^ i", "start": [385, 1], "end": [397, 95], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.two_lt_q", "code": "theorem two_lt_q (p' : \u2115) : 2 < q (p' + 2)", "start": [409, 1], "end": [414, 65], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.\u03c9_pow_formula", "code": "theorem \u03c9_pow_formula (p' : \u2115) (h : lucasLehmerResidue (p' + 2) = 0) :\n    \u2203 k : \u2124,\n      (\u03c9 : X (q (p' + 2))) ^ 2 ^ (p' + 1) =\n        k * mersenne (p' + 2) * (\u03c9 : X (q (p' + 2))) ^ 2 ^ p' - 1", "start": [417, 1], "end": [438, 19], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.mersenne_coe_X", "code": "theorem mersenne_coe_X (p : \u2115) : (mersenne p : X (q p)) = 0", "start": [441, 1], "end": [444, 23], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.\u03c9_pow_eq_neg_one", "code": "theorem \u03c9_pow_eq_neg_one (p' : \u2115) (h : lucasLehmerResidue (p' + 2) = 0) :\n    (\u03c9 : X (q (p' + 2))) ^ 2 ^ (p' + 1) = -1", "start": [448, 1], "end": [452, 16], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.\u03c9_pow_eq_one", "code": "theorem \u03c9_pow_eq_one (p' : \u2115) (h : lucasLehmerResidue (p' + 2) = 0) :\n    (\u03c9 : X (q (p' + 2))) ^ 2 ^ (p' + 2) = 1", "start": [455, 1], "end": [461, 21], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.\u03c9Unit", "code": "def \u03c9Unit (p : \u2115) : Units (X (q p)) where\n  val := \u03c9\n  inv := \u03c9b\n  val_inv := \u03c9_mul_\u03c9b _\n  inv_val := \u03c9b_mul_\u03c9 _", "start": [464, 1], "end": [469, 24], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.\u03c9Unit_coe", "code": "@[simp]\ntheorem \u03c9Unit_coe (p : \u2115) : (\u03c9Unit p : X (q p)) = \u03c9", "start": [472, 1], "end": [474, 6], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.order_\u03c9", "code": "theorem order_\u03c9 (p' : \u2115) (h : lucasLehmerResidue (p' + 2) = 0) :\n    orderOf (\u03c9Unit (p' + 2)) = 2 ^ (p' + 2)", "start": [477, 1], "end": [495, 28], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.order_ineq", "code": "theorem order_ineq (p' : \u2115) (h : lucasLehmerResidue (p' + 2) = 0) :\n    2 ^ (p' + 2) < (q (p' + 2) : \u2115) ^ 2", "start": [498, 1], "end": [503, 79], "kind": "commanddeclaration"}, {"full_name": "lucas_lehmer_sufficiency", "code": "theorem lucas_lehmer_sufficiency (p : \u2115) (w : 1 < p) : LucasLehmerTest p \u2192 (mersenne p).Prime", "start": [512, 1], "end": [523, 40], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.norm_num_ext.sMod'", "code": "def sMod' (q : \u2115) : \u2115 \u2192 \u2115\n  | 0 => 4 % q\n  | i + 1 => (sMod' q i ^ 2 + (q - 2)) % q", "start": [544, 1], "end": [548, 43], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.norm_num_ext.sMod'_eq_sMod", "code": "theorem sMod'_eq_sMod (p k : \u2115) (hp : 2 \u2264 p) : (sMod' (2 ^ p - 1) k : \u2124) = sMod p k", "start": [550, 1], "end": [568, 43], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.norm_num_ext.testTrueHelper", "code": "lemma testTrueHelper (p : \u2115) (hp : Nat.blt 1 p = true) (h : sMod' (2 ^ p - 1) (p - 2) = 0) :\n    LucasLehmerTest p := by\n  rw [Nat.blt_eq] at hp\n  rw [LucasLehmerTest, LucasLehmer.residue_eq_zero_iff_sMod_eq_zero p hp, \u2190 sMod'_eq_sMod p _ hp, h]\n  rfl", "start": [570, 1], "end": [574, 6], "kind": "mathlibtacticlemma"}, {"full_name": "LucasLehmer.norm_num_ext.testFalseHelper", "code": "lemma testFalseHelper (p : \u2115) (hp : Nat.blt 1 p = true)\n    (h : Nat.ble 1 (sMod' (2 ^ p - 1) (p - 2))) : \u00ac LucasLehmerTest p := by\n  rw [Nat.blt_eq] at hp\n  rw [Nat.ble_eq, Nat.succ_le, Nat.pos_iff_ne_zero] at h\n  rw [LucasLehmerTest, LucasLehmer.residue_eq_zero_iff_sMod_eq_zero p hp, \u2190 sMod'_eq_sMod p _ hp]\n  simpa using h", "start": [576, 1], "end": [581, 16], "kind": "mathlibtacticlemma"}, {"full_name": "LucasLehmer.norm_num_ext.isNat_lucasLehmerTest", "code": "theorem isNat_lucasLehmerTest : {p np : \u2115} \u2192\n    IsNat p np \u2192 LucasLehmerTest np \u2192 LucasLehmerTest p", "start": [583, 1], "end": [585, 24], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.norm_num_ext.isNat_not_lucasLehmerTest", "code": "theorem isNat_not_lucasLehmerTest : {p np : \u2115} \u2192\n    IsNat p np \u2192 \u00ac LucasLehmerTest np \u2192 \u00ac LucasLehmerTest p", "start": [587, 1], "end": [589, 24], "kind": "commanddeclaration"}, {"full_name": "LucasLehmer.norm_num_ext.evalLucasLehmerTest", "code": "@[norm_num LucasLehmer.LucasLehmerTest (_ : \u2115)]\ndef evalLucasLehmerTest : NormNumExt where eval {u \u03b1} e := do\n  let .app _ (p : Q(\u2115)) \u2190 Meta.whnfR e | failure\n  let \u27e8ep, hp\u27e9 \u2190 deriveNat p _\n  let np := ep.natLit!\n  unless 1 < np do\n    failure\n  haveI' h1ltp : Nat.blt 1 $ep =Q true := \u27e8\u27e9\n  if sMod' (2 ^ np - 1) (np - 2) = 0 then\n    haveI' hs : sMod' (2 ^ $ep - 1) ($ep - 2) =Q 0 := \u27e8\u27e9\n    have pf : Q(LucasLehmerTest $ep) := q(testTrueHelper $ep $h1ltp $hs)\n    have pf' : Q(LucasLehmerTest $p) := q(isNat_lucasLehmerTest $hp $pf)\n    return .isTrue pf'\n  else\n    haveI' hs : Nat.ble 1 (sMod' (2 ^ $ep - 1) ($ep - 2)) =Q true := \u27e8\u27e9\n    have pf : Q(\u00ac LucasLehmerTest $ep) := q(testFalseHelper $ep $h1ltp $hs)\n    have pf' : Q(\u00ac LucasLehmerTest $p) := q(isNat_not_lucasLehmerTest $hp $pf)\n    return .isFalse pf'", "start": [591, 1], "end": [610, 24], "kind": "commanddeclaration"}, {"full_name": "modEq_mersenne", "code": "theorem modEq_mersenne (n k : \u2115) : k \u2261 k / 2 ^ n + k % 2 ^ n [MOD 2 ^ n - 1]", "start": [634, 1], "end": [640, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/VonMangoldt.lean", "imports": ["Mathlib/NumberTheory/ArithmeticFunction.lean", "Mathlib/Algebra/IsPrimePow.lean", "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.ArithmeticFunction.log", "code": "noncomputable def log : ArithmeticFunction \u211d :=\n  \u27e8fun n => Real.log n, by simp\u27e9", "start": [44, 1], "end": [48, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.log_apply", "code": "@[simp]\ntheorem log_apply {n : \u2115} : log n = Real.log n", "start": [51, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.vonMangoldt", "code": "noncomputable def vonMangoldt : ArithmeticFunction \u211d :=\n  \u27e8fun n => if IsPrimePow n then Real.log (minFac n) else 0, if_neg not_isPrimePow_zero\u27e9", "start": [56, 1], "end": [65, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.vonMangoldt_apply", "code": "theorem vonMangoldt_apply {n : \u2115} : \u039b n = if IsPrimePow n then Real.log (minFac n) else 0", "start": [70, 1], "end": [71, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.vonMangoldt_apply_one", "code": "@[simp]\ntheorem vonMangoldt_apply_one : \u039b 1 = 0", "start": [74, 1], "end": [75, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.vonMangoldt_nonneg", "code": "@[simp]\ntheorem vonMangoldt_nonneg {n : \u2115} : 0 \u2264 \u039b n", "start": [78, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.vonMangoldt_apply_pow", "code": "theorem vonMangoldt_apply_pow {n k : \u2115} (hk : k \u2260 0) : \u039b (n ^ k) = \u039b n", "start": [86, 1], "end": [87, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.vonMangoldt_apply_prime", "code": "theorem vonMangoldt_apply_prime {p : \u2115} (hp : p.Prime) : \u039b p = Real.log p", "start": [90, 1], "end": [91, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.vonMangoldt_ne_zero_iff", "code": "theorem vonMangoldt_ne_zero_iff {n : \u2115} : \u039b n \u2260 0 \u2194 IsPrimePow n", "start": [94, 1], "end": [96, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.vonMangoldt_pos_iff", "code": "theorem vonMangoldt_pos_iff {n : \u2115} : 0 < \u039b n \u2194 IsPrimePow n", "start": [99, 1], "end": [100, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.vonMangoldt_eq_zero_iff", "code": "theorem vonMangoldt_eq_zero_iff {n : \u2115} : \u039b n = 0 \u2194 \u00acIsPrimePow n", "start": [103, 1], "end": [104, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.vonMangoldt_sum", "code": "theorem vonMangoldt_sum {n : \u2115} : \u2211 i in n.divisors, \u039b i = Real.log n", "start": [109, 1], "end": [120, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.vonMangoldt_mul_zeta", "code": "@[simp]\ntheorem vonMangoldt_mul_zeta : \u039b * \u03b6 = log", "start": [123, 1], "end": [125, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.zeta_mul_vonMangoldt", "code": "@[simp]\ntheorem zeta_mul_vonMangoldt : (\u03b6 : ArithmeticFunction \u211d) * \u039b = log", "start": [128, 1], "end": [129, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.log_mul_moebius_eq_vonMangoldt", "code": "@[simp]\ntheorem log_mul_moebius_eq_vonMangoldt : log * \u03bc = \u039b", "start": [132, 1], "end": [134, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.moebius_mul_log_eq_vonMangoldt", "code": "@[simp]\ntheorem moebius_mul_log_eq_vonMangoldt : (\u03bc : ArithmeticFunction \u211d) * log = \u039b", "start": [137, 1], "end": [139, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.sum_moebius_mul_log_eq", "code": "theorem sum_moebius_mul_log_eq {n : \u2115} : (\u2211 d in n.divisors, (\u03bc d : \u211d) * log d) = -\u039b n", "start": [142, 1], "end": [158, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.vonMangoldt_le_log", "code": "theorem vonMangoldt_le_log : \u2200 {n : \u2115}, \u039b n \u2264 Real.log (n : \u211d)", "start": [161, 1], "end": [166, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/ConditionallyCompleteOrder.lean", "imports": ["Mathlib/Data/Int/LeastGreatest.lean", "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.csSup_eq_greatest_of_bdd", "code": "theorem csSup_eq_greatest_of_bdd {s : Set \u2124} [DecidablePred (\u00b7 \u2208 s)] (b : \u2124) (Hb : \u2200 z \u2208 s, z \u2264 b)\n    (Hinh : \u2203 z : \u2124, z \u2208 s) : sSup s = greatestOfBdd b Hb Hinh", "start": [65, 1], "end": [69, 93], "kind": "commanddeclaration"}, {"full_name": "Int.csSup_empty", "code": "@[simp]\ntheorem csSup_empty : sSup (\u2205 : Set \u2124) = 0", "start": [72, 1], "end": [74, 20], "kind": "commanddeclaration"}, {"full_name": "Int.csSup_of_not_bdd_above", "code": "theorem csSup_of_not_bdd_above {s : Set \u2124} (h : \u00acBddAbove s) : sSup s = 0", "start": [77, 1], "end": [78, 24], "kind": "commanddeclaration"}, {"full_name": "Int.csInf_eq_least_of_bdd", "code": "theorem csInf_eq_least_of_bdd {s : Set \u2124} [DecidablePred (\u00b7 \u2208 s)] (b : \u2124) (Hb : \u2200 z \u2208 s, b \u2264 z)\n    (Hinh : \u2203 z : \u2124, z \u2208 s) : sInf s = leastOfBdd b Hb Hinh", "start": [82, 1], "end": [86, 90], "kind": "commanddeclaration"}, {"full_name": "Int.csInf_empty", "code": "@[simp]\ntheorem csInf_empty : sInf (\u2205 : Set \u2124) = 0", "start": [89, 1], "end": [91, 20], "kind": "commanddeclaration"}, {"full_name": "Int.csInf_of_not_bdd_below", "code": "theorem csInf_of_not_bdd_below {s : Set \u2124} (h : \u00acBddBelow s) : sInf s = 0", "start": [94, 1], "end": [95, 24], "kind": "commanddeclaration"}, {"full_name": "Int.csSup_mem", "code": "theorem csSup_mem {s : Set \u2124} (h1 : s.Nonempty) (h2 : BddAbove s) : sSup s \u2208 s", "start": [98, 1], "end": [100, 25], "kind": "commanddeclaration"}, {"full_name": "Int.csInf_mem", "code": "theorem csInf_mem {s : Set \u2124} (h1 : s.Nonempty) (h2 : BddBelow s) : sInf s \u2208 s", "start": [103, 1], "end": [105, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Homotopy/HSpaces.lean", "imports": ["Mathlib/Topology/Homotopy/Path.lean", "Mathlib/Topology/CompactOpen.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HSpace", "code": "class HSpace (X : Type u) [TopologicalSpace X] where\n  hmul : C(X \u00d7 X, X)\n  e : X\n  hmul_e_e : hmul (e, e) = e\n  eHmul :\n    (hmul.comp <| (const X e).prodMk <| ContinuousMap.id X).HomotopyRel (ContinuousMap.id X) {e}\n  hmulE :\n    (hmul.comp <| (ContinuousMap.id X).prodMk <| const X e).HomotopyRel (ContinuousMap.id X) {e}", "start": [59, 1], "end": [69, 97], "kind": "commanddeclaration"}, {"full_name": "HSpace.prod", "code": "instance HSpace.prod (X : Type u) (Y : Type v) [TopologicalSpace X] [TopologicalSpace Y] [HSpace X]\n    [HSpace Y] : HSpace (X \u00d7 Y) where\n  hmul := \u27e8fun p => (p.1.1 \u22c0 p.2.1, p.1.2 \u22c0 p.2.2), by\n    exact ((map_continuous HSpace.hmul).comp ((continuous_fst.comp continuous_fst).prod_mk\n        (continuous_fst.comp continuous_snd))).prod_mk ((map_continuous HSpace.hmul).comp\n        ((continuous_snd.comp continuous_fst).prod_mk (continuous_snd.comp continuous_snd)))\n  \u27e9\n  e := (HSpace.e, HSpace.e)\n  hmul_e_e := by\n    simp only [ContinuousMap.coe_mk, Prod.mk.inj_iff]\n    exact \u27e8HSpace.hmul_e_e, HSpace.hmul_e_e\u27e9\n  eHmul := by\n    let G : I \u00d7 X \u00d7 Y \u2192 X \u00d7 Y := fun p => (HSpace.eHmul (p.1, p.2.1), HSpace.eHmul (p.1, p.2.2))\n    have hG : Continuous G :=\n      (Continuous.comp HSpace.eHmul.1.1.2\n            (continuous_fst.prod_mk (continuous_fst.comp continuous_snd))).prod_mk\n        (Continuous.comp HSpace.eHmul.1.1.2\n          (continuous_fst.prod_mk (continuous_snd.comp continuous_snd)))\n    use! \u27e8G, hG\u27e9\n    \u00b7 rintro \u27e8x, y\u27e9\n      exacts [Prod.mk.inj_iff.mpr \u27e8HSpace.eHmul.1.2 x, HSpace.eHmul.1.2 y\u27e9]\n    \u00b7 rintro \u27e8x, y\u27e9\n      exact Prod.mk.inj_iff.mpr \u27e8HSpace.eHmul.1.3 x, HSpace.eHmul.1.3 y\u27e9\n    \u00b7 rintro t \u27e8x, y\u27e9 h\n      replace h := Prod.mk.inj_iff.mp (Set.mem_singleton_iff.mp h)\n      exact\n        \u27e8Prod.mk.inj_iff.mpr\n            \u27e8HomotopyRel.eq_fst HSpace.eHmul t (Set.mem_singleton_iff.mpr h.1),\n              HomotopyRel.eq_fst HSpace.eHmul t (Set.mem_singleton_iff.mpr h.2)\u27e9,\n          Prod.mk.inj_iff.mpr \u27e8(HSpace.eHmul.2 t x h.1).2, (HSpace.eHmul.2 t y h.2).2\u27e9\u27e9\n  hmulE := by\n    let G : I \u00d7 X \u00d7 Y \u2192 X \u00d7 Y := fun p => (HSpace.hmulE (p.1, p.2.1), HSpace.hmulE (p.1, p.2.2))\n    have hG : Continuous G :=\n      (Continuous.comp HSpace.hmulE.1.1.2\n            (continuous_fst.prod_mk (continuous_fst.comp continuous_snd))).prod_mk\n        (Continuous.comp HSpace.hmulE.1.1.2\n          (continuous_fst.prod_mk (continuous_snd.comp continuous_snd)))\n    use! \u27e8G, hG\u27e9\n    \u00b7 rintro \u27e8x, y\u27e9\n      exacts [Prod.mk.inj_iff.mpr \u27e8HSpace.hmulE.1.2 x, HSpace.hmulE.1.2 y\u27e9]\n    \u00b7 rintro \u27e8x, y\u27e9\n      exact Prod.mk.inj_iff.mpr \u27e8HSpace.hmulE.1.3 x, HSpace.hmulE.1.3 y\u27e9\n    \u00b7 rintro t \u27e8x, y\u27e9 h\n      replace h := Prod.mk.inj_iff.mp (Set.mem_singleton_iff.mp h)\n      exact\n        \u27e8Prod.mk.inj_iff.mpr\n            \u27e8HomotopyRel.eq_fst HSpace.hmulE t (Set.mem_singleton_iff.mpr h.1),\n              HomotopyRel.eq_fst HSpace.hmulE t (Set.mem_singleton_iff.mpr h.2)\u27e9,\n          Prod.mk.inj_iff.mpr \u27e8(HSpace.hmulE.2 t x h.1).2, (HSpace.hmulE.2 t y h.2).2\u27e9\u27e9", "start": [78, 1], "end": [127, 88], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.toHSpace", "code": "@[to_additive\n      \"The definition `toHSpace` is not an instance because it comes together with a\n      multiplicative version which would lead to a diamond since a topological field would inherit\n      two `HSpace` structures, one from the `MulOneClass` and one from the `AddZeroClass`.\n      In the case of an additive group, we make `TopologicalAddGroup.hSpace` an instance.\"]\ndef toHSpace (M : Type u) [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] : HSpace M where\n  hmul := \u27e8Function.uncurry Mul.mul, continuous_mul\u27e9\n  e := 1\n  hmul_e_e := one_mul 1\n  eHmul := (HomotopyRel.refl _ _).cast rfl (by ext1; apply one_mul)\n  hmulE := (HomotopyRel.refl _ _).cast rfl (by ext1; apply mul_one)", "start": [133, 1], "end": [147, 68], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.hSpace", "code": "@[to_additive]\ninstance (priority := 600) hSpace (G : Type u) [TopologicalSpace G] [Group G] [TopologicalGroup G] :\n    HSpace G :=\n  toHSpace G", "start": [151, 1], "end": [154, 13], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.one_eq_hSpace_e", "code": "theorem one_eq_hSpace_e {G : Type u} [TopologicalSpace G] [Group G] [TopologicalGroup G] :\n    (1 : G) = HSpace.e", "start": [158, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "unitInterval.qRight", "code": "def qRight (p : I \u00d7 I) : I :=\n  Set.projIcc 0 1 zero_le_one (2 * p.1 / (1 + p.2))", "start": [175, 1], "end": [178, 52], "kind": "commanddeclaration"}, {"full_name": "unitInterval.continuous_qRight", "code": "theorem continuous_qRight : Continuous qRight", "start": [181, 1], "end": [183, 86], "kind": "commanddeclaration"}, {"full_name": "unitInterval.qRight_zero_left", "code": "theorem qRight_zero_left (\u03b8 : I) : qRight (0, \u03b8) = 0", "start": [186, 1], "end": [187, 83], "kind": "commanddeclaration"}, {"full_name": "unitInterval.qRight_one_left", "code": "theorem qRight_one_left (\u03b8 : I) : qRight (1, \u03b8) = 1", "start": [190, 1], "end": [196, 21], "kind": "commanddeclaration"}, {"full_name": "unitInterval.qRight_zero_right", "code": "theorem qRight_zero_right (t : I) :\n    (qRight (t, 0) : \u211d) = if (t : \u211d) \u2264 1 / 2 then (2 : \u211d) * t else 1", "start": [199, 1], "end": [208, 24], "kind": "commanddeclaration"}, {"full_name": "unitInterval.qRight_one_right", "code": "theorem qRight_one_right (t : I) : qRight (t, 1) = t", "start": [211, 1], "end": [219, 34], "kind": "commanddeclaration"}, {"full_name": "Path.delayReflRight", "code": "def delayReflRight (\u03b8 : I) (\u03b3 : Path x y) : Path x y where\n  toFun t := \u03b3 (qRight (t, \u03b8))\n  continuous_toFun := \u03b3.continuous.comp (continuous_qRight.comp <| Continuous.Prod.mk_left \u03b8)\n  source' := by\n    dsimp only\n    rw [qRight_zero_left, \u03b3.source]\n  target' := by\n    dsimp only\n    rw [qRight_one_left, \u03b3.target]", "start": [230, 1], "end": [240, 35], "kind": "commanddeclaration"}, {"full_name": "Path.continuous_delayReflRight", "code": "theorem continuous_delayReflRight : Continuous fun p : I \u00d7 Path x y => delayReflRight p.1 p.2", "start": [243, 1], "end": [246, 93], "kind": "commanddeclaration"}, {"full_name": "Path.delayReflRight_zero", "code": "theorem delayReflRight_zero (\u03b3 : Path x y) : delayReflRight 0 \u03b3 = \u03b3.trans (Path.refl y)", "start": [249, 1], "end": [255, 30], "kind": "commanddeclaration"}, {"full_name": "Path.delayReflRight_one", "code": "theorem delayReflRight_one (\u03b3 : Path x y) : delayReflRight 1 \u03b3 = \u03b3", "start": [258, 1], "end": [260, 41], "kind": "commanddeclaration"}, {"full_name": "Path.delayReflLeft", "code": "def delayReflLeft (\u03b8 : I) (\u03b3 : Path x y) : Path x y :=\n  (delayReflRight \u03b8 \u03b3.symm).symm", "start": [263, 1], "end": [266, 33], "kind": "commanddeclaration"}, {"full_name": "Path.continuous_delayReflLeft", "code": "theorem continuous_delayReflLeft : Continuous fun p : I \u00d7 Path x y => delayReflLeft p.1 p.2", "start": [269, 1], "end": [272, 73], "kind": "commanddeclaration"}, {"full_name": "Path.delayReflLeft_zero", "code": "theorem delayReflLeft_zero (\u03b3 : Path x y) : delayReflLeft 0 \u03b3 = (Path.refl x).trans \u03b3", "start": [275, 1], "end": [276, 88], "kind": "commanddeclaration"}, {"full_name": "Path.delayReflLeft_one", "code": "theorem delayReflLeft_one (\u03b3 : Path x y) : delayReflLeft 1 \u03b3 = \u03b3", "start": [279, 1], "end": [280, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rat/Cast/Lemmas.lean", "imports": ["Mathlib/Data/Rat/Cast/Defs.lean", "Mathlib/Algebra/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Rat.cast_inv_nat", "code": "@[simp]\ntheorem cast_inv_nat (n : \u2115) : ((n\u207b\u00b9 : \u211a) : \u03b1) = (n : \u03b1)\u207b\u00b9", "start": [27, 1], "end": [32, 81], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_inv_int", "code": "@[simp]\ntheorem cast_inv_int (n : \u2124) : ((n\u207b\u00b9 : \u211a) : \u03b1) = (n : \u03b1)\u207b\u00b9", "start": [36, 1], "end": [40, 98], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Buffer/Basic.lean", "imports": ["Mathlib/Init/Align.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/RingTheory/WittVector/Isocrystal.lean", "imports": ["Mathlib/RingTheory/WittVector/FrobeniusFractionField.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WittVector.FractionRing.frobenius", "code": "def FractionRing.frobenius : K(p, k) \u2243+* K(p, k) :=\n  IsFractionRing.fieldEquivOfRingEquiv (frobeniusEquiv p k)", "start": [79, 1], "end": [81, 60], "kind": "commanddeclaration"}, {"full_name": "WittVector.FractionRing.frobeniusRingHom", "code": "def FractionRing.frobeniusRingHom : K(p, k) \u2192+* K(p, k) :=\n  FractionRing.frobenius p k", "start": [84, 1], "end": [86, 29], "kind": "commanddeclaration"}, {"full_name": "WittVector.inv_pair\u2081", "code": "instance inv_pair\u2081 : RingHomInvPair \u03c6(p, k) (FractionRing.frobenius p k).symm :=\n  RingHomInvPair.of_ringEquiv (FractionRing.frobenius p k)", "start": [91, 1], "end": [92, 59], "kind": "commanddeclaration"}, {"full_name": "WittVector.inv_pair\u2082", "code": "instance inv_pair\u2082 : RingHomInvPair ((FractionRing.frobenius p k).symm : K(p, k) \u2192+* K(p, k))\n    (FractionRing.frobenius p k) :=\n  RingHomInvPair.of_ringEquiv (FractionRing.frobenius p k).symm", "start": [95, 1], "end": [97, 64], "kind": "commanddeclaration"}, {"full_name": "WittVector.Isocrystal", "code": "class Isocrystal (V : Type*) [AddCommGroup V] extends Module K(p, k) V where\n  frob : V \u2243\u1da0\u02e1[p, k] V", "start": [111, 1], "end": [115, 23], "kind": "commanddeclaration"}, {"full_name": "WittVector.Isocrystal.frobenius", "code": "def Isocrystal.frobenius : V \u2243\u1da0\u02e1[p, k] V :=\n  @Isocrystal.frob p _ k _ _ _ _ _ _ _", "start": [126, 1], "end": [130, 39], "kind": "commanddeclaration"}, {"full_name": "WittVector.IsocrystalHom", "code": "structure IsocrystalHom extends V \u2192\u2097[K(p, k)] V\u2082 where\n  frob_equivariant : \u2200 x : V, \u03a6(p, k) (toLinearMap x) = toLinearMap (\u03a6(p, k) x)", "start": [137, 1], "end": [141, 80], "kind": "commanddeclaration"}, {"full_name": "WittVector.IsocrystalEquiv", "code": "structure IsocrystalEquiv extends V \u2243\u2097[K(p, k)] V\u2082 where\n  frob_equivariant : \u2200 x : V, \u03a6(p, k) (toLinearEquiv x) = toLinearEquiv (\u03a6(p, k) x)", "start": [144, 1], "end": [148, 84], "kind": "commanddeclaration"}, {"full_name": "WittVector.FractionRing.module", "code": "@[local instance]\ndef FractionRing.module : Module K(p, k) K(p, k) :=\n  Semiring.toModule", "start": [162, 1], "end": [165, 20], "kind": "commanddeclaration"}, {"full_name": "WittVector.StandardOneDimIsocrystal", "code": "@[nolint unusedArguments]\ndef StandardOneDimIsocrystal (_m : \u2124) : Type _ :=\n  K(p, k)", "start": [168, 1], "end": [175, 10], "kind": "commanddeclaration"}, {"full_name": "WittVector.StandardOneDimIsocrystal.frobenius_apply", "code": "@[simp]\ntheorem StandardOneDimIsocrystal.frobenius_apply (m : \u2124) (x : StandardOneDimIsocrystal p k m) :\n    \u03a6(p, k) x = (p : K(p, k)) ^ m \u2022 \u03c6(p, k) x", "start": [198, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "WittVector.isocrystal_classification", "code": "theorem isocrystal_classification (k : Type*) [Field k] [IsAlgClosed k] [CharP k p] (V : Type*)\n    [AddCommGroup V] [Isocrystal p k V] (h_dim : finrank K(p, k) V = 1) :\n    \u2203 m : \u2124, Nonempty (StandardOneDimIsocrystal p k m \u2243\u1da0\u2071[p, k] V)", "start": [209, 1], "end": [251, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Algebra.lean", "imports": ["Mathlib/Algebra/Order/SMul.lean", "Mathlib/Algebra/Algebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "algebraMap_monotone", "code": "theorem algebraMap_monotone : Monotone (algebraMap R A)", "start": [44, 1], "end": [48, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/UpperLower/Hom.lean", "imports": ["Mathlib/Order/UpperLower/Basic.lean", "Mathlib/Order/Hom/CompleteLattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UpperSet.iciSupHom", "code": "def iciSupHom : SupHom \u03b1 (UpperSet \u03b1) :=\n  \u27e8Ici, Ici_sup\u27e9", "start": [29, 1], "end": [31, 17], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_iciSupHom", "code": "@[simp]\ntheorem coe_iciSupHom : (iciSupHom : \u03b1 \u2192 UpperSet \u03b1) = Ici", "start": [34, 1], "end": [36, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.iciSupHom_apply", "code": "@[simp]\ntheorem iciSupHom_apply (a : \u03b1) : iciSupHom a = Ici a", "start": [39, 1], "end": [41, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.icisSupHom", "code": "def icisSupHom : sSupHom \u03b1 (UpperSet \u03b1) :=\n  \u27e8Ici, fun s => (Ici_sSup s).trans sSup_image.symm\u27e9", "start": [48, 1], "end": [50, 53], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_icisSupHom", "code": "@[simp]\ntheorem coe_icisSupHom : (icisSupHom : \u03b1 \u2192 UpperSet \u03b1) = Ici", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.icisSupHom_apply", "code": "@[simp]\ntheorem icisSupHom_apply (a : \u03b1) : icisSupHom a = Ici a", "start": [60, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.iicInfHom", "code": "def iicInfHom : InfHom \u03b1 (LowerSet \u03b1) :=\n  \u27e8Iic, Iic_inf\u27e9", "start": [74, 1], "end": [76, 17], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_iicInfHom", "code": "@[simp]\ntheorem coe_iicInfHom : (iicInfHom : \u03b1 \u2192 LowerSet \u03b1) = Iic", "start": [79, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.iicInfHom_apply", "code": "@[simp]\ntheorem iicInfHom_apply (a : \u03b1) : iicInfHom a = Iic a", "start": [84, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.iicsInfHom", "code": "def iicsInfHom : sInfHom \u03b1 (LowerSet \u03b1) :=\n  \u27e8Iic, fun s => (Iic_sInf s).trans sInf_image.symm\u27e9", "start": [93, 1], "end": [95, 53], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_iicsInfHom", "code": "@[simp]\ntheorem coe_iicsInfHom : (iicsInfHom : \u03b1 \u2192 LowerSet \u03b1) = Iic", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.iicsInfHom_apply", "code": "@[simp]\ntheorem iicsInfHom_apply (a : \u03b1) : iicsInfHom a = Iic a", "start": [105, 1], "end": [107, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/String/Lemmas.lean", "imports": ["Mathlib/Data/List/Basic.lean", "Mathlib/Data/String/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "String.congr_append", "code": "lemma congr_append : \u2200 (a b : String), a ++ b = String.mk (a.data ++ b.data)\n  | \u27e8_\u27e9, \u27e8_\u27e9 => rfl", "start": [11, 1], "end": [12, 20], "kind": "mathlibtacticlemma"}, {"full_name": "String.length_append", "code": "@[simp] lemma length_append : \u2200 (as bs : String), (as ++ bs).length = as.length + bs.length\n  | \u27e8as\u27e9, \u27e8bs\u27e9 => by\n    rw [congr_append]\n    simp only [String.length]\n    exact List.length_append as bs", "start": [14, 1], "end": [18, 35], "kind": "mathlibtacticlemma"}, {"full_name": "String.length_replicate", "code": "@[simp] lemma length_replicate (n : \u2115) (c : Char) : (replicate n c).length = n := by\n  simp only [String.length, String.replicate, List.length_replicate]", "start": [20, 1], "end": [21, 69], "kind": "mathlibtacticlemma"}, {"full_name": "String.length_eq_list_length", "code": "lemma length_eq_list_length (l : List Char) : (String.mk l).length = l.length := by\n  simp only [String.length]", "start": [23, 1], "end": [24, 28], "kind": "mathlibtacticlemma"}, {"full_name": "String.leftpad_length", "code": "@[simp] lemma leftpad_length (n : \u2115) (c : Char) :\n    \u2200 (s : String), (leftpad n c s).length = max n s.length\n  | \u27e8s\u27e9 => by simp only [leftpad, String.length, List.leftpad_length]", "start": [26, 1], "end": [30, 70], "kind": "mathlibtacticlemma"}, {"full_name": "String.leftpad_prefix", "code": "lemma leftpad_prefix (n : \u2115) (c : Char) : \u2200 s, IsPrefix (replicate (n - length s) c) (leftpad n c s)\n  | \u27e8l\u27e9 => by simp only [IsPrefix, replicate, leftpad, String.length, List.leftpad_prefix]", "start": [32, 1], "end": [33, 91], "kind": "mathlibtacticlemma"}, {"full_name": "String.leftpad_suffix", "code": "lemma leftpad_suffix (n : \u2115) (c : Char) : \u2200 s, IsSuffix s (leftpad n c s)\n  | \u27e8l\u27e9 => by simp only [IsSuffix, replicate, leftpad, String.length, List.leftpad_suffix]", "start": [35, 1], "end": [36, 91], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/CategoryTheory/Triangulated/Opposite.lean", "imports": ["Mathlib/Tactic/Linarith.lean", "Mathlib/CategoryTheory/Triangulated/Triangulated.lean", "Mathlib/CategoryTheory/Shift/Pullback.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Shift/Opposite.lean"], "premises": [{"full_name": "CategoryTheory.Pretriangulated.Opposite.OppositeShiftAux", "code": "private abbrev OppositeShiftAux :=\n  PullbackShift (OppositeShift C \u2124)\n    (AddMonoidHom.mk' (fun (n : \u2124) => -n) (by intros; dsimp; linarith))", "start": [54, 1], "end": [61, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.shiftFunctorOpIso", "code": "noncomputable def shiftFunctorOpIso (n m : \u2124) (hnm : n + m = 0) :\n    shiftFunctor C\u1d52\u1d56 n \u2245 (shiftFunctor C m).op := eqToIso (by\n  obtain rfl : m = -n := by linarith\n  rfl)", "start": [76, 1], "end": [81, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.shiftFunctorZero_op_hom_app", "code": "lemma shiftFunctorZero_op_hom_app (X : C\u1d52\u1d56) :\n    (shiftFunctorZero C\u1d52\u1d56 \u2124).hom.app X = (shiftFunctorOpIso C 0 0 (zero_add 0)).hom.app X \u226b\n      ((shiftFunctorZero C \u2124).inv.app X.unop).op := by\n  erw [@pullbackShiftFunctorZero_hom_app (OppositeShift C \u2124), oppositeShiftFunctorZero_hom_app]\n  rfl", "start": [85, 1], "end": [89, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.shiftFunctorZero_op_inv_app", "code": "lemma shiftFunctorZero_op_inv_app (X : C\u1d52\u1d56) :\n    (shiftFunctorZero C\u1d52\u1d56 \u2124).inv.app X =\n      ((shiftFunctorZero C \u2124).hom.app X.unop).op \u226b\n      (shiftFunctorOpIso C 0 0 (zero_add 0)).inv.app X := by\n  rw [\u2190 cancel_epi ((shiftFunctorZero C\u1d52\u1d56 \u2124).hom.app X), Iso.hom_inv_id_app,\n    shiftFunctorZero_op_hom_app, assoc, \u2190 op_comp_assoc, Iso.hom_inv_id_app, op_id,\n    id_comp, Iso.hom_inv_id_app]", "start": [91, 1], "end": [97, 33], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.shiftFunctorAdd'_op_hom_app", "code": "lemma shiftFunctorAdd'_op_hom_app (X : C\u1d52\u1d56) (a\u2081 a\u2082 a\u2083 : \u2124) (h : a\u2081 + a\u2082 = a\u2083)\n    (b\u2081 b\u2082 b\u2083 : \u2124) (h\u2081 : a\u2081 + b\u2081 = 0) (h\u2082 : a\u2082 + b\u2082 = 0) (h\u2083 : a\u2083 + b\u2083 = 0) :\n    (shiftFunctorAdd' C\u1d52\u1d56 a\u2081 a\u2082 a\u2083 h).hom.app X =\n      (shiftFunctorOpIso C _ _ h\u2083).hom.app X \u226b\n        ((shiftFunctorAdd' C b\u2081 b\u2082 b\u2083 (by linarith)).inv.app X.unop).op \u226b\n        (shiftFunctorOpIso C _ _ h\u2082).inv.app _ \u226b\n        (shiftFunctor C\u1d52\u1d56 a\u2082).map ((shiftFunctorOpIso C _ _ h\u2081).inv.app X) := by\n  erw [@pullbackShiftFunctorAdd'_hom_app (OppositeShift C \u2124) _ _ _ _ _ _ _ X\n    a\u2081 a\u2082 a\u2083 h b\u2081 b\u2082 b\u2083 (by dsimp; linarith) (by dsimp; linarith) (by dsimp; linarith)]\n  erw [oppositeShiftFunctorAdd'_hom_app]\n  obtain rfl : b\u2081 = -a\u2081 := by linarith\n  obtain rfl : b\u2082 = -a\u2082 := by linarith\n  obtain rfl : b\u2083 = -a\u2083 := by linarith\n  rfl", "start": [99, 1], "end": [112, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.shiftFunctorAdd'_op_inv_app", "code": "lemma shiftFunctorAdd'_op_inv_app (X : C\u1d52\u1d56) (a\u2081 a\u2082 a\u2083 : \u2124) (h : a\u2081 + a\u2082 = a\u2083)\n    (b\u2081 b\u2082 b\u2083 : \u2124) (h\u2081 : a\u2081 + b\u2081 = 0) (h\u2082 : a\u2082 + b\u2082 = 0) (h\u2083 : a\u2083 + b\u2083 = 0) :\n    (shiftFunctorAdd' C\u1d52\u1d56 a\u2081 a\u2082 a\u2083 h).inv.app X =\n      (shiftFunctor C\u1d52\u1d56 a\u2082).map ((shiftFunctorOpIso C _ _ h\u2081).hom.app X) \u226b\n      (shiftFunctorOpIso C _ _ h\u2082).hom.app _ \u226b\n      ((shiftFunctorAdd' C b\u2081 b\u2082 b\u2083 (by linarith)).hom.app X.unop).op \u226b\n      (shiftFunctorOpIso C _ _ h\u2083).inv.app X := by\n  rw [\u2190 cancel_epi ((shiftFunctorAdd' C\u1d52\u1d56 a\u2081 a\u2082 a\u2083 h).hom.app X), Iso.hom_inv_id_app,\n    shiftFunctorAdd'_op_hom_app X a\u2081 a\u2082 a\u2083 h b\u2081 b\u2082 b\u2083 h\u2081 h\u2082 h\u2083,\n    assoc, assoc, assoc, \u2190 Functor.map_comp_assoc, Iso.inv_hom_id_app]\n  erw [Functor.map_id, id_comp, Iso.inv_hom_id_app_assoc]\n  rw [\u2190 op_comp_assoc, Iso.hom_inv_id_app, op_id, id_comp, Iso.hom_inv_id_app]", "start": [114, 1], "end": [125, 79], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.shiftFunctor_op_map", "code": "lemma shiftFunctor_op_map (n m : \u2124) (hnm : n + m = 0) {K L : C\u1d52\u1d56} (\u03c6 : K \u27f6 L) :\n    (shiftFunctor C\u1d52\u1d56 n).map \u03c6 =\n      (shiftFunctorOpIso C n m hnm).hom.app K \u226b ((shiftFunctor C m).map \u03c6.unop).op \u226b\n        (shiftFunctorOpIso C n m hnm).inv.app L :=\n  (NatIso.naturality_2 (shiftFunctorOpIso C n m hnm) \u03c6).symm", "start": [127, 1], "end": [131, 61], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.opShiftFunctorEquivalence", "code": "@[simps functor inverse]\nnoncomputable def opShiftFunctorEquivalence (n : \u2124) : C\u1d52\u1d56 \u224c C\u1d52\u1d56 where\n  functor := shiftFunctor C\u1d52\u1d56 n\n  inverse := (shiftFunctor C n).op\n  unitIso := NatIso.op (shiftFunctorCompIsoId C (-n) n n.add_left_neg) \u226a\u226b\n    isoWhiskerRight (shiftFunctorOpIso C n (-n) n.add_right_neg).symm (shiftFunctor C n).op\n  counitIso := isoWhiskerLeft _ (shiftFunctorOpIso C n (-n) n.add_right_neg) \u226a\u226b\n    NatIso.op (shiftFunctorCompIsoId C n (-n) n.add_right_neg).symm\n  functor_unitIso_comp X := Quiver.Hom.unop_inj (by\n    dsimp [shiftFunctorOpIso]\n    erw [comp_id, Functor.map_id, comp_id]\n    change (shiftFunctorCompIsoId C n (-n) (add_neg_self n)).inv.app (X.unop\u27e6-n\u27e7) \u226b\n      ((shiftFunctorCompIsoId C (-n) n (neg_add_self n)).hom.app X.unop)\u27e6-n\u27e7' = \ud835\udfd9 _\n    rw [shift_shiftFunctorCompIsoId_neg_add_self_hom_app n X.unop, Iso.inv_hom_id_app])", "start": [135, 1], "end": [151, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_unitIso_hom_naturality", "code": "@[reassoc (attr := simp)]\nlemma opShiftFunctorEquivalence_unitIso_hom_naturality (n : \u2124) {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) :\n    f \u226b (opShiftFunctorEquivalence C n).unitIso.hom.app Y =\n      (opShiftFunctorEquivalence C n).unitIso.hom.app X \u226b (f\u27e6n\u27e7').unop\u27e6n\u27e7'.op :=\n  (opShiftFunctorEquivalence C n).unitIso.hom.naturality f", "start": [156, 1], "end": [160, 59], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_unitIso_inv_naturality", "code": "@[reassoc (attr := simp)]\nlemma opShiftFunctorEquivalence_unitIso_inv_naturality (n : \u2124) {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) :\n    (f\u27e6n\u27e7').unop\u27e6n\u27e7'.op \u226b (opShiftFunctorEquivalence C n).unitIso.inv.app Y =\n      (opShiftFunctorEquivalence C n).unitIso.inv.app X \u226b f :=\n  (opShiftFunctorEquivalence C n).unitIso.inv.naturality f", "start": [162, 1], "end": [166, 59], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_counitIso_hom_naturality", "code": "@[reassoc (attr := simp)]\nlemma opShiftFunctorEquivalence_counitIso_hom_naturality (n : \u2124) {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) :\n    f.unop\u27e6n\u27e7'.op\u27e6n\u27e7' \u226b (opShiftFunctorEquivalence C n).counitIso.hom.app Y =\n      (opShiftFunctorEquivalence C n).counitIso.hom.app X \u226b f :=\n  (opShiftFunctorEquivalence C n).counitIso.hom.naturality f", "start": [168, 1], "end": [172, 61], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_counitIso_inv_naturality", "code": "@[reassoc (attr := simp)]\nlemma opShiftFunctorEquivalence_counitIso_inv_naturality (n : \u2124) {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) :\n    f \u226b (opShiftFunctorEquivalence C n).counitIso.inv.app Y =\n      (opShiftFunctorEquivalence C n).counitIso.inv.app X \u226b f.unop\u27e6n\u27e7'.op\u27e6n\u27e7' :=\n  (opShiftFunctorEquivalence C n).counitIso.inv.naturality f", "start": [174, 1], "end": [178, 61], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.shift_unop_opShiftFunctorEquivalence_counitIso_inv_app", "code": "lemma shift_unop_opShiftFunctorEquivalence_counitIso_inv_app (X : C\u1d52\u1d56) (n : \u2124) :\n    ((opShiftFunctorEquivalence C n).counitIso.inv.app X).unop\u27e6n\u27e7' =\n      ((opShiftFunctorEquivalence C n).unitIso.hom.app ((Opposite.op ((X.unop)\u27e6n\u27e7)))).unop :=\n  Quiver.Hom.op_inj ((opShiftFunctorEquivalence C n).unit_app_inverse X).symm", "start": [182, 1], "end": [185, 78], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.shift_unop_opShiftFunctorEquivalence_counitIso_hom_app", "code": "lemma shift_unop_opShiftFunctorEquivalence_counitIso_hom_app (X : C\u1d52\u1d56) (n : \u2124) :\n    ((opShiftFunctorEquivalence C n).counitIso.hom.app X).unop\u27e6n\u27e7' =\n      ((opShiftFunctorEquivalence C n).unitIso.inv.app ((Opposite.op (X.unop\u27e6n\u27e7)))).unop :=\n  Quiver.Hom.op_inj ((opShiftFunctorEquivalence C n).unitInv_app_inverse X).symm", "start": [187, 1], "end": [190, 81], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_counitIso_inv_app_shift", "code": "lemma opShiftFunctorEquivalence_counitIso_inv_app_shift (X : C\u1d52\u1d56) (n : \u2124) :\n    (opShiftFunctorEquivalence C n).counitIso.inv.app (X\u27e6n\u27e7) =\n      ((opShiftFunctorEquivalence C n).unitIso.hom.app X)\u27e6n\u27e7' :=\n  (opShiftFunctorEquivalence C n).counitInv_app_functor X", "start": [192, 1], "end": [195, 58], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.opShiftFunctorEquivalence_counitIso_hom_app_shift", "code": "lemma opShiftFunctorEquivalence_counitIso_hom_app_shift (X : C\u1d52\u1d56) (n : \u2124) :\n    (opShiftFunctorEquivalence C n).counitIso.hom.app (X\u27e6n\u27e7) =\n      ((opShiftFunctorEquivalence C n).unitIso.inv.app X)\u27e6n\u27e7' :=\n  (opShiftFunctorEquivalence C n).counit_app_functor X", "start": [197, 1], "end": [200, 55], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor", "code": "@[simps]\nnoncomputable def functor : (Triangle C)\u1d52\u1d56 \u2964 Triangle C\u1d52\u1d56 where\n  obj T := Triangle.mk T.unop.mor\u2082.op T.unop.mor\u2081.op\n      ((opShiftFunctorEquivalence C 1).counitIso.inv.app (Opposite.op T.unop.obj\u2081) \u226b\n        T.unop.mor\u2083.op\u27e6(1 : \u2124)\u27e7')\n  map {T\u2081 T\u2082} \u03c6 :=\n    { hom\u2081 := \u03c6.unop.hom\u2083.op\n      hom\u2082 := \u03c6.unop.hom\u2082.op\n      hom\u2083 := \u03c6.unop.hom\u2081.op\n      comm\u2081 := Quiver.Hom.unop_inj \u03c6.unop.comm\u2082.symm\n      comm\u2082 := Quiver.Hom.unop_inj \u03c6.unop.comm\u2081.symm\n      comm\u2083 := by\n        dsimp\n        rw [assoc, \u2190 Functor.map_comp, \u2190 op_comp, \u2190 \u03c6.unop.comm\u2083, op_comp, Functor.map_comp,\n          opShiftFunctorEquivalence_counitIso_inv_naturality_assoc]\n        rfl }", "start": [206, 1], "end": [223, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.TriangleOpEquivalence.inverse", "code": "@[simps]\nnoncomputable def inverse : Triangle C\u1d52\u1d56 \u2964 (Triangle C)\u1d52\u1d56 where\n  obj T := Opposite.op (Triangle.mk T.mor\u2082.unop T.mor\u2081.unop\n      (((opShiftFunctorEquivalence C 1).unitIso.inv.app T.obj\u2081).unop \u226b T.mor\u2083.unop\u27e6(1 : \u2124)\u27e7'))\n  map {T\u2081 T\u2082} \u03c6 := Quiver.Hom.op\n    { hom\u2081 := \u03c6.hom\u2083.unop\n      hom\u2082 := \u03c6.hom\u2082.unop\n      hom\u2083 := \u03c6.hom\u2081.unop\n      comm\u2081 := Quiver.Hom.op_inj \u03c6.comm\u2082.symm\n      comm\u2082 := Quiver.Hom.op_inj \u03c6.comm\u2081.symm\n      comm\u2083 := Quiver.Hom.op_inj (by\n        dsimp\n        rw [assoc, \u2190 opShiftFunctorEquivalence_unitIso_inv_naturality,\n          \u2190 op_comp_assoc, \u2190 Functor.map_comp, \u2190 unop_comp, \u2190 \u03c6.comm\u2083,\n          unop_comp, Functor.map_comp, op_comp, assoc]) }", "start": [225, 1], "end": [241, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.TriangleOpEquivalence.unitIso", "code": "@[simps!]\nnoncomputable def unitIso : \ud835\udfed _ \u2245 functor C \u22d9 inverse C :=\n  NatIso.ofComponents (fun T => Iso.op\n    (Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) (by aesop_cat) (by aesop_cat)\n      (Quiver.Hom.op_inj\n        (by simp [shift_unop_opShiftFunctorEquivalence_counitIso_inv_app]))))\n    (fun {T\u2081 T\u2082} f => Quiver.Hom.unop_inj (by aesop_cat))", "start": [243, 1], "end": [251, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso", "code": "@[simps!]\nnoncomputable def counitIso : inverse C \u22d9 functor C \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents (fun T => by\n    refine' Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) _ _ _\n    \u00b7 aesop_cat\n    \u00b7 aesop_cat\n    \u00b7 dsimp\n      rw [Functor.map_id, comp_id, id_comp, Functor.map_comp,\n        \u2190 opShiftFunctorEquivalence_counitIso_inv_naturality_assoc,\n        opShiftFunctorEquivalence_counitIso_inv_app_shift, \u2190 Functor.map_comp,\n        Iso.hom_inv_id_app, Functor.map_id]\n      simp only [Functor.id_obj, comp_id])\n    (by aesop_cat)", "start": [253, 1], "end": [267, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.triangleOpEquivalence", "code": "@[simps]\nnoncomputable def triangleOpEquivalence :\n    (Triangle C)\u1d52\u1d56 \u224c Triangle C\u1d52\u1d56 where\n  functor := TriangleOpEquivalence.functor C\n  inverse := TriangleOpEquivalence.inverse C\n  unitIso := TriangleOpEquivalence.unitIso C\n  counitIso := TriangleOpEquivalence.counitIso C", "start": [271, 1], "end": [280, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.Opposite.distinguishedTriangles", "code": "def distinguishedTriangles : Set (Triangle C\u1d52\u1d56) :=\n  fun T => ((triangleOpEquivalence C).inverse.obj T).unop \u2208 distTriang C", "start": [287, 1], "end": [290, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.Opposite.mem_distinguishedTriangles_iff", "code": "lemma mem_distinguishedTriangles_iff (T : Triangle C\u1d52\u1d56) :\n    T \u2208 distinguishedTriangles C \u2194\n      ((triangleOpEquivalence C).inverse.obj T).unop \u2208 distTriang C := by\n  rfl", "start": [294, 1], "end": [297, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Opposite.mem_distinguishedTriangles_iff'", "code": "lemma mem_distinguishedTriangles_iff' (T : Triangle C\u1d52\u1d56) :\n    T \u2208 distinguishedTriangles C \u2194\n      \u2203 (T' : Triangle C) (_ : T' \u2208 distTriang C),\n        Nonempty (T \u2245 (triangleOpEquivalence C).functor.obj (Opposite.op T')) := by\n  rw [mem_distinguishedTriangles_iff]\n  constructor\n  \u00b7 intro hT\n    exact \u27e8_ ,hT, \u27e8(triangleOpEquivalence C).counitIso.symm.app T\u27e9\u27e9\n  \u00b7 rintro \u27e8T', hT', \u27e8e\u27e9\u27e9\n    refine' isomorphic_distinguished _ hT' _ _\n    exact Iso.unop ((triangleOpEquivalence C).unitIso.app (Opposite.op T') \u226a\u226b\n      (triangleOpEquivalence C).inverse.mapIso e.symm)", "start": [299, 1], "end": [310, 55], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Opposite.isomorphic_distinguished", "code": "lemma isomorphic_distinguished (T\u2081 : Triangle C\u1d52\u1d56)\n    (hT\u2081 : T\u2081 \u2208 distinguishedTriangles C) (T\u2082 : Triangle C\u1d52\u1d56) (e : T\u2082 \u2245 T\u2081) :\n    T\u2082 \u2208 distinguishedTriangles C := by\n  simp only [mem_distinguishedTriangles_iff] at hT\u2081 \u22a2\n  exact Pretriangulated.isomorphic_distinguished _ hT\u2081 _\n    ((triangleOpEquivalence C).inverse.mapIso e).unop.symm", "start": [312, 1], "end": [317, 59], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Opposite.contractibleTriangleIso", "code": "@[simps!]\nnoncomputable def contractibleTriangleIso (X : C\u1d52\u1d56) :\n    contractibleTriangle X \u2245 (triangleOpEquivalence C).functor.obj\n      (Opposite.op (contractibleTriangle X.unop).invRotate) :=\n  Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    (IsZero.iso (isZero_zero _) (by\n      dsimp\n      rw [IsZero.iff_id_eq_zero]\n      change (\ud835\udfd9 ((0 : C)\u27e6(-1 : \u2124)\u27e7)).op = 0\n      rw [\u2190 Functor.map_id, id_zero, Functor.map_zero, op_zero]))\n    (by aesop_cat) (by aesop_cat) (by aesop_cat)", "start": [319, 1], "end": [331, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.Opposite.contractible_distinguished", "code": "lemma contractible_distinguished (X : C\u1d52\u1d56) :\n    contractibleTriangle X \u2208 distinguishedTriangles C := by\n  rw [mem_distinguishedTriangles_iff']\n  exact \u27e8_, inv_rot_of_distTriang _ (Pretriangulated.contractible_distinguished X.unop),\n    \u27e8contractibleTriangleIso X\u27e9\u27e9", "start": [333, 1], "end": [337, 33], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Opposite.rotateTriangleOpEquivalenceInverseObjRotateUnopIso", "code": "noncomputable def rotateTriangleOpEquivalenceInverseObjRotateUnopIso (T : Triangle C\u1d52\u1d56) :\n    ((triangleOpEquivalence C).inverse.obj T.rotate).unop.rotate \u2245\n      ((triangleOpEquivalence C).inverse.obj T).unop :=\n  Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n      (-((opShiftFunctorEquivalence C 1).unitIso.app T.obj\u2081).unop) (by simp)\n        (Quiver.Hom.op_inj (by aesop_cat)) (by aesop_cat)", "start": [339, 1], "end": [346, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.Opposite.rotate_distinguished_triangle", "code": "lemma rotate_distinguished_triangle (T : Triangle C\u1d52\u1d56) :\n    T \u2208 distinguishedTriangles C \u2194 T.rotate \u2208 distinguishedTriangles C := by\n  simp only [mem_distinguishedTriangles_iff, Pretriangulated.rotate_distinguished_triangle\n    ((triangleOpEquivalence C).inverse.obj (T.rotate)).unop]\n  exact distinguished_iff_of_iso (rotateTriangleOpEquivalenceInverseObjRotateUnopIso T).symm", "start": [348, 1], "end": [352, 93], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Opposite.distinguished_cocone_triangle", "code": "lemma distinguished_cocone_triangle {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) :\n    \u2203 (Z : C\u1d52\u1d56) (g : Y \u27f6 Z) (h : Z \u27f6 X\u27e6(1 : \u2124)\u27e7),\n      Triangle.mk f g h \u2208 distinguishedTriangles C := by\n  obtain \u27e8Z, g, h, H\u27e9 := Pretriangulated.distinguished_cocone_triangle\u2081 f.unop\n  refine' \u27e8_, g.op, (opShiftFunctorEquivalence C 1).counitIso.inv.app (Opposite.op Z) \u226b\n    (shiftFunctor C\u1d52\u1d56 (1 : \u2124)).map h.op, _\u27e9\n  simp only [mem_distinguishedTriangles_iff]\n  refine' Pretriangulated.isomorphic_distinguished _ H _ _\n  exact Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) (by aesop_cat) (by aesop_cat)\n    (Quiver.Hom.op_inj (by simp [shift_unop_opShiftFunctorEquivalence_counitIso_inv_app]))", "start": [354, 1], "end": [363, 91], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Opposite.complete_distinguished_triangle_morphism", "code": "lemma complete_distinguished_triangle_morphism (T\u2081 T\u2082 : Triangle C\u1d52\u1d56)\n    (hT\u2081 : T\u2081 \u2208 distinguishedTriangles C) (hT\u2082 : T\u2082 \u2208 distinguishedTriangles C)\n    (a : T\u2081.obj\u2081 \u27f6 T\u2082.obj\u2081) (b : T\u2081.obj\u2082 \u27f6 T\u2082.obj\u2082) (comm : T\u2081.mor\u2081 \u226b b = a \u226b T\u2082.mor\u2081) :\n    \u2203 (c : T\u2081.obj\u2083 \u27f6 T\u2082.obj\u2083), T\u2081.mor\u2082 \u226b c = b \u226b T\u2082.mor\u2082 \u2227\n      T\u2081.mor\u2083 \u226b a\u27e61\u27e7' = c \u226b T\u2082.mor\u2083 := by\n  rw [mem_distinguishedTriangles_iff] at hT\u2081 hT\u2082\n  obtain \u27e8c, hc\u2081, hc\u2082\u27e9 :=\n    Pretriangulated.complete_distinguished_triangle_morphism\u2081 _ _ hT\u2082 hT\u2081\n      b.unop a.unop (Quiver.Hom.op_inj comm.symm)\n  dsimp at c hc\u2081 hc\u2082\n  replace hc\u2082 := ((opShiftFunctorEquivalence C 1).unitIso.hom.app T\u2082.obj\u2081).unop \u226b= hc\u2082\n  dsimp at hc\u2082\n  simp only [assoc, Iso.unop_hom_inv_id_app_assoc] at hc\u2082\n  refine' \u27e8c.op, Quiver.Hom.unop_inj hc\u2081.symm, Quiver.Hom.unop_inj _\u27e9\n  apply (shiftFunctor C (1 : \u2124)).map_injective\n  rw [unop_comp, unop_comp, Functor.map_comp, Functor.map_comp,\n    Quiver.Hom.unop_op, hc\u2082, \u2190 unop_comp_assoc, \u2190 unop_comp_assoc,\n    \u2190 opShiftFunctorEquivalence_unitIso_inv_naturality]\n  simp", "start": [365, 1], "end": [383, 7], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.mem_distTriang_op_iff", "code": "lemma mem_distTriang_op_iff (T : Triangle C\u1d52\u1d56) :\n    (T \u2208 distTriang C\u1d52\u1d56) \u2194 ((triangleOpEquivalence C).inverse.obj T).unop \u2208 distTriang C := by\n  rfl", "start": [403, 1], "end": [405, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.mem_distTriang_op_iff'", "code": "lemma mem_distTriang_op_iff' (T : Triangle C\u1d52\u1d56) :\n    (T \u2208 distTriang C\u1d52\u1d56) \u2194 \u2203 (T' : Triangle C) (_ : T' \u2208 distTriang C),\n      Nonempty (T \u2245 (triangleOpEquivalence C).functor.obj (Opposite.op T')) :=\n  Opposite.mem_distinguishedTriangles_iff' T", "start": [407, 1], "end": [410, 45], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.op_distinguished", "code": "lemma op_distinguished (T : Triangle C) (hT : T \u2208 distTriang C) :\n    ((triangleOpEquivalence C).functor.obj (Opposite.op T)) \u2208 distTriang C\u1d52\u1d56 := by\n  rw [mem_distTriang_op_iff']\n  exact \u27e8T, hT, \u27e8Iso.refl _\u27e9\u27e9", "start": [412, 1], "end": [415, 30], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.unop_distinguished", "code": "lemma unop_distinguished (T : Triangle C\u1d52\u1d56) (hT : T \u2208 distTriang C\u1d52\u1d56) :\n    ((triangleOpEquivalence C).inverse.obj T).unop \u2208 distTriang C := hT", "start": [417, 1], "end": [418, 72], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/CategoryTheory/Adhesive.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/KernelPair.lean", "Mathlib/CategoryTheory/Extensive.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.IsPushout.IsVanKampen", "code": "@[nolint unusedArguments]\ndef IsPushout.IsVanKampen (_ : IsPushout f g h i) : Prop :=\n  \u2200 \u2983W' X' Y' Z' : C\u2984 (f' : W' \u27f6 X') (g' : W' \u27f6 Y') (h' : X' \u27f6 Z') (i' : Y' \u27f6 Z') (\u03b1W : W' \u27f6 W)\n    (\u03b1X : X' \u27f6 X) (\u03b1Y : Y' \u27f6 Y) (\u03b1Z : Z' \u27f6 Z) (_ : IsPullback f' \u03b1W \u03b1X f)\n    (_ : IsPullback g' \u03b1W \u03b1Y g) (_ : CommSq h' \u03b1X \u03b1Z h) (_ : CommSq i' \u03b1Y \u03b1Z i)\n    (_ : CommSq f' g' h' i'), IsPushout f' g' h' i' \u2194 IsPullback h' \u03b1X \u03b1Z h \u2227 IsPullback i' \u03b1Y \u03b1Z i", "start": [54, 1], "end": [61, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsPushout.IsVanKampen.flip", "code": "theorem IsPushout.IsVanKampen.flip {H : IsPushout f g h i} (H' : H.IsVanKampen) :\n    H.flip.IsVanKampen", "start": [64, 1], "end": [68, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsPushout.isVanKampen_iff", "code": "theorem IsPushout.isVanKampen_iff (H : IsPushout f g h i) :\n    H.IsVanKampen \u2194 IsVanKampenColimit (PushoutCocone.mk h i H.w)", "start": [71, 1], "end": [115, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.is_coprod_iff_isPushout", "code": "theorem is_coprod_iff_isPushout {X E Y YE : C} (c : BinaryCofan X E) (hc : IsColimit c) {f : X \u27f6 Y}\n    {iY : Y \u27f6 YE} {fE : c.pt \u27f6 YE} (H : CommSq f c.inl iY fE) :\n    Nonempty (IsColimit (BinaryCofan.mk (c.inr \u226b fE) iY)) \u2194 IsPushout f c.inl iY fE", "start": [118, 1], "end": [148, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsPushout.isVanKampen_inl", "code": "theorem IsPushout.isVanKampen_inl {W E X Z : C} (c : BinaryCofan W E) [FinitaryExtensive C]\n    [HasPullbacks C] (hc : IsColimit c) (f : W \u27f6 X) (h : X \u27f6 Z) (i : c.pt \u27f6 Z)\n    (H : IsPushout f c.inl h i) : H.IsVanKampen", "start": [151, 1], "end": [188, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsPushout.IsVanKampen.isPullback_of_mono_left", "code": "theorem IsPushout.IsVanKampen.isPullback_of_mono_left [Mono f] {H : IsPushout f g h i}\n    (H' : H.IsVanKampen) : IsPullback f g h i", "start": [191, 1], "end": [195, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsPushout.IsVanKampen.isPullback_of_mono_right", "code": "theorem IsPushout.IsVanKampen.isPullback_of_mono_right [Mono g] {H : IsPushout f g h i}\n    (H' : H.IsVanKampen) : IsPullback f g h i", "start": [198, 1], "end": [202, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsPushout.IsVanKampen.mono_of_mono_left", "code": "theorem IsPushout.IsVanKampen.mono_of_mono_left [Mono f] {H : IsPushout f g h i}\n    (H' : H.IsVanKampen) : Mono i", "start": [205, 1], "end": [210, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsPushout.IsVanKampen.mono_of_mono_right", "code": "theorem IsPushout.IsVanKampen.mono_of_mono_right [Mono g] {H : IsPushout f g h i}\n    (H' : H.IsVanKampen) : Mono h", "start": [213, 1], "end": [218, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adhesive", "code": "class Adhesive (C : Type u) [Category.{v} C] : Prop where\n  [hasPullback_of_mono_left : \u2200 {X Y S : C} (f : X \u27f6 S) (g : Y \u27f6 S) [Mono f], HasPullback f g]\n  [hasPushout_of_mono_left : \u2200 {X Y S : C} (f : S \u27f6 X) (g : S \u27f6 Y) [Mono f], HasPushout f g]\n  van_kampen : \u2200 {W X Y Z : C} {f : W \u27f6 X} {g : W \u27f6 Y} {h : X \u27f6 Z} {i : Y \u27f6 Z} [Mono f]\n    (H : IsPushout f g h i), H.IsVanKampen", "start": [221, 1], "end": [227, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adhesive.van_kampen'", "code": "theorem Adhesive.van_kampen' [Adhesive C] [Mono g] (H : IsPushout f g h i) : H.IsVanKampen", "start": [232, 1], "end": [233, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adhesive.isPullback_of_isPushout_of_mono_left", "code": "theorem Adhesive.isPullback_of_isPushout_of_mono_left [Adhesive C] (H : IsPushout f g h i)\n    [Mono f] : IsPullback f g h i", "start": [236, 1], "end": [238, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adhesive.isPullback_of_isPushout_of_mono_right", "code": "theorem Adhesive.isPullback_of_isPushout_of_mono_right [Adhesive C] (H : IsPushout f g h i)\n    [Mono g] : IsPullback f g h i", "start": [241, 1], "end": [243, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adhesive.mono_of_isPushout_of_mono_left", "code": "theorem Adhesive.mono_of_isPushout_of_mono_left [Adhesive C] (H : IsPushout f g h i) [Mono f] :\n    Mono i", "start": [246, 1], "end": [248, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adhesive.mono_of_isPushout_of_mono_right", "code": "theorem Adhesive.mono_of_isPushout_of_mono_right [Adhesive C] (H : IsPushout f g h i) [Mono g] :\n    Mono h", "start": [251, 1], "end": [253, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Type.adhesive", "code": "instance Type.adhesive : Adhesive (Type u) :=\n  \u27e8fun {_ _ _ _ f _ _ _ _} H =>\n    (IsPushout.isVanKampen_inl _ (Types.isCoprodOfMono f) _ _ _ H.flip).flip\u27e9", "start": [256, 1], "end": [258, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adhesive.toRegularMonoCategory", "code": "noncomputable instance (priority := 100) Adhesive.toRegularMonoCategory [Adhesive C] :\n    RegularMonoCategory C :=\n  \u27e8fun f _ =>\n    { Z := pushout f f\n      left := pushout.inl\n      right := pushout.inr\n      w := pushout.condition\n      isLimit := (Adhesive.isPullback_of_isPushout_of_mono_left\n        (IsPushout.of_hasPushout f f)).isLimitFork }\u27e9", "start": [261, 1], "end": [269, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/String/Basic.lean", "imports": ["Mathlib/Data/List/Lex.lean", "Mathlib/Data/Char.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "String.ltb", "code": "def ltb (s\u2081 s\u2082 : Iterator) : Bool :=\n  if s\u2082.hasNext then\n    if s\u2081.hasNext then\n      if s\u2081.curr = s\u2082.curr then\n        ltb s\u2081.next s\u2082.next\n      else s\u2081.curr < s\u2082.curr\n    else true\n  else false", "start": [19, 1], "end": [27, 13], "kind": "commanddeclaration"}, {"full_name": "String.LT'", "code": "instance LT' : LT String :=\n  \u27e8fun s\u2081 s\u2082 \u21a6 ltb s\u2081.iter s\u2082.iter\u27e9", "start": [30, 1], "end": [31, 36], "kind": "commanddeclaration"}, {"full_name": "String.decidableLT", "code": "instance decidableLT : @DecidableRel String (\u00b7 < \u00b7) := by\n  simp only [LT']\n  infer_instance", "start": [34, 1], "end": [36, 17], "kind": "commanddeclaration"}, {"full_name": "String.ltb.inductionOn", "code": "def ltb.inductionOn.{u} {motive : Iterator \u2192 Iterator \u2192 Sort u} (it\u2081 it\u2082 : Iterator)\n    (ind : \u2200 s\u2081 s\u2082 i\u2081 i\u2082, Iterator.hasNext \u27e8s\u2082, i\u2082\u27e9 \u2192 Iterator.hasNext \u27e8s\u2081, i\u2081\u27e9 \u2192\n      get s\u2081 i\u2081 = get s\u2082 i\u2082 \u2192 motive (Iterator.next \u27e8s\u2081, i\u2081\u27e9) (Iterator.next \u27e8s\u2082, i\u2082\u27e9) \u2192\n      motive \u27e8s\u2081, i\u2081\u27e9 \u27e8s\u2082, i\u2082\u27e9)\n    (eq : \u2200 s\u2081 s\u2082 i\u2081 i\u2082, Iterator.hasNext \u27e8s\u2082, i\u2082\u27e9 \u2192 Iterator.hasNext \u27e8s\u2081, i\u2081\u27e9 \u2192\n      \u00ac get s\u2081 i\u2081 = get s\u2082 i\u2082 \u2192 motive \u27e8s\u2081, i\u2081\u27e9 \u27e8s\u2082, i\u2082\u27e9)\n    (base\u2081 : \u2200 s\u2081 s\u2082 i\u2081 i\u2082, Iterator.hasNext \u27e8s\u2082, i\u2082\u27e9 \u2192 \u00ac Iterator.hasNext \u27e8s\u2081, i\u2081\u27e9 \u2192\n      motive \u27e8s\u2081, i\u2081\u27e9 \u27e8s\u2082, i\u2082\u27e9)\n    (base\u2082 : \u2200 s\u2081 s\u2082 i\u2081 i\u2082, \u00ac Iterator.hasNext \u27e8s\u2082, i\u2082\u27e9 \u2192 motive \u27e8s\u2081, i\u2081\u27e9 \u27e8s\u2082, i\u2082\u27e9) :\n    motive it\u2081 it\u2082 :=\n  if h\u2082 : it\u2082.hasNext then\n    if h\u2081 : it\u2081.hasNext then\n      if heq : it\u2081.curr = it\u2082.curr then\n        ind it\u2081.s it\u2082.s it\u2081.i it\u2082.i h\u2082 h\u2081 heq (inductionOn it\u2081.next it\u2082.next ind eq base\u2081 base\u2082)\n      else eq it\u2081.s it\u2082.s it\u2081.i it\u2082.i h\u2082 h\u2081 heq\n    else base\u2081 it\u2081.s it\u2082.s it\u2081.i it\u2082.i h\u2082 h\u2081\n  else base\u2082 it\u2081.s it\u2082.s it\u2081.i it\u2082.i h\u2082", "start": [39, 1], "end": [56, 40], "kind": "commanddeclaration"}, {"full_name": "String.ltb_cons_addChar", "code": "theorem ltb_cons_addChar (c : Char) (cs\u2081 cs\u2082 : List Char) (i\u2081 i\u2082 : Pos) :\n    ltb \u27e8\u27e8c :: cs\u2081\u27e9, i\u2081 + c\u27e9 \u27e8\u27e8c :: cs\u2082\u27e9, i\u2082 + c\u27e9 = ltb \u27e8\u27e8cs\u2081\u27e9, i\u2081\u27e9 \u27e8\u27e8cs\u2082\u27e9, i\u2082\u27e9", "start": [58, 1], "end": [72, 46], "kind": "commanddeclaration"}, {"full_name": "String.lt_iff_toList_lt", "code": "@[simp]\ntheorem lt_iff_toList_lt : \u2200 {s\u2081 s\u2082 : String}, s\u2081 < s\u2082 \u2194 s\u2081.toList < s\u2082.toList", "start": [74, 1], "end": [98, 21], "kind": "commanddeclaration"}, {"full_name": "String.LE", "code": "instance LE : LE String :=\n  \u27e8fun s\u2081 s\u2082 \u21a6 \u00acs\u2082 < s\u2081\u27e9", "start": [101, 1], "end": [102, 25], "kind": "commanddeclaration"}, {"full_name": "String.decidableLE", "code": "instance decidableLE : @DecidableRel String (\u00b7 \u2264 \u00b7) := by\n  simp only [LE]\n  infer_instance", "start": [105, 1], "end": [107, 17], "kind": "commanddeclaration"}, {"full_name": "String.le_iff_toList_le", "code": "@[simp]\ntheorem le_iff_toList_le {s\u2081 s\u2082 : String} : s\u2081 \u2264 s\u2082 \u2194 s\u2081.toList \u2264 s\u2082.toList", "start": [110, 1], "end": [112, 44], "kind": "commanddeclaration"}, {"full_name": "String.toList_inj", "code": "theorem toList_inj {s\u2081 s\u2082 : String} : s\u2081.toList = s\u2082.toList \u2194 s\u2081 = s\u2082", "start": [115, 1], "end": [116, 35], "kind": "commanddeclaration"}, {"full_name": "String.nil_asString_eq_empty", "code": "theorem nil_asString_eq_empty : [].asString = \"\"", "start": [119, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "String.toList_empty", "code": "@[simp]\ntheorem toList_empty : \"\".toList = []", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "String.asString_inv_toList", "code": "theorem asString_inv_toList (s : String) : s.toList.asString = s", "start": [128, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "String.toList_nonempty", "code": "theorem toList_nonempty : \u2200 {s : String}, s \u2260 \"\" \u2192 s.toList = s.head :: (s.drop 1).toList", "start": [134, 1], "end": [140, 44], "kind": "commanddeclaration"}, {"full_name": "String.head_empty", "code": "@[simp]\ntheorem head_empty : \"\".data.head! = default", "start": [143, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "List.toList_inv_asString", "code": "theorem List.toList_inv_asString (l : List Char) : l.asString.toList = l", "start": [175, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "List.length_asString", "code": "@[simp]\ntheorem List.length_asString (l : List Char) : l.asString.length = l.length", "start": [179, 1], "end": [181, 6], "kind": "commanddeclaration"}, {"full_name": "List.asString_inj", "code": "@[simp]\ntheorem List.asString_inj {l l' : List Char} : l.asString = l'.asString \u2194 l = l'", "start": [184, 1], "end": [187, 20], "kind": "commanddeclaration"}, {"full_name": "String.length_data", "code": "@[simp]\ntheorem String.length_data (s : String) : s.data.length = s.length", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "List.asString_eq", "code": "theorem List.asString_eq {l : List Char} {s : String} : l.asString = s \u2194 l = s.toList", "start": [195, 1], "end": [196, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/InverseDeriv.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.deriv_arcsin_aux", "code": "theorem deriv_arcsin_aux {x : \u211d} (h\u2081 : x \u2260 -1) (h\u2082 : x \u2260 1) :\n    HasStrictDerivAt arcsin (1 / sqrt (1 - x ^ 2)) x \u2227 ContDiffAt \u211d \u22a4 arcsin x", "start": [30, 1], "end": [49, 51], "kind": "commanddeclaration"}, {"full_name": "Real.hasStrictDerivAt_arcsin", "code": "theorem hasStrictDerivAt_arcsin {x : \u211d} (h\u2081 : x \u2260 -1) (h\u2082 : x \u2260 1) :\n    HasStrictDerivAt arcsin (1 / sqrt (1 - x ^ 2)) x", "start": [52, 1], "end": [54, 29], "kind": "commanddeclaration"}, {"full_name": "Real.hasDerivAt_arcsin", "code": "theorem hasDerivAt_arcsin {x : \u211d} (h\u2081 : x \u2260 -1) (h\u2082 : x \u2260 1) :\n    HasDerivAt arcsin (1 / sqrt (1 - x ^ 2)) x", "start": [57, 1], "end": [59, 45], "kind": "commanddeclaration"}, {"full_name": "Real.contDiffAt_arcsin", "code": "theorem contDiffAt_arcsin {x : \u211d} (h\u2081 : x \u2260 -1) (h\u2082 : x \u2260 1) {n : \u2115\u221e} : ContDiffAt \u211d n arcsin x", "start": [62, 1], "end": [63, 42], "kind": "commanddeclaration"}, {"full_name": "Real.hasDerivWithinAt_arcsin_Ici", "code": "theorem hasDerivWithinAt_arcsin_Ici {x : \u211d} (h : x \u2260 -1) :\n    HasDerivWithinAt arcsin (1 / sqrt (1 - x ^ 2)) (Ici x) x", "start": [66, 1], "end": [71, 52], "kind": "commanddeclaration"}, {"full_name": "Real.hasDerivWithinAt_arcsin_Iic", "code": "theorem hasDerivWithinAt_arcsin_Iic {x : \u211d} (h : x \u2260 1) :\n    HasDerivWithinAt arcsin (1 / sqrt (1 - x ^ 2)) (Iic x) x", "start": [74, 1], "end": [79, 52], "kind": "commanddeclaration"}, {"full_name": "Real.differentiableWithinAt_arcsin_Ici", "code": "theorem differentiableWithinAt_arcsin_Ici {x : \u211d} :\n    DifferentiableWithinAt \u211d arcsin (Ici x) x \u2194 x \u2260 -1", "start": [82, 1], "end": [90, 92], "kind": "commanddeclaration"}, {"full_name": "Real.differentiableWithinAt_arcsin_Iic", "code": "theorem differentiableWithinAt_arcsin_Iic {x : \u211d} :\n    DifferentiableWithinAt \u211d arcsin (Iic x) x \u2194 x \u2260 1", "start": [93, 1], "end": [98, 64], "kind": "commanddeclaration"}, {"full_name": "Real.differentiableAt_arcsin", "code": "theorem differentiableAt_arcsin {x : \u211d} : DifferentiableAt \u211d arcsin x \u2194 x \u2260 -1 \u2227 x \u2260 1", "start": [101, 1], "end": [104, 59], "kind": "commanddeclaration"}, {"full_name": "Real.deriv_arcsin", "code": "@[simp]\ntheorem deriv_arcsin : deriv arcsin = fun x => 1 / sqrt (1 - x ^ 2)", "start": [107, 1], "end": [114, 39], "kind": "commanddeclaration"}, {"full_name": "Real.differentiableOn_arcsin", "code": "theorem differentiableOn_arcsin : DifferentiableOn \u211d arcsin {-1, 1}\u1d9c", "start": [117, 1], "end": [119, 79], "kind": "commanddeclaration"}, {"full_name": "Real.contDiffOn_arcsin", "code": "theorem contDiffOn_arcsin {n : \u2115\u221e} : ContDiffOn \u211d n arcsin {-1, 1}\u1d9c", "start": [122, 1], "end": [123, 69], "kind": "commanddeclaration"}, {"full_name": "Real.contDiffAt_arcsin_iff", "code": "theorem contDiffAt_arcsin_iff {x : \u211d} {n : \u2115\u221e} : ContDiffAt \u211d n arcsin x \u2194 n = 0 \u2228 x \u2260 -1 \u2227 x \u2260 1", "start": [126, 1], "end": [130, 35], "kind": "commanddeclaration"}, {"full_name": "Real.hasStrictDerivAt_arccos", "code": "theorem hasStrictDerivAt_arccos {x : \u211d} (h\u2081 : x \u2260 -1) (h\u2082 : x \u2260 1) :\n    HasStrictDerivAt arccos (-(1 / sqrt (1 - x ^ 2))) x", "start": [137, 1], "end": [139, 52], "kind": "commanddeclaration"}, {"full_name": "Real.hasDerivAt_arccos", "code": "theorem hasDerivAt_arccos {x : \u211d} (h\u2081 : x \u2260 -1) (h\u2082 : x \u2260 1) :\n    HasDerivAt arccos (-(1 / sqrt (1 - x ^ 2))) x", "start": [142, 1], "end": [144, 46], "kind": "commanddeclaration"}, {"full_name": "Real.contDiffAt_arccos", "code": "theorem contDiffAt_arccos {x : \u211d} (h\u2081 : x \u2260 -1) (h\u2082 : x \u2260 1) {n : \u2115\u221e} : ContDiffAt \u211d n arccos x", "start": [147, 1], "end": [148, 49], "kind": "commanddeclaration"}, {"full_name": "Real.hasDerivWithinAt_arccos_Ici", "code": "theorem hasDerivWithinAt_arccos_Ici {x : \u211d} (h : x \u2260 -1) :\n    HasDerivWithinAt arccos (-(1 / sqrt (1 - x ^ 2))) (Ici x) x", "start": [151, 1], "end": [153, 46], "kind": "commanddeclaration"}, {"full_name": "Real.hasDerivWithinAt_arccos_Iic", "code": "theorem hasDerivWithinAt_arccos_Iic {x : \u211d} (h : x \u2260 1) :\n    HasDerivWithinAt arccos (-(1 / sqrt (1 - x ^ 2))) (Iic x) x", "start": [156, 1], "end": [158, 46], "kind": "commanddeclaration"}, {"full_name": "Real.differentiableWithinAt_arccos_Ici", "code": "theorem differentiableWithinAt_arccos_Ici {x : \u211d} :\n    DifferentiableWithinAt \u211d arccos (Ici x) x \u2194 x \u2260 -1", "start": [161, 1], "end": [163, 83], "kind": "commanddeclaration"}, {"full_name": "Real.differentiableWithinAt_arccos_Iic", "code": "theorem differentiableWithinAt_arccos_Iic {x : \u211d} :\n    DifferentiableWithinAt \u211d arccos (Iic x) x \u2194 x \u2260 1", "start": [166, 1], "end": [168, 83], "kind": "commanddeclaration"}, {"full_name": "Real.differentiableAt_arccos", "code": "theorem differentiableAt_arccos {x : \u211d} : DifferentiableAt \u211d arccos x \u2194 x \u2260 -1 \u2227 x \u2260 1", "start": [171, 1], "end": [172, 67], "kind": "commanddeclaration"}, {"full_name": "Real.deriv_arccos", "code": "@[simp]\ntheorem deriv_arccos : deriv arccos = fun x => -(1 / sqrt (1 - x ^ 2))", "start": [175, 1], "end": [177, 75], "kind": "commanddeclaration"}, {"full_name": "Real.differentiableOn_arccos", "code": "theorem differentiableOn_arccos : DifferentiableOn \u211d arccos {-1, 1}\u1d9c", "start": [180, 1], "end": [181, 38], "kind": "commanddeclaration"}, {"full_name": "Real.contDiffOn_arccos", "code": "theorem contDiffOn_arccos {n : \u2115\u221e} : ContDiffOn \u211d n arccos {-1, 1}\u1d9c", "start": [184, 1], "end": [185, 41], "kind": "commanddeclaration"}, {"full_name": "Real.contDiffAt_arccos_iff", "code": "theorem contDiffAt_arccos_iff {x : \u211d} {n : \u2115\u221e} :\n    ContDiffAt \u211d n arccos x \u2194 n = 0 \u2228 x \u2260 -1 \u2227 x \u2260 1", "start": [188, 1], "end": [191, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Abelian/LeftDerived.lean", "imports": ["Mathlib/CategoryTheory/Functor/LeftDerived.lean", "Mathlib/CategoryTheory/Abelian/Homology.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Constructions/EpiMono.lean", "Mathlib/CategoryTheory/Abelian/Projective.lean"], "premises": [{"full_name": "CategoryTheory.Abelian.Functor.preserves_exact_of_PreservesFiniteColimits_of_epi", "code": "theorem preserves_exact_of_PreservesFiniteColimits_of_epi [PreservesFiniteColimits F] [Epi g]\n    (ex : Exact f g) : Exact (F.map f) (F.map g)", "start": [47, 1], "end": [52, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.exact_of_map_projectiveResolution", "code": "theorem exact_of_map_projectiveResolution (P : ProjectiveResolution X)\n    [PreservesFiniteColimits F] :\n    Exact (((F.mapHomologicalComplex (ComplexShape.down \u2115)).obj P.complex).dTo 0)\n      (F.map (P.\u03c0.f 0))", "start": [55, 1], "end": [65, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.leftDerivedZeroToSelfApp", "code": "def leftDerivedZeroToSelfApp [EnoughProjectives C] {X : C} (P : ProjectiveResolution X) :\n    (F.leftDerived 0).obj X \u27f6 F.obj X :=\n  (leftDerivedObjIso F 0 P).hom \u226b\n    homology.desc' _ _ _ (kernel.\u03b9 _ \u226b F.map (P.\u03c0.f 0))\n      (by\n        rw [kernel.lift_\u03b9_assoc,\n          HomologicalComplex.dTo_eq _ (by simp : (ComplexShape.down \u2115).Rel 1 0),\n          mapHomologicalComplex_obj_d, Category.assoc, \u2190 Functor.map_comp]\n        simp)", "start": [68, 1], "end": [77, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.leftDerivedZeroToSelfAppInv", "code": "def leftDerivedZeroToSelfAppInv [EnoughProjectives C] [PreservesFiniteColimits F] {X : C}\n    (P : ProjectiveResolution X) : F.obj X \u27f6 (F.leftDerived 0).obj X := by\n  have := isIso_cokernel_desc_of_exact_of_epi _ _ (exact_of_map_projectiveResolution F P)\n  refine'\n    (asIso (cokernel.desc _ _ (exact_of_map_projectiveResolution F P).w)).inv \u226b\n      _ \u226b (homologyIsoCokernelLift _ _ _).inv \u226b (leftDerivedObjIso F 0 P).inv\n  refine' cokernel.map _ _ (\ud835\udfd9 _) (kernel.lift _ (\ud835\udfd9 _) (by simp)) _\n  ext\n  simp only [Category.assoc, kernel.lift_\u03b9, Category.comp_id, Category.id_comp]", "start": [80, 1], "end": [92, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.leftDerivedZeroToSelfApp_comp_inv", "code": "theorem leftDerivedZeroToSelfApp_comp_inv [EnoughProjectives C] [PreservesFiniteColimits F] {X : C}\n    (P : ProjectiveResolution X) :\n    leftDerivedZeroToSelfApp F P \u226b leftDerivedZeroToSelfAppInv F P = \ud835\udfd9 _", "start": [95, 1], "end": [119, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.leftDerivedZeroToSelfAppInv_comp", "code": "@[nolint unusedHavesSuffices]\ntheorem leftDerivedZeroToSelfAppInv_comp [EnoughProjectives C] [PreservesFiniteColimits F] {X : C}\n    (P : ProjectiveResolution X) :\n    leftDerivedZeroToSelfAppInv F P \u226b leftDerivedZeroToSelfApp F P = \ud835\udfd9 _", "start": [124, 1], "end": [146, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.leftDerivedZeroToSelfAppIso", "code": "def leftDerivedZeroToSelfAppIso [EnoughProjectives C] [PreservesFiniteColimits F] {X : C}\n    (P : ProjectiveResolution X) : (F.leftDerived 0).obj X \u2245 F.obj X where\n  hom := leftDerivedZeroToSelfApp _ P\n  inv := leftDerivedZeroToSelfAppInv _ P\n  hom_inv_id := leftDerivedZeroToSelfApp_comp_inv _ P\n  inv_hom_id := leftDerivedZeroToSelfAppInv_comp _ P", "start": [149, 1], "end": [156, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.leftDerived_zero_to_self_natural", "code": "theorem leftDerived_zero_to_self_natural [EnoughProjectives C] {X : C} {Y : C} (f : X \u27f6 Y)\n    (P : ProjectiveResolution X) (Q : ProjectiveResolution Y) :\n    (F.leftDerived 0).map f \u226b leftDerivedZeroToSelfApp F Q =\n      leftDerivedZeroToSelfApp F P \u226b F.map f", "start": [159, 1], "end": [176, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.leftDerivedZeroIsoSelf", "code": "def leftDerivedZeroIsoSelf [EnoughProjectives C] [PreservesFiniteColimits F] :\n    F.leftDerived 0 \u2245 F :=\n  NatIso.ofComponents (fun X => leftDerivedZeroToSelfAppIso _ (ProjectiveResolution.of X))\n    fun {_ _} _ => leftDerived_zero_to_self_natural _ _ _ _", "start": [179, 1], "end": [183, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Noetherian.lean", "imports": ["Mathlib/CategoryTheory/Subobject/Lattice.lean", "Mathlib/CategoryTheory/EssentiallySmall.lean", "Mathlib/CategoryTheory/Simple.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.NoetherianObject", "code": "class NoetherianObject (X : C) : Prop where\n  subobject_gt_wellFounded' : WellFounded ((\u00b7 > \u00b7) : Subobject X \u2192 Subobject X \u2192 Prop)", "start": [34, 1], "end": [40, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NoetherianObject.subobject_gt_wellFounded", "code": "lemma NoetherianObject.subobject_gt_wellFounded (X : C) [NoetherianObject X] :\n    WellFounded ((\u00b7 > \u00b7) : Subobject X \u2192 Subobject X \u2192 Prop) :=\n  NoetherianObject.subobject_gt_wellFounded'", "start": [43, 1], "end": [45, 45], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ArtinianObject", "code": "class ArtinianObject (X : C) : Prop where\n  subobject_lt_wellFounded' : WellFounded ((\u00b7 < \u00b7) : Subobject X \u2192 Subobject X \u2192 Prop)", "start": [47, 1], "end": [53, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ArtinianObject.subobject_lt_wellFounded", "code": "lemma ArtinianObject.subobject_lt_wellFounded (X : C) [ArtinianObject X] :\n    WellFounded ((\u00b7 < \u00b7) : Subobject X \u2192 Subobject X \u2192 Prop) :=\n  ArtinianObject.subobject_lt_wellFounded'", "start": [56, 1], "end": [58, 43], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Noetherian", "code": "class Noetherian extends EssentiallySmall C : Prop where\n  noetherianObject : \u2200 X : C, NoetherianObject X", "start": [62, 1], "end": [64, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Artinian", "code": "class Artinian extends EssentiallySmall C : Prop where\n  artinianObject : \u2200 X : C, ArtinianObject X", "start": [69, 1], "end": [71, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.exists_simple_subobject", "code": "theorem exists_simple_subobject {X : C} [ArtinianObject X] (h : \u00acIsZero X) :\n    \u2203 Y : Subobject X, Simple (Y : C)", "start": [82, 1], "end": [87, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.simpleSubobject", "code": "noncomputable def simpleSubobject {X : C} [ArtinianObject X] (h : \u00acIsZero X) : C :=\n  (exists_simple_subobject h).choose", "start": [90, 1], "end": [92, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.simpleSubobjectArrow", "code": "noncomputable def simpleSubobjectArrow {X : C} [ArtinianObject X] (h : \u00acIsZero X) :\n    simpleSubobject h \u27f6 X :=\n  (exists_simple_subobject h).choose.arrow", "start": [95, 1], "end": [98, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mono_simpleSubobjectArrow", "code": "instance mono_simpleSubobjectArrow {X : C} [ArtinianObject X] (h : \u00acIsZero X) :\n    Mono (simpleSubobjectArrow h) := by\n  dsimp only [simpleSubobjectArrow]\n  infer_instance", "start": [101, 1], "end": [104, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/MonoidAlgebra/ToDirectSum.lean", "imports": ["Mathlib/Algebra/MonoidAlgebra/Basic.lean", "Mathlib/Data/Finsupp/ToDFinsupp.lean", "Mathlib/Algebra/DirectSum/Algebra.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddMonoidAlgebra.toDirectSum", "code": "def AddMonoidAlgebra.toDirectSum [Semiring M] (f : AddMonoidAlgebra M \u03b9) : \u2a01 _ : \u03b9, M :=\n  Finsupp.toDFinsupp f", "start": [69, 1], "end": [71, 23], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.toDirectSum_single", "code": "@[simp]\ntheorem AddMonoidAlgebra.toDirectSum_single (i : \u03b9) (m : M) :\n    AddMonoidAlgebra.toDirectSum (Finsupp.single i m) = DirectSum.of _ i m", "start": [78, 1], "end": [81, 32], "kind": "commanddeclaration"}, {"full_name": "DirectSum.toAddMonoidAlgebra", "code": "def DirectSum.toAddMonoidAlgebra (f : \u2a01 _ : \u03b9, M) : AddMonoidAlgebra M \u03b9 :=\n  DFinsupp.toFinsupp f", "start": [86, 1], "end": [88, 23], "kind": "commanddeclaration"}, {"full_name": "DirectSum.toAddMonoidAlgebra_of", "code": "@[simp]\ntheorem DirectSum.toAddMonoidAlgebra_of (i : \u03b9) (m : M) :\n    (DirectSum.of _ i m : \u2a01 _ : \u03b9, M).toAddMonoidAlgebra = Finsupp.single i m", "start": [91, 1], "end": [94, 32], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.toDirectSum_toAddMonoidAlgebra", "code": "@[simp]\ntheorem AddMonoidAlgebra.toDirectSum_toAddMonoidAlgebra (f : AddMonoidAlgebra M \u03b9) :\n    f.toDirectSum.toAddMonoidAlgebra = f", "start": [97, 1], "end": [100, 33], "kind": "commanddeclaration"}, {"full_name": "DirectSum.toAddMonoidAlgebra_toDirectSum", "code": "@[simp]\ntheorem DirectSum.toAddMonoidAlgebra_toDirectSum (f : \u2a01 _ : \u03b9, M) :\n    f.toAddMonoidAlgebra.toDirectSum = f", "start": [103, 1], "end": [106, 64], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.toDirectSum_zero", "code": "@[simp]\ntheorem toDirectSum_zero [Semiring M] : (0 : AddMonoidAlgebra M \u03b9).toDirectSum = 0", "start": [120, 1], "end": [122, 26], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.toDirectSum_add", "code": "@[simp]\ntheorem toDirectSum_add [Semiring M] (f g : AddMonoidAlgebra M \u03b9) :\n    (f + g).toDirectSum = f.toDirectSum + g.toDirectSum", "start": [125, 1], "end": [128, 29], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.toDirectSum_mul", "code": "@[simp]\ntheorem toDirectSum_mul [DecidableEq \u03b9] [AddMonoid \u03b9] [Semiring M] (f g : AddMonoidAlgebra M \u03b9) :\n    (f * g).toDirectSum = f.toDirectSum * g.toDirectSum", "start": [131, 1], "end": [159, 42], "kind": "commanddeclaration"}, {"full_name": "DirectSum.toAddMonoidAlgebra_zero", "code": "@[simp]\ntheorem toAddMonoidAlgebra_zero [Semiring M] [\u2200 m : M, Decidable (m \u2260 0)] :\n    toAddMonoidAlgebra 0 = (0 : AddMonoidAlgebra M \u03b9)", "start": [168, 1], "end": [171, 26], "kind": "commanddeclaration"}, {"full_name": "DirectSum.toAddMonoidAlgebra_add", "code": "@[simp]\ntheorem toAddMonoidAlgebra_add [Semiring M] [\u2200 m : M, Decidable (m \u2260 0)] (f g : \u2a01 _ : \u03b9, M) :\n    (f + g).toAddMonoidAlgebra = toAddMonoidAlgebra f + toAddMonoidAlgebra g", "start": [174, 1], "end": [177, 29], "kind": "commanddeclaration"}, {"full_name": "DirectSum.toAddMonoidAlgebra_mul", "code": "@[simp]\ntheorem toAddMonoidAlgebra_mul [AddMonoid \u03b9] [Semiring M]\n    [\u2200 m : M, Decidable (m \u2260 0)] (f g : \u2a01 _ : \u03b9, M) :\n    (f * g).toAddMonoidAlgebra = toAddMonoidAlgebra f * toAddMonoidAlgebra g", "start": [180, 1], "end": [187, 58], "kind": "commanddeclaration"}, {"full_name": "addMonoidAlgebraEquivDirectSum", "code": "@[simps (config := { fullyApplied := false })]\ndef addMonoidAlgebraEquivDirectSum [DecidableEq \u03b9] [Semiring M] [\u2200 m : M, Decidable (m \u2260 0)] :\n    AddMonoidAlgebra M \u03b9 \u2243 \u2a01 _ : \u03b9, M :=\n  { finsuppEquivDFinsupp with\n    toFun := AddMonoidAlgebra.toDirectSum\n    invFun := DirectSum.toAddMonoidAlgebra }", "start": [199, 1], "end": [206, 45], "kind": "commanddeclaration"}, {"full_name": "addMonoidAlgebraAddEquivDirectSum", "code": "@[simps (config := { fullyApplied := false })]\ndef addMonoidAlgebraAddEquivDirectSum [DecidableEq \u03b9] [Semiring M] [\u2200 m : M, Decidable (m \u2260 0)] :\n    AddMonoidAlgebra M \u03b9 \u2243+ \u2a01 _ : \u03b9, M :=\n  { addMonoidAlgebraEquivDirectSum with\n    toFun := AddMonoidAlgebra.toDirectSum\n    invFun := DirectSum.toAddMonoidAlgebra\n    map_add' := AddMonoidAlgebra.toDirectSum_add }", "start": [209, 1], "end": [216, 51], "kind": "commanddeclaration"}, {"full_name": "addMonoidAlgebraRingEquivDirectSum", "code": "@[simps (config := { fullyApplied := false })]\ndef addMonoidAlgebraRingEquivDirectSum [DecidableEq \u03b9] [AddMonoid \u03b9] [Semiring M]\n    [\u2200 m : M, Decidable (m \u2260 0)] : AddMonoidAlgebra M \u03b9 \u2243+* \u2a01 _ : \u03b9, M :=\n  { (addMonoidAlgebraAddEquivDirectSum : AddMonoidAlgebra M \u03b9 \u2243+ \u2a01 _ : \u03b9, M) with\n    toFun := AddMonoidAlgebra.toDirectSum\n    invFun := DirectSum.toAddMonoidAlgebra\n    map_mul' := AddMonoidAlgebra.toDirectSum_mul }", "start": [219, 1], "end": [226, 51], "kind": "commanddeclaration"}, {"full_name": "addMonoidAlgebraAlgEquivDirectSum", "code": "@[simps (config := { fullyApplied := false })]\ndef addMonoidAlgebraAlgEquivDirectSum [DecidableEq \u03b9] [AddMonoid \u03b9] [CommSemiring R] [Semiring A]\n    [Algebra R A] [\u2200 m : A, Decidable (m \u2260 0)] : AddMonoidAlgebra A \u03b9 \u2243\u2090[R] \u2a01 _ : \u03b9, A :=\n  { (addMonoidAlgebraRingEquivDirectSum : AddMonoidAlgebra A \u03b9 \u2243+* \u2a01 _ : \u03b9, A) with\n    toFun := AddMonoidAlgebra.toDirectSum\n    invFun := DirectSum.toAddMonoidAlgebra\n    commutes' := fun _r => AddMonoidAlgebra.toDirectSum_single _ _ }", "start": [229, 1], "end": [236, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Moments.lean", "imports": ["Mathlib/Probability/Variance.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.moment", "code": "def moment (X : \u03a9 \u2192 \u211d) (p : \u2115) (\u03bc : Measure \u03a9) : \u211d :=\n  \u03bc[X ^ p]", "start": [50, 1], "end": [52, 11], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.centralMoment", "code": "def centralMoment (X : \u03a9 \u2192 \u211d) (p : \u2115) (\u03bc : Measure \u03a9) : \u211d := by\n  have m := fun (x : \u03a9) => \u03bc[X] exact \u03bc[(X - m) ^ p]", "start": [55, 1], "end": [58, 23], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.moment_zero", "code": "@[simp]\ntheorem moment_zero (hp : p \u2260 0) : moment 0 p \u03bc = 0", "start": [61, 1], "end": [64, 27], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.centralMoment_zero", "code": "@[simp]\ntheorem centralMoment_zero (hp : p \u2260 0) : centralMoment 0 p \u03bc = 0", "start": [67, 1], "end": [70, 96], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.centralMoment_one'", "code": "theorem centralMoment_one' [IsFiniteMeasure \u03bc] (h_int : Integrable X \u03bc) :\n    centralMoment X 1 \u03bc = (1 - (\u03bc Set.univ).toReal) * \u03bc[X]", "start": [73, 1], "end": [77, 60], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.centralMoment_one", "code": "@[simp]\ntheorem centralMoment_one [IsProbabilityMeasure \u03bc] : centralMoment X 1 \u03bc = 0", "start": [80, 1], "end": [91, 29], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.centralMoment_two_eq_variance", "code": "theorem centralMoment_two_eq_variance [IsFiniteMeasure \u03bc] (hX : Mem\u2112p X 2 \u03bc) :\n    centralMoment X 2 \u03bc = variance X \u03bc", "start": [94, 1], "end": [95, 70], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.mgf", "code": "def mgf (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) (t : \u211d) : \u211d :=\n  \u03bc[fun \u03c9 => exp (t * X \u03c9)]", "start": [102, 1], "end": [104, 28], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cgf", "code": "def cgf (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) (t : \u211d) : \u211d :=\n  log (mgf X \u03bc t)", "start": [107, 1], "end": [109, 18], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.mgf_zero_fun", "code": "@[simp]\ntheorem mgf_zero_fun : mgf 0 \u03bc t = (\u03bc Set.univ).toReal", "start": [112, 1], "end": [114, 91], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cgf_zero_fun", "code": "@[simp]\ntheorem cgf_zero_fun : cgf 0 \u03bc t = log (\u03bc Set.univ).toReal", "start": [117, 1], "end": [118, 95], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.mgf_zero_measure", "code": "@[simp]\ntheorem mgf_zero_measure : mgf X (0 : Measure \u03a9) t = 0", "start": [121, 1], "end": [122, 100], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cgf_zero_measure", "code": "@[simp]\ntheorem cgf_zero_measure : cgf X (0 : Measure \u03a9) t = 0", "start": [125, 1], "end": [127, 46], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.mgf_const'", "code": "@[simp]\ntheorem mgf_const' (c : \u211d) : mgf (fun _ => c) \u03bc t = (\u03bc Set.univ).toReal * exp (t * c)", "start": [130, 1], "end": [132, 47], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.mgf_const", "code": "theorem mgf_const (c : \u211d) [IsProbabilityMeasure \u03bc] : mgf (fun _ => c) \u03bc t = exp (t * c)", "start": [136, 1], "end": [137, 68], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cgf_const'", "code": "@[simp]\ntheorem cgf_const' [IsFiniteMeasure \u03bc] (h\u03bc : \u03bc \u2260 0) (c : \u211d) :\n    cgf (fun _ => c) \u03bc t = log (\u03bc Set.univ).toReal + t * c", "start": [140, 1], "end": [147, 74], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cgf_const", "code": "@[simp]\ntheorem cgf_const [IsProbabilityMeasure \u03bc] (c : \u211d) : cgf (fun _ => c) \u03bc t = t * c", "start": [150, 1], "end": [152, 38], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.mgf_zero'", "code": "@[simp]\ntheorem mgf_zero' : mgf X \u03bc 0 = (\u03bc Set.univ).toReal", "start": [155, 1], "end": [157, 76], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.mgf_zero", "code": "theorem mgf_zero [IsProbabilityMeasure \u03bc] : mgf X \u03bc 0 = 1", "start": [161, 1], "end": [162, 58], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cgf_zero'", "code": "@[simp]\ntheorem cgf_zero' : cgf X \u03bc 0 = log (\u03bc Set.univ).toReal", "start": [165, 1], "end": [166, 89], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cgf_zero", "code": "theorem cgf_zero [IsProbabilityMeasure \u03bc] : cgf X \u03bc 0 = 0", "start": [170, 1], "end": [171, 67], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.mgf_undef", "code": "theorem mgf_undef (hX : \u00acIntegrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc) : mgf X \u03bc t = 0", "start": [174, 1], "end": [175, 37], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cgf_undef", "code": "theorem cgf_undef (hX : \u00acIntegrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc) : cgf X \u03bc t = 0", "start": [178, 1], "end": [179, 42], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.mgf_nonneg", "code": "theorem mgf_nonneg : 0 \u2264 mgf X \u03bc t", "start": [182, 1], "end": [186, 23], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.mgf_pos'", "code": "theorem mgf_pos' (h\u03bc : \u03bc \u2260 0) (h_int_X : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc) :\n    0 < mgf X \u03bc t", "start": [189, 1], "end": [205, 28], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.mgf_pos", "code": "theorem mgf_pos [IsProbabilityMeasure \u03bc] (h_int_X : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc) :\n    0 < mgf X \u03bc t", "start": [208, 1], "end": [210, 52], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.mgf_neg", "code": "theorem mgf_neg : mgf (-X) \u03bc t = mgf X \u03bc (-t)", "start": [213, 1], "end": [213, 98], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cgf_neg", "code": "theorem cgf_neg : cgf (-X) \u03bc t = cgf X \u03bc (-t)", "start": [216, 1], "end": [216, 75], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IndepFun.exp_mul", "code": "theorem IndepFun.exp_mul {X Y : \u03a9 \u2192 \u211d} (h_indep : IndepFun X Y \u03bc) (s t : \u211d) :\n    IndepFun (fun \u03c9 => exp (s * X \u03c9)) (fun \u03c9 => exp (t * Y \u03c9)) \u03bc", "start": [219, 1], "end": [224, 52], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IndepFun.mgf_add", "code": "theorem IndepFun.mgf_add {X Y : \u03a9 \u2192 \u211d} (h_indep : IndepFun X Y \u03bc)\n    (hX : AEStronglyMeasurable (fun \u03c9 => exp (t * X \u03c9)) \u03bc)\n    (hY : AEStronglyMeasurable (fun \u03c9 => exp (t * Y \u03c9)) \u03bc) :\n    mgf (X + Y) \u03bc t = mgf X \u03bc t * mgf Y \u03bc t", "start": [227, 1], "end": [232, 49], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IndepFun.mgf_add'", "code": "theorem IndepFun.mgf_add' {X Y : \u03a9 \u2192 \u211d} (h_indep : IndepFun X Y \u03bc) (hX : AEStronglyMeasurable X \u03bc)\n    (hY : AEStronglyMeasurable Y \u03bc) : mgf (X + Y) \u03bc t = mgf X \u03bc t * mgf Y \u03bc t", "start": [235, 1], "end": [242, 32], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IndepFun.cgf_add", "code": "theorem IndepFun.cgf_add {X Y : \u03a9 \u2192 \u211d} (h_indep : IndepFun X Y \u03bc)\n    (h_int_X : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc)\n    (h_int_Y : Integrable (fun \u03c9 => exp (t * Y \u03c9)) \u03bc) :\n    cgf (X + Y) \u03bc t = cgf X \u03bc t + cgf Y \u03bc t", "start": [245, 1], "end": [252, 68], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.aestronglyMeasurable_exp_mul_add", "code": "theorem aestronglyMeasurable_exp_mul_add {X Y : \u03a9 \u2192 \u211d}\n    (h_int_X : AEStronglyMeasurable (fun \u03c9 => exp (t * X \u03c9)) \u03bc)\n    (h_int_Y : AEStronglyMeasurable (fun \u03c9 => exp (t * Y \u03c9)) \u03bc) :\n    AEStronglyMeasurable (fun \u03c9 => exp (t * (X + Y) \u03c9)) \u03bc", "start": [255, 1], "end": [260, 49], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.aestronglyMeasurable_exp_mul_sum", "code": "theorem aestronglyMeasurable_exp_mul_sum {X : \u03b9 \u2192 \u03a9 \u2192 \u211d} {s : Finset \u03b9}\n    (h_int : \u2200 i \u2208 s, AEStronglyMeasurable (fun \u03c9 => exp (t * X i \u03c9)) \u03bc) :\n    AEStronglyMeasurable (fun \u03c9 => exp (t * (\u2211 i in s, X i) \u03c9)) \u03bc", "start": [263, 1], "end": [274, 81], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IndepFun.integrable_exp_mul_add", "code": "theorem IndepFun.integrable_exp_mul_add {X Y : \u03a9 \u2192 \u211d} (h_indep : IndepFun X Y \u03bc)\n    (h_int_X : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc)\n    (h_int_Y : Integrable (fun \u03c9 => exp (t * Y \u03c9)) \u03bc) :\n    Integrable (fun \u03c9 => exp (t * (X + Y) \u03c9)) \u03bc", "start": [277, 1], "end": [282, 61], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.iIndepFun.integrable_exp_mul_sum", "code": "theorem iIndepFun.integrable_exp_mul_sum [IsProbabilityMeasure \u03bc] {X : \u03b9 \u2192 \u03a9 \u2192 \u211d}\n    (h_indep : iIndepFun (fun i => inferInstance) X \u03bc) (h_meas : \u2200 i, Measurable (X i))\n    {s : Finset \u03b9} (h_int : \u2200 i \u2208 s, Integrable (fun \u03c9 => exp (t * X i \u03c9)) \u03bc) :\n    Integrable (fun \u03c9 => exp (t * (\u2211 i in s, X i) \u03c9)) \u03bc", "start": [285, 1], "end": [298, 74], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.iIndepFun.mgf_sum", "code": "theorem iIndepFun.mgf_sum [IsProbabilityMeasure \u03bc] {X : \u03b9 \u2192 \u03a9 \u2192 \u211d}\n    (h_indep : iIndepFun (fun i => inferInstance) X \u03bc) (h_meas : \u2200 i, Measurable (X i))\n    (s : Finset \u03b9) : mgf (\u2211 i in s, X i) \u03bc t = \u220f i in s, mgf (X i) \u03bc t", "start": [302, 1], "end": [313, 37], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.iIndepFun.cgf_sum", "code": "theorem iIndepFun.cgf_sum [IsProbabilityMeasure \u03bc] {X : \u03b9 \u2192 \u03a9 \u2192 \u211d}\n    (h_indep : iIndepFun (fun i => inferInstance) X \u03bc) (h_meas : \u2200 i, Measurable (X i))\n    {s : Finset \u03b9} (h_int : \u2200 i \u2208 s, Integrable (fun \u03c9 => exp (t * X i \u03c9)) \u03bc) :\n    cgf (\u2211 i in s, X i) \u03bc t = \u2211 i in s, cgf (X i) \u03bc t", "start": [317, 1], "end": [324, 37], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measure_ge_le_exp_mul_mgf", "code": "theorem measure_ge_le_exp_mul_mgf [IsFiniteMeasure \u03bc] (\u03b5 : \u211d) (ht : 0 \u2264 t)\n    (h_int : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc) :\n    (\u03bc {\u03c9 | \u03b5 \u2264 X \u03c9}).toReal \u2264 exp (-t * \u03b5) * mgf X \u03bc t", "start": [328, 1], "end": [348, 66], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measure_le_le_exp_mul_mgf", "code": "theorem measure_le_le_exp_mul_mgf [IsFiniteMeasure \u03bc] (\u03b5 : \u211d) (ht : t \u2264 0)\n    (h_int : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc) :\n    (\u03bc {\u03c9 | X \u03c9 \u2264 \u03b5}).toReal \u2264 exp (-t * \u03b5) * mgf X \u03bc t", "start": [351, 1], "end": [360, 16], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measure_ge_le_exp_cgf", "code": "theorem measure_ge_le_exp_cgf [IsFiniteMeasure \u03bc] (\u03b5 : \u211d) (ht : 0 \u2264 t)\n    (h_int : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc) :\n    (\u03bc {\u03c9 | \u03b5 \u2264 X \u03c9}).toReal \u2264 exp (-t * \u03b5 + cgf X \u03bc t)", "start": [363, 1], "end": [369, 67], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measure_le_le_exp_cgf", "code": "theorem measure_le_le_exp_cgf [IsFiniteMeasure \u03bc] (\u03b5 : \u211d) (ht : t \u2264 0)\n    (h_int : Integrable (fun \u03c9 => exp (t * X \u03c9)) \u03bc) :\n    (\u03bc {\u03c9 | X \u03c9 \u2264 \u03b5}).toReal \u2264 exp (-t * \u03b5 + cgf X \u03bc t)", "start": [372, 1], "end": [378, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Pi.lean", "imports": ["Mathlib/CategoryTheory/Limits/HasLimits.lean", "Mathlib/CategoryTheory/Pi/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.pi.coneCompEval", "code": "def coneCompEval (c : Cone F) (i : I) : Cone (F \u22d9 Pi.eval C i) where\n  pt := c.pt i\n  \u03c0 :=\n    { app := fun j => c.\u03c0.app j i\n      naturality := fun _ _ f => congr_fun (c.\u03c0.naturality f) i }", "start": [36, 1], "end": [42, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.pi.coconeCompEval", "code": "def coconeCompEval (c : Cocone F) (i : I) : Cocone (F \u22d9 Pi.eval C i) where\n  pt := c.pt i\n  \u03b9 :=\n    { app := fun j => c.\u03b9.app j i\n      naturality := fun _ _ f => congr_fun (c.\u03b9.naturality f) i }", "start": [45, 1], "end": [52, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.pi.coneOfConeCompEval", "code": "def coneOfConeCompEval (c : \u2200 i, Cone (F \u22d9 Pi.eval C i)) : Cone F where\n  pt i := (c i).pt\n  \u03c0 :=\n    { app := fun j i => (c i).\u03c0.app j\n      naturality := fun j j' f => by\n        funext i\n        exact (c i).\u03c0.naturality f }", "start": [55, 1], "end": [64, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.pi.coconeOfCoconeCompEval", "code": "def coconeOfCoconeCompEval (c : \u2200 i, Cocone (F \u22d9 Pi.eval C i)) : Cocone F where\n  pt i := (c i).pt\n  \u03b9 :=\n    { app := fun j i => (c i).\u03b9.app j\n      naturality := fun j j' f => by\n        funext i\n        exact (c i).\u03b9.naturality f }", "start": [67, 1], "end": [76, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.pi.coneOfConeEvalIsLimit", "code": "def coneOfConeEvalIsLimit {c : \u2200 i, Cone (F \u22d9 Pi.eval C i)} (P : \u2200 i, IsLimit (c i)) :\n    IsLimit (coneOfConeCompEval c) where\n  lift s i := (P i).lift (coneCompEval s i)\n  fac s j := by\n    funext i\n    exact (P i).fac (coneCompEval s i) j\n  uniq s m w := by\n    funext i\n    exact (P i).uniq (coneCompEval s i) (m i) fun j => congr_fun (w j) i", "start": [79, 1], "end": [90, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.pi.coconeOfCoconeEvalIsColimit", "code": "def coconeOfCoconeEvalIsColimit {c : \u2200 i, Cocone (F \u22d9 Pi.eval C i)} (P : \u2200 i, IsColimit (c i)) :\n    IsColimit (coconeOfCoconeCompEval c) where\n  desc s i := (P i).desc (coconeCompEval s i)\n  fac s j := by\n    funext i\n    exact (P i).fac (coconeCompEval s i) j\n  uniq s m w := by\n    funext i\n    exact (P i).uniq (coconeCompEval s i) (m i) fun j => congr_fun (w j) i", "start": [93, 1], "end": [104, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.pi.hasLimit_of_hasLimit_comp_eval", "code": "theorem hasLimit_of_hasLimit_comp_eval : HasLimit F", "start": [111, 1], "end": [118, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.pi.hasColimit_of_hasColimit_comp_eval", "code": "theorem hasColimit_of_hasColimit_comp_eval : HasColimit F", "start": [127, 1], "end": [134, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Sites/Types.lean", "imports": ["Mathlib/CategoryTheory/Sites/Canonical.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.typesGrothendieckTopology", "code": "def typesGrothendieckTopology : GrothendieckTopology (Type u) where\n  sieves \u03b1 S := \u2200 x : \u03b1, S fun _ : PUnit => x\n  top_mem' _ _ := trivial\n  pullback_stable' _ _ _ f hs x := hs (f x)\n  transitive' _ _ hs _ hr x := hr (hs x) PUnit.unit", "start": [27, 1], "end": [33, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.discreteSieve", "code": "@[simps]\ndef discreteSieve (\u03b1 : Type u) : Sieve \u03b1 where\n  arrows _ f := \u2203 x, \u2200 y, f y = x\n  downward_closed := fun \u27e8x, hx\u27e9 g => \u27e8x, fun y => hx <| g y\u27e9", "start": [36, 1], "end": [40, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.discreteSieve_mem", "code": "theorem discreteSieve_mem (\u03b1 : Type u) : discreteSieve \u03b1 \u2208 typesGrothendieckTopology \u03b1", "start": [43, 1], "end": [44, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.discretePresieve", "code": "def discretePresieve (\u03b1 : Type u) : Presieve \u03b1 :=\n  fun \u03b2 _ => \u2203 x : \u03b2, \u2200 y : \u03b2, y = x", "start": [47, 1], "end": [49, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.generate_discretePresieve_mem", "code": "theorem generate_discretePresieve_mem (\u03b1 : Type u) :\n    Sieve.generate (discretePresieve \u03b1) \u2208 typesGrothendieckTopology \u03b1", "start": [52, 1], "end": [54, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSheaf_yoneda'", "code": "theorem isSheaf_yoneda' {\u03b1 : Type u} : IsSheaf typesGrothendieckTopology (yoneda.obj \u03b1)", "start": [59, 1], "end": [64, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yoneda'", "code": "@[simps]\ndef yoneda' : Type u \u2964 SheafOfTypes typesGrothendieckTopology where\n  obj \u03b1 := \u27e8yoneda.obj \u03b1, isSheaf_yoneda'\u27e9\n  map f := \u27e8yoneda.map f\u27e9", "start": [67, 1], "end": [71, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yoneda'_comp", "code": "@[simp]\ntheorem yoneda'_comp : yoneda'.{u} \u22d9 sheafOfTypesToPresheaf _ = yoneda", "start": [74, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eval", "code": "def eval (P : Type u\u1d52\u1d56 \u2964 Type u) (\u03b1 : Type u) (s : P.obj (op \u03b1)) (x : \u03b1) : P.obj (op PUnit) :=\n  P.map (\u21befun _ => x).op s", "start": [81, 1], "end": [84, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.typesGlue", "code": "noncomputable def typesGlue (S : Type u\u1d52\u1d56 \u2964 Type u) (hs : IsSheaf typesGrothendieckTopology S)\n    (\u03b1 : Type u) (f : \u03b1 \u2192 S.obj (op PUnit)) : S.obj (op \u03b1) :=\n  (hs.isSheafFor _ _ (generate_discretePresieve_mem \u03b1)).amalgamate\n    (fun \u03b2 g hg => S.map (\u21befun _ => PUnit.unit).op <| f <| g <| Classical.choose hg)\n    fun \u03b2 \u03b3 \u03b4 g\u2081 g\u2082 f\u2081 f\u2082 hf\u2081 hf\u2082 h =>\n    (hs.isSheafFor _ _ (generate_discretePresieve_mem \u03b4)).isSeparatedFor.ext fun \u03b5 g \u27e8x, _\u27e9 => by\n      have : f\u2081 (Classical.choose hf\u2081) = f\u2082 (Classical.choose hf\u2082) :=\n        Classical.choose_spec hf\u2081 (g\u2081 <| g x) \u25b8\n          Classical.choose_spec hf\u2082 (g\u2082 <| g x) \u25b8 congr_fun h _\n      simp_rw [\u2190 FunctorToTypes.map_comp_apply, this, \u2190 op_comp]\n      rfl", "start": [87, 1], "end": [99, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eval_typesGlue", "code": "theorem eval_typesGlue {S hs \u03b1} (f) : eval.{u} S \u03b1 (typesGlue S hs \u03b1 f) = f", "start": [102, 1], "end": [105, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.typesGlue_eval", "code": "theorem typesGlue_eval {S hs \u03b1} (s) : typesGlue.{u} S hs \u03b1 (eval S \u03b1 s) = s", "start": [108, 1], "end": [117, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.evalEquiv", "code": "@[simps]\nnoncomputable def evalEquiv (S : Type u\u1d52\u1d56 \u2964 Type u) (hs : IsSheaf typesGrothendieckTopology S)\n    (\u03b1 : Type u) : S.obj (op \u03b1) \u2243 (\u03b1 \u2192 S.obj (op PUnit)) where\n  toFun := eval S \u03b1\n  invFun := typesGlue S hs \u03b1\n  left_inv := typesGlue_eval\n  right_inv := eval_typesGlue", "start": [120, 1], "end": [127, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eval_map", "code": "theorem eval_map (S : Type u\u1d52\u1d56 \u2964 Type u) (\u03b1 \u03b2) (f : \u03b2 \u27f6 \u03b1) (s x) :\n    eval S \u03b2 (S.map f.op s) x = eval S \u03b1 s (f x)", "start": [130, 1], "end": [132, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.equivYoneda", "code": "@[simps!]\nnoncomputable def equivYoneda (S : Type u\u1d52\u1d56 \u2964 Type u) (hs : IsSheaf typesGrothendieckTopology S) :\n    S \u2245 yoneda.obj (S.obj (op PUnit)) :=\n  NatIso.ofComponents (fun \u03b1 => Equiv.toIso <| evalEquiv S hs <| unop \u03b1) fun {\u03b1 \u03b2} f =>\n    funext fun _ => funext fun _ => eval_map S (unop \u03b1) (unop \u03b2) f.unop _ _", "start": [135, 1], "end": [140, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.equivYoneda'", "code": "@[simps]\nnoncomputable def equivYoneda' (S : SheafOfTypes typesGrothendieckTopology) :\n    S \u2245 yoneda'.obj (S.1.obj (op PUnit)) where\n  hom := \u27e8(equivYoneda S.1 S.2).hom\u27e9\n  inv := \u27e8(equivYoneda S.1 S.2).inv\u27e9\n  hom_inv_id := by ext1; apply (equivYoneda S.1 S.2).hom_inv_id\n  inv_hom_id := by ext1; apply (equivYoneda S.1 S.2).inv_hom_id", "start": [143, 1], "end": [150, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eval_app", "code": "theorem eval_app (S\u2081 S\u2082 : SheafOfTypes.{u} typesGrothendieckTopology) (f : S\u2081 \u27f6 S\u2082) (\u03b1 : Type u)\n    (s : S\u2081.1.obj (op \u03b1)) (x : \u03b1) :\n    eval S\u2082.1 \u03b1 (f.val.app (op \u03b1) s) x = f.val.app (op PUnit) (eval S\u2081.1 \u03b1 s x)", "start": [153, 1], "end": [156, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.typeEquiv", "code": "@[simps!]\nnoncomputable def typeEquiv : Type u \u224c SheafOfTypes typesGrothendieckTopology :=\n  Equivalence.mk yoneda' (sheafOfTypesToPresheaf _ \u22d9 (evaluation _ _).obj (op PUnit))\n    (NatIso.ofComponents\n      (fun _\u03b1 => { hom := fun x _ => x\n          inv := fun f => f PUnit.unit\n          hom_inv_id := funext fun _ => rfl\n          inv_hom_id := funext fun _ => funext fun y => PUnit.casesOn y rfl })\n      fun _ => rfl)\n    (Iso.symm <|\n      NatIso.ofComponents (fun S => equivYoneda' S) fun {S\u2081 S\u2082} f =>\n        SheafOfTypes.Hom.ext _ _ <|\n          NatTrans.ext _ _ <|\n            funext fun \u03b1 => funext fun s => funext fun x => eval_app S\u2081 S\u2082 f (unop \u03b1) s x)", "start": [159, 1], "end": [175, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.subcanonical_typesGrothendieckTopology", "code": "theorem subcanonical_typesGrothendieckTopology : Sheaf.Subcanonical typesGrothendieckTopology.{u}", "start": [178, 1], "end": [179, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.typesGrothendieckTopology_eq_canonical", "code": "theorem typesGrothendieckTopology_eq_canonical :\n    typesGrothendieckTopology.{u} = Sheaf.canonicalTopology (Type u)", "start": [182, 1], "end": [193, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/MStructure.lean", "imports": ["Mathlib/Algebra/Ring/Idempotents.lean", "Mathlib/Analysis/Normed/Group/Basic.lean", "Mathlib/Tactic/NoncommRing.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsLprojection", "code": "structure IsLprojection (P : M) : Prop where\n  proj : IsIdempotentElem P\n  Lnorm : \u2200 x : X, \u2016x\u2016 = \u2016P \u2022 x\u2016 + \u2016(1 - P) \u2022 x\u2016", "start": [70, 1], "end": [77, 49], "kind": "commanddeclaration"}, {"full_name": "IsMprojection", "code": "structure IsMprojection (P : M) : Prop where\n  proj : IsIdempotentElem P\n  Mnorm : \u2200 x : X, \u2016x\u2016 = max \u2016P \u2022 x\u2016 \u2016(1 - P) \u2022 x\u2016", "start": [80, 1], "end": [87, 51], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.Lcomplement", "code": "theorem Lcomplement {P : M} (h : IsLprojection X P) : IsLprojection X (1 - P)", "start": [95, 1], "end": [98, 21], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.Lcomplement_iff", "code": "theorem Lcomplement_iff (P : M) : IsLprojection X P \u2194 IsLprojection X (1 - P)", "start": [101, 1], "end": [102, 61], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.commute", "code": "theorem commute [FaithfulSMul M X] {P Q : M} (h\u2081 : IsLprojection X P) (h\u2082 : IsLprojection X Q) :\n    Commute P Q", "start": [105, 1], "end": [144, 35], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.mul", "code": "theorem mul [FaithfulSMul M X] {P Q : M} (h\u2081 : IsLprojection X P) (h\u2082 : IsLprojection X Q) :\n    IsLprojection X (P * Q)", "start": [147, 1], "end": [162, 63], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.join", "code": "theorem join [FaithfulSMul M X] {P Q : M} (h\u2081 : IsLprojection X P) (h\u2082 : IsLprojection X Q) :\n    IsLprojection X (P + Q - P * Q)", "start": [165, 1], "end": [168, 15], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.Subtype.hasCompl", "code": "instance Subtype.hasCompl : HasCompl { f : M // IsLprojection X f } :=\n  \u27e8fun P => \u27e81 - P, P.prop.Lcomplement\u27e9\u27e9", "start": [173, 1], "end": [174, 41], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.coe_compl", "code": "@[simp]\ntheorem coe_compl (P : { P : M // IsLprojection X P }) : \u2191P\u1d9c = (1 : M) - \u2191P", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.Subtype.inf", "code": "instance Subtype.inf [FaithfulSMul M X] : Inf { P : M // IsLprojection X P } :=\n  \u27e8fun P Q => \u27e8P * Q, P.prop.mul Q.prop\u27e9\u27e9", "start": [181, 1], "end": [182, 42], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.coe_inf", "code": "@[simp]\ntheorem coe_inf [FaithfulSMul M X] (P Q : { P : M // IsLprojection X P }) :\n    \u2191(P \u2293 Q) = (\u2191P : M) * \u2191Q", "start": [184, 1], "end": [187, 6], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.Subtype.sup", "code": "instance Subtype.sup [FaithfulSMul M X] : Sup { P : M // IsLprojection X P } :=\n  \u27e8fun P Q => \u27e8P + Q - P * Q, P.prop.join Q.prop\u27e9\u27e9", "start": [190, 1], "end": [191, 51], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.coe_sup", "code": "@[simp]\ntheorem coe_sup [FaithfulSMul M X] (P Q : { P : M // IsLprojection X P }) :\n    \u2191(P \u2294 Q) = (\u2191P : M) + \u2191Q - \u2191P * \u2191Q", "start": [193, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.Subtype.sdiff", "code": "instance Subtype.sdiff [FaithfulSMul M X] : SDiff { P : M // IsLprojection X P } :=\n  \u27e8fun P Q => \u27e8P * (1 - Q), P.prop.mul Q.prop.Lcomplement\u27e9\u27e9", "start": [199, 1], "end": [200, 60], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.coe_sdiff", "code": "@[simp]\ntheorem coe_sdiff [FaithfulSMul M X] (P Q : { P : M // IsLprojection X P }) :\n    \u2191(P \\ Q) = (\u2191P : M) * (1 - \u2191Q)", "start": [202, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.Subtype.partialOrder", "code": "instance Subtype.partialOrder [FaithfulSMul M X] :\n    PartialOrder { P : M // IsLprojection X P } where\n  le P Q := (\u2191P : M) = \u2191(P \u2293 Q)\n  le_refl P := by simpa only [coe_inf, \u2190 sq] using P.prop.proj.eq.symm\n  le_trans P Q R h\u2081 h\u2082 := by\n    simp only [coe_inf] at h\u2081 h\u2082 \u22a2\n    rw [h\u2081, mul_assoc, \u2190 h\u2082]\n  le_antisymm P Q h\u2081 h\u2082 := Subtype.eq (by convert (P.prop.commute Q.prop).eq)", "start": [208, 1], "end": [215, 78], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.le_def", "code": "theorem le_def [FaithfulSMul M X] (P Q : { P : M // IsLprojection X P }) :\n    P \u2264 Q \u2194 (P : M) = \u2191(P \u2293 Q)", "start": [217, 1], "end": [219, 10], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.Subtype.zero", "code": "instance Subtype.zero : Zero { P : M // IsLprojection X P } :=\n  \u27e8\u27e80, \u27e8by rw [IsIdempotentElem, zero_mul], fun x => by\n        simp only [zero_smul, norm_zero, sub_zero, one_smul, zero_add]\u27e9\u27e9\u27e9", "start": [222, 1], "end": [224, 74], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u2191(0 : { P : M // IsLprojection X P }) = (0 : M)", "start": [226, 1], "end": [228, 6], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.Subtype.one", "code": "instance Subtype.one : One { P : M // IsLprojection X P } :=\n  \u27e8\u27e81, sub_zero (1 : M) \u25b8 (0 : { P : M // IsLprojection X P }).prop.Lcomplement\u27e9\u27e9", "start": [231, 1], "end": [232, 82], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.coe_one", "code": "@[simp]\ntheorem coe_one : \u2191(1 : { P : M // IsLprojection X P }) = (1 : M)", "start": [234, 1], "end": [236, 6], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.Subtype.boundedOrder", "code": "instance Subtype.boundedOrder [FaithfulSMul M X] :\n    BoundedOrder { P : M // IsLprojection X P } where\n  top := 1\n  le_top P := (mul_one (P : M)).symm\n  bot := 0\n  bot_le P := (zero_mul (P : M)).symm", "start": [239, 1], "end": [244, 38], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.coe_bot", "code": "@[simp]\ntheorem coe_bot [FaithfulSMul M X] :\n    \u2191(BoundedOrder.toOrderBot.toBot.bot : { P : M // IsLprojection X P }) = (0 : M)", "start": [246, 1], "end": [250, 6], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.coe_top", "code": "@[simp]\ntheorem coe_top [FaithfulSMul M X] :\n    \u2191(BoundedOrder.toOrderTop.toTop.top : { P : M // IsLprojection X P }) = (1 : M)", "start": [253, 1], "end": [257, 6], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.compl_mul", "code": "theorem compl_mul {P : { P : M // IsLprojection X P }} {Q : M} : \u2191P\u1d9c * Q = Q - \u2191P * Q", "start": [260, 1], "end": [261, 35], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.mul_compl_self", "code": "theorem mul_compl_self {P : { P : M // IsLprojection X P }} : (\u2191P : M) * \u2191P\u1d9c = 0", "start": [264, 1], "end": [265, 61], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.distrib_lattice_lemma", "code": "theorem distrib_lattice_lemma [FaithfulSMul M X] {P Q R : { P : M // IsLprojection X P }} :\n    ((\u2191P : M) + \u2191P\u1d9c * R) * (\u2191P + \u2191Q * \u2191R * \u2191P\u1d9c) = \u2191P + \u2191Q * \u2191R * \u2191P\u1d9c", "start": [268, 1], "end": [276, 21], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.Subtype.distribLattice", "code": "instance Subtype.distribLattice [FaithfulSMul M X] :\n    DistribLattice { P : M // IsLprojection X P } where\n  le_sup_inf P Q R := by\n    have e\u2081 : \u2191((P \u2294 Q) \u2293 (P \u2294 R)) = \u2191P + \u2191Q * (R : M) * \u2191P\u1d9c := by\n      rw [coe_inf, coe_sup, coe_sup, \u2190 add_sub, \u2190 add_sub, \u2190 compl_mul, \u2190 compl_mul, add_mul,\n        mul_add, (P\u1d9c.prop.commute Q.prop).eq, mul_add, \u2190 mul_assoc, mul_assoc (Q: M),\n        (P\u1d9c.prop.commute P.prop).eq, mul_compl_self, zero_mul, mul_zero,\n        zero_add, add_zero, \u2190 mul_assoc, mul_assoc (Q : M), P.prop.proj.eq, P\u1d9c.prop.proj.eq,\n        mul_assoc, (P\u1d9c.prop.commute R.prop).eq, \u2190 mul_assoc]\n    have e\u2082 : \u2191((P \u2294 Q) \u2293 (P \u2294 R)) * \u2191(P \u2294 Q \u2293 R) = (P : M) + \u2191Q * \u2191R * \u2191P\u1d9c := by\n      rw [coe_inf, coe_sup, coe_sup, coe_sup, \u2190 add_sub, \u2190 add_sub, \u2190 add_sub, \u2190 compl_mul, \u2190\n        compl_mul, \u2190 compl_mul, (P\u1d9c.prop.commute (Q \u2293 R).prop).eq, coe_inf, mul_assoc,\n        distrib_lattice_lemma, (Q.prop.commute R.prop).eq, distrib_lattice_lemma]\n    rw [le_def, e\u2081, coe_inf, e\u2082]", "start": [304, 1], "end": [317, 33], "kind": "commanddeclaration"}, {"full_name": "IsLprojection.Subtype.BooleanAlgebra", "code": "instance Subtype.BooleanAlgebra [FaithfulSMul M X] :\n    BooleanAlgebra { P : M // IsLprojection X P } :=\n{ IsLprojection.Subtype.hasCompl,\n    IsLprojection.Subtype.sdiff,\n    IsLprojection.Subtype.boundedOrder with\n    inf_compl_le_bot := fun P =>\n      (Subtype.ext (by rw [coe_inf, coe_compl, coe_bot, \u2190 coe_compl, mul_compl_self])).le\n    top_le_sup_compl := fun P =>\n      (Subtype.ext\n        (by\n          rw [coe_top, coe_sup, coe_compl, add_sub_cancel'_right, \u2190 coe_compl, mul_compl_self,\n            sub_zero])).le\n    sdiff_eq := fun P Q => Subtype.ext <| by rw [coe_sdiff, \u2190 coe_compl, coe_inf] }", "start": [319, 1], "end": [332, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/SpecificFunctions/Pow.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "Mathlib/Analysis/Convex/SpecificFunctions/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NNReal.strictConcaveOn_rpow", "code": "lemma strictConcaveOn_rpow {p : \u211d} (hp\u2080 : 0 < p) (hp\u2081 : p < 1) :\n    StrictConcaveOn \u211d\u22650 univ fun x : \u211d\u22650 \u21a6 x ^ p := by\n  have hp\u2080' : 0 < 1 / p := by positivity\n  have hp\u2081' : 1 < 1 / p := by rw [one_lt_div hp\u2080]; exact hp\u2081\n  let f := NNReal.orderIsoRpow (1 / p) hp\u2080'\n  have h\u2081 : StrictConvexOn \u211d\u22650 univ f := by\n    refine \u27e8convex_univ, fun x _ y _ hxy a b ha hb hab => ?_\u27e9\n    exact (strictConvexOn_rpow hp\u2081').2 (by positivity : 0 \u2264 x) (by positivity : 0 \u2264 y)\n      (by simp [hxy]) ha hb (by simp; norm_cast)\n  have h\u2082 : \u2200 x, f.symm x = x ^ p := by simp [NNReal.orderIsoRpow_symm_eq]\n  refine \u27e8convex_univ, fun x _ y _ hxy a b ha hb hab => ?_\u27e9\n  simp only [\u2190h\u2082]\n  exact (f.strictConcaveOn_symm h\u2081).2 (Set.mem_univ x) (Set.mem_univ y) hxy ha hb hab", "start": [36, 1], "end": [48, 86], "kind": "mathlibtacticlemma"}, {"full_name": "NNReal.concaveOn_rpow", "code": "lemma concaveOn_rpow {p : \u211d} (hp\u2080 : 0 \u2264 p) (hp\u2081 : p \u2264 1) :\n    ConcaveOn \u211d\u22650 univ fun x : \u211d\u22650 \u21a6 x ^ p := by\n  by_cases hp : p = 0\n  case pos => exact \u27e8convex_univ, fun _ _ _ _ _ _ _ _ hab => by simp [hp, hab]\u27e9\n  case neg =>\n    push_neg at hp\n    by_cases hp' : p = 1\n    case pos => exact \u27e8convex_univ, by simp [hp']\u27e9\n    case neg =>\n      push_neg at hp'\n      exact (strictConcaveOn_rpow (by positivity) (lt_of_le_of_ne hp\u2081 hp')).concaveOn", "start": [50, 1], "end": [60, 86], "kind": "mathlibtacticlemma"}, {"full_name": "NNReal.strictConcaveOn_sqrt", "code": "lemma strictConcaveOn_sqrt : StrictConcaveOn \u211d\u22650 univ NNReal.sqrt := by\n  have : NNReal.sqrt = fun (x:\u211d\u22650) \u21a6 x ^ (1 / (2:\u211d)) := by\n    ext x; exact_mod_cast NNReal.sqrt_eq_rpow x\n  rw [this]\n  exact strictConcaveOn_rpow (by positivity) (by linarith)", "start": [62, 1], "end": [66, 59], "kind": "mathlibtacticlemma"}, {"full_name": "Real.strictConcaveOn_rpow", "code": "lemma strictConcaveOn_rpow {p : \u211d} (hp\u2080 : 0 < p) (hp\u2081 : p < 1) :\n    StrictConcaveOn \u211d (Set.Ici 0) fun x : \u211d \u21a6 x ^ p := by\n  refine \u27e8convex_Ici _, fun x hx y hy hxy a b ha hb hab => ?_\u27e9\n  let x' : \u211d\u22650 := \u27e8x, hx\u27e9\n  let y' : \u211d\u22650 := \u27e8y, hy\u27e9\n  let a' : \u211d\u22650 := \u27e8a, by positivity\u27e9\n  let b' : \u211d\u22650 := \u27e8b, by positivity\u27e9\n  have hx' : (fun z => z ^ p) x = (fun z => z ^ p) x' := rfl\n  have hy' : (fun z => z ^ p) y = (fun z => z ^ p) y' := rfl\n  have hxy' : x' \u2260 y' := Subtype.ne_of_val_ne hxy\n  have hab' : a' + b' = 1 := by ext; simp [hab]\n  rw [hx', hy']\n  exact (NNReal.strictConcaveOn_rpow hp\u2080 hp\u2081).2 (Set.mem_univ x') (Set.mem_univ y')\n    hxy' (by exact_mod_cast ha) (by exact_mod_cast hb) hab'", "start": [74, 1], "end": [87, 60], "kind": "mathlibtacticlemma"}, {"full_name": "Real.concaveOn_rpow", "code": "lemma concaveOn_rpow {p : \u211d} (hp\u2080 : 0 \u2264 p) (hp\u2081 : p \u2264 1) :\n    ConcaveOn \u211d (Set.Ici 0) fun x : \u211d \u21a6 x ^ p := by\n  by_cases hp : p = 0\n  case pos => exact \u27e8convex_Ici 0, fun _ _ _ _ _ _ _ _ hab => by simp [hp, hab]\u27e9\n  case neg =>\n    push_neg at hp\n    by_cases hp' : p = 1\n    case pos => exact \u27e8convex_Ici 0, by simp [hp']\u27e9\n    case neg =>\n      push_neg at hp'\n      exact (strictConcaveOn_rpow (by positivity) (lt_of_le_of_ne hp\u2081 hp')).concaveOn", "start": [89, 1], "end": [99, 86], "kind": "mathlibtacticlemma"}, {"full_name": "Real.strictConcaveOn_sqrt", "code": "lemma strictConcaveOn_sqrt : StrictConcaveOn \u211d (Set.Ici 0) Real.sqrt := by\n  have : Real.sqrt = fun (x:\u211d) \u21a6 x ^ (1 / (2:\u211d)) := by\n    ext x; exact Real.sqrt_eq_rpow x\n  rw [this]\n  exact strictConcaveOn_rpow (by positivity) (by linarith)", "start": [101, 1], "end": [105, 59], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/CategoryTheory/Category/GaloisConnection.lean", "imports": ["Mathlib/CategoryTheory/Category/Preorder.lean", "Mathlib/Order/GaloisConnection.lean", "Mathlib/CategoryTheory/Adjunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "GaloisConnection.adjunction", "code": "def GaloisConnection.adjunction {l : X \u2192 Y} {u : Y \u2192 X} (gc : GaloisConnection l u) :\n    gc.monotone_l.functor \u22a3 gc.monotone_u.functor :=\n  CategoryTheory.Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y =>\n        \u27e8fun f => CategoryTheory.homOfLE (gc.le_u f.le),\n         fun f => CategoryTheory.homOfLE (gc.l_le f.le), _, _\u27e9 }", "start": [27, 1], "end": [34, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.gc", "code": "theorem Adjunction.gc {L : X \u2964 Y} {R : Y \u2964 X} (adj : L \u22a3 R) : GaloisConnection L.obj R.obj", "start": [43, 1], "end": [47, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/ContinuedFractions/Computation/TerminatesIffRat.lean", "imports": ["Mathlib/Algebra/ContinuedFractions/Computation/CorrectnessTerminating.lean", "Mathlib/Data/Rat/Floor.lean", "Mathlib/Algebra/ContinuedFractions/Computation/Approximations.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "GeneralizedContinuedFraction.exists_gcf_pair_rat_eq_of_nth_conts_aux", "code": "nonrec theorem exists_gcf_pair_rat_eq_of_nth_conts_aux :\n    \u2203 conts : Pair \u211a, (of v).continuantsAux n = (conts.map (\u2191) : Pair K)", "start": [63, 1], "end": [99, 66], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.exists_gcf_pair_rat_eq_nth_conts", "code": "theorem exists_gcf_pair_rat_eq_nth_conts :\n    \u2203 conts : Pair \u211a, (of v).continuants n = (conts.map (\u2191) : Pair K)", "start": [102, 1], "end": [104, 95], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.exists_rat_eq_nth_numerator", "code": "theorem exists_rat_eq_nth_numerator : \u2203 q : \u211a, (of v).numerators n = (q : K)", "start": [107, 1], "end": [110, 37], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.exists_rat_eq_nth_denominator", "code": "theorem exists_rat_eq_nth_denominator : \u2203 q : \u211a, (of v).denominators n = (q : K)", "start": [113, 1], "end": [116, 39], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.exists_rat_eq_nth_convergent", "code": "theorem exists_rat_eq_nth_convergent : \u2203 q : \u211a, (of v).convergents n = (q : K)", "start": [119, 1], "end": [124, 63], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.exists_rat_eq_of_terminates", "code": "theorem exists_rat_eq_of_terminates (terminates : (of v).Terminates) : \u2203 q : \u211a, v = \u2191q", "start": [129, 1], "end": [136, 14], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.IntFractPair.coe_of_rat_eq", "code": "theorem coe_of_rat_eq : ((IntFractPair.of q).mapFr (\u2191) : IntFractPair K) = IntFractPair.of v", "start": [171, 1], "end": [172, 33], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.IntFractPair.coe_stream_nth_rat_eq", "code": "theorem coe_stream_nth_rat_eq :\n    ((IntFractPair.stream q n).map (mapFr (\u2191)) : Option <| IntFractPair K) =\n      IntFractPair.stream v n", "start": [175, 1], "end": [195, 82], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.IntFractPair.coe_stream'_rat_eq", "code": "theorem coe_stream'_rat_eq :\n    ((IntFractPair.stream q).map (Option.map (mapFr (\u2191))) : Stream' <| Option <| IntFractPair K) =\n      IntFractPair.stream v", "start": [198, 1], "end": [201, 65], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.coe_of_h_rat_eq", "code": "theorem coe_of_h_rat_eq : (\u2191((of q).h : \u211a) : K) = (of v).h", "start": [209, 1], "end": [212, 7], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.coe_of_s_get?_rat_eq", "code": "theorem coe_of_s_get?_rat_eq :\n    (((of q).s.get? n).map (Pair.map (\u2191)) : Option <| Pair K) = (of v).s.get? n", "start": [215, 1], "end": [221, 56], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.coe_of_s_rat_eq", "code": "theorem coe_of_s_rat_eq : ((of q).s.map (Pair.map ((\u2191))) : Stream'.Seq <| Pair K) = (of v).s", "start": [224, 1], "end": [225, 49], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.coe_of_rat_eq", "code": "theorem coe_of_rat_eq :\n    (\u27e8(of q).h, (of q).s.map (Pair.map (\u2191))\u27e9 : GeneralizedContinuedFraction K) = of v", "start": [228, 1], "end": [237, 74], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.of_terminates_iff_of_rat_terminates", "code": "theorem of_terminates_iff_of_rat_terminates {v : K} {q : \u211a} (v_eq_q : v = (q : K)) :\n    (of v).Terminates \u2194 (of q).Terminates", "start": [240, 1], "end": [246, 12], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.IntFractPair.of_inv_fr_num_lt_num_of_pos", "code": "theorem of_inv_fr_num_lt_num_of_pos (q_pos : 0 < q) : (IntFractPair.of q\u207b\u00b9).fr.num < q.num", "start": [270, 1], "end": [274, 40], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.IntFractPair.stream_succ_nth_fr_num_lt_nth_fr_num_rat", "code": "theorem stream_succ_nth_fr_num_lt_nth_fr_num_rat {ifp_n ifp_succ_n : IntFractPair \u211a}\n    (stream_nth_eq : IntFractPair.stream q n = some ifp_n)\n    (stream_succ_nth_eq : IntFractPair.stream q (n + 1) = some ifp_succ_n) :\n    ifp_succ_n.fr.num < ifp_n.fr.num", "start": [277, 1], "end": [293, 41], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.IntFractPair.stream_nth_fr_num_le_fr_num_sub_n_rat", "code": "theorem stream_nth_fr_num_le_fr_num_sub_n_rat :\n    \u2200 {ifp_n : IntFractPair \u211a},\n      IntFractPair.stream q n = some ifp_n \u2192 ifp_n.fr.num \u2264 (IntFractPair.of q).fr.num - n", "start": [296, 1], "end": [313, 43], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.IntFractPair.exists_nth_stream_eq_none_of_rat", "code": "theorem exists_nth_stream_eq_none_of_rat (q : \u211a) : \u2203 n : \u2115, IntFractPair.stream q n = none", "start": [316, 1], "end": [332, 13], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.terminates_of_rat", "code": "theorem terminates_of_rat (q : \u211a) : (of q).Terminates", "start": [337, 1], "end": [342, 75], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.terminates_iff_rat", "code": "theorem terminates_iff_rat (v : K) : (of v).Terminates \u2194 \u2203 q : \u211a, v = (q : K)", "start": [347, 1], "end": [356, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/ProbabilityMassFunction/Binomial.lean", "imports": ["Mathlib/Tactic/FinCases.lean", "Mathlib/Probability/ProbabilityMassFunction/Constructions.lean", "Mathlib/Data/Nat/Choose/Multinomial.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PMF.binomial", "code": "noncomputable\ndef binomial (p : \u211d\u22650\u221e) (h : p \u2264 1) (n : \u2115) : PMF (Fin (n + 1)) :=\n  .ofFintype (fun i => p^(i : \u2115) * (1-p)^((Fin.last n - i) : \u2115) * (n.choose i : \u2115)) (by\n    convert (add_pow p (1-p) n).symm\n    \u00b7 rw [Finset.sum_fin_eq_sum_range]\n      apply Finset.sum_congr rfl\n      intro i hi\n      rw [Finset.mem_range] at hi\n      rw [dif_pos hi, Fin.last]\n    \u00b7 simp [h])", "start": [24, 1], "end": [35, 16], "kind": "commanddeclaration"}, {"full_name": "PMF.binomial_apply", "code": "theorem binomial_apply (p : \u211d\u22650\u221e) (h : p \u2264 1) (n : \u2115) (i : Fin (n + 1)) :\n    binomial p h n i = p^(i : \u2115) * (1-p)^((Fin.last n - i) : \u2115) * (n.choose i : \u2115)", "start": [37, 1], "end": [38, 90], "kind": "commanddeclaration"}, {"full_name": "PMF.binomial_apply_zero", "code": "@[simp]\ntheorem binomial_apply_zero (p : \u211d\u22650\u221e) (h : p \u2264 1) (n : \u2115) :\n    binomial p h n 0 = (1-p)^n", "start": [40, 1], "end": [43, 24], "kind": "commanddeclaration"}, {"full_name": "PMF.binomial_apply_self", "code": "@[simp]\ntheorem binomial_apply_self (p : \u211d\u22650\u221e) (h : p \u2264 1) (n : \u2115) :\n    binomial p h n n = p^n", "start": [45, 1], "end": [48, 42], "kind": "commanddeclaration"}, {"full_name": "PMF.binomial_one_eq_bernoulli", "code": "theorem binomial_one_eq_bernoulli (p : \u211d\u22650\u221e) (h : p \u2264 1) :\n    binomial p h 1 = (bernoulli p h).map (cond \u00b7 1 0)", "start": [50, 1], "end": [53, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Int/Lemmas.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Data/Int/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Probability/BorelCantelli.lean", "imports": ["Mathlib/Probability/ConditionalExpectation.lean", "Mathlib/Probability/Martingale/BorelCantelli.lean", "Mathlib/Probability/Independence/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.iIndepFun.indep_comap_natural_of_lt", "code": "theorem iIndepFun.indep_comap_natural_of_lt (hf : \u2200 i, StronglyMeasurable (f i))\n    (hfi : iIndepFun (fun _ => m\u03b2) f \u03bc) (hij : i < j) :\n    Indep (MeasurableSpace.comap (f j) m\u03b2) (Filtration.natural f hf i) \u03bc", "start": [41, 1], "end": [46, 84], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.iIndepFun.condexp_natural_ae_eq_of_lt", "code": "theorem iIndepFun.condexp_natural_ae_eq_of_lt [SecondCountableTopology \u03b2] [CompleteSpace \u03b2]\n    [NormedSpace \u211d \u03b2] (hf : \u2200 i, StronglyMeasurable (f i)) (hfi : iIndepFun (fun _ => m\u03b2) f \u03bc)\n    (hij : i < j) : \u03bc[f j|Filtration.natural f hf i] =\u1d50[\u03bc] fun _ => \u03bc[f j]", "start": [50, 1], "end": [54, 88], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.iIndepSet.condexp_indicator_filtrationOfSet_ae_eq", "code": "theorem iIndepSet.condexp_indicator_filtrationOfSet_ae_eq (hsm : \u2200 n, MeasurableSet (s n))\n    (hs : iIndepSet s \u03bc) (hij : i < j) :\n    \u03bc[(s j).indicator (fun _ => 1 : \u03a9 \u2192 \u211d)|filtrationOfSet hsm i] =\u1d50[\u03bc]\n    fun _ => (\u03bc (s j)).toReal", "start": [58, 1], "end": [64, 87], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measure_limsup_eq_one", "code": "theorem measure_limsup_eq_one {s : \u2115 \u2192 Set \u03a9} (hsm : \u2200 n, MeasurableSet (s n)) (hs : iIndepSet s \u03bc)\n    (hs' : (\u2211' n, \u03bc (s n)) = \u221e) : \u03bc (limsup s atTop) = 1", "start": [70, 1], "end": [103, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Deprecated/Ring.lean", "imports": ["Mathlib/Deprecated/Group.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsSemiringHom", "code": "structure IsSemiringHom {\u03b1 : Type u} {\u03b2 : Type v} [Semiring \u03b1] [Semiring \u03b2] (f : \u03b1 \u2192 \u03b2) : Prop where\n  \n  map_zero : f 0 = 0\n  \n  map_one : f 1 = 1\n  \n  map_add : \u2200 x y, f (x + y) = f x + f y\n  \n  map_mul : \u2200 x y, f (x * y) = f x * f y", "start": [36, 1], "end": [45, 41], "kind": "commanddeclaration"}, {"full_name": "IsSemiringHom.id", "code": "theorem id : IsSemiringHom (@id \u03b1)", "start": [54, 1], "end": [55, 75], "kind": "commanddeclaration"}, {"full_name": "IsSemiringHom.comp", "code": "theorem comp (hf : IsSemiringHom f) {\u03b3} [Semiring \u03b3] {g : \u03b2 \u2192 \u03b3} (hg : IsSemiringHom g) :\n    IsSemiringHom (g \u2218 f)", "start": [58, 1], "end": [64, 63], "kind": "commanddeclaration"}, {"full_name": "IsSemiringHom.to_isAddMonoidHom", "code": "theorem to_isAddMonoidHom (hf : IsSemiringHom f) : IsAddMonoidHom f", "start": [67, 1], "end": [69, 76], "kind": "commanddeclaration"}, {"full_name": "IsSemiringHom.to_isMonoidHom", "code": "theorem to_isMonoidHom (hf : IsSemiringHom f) : IsMonoidHom f", "start": [72, 1], "end": [74, 29], "kind": "commanddeclaration"}, {"full_name": "IsRingHom", "code": "structure IsRingHom {\u03b1 : Type u} {\u03b2 : Type v} [Ring \u03b1] [Ring \u03b2] (f : \u03b1 \u2192 \u03b2) : Prop where\n  \n  map_one : f 1 = 1\n  \n  map_mul : \u2200 x y, f (x * y) = f x * f y\n  \n  map_add : \u2200 x y, f (x + y) = f x + f y", "start": [79, 1], "end": [86, 41], "kind": "commanddeclaration"}, {"full_name": "IsRingHom.of_semiring", "code": "theorem of_semiring {f : \u03b1 \u2192 \u03b2} (H : IsSemiringHom f) : IsRingHom f", "start": [93, 1], "end": [95, 13], "kind": "commanddeclaration"}, {"full_name": "IsRingHom.map_zero", "code": "theorem map_zero (hf : IsRingHom f) : f 0 = 0", "start": [100, 1], "end": [104, 21], "kind": "commanddeclaration"}, {"full_name": "IsRingHom.map_neg", "code": "theorem map_neg (hf : IsRingHom f) : f (-x) = -f x", "start": [107, 1], "end": [111, 38], "kind": "commanddeclaration"}, {"full_name": "IsRingHom.map_sub", "code": "theorem map_sub (hf : IsRingHom f) : f (x - y) = f x - f y", "start": [114, 1], "end": [116, 48], "kind": "commanddeclaration"}, {"full_name": "IsRingHom.id", "code": "theorem id : IsRingHom (@id \u03b1)", "start": [119, 1], "end": [120, 71], "kind": "commanddeclaration"}, {"full_name": "IsRingHom.comp", "code": "theorem comp (hf : IsRingHom f) {\u03b3} [Ring \u03b3] {g : \u03b2 \u2192 \u03b3} (hg : IsRingHom g) : IsRingHom (g \u2218 f)", "start": [124, 1], "end": [128, 56], "kind": "commanddeclaration"}, {"full_name": "IsRingHom.to_isSemiringHom", "code": "theorem to_isSemiringHom (hf : IsRingHom f) : IsSemiringHom f", "start": [131, 1], "end": [133, 49], "kind": "commanddeclaration"}, {"full_name": "IsRingHom.to_isAddGroupHom", "code": "theorem to_isAddGroupHom (hf : IsRingHom f) : IsAddGroupHom f", "start": [136, 1], "end": [137, 28], "kind": "commanddeclaration"}, {"full_name": "RingHom.of", "code": "def of {f : \u03b1 \u2192 \u03b2} (hf : IsSemiringHom f) : \u03b1 \u2192+* \u03b2 :=\n  { MonoidHom.of hf.to_isMonoidHom, AddMonoidHom.of hf.to_isAddMonoidHom with toFun := f }", "start": [148, 1], "end": [150, 91], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_of", "code": "@[simp]\ntheorem coe_of {f : \u03b1 \u2192 \u03b2} (hf : IsSemiringHom f) : \u21d1(of hf) = f", "start": [153, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.to_isSemiringHom", "code": "theorem to_isSemiringHom (f : \u03b1 \u2192+* \u03b2) : IsSemiringHom f", "start": [158, 1], "end": [162, 27], "kind": "commanddeclaration"}, {"full_name": "RingHom.to_isRingHom", "code": "theorem to_isRingHom {\u03b1 \u03b3} [Ring \u03b1] [Ring \u03b3] (g : \u03b1 \u2192+* \u03b3) : IsRingHom g", "start": [167, 1], "end": [168, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/AList.lean", "imports": ["Mathlib/Data/Finsupp/Basic.lean", "Mathlib/Data/List/AList.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp.toAList", "code": "@[simps]\nnoncomputable def toAList (f : \u03b1 \u2192\u2080 M) : AList fun _x : \u03b1 => M :=\n  \u27e8f.graph.toList.map Prod.toSigma,\n    by\n      rw [List.NodupKeys, List.keys, List.map_map, Prod.fst_comp_toSigma, List.nodup_map_iff_inj_on]\n      \u00b7 rintro \u27e8b, m\u27e9 hb \u27e8c, n\u27e9 hc (rfl : b = c)\n        rw [Finset.mem_toList, Finsupp.mem_graph_iff] at hb hc\n        dsimp at hb hc\n        rw [\u2190 hc.1, hb.1]\n      \u00b7 apply Finset.nodup_toList\u27e9", "start": [27, 1], "end": [37, 35], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toAList_keys_toFinset", "code": "@[simp]\ntheorem toAList_keys_toFinset [DecidableEq \u03b1] (f : \u03b1 \u2192\u2080 M) :\n    f.toAList.keys.toFinset = f.support", "start": [40, 1], "end": [44, 56], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_toAlist", "code": "@[simp]\ntheorem mem_toAlist {f : \u03b1 \u2192\u2080 M} {x : \u03b1} : x \u2208 f.toAList \u2194 f x \u2260 0", "start": [47, 1], "end": [49, 93], "kind": "commanddeclaration"}, {"full_name": "AList.lookupFinsupp", "code": "noncomputable def lookupFinsupp (l : AList fun _x : \u03b1 => M) : \u03b1 \u2192\u2080 M\n    where\n  support := by\n    haveI := Classical.decEq \u03b1; haveI := Classical.decEq M\n    exact (l.1.filter fun x => Sigma.snd x \u2260 0).keys.toFinset\n  toFun a :=\n    haveI := Classical.decEq \u03b1\n    (l.lookup a).getD 0\n  mem_support_toFun a := by\n    classical\n      simp_rw [@mem_toFinset _ _, List.mem_keys, List.mem_filter, \u2190 mem_lookup_iff]\n      cases lookup a l <;> simp", "start": [60, 1], "end": [73, 32], "kind": "commanddeclaration"}, {"full_name": "AList.lookupFinsupp_apply", "code": "@[simp]\ntheorem lookupFinsupp_apply [DecidableEq \u03b1] (l : AList fun _x : \u03b1 => M) (a : \u03b1) :\n    l.lookupFinsupp a = (l.lookup a).getD 0", "start": [76, 1], "end": [80, 60], "kind": "commanddeclaration"}, {"full_name": "AList.lookupFinsupp_support", "code": "@[simp]\ntheorem lookupFinsupp_support [DecidableEq \u03b1] [DecidableEq M] (l : AList fun _x : \u03b1 => M) :\n    l.lookupFinsupp.support = (l.1.filter fun x => Sigma.snd x \u2260 0).keys.toFinset", "start": [83, 1], "end": [89, 21], "kind": "commanddeclaration"}, {"full_name": "AList.lookupFinsupp_eq_iff_of_ne_zero", "code": "theorem lookupFinsupp_eq_iff_of_ne_zero [DecidableEq \u03b1] {l : AList fun _x : \u03b1 => M} {a : \u03b1} {x : M}\n    (hx : x \u2260 0) : l.lookupFinsupp a = x \u2194 x \u2208 l.lookup a", "start": [92, 1], "end": [95, 46], "kind": "commanddeclaration"}, {"full_name": "AList.lookupFinsupp_eq_zero_iff", "code": "theorem lookupFinsupp_eq_zero_iff [DecidableEq \u03b1] {l : AList fun _x : \u03b1 => M} {a : \u03b1} :\n    l.lookupFinsupp a = 0 \u2194 a \u2209 l \u2228 (0 : M) \u2208 l.lookup a", "start": [98, 1], "end": [101, 36], "kind": "commanddeclaration"}, {"full_name": "AList.empty_lookupFinsupp", "code": "@[simp]\ntheorem empty_lookupFinsupp : lookupFinsupp (\u2205 : AList fun _x : \u03b1 => M) = 0", "start": [104, 1], "end": [108, 9], "kind": "commanddeclaration"}, {"full_name": "AList.insert_lookupFinsupp", "code": "@[simp]\ntheorem insert_lookupFinsupp [DecidableEq \u03b1] (l : AList fun _x : \u03b1 => M) (a : \u03b1) (m : M) :\n    (l.insert a m).lookupFinsupp = l.lookupFinsupp.update a m", "start": [111, 1], "end": [115, 34], "kind": "commanddeclaration"}, {"full_name": "AList.singleton_lookupFinsupp", "code": "@[simp]\ntheorem singleton_lookupFinsupp (a : \u03b1) (m : M) :\n    (singleton a m).lookupFinsupp = Finsupp.single a m", "start": [118, 1], "end": [123, 99], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toAList_lookupFinsupp", "code": "@[simp]\ntheorem _root_.Finsupp.toAList_lookupFinsupp (f : \u03b1 \u2192\u2080 M) : f.toAList.lookupFinsupp = f", "start": [126, 1], "end": [135, 22], "kind": "commanddeclaration"}, {"full_name": "AList.lookupFinsupp_surjective", "code": "theorem lookupFinsupp_surjective : Function.Surjective (@lookupFinsupp \u03b1 M _)", "start": [138, 1], "end": [139, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/LSeries.lean", "imports": ["Mathlib/Analysis/PSeries.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/NumberTheory/ArithmeticFunction.lean", "Mathlib/Analysis/NormedSpace/FiniteDimension.lean", "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean"], "premises": [{"full_name": "Nat.ArithmeticFunction.LSeries", "code": "def LSeries (f : ArithmeticFunction \u2102) (z : \u2102) : \u2102 :=\n  \u2211' n, f n / n ^ z", "start": [41, 1], "end": [43, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.LSeriesSummable", "code": "def LSeriesSummable (f : ArithmeticFunction \u2102) (z : \u2102) : Prop :=\n  Summable fun n => f n / n ^ z", "start": [46, 1], "end": [48, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.LSeries_eq_zero_of_not_LSeriesSummable", "code": "theorem LSeries_eq_zero_of_not_LSeriesSummable (f : ArithmeticFunction \u2102) (z : \u2102) :\n    \u00acf.LSeriesSummable z \u2192 f.LSeries z = 0", "start": [51, 1], "end": [53, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.LSeriesSummable_zero", "code": "@[simp]\ntheorem LSeriesSummable_zero {z : \u2102} : LSeriesSummable 0 z", "start": [56, 1], "end": [58, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.LSeriesSummable_of_bounded_of_one_lt_real", "code": "theorem LSeriesSummable_of_bounded_of_one_lt_real {f : ArithmeticFunction \u2102} {m : \u211d}\n    (h : \u2200 n : \u2115, Complex.abs (f n) \u2264 m) {z : \u211d} (hz : 1 < z) : f.LSeriesSummable z", "start": [61, 1], "end": [77, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.LSeriesSummable_iff_of_re_eq_re", "code": "theorem LSeriesSummable_iff_of_re_eq_re {f : ArithmeticFunction \u2102} {w z : \u2102} (h : w.re = z.re) :\n    f.LSeriesSummable w \u2194 f.LSeriesSummable z", "start": [80, 1], "end": [95, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.LSeriesSummable_of_bounded_of_one_lt_re", "code": "theorem LSeriesSummable_of_bounded_of_one_lt_re {f : ArithmeticFunction \u2102} {m : \u211d}\n    (h : \u2200 n : \u2115, Complex.abs (f n) \u2264 m) {z : \u2102} (hz : 1 < z.re) : f.LSeriesSummable z", "start": [98, 1], "end": [102, 11], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.zeta_LSeriesSummable_iff_one_lt_re", "code": "theorem zeta_LSeriesSummable_iff_one_lt_re {z : \u2102} : LSeriesSummable \u03b6 z \u2194 1 < z.re", "start": [107, 1], "end": [120, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.ArithmeticFunction.LSeries_add", "code": "@[simp]\ntheorem LSeries_add {f g : ArithmeticFunction \u2102} {z : \u2102} (hf : f.LSeriesSummable z)\n    (hg : g.LSeriesSummable z) : (f + g).LSeries z = f.LSeries z + g.LSeries z", "start": [123, 1], "end": [129, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Connectivity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.Subgraph.Preconnected", "code": "protected structure Preconnected (H : G.Subgraph) : Prop where\n  protected coe : H.coe.Preconnected", "start": [26, 1], "end": [30, 37], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.preconnected_iff", "code": "protected lemma preconnected_iff {H : G.Subgraph} :\n    H.Preconnected \u2194 H.coe.Preconnected := \u27e8fun \u27e8h\u27e9 => h, .mk\u27e9", "start": [37, 1], "end": [38, 63], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Subgraph.Connected", "code": "protected structure Connected (H : G.Subgraph) : Prop where\n  protected coe : H.coe.Connected", "start": [40, 1], "end": [44, 34], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.connected_iff'", "code": "protected lemma connected_iff' {H : G.Subgraph} :\n    H.Connected \u2194 H.coe.Connected := \u27e8fun \u27e8h\u27e9 => h, .mk\u27e9", "start": [52, 1], "end": [53, 57], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Subgraph.connected_iff", "code": "protected lemma connected_iff {H : G.Subgraph} :\n    H.Connected \u2194 H.Preconnected \u2227 H.verts.Nonempty := by\n  rw [H.connected_iff', connected_iff, H.preconnected_iff, Set.nonempty_coe_sort]", "start": [55, 1], "end": [57, 82], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Subgraph.Connected.preconnected", "code": "protected lemma Connected.preconnected {H : G.Subgraph} (h : H.Connected) : H.Preconnected := by\n  rw [H.connected_iff] at h; exact h.1", "start": [59, 1], "end": [60, 39], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Subgraph.Connected.nonempty", "code": "protected lemma Connected.nonempty {H : G.Subgraph} (h : H.Connected) : H.verts.Nonempty := by\n  rw [H.connected_iff] at h; exact h.2", "start": [62, 1], "end": [63, 39], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Subgraph.singletonSubgraph_connected", "code": "theorem singletonSubgraph_connected {v : V} : (G.singletonSubgraph v).Connected", "start": [65, 1], "end": [70, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.subgraphOfAdj_connected", "code": "@[simp]\ntheorem subgraphOfAdj_connected {v w : V} (hvw : G.Adj v w) : (G.subgraphOfAdj hvw).Connected", "start": [73, 1], "end": [79, 46], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.top_induce_pair_connected_of_adj", "code": "lemma top_induce_pair_connected_of_adj {u v : V} (huv : G.Adj u v) :\n    ((\u22a4 : G.Subgraph).induce {u, v}).Connected := by\n  rw [\u2190 subgraphOfAdj_eq_induce huv]\n  exact subgraphOfAdj_connected huv", "start": [82, 1], "end": [85, 36], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Subgraph.Connected.mono", "code": "@[mono]\nprotected lemma Connected.mono {H H' : G.Subgraph} (hle : H \u2264 H') (hv : H.verts = H'.verts)\n    (h : H.Connected) : H'.Connected := by\n  rw [\u2190 Subgraph.copy_eq H' H.verts hv H'.Adj rfl]\n  refine \u27e8h.coe.mono ?_\u27e9\n  rintro \u27e8v, hv\u27e9 \u27e8w, hw\u27e9 hvw\n  exact hle.2 hvw", "start": [87, 1], "end": [93, 18], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Subgraph.Connected.mono'", "code": "protected lemma Connected.mono' {H H' : G.Subgraph}\n    (hle : \u2200 v w, H.Adj v w \u2192 H'.Adj v w) (hv : H.verts = H'.verts)\n    (h : H.Connected) : H'.Connected := by\n  exact h.mono \u27e8hv.le, hle\u27e9 hv", "start": [95, 1], "end": [98, 31], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Subgraph.Connected.sup", "code": "protected lemma Connected.sup {H K : G.Subgraph}\n    (hH : H.Connected) (hK : K.Connected) (hn : (H \u2293 K).verts.Nonempty) :\n    (H \u2294 K).Connected := by\n  rw [Subgraph.connected_iff', connected_iff_exists_forall_reachable]\n  obtain \u27e8u, hu, hu'\u27e9 := hn\n  exists \u27e8u, Or.inl hu\u27e9\n  rintro \u27e8v, (hv|hv)\u27e9\n  \u00b7 exact Reachable.map (Subgraph.inclusion (le_sup_left : H \u2264 H \u2294 K)) (hH \u27e8u, hu\u27e9 \u27e8v, hv\u27e9)\n  \u00b7 exact Reachable.map (Subgraph.inclusion (le_sup_right : K \u2264 H \u2294 K)) (hK \u27e8u, hu'\u27e9 \u27e8v, hv\u27e9)", "start": [100, 1], "end": [108, 94], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.toSubgraph_connected", "code": "lemma _root_.SimpleGraph.Walk.toSubgraph_connected {u v : V} (p : G.Walk u v) :\n    p.toSubgraph.Connected := by\n  induction p with\n  | nil => apply singletonSubgraph_connected\n  | @cons _ w _ h p ih =>\n    apply (subgraphOfAdj_connected h).sup ih\n    exists w\n    simp", "start": [110, 1], "end": [117, 9], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Subgraph.induce_union_connected", "code": "lemma induce_union_connected {H : G.Subgraph} {s t : Set V}\n    (sconn : (H.induce s).Connected) (tconn : (H.induce t).Connected)\n    (sintert : (s \u2293 t).Nonempty) :\n    (H.induce (s \u222a t)).Connected := by\n  refine (sconn.sup tconn sintert).mono ?_ ?_\n  \u00b7 apply le_induce_union\n  \u00b7 simp", "start": [119, 1], "end": [125, 9], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Subgraph.Connected.adj_union", "code": "lemma Connected.adj_union {H K : G.Subgraph}\n    (Hconn : H.Connected) (Kconn : K.Connected) {u v : V} (uH : u \u2208 H.verts) (vK : v \u2208 K.verts)\n    (huv : G.Adj u v) :\n    ((\u22a4 : G.Subgraph).induce {u, v} \u2294 H \u2294 K).Connected := by\n  refine ((top_induce_pair_connected_of_adj huv).sup Hconn ?_).sup Kconn ?_\n  \u00b7 exact \u27e8u, by simp [uH]\u27e9\n  \u00b7 exact \u27e8v, by simp [vK]\u27e9", "start": [127, 1], "end": [133, 28], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Subgraph.preconnected_iff_forall_exists_walk_subgraph", "code": "lemma preconnected_iff_forall_exists_walk_subgraph (H : G.Subgraph) :\n    H.Preconnected \u2194 \u2200 {u v}, u \u2208 H.verts \u2192 v \u2208 H.verts \u2192 \u2203 p : G.Walk u v, p.toSubgraph \u2264 H := by\n  constructor\n  \u00b7 intro hc u v hu hv\n    refine (hc \u27e8_, hu\u27e9 \u27e8_, hv\u27e9).elim fun p => ?_\n    exists p.map (Subgraph.hom _)\n    simp [coeSubgraph_le]\n  \u00b7 intro hw\n    rw [Subgraph.preconnected_iff]\n    rintro \u27e8u, hu\u27e9 \u27e8v, hv\u27e9\n    obtain \u27e8p, h\u27e9 := hw hu hv\n    exact Reachable.map (Subgraph.inclusion h)\n      (p.toSubgraph_connected \u27e8_, p.start_mem_verts_toSubgraph\u27e9 \u27e8_, p.end_mem_verts_toSubgraph\u27e9)", "start": [135, 1], "end": [147, 97], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Subgraph.connected_iff_forall_exists_walk_subgraph", "code": "lemma connected_iff_forall_exists_walk_subgraph (H : G.Subgraph) :\n    H.Connected \u2194\n      H.verts.Nonempty \u2227\n        \u2200 {u v}, u \u2208 H.verts \u2192 v \u2208 H.verts \u2192 \u2203 p : G.Walk u v, p.toSubgraph \u2264 H := by\n  rw [H.connected_iff, preconnected_iff_forall_exists_walk_subgraph, and_comm]", "start": [149, 1], "end": [153, 79], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.connected_induce_iff", "code": "lemma connected_induce_iff : (G.induce s).Connected \u2194 ((\u22a4 : G.Subgraph).induce s).Connected := by\n  rw [induce_eq_coe_induce_top, \u2190 Subgraph.connected_iff']", "start": [159, 1], "end": [160, 59], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.induce_union_connected", "code": "lemma induce_union_connected {s t : Set V}\n    (sconn : (G.induce s).Connected) (tconn : (G.induce t).Connected)\n    (sintert : (s \u2229 t).Nonempty) :\n    (G.induce (s \u222a t)).Connected := by\n  rw [connected_induce_iff] at sconn tconn \u22a2\n  exact Subgraph.induce_union_connected sconn tconn sintert", "start": [162, 1], "end": [167, 60], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.induce_pair_connected_of_adj", "code": "lemma induce_pair_connected_of_adj {u v : V} (huv : G.Adj u v) :\n    (G.induce {u, v}).Connected := by\n  rw [connected_induce_iff]\n  exact Subgraph.top_induce_pair_connected_of_adj huv", "start": [169, 1], "end": [172, 54], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Subgraph.Connected.induce_verts", "code": "lemma Subgraph.Connected.induce_verts {H : G.Subgraph} (h : H.Connected) :\n    (G.induce H.verts).Connected := by\n  rw [connected_induce_iff]\n  exact h.mono le_induce_top_verts (by exact rfl)", "start": [174, 1], "end": [177, 50], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.connected_induce_support", "code": "lemma Walk.connected_induce_support {u v : V} (p : G.Walk u v) :\n    (G.induce {v | v \u2208 p.support}).Connected := by\n  rw [\u2190 p.verts_toSubgraph]\n  exact p.toSubgraph_connected.induce_verts", "start": [179, 1], "end": [182, 44], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.induce_connected_adj_union", "code": "lemma induce_connected_adj_union {s t : Set V}\n    (sconn : (G.induce s).Connected) (tconn : (G.induce t).Connected)\n    (hv : v \u2208 s) (hw : w \u2208 t) (ha : G.Adj v w) :\n    (G.induce (s \u222a t)).Connected := by\n  rw [connected_induce_iff] at sconn tconn \u22a2\n  apply (sconn.adj_union tconn hv hw ha).mono\n  \u00b7 simp only [Set.mem_singleton_iff, sup_le_iff, Subgraph.le_induce_union_left,\n      Subgraph.le_induce_union_right, and_true, \u2190 Subgraph.subgraphOfAdj_eq_induce ha]\n    apply subgraphOfAdj_le_of_adj\n    simp [hv, hw, ha]\n  \u00b7 simp only [Set.mem_singleton_iff, sup_le_iff, Subgraph.verts_sup, Subgraph.induce_verts]\n    rw [Set.union_assoc]\n    simp [Set.insert_subset_iff, Set.singleton_subset_iff, hv, hw]", "start": [184, 1], "end": [196, 67], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.induce_connected_of_patches", "code": "lemma induce_connected_of_patches {s : Set V} (u : V) (hu : u \u2208 s)\n    (patches : \u2200 {v} (_ : v \u2208 s), \u2203 (s' : Set V) (_ : s' \u2286 s) (hu' : u \u2208 s') (hv' : v \u2208 s'),\n                  (G.induce s').Reachable \u27e8u, hu'\u27e9 \u27e8v, hv'\u27e9) : (G.induce s).Connected := by\n  rw [connected_iff_exists_forall_reachable]\n  refine \u27e8\u27e8u, hu\u27e9, ?_\u27e9\n  rintro \u27e8v, hv\u27e9\n  obtain \u27e8sv, svs, hu', hv', uv\u27e9 := patches hv\n  exact uv.map (induceHomOfLE _ svs).toHom", "start": [198, 1], "end": [205, 43], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.induce_sUnion_connected_of_pairwise_not_disjoint", "code": "lemma induce_sUnion_connected_of_pairwise_not_disjoint {S : Set (Set V)} (Sn : S.Nonempty)\n    (Snd : \u2200 {s t}, s \u2208 S \u2192 t \u2208 S \u2192 (s \u2229 t).Nonempty)\n    (Sc : \u2200 {s}, s \u2208 S \u2192 (G.induce s).Connected) :\n    (G.induce (\u22c3\u2080 S)).Connected := by\n  obtain \u27e8s, sS\u27e9 := Sn\n  obtain \u27e8v, vs\u27e9 := (Sc sS).nonempty\n  apply G.induce_connected_of_patches _ (Set.subset_sUnion_of_mem sS vs)\n  rintro w hw\n  simp only [Set.mem_sUnion, exists_prop] at hw\n  obtain \u27e8t, tS, wt\u27e9 := hw\n  refine \u27e8s \u222a t, Set.union_subset (Set.subset_sUnion_of_mem sS) (Set.subset_sUnion_of_mem tS),\n          Or.inl vs, Or.inr wt, induce_union_connected (Sc sS) (Sc tS) (Snd sS tS) _ _\u27e9", "start": [207, 1], "end": [218, 88], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.extend_finset_to_connected", "code": "lemma extend_finset_to_connected (Gpc : G.Preconnected) {t : Finset V} (tn : t.Nonempty) :\n    \u2203 (t' : Finset V), t \u2286 t' \u2227 (G.induce (t' : Set V)).Connected := by\n  classical\n  obtain \u27e8u, ut\u27e9 := tn\n  refine \u27e8t.biUnion (fun v => (Gpc u v).some.support.toFinset), fun v vt => ?_, ?_\u27e9\n  \u00b7 simp only [Finset.mem_biUnion, List.mem_toFinset, exists_prop]\n    refine \u27e8v, vt, Walk.end_mem_support _\u27e9\n  \u00b7 apply G.induce_connected_of_patches u\n    \u00b7 simp only [Finset.coe_biUnion, Finset.mem_coe, List.coe_toFinset, Set.mem_iUnion,\n                 Set.mem_setOf_eq, Walk.start_mem_support, exists_prop, and_true]\n      exact \u27e8u, ut\u27e9\n    intros v hv\n    simp only [Finset.mem_coe, Finset.mem_biUnion, List.mem_toFinset, exists_prop] at hv\n    obtain \u27e8w, wt, hw\u27e9 := hv\n    refine \u27e8{x | x \u2208 (Gpc u w).some.support}, ?_, ?_\u27e9\n    \u00b7 simp only [Finset.coe_biUnion, Finset.mem_coe, List.coe_toFinset]\n      exact fun x xw => Set.mem_iUnion\u2082.mpr \u27e8w,wt,xw\u27e9\n    \u00b7 simp only [Set.mem_setOf_eq, Walk.start_mem_support, exists_true_left]\n      refine \u27e8hw, Walk.connected_induce_support _ _ _\u27e9", "start": [220, 1], "end": [238, 55], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Init/Data/Rat/Basic.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Data/Rat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/RingTheory/Polynomial/Opposites.lean", "imports": ["Mathlib/Data/Polynomial/Degree/Definitions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.opRingEquiv", "code": "def opRingEquiv (R : Type*) [Semiring R] : R[X]\u1d50\u1d52\u1d56 \u2243+* R\u1d50\u1d52\u1d56[X] :=\n  ((toFinsuppIso R).op.trans AddMonoidAlgebra.opRingEquiv).trans (toFinsuppIso _).symm", "start": [27, 1], "end": [30, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.opRingEquiv_op_monomial", "code": "@[simp]\ntheorem opRingEquiv_op_monomial (n : \u2115) (r : R) :\n    opRingEquiv R (op (monomial n r : R[X])) = monomial n (op r)", "start": [37, 1], "end": [42, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.opRingEquiv_op_C", "code": "@[simp]\ntheorem opRingEquiv_op_C (a : R) : opRingEquiv R (op (C a)) = C (op a)", "start": [45, 1], "end": [47, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.opRingEquiv_op_X", "code": "@[simp]\ntheorem opRingEquiv_op_X : opRingEquiv R (op (X : R[X])) = X", "start": [51, 1], "end": [53, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.opRingEquiv_op_C_mul_X_pow", "code": "theorem opRingEquiv_op_C_mul_X_pow (r : R) (n : \u2115) :\n    opRingEquiv R (op (C r * X ^ n : R[X])) = C (op r) * X ^ n", "start": [57, 1], "end": [59, 94], "kind": "commanddeclaration"}, {"full_name": "Polynomial.opRingEquiv_symm_monomial", "code": "@[simp]\ntheorem opRingEquiv_symm_monomial (n : \u2115) (r : R\u1d50\u1d52\u1d56) :\n    (opRingEquiv R).symm (monomial n r) = op (monomial n (unop r))", "start": [67, 1], "end": [70, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.opRingEquiv_symm_C", "code": "@[simp]\ntheorem opRingEquiv_symm_C (a : R\u1d50\u1d52\u1d56) : (opRingEquiv R).symm (C a) = op (C (unop a))", "start": [73, 1], "end": [75, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.opRingEquiv_symm_X", "code": "@[simp]\ntheorem opRingEquiv_symm_X : (opRingEquiv R).symm (X : R\u1d50\u1d52\u1d56[X]) = op X", "start": [79, 1], "end": [81, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.opRingEquiv_symm_C_mul_X_pow", "code": "theorem opRingEquiv_symm_C_mul_X_pow (r : R\u1d50\u1d52\u1d56) (n : \u2115) :\n    (opRingEquiv R).symm (C r * X ^ n : R\u1d50\u1d52\u1d56[X]) = op (C (unop r) * X ^ n)", "start": [85, 1], "end": [87, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_opRingEquiv", "code": "@[simp]\ntheorem coeff_opRingEquiv (p : R[X]\u1d50\u1d52\u1d56) (n : \u2115) :\n    (opRingEquiv R p).coeff n = op ((unop p).coeff n)", "start": [94, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_opRingEquiv", "code": "@[simp]\ntheorem support_opRingEquiv (p : R[X]\u1d50\u1d52\u1d56) : (opRingEquiv R p).support = (unop p).support", "start": [102, 1], "end": [106, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_opRingEquiv", "code": "@[simp]\ntheorem natDegree_opRingEquiv (p : R[X]\u1d50\u1d52\u1d56) : (opRingEquiv R p).natDegree = (unop p).natDegree", "start": [109, 1], "end": [114, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_opRingEquiv", "code": "@[simp]\ntheorem leadingCoeff_opRingEquiv (p : R[X]\u1d50\u1d52\u1d56) :\n    (opRingEquiv R p).leadingCoeff = op (unop p).leadingCoeff", "start": [117, 1], "end": [120, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Bicategory/SingleObj.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/Functor.lean", "Mathlib/CategoryTheory/Bicategory/End.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.MonoidalSingleObj", "code": "@[nolint unusedArguments]\ndef MonoidalSingleObj (C : Type*) [Category C] [MonoidalCategory C] :=\n  PUnit", "start": [35, 1], "end": [42, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalSingleObj.star", "code": "@[nolint unusedArguments]\nprotected def star : MonoidalSingleObj C :=\n  PUnit.unit", "start": [71, 1], "end": [74, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalSingleObj.endMonoidalStarFunctor", "code": "@[simps]\ndef endMonoidalStarFunctor : MonoidalFunctor (EndMonoidal (MonoidalSingleObj.star C)) C where\n  obj X := X\n  map f := f\n  \u03b5 := \ud835\udfd9 _\n  \u03bc X Y := \ud835\udfd9 _\n  \u03bc_natural f g := by\n    simp_rw [Category.id_comp, Category.comp_id]\n    exact (tensor_id_comp_id_tensor _ _).symm", "start": [77, 1], "end": [92, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalSingleObj.endMonoidalStarFunctorIsEquivalence", "code": "noncomputable def endMonoidalStarFunctorIsEquivalence :\n    IsEquivalence (endMonoidalStarFunctor C).toFunctor where\n  inverse :=\n    { obj := fun X => X\n      map := fun f => f }\n  unitIso := NatIso.ofComponents fun X => asIso (\ud835\udfd9 _)\n  counitIso := NatIso.ofComponents fun X => asIso (\ud835\udfd9 _)", "start": [95, 1], "end": [105, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/Bitraversable/Instances.lean", "imports": ["Mathlib/Control/Traversable/Lemmas.lean", "Mathlib/Control/Bitraversable/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prod.bitraverse", "code": "def Prod.bitraverse {\u03b1 \u03b1' \u03b2 \u03b2'} (f : \u03b1 \u2192 F \u03b1') (f' : \u03b2 \u2192 F \u03b2') : \u03b1 \u00d7 \u03b2 \u2192 F (\u03b1' \u00d7 \u03b2')\n  | (x, y) => Prod.mk <$> f x <*> f' y", "start": [40, 1], "end": [42, 39], "kind": "commanddeclaration"}, {"full_name": "Sum.bitraverse", "code": "def Sum.bitraverse {\u03b1 \u03b1' \u03b2 \u03b2'} (f : \u03b1 \u2192 F \u03b1') (f' : \u03b2 \u2192 F \u03b2') : Sum \u03b1 \u03b2 \u2192 F (Sum \u03b1' \u03b2')\n  | Sum.inl x => Sum.inl <$> f x\n  | Sum.inr x => Sum.inr <$> f' x", "start": [53, 1], "end": [56, 34], "kind": "commanddeclaration"}, {"full_name": "Const.bitraverse", "code": "@[nolint unusedArguments]\ndef Const.bitraverse {F : Type u \u2192 Type u} [Applicative F] {\u03b1 \u03b1' \u03b2 \u03b2'} (f : \u03b1 \u2192 F \u03b1')\n    (f' : \u03b2 \u2192 F \u03b2') : Const \u03b1 \u03b2 \u2192 F (Const \u03b1' \u03b2') :=\n  f", "start": [67, 1], "end": [71, 4], "kind": "commanddeclaration"}, {"full_name": "Bitraversable.const", "code": "instance Bitraversable.const : Bitraversable Const where bitraverse := @Const.bitraverse", "start": [74, 1], "end": [74, 89], "kind": "commanddeclaration"}, {"full_name": "LawfulBitraversable.const", "code": "instance LawfulBitraversable.const : LawfulBitraversable Const := by\n  constructor <;> intros <;> simp [bitraverse, Const.bitraverse, functor_norm] <;> rfl", "start": [77, 1], "end": [78, 87], "kind": "commanddeclaration"}, {"full_name": "flip.bitraverse", "code": "nonrec def flip.bitraverse {\u03b1 \u03b1' \u03b2 \u03b2'} (f : \u03b1 \u2192 F \u03b1') (f' : \u03b2 \u2192 F \u03b2') :\n    flip t \u03b1 \u03b2 \u2192 F (flip t \u03b1' \u03b2') :=\n  (bitraverse f' f : t \u03b2 \u03b1 \u2192 F (t \u03b2' \u03b1'))", "start": [81, 1], "end": [84, 42], "kind": "commanddeclaration"}, {"full_name": "Bitraversable.flip", "code": "instance Bitraversable.flip : Bitraversable (flip t) where bitraverse := @flip.bitraverse t _", "start": [87, 1], "end": [87, 94], "kind": "commanddeclaration"}, {"full_name": "LawfulBitraversable.flip", "code": "instance LawfulBitraversable.flip [LawfulBitraversable t] : LawfulBitraversable (flip t) := by\n  constructor <;> intros <;> casesm LawfulBitraversable t <;> apply_assumption only [*]", "start": [92, 1], "end": [93, 88], "kind": "commanddeclaration"}, {"full_name": "Bitraversable.traversable", "code": "instance (priority := 10) Bitraversable.traversable {\u03b1} : Traversable (t \u03b1) where\n  traverse := @tsnd t _ _", "start": [98, 1], "end": [99, 26], "kind": "commanddeclaration"}, {"full_name": "Bitraversable.isLawfulTraversable", "code": "instance (priority := 10) Bitraversable.isLawfulTraversable [LawfulBitraversable t] {\u03b1} :\n    LawfulTraversable (t \u03b1) := by\n  constructor <;> intros <;>\n    simp [traverse, comp_tsnd, functor_norm, -ApplicativeTransformation.app_eq_coe]\n  \u00b7 simp [tsnd_eq_snd_id]; rfl\n  \u00b7 simp [tsnd, binaturality, Function.comp, functor_norm, -ApplicativeTransformation.app_eq_coe]", "start": [102, 1], "end": [107, 98], "kind": "commanddeclaration"}, {"full_name": "Bicompl.bitraverse", "code": "nonrec def Bicompl.bitraverse {m} [Applicative m] {\u03b1 \u03b2 \u03b1' \u03b2'} (f : \u03b1 \u2192 m \u03b2) (f' : \u03b1' \u2192 m \u03b2') :\n    bicompl t F G \u03b1 \u03b1' \u2192 m (bicompl t F G \u03b2 \u03b2') :=\n  (bitraverse (traverse f) (traverse f') : t (F \u03b1) (G \u03b1') \u2192 m _)", "start": [120, 1], "end": [123, 65], "kind": "commanddeclaration"}, {"full_name": "Bicompr.bitraverse", "code": "nonrec def Bicompr.bitraverse {m} [Applicative m] {\u03b1 \u03b2 \u03b1' \u03b2'} (f : \u03b1 \u2192 m \u03b2) (f' : \u03b1' \u2192 m \u03b2') :\n    bicompr F t \u03b1 \u03b1' \u2192 m (bicompr F t \u03b2 \u03b2') :=\n  (traverse (bitraverse f f') : F (t \u03b1 \u03b1') \u2192 m _)", "start": [143, 1], "end": [146, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/DualQuaternion.lean", "imports": ["Mathlib/Algebra/Quaternion.lean", "Mathlib/Algebra/DualNumber.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Quaternion.dualNumberEquiv", "code": "def dualNumberEquiv : Quaternion (DualNumber R) \u2243\u2090[R] DualNumber (Quaternion R) where\n  toFun q :=\n    (\u27e8q.re.fst, q.imI.fst, q.imJ.fst, q.imK.fst\u27e9, \u27e8q.re.snd, q.imI.snd, q.imJ.snd, q.imK.snd\u27e9)\n  invFun d :=\n    \u27e8(d.fst.re, d.snd.re), (d.fst.imI, d.snd.imI), (d.fst.imJ, d.snd.imJ), (d.fst.imK, d.snd.imK)\u27e9\n  left_inv := fun \u27e8\u27e8r, r\u03b5\u27e9, \u27e8i, i\u03b5\u27e9, \u27e8j, j\u03b5\u27e9, \u27e8k, k\u03b5\u27e9\u27e9 => rfl\n  right_inv := fun \u27e8\u27e8r, i, j, k\u27e9, \u27e8r\u03b5, i\u03b5, j\u03b5, k\u03b5\u27e9\u27e9 => rfl\n  map_mul' := by\n    rintro \u27e8\u27e8xr, xr\u03b5\u27e9, \u27e8xi, xi\u03b5\u27e9, \u27e8xj, xj\u03b5\u27e9, \u27e8xk, xk\u03b5\u27e9\u27e9\n    rintro \u27e8\u27e8yr, yr\u03b5\u27e9, \u27e8yi, yi\u03b5\u27e9, \u27e8yj, yj\u03b5\u27e9, \u27e8yk, yk\u03b5\u27e9\u27e9\n    ext : 1\n    \u00b7 rfl\n    \u00b7 dsimp\n      congr 1 <;> simp <;> ring\n  map_add' := by\n    rintro \u27e8\u27e8xr, xr\u03b5\u27e9, \u27e8xi, xi\u03b5\u27e9, \u27e8xj, xj\u03b5\u27e9, \u27e8xk, xk\u03b5\u27e9\u27e9\n    rintro \u27e8\u27e8yr, yr\u03b5\u27e9, \u27e8yi, yi\u03b5\u27e9, \u27e8yj, yj\u03b5\u27e9, \u27e8yk, yk\u03b5\u27e9\u27e9\n    rfl\n  commutes' r := rfl", "start": [32, 1], "end": [54, 21], "kind": "commanddeclaration"}, {"full_name": "Quaternion.re_fst_dualNumberEquiv", "code": "@[simp]\ntheorem re_fst_dualNumberEquiv (q : Quaternion (DualNumber R)) :\n    (dualNumberEquiv q).fst.re = q.re.fst", "start": [61, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.imI_fst_dualNumberEquiv", "code": "@[simp]\ntheorem imI_fst_dualNumberEquiv (q : Quaternion (DualNumber R)) :\n    (dualNumberEquiv q).fst.imI = q.imI.fst", "start": [67, 1], "end": [70, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.imJ_fst_dualNumberEquiv", "code": "@[simp]\ntheorem imJ_fst_dualNumberEquiv (q : Quaternion (DualNumber R)) :\n    (dualNumberEquiv q).fst.imJ = q.imJ.fst", "start": [73, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.imK_fst_dualNumberEquiv", "code": "@[simp]\ntheorem imK_fst_dualNumberEquiv (q : Quaternion (DualNumber R)) :\n    (dualNumberEquiv q).fst.imK = q.imK.fst", "start": [79, 1], "end": [82, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.re_snd_dualNumberEquiv", "code": "@[simp]\ntheorem re_snd_dualNumberEquiv (q : Quaternion (DualNumber R)) :\n    (dualNumberEquiv q).snd.re = q.re.snd", "start": [85, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.imI_snd_dualNumberEquiv", "code": "@[simp]\ntheorem imI_snd_dualNumberEquiv (q : Quaternion (DualNumber R)) :\n    (dualNumberEquiv q).snd.imI = q.imI.snd", "start": [91, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.imJ_snd_dualNumberEquiv", "code": "@[simp]\ntheorem imJ_snd_dualNumberEquiv (q : Quaternion (DualNumber R)) :\n    (dualNumberEquiv q).snd.imJ = q.imJ.snd", "start": [97, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.imK_snd_dualNumberEquiv", "code": "@[simp]\ntheorem imK_snd_dualNumberEquiv (q : Quaternion (DualNumber R)) :\n    (dualNumberEquiv q).snd.imK = q.imK.snd", "start": [103, 1], "end": [106, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.fst_re_dualNumberEquiv_symm", "code": "@[simp]\ntheorem fst_re_dualNumberEquiv_symm (d : DualNumber (Quaternion R)) :\n    (dualNumberEquiv.symm d).re.fst = d.fst.re", "start": [109, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.fst_imI_dualNumberEquiv_symm", "code": "@[simp]\ntheorem fst_imI_dualNumberEquiv_symm (d : DualNumber (Quaternion R)) :\n    (dualNumberEquiv.symm d).imI.fst = d.fst.imI", "start": [115, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.fst_imJ_dualNumberEquiv_symm", "code": "@[simp]\ntheorem fst_imJ_dualNumberEquiv_symm (d : DualNumber (Quaternion R)) :\n    (dualNumberEquiv.symm d).imJ.fst = d.fst.imJ", "start": [121, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.fst_imK_dualNumberEquiv_symm", "code": "@[simp]\ntheorem fst_imK_dualNumberEquiv_symm (d : DualNumber (Quaternion R)) :\n    (dualNumberEquiv.symm d).imK.fst = d.fst.imK", "start": [127, 1], "end": [130, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.snd_re_dualNumberEquiv_symm", "code": "@[simp]\ntheorem snd_re_dualNumberEquiv_symm (d : DualNumber (Quaternion R)) :\n    (dualNumberEquiv.symm d).re.snd = d.snd.re", "start": [133, 1], "end": [136, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.snd_imI_dualNumberEquiv_symm", "code": "@[simp]\ntheorem snd_imI_dualNumberEquiv_symm (d : DualNumber (Quaternion R)) :\n    (dualNumberEquiv.symm d).imI.snd = d.snd.imI", "start": [139, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.snd_imJ_dualNumberEquiv_symm", "code": "@[simp]\ntheorem snd_imJ_dualNumberEquiv_symm (d : DualNumber (Quaternion R)) :\n    (dualNumberEquiv.symm d).imJ.snd = d.snd.imJ", "start": [145, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.snd_imK_dualNumberEquiv_symm", "code": "@[simp]\ntheorem snd_imK_dualNumberEquiv_symm (d : DualNumber (Quaternion R)) :\n    (dualNumberEquiv.symm d).imK.snd = d.snd.imK", "start": [151, 1], "end": [154, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Category/Factorisation.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "Mathlib/CategoryTheory/Arrow.lean", "Mathlib/CategoryTheory/Category/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Factorisation", "code": "structure Factorisation {X Y : C} (f : X \u27f6 Y) where\n  \n  mid : C\n  \n  \u03b9   : X \u27f6 mid\n  \n  \u03c0   : mid \u27f6 Y\n  \n  \u03b9_\u03c0 : \u03b9 \u226b \u03c0 = f := by aesop_cat", "start": [28, 1], "end": [38, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Factorisation.Hom", "code": "@[ext]\nprotected structure Hom (d e : Factorisation f) : Type (max u v) where\n  \n  h : d.mid \u27f6 e.mid\n  \n  \u03b9_h : d.\u03b9 \u226b h = e.\u03b9 := by aesop_cat\n  \n  h_\u03c0 : h \u226b e.\u03c0 = d.\u03c0 := by aesop_cat", "start": [46, 1], "end": [55, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Factorisation.Hom.id", "code": "@[simps]\nprotected def Hom.id (d : Factorisation f) : Factorisation.Hom d d where\n  h := \ud835\udfd9 _", "start": [59, 1], "end": [62, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Factorisation.Hom.comp", "code": "@[simps]\nprotected def Hom.comp {d\u2081 d\u2082 d\u2083 : Factorisation f}\n    (f : Factorisation.Hom d\u2081 d\u2082) (g : Factorisation.Hom d\u2082 d\u2083) : Factorisation.Hom d\u2081 d\u2083 where\n  h := f.h \u226b g.h\n  \u03b9_h := by rw [\u2190 Category.assoc, f.\u03b9_h, g.\u03b9_h]\n  h_\u03c0 := by rw [Category.assoc, g.h_\u03c0, f.h_\u03c0]", "start": [64, 1], "end": [70, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Factorisation.initial", "code": "@[simps]\nprotected def initial : Factorisation f where\n  mid := X\n  \u03b9 := \ud835\udfd9 _\n  \u03c0 := f", "start": [79, 1], "end": [84, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Factorisation.initialHom", "code": "@[simps]\nprotected def initialHom (d : Factorisation f) :\n    Factorisation.Hom (Factorisation.initial : Factorisation f) d where\n  h := d.\u03b9", "start": [86, 1], "end": [90, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Factorisation.terminal", "code": "@[simps]\nprotected def terminal : Factorisation f where\n  mid := Y\n  \u03b9 := f\n  \u03c0 := \ud835\udfd9 _", "start": [96, 1], "end": [101, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Factorisation.terminalHom", "code": "@[simps]\nprotected def terminalHom (d : Factorisation f) :\n    Factorisation.Hom d (Factorisation.terminal : Factorisation f) where\n  h := d.\u03c0", "start": [103, 1], "end": [107, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Factorisation.IsInitial_initial", "code": "def IsInitial_initial : IsInitial (Factorisation.initial : Factorisation f) := IsInitial.ofUnique _", "start": [115, 1], "end": [116, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Factorisation.IsTerminal_terminal", "code": "def IsTerminal_terminal : IsTerminal (Factorisation.terminal : Factorisation f) :=\nIsTerminal.ofUnique _", "start": [120, 1], "end": [122, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Factorisation.forget", "code": "@[simps]\ndef forget : Factorisation f \u2964 C where\n  obj := Factorisation.mid\n  map f := f.h", "start": [126, 1], "end": [130, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/FinallySmall.lean", "imports": ["Mathlib/CategoryTheory/Limits/Final.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.FinallySmall", "code": "class FinallySmall : Prop where\n  \n  final_smallCategory : \u2203 (S : Type w) (_ : SmallCategory S) (F : S \u2964 J), Final F", "start": [32, 1], "end": [35, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinallySmall.mk'", "code": "theorem FinallySmall.mk' {J : Type u} [Category.{v} J] {S : Type w} [SmallCategory S]\n    (F : S \u2964 J) [Final F] : FinallySmall.{w} J", "start": [37, 1], "end": [40, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinalModel", "code": "def FinalModel [FinallySmall.{w} J] : Type w :=\n  Classical.choose (@FinallySmall.final_smallCategory J _ _)", "start": [42, 1], "end": [44, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.smallCategoryFinalModel", "code": "noncomputable instance smallCategoryFinalModel [FinallySmall.{w} J] :\n    SmallCategory (FinalModel J) :=\n  Classical.choose (Classical.choose_spec (@FinallySmall.final_smallCategory J _ _))", "start": [46, 1], "end": [48, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.fromFinalModel", "code": "noncomputable def fromFinalModel [FinallySmall.{w} J] : FinalModel J \u2964 J :=\n  Classical.choose (Classical.choose_spec (Classical.choose_spec\n    (@FinallySmall.final_smallCategory J _ _)))", "start": [50, 1], "end": [53, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.final_fromFinalModel", "code": "instance final_fromFinalModel [FinallySmall.{w} J] : Final (fromFinalModel J) :=\n  Classical.choose_spec (Classical.choose_spec (Classical.choose_spec\n    (@FinallySmall.final_smallCategory J _ _)))", "start": [55, 1], "end": [57, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finallySmall_of_essentiallySmall", "code": "theorem finallySmall_of_essentiallySmall [EssentiallySmall.{w} J] : FinallySmall.{w} J", "start": [59, 1], "end": [60, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InitiallySmall", "code": "class InitiallySmall : Prop where\n  \n  initial_smallCategory : \u2203 (S : Type w) (_ : SmallCategory S) (F : S \u2964 J), Initial F", "start": [68, 1], "end": [71, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InitiallySmall.mk'", "code": "theorem InitiallySmall.mk' {J : Type u} [Category.{v} J] {S : Type w} [SmallCategory S]\n    (F : S \u2964 J) [Initial F] : InitiallySmall.{w} J", "start": [73, 1], "end": [76, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InitialModel", "code": "def InitialModel [InitiallySmall.{w} J] : Type w :=\n  Classical.choose (@InitiallySmall.initial_smallCategory J _ _)", "start": [78, 1], "end": [80, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.smallCategoryInitialModel", "code": "noncomputable instance smallCategoryInitialModel [InitiallySmall.{w} J] :\n    SmallCategory (InitialModel J) :=\n  Classical.choose (Classical.choose_spec (@InitiallySmall.initial_smallCategory J _ _))", "start": [82, 1], "end": [84, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.fromInitialModel", "code": "noncomputable def fromInitialModel [InitiallySmall.{w} J] : InitialModel J \u2964 J :=\n  Classical.choose (Classical.choose_spec (Classical.choose_spec\n    (@InitiallySmall.initial_smallCategory J _ _)))", "start": [86, 1], "end": [89, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.initial_fromInitialModel", "code": "instance initial_fromInitialModel [InitiallySmall.{w} J] : Initial (fromInitialModel J) :=\n  Classical.choose_spec (Classical.choose_spec (Classical.choose_spec\n    (@InitiallySmall.initial_smallCategory J _ _)))", "start": [91, 1], "end": [93, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.initiallySmall_of_essentiallySmall", "code": "theorem initiallySmall_of_essentiallySmall [EssentiallySmall.{w} J] : InitiallySmall.{w} J", "start": [95, 1], "end": [96, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimitsOfShape_of_finallySmall", "code": "theorem hasColimitsOfShape_of_finallySmall (J : Type u) [Category.{v} J] [FinallySmall.{w} J]\n    (C : Type u\u2081) [Category.{v\u2081} C] [HasColimitsOfSize.{w, w} C] : HasColimitsOfShape J C", "start": [102, 1], "end": [104, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitsOfShape_of_initiallySmall", "code": "theorem hasLimitsOfShape_of_initiallySmall (J : Type u) [Category.{v} J] [InitiallySmall.{w} J]\n    (C : Type u\u2081) [Category.{v\u2081} C] [HasLimitsOfSize.{w, w} C] : HasLimitsOfShape J C", "start": [106, 1], "end": [108, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Colex.lean", "imports": ["Mathlib/Algebra/GeomSum.lean", "Mathlib/Data/Fintype/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.Colex", "code": "def Finset.Colex (\u03b1) :=\n  Finset \u03b1", "start": [59, 1], "end": [63, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.toColex", "code": "def Finset.toColex {\u03b1} (s : Finset \u03b1) : Finset.Colex \u03b1 :=\n  s", "start": [69, 1], "end": [73, 4], "kind": "commanddeclaration"}, {"full_name": "Colex.eq_iff", "code": "@[simp]\ntheorem Colex.eq_iff (A B : Finset \u03b1) : A.toColex = B.toColex \u2194 A = B", "start": [76, 1], "end": [78, 10], "kind": "commanddeclaration"}, {"full_name": "Colex.instLT", "code": "instance Colex.instLT [LT \u03b1] : LT (Finset.Colex \u03b1) :=\n  \u27e8fun A B : Finset \u03b1 => \u2203 k : \u03b1, (\u2200 {x}, k < x \u2192 (x \u2208 A \u2194 x \u2208 B)) \u2227 k \u2209 A \u2227 k \u2208 B\u27e9", "start": [81, 1], "end": [85, 84], "kind": "commanddeclaration"}, {"full_name": "Colex.instLE", "code": "instance Colex.instLE [LT \u03b1] : LE (Finset.Colex \u03b1) :=\n  \u27e8fun A B => A < B \u2228 A = B\u27e9", "start": [87, 1], "end": [89, 29], "kind": "commanddeclaration"}, {"full_name": "Colex.lt_def", "code": "theorem Colex.lt_def [LT \u03b1] (A B : Finset \u03b1) :\n    A.toColex < B.toColex \u2194 \u2203 k, (\u2200 {x}, k < x \u2192 (x \u2208 A \u2194 x \u2208 B)) \u2227 k \u2209 A \u2227 k \u2208 B", "start": [91, 1], "end": [93, 10], "kind": "commanddeclaration"}, {"full_name": "Colex.le_def", "code": "theorem Colex.le_def [LT \u03b1] (A B : Finset \u03b1) :\n    A.toColex \u2264 B.toColex \u2194 A.toColex < B.toColex \u2228 A = B", "start": [96, 1], "end": [98, 10], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_two_pow_lt", "code": "theorem Nat.sum_two_pow_lt {k : \u2115} {A : Finset \u2115} (h\u2081 : \u2200 {x}, x \u2208 A \u2192 x < k) :\n    A.sum (Nat.pow 2) < 2 ^ k", "start": [101, 1], "end": [108, 25], "kind": "commanddeclaration"}, {"full_name": "Colex.hom_lt_iff", "code": "theorem hom_lt_iff {\u03b2 : Type*} [LinearOrder \u03b1] [DecidableEq \u03b2] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (h\u2081 : StrictMono f) (A B : Finset \u03b1) :\n    (A.image f).toColex < (B.image f).toColex \u2194 A.toColex < B.toColex", "start": [113, 1], "end": [132, 49], "kind": "commanddeclaration"}, {"full_name": "Colex.hom_fin_lt_iff", "code": "@[simp]\ntheorem hom_fin_lt_iff {n : \u2115} (A B : Finset (Fin n)) :\n    (A.image fun i : Fin n => (i : \u2115)).toColex < (B.image fun i : Fin n => (i : \u2115)).toColex \u2194\n      A.toColex < B.toColex", "start": [135, 1], "end": [141, 25], "kind": "commanddeclaration"}, {"full_name": "Colex.lt_trans", "code": "@[trans]\ntheorem lt_trans [LinearOrder \u03b1] {a b c : Finset.Colex \u03b1} : a < b \u2192 b < c \u2192 a < c", "start": [147, 1], "end": [157, 33], "kind": "commanddeclaration"}, {"full_name": "Colex.le_trans", "code": "@[trans]\ntheorem le_trans [LinearOrder \u03b1] (a b c : Finset.Colex \u03b1) : a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c", "start": [160, 1], "end": [162, 99], "kind": "commanddeclaration"}, {"full_name": "Colex.lt_trichotomy", "code": "theorem lt_trichotomy [LinearOrder \u03b1] (A B : Finset.Colex \u03b1) : A < B \u2228 A = B \u2228 B < A", "start": [168, 1], "end": [193, 35], "kind": "commanddeclaration"}, {"full_name": "Colex.decidableLt", "code": "instance decidableLt [LinearOrder \u03b1] : \u2200 {A B : Finset.Colex \u03b1}, Decidable (A < B) :=\n  show \u2200 {A B : Finset \u03b1}, Decidable (A.toColex < B.toColex) from @fun A B =>\n    decidable_of_iff' (\u2203 k \u2208 B, (\u2200 x \u2208 A \u222a B, k < x \u2192 (x \u2208 A \u2194 x \u2208 B)) \u2227 k \u2209 A)\n      (by\n        rw [Colex.lt_def]\n        apply exists_congr\n        simp only [mem_union, exists_prop, or_imp, and_comm (a := _ \u2208 B), and_assoc]\n        intro k\n        refine' and_congr_left' (forall_congr' _)\n        tauto)", "start": [199, 1], "end": [208, 15], "kind": "commanddeclaration"}, {"full_name": "Colex.hom_le_iff", "code": "theorem hom_le_iff {\u03b2 : Type*} [LinearOrder \u03b1] [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} (h\u2081 : StrictMono f)\n    (A B : Finset \u03b1) : (A.image f).toColex \u2264 (B.image f).toColex \u2194 A.toColex \u2264 B.toColex", "start": [241, 1], "end": [244, 46], "kind": "commanddeclaration"}, {"full_name": "Colex.hom_fin_le_iff", "code": "@[simp]\ntheorem hom_fin_le_iff {n : \u2115} (A B : Finset (Fin n)) :\n    (A.image fun i : Fin n => (i : \u2115)).toColex \u2264 (B.image fun i : Fin n => (i : \u2115)).toColex \u2194\n      A.toColex \u2264 B.toColex", "start": [248, 1], "end": [253, 42], "kind": "commanddeclaration"}, {"full_name": "Colex.forall_lt_of_colex_lt_of_forall_lt", "code": "theorem forall_lt_of_colex_lt_of_forall_lt [LinearOrder \u03b1] {A B : Finset \u03b1} (t : \u03b1)\n    (h\u2081 : A.toColex < B.toColex) (h\u2082 : \u2200 x \u2208 B, x < t) : \u2200 x \u2208 A, x < t", "start": [256, 1], "end": [267, 36], "kind": "commanddeclaration"}, {"full_name": "Colex.lt_singleton_iff_mem_lt", "code": "theorem lt_singleton_iff_mem_lt [LinearOrder \u03b1] {r : \u03b1} {s : Finset \u03b1} :\n    s.toColex < ({r} : Finset \u03b1).toColex \u2194 \u2200 x \u2208 s, x < r", "start": [270, 1], "end": [283, 30], "kind": "commanddeclaration"}, {"full_name": "Colex.mem_le_of_singleton_le", "code": "theorem mem_le_of_singleton_le [LinearOrder \u03b1] {r : \u03b1} {s : Finset \u03b1} :\n    ({r} : Finset \u03b1).toColex \u2264 s.toColex \u2194 \u2203 x \u2208 s, r \u2264 x", "start": [287, 1], "end": [292, 33], "kind": "commanddeclaration"}, {"full_name": "Colex.singleton_lt_iff_lt", "code": "theorem singleton_lt_iff_lt [LinearOrder \u03b1] {r s : \u03b1} :\n    ({r} : Finset \u03b1).toColex < ({s} : Finset \u03b1).toColex \u2194 r < s", "start": [295, 1], "end": [297, 101], "kind": "commanddeclaration"}, {"full_name": "Colex.singleton_le_iff_le", "code": "theorem singleton_le_iff_le [LinearOrder \u03b1] {r s : \u03b1} :\n    ({r} : Finset \u03b1).toColex \u2264 ({s} : Finset \u03b1).toColex \u2194 r \u2264 s", "start": [300, 1], "end": [303, 52], "kind": "commanddeclaration"}, {"full_name": "Colex.sdiff_lt_sdiff_iff_lt", "code": "@[simp]\ntheorem sdiff_lt_sdiff_iff_lt [LT \u03b1] [DecidableEq \u03b1] (A B : Finset \u03b1) :\n    (A \\ B).toColex < (B \\ A).toColex \u2194 A.toColex < B.toColex", "start": [306, 1], "end": [323, 14], "kind": "commanddeclaration"}, {"full_name": "Colex.sdiff_le_sdiff_iff_le", "code": "@[simp]\ntheorem sdiff_le_sdiff_iff_le [LinearOrder \u03b1] (A B : Finset \u03b1) :\n    (A \\ B).toColex \u2264 (B \\ A).toColex \u2194 A.toColex \u2264 B.toColex", "start": [326, 1], "end": [330, 54], "kind": "commanddeclaration"}, {"full_name": "Colex.empty_toColex_lt", "code": "theorem empty_toColex_lt [LinearOrder \u03b1] {A : Finset \u03b1} (hA : A.Nonempty) :\n    (\u2205 : Finset \u03b1).toColex < A.toColex", "start": [333, 1], "end": [339, 40], "kind": "commanddeclaration"}, {"full_name": "Colex.colex_lt_of_ssubset", "code": "theorem colex_lt_of_ssubset [LinearOrder \u03b1] {A B : Finset \u03b1} (h : A \u2282 B) :\n    A.toColex < B.toColex", "start": [342, 1], "end": [347, 80], "kind": "commanddeclaration"}, {"full_name": "Colex.empty_toColex_le", "code": "@[simp]\ntheorem empty_toColex_le [LinearOrder \u03b1] {A : Finset \u03b1} : (\u2205 : Finset \u03b1).toColex \u2264 A.toColex", "start": [350, 1], "end": [354, 35], "kind": "commanddeclaration"}, {"full_name": "Colex.colex_le_of_subset", "code": "theorem colex_le_of_subset [LinearOrder \u03b1] {A B : Finset \u03b1} (h : A \u2286 B) :\n    A.toColex \u2264 B.toColex", "start": [357, 1], "end": [362, 25], "kind": "commanddeclaration"}, {"full_name": "Colex.toColexRelHom", "code": "@[simps]\ndef toColexRelHom [LinearOrder \u03b1] :\n    ((\u00b7 \u2286 \u00b7) : Finset \u03b1 \u2192 Finset \u03b1 \u2192 Prop) \u2192r ((\u00b7 \u2264 \u00b7) : Finset.Colex \u03b1 \u2192 Finset.Colex \u03b1 \u2192 Prop)\n    where\n  toFun := Finset.toColex\n  map_rel' {_ _} := colex_le_of_subset", "start": [365, 1], "end": [371, 39], "kind": "commanddeclaration"}, {"full_name": "Colex.sum_two_pow_lt_iff_lt", "code": "theorem sum_two_pow_lt_iff_lt (A B : Finset \u2115) :\n    ((\u2211 i in A, 2 ^ i) < \u2211 i in B, 2 ^ i) \u2194 A.toColex < B.toColex", "start": [390, 1], "end": [414, 19], "kind": "commanddeclaration"}, {"full_name": "Colex.sum_two_pow_le_iff_lt", "code": "theorem sum_two_pow_le_iff_lt (A B : Finset \u2115) :\n    ((\u2211 i in A, 2 ^ i) \u2264 \u2211 i in B, 2 ^ i) \u2194 A.toColex \u2264 B.toColex", "start": [417, 1], "end": [420, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/Profinite/Product.lean", "imports": ["Mathlib/Topology/Category/Profinite/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Profinite.IndexFunctor.obj", "code": "def obj : Set ((i : {i : \u03b9 // J i}) \u2192 X i) := ContinuousMap.precomp (Subtype.val (p := J)) '' C", "start": [41, 1], "end": [42, 96], "kind": "commanddeclaration"}, {"full_name": "Profinite.IndexFunctor.\u03c0_app", "code": "def \u03c0_app : C(C, obj C J) :=\n  \u27e8Set.MapsTo.restrict (precomp (Subtype.val (p := J))) _ _ (Set.mapsTo_image _ _),\n    Continuous.restrict _ (Pi.continuous_precomp' _)\u27e9", "start": [44, 1], "end": [47, 54], "kind": "commanddeclaration"}, {"full_name": "Profinite.IndexFunctor.map", "code": "def map (h : \u2200 i, J i \u2192 K i) : C(obj C K, obj C J) :=\n  \u27e8Set.MapsTo.restrict (precomp (Set.inclusion h)) _ _ (fun _ hx \u21a6 by\n    obtain \u27e8y, hy\u27e9 := hx\n    rw [\u2190 hy.2]\n    exact \u27e8y, hy.1, rfl\u27e9), Continuous.restrict _ (Pi.continuous_precomp' _)\u27e9", "start": [51, 1], "end": [56, 77], "kind": "commanddeclaration"}, {"full_name": "Profinite.IndexFunctor.surjective_\u03c0_app", "code": "theorem surjective_\u03c0_app :\n    Function.Surjective (\u03c0_app C J)", "start": [58, 1], "end": [62, 38], "kind": "commanddeclaration"}, {"full_name": "Profinite.IndexFunctor.map_comp_\u03c0_app", "code": "theorem map_comp_\u03c0_app (h : \u2200 i, J i \u2192 K i) : map C h \u2218 \u03c0_app C K = \u03c0_app C J", "start": [64, 1], "end": [64, 85], "kind": "commanddeclaration"}, {"full_name": "Profinite.IndexFunctor.eq_of_forall_\u03c0_app_eq", "code": "theorem eq_of_forall_\u03c0_app_eq (a b : C)\n    (h : \u2200 (J : Finset \u03b9), \u03c0_app C (\u00b7 \u2208 J) a = \u03c0_app C (\u00b7 \u2208 J) b) : a = b", "start": [68, 1], "end": [75, 54], "kind": "commanddeclaration"}, {"full_name": "Profinite.indexFunctor", "code": "noncomputable\ndef indexFunctor : (Finset \u03b9)\u1d52\u1d56 \u2964 Profinite.{u} where\n  obj J := @Profinite.of (obj C (\u00b7 \u2208 (unop J))) _\n    (by rw [\u2190 isCompact_iff_compactSpace]; exact hC.image (Pi.continuous_precomp' _)) _ _\n  map h := map C (leOfHom h.unop)", "start": [83, 1], "end": [88, 34], "kind": "commanddeclaration"}, {"full_name": "Profinite.indexCone", "code": "noncomputable\ndef indexCone : Cone (indexFunctor hC) where\n  pt := @Profinite.of C _ (by rwa [\u2190 isCompact_iff_compactSpace]) _ _\n  \u03c0 := { app := fun J \u21a6 \u03c0_app C (\u00b7 \u2208 unop J) }", "start": [90, 1], "end": [94, 47], "kind": "commanddeclaration"}, {"full_name": "Profinite.isIso_indexCone_lift", "code": "instance isIso_indexCone_lift [DecidableEq \u03b9] :\n    IsIso ((limitConeIsLimit (indexFunctor hC)).lift (indexCone hC)) :=\n  haveI : CompactSpace C := by rwa [\u2190 isCompact_iff_compactSpace]\n  isIso_of_bijective _\n    (by\n      refine \u27e8fun a b h \u21a6 ?_, fun a \u21a6 ?_\u27e9\n      \u00b7 refine eq_of_forall_\u03c0_app_eq a b (fun J \u21a6 ?_)\n        apply_fun fun f : (limitCone (indexFunctor hC)).pt => f.val (op J) at h\n        exact h\n      \u00b7 suffices : \u2203 (x : C), \u2200 (J : Finset \u03b9), \u03c0_app C (\u00b7 \u2208 J) x = a.val (op J)\n        \u00b7 obtain \u27e8b, hb\u27e9 := this\n          use b\n          apply Subtype.ext\n          apply funext\n          intro J\n          exact hb (unop J)\n        have hc : \u2200 (J : Finset \u03b9) s, IsClosed ((\u03c0_app C (\u00b7 \u2208 J)) \u207b\u00b9' {s})\n        \u00b7 intro J s\n          refine IsClosed.preimage (\u03c0_app C (\u00b7 \u2208 J)).continuous ?_\n          exact T1Space.t1 s\n        have H\u2081 : \u2200 (Q\u2081 Q\u2082 : Finset \u03b9), Q\u2081 \u2264 Q\u2082 \u2192\n            \u03c0_app C (\u00b7 \u2208 Q\u2081) \u207b\u00b9' {a.val (op Q\u2081)} \u2287\n            \u03c0_app C (\u00b7 \u2208 Q\u2082) \u207b\u00b9' {a.val (op Q\u2082)}\n        \u00b7 intro J K h x hx\n          simp only [Set.mem_preimage, Set.mem_singleton_iff] at hx \u22a2\n          rw [\u2190 map_comp_\u03c0_app C h, Function.comp_apply,\n            hx, \u2190 a.prop (homOfLE h).op]\n          rfl\n        obtain \u27e8x, hx\u27e9 :\n            Set.Nonempty (\u22c2 (J : Finset \u03b9), \u03c0_app C (\u00b7 \u2208 J) \u207b\u00b9' {a.val (op J)}) :=\n          IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed\n            (fun J : Finset \u03b9 => \u03c0_app C (\u00b7 \u2208 J) \u207b\u00b9' {a.val (op J)}) (directed_of_sup H\u2081)\n            (fun J => (Set.singleton_nonempty _).preimage (surjective_\u03c0_app _))\n            (fun J => (hc J (a.val (op J))).isCompact) fun J => hc J (a.val (op J))\n        exact \u27e8x, Set.mem_iInter.1 hx\u27e9)", "start": [96, 1], "end": [130, 40], "kind": "commanddeclaration"}, {"full_name": "Profinite.isoindexConeLift", "code": "noncomputable\ndef isoindexConeLift [DecidableEq \u03b9] :\n    @Profinite.of C _ (by rwa [\u2190 isCompact_iff_compactSpace]) _ _ \u2245\n    (Profinite.limitCone (indexFunctor hC)).pt :=\n  asIso <| (Profinite.limitConeIsLimit _).lift (indexCone hC)", "start": [132, 1], "end": [137, 62], "kind": "commanddeclaration"}, {"full_name": "Profinite.asLimitindexConeIso", "code": "noncomputable\ndef asLimitindexConeIso [DecidableEq \u03b9] : indexCone hC \u2245 Profinite.limitCone _ :=\n  Limits.Cones.ext (isoindexConeLift hC) fun _ => rfl", "start": [139, 1], "end": [142, 54], "kind": "commanddeclaration"}, {"full_name": "Profinite.indexCone_isLimit", "code": "noncomputable\ndef indexCone_isLimit [DecidableEq \u03b9] : CategoryTheory.Limits.IsLimit (indexCone hC) :=\n  Limits.IsLimit.ofIsoLimit (Profinite.limitConeIsLimit _) (asLimitindexConeIso hC).symm", "start": [144, 1], "end": [147, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/PartialFractions.lean", "imports": ["Mathlib/Data/Polynomial/Div.lean", "Mathlib/Tactic/LinearCombination.lean", "Mathlib/RingTheory/Localization/FractionRing.lean", "Mathlib/Data/ZMod/Basic.lean", "Mathlib/Logic/Function/Basic.lean", "Mathlib/Tactic/FieldSimp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "div_eq_quo_add_rem_div_add_rem_div", "code": "theorem div_eq_quo_add_rem_div_add_rem_div (f : R[X]) {g\u2081 g\u2082 : R[X]} (hg\u2081 : g\u2081.Monic)\n    (hg\u2082 : g\u2082.Monic) (hcoprime : IsCoprime g\u2081 g\u2082) :\n    \u2203 q r\u2081 r\u2082 : R[X],\n      r\u2081.degree < g\u2081.degree \u2227\n        r\u2082.degree < g\u2082.degree \u2227 (f : K) / (\u2191g\u2081 * \u2191g\u2082) = \u2191q + \u2191r\u2081 / \u2191g\u2081 + \u2191r\u2082 / \u2191g\u2082", "start": [57, 1], "end": [80, 66], "kind": "commanddeclaration"}, {"full_name": "div_eq_quo_add_sum_rem_div", "code": "theorem div_eq_quo_add_sum_rem_div (f : R[X]) {\u03b9 : Type*} {g : \u03b9 \u2192 R[X]} {s : Finset \u03b9}\n    (hg : \u2200 i \u2208 s, (g i).Monic) (hcop : Set.Pairwise \u2191s fun i j => IsCoprime (g i) (g j)) :\n    \u2203 (q : R[X]) (r : \u03b9 \u2192 R[X]),\n      (\u2200 i \u2208 s, (r i).degree < (g i).degree) \u2227\n        ((\u2191f : K) / \u220f i in s, \u2191(g i)) = \u2191q + \u2211 i in s, (r i : K) / (g i : K)", "start": [92, 1], "end": [134, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rbtree/DefaultLt.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Combinatorics/Configuration.lean", "imports": ["Mathlib/Algebra/BigOperators/Order.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/Combinatorics/Hall/Basic.lean", "Mathlib/SetTheory/Cardinal/Finite.lean"], "premises": [{"full_name": "Configuration.Dual", "code": "def Dual :=\n  P", "start": [44, 1], "end": [46, 4], "kind": "commanddeclaration"}, {"full_name": "Configuration.Nondegenerate", "code": "class Nondegenerate : Prop where\n  exists_point : \u2200 l : L, \u2203 p, p \u2209 l\n  exists_line : \u2200 p, \u2203 l : L, p \u2209 l\n  eq_or_eq : \u2200 {p\u2081 p\u2082 : P} {l\u2081 l\u2082 : L}, p\u2081 \u2208 l\u2081 \u2192 p\u2082 \u2208 l\u2081 \u2192 p\u2081 \u2208 l\u2082 \u2192 p\u2082 \u2208 l\u2082 \u2192 p\u2081 = p\u2082 \u2228 l\u2081 = l\u2082", "start": [65, 1], "end": [74, 98], "kind": "commanddeclaration"}, {"full_name": "Configuration.HasPoints", "code": "class HasPoints extends Nondegenerate P L where\n  mkPoint : \u2200 {l\u2081 l\u2082 : L} (_ : l\u2081 \u2260 l\u2082), P\n  mkPoint_ax : \u2200 {l\u2081 l\u2082 : L} (h : l\u2081 \u2260 l\u2082), mkPoint h \u2208 l\u2081 \u2227 mkPoint h \u2208 l\u2082", "start": [77, 1], "end": [80, 76], "kind": "commanddeclaration"}, {"full_name": "Configuration.HasLines", "code": "class HasLines extends Nondegenerate P L where\n  mkLine : \u2200 {p\u2081 p\u2082 : P} (_ : p\u2081 \u2260 p\u2082), L\n  mkLine_ax : \u2200 {p\u2081 p\u2082 : P} (h : p\u2081 \u2260 p\u2082), p\u2081 \u2208 mkLine h \u2227 p\u2082 \u2208 mkLine h", "start": [83, 1], "end": [86, 73], "kind": "commanddeclaration"}, {"full_name": "Configuration.Dual.Nondegenerate", "code": "instance Dual.Nondegenerate [Nondegenerate P L] : Nondegenerate (Dual L) (Dual P) where\n  exists_point := @exists_line P L _ _\n  exists_line := @exists_point P L _ _\n  eq_or_eq := @fun l\u2081 l\u2082 p\u2081 p\u2082 h\u2081 h\u2082 h\u2083 h\u2084 => (@eq_or_eq P L _ _ p\u2081 p\u2082 l\u2081 l\u2082 h\u2081 h\u2083 h\u2082 h\u2084).symm", "start": [95, 1], "end": [98, 95], "kind": "commanddeclaration"}, {"full_name": "Configuration.Dual.hasLines", "code": "instance Dual.hasLines [HasPoints P L] : HasLines (Dual L) (Dual P) :=\n  { Dual.Nondegenerate _ _ with\n    mkLine := @mkPoint P L _ _\n    mkLine_ax := @mkPoint_ax P L _ _ }", "start": [100, 1], "end": [103, 39], "kind": "commanddeclaration"}, {"full_name": "Configuration.Dual.hasPoints", "code": "instance Dual.hasPoints [HasLines P L] : HasPoints (Dual L) (Dual P) :=\n  { Dual.Nondegenerate _ _ with\n    mkPoint := @mkLine P L _ _\n    mkPoint_ax := @mkLine_ax P L _ _ }", "start": [105, 1], "end": [108, 39], "kind": "commanddeclaration"}, {"full_name": "Configuration.HasPoints.existsUnique_point", "code": "theorem HasPoints.existsUnique_point [HasPoints P L] (l\u2081 l\u2082 : L) (hl : l\u2081 \u2260 l\u2082) :\n    \u2203! p, p \u2208 l\u2081 \u2227 p \u2208 l\u2082", "start": [110, 1], "end": [113, 79], "kind": "commanddeclaration"}, {"full_name": "Configuration.HasLines.existsUnique_line", "code": "theorem HasLines.existsUnique_line [HasLines P L] (p\u2081 p\u2082 : P) (hp : p\u2081 \u2260 p\u2082) :\n    \u2203! l : L, p\u2081 \u2208 l \u2227 p\u2082 \u2208 l", "start": [116, 1], "end": [118, 58], "kind": "commanddeclaration"}, {"full_name": "Configuration.Nondegenerate.exists_injective_of_card_le", "code": "theorem Nondegenerate.exists_injective_of_card_le [Nondegenerate P L] [Fintype P] [Fintype L]\n    (h : Fintype.card L \u2264 Fintype.card P) : \u2203 f : L \u2192 P, Function.Injective f \u2227 \u2200 l, f l \u2209 l", "start": [123, 1], "end": [166, 55], "kind": "commanddeclaration"}, {"full_name": "Configuration.lineCount", "code": "noncomputable def lineCount (p : P) : \u2115 :=\n  Nat.card { l : L // p \u2208 l }", "start": [173, 1], "end": [175, 30], "kind": "commanddeclaration"}, {"full_name": "Configuration.pointCount", "code": "noncomputable def pointCount (l : L) : \u2115 :=\n  Nat.card { p : P // p \u2208 l }", "start": [180, 1], "end": [182, 30], "kind": "commanddeclaration"}, {"full_name": "Configuration.sum_lineCount_eq_sum_pointCount", "code": "theorem sum_lineCount_eq_sum_pointCount [Fintype P] [Fintype L] :\n    \u2211 p : P, lineCount L p = \u2211 l : L, pointCount P l", "start": [188, 1], "end": [197, 96], "kind": "commanddeclaration"}, {"full_name": "Configuration.HasLines.pointCount_le_lineCount", "code": "theorem HasLines.pointCount_le_lineCount [HasLines P L] {p : P} {l : L} (h : p \u2209 l)\n    [Finite { l : L // p \u2208 l }] : pointCount P l \u2264 lineCount L p", "start": [202, 1], "end": [216, 74], "kind": "commanddeclaration"}, {"full_name": "Configuration.HasPoints.lineCount_le_pointCount", "code": "theorem HasPoints.lineCount_le_pointCount [HasPoints P L] {p : P} {l : L} (h : p \u2209 l)\n    [hf : Finite { p : P // p \u2208 l }] : lineCount L p \u2264 pointCount P l", "start": [219, 1], "end": [221, 67], "kind": "commanddeclaration"}, {"full_name": "Configuration.HasLines.card_le", "code": "theorem HasLines.card_le [HasLines P L] [Fintype P] [Fintype L] :\n    Fintype.card P \u2264 Fintype.card L", "start": [226, 1], "end": [253, 25], "kind": "commanddeclaration"}, {"full_name": "Configuration.HasPoints.card_le", "code": "theorem HasPoints.card_le [HasPoints P L] [Fintype P] [Fintype L] :\n    Fintype.card L \u2264 Fintype.card P", "start": [256, 1], "end": [259, 46], "kind": "commanddeclaration"}, {"full_name": "Configuration.HasLines.exists_bijective_of_card_eq", "code": "theorem HasLines.exists_bijective_of_card_eq [HasLines P L] [Fintype P] [Fintype L]\n    (h : Fintype.card P = Fintype.card L) :\n    \u2203 f : L \u2192 P, Function.Bijective f \u2227 \u2200 l, pointCount P l = lineCount L (f l)", "start": [264, 1], "end": [279, 38], "kind": "commanddeclaration"}, {"full_name": "Configuration.HasLines.lineCount_eq_pointCount", "code": "theorem HasLines.lineCount_eq_pointCount [HasLines P L] [Fintype P] [Fintype L]\n    (hPL : Fintype.card P = Fintype.card L) {p : P} {l : L} (hpl : p \u2209 l) :\n    lineCount L p = pointCount P l", "start": [282, 1], "end": [309, 61], "kind": "commanddeclaration"}, {"full_name": "Configuration.HasPoints.lineCount_eq_pointCount", "code": "theorem HasPoints.lineCount_eq_pointCount [HasPoints P L] [Fintype P] [Fintype L]\n    (hPL : Fintype.card P = Fintype.card L) {p : P} {l : L} (hpl : p \u2209 l) :\n    lineCount L p = pointCount P l", "start": [312, 1], "end": [315, 86], "kind": "commanddeclaration"}, {"full_name": "Configuration.HasLines.hasPoints", "code": "noncomputable def HasLines.hasPoints [HasLines P L] [Fintype P] [Fintype L]\n    (h : Fintype.card P = Fintype.card L) : HasPoints P L :=\n  let this : \u2200 l\u2081 l\u2082 : L, l\u2081 \u2260 l\u2082 \u2192 \u2203 p : P, p \u2208 l\u2081 \u2227 p \u2208 l\u2082 := fun l\u2081 l\u2082 hl => by\n    classical\n      obtain \u27e8f, _, hf2\u27e9 := HasLines.exists_bijective_of_card_eq h\n      haveI : Nontrivial L := \u27e8\u27e8l\u2081, l\u2082, hl\u27e9\u27e9\n      haveI := Fintype.one_lt_card_iff_nontrivial.mp ((congr_arg _ h).mpr Fintype.one_lt_card)\n      have h\u2081 : \u2200 p : P, 0 < lineCount L p := fun p =>\n        Exists.elim (exists_ne p) fun q hq =>\n          (congr_arg _ Nat.card_eq_fintype_card).mpr\n            (Fintype.card_pos_iff.mpr \u27e8\u27e8mkLine hq, (mkLine_ax hq).2\u27e9\u27e9)\n      have h\u2082 : \u2200 l : L, 0 < pointCount P l := fun l => (congr_arg _ (hf2 l)).mpr (h\u2081 (f l))\n      obtain \u27e8p, hl\u2081\u27e9 := Fintype.card_pos_iff.mp ((congr_arg _ Nat.card_eq_fintype_card).mp (h\u2082 l\u2081))\n      by_cases hl\u2082 : p \u2208 l\u2082\n      exact \u27e8p, hl\u2081, hl\u2082\u27e9\n      have key' : Fintype.card { q : P // q \u2208 l\u2082 } = Fintype.card { l : L // p \u2208 l } :=\n        ((HasLines.lineCount_eq_pointCount h hl\u2082).trans Nat.card_eq_fintype_card).symm.trans\n          Nat.card_eq_fintype_card\n      have : \u2200 q : { q // q \u2208 l\u2082 }, p \u2260 q := fun q hq => hl\u2082 ((congr_arg (\u00b7 \u2208 l\u2082) hq).mpr q.2)\n      let f : { q : P // q \u2208 l\u2082 } \u2192 { l : L // p \u2208 l } := fun q =>\n        \u27e8mkLine (this q), (mkLine_ax (this q)).1\u27e9\n      have hf : Function.Injective f := fun q\u2081 q\u2082 hq =>\n        Subtype.ext\n          ((eq_or_eq q\u2081.2 q\u2082.2 (mkLine_ax (this q\u2081)).2\n                ((congr_arg _ (Subtype.ext_iff.mp hq)).mpr (mkLine_ax (this q\u2082)).2)).resolve_right\n            fun h => (congr_arg (\u00acp \u2208 \u00b7) h).mp hl\u2082 (mkLine_ax (this q\u2081)).1)\n      have key' := ((Fintype.bijective_iff_injective_and_card f).mpr \u27e8hf, key'\u27e9).2\n      obtain \u27e8q, hq\u27e9 := key' \u27e8l\u2081, hl\u2081\u27e9\n      exact \u27e8q, (congr_arg _ (Subtype.ext_iff.mp hq)).mp (mkLine_ax (this q)).2, q.2\u27e9\n  { \u2039HasLines P L\u203a with\n    mkPoint := fun {l\u2081 l\u2082} hl => Classical.choose (this l\u2081 l\u2082 hl)\n    mkPoint_ax := fun {l\u2081 l\u2082} hl => Classical.choose_spec (this l\u2081 l\u2082 hl) }", "start": [318, 1], "end": [351, 76], "kind": "commanddeclaration"}, {"full_name": "Configuration.HasPoints.hasLines", "code": "noncomputable def HasPoints.hasLines [HasPoints P L] [Fintype P] [Fintype L]\n    (h : Fintype.card P = Fintype.card L) : HasLines P L :=\n  let this := @HasLines.hasPoints (Dual L) (Dual P) _ _ _ _ h.symm\n  { \u2039HasPoints P L\u203a with\n    mkLine := @fun _ _ => this.mkPoint\n    mkLine_ax := @fun _ _ => this.mkPoint_ax }", "start": [354, 1], "end": [361, 47], "kind": "commanddeclaration"}, {"full_name": "Configuration.ProjectivePlane", "code": "class ProjectivePlane extends HasPoints P L, HasLines P L where\n  exists_config :\n    \u2203 (p\u2081 p\u2082 p\u2083 : P) (l\u2081 l\u2082 l\u2083 : L),\n      p\u2081 \u2209 l\u2082 \u2227 p\u2081 \u2209 l\u2083 \u2227 p\u2082 \u2209 l\u2081 \u2227 p\u2082 \u2208 l\u2082 \u2227 p\u2082 \u2208 l\u2083 \u2227 p\u2083 \u2209 l\u2081 \u2227 p\u2083 \u2208 l\u2082 \u2227 p\u2083 \u2209 l\u2083", "start": [366, 1], "end": [372, 84], "kind": "commanddeclaration"}, {"full_name": "Configuration.ProjectivePlane.order", "code": "noncomputable def order : \u2115 :=\n  lineCount L (Classical.choose (@exists_config P L _ _)) - 1", "start": [385, 1], "end": [388, 62], "kind": "commanddeclaration"}, {"full_name": "Configuration.ProjectivePlane.card_points_eq_card_lines", "code": "theorem card_points_eq_card_lines [Fintype P] [Fintype L] : Fintype.card P = Fintype.card L", "start": [391, 1], "end": [392, 61], "kind": "commanddeclaration"}, {"full_name": "Configuration.ProjectivePlane.lineCount_eq_lineCount", "code": "theorem lineCount_eq_lineCount [Finite P] [Finite L] (p q : P) : lineCount L p = lineCount L q", "start": [398, 1], "end": [415, 54], "kind": "commanddeclaration"}, {"full_name": "Configuration.ProjectivePlane.pointCount_eq_pointCount", "code": "theorem pointCount_eq_pointCount [Finite P] [Finite L] (l m : L) :\n    pointCount P l = pointCount P m", "start": [420, 1], "end": [422, 40], "kind": "commanddeclaration"}, {"full_name": "Configuration.ProjectivePlane.lineCount_eq_pointCount", "code": "theorem lineCount_eq_pointCount [Finite P] [Finite L] (p : P) (l : L) :\n    lineCount L p = pointCount P l", "start": [428, 1], "end": [434, 80], "kind": "commanddeclaration"}, {"full_name": "Configuration.ProjectivePlane.Dual.order", "code": "theorem Dual.order [Finite P] [Finite L] : order (Dual L) (Dual P) = order P L", "start": [439, 1], "end": [440, 59], "kind": "commanddeclaration"}, {"full_name": "Configuration.ProjectivePlane.lineCount_eq", "code": "theorem lineCount_eq [Finite P] [Finite L] (p : P) : lineCount L p = order P L + 1", "start": [446, 1], "end": [452, 44], "kind": "commanddeclaration"}, {"full_name": "Configuration.ProjectivePlane.pointCount_eq", "code": "theorem pointCount_eq [Finite P] [Finite L] (l : L) : pointCount P l = order P L + 1", "start": [457, 1], "end": [458, 80], "kind": "commanddeclaration"}, {"full_name": "Configuration.ProjectivePlane.one_lt_order", "code": "theorem one_lt_order [Finite P] [Finite L] : 1 < order P L", "start": [463, 1], "end": [472, 66], "kind": "commanddeclaration"}, {"full_name": "Configuration.ProjectivePlane.two_lt_lineCount", "code": "theorem two_lt_lineCount [Finite P] [Finite L] (p : P) : 2 < lineCount L p", "start": [477, 1], "end": [478, 77], "kind": "commanddeclaration"}, {"full_name": "Configuration.ProjectivePlane.two_lt_pointCount", "code": "theorem two_lt_pointCount [Finite P] [Finite L] (l : L) : 2 < pointCount P l", "start": [483, 1], "end": [484, 78], "kind": "commanddeclaration"}, {"full_name": "Configuration.ProjectivePlane.card_points", "code": "theorem card_points [Fintype P] [Finite L] : Fintype.card P = order P L ^ 2 + order P L + 1", "start": [490, 1], "end": [516, 94], "kind": "commanddeclaration"}, {"full_name": "Configuration.ProjectivePlane.card_lines", "code": "theorem card_lines [Finite P] [Fintype L] : Fintype.card L = order P L ^ 2 + order P L + 1", "start": [519, 1], "end": [520, 94], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Tropical/BigOperators.lean", "imports": ["Mathlib/Order/ConditionallyCompleteLattice/Finset.lean", "Mathlib/Algebra/Tropical/Basic.lean", "Mathlib/Data/List/MinMax.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Basic.lean"], "premises": [{"full_name": "List.trop_sum", "code": "theorem List.trop_sum [AddMonoid R] (l : List R) : trop l.sum = List.prod (l.map trop)", "start": [42, 1], "end": [45, 16], "kind": "commanddeclaration"}, {"full_name": "Multiset.trop_sum", "code": "theorem Multiset.trop_sum [AddCommMonoid R] (s : Multiset R) :\n    trop s.sum = Multiset.prod (s.map trop)", "start": [48, 1], "end": [50, 56], "kind": "commanddeclaration"}, {"full_name": "trop_sum", "code": "theorem trop_sum [AddCommMonoid R] (s : Finset S) (f : S \u2192 R) :\n    trop (\u2211 i in s, f i) = \u220f i in s, trop (f i)", "start": [53, 1], "end": [57, 6], "kind": "commanddeclaration"}, {"full_name": "List.untrop_prod", "code": "theorem List.untrop_prod [AddMonoid R] (l : List (Tropical R)) :\n    untrop l.prod = List.sum (l.map untrop)", "start": [60, 1], "end": [64, 16], "kind": "commanddeclaration"}, {"full_name": "Multiset.untrop_prod", "code": "theorem Multiset.untrop_prod [AddCommMonoid R] (s : Multiset (Tropical R)) :\n    untrop s.prod = Multiset.sum (s.map untrop)", "start": [67, 1], "end": [69, 59], "kind": "commanddeclaration"}, {"full_name": "untrop_prod", "code": "theorem untrop_prod [AddCommMonoid R] (s : Finset S) (f : S \u2192 Tropical R) :\n    untrop (\u220f i in s, f i) = \u2211 i in s, untrop (f i)", "start": [72, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "List.trop_minimum", "code": "theorem List.trop_minimum [LinearOrder R] (l : List R) :\n    trop l.minimum = List.sum (l.map (trop \u2218 WithTop.some))", "start": [80, 1], "end": [84, 35], "kind": "commanddeclaration"}, {"full_name": "Multiset.trop_inf", "code": "theorem Multiset.trop_inf [LinearOrder R] [OrderTop R] (s : Multiset R) :\n    trop s.inf = Multiset.sum (s.map trop)", "start": [87, 1], "end": [91, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.trop_inf", "code": "theorem Finset.trop_inf [LinearOrder R] [OrderTop R] (s : Finset S) (f : S \u2192 R) :\n    trop (s.inf f) = \u2211 i in s, trop (f i)", "start": [94, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "trop_sInf_image", "code": "theorem trop_sInf_image [ConditionallyCompleteLinearOrder R] (s : Finset S) (f : S \u2192 WithTop R) :\n    trop (sInf (f '' s)) = \u2211 i in s, trop (f i)", "start": [101, 1], "end": [105, 58], "kind": "commanddeclaration"}, {"full_name": "trop_iInf", "code": "theorem trop_iInf [ConditionallyCompleteLinearOrder R] [Fintype S] (f : S \u2192 WithTop R) :\n    trop (\u2a05 i : S, f i) = \u2211 i : S, trop (f i)", "start": [108, 1], "end": [110, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.untrop_sum", "code": "theorem Multiset.untrop_sum [LinearOrder R] [OrderTop R] (s : Multiset (Tropical R)) :\n    untrop s.sum = Multiset.inf (s.map untrop)", "start": [113, 1], "end": [118, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.untrop_sum'", "code": "theorem Finset.untrop_sum' [LinearOrder R] [OrderTop R] (s : Finset S) (f : S \u2192 Tropical R) :\n    untrop (\u2211 i in s, f i) = s.inf (untrop \u2218 f)", "start": [121, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "untrop_sum_eq_sInf_image", "code": "theorem untrop_sum_eq_sInf_image [ConditionallyCompleteLinearOrder R] (s : Finset S)\n    (f : S \u2192 Tropical (WithTop R)) : untrop (\u2211 i in s, f i) = sInf (untrop \u2218 f '' s)", "start": [128, 1], "end": [132, 68], "kind": "commanddeclaration"}, {"full_name": "untrop_sum", "code": "theorem untrop_sum [ConditionallyCompleteLinearOrder R] [Fintype S] (f : S \u2192 Tropical (WithTop R)) :\n    untrop (\u2211 i : S, f i) = \u2a05 i : S, untrop (f i)", "start": [135, 1], "end": [138, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.untrop_sum", "code": "theorem Finset.untrop_sum [ConditionallyCompleteLinearOrder R] (s : Finset S)\n    (f : S \u2192 Tropical (WithTop R)) : untrop (\u2211 i in s, f i) = \u2a05 i : s, untrop (f i)", "start": [141, 1], "end": [145, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/PrimesCongruentOne.lean", "imports": ["Mathlib/RingTheory/Polynomial/Cyclotomic/Eval.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.exists_prime_gt_modEq_one", "code": "theorem exists_prime_gt_modEq_one {k : \u2115} (n : \u2115) (hk0 : k \u2260 0) :\n    \u2203 p : \u2115, Nat.Prime p \u2227 n < p \u2227 p \u2261 1 [MOD k]", "start": [24, 1], "end": [57, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.frequently_atTop_modEq_one", "code": "theorem frequently_atTop_modEq_one {k : \u2115} (hk0 : k \u2260 0) :\n    \u2203\u1da0 p in atTop, Nat.Prime p \u2227 p \u2261 1 [MOD k]", "start": [60, 1], "end": [64, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.infinite_setOf_prime_modEq_one", "code": "theorem infinite_setOf_prime_modEq_one {k : \u2115} (hk0 : k \u2260 0) :\n    Set.Infinite {p : \u2115 | Nat.Prime p \u2227 p \u2261 1 [MOD k]}", "start": [67, 1], "end": [70, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/FreeAbelianGroupFinsupp.lean", "imports": ["Mathlib/Data/Finsupp/Defs.lean", "Mathlib/Algebra/Module/Equiv.lean", "Mathlib/LinearAlgebra/Dimension.lean", "Mathlib/Algebra/Hom/Equiv/TypeTags.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/FreeGroup/IsFreeGroup.lean", "Mathlib/GroupTheory/FreeAbelianGroup.lean"], "premises": [{"full_name": "FreeAbelianGroup.toFinsupp", "code": "def FreeAbelianGroup.toFinsupp : FreeAbelianGroup X \u2192+ X \u2192\u2080 \u2124 :=\n  FreeAbelianGroup.lift fun x => Finsupp.single x (1 : \u2124)", "start": [36, 1], "end": [38, 58], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toFreeAbelianGroup", "code": "def Finsupp.toFreeAbelianGroup : (X \u2192\u2080 \u2124) \u2192+ FreeAbelianGroup X :=\n  Finsupp.liftAddHom fun x => (smulAddHom \u2124 (FreeAbelianGroup X)).flip (FreeAbelianGroup.of x)", "start": [41, 1], "end": [43, 95], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toFreeAbelianGroup_comp_singleAddHom", "code": "@[simp]\ntheorem Finsupp.toFreeAbelianGroup_comp_singleAddHom (x : X) :\n    Finsupp.toFreeAbelianGroup.comp (Finsupp.singleAddHom x) =\n      (smulAddHom \u2124 (FreeAbelianGroup X)).flip (of x)", "start": [48, 1], "end": [54, 57], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.toFinsupp_comp_toFreeAbelianGroup", "code": "@[simp]\ntheorem FreeAbelianGroup.toFinsupp_comp_toFreeAbelianGroup :\n    toFinsupp.comp toFreeAbelianGroup = AddMonoidHom.id (X \u2192\u2080 \u2124)", "start": [57, 1], "end": [63, 89], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toFreeAbelianGroup_comp_toFinsupp", "code": "@[simp]\ntheorem Finsupp.toFreeAbelianGroup_comp_toFinsupp :\n    toFreeAbelianGroup.comp toFinsupp = AddMonoidHom.id (FreeAbelianGroup X)", "start": [66, 1], "end": [72, 27], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toFreeAbelianGroup_toFinsupp", "code": "@[simp]\ntheorem Finsupp.toFreeAbelianGroup_toFinsupp {X} (x : FreeAbelianGroup X) :\n    Finsupp.toFreeAbelianGroup (FreeAbelianGroup.toFinsupp x) = x", "start": [75, 1], "end": [78, 99], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.toFinsupp_of", "code": "@[simp]\ntheorem toFinsupp_of (x : X) : toFinsupp (of x) = Finsupp.single x 1", "start": [85, 1], "end": [87, 33], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.toFinsupp_toFreeAbelianGroup", "code": "@[simp]\ntheorem toFinsupp_toFreeAbelianGroup (f : X \u2192\u2080 \u2124) :\n    FreeAbelianGroup.toFinsupp (Finsupp.toFreeAbelianGroup f) = f", "start": [90, 1], "end": [93, 91], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.equivFinsupp", "code": "@[simps!]\ndef equivFinsupp : FreeAbelianGroup X \u2243+ (X \u2192\u2080 \u2124) where\n  toFun := toFinsupp\n  invFun := toFreeAbelianGroup\n  left_inv := toFreeAbelianGroup_toFinsupp\n  right_inv := toFinsupp_toFreeAbelianGroup\n  map_add' := toFinsupp.map_add", "start": [98, 1], "end": [105, 32], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.basis", "code": "noncomputable def basis (\u03b1 : Type*) : Basis \u03b1 \u2124 (FreeAbelianGroup \u03b1) :=\n  \u27e8(FreeAbelianGroup.equivFinsupp \u03b1).toIntLinearEquiv\u27e9", "start": [108, 1], "end": [110, 55], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.Equiv.ofFreeAbelianGroupLinearEquiv", "code": "def Equiv.ofFreeAbelianGroupLinearEquiv {\u03b1 \u03b2 : Type*}\n    (e : FreeAbelianGroup \u03b1 \u2243\u2097[\u2124] FreeAbelianGroup \u03b2) : \u03b1 \u2243 \u03b2 :=\n  let t : Basis \u03b1 \u2124 (FreeAbelianGroup \u03b2) := (FreeAbelianGroup.basis \u03b1).map e\n  t.indexEquiv <| FreeAbelianGroup.basis _", "start": [113, 1], "end": [117, 43], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.Equiv.ofFreeAbelianGroupEquiv", "code": "def Equiv.ofFreeAbelianGroupEquiv {\u03b1 \u03b2 : Type*} (e : FreeAbelianGroup \u03b1 \u2243+ FreeAbelianGroup \u03b2) :\n    \u03b1 \u2243 \u03b2 :=\n  Equiv.ofFreeAbelianGroupLinearEquiv e.toIntLinearEquiv", "start": [120, 1], "end": [123, 57], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.Equiv.ofFreeGroupEquiv", "code": "def Equiv.ofFreeGroupEquiv {\u03b1 \u03b2 : Type*} (e : FreeGroup \u03b1 \u2243* FreeGroup \u03b2) : \u03b1 \u2243 \u03b2 :=\n  Equiv.ofFreeAbelianGroupEquiv (MulEquiv.toAdditive e.abelianizationCongr)", "start": [126, 1], "end": [128, 76], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.Equiv.ofIsFreeGroupEquiv", "code": "def Equiv.ofIsFreeGroupEquiv {G H : Type*} [Group G] [Group H] [IsFreeGroup G] [IsFreeGroup H]\n    (e : G \u2243* H) : Generators G \u2243 Generators H :=\n  Equiv.ofFreeGroupEquiv <| MulEquiv.trans (toFreeGroup G).symm <| MulEquiv.trans e <| toFreeGroup H", "start": [133, 1], "end": [136, 101], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.coeff", "code": "def coeff (x : X) : FreeAbelianGroup X \u2192+ \u2124 :=\n  (Finsupp.applyAddHom x).comp toFinsupp", "start": [141, 1], "end": [144, 41], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.support", "code": "def support (a : FreeAbelianGroup X) : Finset X :=\n  a.toFinsupp.support", "start": [147, 1], "end": [150, 22], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.mem_support_iff", "code": "theorem mem_support_iff (x : X) (a : FreeAbelianGroup X) : x \u2208 a.support \u2194 coeff x a \u2260 0", "start": [153, 1], "end": [155, 16], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.not_mem_support_iff", "code": "theorem not_mem_support_iff (x : X) (a : FreeAbelianGroup X) : x \u2209 a.support \u2194 coeff x a = 0", "start": [158, 1], "end": [160, 16], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.support_zero", "code": "@[simp]\ntheorem support_zero : support (0 : FreeAbelianGroup X) = \u2205", "start": [163, 1], "end": [165, 67], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.support_of", "code": "@[simp]\ntheorem support_of (x : X) : support (of x) = {x}", "start": [168, 1], "end": [170, 75], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.support_neg", "code": "@[simp]\ntheorem support_neg (a : FreeAbelianGroup X) : support (-a) = support a", "start": [173, 1], "end": [175, 65], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.support_zsmul", "code": "@[simp]\ntheorem support_zsmul (k : \u2124) (h : k \u2260 0) (a : FreeAbelianGroup X) :\n    support (k \u2022 a) = support a", "start": [178, 1], "end": [183, 66], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.support_nsmul", "code": "@[simp]\ntheorem support_nsmul (k : \u2115) (h : k \u2260 0) (a : FreeAbelianGroup X) :\n    support (k \u2022 a) = support a", "start": [186, 1], "end": [190, 19], "kind": "commanddeclaration"}, {"full_name": "FreeAbelianGroup.support_add", "code": "theorem support_add (a b : FreeAbelianGroup X) : support (a + b) \u2286 a.support \u222a b.support", "start": [195, 1], "end": [197, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Rayleigh.lean", "imports": ["Mathlib/Data/Real/ConjugateExponents.lean", "Mathlib/Data/Real/Irrational.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "beattySeq", "code": "noncomputable def beattySeq (r : \u211d) : \u2124 \u2192 \u2124 :=\n  fun k \u21a6 \u230ak * r\u230b", "start": [48, 1], "end": [50, 18], "kind": "commanddeclaration"}, {"full_name": "beattySeq'", "code": "noncomputable def beattySeq' (r : \u211d) : \u2124 \u2192 \u2124 :=\n  fun k \u21a6 \u2308k * r\u2309 - 1", "start": [52, 1], "end": [54, 22], "kind": "commanddeclaration"}, {"full_name": "Beatty.no_collision", "code": "private theorem no_collision : Disjoint {beattySeq r k | k} {beattySeq' s k | k}", "start": [60, 1], "end": [73, 21], "kind": "commanddeclaration"}, {"full_name": "Beatty.no_anticollision", "code": "private theorem no_anticollision :\n    \u00ac\u2203 j k m : \u2124, k < j / r \u2227 (j + 1) / r \u2264 k + 1 \u2227 m \u2264 j / s \u2227 (j + 1) / s < m + 1", "start": [75, 1], "end": [85, 21], "kind": "commanddeclaration"}, {"full_name": "Beatty.hit_or_miss", "code": "private theorem hit_or_miss (h : r > 0) :\n    j \u2208 {beattySeq r k | k} \u2228 \u2203 k : \u2124, k < j / r \u2227 (j + 1) / r \u2264 k + 1", "start": [87, 1], "end": [97, 39], "kind": "commanddeclaration"}, {"full_name": "Beatty.hit_or_miss'", "code": "private theorem hit_or_miss' (h : r > 0) :\n    j \u2208 {beattySeq' r k | k} \u2228 \u2203 k : \u2124, k \u2264 j / r \u2227 (j + 1) / r < k + 1", "start": [99, 1], "end": [109, 68], "kind": "commanddeclaration"}, {"full_name": "compl_beattySeq", "code": "theorem compl_beattySeq {r s : \u211d} (hrs : r.IsConjugateExponent s) :\n    {beattySeq r k | k}\u1d9c = {beattySeq' s k | k}", "start": [113, 1], "end": [124, 75], "kind": "commanddeclaration"}, {"full_name": "compl_beattySeq'", "code": "theorem compl_beattySeq' {r s : \u211d} (hrs : r.IsConjugateExponent s) :\n    {beattySeq' r k | k}\u1d9c = {beattySeq s k | k}", "start": [126, 1], "end": [128, 47], "kind": "commanddeclaration"}, {"full_name": "beattySeq_symmDiff_beattySeq'_pos", "code": "theorem beattySeq_symmDiff_beattySeq'_pos {r s : \u211d} (hrs : r.IsConjugateExponent s) :\n    {beattySeq r k | k > 0} \u2206 {beattySeq' s k | k > 0} = {n | 0 < n}", "start": [130, 1], "end": [153, 15], "kind": "commanddeclaration"}, {"full_name": "beattySeq'_symmDiff_beattySeq_pos", "code": "theorem beattySeq'_symmDiff_beattySeq_pos {r s : \u211d} (hrs : r.IsConjugateExponent s) :\n    {beattySeq' r k | k > 0} \u2206 {beattySeq s k | k > 0} = {n | 0 < n}", "start": [155, 1], "end": [157, 65], "kind": "commanddeclaration"}, {"full_name": "Irrational.beattySeq'_pos_eq", "code": "theorem Irrational.beattySeq'_pos_eq {r : \u211d} (hr : Irrational r) :\n    {beattySeq' r k | k > 0} = {beattySeq r k | k > 0}", "start": [159, 1], "end": [166, 50], "kind": "commanddeclaration"}, {"full_name": "Irrational.beattySeq_symmDiff_beattySeq_pos", "code": "theorem Irrational.beattySeq_symmDiff_beattySeq_pos {r s : \u211d}\n    (hrs : r.IsConjugateExponent s) (hr : Irrational r) :\n    {beattySeq r k | k > 0} \u2206 {beattySeq s k | k > 0} = {n | 0 < n}", "start": [168, 1], "end": [173, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Divisibility/Prod.lean", "imports": ["Mathlib/Algebra/Divisibility/Basic.lean", "Mathlib/Algebra/Group/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "prod_dvd_iff", "code": "theorem prod_dvd_iff {x y : G\u2081 \u00d7 G\u2082} :\n    x \u2223 y \u2194 x.1 \u2223 y.1 \u2227 x.2 \u2223 y.2", "start": [16, 1], "end": [20, 59], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_dvd_mk", "code": "@[simp]\ntheorem Prod.mk_dvd_mk {x\u2081 y\u2081 : G\u2081} {x\u2082 y\u2082 : G\u2082} :\n    (x\u2081, x\u2082) \u2223 (y\u2081, y\u2082) \u2194 x\u2081 \u2223 y\u2081 \u2227 x\u2082 \u2223 y\u2082", "start": [22, 1], "end": [25, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/PNat/Xgcd.lean", "imports": ["Mathlib/Tactic/Ring.lean", "Mathlib/Data/PNat/Prime.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PNat.XgcdType", "code": "structure XgcdType where\n  \n  wp : \u2115\n  \n  x : \u2115\n  \n  y : \u2115\n  \n  zp : \u2115\n  \n  ap : \u2115\n  \n  bp : \u2115\n  deriving Inhabited", "start": [41, 1], "end": [59, 21], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.mk'", "code": "def mk' (w : \u2115+) (x : \u2115) (y : \u2115) (z : \u2115+) (a : \u2115+) (b : \u2115+) : XgcdType :=\n  mk w.val.pred x y z.val.pred a.val.pred b.val.pred", "start": [77, 1], "end": [79, 53], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.w", "code": "def w : \u2115+ :=\n  succPNat u.wp", "start": [82, 1], "end": [84, 16], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.z", "code": "def z : \u2115+ :=\n  succPNat u.zp", "start": [87, 1], "end": [89, 16], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.a", "code": "def a : \u2115+ :=\n  succPNat u.ap", "start": [92, 1], "end": [94, 16], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.b", "code": "def b : \u2115+ :=\n  succPNat u.bp", "start": [97, 1], "end": [99, 16], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.r", "code": "def r : \u2115 :=\n  (u.ap + 1) % (u.bp + 1)", "start": [102, 1], "end": [104, 26], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.q", "code": "def q : \u2115 :=\n  (u.ap + 1) / (u.bp + 1)", "start": [107, 1], "end": [109, 26], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.qp", "code": "def qp : \u2115 :=\n  u.q - 1", "start": [112, 1], "end": [114, 10], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.vp", "code": "def vp : \u2115 \u00d7 \u2115 :=\n  \u27e8u.wp + u.x + u.ap + u.wp * u.ap + u.x * u.bp, u.y + u.zp + u.bp + u.y * u.ap + u.zp * u.bp\u27e9", "start": [117, 1], "end": [123, 95], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.v", "code": "def v : \u2115 \u00d7 \u2115 :=\n  \u27e8u.w * u.a + u.x * u.b, u.y * u.a + u.z * u.b\u27e9", "start": [126, 1], "end": [128, 49], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.succ\u2082", "code": "def succ\u2082 (t : \u2115 \u00d7 \u2115) : \u2115 \u00d7 \u2115 :=\n  \u27e8t.1.succ, t.2.succ\u27e9", "start": [131, 1], "end": [133, 23], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.v_eq_succ_vp", "code": "theorem v_eq_succ_vp : u.v = succ\u2082 u.vp", "start": [136, 1], "end": [137, 91], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.IsSpecial", "code": "def IsSpecial : Prop :=\n  u.wp + u.zp + u.wp * u.zp = u.x * u.y", "start": [140, 1], "end": [142, 40], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.IsSpecial'", "code": "def IsSpecial' : Prop :=\n  u.w * u.z = succPNat (u.x * u.y)", "start": [145, 1], "end": [147, 35], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.isSpecial_iff", "code": "theorem isSpecial_iff : u.IsSpecial \u2194 u.IsSpecial'", "start": [150, 1], "end": [156, 95], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.IsReduced", "code": "def IsReduced : Prop :=\n  u.ap = u.bp", "start": [160, 1], "end": [165, 14], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.IsReduced'", "code": "def IsReduced' : Prop :=\n  u.a = u.b", "start": [168, 1], "end": [170, 12], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.isReduced_iff", "code": "theorem isReduced_iff : u.IsReduced \u2194 u.IsReduced'", "start": [173, 1], "end": [174, 20], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.flip", "code": "def flip : XgcdType where\n  wp := u.zp\n  x := u.y\n  y := u.x\n  zp := u.wp\n  ap := u.bp\n  bp := u.ap", "start": [177, 1], "end": [184, 13], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.flip_w", "code": "@[simp]\ntheorem flip_w : (flip u).w = u.z", "start": [187, 1], "end": [189, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.flip_x", "code": "@[simp]\ntheorem flip_x : (flip u).x = u.y", "start": [192, 1], "end": [194, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.flip_y", "code": "@[simp]\ntheorem flip_y : (flip u).y = u.x", "start": [197, 1], "end": [199, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.flip_z", "code": "@[simp]\ntheorem flip_z : (flip u).z = u.w", "start": [202, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.flip_a", "code": "@[simp]\ntheorem flip_a : (flip u).a = u.b", "start": [207, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.flip_b", "code": "@[simp]\ntheorem flip_b : (flip u).b = u.a", "start": [212, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.flip_isReduced", "code": "theorem flip_isReduced : (flip u).IsReduced \u2194 u.IsReduced", "start": [217, 1], "end": [219, 43], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.flip_isSpecial", "code": "theorem flip_isSpecial : (flip u).IsSpecial \u2194 u.IsSpecial", "start": [222, 1], "end": [224, 50], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.flip_v", "code": "theorem flip_v : (flip u).v = u.v.swap", "start": [227, 1], "end": [233, 9], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.rq_eq", "code": "theorem rq_eq : u.r + (u.bp + 1) * u.q = u.ap + 1", "start": [236, 1], "end": [238, 40], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.qp_eq", "code": "theorem qp_eq (hr : u.r = 0) : u.q = u.qp + 1", "start": [241, 1], "end": [246, 65], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.start", "code": "def start (a b : \u2115+) : XgcdType :=\n  \u27e80, 0, 0, 0, a - 1, b - 1\u27e9", "start": [249, 1], "end": [255, 29], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.start_isSpecial", "code": "theorem start_isSpecial (a b : \u2115+) : (start a b).IsSpecial", "start": [258, 1], "end": [259, 27], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.start_v", "code": "theorem start_v (a b : \u2115+) : (start a b).v = \u27e8a, b\u27e9", "start": [262, 1], "end": [267, 68], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.finish", "code": "def finish : XgcdType :=\n  XgcdType.mk u.wp ((u.wp + 1) * u.qp + u.x) u.y (u.y * u.qp + u.zp) u.bp u.bp", "start": [270, 1], "end": [272, 79], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.finish_isReduced", "code": "theorem finish_isReduced : u.finish.IsReduced", "start": [275, 1], "end": [277, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.finish_isSpecial", "code": "theorem finish_isSpecial (hs : u.IsSpecial) : u.finish.IsSpecial", "start": [280, 1], "end": [283, 7], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.finish_v", "code": "theorem finish_v (hr : u.r = 0) : u.finish.v = u.v", "start": [286, 1], "end": [296, 9], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.step", "code": "def step : XgcdType :=\n  XgcdType.mk (u.y * u.q + u.zp) u.y ((u.wp + 1) * u.q + u.x) u.wp u.bp (u.r - 1)", "start": [299, 1], "end": [302, 82], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.step_wf", "code": "theorem step_wf (hr : u.r \u2260 0) : SizeOf.sizeOf u.step < SizeOf.sizeOf u", "start": [305, 1], "end": [312, 30], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.step_isSpecial", "code": "theorem step_isSpecial (hs : u.IsSpecial) : u.step.IsSpecial", "start": [315, 1], "end": [318, 7], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.step_v", "code": "theorem step_v (hr : u.r \u2260 0) : u.step.v = u.v.swap", "start": [321, 1], "end": [331, 9], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.reduce", "code": "def reduce (u : XgcdType) : XgcdType :=\n  dite (u.r = 0) (fun _ => u.finish) fun _h =>\n    flip (reduce u.step)\ndecreasing_by apply u.step_wf _h", "start": [335, 1], "end": [345, 33], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.reduce_a", "code": "theorem reduce_a {u : XgcdType} (h : u.r = 0) : u.reduce = u.finish", "start": [348, 1], "end": [350, 17], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.reduce_b", "code": "theorem reduce_b {u : XgcdType} (h : u.r \u2260 0) : u.reduce = u.step.reduce.flip", "start": [353, 1], "end": [355, 17], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.reduce_isReduced", "code": "theorem reduce_isReduced : \u2200 u : XgcdType, u.reduce.IsReduced", "start": [358, 1], "end": [367, 29], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.reduce_isReduced'", "code": "theorem reduce_isReduced' (u : XgcdType) : u.reduce.IsReduced'", "start": [370, 1], "end": [371, 42], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.reduce_isSpecial", "code": "theorem reduce_isSpecial : \u2200 u : XgcdType, u.IsSpecial \u2192 u.reduce.IsSpecial", "start": [374, 1], "end": [383, 78], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.reduce_isSpecial'", "code": "theorem reduce_isSpecial' (u : XgcdType) (hs : u.IsSpecial) : u.reduce.IsSpecial'", "start": [386, 1], "end": [387, 47], "kind": "commanddeclaration"}, {"full_name": "PNat.XgcdType.reduce_v", "code": "theorem reduce_v : \u2200 u : XgcdType, u.reduce.v = u.v", "start": [390, 1], "end": [394, 77], "kind": "commanddeclaration"}, {"full_name": "PNat.xgcd", "code": "def xgcd : XgcdType :=\n  (XgcdType.start a b).reduce", "start": [403, 1], "end": [405, 30], "kind": "commanddeclaration"}, {"full_name": "PNat.gcdD", "code": "def gcdD : \u2115+ :=\n  (xgcd a b).a", "start": [408, 1], "end": [410, 15], "kind": "commanddeclaration"}, {"full_name": "PNat.gcdW", "code": "def gcdW : \u2115+ :=\n  (xgcd a b).w", "start": [413, 1], "end": [415, 15], "kind": "commanddeclaration"}, {"full_name": "PNat.gcdX", "code": "def gcdX : \u2115 :=\n  (xgcd a b).x", "start": [418, 1], "end": [420, 15], "kind": "commanddeclaration"}, {"full_name": "PNat.gcdY", "code": "def gcdY : \u2115 :=\n  (xgcd a b).y", "start": [423, 1], "end": [425, 15], "kind": "commanddeclaration"}, {"full_name": "PNat.gcdZ", "code": "def gcdZ : \u2115+ :=\n  (xgcd a b).z", "start": [428, 1], "end": [430, 15], "kind": "commanddeclaration"}, {"full_name": "PNat.gcdA'", "code": "def gcdA' : \u2115+ :=\n  succPNat ((xgcd a b).wp + (xgcd a b).x)", "start": [433, 1], "end": [435, 42], "kind": "commanddeclaration"}, {"full_name": "PNat.gcdB'", "code": "def gcdB' : \u2115+ :=\n  succPNat ((xgcd a b).y + (xgcd a b).zp)", "start": [438, 1], "end": [440, 42], "kind": "commanddeclaration"}, {"full_name": "PNat.gcdA'_coe", "code": "theorem gcdA'_coe : (gcdA' a b : \u2115) = gcdW a b + gcdX a b", "start": [443, 1], "end": [445, 64], "kind": "commanddeclaration"}, {"full_name": "PNat.gcdB'_coe", "code": "theorem gcdB'_coe : (gcdB' a b : \u2115) = gcdY a b + gcdZ a b", "start": [448, 1], "end": [450, 59], "kind": "commanddeclaration"}, {"full_name": "PNat.gcd_props", "code": "theorem gcd_props :\n    let d := gcdD a b\n    let w := gcdW a b\n    let x := gcdX a b\n    let y := gcdY a b\n    let z := gcdZ a b\n    let a' := gcdA' a b\n    let b' := gcdB' a b\n    w * z = succPNat (x * y) \u2227\n      a = a' * d \u2227\n        b = b' * d \u2227\n          z * a' = succPNat (x * b') \u2227\n            w * b' = succPNat (y * a') \u2227 (z * a : \u2115) = x * b + d \u2227 (w * b : \u2115) = y * a + d", "start": [453, 1], "end": [503, 23], "kind": "commanddeclaration"}, {"full_name": "PNat.gcd_eq", "code": "theorem gcd_eq : gcdD a b = gcd a b", "start": [506, 1], "end": [516, 44], "kind": "commanddeclaration"}, {"full_name": "PNat.gcd_det_eq", "code": "theorem gcd_det_eq : gcdW a b * gcdZ a b = succPNat (gcdX a b * gcdY a b)", "start": [519, 1], "end": [520, 20], "kind": "commanddeclaration"}, {"full_name": "PNat.gcd_a_eq", "code": "theorem gcd_a_eq : a = gcdA' a b * gcd a b", "start": [523, 1], "end": [524, 35], "kind": "commanddeclaration"}, {"full_name": "PNat.gcd_b_eq", "code": "theorem gcd_b_eq : b = gcdB' a b * gcd a b", "start": [527, 1], "end": [528, 37], "kind": "commanddeclaration"}, {"full_name": "PNat.gcd_rel_left'", "code": "theorem gcd_rel_left' : gcdZ a b * gcdA' a b = succPNat (gcdX a b * gcdB' a b)", "start": [531, 1], "end": [532, 26], "kind": "commanddeclaration"}, {"full_name": "PNat.gcd_rel_right'", "code": "theorem gcd_rel_right' : gcdW a b * gcdB' a b = succPNat (gcdY a b * gcdA' a b)", "start": [535, 1], "end": [536, 28], "kind": "commanddeclaration"}, {"full_name": "PNat.gcd_rel_left", "code": "theorem gcd_rel_left : (gcdZ a b * a : \u2115) = gcdX a b * b + gcd a b", "start": [539, 1], "end": [540, 43], "kind": "commanddeclaration"}, {"full_name": "PNat.gcd_rel_right", "code": "theorem gcd_rel_right : (gcdW a b * b : \u2115) = gcdY a b * a + gcd a b", "start": [543, 1], "end": [544, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Sheaves/Operations.lean", "imports": ["Mathlib/Algebra/Category/Ring/FilteredColimits.lean", "Mathlib/Algebra/Category/Ring/Instances.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Sheaves/Stalks.lean", "Mathlib/RingTheory/Localization/Basic.lean"], "premises": [{"full_name": "TopCat.Presheaf.SubmonoidPresheaf", "code": "structure SubmonoidPresheaf [\u2200 X : C, MulOneClass X] [\u2200 X Y : C, MonoidHomClass (X \u27f6 Y) X Y]\n    (F : X.Presheaf C) where\n  obj : \u2200 U, Submonoid (F.obj U)\n  map : \u2200 {U V : (Opens X)\u1d52\u1d56} (i : U \u27f6 V), obj U \u2264 (obj V).comap (F.map i)", "start": [42, 1], "end": [46, 75], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SubmonoidPresheaf.localizationPresheaf", "code": "protected noncomputable def SubmonoidPresheaf.localizationPresheaf : X.Presheaf CommRingCat where\n  obj U := CommRingCat.of <| Localization (G.obj U)\n  map {U V} i := CommRingCat.ofHom <| IsLocalization.map _ (F.map i) (G.map i)\n  map_id U := by\n    simp_rw [F.map_id]\n    ext x\n    exact IsLocalization.map_id (M := G.obj U) (S := Localization (G.obj U)) x\n  map_comp {U V W} i j := by\n    delta CommRingCat.ofHom CommRingCat.of Bundled.of\n    simp_rw [F.map_comp, CommRingCat.comp_eq_ring_hom_comp]\n    rw [IsLocalization.map_comp_map]", "start": [51, 1], "end": [63, 37], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SubmonoidPresheaf.toLocalizationPresheaf", "code": "@[simps app]\ndef SubmonoidPresheaf.toLocalizationPresheaf : F \u27f6 G.localizationPresheaf where\n  app U := CommRingCat.ofHom <| algebraMap (F.obj U) (Localization <| G.obj U)\n  naturality {_ _} i := (IsLocalization.map_comp (G.map i)).symm", "start": [74, 1], "end": [78, 65], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.epi_toLocalizationPresheaf", "code": "instance epi_toLocalizationPresheaf : Epi G.toLocalizationPresheaf :=\n  @NatTrans.epi_of_epi_app _ _ _ _ _ _ G.toLocalizationPresheaf fun U => Localization.epi' (G.obj U)", "start": [81, 1], "end": [82, 101], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.submonoidPresheafOfStalk", "code": "@[simps]\nnoncomputable def submonoidPresheafOfStalk (S : \u2200 x : X, Submonoid (F.stalk x)) :\n    F.SubmonoidPresheaf where\n  obj U := \u2a05 x : U.unop, Submonoid.comap (F.germ x) (S x)\n  map {U V} i := by\n    intro s hs\n    simp only [Submonoid.mem_comap, Submonoid.mem_iInf] at hs \u22a2\n    intro x\n    change (F.map i.unop.op \u226b F.germ x) s \u2208 _\n    rw [F.germ_res]\n    exact hs _", "start": [86, 1], "end": [98, 15], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.totalQuotientPresheaf", "code": "noncomputable def totalQuotientPresheaf : X.Presheaf CommRingCat.{w} :=\n  (F.submonoidPresheafOfStalk fun x => (F.stalk x)\u2070).localizationPresheaf", "start": [104, 1], "end": [106, 74], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.toTotalQuotientPresheaf", "code": "noncomputable def toTotalQuotientPresheaf : F \u27f6 F.totalQuotientPresheaf :=\n  SubmonoidPresheaf.toLocalizationPresheaf _", "start": [109, 1], "end": [111, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/AssertNoSorry.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Print.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/NumberTheory/LucasPrimality.lean", "imports": ["Mathlib/GroupTheory/OrderOfElement.lean", "Mathlib/Data/Nat/Totient.lean", "Mathlib/Tactic/Zify.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/Basic.lean"], "premises": [{"full_name": "lucas_primality", "code": "theorem lucas_primality (p : \u2115) (a : ZMod p) (ha : a ^ (p - 1) = 1)\n    (hd : \u2200 q : \u2115, q.Prime \u2192 q \u2223 p - 1 \u2192 a ^ ((p - 1) / q) \u2260 1) : p.Prime", "start": [38, 1], "end": [63, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Etale.lean", "imports": ["Mathlib/RingTheory/QuotientNilpotent.lean", "Mathlib/RingTheory/Kaehler.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Algebra.FormallyUnramified", "code": "@[mk_iff]\nclass FormallyUnramified : Prop where\n  comp_injective :\n    \u2200 \u2983B : Type u\u2984 [CommRing B],\n      \u2200 [Algebra R B] (I : Ideal B) (_ : I ^ 2 = \u22a5),\n        Function.Injective ((Ideal.Quotient.mk\u2090 R I).comp : (A \u2192\u2090[R] B) \u2192 A \u2192\u2090[R] B \u29f8 I)", "start": [40, 1], "end": [47, 89], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth", "code": "@[mk_iff]\nclass FormallySmooth : Prop where\n  comp_surjective :\n    \u2200 \u2983B : Type u\u2984 [CommRing B],\n      \u2200 [Algebra R B] (I : Ideal B) (_ : I ^ 2 = \u22a5),\n        Function.Surjective ((Ideal.Quotient.mk\u2090 R I).comp : (A \u2192\u2090[R] B) \u2192 A \u2192\u2090[R] B \u29f8 I)", "start": [50, 1], "end": [57, 90], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyEtale", "code": "@[mk_iff]\nclass FormallyEtale : Prop where\n  comp_bijective :\n    \u2200 \u2983B : Type u\u2984 [CommRing B],\n      \u2200 [Algebra R B] (I : Ideal B) (_ : I ^ 2 = \u22a5),\n        Function.Bijective ((Ideal.Quotient.mk\u2090 R I).comp : (A \u2192\u2090[R] B) \u2192 A \u2192\u2090[R] B \u29f8 I)", "start": [60, 1], "end": [67, 89], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyEtale.iff_unramified_and_smooth", "code": "theorem FormallyEtale.iff_unramified_and_smooth :\n    FormallyEtale R A \u2194 FormallyUnramified R A \u2227 FormallySmooth R A", "start": [72, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyEtale.to_unramified", "code": "instance (priority := 100) FormallyEtale.to_unramified [h : FormallyEtale R A] :\n    FormallyUnramified R A :=\n  (FormallyEtale.iff_unramified_and_smooth.mp h).1", "start": [79, 1], "end": [81, 51], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyEtale.to_smooth", "code": "instance (priority := 100) FormallyEtale.to_smooth [h : FormallyEtale R A] : FormallySmooth R A :=\n  (FormallyEtale.iff_unramified_and_smooth.mp h).2", "start": [84, 1], "end": [85, 51], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyEtale.of_unramified_and_smooth", "code": "theorem FormallyEtale.of_unramified_and_smooth [h\u2081 : FormallyUnramified R A]\n    [h\u2082 : FormallySmooth R A] : FormallyEtale R A", "start": [88, 1], "end": [90, 55], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyUnramified.lift_unique", "code": "theorem FormallyUnramified.lift_unique {B : Type u} [CommRing B] [_RB : Algebra R B]\n    [FormallyUnramified R A] (I : Ideal B) (hI : IsNilpotent I) (g\u2081 g\u2082 : A \u2192\u2090[R] B)\n    (h : (Ideal.Quotient.mk\u2090 R I).comp g\u2081 = (Ideal.Quotient.mk\u2090 R I).comp g\u2082) : g\u2081 = g\u2082", "start": [93, 1], "end": [107, 92], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyUnramified.ext", "code": "theorem FormallyUnramified.ext [FormallyUnramified R A] (hI : IsNilpotent I) {g\u2081 g\u2082 : A \u2192\u2090[R] B}\n    (H : \u2200 x, Ideal.Quotient.mk I (g\u2081 x) = Ideal.Quotient.mk I (g\u2082 x)) : g\u2081 = g\u2082", "start": [110, 1], "end": [112, 59], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyUnramified.lift_unique_of_ringHom", "code": "theorem FormallyUnramified.lift_unique_of_ringHom [FormallyUnramified R A] {C : Type u} [CommRing C]\n    (f : B \u2192+* C) (hf : IsNilpotent <| RingHom.ker f) (g\u2081 g\u2082 : A \u2192\u2090[R] B)\n    (h : f.comp \u2191g\u2081 = f.comp (g\u2082 : A \u2192+* B)) : g\u2081 = g\u2082", "start": [115, 1], "end": [123, 48], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyUnramified.ext'", "code": "theorem FormallyUnramified.ext' [FormallyUnramified R A] {C : Type u} [CommRing C] (f : B \u2192+* C)\n    (hf : IsNilpotent <| RingHom.ker f) (g\u2081 g\u2082 : A \u2192\u2090[R] B) (h : \u2200 x, f (g\u2081 x) = f (g\u2082 x)) :\n    g\u2081 = g\u2082", "start": [126, 1], "end": [129, 71], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyUnramified.lift_unique'", "code": "theorem FormallyUnramified.lift_unique' [FormallyUnramified R A] {C : Type u} [CommRing C]\n    [Algebra R C] (f : B \u2192\u2090[R] C) (hf : IsNilpotent <| RingHom.ker (f : B \u2192+* C))\n    (g\u2081 g\u2082 : A \u2192\u2090[R] B) (h : f.comp g\u2081 = f.comp g\u2082) : g\u2081 = g\u2082", "start": [132, 1], "end": [135, 58], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.exists_lift", "code": "theorem FormallySmooth.exists_lift {B : Type u} [CommRing B] [_RB : Algebra R B]\n    [FormallySmooth R A] (I : Ideal B) (hI : IsNilpotent I) (g : A \u2192\u2090[R] B \u29f8 I) :\n    \u2203 f : A \u2192\u2090[R] B, (Ideal.Quotient.mk\u2090 R I).comp f = g", "start": [138, 1], "end": [158, 18], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.lift", "code": "noncomputable def FormallySmooth.lift [FormallySmooth R A] (I : Ideal B) (hI : IsNilpotent I)\n    (g : A \u2192\u2090[R] B \u29f8 I) : A \u2192\u2090[R] B :=\n  (FormallySmooth.exists_lift I hI g).choose", "start": [161, 1], "end": [165, 45], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.comp_lift", "code": "@[simp]\ntheorem FormallySmooth.comp_lift [FormallySmooth R A] (I : Ideal B) (hI : IsNilpotent I)\n    (g : A \u2192\u2090[R] B \u29f8 I) : (Ideal.Quotient.mk\u2090 R I).comp (FormallySmooth.lift I hI g) = g", "start": [168, 1], "end": [171, 50], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.mk_lift", "code": "@[simp]\ntheorem FormallySmooth.mk_lift [FormallySmooth R A] (I : Ideal B) (hI : IsNilpotent I)\n    (g : A \u2192\u2090[R] B \u29f8 I) (x : A) : Ideal.Quotient.mk I (FormallySmooth.lift I hI g x) = g x", "start": [174, 1], "end": [177, 59], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.liftOfSurjective", "code": "noncomputable def FormallySmooth.liftOfSurjective [FormallySmooth R A] (f : A \u2192\u2090[R] C)\n    (g : B \u2192\u2090[R] C) (hg : Function.Surjective g) (hg' : IsNilpotent <| RingHom.ker (g : B \u2192+* C)) :\n    A \u2192\u2090[R] B :=\n  FormallySmooth.lift _ hg' ((Ideal.quotientKerAlgEquivOfSurjective hg).symm.toAlgHom.comp f)", "start": [182, 1], "end": [187, 94], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.liftOfSurjective_apply", "code": "@[simp]\ntheorem FormallySmooth.liftOfSurjective_apply [FormallySmooth R A] (f : A \u2192\u2090[R] C) (g : B \u2192\u2090[R] C)\n    (hg : Function.Surjective g) (hg' : IsNilpotent <| RingHom.ker (g : B \u2192+* C)) (x : A) :\n    g (FormallySmooth.liftOfSurjective f g hg hg' x) = f x", "start": [190, 1], "end": [202, 39], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.comp_liftOfSurjective", "code": "@[simp]\ntheorem FormallySmooth.comp_liftOfSurjective [FormallySmooth R A] (f : A \u2192\u2090[R] C) (g : B \u2192\u2090[R] C)\n    (hg : Function.Surjective g) (hg' : IsNilpotent <| RingHom.ker (g : B \u2192+* C)) :\n    g.comp (FormallySmooth.liftOfSurjective f g hg hg') = f", "start": [205, 1], "end": [209, 64], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.of_equiv", "code": "theorem FormallySmooth.of_equiv [FormallySmooth R A] (e : A \u2243\u2090[R] B) : FormallySmooth R B", "start": [220, 1], "end": [225, 20], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyUnramified.of_equiv", "code": "theorem FormallyUnramified.of_equiv [FormallyUnramified R A] (e : A \u2243\u2090[R] B) :\n    FormallyUnramified R B", "start": [228, 1], "end": [235, 50], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyEtale.of_equiv", "code": "theorem FormallyEtale.of_equiv [FormallyEtale R A] (e : A \u2243\u2090[R] B) : FormallyEtale R B", "start": [238, 1], "end": [240, 63], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.mvPolynomial", "code": "instance FormallySmooth.mvPolynomial (\u03c3 : Type u) : FormallySmooth R (MvPolynomial \u03c3 R) := by\n  constructor\n  intro C _ _ I _ f\n  have : \u2200 s : \u03c3, \u2203 c : C, Ideal.Quotient.mk I c = f (MvPolynomial.X s) := fun s =>\n    Ideal.Quotient.mk_surjective _\n  choose g hg using this\n  refine' \u27e8MvPolynomial.aeval g, _\u27e9\n  ext s\n  rw [\u2190 hg, AlgHom.comp_apply, MvPolynomial.aeval_X]\n  rfl", "start": [251, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.polynomial", "code": "instance FormallySmooth.polynomial : FormallySmooth R R[X] :=\n  @FormallySmooth.of_equiv _ _ _ _ _ _ _ _ (FormallySmooth.mvPolynomial R PUnit)\n    (MvPolynomial.pUnitAlgEquiv R)", "start": [263, 1], "end": [266, 35], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.comp", "code": "theorem FormallySmooth.comp [FormallySmooth R A] [FormallySmooth A B] : FormallySmooth R B", "start": [279, 1], "end": [287, 68], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyUnramified.comp", "code": "theorem FormallyUnramified.comp [FormallyUnramified R A] [FormallyUnramified A B] :\n    FormallyUnramified R B", "start": [290, 1], "end": [303, 62], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyUnramified.of_comp", "code": "theorem FormallyUnramified.of_comp [FormallyUnramified R B] : FormallyUnramified A B", "start": [306, 1], "end": [314, 30], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyEtale.comp", "code": "theorem FormallyEtale.comp [FormallyEtale R A] [FormallyEtale A B] : FormallyEtale R B", "start": [317, 1], "end": [319, 63], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.of_split", "code": "theorem FormallySmooth.of_split [FormallySmooth R P] (g : A \u2192\u2090[R] P \u29f8 (RingHom.ker f.toRingHom) ^ 2)\n    (hg : f.kerSquareLift.comp g = AlgHom.id R A) : FormallySmooth R A", "start": [332, 1], "end": [350, 95], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.iff_split_surjection", "code": "theorem FormallySmooth.iff_split_surjection [FormallySmooth R P] :\n    FormallySmooth R A \u2194 \u2203 g, f.kerSquareLift.comp g = AlgHom.id R A", "start": [353, 1], "end": [388, 57], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyUnramified.subsingleton_kaehlerDifferential", "code": "instance FormallyUnramified.subsingleton_kaehlerDifferential [FormallyUnramified R S] :\n    Subsingleton (\u03a9[S\u2044R]) := by\n  rw [\u2190 not_nontrivial_iff_subsingleton]\n  intro h\n  obtain \u27e8f\u2081, f\u2082, e\u27e9 := (KaehlerDifferential.endEquiv R S).injective.nontrivial\n  apply e\n  ext1\n  apply FormallyUnramified.lift_unique' _ _ _ _ (f\u2081.2.trans f\u2082.2.symm)\n  rw [\u2190 AlgHom.toRingHom_eq_coe, AlgHom.ker_kerSquareLift]\n  exact \u27e8_, Ideal.cotangentIdeal_square _\u27e9", "start": [399, 1], "end": [408, 43], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyUnramified.iff_subsingleton_kaehlerDifferential", "code": "theorem FormallyUnramified.iff_subsingleton_kaehlerDifferential :\n    FormallyUnramified R S \u2194 Subsingleton (\u03a9[S\u2044R])", "start": [411, 1], "end": [423, 80], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyUnramified.base_change", "code": "instance FormallyUnramified.base_change [FormallyUnramified R A] :\n    FormallyUnramified B (B \u2297[R] A) := by\n  constructor\n  intro C _ _ I hI f\u2081 f\u2082 e\n  letI := ((algebraMap B C).comp (algebraMap R B)).toAlgebra\n  haveI : IsScalarTower R B C := IsScalarTower.of_algebraMap_eq' rfl\n  ext : 1\n  \u00b7 exact Subsingleton.elim _ _\n  \u00b7 exact FormallyUnramified.ext I \u27e82, hI\u27e9 fun x => AlgHom.congr_fun e (1 \u2297\u209c x)", "start": [438, 1], "end": [446, 80], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.base_change", "code": "instance FormallySmooth.base_change [FormallySmooth R A] : FormallySmooth B (B \u2297[R] A) := by\n  constructor\n  intro C _ _ I hI f\n  letI := ((algebraMap B C).comp (algebraMap R B)).toAlgebra\n  haveI : IsScalarTower R B C := IsScalarTower.of_algebraMap_eq' rfl\n  refine' \u27e8TensorProduct.productLeftAlgHom (Algebra.ofId B C) _, _\u27e9\n  \u00b7 exact FormallySmooth.lift I \u27e82, hI\u27e9 ((f.restrictScalars R).comp TensorProduct.includeRight)\n  \u00b7 apply AlgHom.restrictScalars_injective R\n    apply TensorProduct.ext'\n    intro b a\n    suffices algebraMap B _ b * f (1 \u2297\u209c[R] a) = f (b \u2297\u209c[R] a) by simpa [Algebra.ofId_apply]\n    rw [\u2190 Algebra.smul_def, \u2190 map_smul, TensorProduct.smul_tmul', smul_eq_mul, mul_one]", "start": [449, 1], "end": [460, 88], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyEtale.base_change", "code": "instance FormallyEtale.base_change [FormallyEtale R A] : FormallyEtale B (B \u2297[R] A) :=\n  FormallyEtale.iff_unramified_and_smooth.mpr \u27e8inferInstance, inferInstance\u27e9", "start": [463, 1], "end": [464, 77], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.of_isLocalization", "code": "theorem FormallySmooth.of_isLocalization : FormallySmooth R R\u2098", "start": [484, 1], "end": [498, 7], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyUnramified.of_isLocalization", "code": "theorem FormallyUnramified.of_isLocalization : FormallyUnramified R R\u2098", "start": [501, 1], "end": [508, 7], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyEtale.of_isLocalization", "code": "theorem FormallyEtale.of_isLocalization : FormallyEtale R R\u2098", "start": [511, 1], "end": [513, 81], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.localization_base", "code": "theorem FormallySmooth.localization_base [FormallySmooth R S\u2098] : FormallySmooth R\u2098 S\u2098", "start": [516, 1], "end": [535, 7], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyUnramified.localization_base", "code": "theorem FormallyUnramified.localization_base [FormallyUnramified R S\u2098] : FormallyUnramified R\u2098 S\u2098", "start": [538, 1], "end": [547, 37], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyEtale.localization_base", "code": "theorem FormallyEtale.localization_base [FormallyEtale R S\u2098] : FormallyEtale R\u2098 S\u2098", "start": [550, 1], "end": [552, 81], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallySmooth.localization_map", "code": "theorem FormallySmooth.localization_map [FormallySmooth R S] : FormallySmooth R\u2098 S\u2098", "start": [555, 1], "end": [558, 43], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyUnramified.localization_map", "code": "theorem FormallyUnramified.localization_map [FormallyUnramified R S] :\n    FormallyUnramified R\u2098 S\u2098", "start": [561, 1], "end": [566, 47], "kind": "commanddeclaration"}, {"full_name": "Algebra.FormallyEtale.localization_map", "code": "theorem FormallyEtale.localization_map [FormallyEtale R S] : FormallyEtale R\u2098 S\u2098", "start": [569, 1], "end": [572, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Density.lean", "imports": ["Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean", "Mathlib/MeasureTheory/Measure/Haar/OfBasis.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.HasPDF", "code": "class HasPDF {m : MeasurableSpace \u03a9} (X : \u03a9 \u2192 E) (\u2119 : Measure \u03a9)\n    (\u03bc : Measure E := by volume_tac) : Prop where\n  pdf' : Measurable X \u2227 \u2203 f : E \u2192 \u211d\u22650\u221e, Measurable f \u2227 map X \u2119 = \u03bc.withDensity f", "start": [64, 1], "end": [70, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.HasPDF.measurable", "code": "@[measurability]\ntheorem HasPDF.measurable {_ : MeasurableSpace \u03a9} (X : \u03a9 \u2192 E) (\u2119 : Measure \u03a9)\n    (\u03bc : Measure E := by volume_tac) [hX : HasPDF X \u2119 \u03bc] :\n    Measurable X", "start": [73, 1], "end": [77, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf", "code": "def pdf {_ : MeasurableSpace \u03a9} (X : \u03a9 \u2192 E) (\u2119 : Measure \u03a9) (\u03bc : Measure E := by volume_tac) :\n    E \u2192 \u211d\u22650\u221e :=\n  if hX : HasPDF X \u2119 \u03bc then Classical.choose hX.pdf'.2 else 0", "start": [80, 1], "end": [84, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf_undef", "code": "theorem pdf_undef {m : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E}\n    (h : \u00acHasPDF X \u2119 \u03bc) : pdf X \u2119 \u03bc = 0", "start": [87, 1], "end": [88, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.hasPDF_of_pdf_ne_zero", "code": "theorem hasPDF_of_pdf_ne_zero {m : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9} {\u03bc : Measure E} {X : \u03a9 \u2192 E}\n    (h : pdf X \u2119 \u03bc \u2260 0) : HasPDF X \u2119 \u03bc", "start": [91, 1], "end": [94, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf_eq_zero_of_not_measurable", "code": "theorem pdf_eq_zero_of_not_measurable {_ : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9} {\u03bc : Measure E}\n    {X : \u03a9 \u2192 E} (hX : \u00acMeasurable X) : pdf X \u2119 \u03bc = 0", "start": [97, 1], "end": [99, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measurable_of_pdf_ne_zero", "code": "theorem measurable_of_pdf_ne_zero {m : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9} {\u03bc : Measure E}\n    (X : \u03a9 \u2192 E) (h : pdf X \u2119 \u03bc \u2260 0) : Measurable X", "start": [102, 1], "end": [105, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measurable_pdf", "code": "@[measurability]\ntheorem measurable_pdf {m : MeasurableSpace \u03a9} (X : \u03a9 \u2192 E) (\u2119 : Measure \u03a9)\n    (\u03bc : Measure E := by volume_tac) : Measurable (pdf X \u2119 \u03bc)", "start": [108, 1], "end": [113, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.map_eq_withDensity_pdf", "code": "theorem map_eq_withDensity_pdf {m : MeasurableSpace \u03a9} (X : \u03a9 \u2192 E) (\u2119 : Measure \u03a9)\n    (\u03bc : Measure E := by volume_tac) [hX : HasPDF X \u2119 \u03bc] :\n    Measure.map X \u2119 = \u03bc.withDensity (pdf X \u2119 \u03bc)", "start": [116, 1], "end": [120, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.map_eq_set_lintegral_pdf", "code": "theorem map_eq_set_lintegral_pdf {m : MeasurableSpace \u03a9} (X : \u03a9 \u2192 E) (\u2119 : Measure \u03a9)\n    (\u03bc : Measure E := by volume_tac) [hX : HasPDF X \u2119 \u03bc] {s : Set E}\n    (hs : MeasurableSet s) : Measure.map X \u2119 s = \u222b\u207b x in s, pdf X \u2119 \u03bc x \u2202\u03bc", "start": [123, 1], "end": [126, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.lintegral_eq_measure_univ", "code": "theorem lintegral_eq_measure_univ {X : \u03a9 \u2192 E} [HasPDF X \u2119 \u03bc] :\n    \u222b\u207b x, pdf X \u2119 \u03bc x \u2202\u03bc = \u2119 Set.univ", "start": [133, 1], "end": [136, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.ae_lt_top", "code": "nonrec theorem ae_lt_top [IsFiniteMeasure \u2119] {\u03bc : Measure E} {X : \u03a9 \u2192 E} :\n    \u2200\u1d50 x \u2202\u03bc, pdf X \u2119 \u03bc x < \u221e", "start": [139, 1], "end": [146, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.ofReal_toReal_ae_eq", "code": "nonrec theorem ofReal_toReal_ae_eq [IsFiniteMeasure \u2119] {X : \u03a9 \u2192 E} :\n    (fun x => ENNReal.ofReal (pdf X \u2119 \u03bc x).toReal) =\u1d50[\u03bc] pdf X \u2119 \u03bc", "start": [149, 1], "end": [151, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.integrable_iff_integrable_mul_pdf", "code": "theorem integrable_iff_integrable_mul_pdf [IsFiniteMeasure \u2119] {X : \u03a9 \u2192 E} [HasPDF X \u2119 \u03bc] {f : E \u2192 \u211d}\n    (hf : Measurable f) :\n    Integrable (fun x => f (X x)) \u2119 \u2194 Integrable (fun x => f x * (pdf X \u2119 \u03bc x).toReal) \u03bc", "start": [154, 1], "end": [160, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.integral_fun_mul_eq_integral", "code": "theorem integral_fun_mul_eq_integral [IsFiniteMeasure \u2119] {X : \u03a9 \u2192 E} [HasPDF X \u2119 \u03bc] {f : E \u2192 \u211d}\n    (hf : Measurable f) : \u222b x, f x * (pdf X \u2119 \u03bc x).toReal \u2202\u03bc = \u222b x, f (X x) \u2202\u2119", "start": [163, 1], "end": [201, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.map_absolutelyContinuous", "code": "theorem map_absolutelyContinuous {X : \u03a9 \u2192 E} [HasPDF X \u2119 \u03bc] : map X \u2119 \u226a \u03bc", "start": [204, 1], "end": [205, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.to_quasiMeasurePreserving", "code": "theorem to_quasiMeasurePreserving {X : \u03a9 \u2192 E} [HasPDF X \u2119 \u03bc] : QuasiMeasurePreserving X \u2119 \u03bc", "start": [208, 1], "end": [211, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.haveLebesgueDecomposition_of_hasPDF", "code": "theorem haveLebesgueDecomposition_of_hasPDF {X : \u03a9 \u2192 E} [hX' : HasPDF X \u2119 \u03bc] :\n    (map X \u2119).HaveLebesgueDecomposition \u03bc", "start": [214, 1], "end": [218, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.hasPDF_iff", "code": "theorem hasPDF_iff {X : \u03a9 \u2192 E} :\n    HasPDF X \u2119 \u03bc \u2194 Measurable X \u2227 (map X \u2119).HaveLebesgueDecomposition \u03bc \u2227 map X \u2119 \u226a \u03bc", "start": [221, 1], "end": [229, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.hasPDF_iff_of_measurable", "code": "theorem hasPDF_iff_of_measurable {X : \u03a9 \u2192 E} (hX : Measurable X) :\n    HasPDF X \u2119 \u03bc \u2194 (map X \u2119).HaveLebesgueDecomposition \u03bc \u2227 map X \u2119 \u226a \u03bc", "start": [232, 1], "end": [235, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.quasiMeasurePreserving_hasPDF", "code": "theorem quasiMeasurePreserving_hasPDF {X : \u03a9 \u2192 E} [HasPDF X \u2119 \u03bc] {g : E \u2192 F}\n    (hg : QuasiMeasurePreserving g \u03bc \u03bd) (hmap : (map g (map X \u2119)).HaveLebesgueDecomposition \u03bd) :\n    HasPDF (g \u2218 X) \u2119 \u03bd", "start": [242, 1], "end": [257, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.quasiMeasurePreserving_hasPDF'", "code": "theorem quasiMeasurePreserving_hasPDF' [IsFiniteMeasure \u2119] [SigmaFinite \u03bd] {X : \u03a9 \u2192 E}\n    [HasPDF X \u2119 \u03bc] {g : E \u2192 F} (hg : QuasiMeasurePreserving g \u03bc \u03bd) : HasPDF (g \u2218 X) \u2119 \u03bd", "start": [260, 1], "end": [262, 49], "kind": "commanddeclaration"}, {"full_name": "Real.hasPDF_iff_of_measurable", "code": "nonrec theorem _root_.Real.hasPDF_iff_of_measurable (hX : Measurable X) :\n    HasPDF X \u2119 \u2194 map X \u2119 \u226a volume", "start": [271, 1], "end": [276, 36], "kind": "commanddeclaration"}, {"full_name": "Real.hasPDF_iff", "code": "theorem _root_.Real.hasPDF_iff : HasPDF X \u2119 \u2194 Measurable X \u2227 map X \u2119 \u226a volume", "start": [279, 1], "end": [283, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.integral_mul_eq_integral", "code": "theorem integral_mul_eq_integral [HasPDF X \u2119] : \u222b x, x * (pdf X \u2119 volume x).toReal = \u222b x, X x \u2202\u2119", "start": [286, 1], "end": [289, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.hasFiniteIntegral_mul", "code": "theorem hasFiniteIntegral_mul {f : \u211d \u2192 \u211d} {g : \u211d \u2192 \u211d\u22650\u221e} (hg : pdf X \u2119 =\u1d50[volume] g)\n    (hgi : \u222b\u207b x, \u2016f x\u2016\u208a * g x \u2260 \u221e) :\n    HasFiniteIntegral fun x => f x * (pdf X \u2119 volume x).toReal", "start": [292, 1], "end": [302, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.IsUniform", "code": "def IsUniform {_ : MeasurableSpace \u03a9} (X : \u03a9 \u2192 E) (support : Set E) (\u2119 : Measure \u03a9)\n    (\u03bc : Measure E := by volume_tac) :=\n  pdf X \u2119 \u03bc =\u1d50[\u03bc] support.indicator ((\u03bc support)\u207b\u00b9 \u2022 (1 : E \u2192 \u211d\u22650\u221e))", "start": [311, 1], "end": [315, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.IsUniform.hasPDF", "code": "theorem hasPDF {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 E} {\u2119 : Measure \u03a9} {\u03bc : Measure E} {s : Set E}\n    (hns : \u03bc s \u2260 0) (hnt : \u03bc s \u2260 \u221e) (hu : IsUniform X s \u2119 \u03bc) : HasPDF X \u2119 \u03bc", "start": [320, 1], "end": [333, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.IsUniform.pdf_toReal_ae_eq", "code": "theorem pdf_toReal_ae_eq {_ : MeasurableSpace \u03a9} {X : \u03a9 \u2192 E} {\u2119 : Measure \u03a9} {\u03bc : Measure E}\n    {s : Set E} (hX : IsUniform X s \u2119 \u03bc) :\n    (fun x => (pdf X \u2119 \u03bc x).toReal) =\u1d50[\u03bc] fun x =>\n      (s.indicator ((\u03bc s)\u207b\u00b9 \u2022 (1 : E \u2192 \u211d\u22650\u221e)) x).toReal", "start": [336, 1], "end": [340, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.IsUniform.measure_preimage", "code": "theorem measure_preimage {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 E} {\u2119 : Measure \u03a9} {\u03bc : Measure E}\n    {s : Set E} (hns : \u03bc s \u2260 0) (hnt : \u03bc s \u2260 \u221e) (hms : MeasurableSet s) (hu : IsUniform X s \u2119 \u03bc)\n    {A : Set E} (hA : MeasurableSet A) : \u2119 (X \u207b\u00b9' A) = \u03bc (s \u2229 A) / \u03bc s", "start": [343, 1], "end": [351, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.IsUniform.isProbabilityMeasure", "code": "theorem isProbabilityMeasure {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 E} {\u2119 : Measure \u03a9} {\u03bc : Measure E}\n    {s : Set E} (hns : \u03bc s \u2260 0) (hnt : \u03bc s \u2260 \u221e) (hms : MeasurableSet s) (hu : IsUniform X s \u2119 \u03bc) :\n    IsProbabilityMeasure \u2119", "start": [354, 1], "end": [360, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.IsUniform.mul_pdf_integrable", "code": "theorem mul_pdf_integrable [IsFiniteMeasure \u2119] (hcs : IsCompact s) (huX : IsUniform X s \u2119) :\n    Integrable fun x : \u211d => x * (pdf X \u2119 volume x).toReal", "start": [365, 1], "end": [386, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.pdf.IsUniform.integral_eq", "code": "theorem integral_eq (hnt : volume s \u2260 \u221e) (huX : IsUniform X s \u2119) :\n    \u222b x, X x \u2202\u2119 = (volume s)\u207b\u00b9.toReal * \u222b x in s, x", "start": [389, 1], "end": [407, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/TensorAlgebra/ToTensorPower.lean", "imports": ["Mathlib/LinearAlgebra/TensorPower.lean", "Mathlib/LinearAlgebra/TensorAlgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TensorPower.toTensorAlgebra", "code": "def toTensorAlgebra {n} : (\u2a02[R]^n) M \u2192\u2097[R] TensorAlgebra R M :=\n  PiTensorProduct.lift (TensorAlgebra.tprod R M n)", "start": [26, 1], "end": [28, 51], "kind": "commanddeclaration"}, {"full_name": "TensorPower.toTensorAlgebra_tprod", "code": "@[simp]\ntheorem toTensorAlgebra_tprod {n} (x : Fin n \u2192 M) :\n    TensorPower.toTensorAlgebra (PiTensorProduct.tprod R x) = TensorAlgebra.tprod R M n x", "start": [31, 1], "end": [34, 31], "kind": "commanddeclaration"}, {"full_name": "TensorPower.toTensorAlgebra_gOne", "code": "@[simp]\ntheorem toTensorAlgebra_gOne :\n    TensorPower.toTensorAlgebra (@GradedMonoid.GOne.one _ (fun n => (\u2a02[R]^n) M) _ _) = 1", "start": [37, 1], "end": [40, 38], "kind": "commanddeclaration"}, {"full_name": "TensorPower.toTensorAlgebra_gMul", "code": "@[simp]\ntheorem toTensorAlgebra_gMul {i j} (a : (\u2a02[R]^i) M) (b : (\u2a02[R]^j) M) :\n    TensorPower.toTensorAlgebra (@GradedMonoid.GMul.mul _ (fun n => (\u2a02[R]^n) M) _ _ _ _ a b) =\n      TensorPower.toTensorAlgebra a * TensorPower.toTensorAlgebra b", "start": [43, 1], "end": [65, 82], "kind": "commanddeclaration"}, {"full_name": "TensorPower.toTensorAlgebra_galgebra_toFun", "code": "@[simp]\ntheorem toTensorAlgebra_galgebra_toFun (r : R) :\n    TensorPower.toTensorAlgebra (DirectSum.GAlgebra.toFun (R := R) (A := fun n => (\u2a02[R]^n) M) r) =\n      algebraMap _ _ r", "start": [68, 1], "end": [73, 70], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.ofDirectSum", "code": "def ofDirectSum : (\u2a01 n, (\u2a02[R]^n) M) \u2192\u2090[R] TensorAlgebra R M :=\n  DirectSum.toAlgebra _ _ (fun _ => TensorPower.toTensorAlgebra) TensorPower.toTensorAlgebra_gOne\n    (fun {_ _} => TensorPower.toTensorAlgebra_gMul)", "start": [80, 1], "end": [83, 52], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.ofDirectSum_of_tprod", "code": "@[simp]\ntheorem ofDirectSum_of_tprod {n} (x : Fin n \u2192 M) :\n    ofDirectSum (DirectSum.of _ n (PiTensorProduct.tprod R x)) = tprod R M n x", "start": [86, 1], "end": [91, 40], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.toDirectSum", "code": "def toDirectSum : TensorAlgebra R M \u2192\u2090[R] \u2a01 n, (\u2a02[R]^n) M :=\n  TensorAlgebra.lift R <|\n    DirectSum.lof R \u2115 (fun n => (\u2a02[R]^n) M) _ \u2218\u2097\n      (LinearEquiv.symm <| PiTensorProduct.subsingletonEquiv (0 : Fin 1) : M \u2243\u2097[R] _).toLinearMap", "start": [94, 1], "end": [98, 98], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.toDirectSum_\u03b9", "code": "@[simp]\ntheorem toDirectSum_\u03b9 (x : M) :\n    toDirectSum (\u03b9 R x) =\n      DirectSum.of (fun n => (\u2a02[R]^n) M) _ (PiTensorProduct.tprod R fun _ : Fin 1 => x)", "start": [101, 1], "end": [105, 33], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.ofDirectSum_comp_toDirectSum", "code": "theorem ofDirectSum_comp_toDirectSum :\n    ofDirectSum.comp toDirectSum = AlgHom.id R (TensorAlgebra R M)", "start": [108, 1], "end": [111, 42], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.ofDirectSum_toDirectSum", "code": "@[simp]\ntheorem ofDirectSum_toDirectSum (x : TensorAlgebra R M) :\n    ofDirectSum (TensorAlgebra.toDirectSum x) = x", "start": [114, 1], "end": [117, 50], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.mk_reindex_cast", "code": "@[simp]\ntheorem mk_reindex_cast {n m : \u2115} (h : n = m) (x : (\u2a02[R]^n) M) :\n    GradedMonoid.mk (A := fun i => (\u2a02[R]^i) M) m\n    (PiTensorProduct.reindex R M (Equiv.cast <| congr_arg Fin h) x) =\n    GradedMonoid.mk n x", "start": [120, 1], "end": [125, 66], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.mk_reindex_fin_cast", "code": "@[simp]\ntheorem mk_reindex_fin_cast {n m : \u2115} (h : n = m) (x : (\u2a02[R]^n) M) :\n    GradedMonoid.mk (A := fun i => (\u2a02[R]^i) M) m\n    (PiTensorProduct.reindex R M (Fin.castIso h).toEquiv x) = GradedMonoid.mk n x", "start": [128, 1], "end": [132, 50], "kind": "commanddeclaration"}, {"full_name": "TensorPower.list_prod_gradedMonoid_mk_single", "code": "theorem _root_.TensorPower.list_prod_gradedMonoid_mk_single (n : \u2115) (x : Fin n \u2192 M) :\n    ((List.finRange n).map fun a =>\n          (GradedMonoid.mk _ (PiTensorProduct.tprod R fun _ : Fin 1 => x a) :\n            GradedMonoid fun n => (\u2a02[R]^n) M)).prod =\n      GradedMonoid.mk n (PiTensorProduct.tprod R x)", "start": [135, 1], "end": [153, 19], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.toDirectSum_tensorPower_tprod", "code": "theorem toDirectSum_tensorPower_tprod {n} (x : Fin n \u2192 M) :\n    toDirectSum (tprod R M n x) = DirectSum.of _ n (PiTensorProduct.tprod R x)", "start": [156, 1], "end": [163, 52], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.toDirectSum_comp_ofDirectSum", "code": "theorem toDirectSum_comp_ofDirectSum :\n    toDirectSum.comp ofDirectSum = AlgHom.id R (\u2a01 n, (\u2a02[R]^n) M)", "start": [166, 1], "end": [169, 74], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.toDirectSum_ofDirectSum", "code": "@[simp]\ntheorem toDirectSum_ofDirectSum (x : \u2a01 n, (\u2a02[R]^n) M) :\n    TensorAlgebra.toDirectSum (ofDirectSum x) = x", "start": [172, 1], "end": [175, 50], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.equivDirectSum", "code": "@[simps!]\ndef equivDirectSum : TensorAlgebra R M \u2243\u2090[R] \u2a01 n, (\u2a02[R]^n) M :=\n  AlgEquiv.ofAlgHom toDirectSum ofDirectSum toDirectSum_comp_ofDirectSum\n    ofDirectSum_comp_toDirectSum", "start": [178, 1], "end": [182, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Triangle/Basic.lean", "imports": ["Mathlib/Tactic/GCongr.lean", "Mathlib/Combinatorics/SimpleGraph/Clique.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.FarFromTriangleFree", "code": "def FarFromTriangleFree (G : SimpleGraph \u03b1) (\u03b5 : \ud835\udd5c) : Prop :=\n  (G.DeleteFar fun H => H.CliqueFree 3) <| \u03b5 * (card \u03b1 ^ 2 : \u2115)", "start": [39, 1], "end": [42, 64], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.farFromTriangleFree_iff", "code": "theorem farFromTriangleFree_iff : G.FarFromTriangleFree \u03b5 \u2194 \u2200 \u2983H\u2984, H \u2264 G \u2192 H.CliqueFree 3 \u2192\n    \u03b5 * (card \u03b1 ^ 2 : \u2115) \u2264 G.edgeFinset.card - H.edgeFinset.card", "start": [45, 1], "end": [46, 82], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.farFromTriangleFree.le_card_sub_card", "code": "alias \u27e8farFromTriangleFree.le_card_sub_card, _\u27e9 := farFromTriangleFree_iff", "start": [49, 1], "end": [49, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SimpleGraph.FarFromTriangleFree.mono", "code": "nonrec theorem FarFromTriangleFree.mono (h\u03b5 : G.FarFromTriangleFree \u03b5) (h : \u03b4 \u2264 \u03b5) :\n    G.FarFromTriangleFree \u03b4", "start": [52, 1], "end": [53, 52], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.FarFromTriangleFree.cliqueFinset_nonempty'", "code": "theorem FarFromTriangleFree.cliqueFinset_nonempty' (hH : H \u2264 G) (hG : G.FarFromTriangleFree \u03b5)\n    (hcard : (G.edgeFinset.card - H.edgeFinset.card : \ud835\udd5c) < \u03b5 * (card \u03b1 ^ 2 : \u2115)) :\n    (H.cliqueFinset 3).Nonempty", "start": [56, 1], "end": [60, 91], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.FarFromTriangleFree.nonpos", "code": "theorem FarFromTriangleFree.nonpos (h\u2080 : G.FarFromTriangleFree \u03b5) (h\u2081 : G.CliqueFree 3) :\n    \u03b5 \u2264 0", "start": [65, 1], "end": [69, 91], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.CliqueFree.not_farFromTriangleFree", "code": "theorem CliqueFree.not_farFromTriangleFree (hG : G.CliqueFree 3) (h\u03b5 : 0 < \u03b5) :\n    \u00acG.FarFromTriangleFree \u03b5", "start": [72, 1], "end": [73, 65], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.FarFromTriangleFree.not_cliqueFree", "code": "theorem FarFromTriangleFree.not_cliqueFree (hG : G.FarFromTriangleFree \u03b5) (h\u03b5 : 0 < \u03b5) :\n    \u00acG.CliqueFree 3", "start": [76, 1], "end": [77, 56], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.FarFromTriangleFree.cliqueFinset_nonempty", "code": "theorem FarFromTriangleFree.cliqueFinset_nonempty (hG : G.FarFromTriangleFree \u03b5) (h\u03b5 : 0 < \u03b5) :\n    (G.cliqueFinset 3).Nonempty", "start": [80, 1], "end": [82, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/QPF/Univariate/Basic.lean", "imports": ["Mathlib/Data/PFunctor/Univariate/M.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "QPF", "code": "class QPF (F : Type u \u2192 Type u) [Functor F] where\n  P : PFunctor.{u}\n  abs : \u2200 {\u03b1}, P \u03b1 \u2192 F \u03b1\n  repr : \u2200 {\u03b1}, F \u03b1 \u2192 P \u03b1\n  abs_repr : \u2200 {\u03b1} (x : F \u03b1), abs (repr x) = x\n  abs_map : \u2200 {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (p : P \u03b1), abs (f <$> p) = f <$> abs p", "start": [45, 1], "end": [56, 71], "kind": "commanddeclaration"}, {"full_name": "QPF.id_map", "code": "theorem id_map {\u03b1 : Type _} (x : F \u03b1) : id <$> x = x", "start": [71, 1], "end": [75, 6], "kind": "commanddeclaration"}, {"full_name": "QPF.comp_map", "code": "theorem comp_map {\u03b1 \u03b2 \u03b3 : Type _} (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) (x : F \u03b1) :\n    (g \u2218 f) <$> x = g <$> f <$> x", "start": [78, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "QPF.lawfulFunctor", "code": "theorem lawfulFunctor\n    (h : \u2200 \u03b1 \u03b2 : Type u, @Functor.mapConst F _ \u03b1 _ = Functor.map \u2218 Function.const \u03b2) :\n    LawfulFunctor F", "start": [86, 1], "end": [91, 34], "kind": "commanddeclaration"}, {"full_name": "QPF.liftp_iff", "code": "theorem liftp_iff {\u03b1 : Type u} (p : \u03b1 \u2192 Prop) (x : F \u03b1) :\n    Liftp p x \u2194 \u2203 a f, x = abs \u27e8a, f\u27e9 \u2227 \u2200 i, p (f i)", "start": [101, 1], "end": [114, 26], "kind": "commanddeclaration"}, {"full_name": "QPF.liftp_iff'", "code": "theorem liftp_iff' {\u03b1 : Type u} (p : \u03b1 \u2192 Prop) (x : F \u03b1) :\n    Liftp p x \u2194 \u2203 u : q.P \u03b1, abs u = x \u2227 \u2200 i, p (u.snd i)", "start": [117, 1], "end": [131, 28], "kind": "commanddeclaration"}, {"full_name": "QPF.liftr_iff", "code": "theorem liftr_iff {\u03b1 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (x y : F \u03b1) :\n    Liftr r x y \u2194 \u2203 a f\u2080 f\u2081, x = abs \u27e8a, f\u2080\u27e9 \u2227 y = abs \u27e8a, f\u2081\u27e9 \u2227 \u2200 i, r (f\u2080 i) (f\u2081 i)", "start": [134, 1], "end": [153, 27], "kind": "commanddeclaration"}, {"full_name": "QPF.recF", "code": "def recF {\u03b1 : Type _} (g : F \u03b1 \u2192 \u03b1) : q.P.W \u2192 \u03b1\n  | \u27e8a, f\u27e9 => g (abs \u27e8a, fun x => recF g (f x)\u27e9)", "start": [163, 1], "end": [165, 49], "kind": "commanddeclaration"}, {"full_name": "QPF.recF_eq", "code": "theorem recF_eq {\u03b1 : Type _} (g : F \u03b1 \u2192 \u03b1) (x : q.P.W) :\n    recF g x = g (abs (recF g <$> x.dest))", "start": [169, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "QPF.recF_eq'", "code": "theorem recF_eq' {\u03b1 : Type _} (g : F \u03b1 \u2192 \u03b1) (a : q.P.A) (f : q.P.B a \u2192 q.P.W) :\n    recF g \u27e8a, f\u27e9 = g (abs (recF g <$> \u27e8a, f\u27e9))", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "QPF.Wequiv", "code": "inductive Wequiv : q.P.W \u2192 q.P.W \u2192 Prop\n  | ind (a : q.P.A) (f f' : q.P.B a \u2192 q.P.W) : (\u2200 x, Wequiv (f x) (f' x)) \u2192 Wequiv \u27e8a, f\u27e9 \u27e8a, f'\u27e9\n  | abs (a : q.P.A) (f : q.P.B a \u2192 q.P.W) (a' : q.P.A) (f' : q.P.B a' \u2192 q.P.W) :\n      abs \u27e8a, f\u27e9 = abs \u27e8a', f'\u27e9 \u2192 Wequiv \u27e8a, f\u27e9 \u27e8a', f'\u27e9\n  | trans (u v w : q.P.W) : Wequiv u v \u2192 Wequiv v w \u2192 Wequiv u w", "start": [182, 1], "end": [187, 65], "kind": "commanddeclaration"}, {"full_name": "QPF.recF_eq_of_Wequiv", "code": "theorem recF_eq_of_Wequiv {\u03b1 : Type u} (u : F \u03b1 \u2192 \u03b1) (x y : q.P.W) :\n    Wequiv x y \u2192 recF u x = recF u y", "start": [191, 1], "end": [198, 57], "kind": "commanddeclaration"}, {"full_name": "QPF.Wequiv.abs'", "code": "theorem Wequiv.abs' (x y : q.P.W) (h : QPF.abs x.dest = QPF.abs y.dest) : Wequiv x y", "start": [202, 1], "end": [206, 10], "kind": "commanddeclaration"}, {"full_name": "QPF.Wequiv.refl", "code": "theorem Wequiv.refl (x : q.P.W) : Wequiv x x", "start": [210, 1], "end": [212, 31], "kind": "commanddeclaration"}, {"full_name": "QPF.Wequiv.symm", "code": "theorem Wequiv.symm (x y : q.P.W) : Wequiv x y \u2192 Wequiv y x", "start": [216, 1], "end": [221, 71], "kind": "commanddeclaration"}, {"full_name": "QPF.Wrepr", "code": "def Wrepr : q.P.W \u2192 q.P.W :=\n  recF (PFunctor.W.mk \u2218 repr)", "start": [225, 1], "end": [227, 30], "kind": "commanddeclaration"}, {"full_name": "QPF.Wrepr_equiv", "code": "theorem Wrepr_equiv (x : q.P.W) : Wequiv (Wrepr x) x", "start": [231, 1], "end": [239, 29], "kind": "commanddeclaration"}, {"full_name": "QPF.Wsetoid", "code": "def Wsetoid : Setoid q.P.W :=\n  \u27e8Wequiv, @Wequiv.refl _ _ _, @Wequiv.symm _ _ _, @Wequiv.trans _ _ _\u27e9", "start": [243, 1], "end": [245, 72], "kind": "commanddeclaration"}, {"full_name": "QPF.Fix", "code": "def Fix (F : Type u \u2192 Type u) [Functor F] [q : QPF F] :=\n  Quotient (Wsetoid : Setoid q.P.W)", "start": [251, 1], "end": [254, 36], "kind": "commanddeclaration"}, {"full_name": "QPF.Fix.rec", "code": "def Fix.rec {\u03b1 : Type _} (g : F \u03b1 \u2192 \u03b1) : Fix F \u2192 \u03b1 :=\n  Quot.lift (recF g) (recF_eq_of_Wequiv g)", "start": [257, 1], "end": [259, 43], "kind": "commanddeclaration"}, {"full_name": "QPF.fixToW", "code": "def fixToW : Fix F \u2192 q.P.W :=\n  Quotient.lift Wrepr (recF_eq_of_Wequiv fun x => @PFunctor.W.mk q.P (repr x))", "start": [262, 1], "end": [264, 79], "kind": "commanddeclaration"}, {"full_name": "QPF.Fix.mk", "code": "def Fix.mk (x : F (Fix F)) : Fix F :=\n  Quot.mk _ (PFunctor.W.mk (fixToW <$> repr x))", "start": [268, 1], "end": [270, 48], "kind": "commanddeclaration"}, {"full_name": "QPF.Fix.dest", "code": "def Fix.dest : Fix F \u2192 F (Fix F) :=\n  Fix.rec (Functor.map Fix.mk)", "start": [273, 1], "end": [275, 31], "kind": "commanddeclaration"}, {"full_name": "QPF.Fix.rec_eq", "code": "theorem Fix.rec_eq {\u03b1 : Type _} (g : F \u03b1 \u2192 \u03b1) (x : F (Fix F)) :\n    Fix.rec g (Fix.mk x) = g (Fix.rec g <$> x)", "start": [278, 1], "end": [293, 25], "kind": "commanddeclaration"}, {"full_name": "QPF.Fix.ind_aux", "code": "theorem Fix.ind_aux (a : q.P.A) (f : q.P.B a \u2192 q.P.W) :\n    Fix.mk (abs \u27e8a, fun x => \u27e6f x\u27e7\u27e9) = \u27e6\u27e8a, f\u27e9\u27e7", "start": [296, 1], "end": [306, 20], "kind": "commanddeclaration"}, {"full_name": "QPF.Fix.ind_rec", "code": "theorem Fix.ind_rec {\u03b1 : Type u} (g\u2081 g\u2082 : Fix F \u2192 \u03b1)\n    (h : \u2200 x : F (Fix F), g\u2081 <$> x = g\u2082 <$> x \u2192 g\u2081 (Fix.mk x) = g\u2082 (Fix.mk x)) :\n    \u2200 x, g\u2081 x = g\u2082 x", "start": [309, 1], "end": [319, 11], "kind": "commanddeclaration"}, {"full_name": "QPF.Fix.rec_unique", "code": "theorem Fix.rec_unique {\u03b1 : Type u} (g : F \u03b1 \u2192 \u03b1) (h : Fix F \u2192 \u03b1)\n    (hyp : \u2200 x, h (Fix.mk x) = g (h <$> x)) : Fix.rec g = h", "start": [322, 1], "end": [327, 31], "kind": "commanddeclaration"}, {"full_name": "QPF.Fix.mk_dest", "code": "theorem Fix.mk_dest (x : Fix F) : Fix.mk (Fix.dest x) = x", "start": [330, 1], "end": [336, 9], "kind": "commanddeclaration"}, {"full_name": "QPF.Fix.dest_mk", "code": "theorem Fix.dest_mk (x : F (Fix F)) : Fix.dest (Fix.mk x) = x", "start": [339, 1], "end": [345, 20], "kind": "commanddeclaration"}, {"full_name": "QPF.Fix.ind", "code": "theorem Fix.ind (p : Fix F \u2192 Prop) (h : \u2200 x : F (Fix F), Liftp p x \u2192 p (Fix.mk x)) : \u2200 x, p x", "start": [348, 1], "end": [357, 13], "kind": "commanddeclaration"}, {"full_name": "QPF.corecF", "code": "def corecF {\u03b1 : Type _} (g : \u03b1 \u2192 F \u03b1) : \u03b1 \u2192 q.P.M :=\n  PFunctor.M.corec fun x => repr (g x)", "start": [371, 1], "end": [373, 39], "kind": "commanddeclaration"}, {"full_name": "QPF.corecF_eq", "code": "theorem corecF_eq {\u03b1 : Type _} (g : \u03b1 \u2192 F \u03b1) (x : \u03b1) :\n    PFunctor.M.dest (corecF g x) = corecF g <$> repr (g x)", "start": [377, 1], "end": [378, 100], "kind": "commanddeclaration"}, {"full_name": "QPF.IsPrecongr", "code": "def IsPrecongr (r : q.P.M \u2192 q.P.M \u2192 Prop) : Prop :=\n  \u2200 \u2983x y\u2984, r x y \u2192 abs (Quot.mk r <$> PFunctor.M.dest x) = abs (Quot.mk r <$> PFunctor.M.dest y)", "start": [383, 1], "end": [385, 97], "kind": "commanddeclaration"}, {"full_name": "QPF.Mcongr", "code": "def Mcongr : q.P.M \u2192 q.P.M \u2192 Prop := fun x y => \u2203 r, IsPrecongr r \u2227 r x y", "start": [388, 1], "end": [389, 74], "kind": "commanddeclaration"}, {"full_name": "QPF.Cofix", "code": "def Cofix (F : Type u \u2192 Type u) [Functor F] [q : QPF F] :=\n  Quot (@Mcongr F _ q)", "start": [393, 1], "end": [395, 23], "kind": "commanddeclaration"}, {"full_name": "QPF.Cofix.corec", "code": "def Cofix.corec {\u03b1 : Type _} (g : \u03b1 \u2192 F \u03b1) (x : \u03b1) : Cofix F :=\n  Quot.mk _ (corecF g x)", "start": [401, 1], "end": [403, 25], "kind": "commanddeclaration"}, {"full_name": "QPF.Cofix.dest", "code": "def Cofix.dest : Cofix F \u2192 F (Cofix F) :=\n  Quot.lift (fun x => Quot.mk Mcongr <$> abs (PFunctor.M.dest x))\n    (by\n      rintro x y \u27e8r, pr, rxy\u27e9\n      dsimp\n      have : \u2200 x y, r x y \u2192 Mcongr x y := by\n        intro x y h\n        exact \u27e8r, pr, h\u27e9\n      rw [\u2190 Quot.factor_mk_eq _ _ this]\n      conv =>\n        lhs\n        rw [comp_map, \u2190 abs_map, pr rxy, abs_map, \u2190 comp_map])", "start": [406, 1], "end": [418, 63], "kind": "commanddeclaration"}, {"full_name": "QPF.Cofix.dest_corec", "code": "theorem Cofix.dest_corec {\u03b1 : Type u} (g : \u03b1 \u2192 F \u03b1) (x : \u03b1) :\n    Cofix.dest (Cofix.corec g x) = Cofix.corec g <$> g x", "start": [421, 1], "end": [427, 53], "kind": "commanddeclaration"}, {"full_name": "QPF.Cofix.bisim_aux", "code": "private theorem Cofix.bisim_aux (r : Cofix F \u2192 Cofix F \u2192 Prop) (h' : \u2200 x, r x x)\n    (h : \u2200 x y, r x y \u2192 Quot.mk r <$> Cofix.dest x = Quot.mk r <$> Cofix.dest y) :\n    \u2200 x y, r x y \u2192 x = y", "start": [431, 1], "end": [465, 26], "kind": "commanddeclaration"}, {"full_name": "QPF.Cofix.bisim_rel", "code": "theorem Cofix.bisim_rel (r : Cofix F \u2192 Cofix F \u2192 Prop)\n    (h : \u2200 x y, r x y \u2192 Quot.mk r <$> Cofix.dest x = Quot.mk r <$> Cofix.dest y) :\n    \u2200 x y, r x y \u2192 x = y", "start": [467, 1], "end": [484, 19], "kind": "commanddeclaration"}, {"full_name": "QPF.Cofix.bisim", "code": "theorem Cofix.bisim (r : Cofix F \u2192 Cofix F \u2192 Prop)\n    (h : \u2200 x y, r x y \u2192 Liftr r (Cofix.dest x) (Cofix.dest y)) : \u2200 x y, r x y \u2192 x = y", "start": [487, 1], "end": [495, 11], "kind": "commanddeclaration"}, {"full_name": "QPF.Cofix.bisim'", "code": "theorem Cofix.bisim' {\u03b1 : Type*} (Q : \u03b1 \u2192 Prop) (u v : \u03b1 \u2192 Cofix F)\n    (h : \u2200 x, Q x \u2192 \u2203 a f f', Cofix.dest (u x) = abs \u27e8a, f\u27e9 \u2227 Cofix.dest (v x) = abs \u27e8a, f'\u27e9 \u2227\n      \u2200 i, \u2203 x', Q x' \u2227 f i = u x' \u2227 f' i = v x') :\n    \u2200 x, Q x \u2192 u x = v x", "start": [498, 1], "end": [508, 26], "kind": "commanddeclaration"}, {"full_name": "QPF.comp", "code": "def comp : QPF (Functor.Comp F\u2082 F\u2081) where\n  P := PFunctor.comp q\u2082.P q\u2081.P\n  abs {\u03b1} := by\n    dsimp [Functor.Comp]\n    intro p\n    exact abs \u27e8p.1.1, fun x => abs \u27e8p.1.2 x, fun y => p.2 \u27e8x, y\u27e9\u27e9\u27e9\n  repr {\u03b1} := by\n    dsimp [Functor.Comp]\n    intro y\n    refine' \u27e8\u27e8(repr y).1, fun u => (repr ((repr y).2 u)).1\u27e9, _\u27e9\n    dsimp [PFunctor.comp]\n    intro x\n    exact (repr ((repr y).2 x.1)).snd x.2\n  abs_repr {\u03b1} := by\n    dsimp [Functor.Comp]\n    intro x\n    conv =>\n      rhs\n      rw [\u2190 abs_repr x]\n    cases' h : repr x with a f\n    dsimp\n    congr with x\n    cases' h' : repr (f x) with b g\n    dsimp; rw [\u2190 h', abs_repr]\n  abs_map {\u03b1 \u03b2} f := by\n    dsimp [Functor.Comp, PFunctor.comp]\n    intro p\n    cases' p with a g; dsimp\n    cases' a with b h; dsimp\n    symm\n    trans\n    symm\n    apply abs_map\n    congr\n    rw [PFunctor.map_eq]\n    dsimp [Function.comp]\n    congr\n    ext x\n    rw [\u2190 abs_map]\n    rfl", "start": [522, 1], "end": [562, 8], "kind": "commanddeclaration"}, {"full_name": "QPF.quotientQPF", "code": "def quotientQPF (FG_abs_repr : \u2200 {\u03b1} (x : G \u03b1), FG_abs (FG_repr x) = x)\n    (FG_abs_map : \u2200 {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (x : F \u03b1), FG_abs (f <$> x) = f <$> FG_abs x) : QPF G where\n  P := q.P\n  abs {\u03b1} p := FG_abs (abs p)\n  repr {\u03b1} x := repr (FG_repr x)\n  abs_repr {\u03b1} x := by simp only; rw [abs_repr, FG_abs_repr]\n  abs_map {\u03b1 \u03b2} f x := by simp only; rw [abs_map, FG_abs_map]", "start": [582, 1], "end": [592, 62], "kind": "commanddeclaration"}, {"full_name": "QPF.mem_supp", "code": "theorem mem_supp {\u03b1 : Type u} (x : F \u03b1) (u : \u03b1) :\n    u \u2208 supp x \u2194 \u2200 a f, abs \u27e8a, f\u27e9 = x \u2192 u \u2208 f '' univ", "start": [608, 1], "end": [619, 22], "kind": "commanddeclaration"}, {"full_name": "QPF.supp_eq", "code": "theorem supp_eq {\u03b1 : Type u} (x : F \u03b1) :\n    supp x = { u | \u2200 a f, abs \u27e8a, f\u27e9 = x \u2192 u \u2208 f '' univ }", "start": [622, 1], "end": [625, 17], "kind": "commanddeclaration"}, {"full_name": "QPF.has_good_supp_iff", "code": "theorem has_good_supp_iff {\u03b1 : Type u} (x : F \u03b1) :\n    (\u2200 p, Liftp p x \u2194 \u2200 u \u2208 supp x, p u) \u2194\n      \u2203 a f, abs \u27e8a, f\u27e9 = x \u2227 \u2200 a' f', abs \u27e8a', f'\u27e9 = x \u2192 f '' univ \u2286 f' '' univ", "start": [628, 1], "end": [651, 40], "kind": "commanddeclaration"}, {"full_name": "QPF.IsUniform", "code": "def IsUniform : Prop :=\n  \u2200 \u2983\u03b1 : Type u\u2984 (a a' : q.P.A) (f : q.P.B a \u2192 \u03b1) (f' : q.P.B a' \u2192 \u03b1),\n    abs \u27e8a, f\u27e9 = abs \u27e8a', f'\u27e9 \u2192 f '' univ = f' '' univ", "start": [654, 1], "end": [658, 55], "kind": "commanddeclaration"}, {"full_name": "QPF.LiftpPreservation", "code": "def LiftpPreservation : Prop :=\n  \u2200 \u2983\u03b1\u2984 (p : \u03b1 \u2192 Prop) (x : q.P \u03b1), Liftp p (abs x) \u2194 Liftp p x", "start": [661, 1], "end": [663, 64], "kind": "commanddeclaration"}, {"full_name": "QPF.SuppPreservation", "code": "def SuppPreservation : Prop :=\n  \u2200 \u2983\u03b1\u2984 (x : q.P \u03b1), supp (abs x) = supp x", "start": [666, 1], "end": [668, 43], "kind": "commanddeclaration"}, {"full_name": "QPF.supp_eq_of_isUniform", "code": "theorem supp_eq_of_isUniform (h : q.IsUniform) {\u03b1 : Type u} (a : q.P.A) (f : q.P.B a \u2192 \u03b1) :\n    supp (abs \u27e8a, f\u27e9) = f '' univ", "start": [671, 1], "end": [677, 36], "kind": "commanddeclaration"}, {"full_name": "QPF.liftp_iff_of_isUniform", "code": "theorem liftp_iff_of_isUniform (h : q.IsUniform) {\u03b1 : Type u} (x : F \u03b1) (p : \u03b1 \u2192 Prop) :\n    Liftp p x \u2194 \u2200 u \u2208 supp x, p u", "start": [680, 1], "end": [692, 29], "kind": "commanddeclaration"}, {"full_name": "QPF.supp_map", "code": "theorem supp_map (h : q.IsUniform) {\u03b1 \u03b2 : Type u} (g : \u03b1 \u2192 \u03b2) (x : F \u03b1) :\n    supp (g <$> x) = g '' supp x", "start": [695, 1], "end": [698, 66], "kind": "commanddeclaration"}, {"full_name": "QPF.suppPreservation_iff_uniform", "code": "theorem suppPreservation_iff_uniform : q.SuppPreservation \u2194 q.IsUniform", "start": [701, 1], "end": [706, 49], "kind": "commanddeclaration"}, {"full_name": "QPF.suppPreservation_iff_liftpPreservation", "code": "theorem suppPreservation_iff_liftpPreservation : q.SuppPreservation \u2194 q.LiftpPreservation", "start": [709, 1], "end": [720, 24], "kind": "commanddeclaration"}, {"full_name": "QPF.liftpPreservation_iff_uniform", "code": "theorem liftpPreservation_iff_uniform : q.LiftpPreservation \u2194 q.IsUniform", "start": [723, 1], "end": [724, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/SpecialFunctions/Arctan.lean", "imports": ["Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/Arctan.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.measurable_arctan", "code": "@[measurability]\ntheorem measurable_arctan : Measurable arctan", "start": [19, 1], "end": [21, 31], "kind": "commanddeclaration"}, {"full_name": "Measurable.arctan", "code": "@[measurability]\ntheorem Measurable.arctan : Measurable fun x => arctan (f x)", "start": [32, 1], "end": [34, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/PNat/Find.lean", "imports": ["Mathlib/Data/PNat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PNat.decidablePredExistsNat", "code": "instance decidablePredExistsNat : DecidablePred fun n' : \u2115 => \u2203 (n : \u2115+) (_ : n' = n), p n :=\n  fun n' =>\n  decidable_of_iff' (\u2203 h : 0 < n', p \u27e8n', h\u27e9) <|\n    Subtype.exists.trans <| by\n      simp_rw [mk_coe, @exists_comm (_ < _) (_ = _), exists_prop, exists_eq_left']", "start": [22, 1], "end": [26, 83], "kind": "commanddeclaration"}, {"full_name": "PNat.findX", "code": "protected def findX : { n // p n \u2227 \u2200 m : \u2115+, m < n \u2192 \u00acp m } := by\n  have : \u2203 (n' : \u2115) (n : \u2115+) (_ : n' = n), p n := Exists.elim h fun n hn => \u27e8n, n, rfl, hn\u27e9\n  have n := Nat.findX this\n  refine' \u27e8\u27e8n, _\u27e9, _, fun m hm pm => _\u27e9\n  \u00b7 obtain \u27e8n', hn', -\u27e9 := n.prop.1\n    rw [hn']\n    exact n'.prop\n  \u00b7 obtain \u27e8n', hn', pn'\u27e9 := n.prop.1\n    simpa [hn', Subtype.coe_eta] using pn'\n  \u00b7 exact n.prop.2 m hm \u27e8m, rfl, pm\u27e9", "start": [31, 1], "end": [41, 37], "kind": "commanddeclaration"}, {"full_name": "PNat.find", "code": "protected def find : \u2115+ :=\n  PNat.findX h", "start": [44, 1], "end": [56, 15], "kind": "commanddeclaration"}, {"full_name": "PNat.find_spec", "code": "protected theorem find_spec : p (PNat.find h)", "start": [59, 1], "end": [60, 27], "kind": "commanddeclaration"}, {"full_name": "PNat.find_min", "code": "protected theorem find_min : \u2200 {m : \u2115+}, m < PNat.find h \u2192 \u00acp m", "start": [63, 1], "end": [64, 29], "kind": "commanddeclaration"}, {"full_name": "PNat.find_min'", "code": "protected theorem find_min' {m : \u2115+} (hm : p m) : PNat.find h \u2264 m", "start": [67, 1], "end": [68, 45], "kind": "commanddeclaration"}, {"full_name": "PNat.find_eq_iff", "code": "theorem find_eq_iff : PNat.find h = m \u2194 p m \u2227 \u2200 n < m, \u00acp n", "start": [73, 1], "end": [78, 101], "kind": "commanddeclaration"}, {"full_name": "PNat.find_lt_iff", "code": "@[simp]\ntheorem find_lt_iff (n : \u2115+) : PNat.find h < n \u2194 \u2203 m < n, p m", "start": [81, 1], "end": [84, 40], "kind": "commanddeclaration"}, {"full_name": "PNat.find_le_iff", "code": "@[simp]\ntheorem find_le_iff (n : \u2115+) : PNat.find h \u2264 n \u2194 \u2203 m \u2264 n, p m", "start": [87, 1], "end": [89, 57], "kind": "commanddeclaration"}, {"full_name": "PNat.le_find_iff", "code": "@[simp]\ntheorem le_find_iff (n : \u2115+) : n \u2264 PNat.find h \u2194 \u2200 m < n, \u00acp m", "start": [92, 1], "end": [94, 57], "kind": "commanddeclaration"}, {"full_name": "PNat.lt_find_iff", "code": "@[simp]\ntheorem lt_find_iff (n : \u2115+) : n < PNat.find h \u2194 \u2200 m \u2264 n, \u00acp m", "start": [97, 1], "end": [99, 66], "kind": "commanddeclaration"}, {"full_name": "PNat.find_eq_one", "code": "@[simp]\ntheorem find_eq_one : PNat.find h = 1 \u2194 p 1", "start": [102, 1], "end": [103, 69], "kind": "commanddeclaration"}, {"full_name": "PNat.one_le_find", "code": "theorem one_le_find : 1 < PNat.find h \u2194 \u00acp 1", "start": [107, 1], "end": [108, 28], "kind": "commanddeclaration"}, {"full_name": "PNat.find_mono", "code": "theorem find_mono (h : \u2200 n, q n \u2192 p n) {hp : \u2203 n, p n} {hq : \u2203 n, q n} :\n    PNat.find hp \u2264 PNat.find hq", "start": [111, 1], "end": [113, 45], "kind": "commanddeclaration"}, {"full_name": "PNat.find_le", "code": "theorem find_le {h : \u2203 n, p n} (hn : p n) : PNat.find h \u2264 n", "start": [116, 1], "end": [117, 43], "kind": "commanddeclaration"}, {"full_name": "PNat.find_comp_succ", "code": "theorem find_comp_succ (h : \u2203 n, p n) (h\u2082 : \u2203 n, p (n + 1)) (h1 : \u00acp 1) :\n    PNat.find h = PNat.find h\u2082 + 1", "start": [120, 1], "end": [126, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/ContinuousFunction/LocallyConstant.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Basic.lean", "Mathlib/Topology/ContinuousFunction/Algebra.lean", "Mathlib/Topology/LocallyConstant/Algebra.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LocallyConstant.toContinuousMapMonoidHom", "code": "@[to_additive (attr := simps)\n\"The inclusion of locally-constant functions into continuous functions as an additive monoid hom.\"]\ndef toContinuousMapMonoidHom [Monoid Y] [ContinuousMul Y] : LocallyConstant X Y \u2192* C(X, Y) where\n  toFun := (\u2191)\n  map_one' := by\n    ext\n    simp\n  map_mul' x y := by\n    ext\n    simp", "start": [22, 1], "end": [33, 9], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.toContinuousMapLinearMap", "code": "@[simps]\ndef toContinuousMapLinearMap (R : Type*) [Semiring R] [AddCommMonoid Y] [Module R Y]\n    [ContinuousAdd Y] [ContinuousConstSMul R Y] : LocallyConstant X Y \u2192\u2097[R] C(X, Y) where\n  toFun := (\u2191)\n  map_add' x y := by\n    ext\n    simp\n  map_smul' x y := by\n    ext\n    simp", "start": [37, 1], "end": [47, 9], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.toContinuousMapAlgHom", "code": "@[simps]\ndef toContinuousMapAlgHom (R : Type*) [CommSemiring R] [Semiring Y] [Algebra R Y]\n    [TopologicalSemiring Y] : LocallyConstant X Y \u2192\u2090[R] C(X, Y) where\n  toFun := (\u2191)\n  map_one' := by\n    ext\n    simp\n  map_mul' x y := by\n    ext\n    simp\n  map_zero' := by\n    ext\n    simp\n  map_add' x y := by\n    ext\n    simp\n  commutes' r := by\n    ext x\n    simp [Algebra.smul_def]", "start": [50, 1], "end": [69, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Groupoid/Subgroupoid.lean", "imports": ["Mathlib/CategoryTheory/Groupoid.lean", "Mathlib/CategoryTheory/Groupoid/Basic.lean", "Mathlib/GroupTheory/Subgroup/Basic.lean", "Mathlib/Data/Set/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Groupoid/VertexGroup.lean", "Mathlib/Order/GaloisConnection.lean", "Mathlib/Algebra/Group/Defs.lean"], "premises": [{"full_name": "CategoryTheory.Subgroupoid", "code": "@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : \u2200 c d : C, Set (c \u27f6 d)\n  protected inv : \u2200 {c d} {p : c \u27f6 d}, p \u2208 arrows c d \u2192 Groupoid.inv p \u2208 arrows d c\n  protected mul : \u2200 {c d e} {p}, p \u2208 arrows c d \u2192 \u2200 {q}, q \u2208 arrows d e \u2192 p \u226b q \u2208 arrows c e", "start": [69, 1], "end": [76, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.inv_mem_iff", "code": "theorem inv_mem_iff {c d : C} (f : c \u27f6 d) :\n    Groupoid.inv f \u2208 S.arrows d c \u2194 f \u2208 S.arrows c d", "start": [83, 1], "end": [88, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mul_mem_cancel_left", "code": "theorem mul_mem_cancel_left {c d e : C} {f : c \u27f6 d} {g : d \u27f6 e} (hf : f \u2208 S.arrows c d) :\n    f \u226b g \u2208 S.arrows c e \u2194 g \u2208 S.arrows d e", "start": [91, 1], "end": [98, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mul_mem_cancel_right", "code": "theorem mul_mem_cancel_right {c d e : C} {f : c \u27f6 d} {g : d \u27f6 e} (hg : g \u2208 S.arrows d e) :\n    f \u226b g \u2208 S.arrows c e \u2194 f \u2208 S.arrows c d", "start": [101, 1], "end": [108, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.objs", "code": "def objs : Set C :=\n  {c : C | (S.arrows c c).Nonempty}", "start": [111, 1], "end": [113, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_objs_of_src", "code": "theorem mem_objs_of_src {c d : C} {f : c \u27f6 d} (h : f \u2208 S.arrows c d) : c \u2208 S.objs", "start": [116, 1], "end": [117, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_objs_of_tgt", "code": "theorem mem_objs_of_tgt {c d : C} {f : c \u27f6 d} (h : f \u2208 S.arrows c d) : d \u2208 S.objs", "start": [120, 1], "end": [121, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.id_mem_of_nonempty_isotropy", "code": "theorem id_mem_of_nonempty_isotropy (c : C) : c \u2208 objs S \u2192 \ud835\udfd9 c \u2208 S.arrows c c", "start": [124, 1], "end": [127, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.id_mem_of_src", "code": "theorem id_mem_of_src {c d : C} {f : c \u27f6 d} (h : f \u2208 S.arrows c d) : \ud835\udfd9 c \u2208 S.arrows c c", "start": [130, 1], "end": [131, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.id_mem_of_tgt", "code": "theorem id_mem_of_tgt {c d : C} {f : c \u27f6 d} (h : f \u2208 S.arrows c d) : \ud835\udfd9 d \u2208 S.arrows d d", "start": [134, 1], "end": [135, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.asWideQuiver", "code": "def asWideQuiver : Quiver C :=\n  \u27e8fun c d => Subtype <| S.arrows c d\u27e9", "start": [138, 1], "end": [140, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.coe", "code": "@[simps comp_coe, simps (config := .lemmasOnly) inv_coe]\ninstance coe : Groupoid S.objs where\n  Hom a b := S.arrows a.val b.val\n  id a := \u27e8\ud835\udfd9 a.val, id_mem_of_nonempty_isotropy S a.val a.prop\u27e9\n  comp p q := \u27e8p.val \u226b q.val, S.mul p.prop q.prop\u27e9\n  inv p := \u27e8Groupoid.inv p.val, S.inv p.prop\u27e9", "start": [143, 1], "end": [149, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.coe_inv_coe'", "code": "@[simp]\ntheorem coe_inv_coe' {c d : S.objs} (p : c \u27f6 d) :\n    (CategoryTheory.inv p).val = CategoryTheory.inv p.val", "start": [152, 1], "end": [155, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.hom", "code": "def hom : S.objs \u2964 C where\n  obj c := c.val\n  map f := f.val\n  map_id _ := rfl\n  map_comp _ _ := rfl", "start": [158, 1], "end": [163, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.hom.inj_on_objects", "code": "theorem hom.inj_on_objects : Function.Injective (hom S).obj", "start": [166, 1], "end": [168, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.hom.faithful", "code": "theorem hom.faithful : \u2200 c d, Function.Injective fun f : c \u27f6 d => (hom S).map f", "start": [171, 1], "end": [172, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.vertexSubgroup", "code": "def vertexSubgroup {c : C} (hc : c \u2208 S.objs) : Subgroup (c \u27f6 c) where\n  carrier := S.arrows c c\n  mul_mem' hf hg := S.mul hf hg\n  one_mem' := id_mem_of_nonempty_isotropy _ _ hc\n  inv_mem' hf := S.inv hf", "start": [175, 1], "end": [180, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.toSet", "code": "@[coe] def toSet (S : Subgroupoid C) : Set (\u03a3 c d : C, c \u27f6 d) :=\n  {F | F.2.2 \u2208 S.arrows F.1 F.2.1}", "start": [183, 1], "end": [185, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_iff", "code": "theorem mem_iff (S : Subgroupoid C) (F : \u03a3 c d, c \u27f6 d) : F \u2208 S \u2194 F.2.2 \u2208 S.arrows F.1 F.2.1", "start": [191, 1], "end": [192, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.le_iff", "code": "theorem le_iff (S T : Subgroupoid C) : S \u2264 T \u2194 \u2200 {c d}, S.arrows c d \u2286 T.arrows c d", "start": [195, 1], "end": [196, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_top", "code": "theorem mem_top {c d : C} (f : c \u27f6 d) : f \u2208 (\u22a4 : Subgroupoid C).arrows c d", "start": [204, 1], "end": [205, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_top_objs", "code": "theorem mem_top_objs (c : C) : c \u2208 (\u22a4 : Subgroupoid C).objs", "start": [208, 1], "end": [210, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_sInf_arrows", "code": "theorem mem_sInf_arrows {s : Set (Subgroupoid C)} {c d : C} {p : c \u27f6 d} :\n    p \u2208 (sInf s).arrows c d \u2194 \u2200 S \u2208 s, p \u2208 S.arrows c d", "start": [236, 1], "end": [238, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_sInf", "code": "theorem mem_sInf {s : Set (Subgroupoid C)} {p : \u03a3 c d : C, c \u27f6 d} :\n    p \u2208 sInf s \u2194 \u2200 S \u2208 s, p \u2208 S", "start": [240, 1], "end": [242, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.le_objs", "code": "theorem le_objs {S T : Subgroupoid C} (h : S \u2264 T) : S.objs \u2286 T.objs", "start": [257, 1], "end": [258, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.inclusion", "code": "def inclusion {S T : Subgroupoid C} (h : S \u2264 T) : S.objs \u2964 T.objs where\n  obj s := \u27e8s.val, le_objs h s.prop\u27e9\n  map f := \u27e8f.val, @h \u27e8_, _, f.val\u27e9 f.prop\u27e9\n  map_id _ := rfl\n  map_comp _ _ := rfl", "start": [261, 1], "end": [266, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.inclusion_inj_on_objects", "code": "theorem inclusion_inj_on_objects {S T : Subgroupoid C} (h : S \u2264 T) :\n    Function.Injective (inclusion h).obj", "start": [269, 1], "end": [271, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.inclusion_faithful", "code": "theorem inclusion_faithful {S T : Subgroupoid C} (h : S \u2264 T) (s t : S.objs) :\n    Function.Injective fun f : s \u27f6 t => (inclusion h).map f", "start": [274, 1], "end": [277, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.inclusion_refl", "code": "theorem inclusion_refl {S : Subgroupoid C} : inclusion (le_refl S) = \ud835\udfed S.objs", "start": [280, 1], "end": [281, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.inclusion_trans", "code": "theorem inclusion_trans {R S T : Subgroupoid C} (k : R \u2264 S) (h : S \u2264 T) :\n    inclusion (k.trans h) = inclusion k \u22d9 inclusion h", "start": [284, 1], "end": [286, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.inclusion_comp_embedding", "code": "theorem inclusion_comp_embedding {S T : Subgroupoid C} (h : S \u2264 T) : inclusion h \u22d9 T.hom = S.hom", "start": [289, 1], "end": [290, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.Discrete.Arrows", "code": "inductive Discrete.Arrows : \u2200 c d : C, (c \u27f6 d) \u2192 Prop\n  | id (c : C) : Discrete.Arrows c c (\ud835\udfd9 c)", "start": [293, 1], "end": [295, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.discrete", "code": "def discrete : Subgroupoid C where\n  arrows c d := {p | Discrete.Arrows c d p}\n  inv := by rintro _ _ _ \u27e8\u27e9; simp only [inv_eq_inv, IsIso.inv_id]; constructor\n  mul := by rintro _ _ _ _ \u27e8\u27e9 _ \u27e8\u27e9; rw [Category.comp_id]; constructor", "start": [298, 1], "end": [302, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_discrete_iff", "code": "theorem mem_discrete_iff {c d : C} (f : c \u27f6 d) :\n    f \u2208 discrete.arrows c d \u2194 \u2203 h : c = d, f = eqToHom h", "start": [305, 1], "end": [307, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.IsWide", "code": "structure IsWide : Prop where\n  wide : \u2200 c, \ud835\udfd9 c \u2208 S.arrows c c", "start": [310, 1], "end": [312, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.isWide_iff_objs_eq_univ", "code": "theorem isWide_iff_objs_eq_univ : S.IsWide \u2194 S.objs = Set.univ", "start": [315, 1], "end": [323, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.IsWide.id_mem", "code": "theorem IsWide.id_mem {S : Subgroupoid C} (Sw : S.IsWide) (c : C) : \ud835\udfd9 c \u2208 S.arrows c c", "start": [326, 1], "end": [327, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.IsWide.eqToHom_mem", "code": "theorem IsWide.eqToHom_mem {S : Subgroupoid C} (Sw : S.IsWide) {c d : C} (h : c = d) :\n    eqToHom h \u2208 S.arrows c d", "start": [330, 1], "end": [331, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.IsNormal", "code": "structure IsNormal extends IsWide S : Prop where\n  conj : \u2200 {c d} (p : c \u27f6 d) {\u03b3 : c \u27f6 c}, \u03b3 \u2208 S.arrows c c \u2192 Groupoid.inv p \u226b \u03b3 \u226b p \u2208 S.arrows d d", "start": [334, 1], "end": [336, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.IsNormal.conj'", "code": "theorem IsNormal.conj' {S : Subgroupoid C} (Sn : IsNormal S) :\n    \u2200 {c d} (p : d \u27f6 c) {\u03b3 : c \u27f6 c}, \u03b3 \u2208 S.arrows c c \u2192 p \u226b \u03b3 \u226b Groupoid.inv p \u2208 S.arrows d d", "start": [339, 1], "end": [341, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.IsNormal.conjugation_bij", "code": "theorem IsNormal.conjugation_bij (Sn : IsNormal S) {c d} (p : c \u27f6 d) :\n    Set.BijOn (fun \u03b3 : c \u27f6 c => Groupoid.inv p \u226b \u03b3 \u226b p) (S.arrows c c) (S.arrows d d)", "start": [344, 1], "end": [351, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.top_isNormal", "code": "theorem top_isNormal : IsNormal (\u22a4 : Subgroupoid C)", "start": [354, 1], "end": [356, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.sInf_isNormal", "code": "theorem sInf_isNormal (s : Set <| Subgroupoid C) (sn : \u2200 S \u2208 s, IsNormal S) : IsNormal (sInf s)", "start": [359, 1], "end": [361, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.discrete_isNormal", "code": "theorem discrete_isNormal : (@discrete C _).IsNormal", "start": [364, 1], "end": [368, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.IsNormal.vertexSubgroup", "code": "theorem IsNormal.vertexSubgroup (Sn : IsNormal S) (c : C) (cS : c \u2208 S.objs) :\n    (S.vertexSubgroup cS).Normal where", "start": [371, 1], "end": [373, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.generated", "code": "def generated : Subgroupoid C :=\n  sInf {S : Subgroupoid C | \u2200 c d, X c d \u2286 S.arrows c d}", "start": [381, 1], "end": [383, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.subset_generated", "code": "theorem subset_generated (c d : C) : X c d \u2286 (generated X).arrows c d", "start": [386, 1], "end": [389, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.generatedNormal", "code": "def generatedNormal : Subgroupoid C :=\n  sInf {S : Subgroupoid C | (\u2200 c d, X c d \u2286 S.arrows c d) \u2227 S.IsNormal}", "start": [392, 1], "end": [394, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.generated_le_generatedNormal", "code": "theorem generated_le_generatedNormal : generated X \u2264 generatedNormal X", "start": [397, 1], "end": [399, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.generatedNormal_isNormal", "code": "theorem generatedNormal_isNormal : (generatedNormal X).IsNormal", "start": [402, 1], "end": [403, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.IsNormal.generatedNormal_le", "code": "theorem IsNormal.generatedNormal_le {S : Subgroupoid C} (Sn : S.IsNormal) :\n    generatedNormal X \u2264 S \u2194 \u2200 c d, X c d \u2286 S.arrows c d", "start": [406, 1], "end": [415, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.comap", "code": "def comap (S : Subgroupoid D) : Subgroupoid C where\n  arrows c d := {f : c \u27f6 d | \u03c6.map f \u2208 S.arrows (\u03c6.obj c) (\u03c6.obj d)}\n  inv hp := by rw [mem_setOf, inv_eq_inv, \u03c6.map_inv, \u2190 inv_eq_inv]; exact S.inv hp\n  mul := by\n    intros\n    simp only [mem_setOf, Functor.map_comp]\n    apply S.mul <;> assumption", "start": [424, 1], "end": [433, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.comap_mono", "code": "theorem comap_mono (S T : Subgroupoid D) : S \u2264 T \u2192 comap \u03c6 S \u2264 comap \u03c6 T", "start": [436, 1], "end": [437, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.isNormal_comap", "code": "theorem isNormal_comap {S : Subgroupoid D} (Sn : IsNormal S) : IsNormal (comap \u03c6 S) where", "start": [440, 1], "end": [444, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.comap_comp", "code": "@[simp]\ntheorem comap_comp {E : Type*} [Groupoid E] (\u03c8 : D \u2964 E) : comap (\u03c6 \u22d9 \u03c8) = comap \u03c6 \u2218 comap \u03c8", "start": [447, 1], "end": [449, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.ker", "code": "def ker : Subgroupoid C :=\n  comap \u03c6 discrete", "start": [452, 1], "end": [454, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_ker_iff", "code": "theorem mem_ker_iff {c d : C} (f : c \u27f6 d) :\n    f \u2208 (ker \u03c6).arrows c d \u2194 \u2203 h : \u03c6.obj c = \u03c6.obj d, \u03c6.map f = eqToHom h", "start": [457, 1], "end": [459, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.ker_isNormal", "code": "theorem ker_isNormal : (ker \u03c6).IsNormal", "start": [462, 1], "end": [463, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.ker_comp", "code": "@[simp]\ntheorem ker_comp {E : Type*} [Groupoid E] (\u03c8 : D \u2964 E) : ker (\u03c6 \u22d9 \u03c8) = comap \u03c6 (ker \u03c8)", "start": [466, 1], "end": [468, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.Map.Arrows", "code": "inductive Map.Arrows (h\u03c6 : Function.Injective \u03c6.obj) (S : Subgroupoid C) : \u2200 c d : D, (c \u27f6 d) \u2192 Prop\n  | im {c d : C} (f : c \u27f6 d) (hf : f \u2208 S.arrows c d) : Map.Arrows h\u03c6 S (\u03c6.obj c) (\u03c6.obj d) (\u03c6.map f)", "start": [471, 1], "end": [473, 101], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.Map.arrows_iff", "code": "theorem Map.arrows_iff (h\u03c6 : Function.Injective \u03c6.obj) (S : Subgroupoid C) {c d : D} (f : c \u27f6 d) :\n    Map.Arrows \u03c6 h\u03c6 S c d f \u2194\n      \u2203 (a b : C) (g : a \u27f6 b) (ha : \u03c6.obj a = c) (hb : \u03c6.obj b = d) (_hg : g \u2208 S.arrows a b),\n        f = eqToHom ha.symm \u226b \u03c6.map g \u226b eqToHom hb", "start": [476, 1], "end": [482, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.map", "code": "def map (h\u03c6 : Function.Injective \u03c6.obj) (S : Subgroupoid C) : Subgroupoid D where\n  arrows c d := {x | Map.Arrows \u03c6 h\u03c6 S c d x}\n  inv := by\n    rintro _ _ _ \u27e8\u27e9\n    rw [inv_eq_inv, \u2190 Functor.map_inv, \u2190 inv_eq_inv]\n    constructor; apply S.inv; assumption\n  mul := by\n    rintro _ _ _ _ \u27e8f, hf\u27e9 q hq\n    obtain \u27e8c\u2083, c\u2084, g, he, rfl, hg, gq\u27e9 := (Map.arrows_iff \u03c6 h\u03c6 S q).mp hq\n    cases h\u03c6 he; rw [gq, \u2190 eq_conj_eqToHom, \u2190 \u03c6.map_comp]\n    constructor; exact S.mul hf hg", "start": [485, 1], "end": [496, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_map_iff", "code": "theorem mem_map_iff (h\u03c6 : Function.Injective \u03c6.obj) (S : Subgroupoid C) {c d : D} (f : c \u27f6 d) :\n    f \u2208 (map \u03c6 h\u03c6 S).arrows c d \u2194\n      \u2203 (a b : C) (g : a \u27f6 b) (ha : \u03c6.obj a = c) (hb : \u03c6.obj b = d) (_hg : g \u2208 S.arrows a b),\n        f = eqToHom ha.symm \u226b \u03c6.map g \u226b eqToHom hb", "start": [499, 1], "end": [503, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.galoisConnection_map_comap", "code": "theorem galoisConnection_map_comap (h\u03c6 : Function.Injective \u03c6.obj) :\n    GaloisConnection (map \u03c6 h\u03c6) (comap \u03c6)", "start": [506, 1], "end": [511, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.map_mono", "code": "theorem map_mono (h\u03c6 : Function.Injective \u03c6.obj) (S T : Subgroupoid C) :\n    S \u2264 T \u2192 map \u03c6 h\u03c6 S \u2264 map \u03c6 h\u03c6 T", "start": [514, 1], "end": [515, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.le_comap_map", "code": "theorem le_comap_map (h\u03c6 : Function.Injective \u03c6.obj) (S : Subgroupoid C) :\n    S \u2264 comap \u03c6 (map \u03c6 h\u03c6 S)", "start": [518, 1], "end": [520, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.map_comap_le", "code": "theorem map_comap_le (h\u03c6 : Function.Injective \u03c6.obj) (T : Subgroupoid D) :\n    map \u03c6 h\u03c6 (comap \u03c6 T) \u2264 T", "start": [523, 1], "end": [525, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.map_le_iff_le_comap", "code": "theorem map_le_iff_le_comap (h\u03c6 : Function.Injective \u03c6.obj) (S : Subgroupoid C)\n    (T : Subgroupoid D) : map \u03c6 h\u03c6 S \u2264 T \u2194 S \u2264 comap \u03c6 T", "start": [528, 1], "end": [530, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_map_objs_iff", "code": "theorem mem_map_objs_iff (h\u03c6 : Function.Injective \u03c6.obj) (d : D) :\n    d \u2208 (map \u03c6 h\u03c6 S).objs \u2194 \u2203 c \u2208 S.objs, \u03c6.obj c = d", "start": [533, 1], "end": [542, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.map_objs_eq", "code": "@[simp]\ntheorem map_objs_eq (h\u03c6 : Function.Injective \u03c6.obj) : (map \u03c6 h\u03c6 S).objs = \u03c6.obj '' S.objs", "start": [545, 1], "end": [547, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.im", "code": "def im (h\u03c6 : Function.Injective \u03c6.obj) :=\n  map \u03c6 h\u03c6 \u22a4", "start": [550, 1], "end": [552, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_im_iff", "code": "theorem mem_im_iff (h\u03c6 : Function.Injective \u03c6.obj) {c d : D} (f : c \u27f6 d) :\n    f \u2208 (im \u03c6 h\u03c6).arrows c d \u2194\n      \u2203 (a b : C) (g : a \u27f6 b) (ha : \u03c6.obj a = c) (hb : \u03c6.obj b = d),\n        f = eqToHom ha.symm \u226b \u03c6.map g \u226b eqToHom hb", "start": [555, 1], "end": [559, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_im_objs_iff", "code": "theorem mem_im_objs_iff (h\u03c6 : Function.Injective \u03c6.obj) (d : D) :\n    d \u2208 (im \u03c6 h\u03c6).objs \u2194 \u2203 c : C, \u03c6.obj c = d", "start": [562, 1], "end": [564, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.obj_surjective_of_im_eq_top", "code": "theorem obj_surjective_of_im_eq_top (h\u03c6 : Function.Injective \u03c6.obj) (h\u03c6' : im \u03c6 h\u03c6 = \u22a4) :\n    Function.Surjective \u03c6.obj", "start": [567, 1], "end": [571, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.isNormal_map", "code": "theorem isNormal_map (h\u03c6 : Function.Injective \u03c6.obj) (h\u03c6' : im \u03c6 h\u03c6 = \u22a4) (Sn : S.IsNormal) :\n    (map \u03c6 h\u03c6 S).IsNormal", "start": [574, 1], "end": [593, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.IsThin", "code": "abbrev IsThin :=\n  Quiver.IsThin S.objs", "start": [600, 1], "end": [603, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.isThin_iff", "code": "nonrec theorem isThin_iff : S.IsThin \u2194 \u2200 c : S.objs, Subsingleton (S.arrows c c)", "start": [606, 1], "end": [606, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.IsTotallyDisconnected", "code": "nonrec abbrev IsTotallyDisconnected :=\n  IsTotallyDisconnected S.objs", "start": [613, 1], "end": [615, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.isTotallyDisconnected_iff", "code": "theorem isTotallyDisconnected_iff :\n    S.IsTotallyDisconnected \u2194 \u2200 c d, (S.arrows c d).Nonempty \u2192 c = d", "start": [618, 1], "end": [626, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.disconnect", "code": "def disconnect : Subgroupoid C where\n  arrows c d := {f | c = d \u2227 f \u2208 S.arrows c d}\n  inv := by rintro _ _ _ \u27e8rfl, h\u27e9; exact \u27e8rfl, S.inv h\u27e9\n  mul := by rintro _ _ _ _ \u27e8rfl, h\u27e9 _ \u27e8rfl, h'\u27e9; exact \u27e8rfl, S.mul h h'\u27e9", "start": [629, 1], "end": [633, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.disconnect_le", "code": "theorem disconnect_le : S.disconnect \u2264 S", "start": [636, 1], "end": [636, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.disconnect_normal", "code": "theorem disconnect_normal (Sn : S.IsNormal) : S.disconnect.IsNormal", "start": [639, 1], "end": [641, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_disconnect_objs_iff", "code": "@[simp]\ntheorem mem_disconnect_objs_iff {c : C} : c \u2208 S.disconnect.objs \u2194 c \u2208 S.objs", "start": [644, 1], "end": [646, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.disconnect_objs", "code": "theorem disconnect_objs : S.disconnect.objs = S.objs", "start": [649, 1], "end": [649, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.disconnect_isTotallyDisconnected", "code": "theorem disconnect_isTotallyDisconnected : S.disconnect.IsTotallyDisconnected", "start": [652, 1], "end": [653, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.full", "code": "def full : Subgroupoid C where\n  arrows c d := {_f | c \u2208 D \u2227 d \u2208 D}\n  inv := by rintro _ _ _ \u27e8\u27e9; constructor <;> assumption\n  mul := by rintro _ _ _ _ \u27e8\u27e9 _ \u27e8\u27e9; constructor <;> assumption", "start": [662, 1], "end": [666, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.full_objs", "code": "theorem full_objs : (full D).objs = D", "start": [669, 1], "end": [670, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_full_iff", "code": "@[simp]\ntheorem mem_full_iff {c d : C} {f : c \u27f6 d} : f \u2208 (full D).arrows c d \u2194 c \u2208 D \u2227 d \u2208 D", "start": [673, 1], "end": [675, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.mem_full_objs_iff", "code": "@[simp]\ntheorem mem_full_objs_iff {c : C} : c \u2208 (full D).objs \u2194 c \u2208 D", "start": [678, 1], "end": [679, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.full_empty", "code": "@[simp]\ntheorem full_empty : full \u2205 = (\u22a5 : Subgroupoid C)", "start": [682, 1], "end": [685, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.full_univ", "code": "@[simp]\ntheorem full_univ : full Set.univ = (\u22a4 : Subgroupoid C)", "start": [688, 1], "end": [691, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.full_mono", "code": "theorem full_mono {D E : Set C} (h : D \u2264 E) : full D \u2264 full E", "start": [694, 1], "end": [698, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subgroupoid.full_arrow_eq_iff", "code": "theorem full_arrow_eq_iff {c d : (full D).objs} {f g : c \u27f6 d} :\n    f = g \u2194 (f.1 : c.val \u27f6 d.val) = g.1", "start": [702, 1], "end": [704, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Independence/ZeroOne.lean", "imports": ["Mathlib/Probability/Independence/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.measure_eq_zero_or_one_or_top_of_indepSet_self", "code": "theorem measure_eq_zero_or_one_or_top_of_indepSet_self {t : Set \u03a9}\n    (h_indep : IndepSet t t \u03bc) : \u03bc t = 0 \u2228 \u03bc t = 1 \u2228 \u03bc t = \u221e", "start": [32, 1], "end": [42, 37], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measure_eq_zero_or_one_of_indepSetCat_self", "code": "theorem measure_eq_zero_or_one_of_indepSetCat_self [IsFiniteMeasure \u03bc] {t : Set \u03a9}\n    (h_indep : IndepSet t t \u03bc) : \u03bc t = 0 \u2228 \u03bc t = 1", "start": [45, 1], "end": [48, 43], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.indep_biSup_compl", "code": "theorem indep_biSup_compl (h_le : \u2200 n, s n \u2264 m0) (h_indep : iIndep s \u03bc) (t : Set \u03b9) :\n    Indep (\u2a06 n \u2208 t, s n) (\u2a06 n \u2208 t\u1d9c, s n) \u03bc", "start": [55, 1], "end": [57, 59], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.indep_biSup_limsup", "code": "theorem indep_biSup_limsup (h_le : \u2200 n, s n \u2264 m0) (h_indep : iIndep s \u03bc) (hf : \u2200 t, p t \u2192 t\u1d9c \u2208 f)\n    {t : Set \u03b9} (ht : p t) : Indep (\u2a06 n \u2208 t, s n) (limsup s f) \u03bc", "start": [75, 1], "end": [80, 45], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.indep_iSup_directed_limsup", "code": "theorem indep_iSup_directed_limsup (h_le : \u2200 n, s n \u2264 m0) (h_indep : iIndep s \u03bc)\n    (hf : \u2200 t, p t \u2192 t\u1d9c \u2208 f) (hns : Directed (\u00b7 \u2264 \u00b7) ns) (hnsp : \u2200 a, p (ns a)) :\n    Indep (\u2a06 a, \u2a06 n \u2208 ns a, s n) (limsup s f) \u03bc", "start": [83, 1], "end": [94, 20], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.indep_iSup_limsup", "code": "theorem indep_iSup_limsup (h_le : \u2200 n, s n \u2264 m0) (h_indep : iIndep s \u03bc) (hf : \u2200 t, p t \u2192 t\u1d9c \u2208 f)\n    (hns : Directed (\u00b7 \u2264 \u00b7) ns) (hnsp : \u2200 a, p (ns a)) (hns_univ : \u2200 n, \u2203 a, n \u2208 ns a) :\n    Indep (\u2a06 n, s n) (limsup s f) \u03bc", "start": [97, 1], "end": [107, 21], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.indep_limsup_self", "code": "theorem indep_limsup_self (h_le : \u2200 n, s n \u2264 m0) (h_indep : iIndep s \u03bc) (hf : \u2200 t, p t \u2192 t\u1d9c \u2208 f)\n    (hns : Directed (\u00b7 \u2264 \u00b7) ns) (hnsp : \u2200 a, p (ns a)) (hns_univ : \u2200 n, \u2203 a, n \u2208 ns a) :\n    Indep (limsup s f) (limsup s f) \u03bc", "start": [110, 1], "end": [113, 97], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measure_zero_or_one_of_measurableSet_limsup", "code": "theorem measure_zero_or_one_of_measurableSet_limsup (h_le : \u2200 n, s n \u2264 m0) (h_indep : iIndep s \u03bc)\n    (hf : \u2200 t, p t \u2192 t\u1d9c \u2208 f) (hns : Directed (\u00b7 \u2264 \u00b7) ns) (hnsp : \u2200 a, p (ns a))\n    (hns_univ : \u2200 n, \u2203 a, n \u2208 ns a) {t : Set \u03a9} (ht_tail : MeasurableSet[limsup s f] t) :\n    \u03bc t = 0 \u2228 \u03bc t = 1", "start": [116, 1], "end": [122, 15], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.indep_limsup_atTop_self", "code": "theorem indep_limsup_atTop_self (h_le : \u2200 n, s n \u2264 m0) (h_indep : iIndep s \u03bc) :\n    Indep (limsup s atTop) (limsup s atTop) \u03bc", "start": [131, 1], "end": [143, 31], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measure_zero_or_one_of_measurableSet_limsup_atTop", "code": "theorem measure_zero_or_one_of_measurableSet_limsup_atTop (h_le : \u2200 n, s n \u2264 m0)\n    (h_indep : iIndep s \u03bc) {t : Set \u03a9} (ht_tail : MeasurableSet[limsup s atTop] t) :\n    \u03bc t = 0 \u2228 \u03bc t = 1", "start": [146, 1], "end": [153, 87], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.indep_limsup_atBot_self", "code": "theorem indep_limsup_atBot_self (h_le : \u2200 n, s n \u2264 m0) (h_indep : iIndep s \u03bc) :\n    Indep (limsup s atBot) (limsup s atBot) \u03bc", "start": [162, 1], "end": [174, 31], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measure_zero_or_one_of_measurableSet_limsup_atBot", "code": "theorem measure_zero_or_one_of_measurableSet_limsup_atBot (h_le : \u2200 n, s n \u2264 m0)\n    (h_indep : iIndep s \u03bc) {t : Set \u03a9} (ht_tail : MeasurableSet[limsup s atBot] t) :\n    \u03bc t = 0 \u2228 \u03bc t = 1", "start": [177, 1], "end": [183, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Bicategory/Adjunction.lean", "imports": ["Mathlib/Tactic/CategoryTheory/Coherence.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Bicategory.leftZigzag", "code": "def leftZigzag (\u03b7 : \ud835\udfd9 a \u27f6 f \u226b g) (\u03b5 : g \u226b f \u27f6 \ud835\udfd9 b) :=\n  \u03b7 \u25b7 f \u2297\u226b f \u25c1 \u03b5", "start": [54, 1], "end": [64, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.rightZigzag", "code": "def rightZigzag (\u03b7 : \ud835\udfd9 a \u27f6 f \u226b g) (\u03b5 : g \u226b f \u27f6 \ud835\udfd9 b) :=\n  g \u25c1 \u03b7 \u2297\u226b \u03b5 \u25b7 g", "start": [66, 1], "end": [76, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.Adjunction", "code": "structure Adjunction (f : a \u27f6 b) (g : b \u27f6 a) where\n  \n  unit : \ud835\udfd9 a \u27f6 f \u226b g\n  \n  counit : g \u226b f \u27f6 \ud835\udfd9 b\n  \n  left_triangle : leftZigzag unit counit = (\u03bb_ _).hom \u226b (\u03c1_ _).inv := by aesop_cat\n  \n  right_triangle : rightZigzag unit counit = (\u03c1_ _).hom \u226b (\u03bb_ _).inv := by aesop_cat", "start": [78, 1], "end": [87, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.Adjunction.id", "code": "def id (a : B) : \ud835\udfd9 a \u22a3 \ud835\udfd9 a where\n  unit := (\u03c1_ _).inv\n  counit := (\u03c1_ _).hom\n  left_triangle := by dsimp; coherence\n  right_triangle := by dsimp; coherence", "start": [97, 1], "end": [102, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.leftZigzagIso", "code": "def leftZigzagIso (\u03b7 : \ud835\udfd9 a \u2245 f \u226b g) (\u03b5 : g \u226b f \u2245 \ud835\udfd9 b) :=\n  whiskerRightIso \u03b7 f \u226a\u2297\u226b whiskerLeftIso f \u03b5", "start": [113, 1], "end": [115, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.rightZigzagIso", "code": "def rightZigzagIso (\u03b7 : \ud835\udfd9 a \u2245 f \u226b g) (\u03b5 : g \u226b f \u2245 \ud835\udfd9 b) :=\n  whiskerLeftIso g \u03b7 \u226a\u2297\u226b whiskerRightIso \u03b5 g", "start": [117, 1], "end": [119, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.leftZigzagIso_hom", "code": "@[simp]\ntheorem leftZigzagIso_hom : (leftZigzagIso \u03b7 \u03b5).hom = leftZigzag \u03b7.hom \u03b5.hom", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.rightZigzagIso_hom", "code": "@[simp]\ntheorem rightZigzagIso_hom : (rightZigzagIso \u03b7 \u03b5).hom = rightZigzag \u03b7.hom \u03b5.hom", "start": [127, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.leftZigzagIso_inv", "code": "@[simp]\ntheorem leftZigzagIso_inv : (leftZigzagIso \u03b7 \u03b5).inv = rightZigzag \u03b5.inv \u03b7.inv", "start": [131, 1], "end": [133, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.rightZigzagIso_inv", "code": "@[simp]\ntheorem rightZigzagIso_inv : (rightZigzagIso \u03b7 \u03b5).inv = leftZigzag \u03b5.inv \u03b7.inv", "start": [135, 1], "end": [137, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.leftZigzagIso_symm", "code": "@[simp]\ntheorem leftZigzagIso_symm : (leftZigzagIso \u03b7 \u03b5).symm = rightZigzagIso \u03b5.symm \u03b7.symm", "start": [139, 1], "end": [141, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.rightZigzagIso_symm", "code": "@[simp]\ntheorem rightZigzagIso_symm : (rightZigzagIso \u03b7 \u03b5).symm = leftZigzagIso \u03b5.symm \u03b7.symm", "start": [143, 1], "end": [145, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.adjointifyCounit", "code": "def adjointifyCounit (\u03b7 : \ud835\udfd9 a \u2245 f \u226b g) (\u03b5 : g \u226b f \u2245 \ud835\udfd9 b) : g \u226b f \u2245 \ud835\udfd9 b :=\n  whiskerLeftIso g ((\u03c1_ f).symm \u226a\u226b rightZigzagIso \u03b5.symm \u03b7.symm \u226a\u226b \u03bb_ f) \u226a\u226b \u03b5", "start": [147, 1], "end": [149, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.adjointifyCounit_left_triangle", "code": "theorem adjointifyCounit_left_triangle (\u03b7 : \ud835\udfd9 a \u2245 f \u226b g) (\u03b5 : g \u226b f \u2245 \ud835\udfd9 b) :\n    leftZigzagIso \u03b7 (adjointifyCounit \u03b7 \u03b5) = \u03bb_ f \u226a\u226b (\u03c1_ f).symm", "start": [151, 1], "end": [166, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.Equivalence", "code": "structure Equivalence (a b : B) where\n  \n  hom : a \u27f6 b\n  \n  inv : b \u27f6 a\n  \n  unit : \ud835\udfd9 a \u2245 hom \u226b inv\n  \n  counit : inv \u226b hom \u2245 \ud835\udfd9 b\n  \n  left_triangle : leftZigzagIso unit counit = \u03bb_ hom \u226a\u226b (\u03c1_ hom).symm := by aesop_cat", "start": [168, 1], "end": [179, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.Equivalence.id", "code": "def id (a : B) : a \u224c a := \u27e8_, _, (\u03c1_ _).symm, \u03c1_ _, by ext; simp [bicategoricalIsoComp]\u27e9", "start": [185, 1], "end": [186, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.Equivalence.mkOfAdjointifyCounit", "code": "def mkOfAdjointifyCounit (\u03b7 : \ud835\udfd9 a \u2245 f \u226b g) (\u03b5 : g \u226b f \u2245 \ud835\udfd9 b) : a \u224c b where\n  hom := f\n  inv := g\n  unit := \u03b7\n  counit := adjointifyCounit \u03b7 \u03b5\n  left_triangle := adjointifyCounit_left_triangle \u03b7 \u03b5", "start": [190, 1], "end": [196, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Integral/RieszMarkovKakutani.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Bounded.lean", "Mathlib/Topology/Sets/Compacts.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "rieszContentAux", "code": "def rieszContentAux : Compacts X \u2192 \u211d\u22650 := fun K =>\n  sInf (\u039b '' { f : X \u2192\u1d47 \u211d\u22650 | \u2200 x \u2208 K, (1 : \u211d\u22650) \u2264 f x })", "start": [41, 1], "end": [45, 58], "kind": "commanddeclaration"}, {"full_name": "rieszContentAux_image_nonempty", "code": "theorem rieszContentAux_image_nonempty (K : Compacts X) :\n    (\u039b '' { f : X \u2192\u1d47 \u211d\u22650 | \u2200 x \u2208 K, (1 : \u211d\u22650) \u2264 f x }).Nonempty", "start": [50, 1], "end": [57, 67], "kind": "commanddeclaration"}, {"full_name": "rieszContentAux_mono", "code": "theorem rieszContentAux_mono {K\u2081 K\u2082 : Compacts X} (h : K\u2081 \u2264 K\u2082) :\n    rieszContentAux \u039b K\u2081 \u2264 rieszContentAux \u039b K\u2082", "start": [60, 1], "end": [65, 91], "kind": "commanddeclaration"}, {"full_name": "rieszContentAux_le", "code": "theorem rieszContentAux_le {K : Compacts X} {f : X \u2192\u1d47 \u211d\u22650} (h : \u2200 x \u2208 K, (1 : \u211d\u22650) \u2264 f x) :\n    rieszContentAux \u039b K \u2264 \u039b f", "start": [72, 1], "end": [76, 47], "kind": "commanddeclaration"}, {"full_name": "exists_lt_rieszContentAux_add_pos", "code": "theorem exists_lt_rieszContentAux_add_pos (K : Compacts X) {\u03b5 : \u211d\u22650} (\u03b5pos : 0 < \u03b5) :\n    \u2203 f : X \u2192\u1d47 \u211d\u22650, (\u2200 x \u2208 K, (1 : \u211d\u22650) \u2264 f x) \u2227 \u039b f < rieszContentAux \u039b K + \u03b5", "start": [79, 1], "end": [90, 14], "kind": "commanddeclaration"}, {"full_name": "rieszContentAux_sup_le", "code": "theorem rieszContentAux_sup_le (K1 K2 : Compacts X) :\n    rieszContentAux \u039b (K1 \u2294 K2) \u2264 rieszContentAux \u039b K1 + rieszContentAux \u039b K2", "start": [93, 1], "end": [113, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Hasse.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Prod.lean", "Mathlib/Order/SuccPred/Relation.lean", "Mathlib/Data/Fin/SuccPred.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.hasse", "code": "def hasse : SimpleGraph \u03b1 where\n  Adj a b := a \u22d6 b \u2228 b \u22d6 a\n  symm _a _b := Or.symm\n  loopless _a h := h.elim (irrefl _) (irrefl _)", "start": [35, 1], "end": [39, 48], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.hasse_adj", "code": "@[simp]\ntheorem hasse_adj : (hasse \u03b1).Adj a b \u2194 a \u22d6 b \u2228 b \u22d6 a", "start": [44, 1], "end": [46, 10], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.hasseDualIso", "code": "def hasseDualIso : hasse \u03b1\u1d52\u1d48 \u2243g hasse \u03b1 :=\n  { ofDual with map_rel_iff' := by simp [or_comm] }", "start": [49, 1], "end": [51, 52], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.hasseDualIso_apply", "code": "@[simp]\ntheorem hasseDualIso_apply (a : \u03b1\u1d52\u1d48) : hasseDualIso a = ofDual a", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.hasseDualIso_symm_apply", "code": "@[simp]\ntheorem hasseDualIso_symm_apply (a : \u03b1) : hasseDualIso.symm a = toDual a", "start": [59, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.hasse_prod", "code": "@[simp]\ntheorem hasse_prod : hasse (\u03b1 \u00d7 \u03b2) = hasse \u03b1 \u25a1 hasse \u03b2", "start": [70, 1], "end": [74, 19], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.hasse_preconnected_of_succ", "code": "theorem hasse_preconnected_of_succ [SuccOrder \u03b1] [IsSuccArchimedean \u03b1] : (hasse \u03b1).Preconnected", "start": [83, 1], "end": [88, 67], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.hasse_preconnected_of_pred", "code": "theorem hasse_preconnected_of_pred [PredOrder \u03b1] [IsPredArchimedean \u03b1] : (hasse \u03b1).Preconnected", "start": [91, 1], "end": [96, 67], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.pathGraph", "code": "def pathGraph (n : \u2115) : SimpleGraph (Fin n) :=\n  hasse _", "start": [101, 1], "end": [103, 10], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.pathGraph_preconnected", "code": "theorem pathGraph_preconnected (n : \u2115) : (pathGraph n).Preconnected", "start": [106, 1], "end": [107, 31], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.pathGraph_connected", "code": "theorem pathGraph_connected (n : \u2115) : (pathGraph (n + 1)).Connected", "start": [110, 1], "end": [111, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Option/Basic.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Data/Option/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/AlgebraicGeometry/Morphisms/FiniteType.lean", "imports": ["Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean", "Mathlib/RingTheory/RingHom/FiniteType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicGeometry.LocallyOfFiniteType", "code": "@[mk_iff]\nclass LocallyOfFiniteType (f : X \u27f6 Y) : Prop where\n  finiteType_of_affine_subset :\n    \u2200 (U : Y.affineOpens) (V : X.affineOpens) (e : V.1 \u2264 (Opens.map f.1.base).obj U.1),\n      (Scheme.Hom.appLe f e).FiniteType", "start": [34, 1], "end": [41, 40], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.locallyOfFiniteType_eq", "code": "theorem locallyOfFiniteType_eq : @LocallyOfFiniteType = affineLocally @RingHom.FiniteType", "start": [44, 1], "end": [47, 39], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.locallyOfFiniteTypeOfIsOpenImmersion", "code": "instance (priority := 900) locallyOfFiniteTypeOfIsOpenImmersion {X Y : Scheme} (f : X \u27f6 Y)\n    [IsOpenImmersion f] : LocallyOfFiniteType f :=\n  locallyOfFiniteType_eq.symm \u25b8 RingHom.finiteType_is_local.affineLocally_of_isOpenImmersion f", "start": [50, 1], "end": [52, 95], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.locallyOfFiniteType_stableUnderComposition", "code": "theorem locallyOfFiniteType_stableUnderComposition :\n    MorphismProperty.StableUnderComposition @LocallyOfFiniteType", "start": [55, 1], "end": [57, 97], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.locallyOfFiniteTypeComp", "code": "instance locallyOfFiniteTypeComp {X Y Z : Scheme} (f : X \u27f6 Y) (g : Y \u27f6 Z)\n    [hf : LocallyOfFiniteType f] [hg : LocallyOfFiniteType g] : LocallyOfFiniteType (f \u226b g) :=\n  locallyOfFiniteType_stableUnderComposition f g hf hg", "start": [60, 1], "end": [62, 55], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.locallyOfFiniteTypeOfComp", "code": "theorem locallyOfFiniteTypeOfComp {X Y Z : Scheme} (f : X \u27f6 Y) (g : Y \u27f6 Z)\n    [hf : LocallyOfFiniteType (f \u226b g)] : LocallyOfFiniteType f", "start": [65, 1], "end": [71, 48], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyOfFiniteType.affine_openCover_iff", "code": "theorem LocallyOfFiniteType.affine_openCover_iff {X Y : Scheme.{u}} (f : X \u27f6 Y)\n    (\ud835\udcb0 : Scheme.OpenCover.{u} Y) [\u2200 i, IsAffine (\ud835\udcb0.obj i)]\n    (\ud835\udcb0' : \u2200 i, Scheme.OpenCover.{u} ((\ud835\udcb0.pullbackCover f).obj i)) [\u2200 i j, IsAffine ((\ud835\udcb0' i).obj j)] :\n    LocallyOfFiniteType f \u2194 \u2200 i j, (Scheme.\u0393.map ((\ud835\udcb0' i).map j \u226b pullback.snd).op).FiniteType", "start": [74, 1], "end": [78, 88], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyOfFiniteType.source_openCover_iff", "code": "theorem LocallyOfFiniteType.source_openCover_iff {X Y : Scheme.{u}} (f : X \u27f6 Y)\n    (\ud835\udcb0 : Scheme.OpenCover.{u} X) : LocallyOfFiniteType f \u2194 \u2200 i, LocallyOfFiniteType (\ud835\udcb0.map i \u226b f)", "start": [81, 1], "end": [83, 85], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyOfFiniteType.openCover_iff", "code": "theorem LocallyOfFiniteType.openCover_iff {X Y : Scheme.{u}} (f : X \u27f6 Y)\n    (\ud835\udcb0 : Scheme.OpenCover.{u} Y) :\n    LocallyOfFiniteType f \u2194 \u2200 i, LocallyOfFiniteType (pullback.snd : pullback f (\ud835\udcb0.map i) \u27f6 _)", "start": [86, 1], "end": [89, 101], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.locallyOfFiniteType_respectsIso", "code": "theorem locallyOfFiniteType_respectsIso : MorphismProperty.RespectsIso @LocallyOfFiniteType", "start": [92, 1], "end": [94, 101], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Countable/Small.lean", "imports": ["Mathlib/Logic/Small/Basic.lean", "Mathlib/Data/Countable/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "small_of_countable", "code": "instance (priority := 100) small_of_countable (\u03b1 : Type v) [Countable \u03b1] : Small.{w} \u03b1 :=\n  let \u27e8_, hf\u27e9 := exists_injective_nat \u03b1\n  small_of_injective hf", "start": [20, 1], "end": [22, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/LocallyConvex/StrongTopology.lean", "imports": ["Mathlib/Topology/Algebra/Module/LocallyConvex.lean", "Mathlib/Topology/Algebra/Module/StrongTopology.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousLinearMap.strongTopology.locallyConvexSpace", "code": "theorem strongTopology.locallyConvexSpace (\ud835\udd16 : Set (Set E)) (h\ud835\udd16\u2081 : \ud835\udd16.Nonempty)\n    (h\ud835\udd16\u2082 : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16) :\n    @LocallyConvexSpace R (E \u2192SL[\u03c3] F) _ _ _ (strongTopology \u03c3 F \ud835\udd16)", "start": [50, 1], "end": [59, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/GroupWithZeroCat.lean", "imports": ["Mathlib/Algebra/Category/MonCat/Basic.lean", "Mathlib/CategoryTheory/Category/Bipointed.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "GroupWithZeroCat", "code": "def GroupWithZeroCat :=\n  Bundled GroupWithZero", "start": [24, 1], "end": [26, 24], "kind": "commanddeclaration"}, {"full_name": "GroupWithZeroCat.of", "code": "def of (\u03b1 : Type*) [GroupWithZero \u03b1] : GroupWithZeroCat :=\n  Bundled.of \u03b1", "start": [38, 1], "end": [40, 15], "kind": "commanddeclaration"}, {"full_name": "GroupWithZeroCat.coe_id", "code": "lemma coe_id {X : GroupWithZeroCat} : (\ud835\udfd9 X : X \u2192 X) = id := rfl", "start": [65, 1], "end": [65, 64], "kind": "mathlibtacticlemma"}, {"full_name": "GroupWithZeroCat.coe_comp", "code": "lemma coe_comp {X Y Z : GroupWithZeroCat} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g : X \u2192 Z) = g \u2218 f := rfl", "start": [68, 1], "end": [68, 99], "kind": "mathlibtacticlemma"}, {"full_name": "GroupWithZeroCat.groupWithZeroConcreteCategory", "code": "instance groupWithZeroConcreteCategory : ConcreteCategory GroupWithZeroCat where\n  forget :=\n  { obj := fun G => G\n    map := fun f => f.toFun }\n  forget_faithful := \u27e8fun h => FunLike.coe_injective h\u27e9", "start": [70, 1], "end": [74, 56], "kind": "commanddeclaration"}, {"full_name": "GroupWithZeroCat.forget_map", "code": "@[simp] lemma forget_map (f : X \u27f6 Y) : (forget GroupWithZeroCat).map f = f := rfl", "start": [77, 1], "end": [77, 82], "kind": "mathlibtacticlemma"}, {"full_name": "GroupWithZeroCat.hasForgetToBipointed", "code": "instance hasForgetToBipointed : HasForget\u2082 GroupWithZeroCat Bipointed where\n  forget\u2082 :=\n      { obj := fun X => \u27e8X, 0, 1\u27e9\n        map := fun f => \u27e8f, f.map_zero', f.map_one'\u27e9 }", "start": [78, 1], "end": [81, 55], "kind": "commanddeclaration"}, {"full_name": "GroupWithZeroCat.hasForgetToMon", "code": "instance hasForgetToMon : HasForget\u2082 GroupWithZeroCat MonCat where\n  forget\u2082 :=\n      { obj := fun X => \u27e8 X , _ \u27e9\n        map := fun f => f.toMonoidHom }", "start": [85, 1], "end": [88, 40], "kind": "commanddeclaration"}, {"full_name": "GroupWithZeroCat.Iso.mk", "code": "@[simps]\ndef Iso.mk {\u03b1 \u03b2 : GroupWithZeroCat.{u}} (e : \u03b1 \u2243* \u03b2) : \u03b1 \u2245 \u03b2 where\n  hom := (e : \u03b1 \u2192*\u2080 \u03b2)\n  inv := (e.symm : \u03b2 \u2192*\u2080 \u03b1)\n  hom_inv_id := by\n    ext\n    exact e.symm_apply_apply _\n  inv_hom_id := by\n    ext\n    exact e.apply_symm_apply _", "start": [96, 1], "end": [106, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Core.lean", "imports": ["Mathlib/Control/EquivFunctor.lean", "Mathlib/CategoryTheory/Groupoid.lean", "Mathlib/CategoryTheory/Types.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Whiskering.lean"], "premises": [{"full_name": "CategoryTheory.Core", "code": "def Core (C : Type u\u2081) := C", "start": [31, 1], "end": [36, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coreCategory", "code": "instance coreCategory : Groupoid.{v\u2081} (Core C) where\n  Hom (X Y : C) := X \u2245 Y\n  id (X : C) := Iso.refl X\n  comp f g := Iso.trans f g\n  inv {X Y} f := Iso.symm f", "start": [41, 1], "end": [45, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Core.id_hom", "code": "@[simp]\n\ntheorem id_hom (X : C) : Iso.hom (coreCategory.id X) = @CategoryStruct.id C _ X", "start": [50, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Core.comp_hom", "code": "@[simp]\ntheorem comp_hom {X Y Z : Core C} (f : X \u27f6 Y) (g : Y \u27f6 Z) : (f \u226b g).hom = f.hom \u226b g.hom", "start": [56, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Core.inclusion", "code": "def inclusion : Core C \u2964 C where\n  obj := id\n  map f := f.hom", "start": [63, 1], "end": [66, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Core.functorToCore", "code": "noncomputable def functorToCore (F : G \u2964 C) : G \u2964 Core C where\n  obj X := F.obj X\n  map f := \u27e8F.map f, F.map (inv f), _, _\u27e9", "start": [79, 1], "end": [82, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Core.forgetFunctorToCore", "code": "def forgetFunctorToCore : (G \u2964 Core C) \u2964 G \u2964 C :=\n  (whiskeringRight _ _ _).obj (inclusion C)", "start": [85, 1], "end": [89, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ofEquivFunctor", "code": "def ofEquivFunctor (m : Type u\u2081 \u2192 Type u\u2082) [EquivFunctor m] : Core (Type u\u2081) \u2964 Core (Type u\u2082)\n    where\n  obj := m\n  map f := (EquivFunctor.mapEquiv m f.toEquiv).toIso\n  map_id \u03b1 := by apply Iso.ext; funext x; exact congr_fun (EquivFunctor.map_refl' _) x\n  map_comp f g := by\n    apply Iso.ext; funext x; dsimp\n    erw [Iso.toEquiv_comp, EquivFunctor.map_trans']\n    rw [Function.comp]", "start": [94, 1], "end": [105, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Instances/RatLemmas.lean", "imports": ["Mathlib/Topology/Compactification/OnePoint.lean", "Mathlib/Topology/Instances/Rat.lean", "Mathlib/Topology/Instances/Irrational.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Rat.interior_compact_eq_empty", "code": "theorem interior_compact_eq_empty (hs : IsCompact s) : interior s = \u2205", "start": [42, 1], "end": [43, 88], "kind": "commanddeclaration"}, {"full_name": "Rat.dense_compl_compact", "code": "theorem dense_compl_compact (hs : IsCompact s) : Dense s\u1d9c", "start": [46, 1], "end": [47, 69], "kind": "commanddeclaration"}, {"full_name": "Rat.cocompact_inf_nhds_neBot", "code": "instance cocompact_inf_nhds_neBot : NeBot (cocompact \u211a \u2293 \ud835\udcdd p) := by\n  refine' (hasBasis_cocompact.inf (nhds_basis_opens _)).neBot_iff.2 _\n  rintro \u27e8s, o\u27e9 \u27e8hs, hpo, ho\u27e9; rw [inter_comm]\n  exact (dense_compl_compact hs).inter_open_nonempty _ ho \u27e8p, hpo\u27e9", "start": [50, 1], "end": [53, 67], "kind": "commanddeclaration"}, {"full_name": "Rat.not_countably_generated_cocompact", "code": "theorem not_countably_generated_cocompact : \u00acIsCountablyGenerated (cocompact \u211a)", "start": [56, 1], "end": [62, 29], "kind": "commanddeclaration"}, {"full_name": "Rat.not_countably_generated_nhds_infty_opc", "code": "theorem not_countably_generated_nhds_infty_opc : \u00acIsCountablyGenerated (\ud835\udcdd (\u221e : \u211a\u221e))", "start": [65, 1], "end": [69, 47], "kind": "commanddeclaration"}, {"full_name": "Rat.not_firstCountableTopology_opc", "code": "theorem not_firstCountableTopology_opc : \u00acFirstCountableTopology \u211a\u221e", "start": [72, 1], "end": [74, 61], "kind": "commanddeclaration"}, {"full_name": "Rat.not_secondCountableTopology_opc", "code": "theorem not_secondCountableTopology_opc : \u00acSecondCountableTopology \u211a\u221e", "start": [77, 1], "end": [79, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Additive/Etransform.lean", "imports": ["Mathlib/Data/Finset/Pointwise.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.mulDysonEtransform", "code": "@[to_additive (attr := simps) \"The **Dyson e-transform**.\nTurns `(s, t)` into `(s \u222a e +\u1d65 t, t \u2229 -e +\u1d65 s)`. This reduces the sum of the two sets.\"]\ndef mulDysonEtransform : Finset \u03b1 \u00d7 Finset \u03b1 :=\n  (x.1 \u222a e \u2022 x.2, x.2 \u2229 e\u207b\u00b9 \u2022 x.1)", "start": [48, 1], "end": [53, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.mulDysonEtransform.subset", "code": "@[to_additive]\ntheorem mulDysonEtransform.subset :\n    (mulDysonEtransform e x).1 * (mulDysonEtransform e x).2 \u2286 x.1 * x.2", "start": [57, 1], "end": [61, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.mulDysonEtransform.card", "code": "@[to_additive]\ntheorem mulDysonEtransform.card :\n    (mulDysonEtransform e x).1.card + (mulDysonEtransform e x).2.card = x.1.card + x.2.card", "start": [65, 1], "end": [70, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.mulDysonEtransform_idem", "code": "@[to_additive (attr := simp)]\ntheorem mulDysonEtransform_idem :\n    mulDysonEtransform e (mulDysonEtransform e x) = mulDysonEtransform e x", "start": [74, 1], "end": [81, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.mulDysonEtransform.smul_finset_snd_subset_fst", "code": "@[to_additive]\ntheorem mulDysonEtransform.smul_finset_snd_subset_fst :\n    e \u2022 (mulDysonEtransform e x).2 \u2286 (mulDysonEtransform e x).1", "start": [87, 1], "end": [92, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.mulEtransformLeft", "code": "@[to_additive (attr := simps) \"An **e-transform**.\nTurns `(s, t)` into `(s \u2229 s +\u1d65 e, t \u222a -e +\u1d65 t)`. This reduces the sum of the two sets.\"]\ndef mulEtransformLeft : Finset \u03b1 \u00d7 Finset \u03b1 :=\n  (x.1 \u2229 op e \u2022 x.1, x.2 \u222a e\u207b\u00b9 \u2022 x.2)", "start": [113, 1], "end": [118, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.mulEtransformRight", "code": "@[to_additive (attr := simps) \"An **e-transform**.\nTurns `(s, t)` into `(s \u222a s +\u1d65 e, t \u2229 -e +\u1d65 t)`. This reduces the sum of the two sets.\"]\ndef mulEtransformRight : Finset \u03b1 \u00d7 Finset \u03b1 :=\n  (x.1 \u222a op e \u2022 x.1, x.2 \u2229 e\u207b\u00b9 \u2022 x.2)", "start": [122, 1], "end": [127, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.mulEtransformLeft_one", "code": "@[to_additive (attr := simp)]\ntheorem mulEtransformLeft_one : mulEtransformLeft 1 x = x", "start": [131, 1], "end": [132, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.mulEtransformRight_one", "code": "@[to_additive (attr := simp)]\ntheorem mulEtransformRight_one : mulEtransformRight 1 x = x", "start": [136, 1], "end": [137, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.mulEtransformLeft.fst_mul_snd_subset", "code": "@[to_additive]\ntheorem mulEtransformLeft.fst_mul_snd_subset :\n    (mulEtransformLeft e x).1 * (mulEtransformLeft e x).2 \u2286 x.1 * x.2", "start": [141, 1], "end": [145, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.mulEtransformRight.fst_mul_snd_subset", "code": "@[to_additive]\ntheorem mulEtransformRight.fst_mul_snd_subset :\n    (mulEtransformRight e x).1 * (mulEtransformRight e x).2 \u2286 x.1 * x.2", "start": [149, 1], "end": [153, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.mulEtransformLeft.card", "code": "@[to_additive]\ntheorem mulEtransformLeft.card :\n    (mulEtransformLeft e x).1.card + (mulEtransformRight e x).1.card = 2 * x.1.card", "start": [157, 1], "end": [160, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.mulEtransformRight.card", "code": "@[to_additive]\ntheorem mulEtransformRight.card :\n    (mulEtransformLeft e x).2.card + (mulEtransformRight e x).2.card = 2 * x.2.card", "start": [164, 1], "end": [167, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.MulEtransform.card", "code": "@[to_additive AddEtransform.card \"This statement is meant to be combined with\n`le_or_lt_of_add_le_add` and similar lemmas.\"]\nprotected theorem MulEtransform.card :\n    (mulEtransformLeft e x).1.card + (mulEtransformLeft e x).2.card +\n        ((mulEtransformRight e x).1.card + (mulEtransformRight e x).2.card) =\n      x.1.card + x.2.card + (x.1.card + x.2.card)", "start": [171, 1], "end": [178, 93], "kind": "commanddeclaration"}, {"full_name": "Finset.mulEtransformLeft_inv", "code": "@[to_additive (attr := simp)]\ntheorem mulEtransformLeft_inv : mulEtransformLeft e\u207b\u00b9 x = (mulEtransformRight e x.swap).swap", "start": [188, 1], "end": [190, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.mulEtransformRight_inv", "code": "@[to_additive (attr := simp)]\ntheorem mulEtransformRight_inv : mulEtransformRight e\u207b\u00b9 x = (mulEtransformLeft e x.swap).swap", "start": [194, 1], "end": [196, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecificLimits/IsROrC.lean", "imports": ["Mathlib/Analysis/Complex/ReImTopology.lean", "Mathlib/Analysis/SpecificLimits/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsROrC.tendsto_inverse_atTop_nhds_0_nat", "code": "theorem IsROrC.tendsto_inverse_atTop_nhds_0_nat :\n    Tendsto (fun n : \u2115 => (n : \ud835\udd5c)\u207b\u00b9) atTop (nhds 0)", "start": [18, 1], "end": [21, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Nat/Div.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Analysis/NormedSpace/Star/Matrix.lean", "imports": ["Mathlib/LinearAlgebra/UnitaryGroup.lean", "Mathlib/Data/IsROrC/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/NormedSpace/Basic.lean", "Mathlib/Analysis/Matrix.lean"], "premises": [{"full_name": "entry_norm_bound_of_unitary", "code": "theorem entry_norm_bound_of_unitary {U : Matrix n n \ud835\udd5c} (hU : U \u2208 Matrix.unitaryGroup n \ud835\udd5c)\n    (i j : n) : \u2016U i j\u2016 \u2264 1", "start": [30, 1], "end": [58, 17], "kind": "commanddeclaration"}, {"full_name": "entrywise_sup_norm_bound_of_unitary", "code": "theorem entrywise_sup_norm_bound_of_unitary {U : Matrix n n \ud835\udd5c} (hU : U \u2208 Matrix.unitaryGroup n \ud835\udd5c) :\n    \u2016U\u2016 \u2264 1", "start": [63, 1], "end": [71, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean", "imports": ["Mathlib/Algebra/Group/ConjFinite.lean", "Mathlib/GroupTheory/Subgroup/Simple.lean", "Mathlib/Tactic/IntervalCases.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/Perm/Fin.lean"], "premises": [{"full_name": "alternatingGroup", "code": "def alternatingGroup : Subgroup (Perm \u03b1) :=\n  sign.ker", "start": [48, 1], "end": [51, 11], "kind": "commanddeclaration"}, {"full_name": "fta", "code": "instance fta : Fintype (alternatingGroup \u03b1) :=\n  @Subtype.fintype _ _ sign.decidableMemKer _", "start": [55, 1], "end": [56, 46], "kind": "commanddeclaration"}, {"full_name": "alternatingGroup_eq_sign_ker", "code": "theorem alternatingGroup_eq_sign_ker : alternatingGroup \u03b1 = sign.ker", "start": [63, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mem_alternatingGroup", "code": "@[simp]\ntheorem mem_alternatingGroup {f : Perm \u03b1} : f \u2208 alternatingGroup \u03b1 \u2194 sign f = 1", "start": [69, 1], "end": [71, 15], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.prod_list_swap_mem_alternatingGroup_iff_even_length", "code": "theorem prod_list_swap_mem_alternatingGroup_iff_even_length {l : List (Perm \u03b1)}\n    (hl : \u2200 g \u2208 l, IsSwap g) : l.prod \u2208 alternatingGroup \u03b1 \u2194 Even l.length", "start": [74, 1], "end": [78, 9], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsThreeCycle.mem_alternatingGroup", "code": "theorem IsThreeCycle.mem_alternatingGroup {f : Perm \u03b1} (h : IsThreeCycle f) :\n    f \u2208 alternatingGroup \u03b1", "start": [81, 1], "end": [83, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.finRotate_bit1_mem_alternatingGroup", "code": "theorem finRotate_bit1_mem_alternatingGroup {n : \u2115} :\n    finRotate (bit1 n) \u2208 alternatingGroup (Fin (bit1 n))", "start": [87, 1], "end": [89, 90], "kind": "commanddeclaration"}, {"full_name": "two_mul_card_alternatingGroup", "code": "theorem two_mul_card_alternatingGroup [Nontrivial \u03b1] :\n    2 * card (alternatingGroup \u03b1) = card (Perm \u03b1)", "start": [94, 1], "end": [98, 66], "kind": "commanddeclaration"}, {"full_name": "alternatingGroup.normal", "code": "instance normal : (alternatingGroup \u03b1).Normal :=\n  sign.normal_ker", "start": [105, 1], "end": [106, 18], "kind": "commanddeclaration"}, {"full_name": "alternatingGroup.isConj_of", "code": "theorem isConj_of {\u03c3 \u03c4 : alternatingGroup \u03b1} (hc : IsConj (\u03c3 : Perm \u03b1) (\u03c4 : Perm \u03b1))\n    (h\u03c3 : (\u03c3 : Perm \u03b1).support.card + 2 \u2264 Fintype.card \u03b1) : IsConj \u03c3 \u03c4", "start": [109, 1], "end": [131, 23], "kind": "commanddeclaration"}, {"full_name": "alternatingGroup.isThreeCycle_isConj", "code": "theorem isThreeCycle_isConj (h5 : 5 \u2264 Fintype.card \u03b1) {\u03c3 \u03c4 : alternatingGroup \u03b1}\n    (h\u03c3 : IsThreeCycle (\u03c3 : Perm \u03b1)) (h\u03c4 : IsThreeCycle (\u03c4 : Perm \u03b1)) : IsConj \u03c3 \u03c4", "start": [134, 1], "end": [137, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.closure_three_cycles_eq_alternating", "code": "@[simp]\ntheorem closure_three_cycles_eq_alternating :\n    closure { \u03c3 : Perm \u03b1 | IsThreeCycle \u03c3 } = alternatingGroup \u03b1", "start": [146, 1], "end": [170, 90], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsThreeCycle.alternating_normalClosure", "code": "theorem IsThreeCycle.alternating_normalClosure (h5 : 5 \u2264 Fintype.card \u03b1) {f : Perm \u03b1}\n    (hf : IsThreeCycle f) :\n    normalClosure ({\u27e8f, hf.mem_alternatingGroup\u27e9} : Set (alternatingGroup \u03b1)) = \u22a4", "start": [173, 1], "end": [188, 94], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isThreeCycle_sq_of_three_mem_cycleType_five", "code": "theorem isThreeCycle_sq_of_three_mem_cycleType_five {g : Perm (Fin 5)} (h : 3 \u2208 cycleType g) :\n    IsThreeCycle (g * g)", "start": [191, 1], "end": [207, 38], "kind": "commanddeclaration"}, {"full_name": "alternatingGroup.nontrivial_of_three_le_card", "code": "theorem nontrivial_of_three_le_card (h3 : 3 \u2264 card \u03b1) : Nontrivial (alternatingGroup \u03b1)", "start": [216, 1], "end": [221, 47], "kind": "commanddeclaration"}, {"full_name": "alternatingGroup.normalClosure_finRotate_five", "code": "theorem normalClosure_finRotate_five : normalClosure ({\u27e8finRotate 5,\n    finRotate_bit1_mem_alternatingGroup (n := 2)\u27e9} : Set (alternatingGroup (Fin 5))) = \u22a4", "start": [230, 1], "end": [248, 100], "kind": "commanddeclaration"}, {"full_name": "alternatingGroup.normalClosure_swap_mul_swap_five", "code": "theorem normalClosure_swap_mul_swap_five :\n    normalClosure\n        ({\u27e8swap 0 4 * swap 1 3, mem_alternatingGroup.2 (by decide)\u27e9} :\n          Set (alternatingGroup (Fin 5))) =\n      \u22a4", "start": [251, 1], "end": [270, 76], "kind": "commanddeclaration"}, {"full_name": "alternatingGroup.isConj_swap_mul_swap_of_cycleType_two", "code": "theorem isConj_swap_mul_swap_of_cycleType_two {g : Perm (Fin 5)} (ha : g \u2208 alternatingGroup (Fin 5))\n    (h1 : g \u2260 1) (h2 : \u2200 n, n \u2208 cycleType (g : Perm (Fin 5)) \u2192 n = 2) :\n    IsConj (swap 0 4 * swap 1 3) g", "start": [273, 1], "end": [302, 15], "kind": "commanddeclaration"}, {"full_name": "alternatingGroup.isSimpleGroup_five", "code": "instance isSimpleGroup_five : IsSimpleGroup (alternatingGroup (Fin 5)) :=\n  \u27e8fun H => by\n    intro Hn\n    refine' or_not.imp id fun Hb => _\n    rw [eq_bot_iff_forall] at Hb\n    push_neg at Hb\n    obtain \u27e8\u27e8g, gA\u27e9, gH, g1\u27e9 : \u2203 x : \u21a5(alternatingGroup (Fin 5)), x \u2208 H \u2227 x \u2260 1 := Hb\n    rw [\u2190 SetLike.mem_coe, \u2190 Set.singleton_subset_iff] at gH\n    refine' eq_top_iff.2 (le_trans (ge_of_eq _) (normalClosure_le_normal gH))\n    by_cases h2 : \u2200 n \u2208 g.cycleType, n = 2\n    \u00b7 rw [Ne.def, Subtype.ext_iff] at g1\n      exact\n        (isConj_swap_mul_swap_of_cycleType_two gA g1 h2).normalClosure_eq_top_of\n          normalClosure_swap_mul_swap_five\n    push_neg at h2\n    obtain \u27e8n, ng, n2\u27e9 : \u2203 n : \u2115, n \u2208 g.cycleType \u2227 n \u2260 2 := h2\n    have n2' : 2 < n := lt_of_le_of_ne (two_le_of_mem_cycleType ng) n2.symm\n    have n5 : n \u2264 5 := le_trans ?_ g.support.card_le_univ\n    swap\n    \u00b7 obtain \u27e8m, hm\u27e9 := Multiset.exists_cons_of_mem ng\n      rw [\u2190 sum_cycleType, hm, Multiset.sum_cons]\n      exact le_add_right le_rfl\n    interval_cases n\n    \u00b7 rw [eq_top_iff, \u2190 (isThreeCycle_sq_of_three_mem_cycleType_five ng).alternating_normalClosure\n        (by rw [card_fin])]\n      refine' normalClosure_le_normal _\n      rw [Set.singleton_subset_iff, SetLike.mem_coe]\n      have h := SetLike.mem_coe.1 (subset_normalClosure\n        (G := alternatingGroup (Fin 5)) (Set.mem_singleton \u27e8g, gA\u27e9))\n      exact mul_mem h h\n    \u00b7 have con := mem_alternatingGroup.1 gA\n      contrapose! con\n      rw [sign_of_cycleType, cycleType_of_card_le_mem_cycleType_add_two (by decide) ng]\n      dsimp only\n      decide\n    \u00b7 refine' (isConj_iff_cycleType_eq.2 _).normalClosure_eq_top_of normalClosure_finRotate_five\n      rw [cycleType_of_card_le_mem_cycleType_add_two (by decide) ng, cycleType_finRotate]\u27e9", "start": [305, 1], "end": [354, 91], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/ModularForms/Basic.lean", "imports": ["Mathlib/Analysis/Complex/UpperHalfPlane/FunctionsBoundedAtInfty.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/Manifold.lean", "Mathlib/NumberTheory/ModularForms/SlashInvariantForms.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ModularForm", "code": "structure ModularForm extends SlashInvariantForm \u0393 k where\n  holo' : MDifferentiable \ud835\udcd8(\u2102) \ud835\udcd8(\u2102) (toSlashInvariantForm : \u210d \u2192 \u2102)\n  bdd_at_infty' : \u2200 A : SL(2, \u2124), IsBoundedAtImInfty (toSlashInvariantForm \u2223[k] A)", "start": [40, 1], "end": [43, 83], "kind": "commanddeclaration"}, {"full_name": "CuspForm", "code": "structure CuspForm extends SlashInvariantForm \u0393 k where\n  holo' : MDifferentiable \ud835\udcd8(\u2102) \ud835\udcd8(\u2102) (toSlashInvariantForm : \u210d \u2192 \u2102)\n  zero_at_infty' : \u2200 A : SL(2, \u2124), IsZeroAtImInfty (toSlashInvariantForm \u2223[k] A)", "start": [49, 1], "end": [52, 81], "kind": "commanddeclaration"}, {"full_name": "ModularFormClass", "code": "class ModularFormClass (F : Type*) (\u0393 : outParam <| Subgroup (SL(2, \u2124))) (k : outParam \u2124)\n    extends SlashInvariantFormClass F \u0393 k where\n  holo : \u2200 f : F, MDifferentiable \ud835\udcd8(\u2102) \ud835\udcd8(\u2102) (f : \u210d \u2192 \u2102)\n  bdd_at_infty : \u2200 (f : F) (A : SL(2, \u2124)), IsBoundedAtImInfty (f \u2223[k] A)", "start": [58, 1], "end": [64, 73], "kind": "commanddeclaration"}, {"full_name": "CuspFormClass", "code": "class CuspFormClass (F : Type*) (\u0393 : outParam <| Subgroup (SL(2, \u2124))) (k : outParam \u2124)\n    extends SlashInvariantFormClass F \u0393 k where\n  holo : \u2200 f : F, MDifferentiable \ud835\udcd8(\u2102) \ud835\udcd8(\u2102) (f : \u210d \u2192 \u2102)\n  zero_at_infty : \u2200 (f : F) (A : SL(2, \u2124)), IsZeroAtImInfty (f \u2223[k] A)", "start": [67, 1], "end": [73, 71], "kind": "commanddeclaration"}, {"full_name": "ModularFormClass.modularForm", "code": "instance (priority := 100) ModularFormClass.modularForm :\n    ModularFormClass (ModularForm \u0393 k) \u0393 k where\n  coe f := f.toFun\n  coe_injective' f g h := by cases f; cases g; congr; exact FunLike.ext' h\n  slash_action_eq f := f.slash_action_eq'\n  holo := ModularForm.holo'\n  bdd_at_infty := ModularForm.bdd_at_infty'", "start": [76, 1], "end": [82, 44], "kind": "commanddeclaration"}, {"full_name": "CuspFormClass.cuspForm", "code": "instance (priority := 100) CuspFormClass.cuspForm : CuspFormClass (CuspForm \u0393 k) \u0393 k where\n  coe f := f.toFun\n  coe_injective' f g h := by cases f; cases g; congr; exact FunLike.ext' h\n  slash_action_eq f := f.slash_action_eq'\n  holo := CuspForm.holo'\n  zero_at_infty := CuspForm.zero_at_infty'", "start": [85, 1], "end": [90, 43], "kind": "commanddeclaration"}, {"full_name": "ModularForm.toFun_eq_coe", "code": "theorem ModularForm.toFun_eq_coe (f : ModularForm \u0393 k) : f.toFun = (f : \u210d \u2192 \u2102)", "start": [95, 1], "end": [96, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.toSlashInvariantForm_coe", "code": "@[simp]\ntheorem ModularForm.toSlashInvariantForm_coe (f : ModularForm \u0393 k) : \u21d1f.1 = f", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "CuspForm.toFun_eq_coe", "code": "theorem CuspForm.toFun_eq_coe {f : CuspForm \u0393 k} : f.toFun = (f : \u210d \u2192 \u2102)", "start": [103, 1], "end": [104, 6], "kind": "commanddeclaration"}, {"full_name": "CuspForm.toSlashInvariantForm_coe", "code": "@[simp]\ntheorem CuspForm.toSlashInvariantForm_coe (f : CuspForm \u0393 k) : \u21d1f.1 = f", "start": [107, 1], "end": [108, 79], "kind": "commanddeclaration"}, {"full_name": "ModularForm.ext", "code": "@[ext]\ntheorem ModularForm.ext {f g : ModularForm \u0393 k} (h : \u2200 x, f x = g x) : f = g", "start": [110, 1], "end": [112, 20], "kind": "commanddeclaration"}, {"full_name": "CuspForm.ext", "code": "@[ext]\ntheorem CuspForm.ext {f g : CuspForm \u0393 k} (h : \u2200 x, f x = g x) : f = g", "start": [115, 1], "end": [117, 20], "kind": "commanddeclaration"}, {"full_name": "ModularForm.copy", "code": "protected def ModularForm.copy (f : ModularForm \u0393 k) (f' : \u210d \u2192 \u2102) (h : f' = \u21d1f) :\n    ModularForm \u0393 k where\n  toSlashInvariantForm := f.1.copy f' h\n  holo' := h.symm \u25b8 f.holo'\n  bdd_at_infty' A := h.symm \u25b8 f.bdd_at_infty' A", "start": [120, 1], "end": [126, 48], "kind": "commanddeclaration"}, {"full_name": "CuspForm.copy", "code": "protected def CuspForm.copy (f : CuspForm \u0393 k) (f' : \u210d \u2192 \u2102) (h : f' = \u21d1f) : CuspForm \u0393 k where\n  toSlashInvariantForm := f.1.copy f' h\n  holo' := h.symm \u25b8 f.holo'\n  zero_at_infty' A := h.symm \u25b8 f.zero_at_infty' A", "start": [129, 1], "end": [134, 50], "kind": "commanddeclaration"}, {"full_name": "ModularForm.add", "code": "instance add : Add (ModularForm \u0393 k) :=\n  \u27e8fun f g =>\n    { toSlashInvariantForm := f + g\n      holo' := f.holo'.add g.holo'\n      bdd_at_infty' := fun A => by simpa using (f.bdd_at_infty' A).add (g.bdd_at_infty' A) }\u27e9", "start": [145, 1], "end": [149, 94], "kind": "commanddeclaration"}, {"full_name": "ModularForm.coe_add", "code": "@[simp]\ntheorem coe_add (f g : ModularForm \u0393 k) : \u21d1(f + g) = f + g", "start": [152, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.add_apply", "code": "@[simp]\ntheorem add_apply (f g : ModularForm \u0393 k) (z : \u210d) : (f + g) z = f z + g z", "start": [157, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.instZero", "code": "instance instZero : Zero (ModularForm \u0393 k) :=\n  \u27e8 { toSlashInvariantForm := 0\n      holo' := fun _ => mdifferentiableAt_const \ud835\udcd8(\u2102, \u2102) \ud835\udcd8(\u2102, \u2102)\n      bdd_at_infty' := fun A => by simpa using zero_form_isBoundedAtImInfty } \u27e9", "start": [162, 1], "end": [165, 80], "kind": "commanddeclaration"}, {"full_name": "ModularForm.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : ModularForm \u0393 k) = (0 : \u210d \u2192 \u2102)", "start": [168, 1], "end": [170, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.zero_apply", "code": "@[simp]\ntheorem zero_apply (z : \u210d) : (0 : ModularForm \u0393 k) z = 0", "start": [173, 1], "end": [175, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.instSMul", "code": "instance instSMul : SMul \u03b1 (ModularForm \u0393 k) :=\n  \u27e8fun c f =>\n    { toSlashInvariantForm := c \u2022 f.1\n      holo' := by simpa using f.holo'.const_smul (c \u2022 (1 : \u2102))\n      bdd_at_infty' := fun A => by simpa using (f.bdd_at_infty' A).const_smul_left (c \u2022 (1 : \u2102)) }\u27e9", "start": [182, 1], "end": [186, 100], "kind": "commanddeclaration"}, {"full_name": "ModularForm.coe_smul", "code": "@[simp]\ntheorem coe_smul (f : ModularForm \u0393 k) (n : \u03b1) : \u21d1(n \u2022 f) = n \u2022 \u21d1f", "start": [189, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.smul_apply", "code": "@[simp]\ntheorem smul_apply (f : ModularForm \u0393 k) (n : \u03b1) (z : \u210d) : (n \u2022 f) z = n \u2022 f z", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.instNeg", "code": "instance instNeg : Neg (ModularForm \u0393 k) :=\n  \u27e8fun f =>\n    { toSlashInvariantForm := -f.1\n      holo' := f.holo'.neg\n      bdd_at_infty' := fun A => by simpa using (f.bdd_at_infty' A).neg }\u27e9", "start": [201, 1], "end": [205, 74], "kind": "commanddeclaration"}, {"full_name": "ModularForm.coe_neg", "code": "@[simp]\ntheorem coe_neg (f : ModularForm \u0393 k) : \u21d1(-f) = -f", "start": [208, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.neg_apply", "code": "@[simp]\ntheorem neg_apply (f : ModularForm \u0393 k) (z : \u210d) : (-f) z = -f z", "start": [213, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.instSub", "code": "instance instSub : Sub (ModularForm \u0393 k) :=\n  \u27e8fun f g => f + -g\u27e9", "start": [218, 1], "end": [219, 22], "kind": "commanddeclaration"}, {"full_name": "ModularForm.coe_sub", "code": "@[simp]\ntheorem coe_sub (f g : ModularForm \u0393 k) : \u21d1(f - g) = f - g", "start": [222, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.sub_apply", "code": "@[simp]\ntheorem sub_apply (f g : ModularForm \u0393 k) (z : \u210d) : (f - g) z = f z - g z", "start": [227, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.coeHom", "code": "@[simps]\ndef coeHom : ModularForm \u0393 k \u2192+ \u210d \u2192 \u2102 where\n  toFun f := f\n  map_zero' := coe_zero\n  map_add' _ _ := rfl", "start": [235, 1], "end": [240, 22], "kind": "commanddeclaration"}, {"full_name": "ModularForm.mul", "code": "def mul {k_1 k_2 : \u2124} {\u0393 : Subgroup SL(2, \u2124)} (f : ModularForm \u0393 k_1) (g : ModularForm \u0393 k_2) :\n    ModularForm \u0393 (k_1 + k_2) where\n  toSlashInvariantForm := f.1.mul g.1\n  holo' := f.holo'.mul g.holo'\n  bdd_at_infty' A := by\n    rw [SlashInvariantForm.coe_mul, mul_slash_SL2]\n    exact (f.bdd_at_infty' A).mul (g.bdd_at_infty' A)", "start": [249, 1], "end": [259, 54], "kind": "commanddeclaration"}, {"full_name": "ModularForm.mul_coe", "code": "@[simp]\ntheorem mul_coe {k_1 k_2 : \u2124} {\u0393 : Subgroup SL(2, \u2124)} (f : ModularForm \u0393 k_1)\n    (g : ModularForm \u0393 k_2) : (f.mul g : \u210d \u2192 \u2102) = f * g", "start": [262, 1], "end": [265, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.one_coe_eq_one", "code": "@[simp]\ntheorem one_coe_eq_one : ((1 : ModularForm \u0393 0) : \u210d \u2192 \u2102) = 1", "start": [275, 1], "end": [277, 6], "kind": "commanddeclaration"}, {"full_name": "CuspForm.hasAdd", "code": "instance hasAdd : Add (CuspForm \u0393 k) :=\n  \u27e8fun f g =>\n    { toSlashInvariantForm := f + g\n      holo' := f.holo'.add g.holo'\n      zero_at_infty' := fun A => by simpa using (f.zero_at_infty' A).add (g.zero_at_infty' A) }\u27e9", "start": [288, 1], "end": [292, 97], "kind": "commanddeclaration"}, {"full_name": "CuspForm.coe_add", "code": "@[simp]\ntheorem coe_add (f g : CuspForm \u0393 k) : \u21d1(f + g) = f + g", "start": [295, 1], "end": [297, 6], "kind": "commanddeclaration"}, {"full_name": "CuspForm.add_apply", "code": "@[simp]\ntheorem add_apply (f g : CuspForm \u0393 k) (z : \u210d) : (f + g) z = f z + g z", "start": [300, 1], "end": [302, 6], "kind": "commanddeclaration"}, {"full_name": "CuspForm.instZero", "code": "instance instZero : Zero (CuspForm \u0393 k) :=\n  \u27e8 { toSlashInvariantForm := 0\n      holo' := fun _ => mdifferentiableAt_const \ud835\udcd8(\u2102, \u2102) \ud835\udcd8(\u2102, \u2102)\n      zero_at_infty' := by simpa using Filter.zero_zeroAtFilter _ } \u27e9", "start": [305, 1], "end": [308, 70], "kind": "commanddeclaration"}, {"full_name": "CuspForm.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : CuspForm \u0393 k) = (0 : \u210d \u2192 \u2102)", "start": [311, 1], "end": [313, 6], "kind": "commanddeclaration"}, {"full_name": "CuspForm.zero_apply", "code": "@[simp]\ntheorem zero_apply (z : \u210d) : (0 : CuspForm \u0393 k) z = 0", "start": [316, 1], "end": [318, 6], "kind": "commanddeclaration"}, {"full_name": "CuspForm.instSMul", "code": "instance instSMul : SMul \u03b1 (CuspForm \u0393 k) :=\n  \u27e8fun c f =>\n    { toSlashInvariantForm := c \u2022 f.1\n      holo' := by simpa using f.holo'.const_smul (c \u2022 (1 : \u2102))\n      zero_at_infty' := fun A => by simpa using (f.zero_at_infty' A).smul (c \u2022 (1 : \u2102)) }\u27e9", "start": [325, 1], "end": [329, 91], "kind": "commanddeclaration"}, {"full_name": "CuspForm.coe_smul", "code": "@[simp]\ntheorem coe_smul (f : CuspForm \u0393 k) (n : \u03b1) : \u21d1(n \u2022 f) = n \u2022 \u21d1f", "start": [332, 1], "end": [334, 6], "kind": "commanddeclaration"}, {"full_name": "CuspForm.smul_apply", "code": "@[simp]\ntheorem smul_apply (f : CuspForm \u0393 k) (n : \u03b1) {z : \u210d} : (n \u2022 f) z = n \u2022 f z", "start": [337, 1], "end": [339, 6], "kind": "commanddeclaration"}, {"full_name": "CuspForm.instNeg", "code": "instance instNeg : Neg (CuspForm \u0393 k) :=\n  \u27e8fun f =>\n    { toSlashInvariantForm := -f.1\n      holo' := f.holo'.neg\n      zero_at_infty' := fun A => by simpa using (f.zero_at_infty' A).neg }\u27e9", "start": [344, 1], "end": [348, 76], "kind": "commanddeclaration"}, {"full_name": "CuspForm.coe_neg", "code": "@[simp]\ntheorem coe_neg (f : CuspForm \u0393 k) : \u21d1(-f) = -f", "start": [351, 1], "end": [353, 6], "kind": "commanddeclaration"}, {"full_name": "CuspForm.neg_apply", "code": "@[simp]\ntheorem neg_apply (f : CuspForm \u0393 k) (z : \u210d) : (-f) z = -f z", "start": [356, 1], "end": [358, 6], "kind": "commanddeclaration"}, {"full_name": "CuspForm.instSub", "code": "instance instSub : Sub (CuspForm \u0393 k) :=\n  \u27e8fun f g => f + -g\u27e9", "start": [361, 1], "end": [362, 22], "kind": "commanddeclaration"}, {"full_name": "CuspForm.coe_sub", "code": "@[simp]\ntheorem coe_sub (f g : CuspForm \u0393 k) : \u21d1(f - g) = f - g", "start": [365, 1], "end": [367, 6], "kind": "commanddeclaration"}, {"full_name": "CuspForm.sub_apply", "code": "@[simp]\ntheorem sub_apply (f g : CuspForm \u0393 k) (z : \u210d) : (f - g) z = f z - g z", "start": [370, 1], "end": [372, 6], "kind": "commanddeclaration"}, {"full_name": "CuspForm.coeHom", "code": "@[simps]\ndef coeHom : CuspForm \u0393 k \u2192+ \u210d \u2192 \u2102 where\n  toFun f := f\n  map_zero' := CuspForm.coe_zero\n  map_add' _ _ := rfl", "start": [378, 1], "end": [383, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Positive/Field.lean", "imports": ["Mathlib/Algebra/Order/Positive/Ring.lean", "Mathlib/Algebra/Order/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Positive.Subtype.inv", "code": "instance Subtype.inv : Inv { x : K // 0 < x } :=\n  \u27e8fun x => \u27e8x\u207b\u00b9, inv_pos.2 x.2\u27e9\u27e9", "start": [23, 1], "end": [24, 34], "kind": "commanddeclaration"}, {"full_name": "Positive.coe_inv", "code": "@[simp]\ntheorem coe_inv (x : { x : K // 0 < x }) : \u2191x\u207b\u00b9 = (x\u207b\u00b9 : K)", "start": [26, 1], "end": [28, 6], "kind": "commanddeclaration"}, {"full_name": "Positive.coe_zpow", "code": "@[simp]\ntheorem coe_zpow (x : { x : K // 0 < x }) (n : \u2124) : \u2191(x ^ n) = (x : K) ^ n", "start": [34, 1], "end": [36, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Choose/Bounds.lean", "imports": ["Mathlib/Algebra/GroupPower/Lemmas.lean", "Mathlib/Data/Nat/Choose/Basic.lean", "Mathlib/Algebra/Order/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.choose_le_pow", "code": "theorem choose_le_pow (r n : \u2115) : (n.choose r : \u03b1) \u2264 (n ^ r : \u03b1) / r !", "start": [31, 1], "end": [36, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_le_choose", "code": "theorem pow_le_choose (r n : \u2115) : ((n + 1 - r : \u2115) ^ r : \u03b1) / r ! \u2264 n.choose r", "start": [40, 1], "end": [45, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Hindman.lean", "imports": ["Mathlib/Topology/Algebra/Semigroup.lean", "Mathlib/Topology/StoneCech.lean", "Mathlib/Data/Stream/Init.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ultrafilter.mul", "code": "@[to_additive\n      \"Addition of ultrafilters given by `\u2200\u1da0 m in U+V, p m \u2194 \u2200\u1da0 m in U, \u2200\u1da0 m' in V, p (m+m')`.\"]\ndef Ultrafilter.mul {M} [Mul M] : Mul (Ultrafilter M) where mul U V := (\u00b7 * \u00b7) <$> U <*> V", "start": [48, 1], "end": [51, 91], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.eventually_mul", "code": "@[to_additive]\ntheorem Ultrafilter.eventually_mul {M} [Mul M] (U V : Ultrafilter M) (p : M \u2192 Prop) :\n    (\u2200\u1da0 m in \u2191(U * V), p m) \u2194 \u2200\u1da0 m in U, \u2200\u1da0 m' in V, p (m * m')", "start": [59, 1], "end": [62, 10], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.semigroup", "code": "@[to_additive\n      \"Additive semigroup structure on `Ultrafilter M` induced by an additive semigroup\n      structure on `M`.\"]\ndef Ultrafilter.semigroup {M} [Semigroup M] : Semigroup (Ultrafilter M) :=\n  { Ultrafilter.mul with\n    mul_assoc := fun U V W =>\n      Ultrafilter.coe_inj.mp <|\n        Filter.ext' fun p => by simp_rw [Ultrafilter.eventually_mul, mul_assoc] }", "start": [66, 1], "end": [75, 82], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.continuous_mul_left", "code": "@[to_additive]\ntheorem Ultrafilter.continuous_mul_left {M} [Semigroup M] (V : Ultrafilter M) :\n    Continuous (\u00b7 * V)", "start": [82, 1], "end": [86, 98], "kind": "commanddeclaration"}, {"full_name": "Hindman.FS", "code": "inductive FS {M} [AddSemigroup M] : Stream' M \u2192 Set M\n  | head (a : Stream' M) : FS a a.head\n  | tail (a : Stream' M) (m : M) (h : FS a.tail m) : FS a m\n  | cons (a : Stream' M) (m : M) (h : FS a.tail m) : FS a (a.head + m)", "start": [95, 1], "end": [100, 71], "kind": "commanddeclaration"}, {"full_name": "Hindman.FP", "code": "@[to_additive FS]\ninductive FP {M} [Semigroup M] : Stream' M \u2192 Set M\n  | head (a : Stream' M) : FP a a.head\n  | tail (a : Stream' M) (m : M) (h : FP a.tail m) : FP a m\n  | cons (a : Stream' M) (m : M) (h : FP a.tail m) : FP a (a.head * m)", "start": [104, 1], "end": [110, 71], "kind": "commanddeclaration"}, {"full_name": "Hindman.FP.mul", "code": "@[to_additive\n      \"If `m` and `m'` are finite sums in `M`, then so is `m + m'`, provided that `m'`\n      is obtained from a subsequence of `M` starting sufficiently late.\"]\ntheorem FP.mul {M} [Semigroup M] {a : Stream' M} {m : M} (hm : m \u2208 FP a) :\n    \u2203 n, \u2200 m' \u2208 FP (a.drop n), m * m' \u2208 FP a", "start": [114, 1], "end": [131, 33], "kind": "commanddeclaration"}, {"full_name": "Hindman.exists_idempotent_ultrafilter_le_FP", "code": "@[to_additive exists_idempotent_ultrafilter_le_FS]\ntheorem exists_idempotent_ultrafilter_le_FP {M} [Semigroup M] (a : Stream' M) :\n    \u2203 U : Ultrafilter M, U * U = U \u2227 \u2200\u1da0 m in U, m \u2208 FP a", "start": [137, 1], "end": [167, 45], "kind": "commanddeclaration"}, {"full_name": "Hindman.exists_FP_of_large", "code": "@[to_additive exists_FS_of_large]\ntheorem exists_FP_of_large {M} [Semigroup M] (U : Ultrafilter M) (U_idem : U * U = U) (s\u2080 : Set M)\n    (sU : s\u2080 \u2208 U) : \u2203 a, FP a \u2286 s\u2080", "start": [173, 1], "end": [206, 45], "kind": "commanddeclaration"}, {"full_name": "Hindman.FP_partition_regular", "code": "@[to_additive FS_partition_regular\n      \"The strong form of **Hindman's theorem**: in any finite cover of\n      an FS-set, one the parts contains an FS-set.\"]\ntheorem FP_partition_regular {M} [Semigroup M] (a : Stream' M) (s : Set (Set M)) (sfin : s.Finite)\n    (scov : FP a \u2286 \u22c3\u2080 s) : \u2203 c \u2208 s, \u2203 b : Stream' M, FP b \u2286 c", "start": [212, 1], "end": [221, 42], "kind": "commanddeclaration"}, {"full_name": "Hindman.exists_FP_of_finite_cover", "code": "@[to_additive exists_FS_of_finite_cover\n      \"The weak form of **Hindman's theorem**: in any finite cover\n      of a nonempty additive semigroup, one of the parts contains an FS-set.\"]\ntheorem exists_FP_of_finite_cover {M} [Semigroup M] [Nonempty M] (s : Set (Set M)) (sfin : s.Finite)\n    (scov : \u22a4 \u2286 \u22c3\u2080 s) : \u2203 c \u2208 s, \u2203 a : Stream' M, FP a \u2286 c", "start": [227, 1], "end": [237, 41], "kind": "commanddeclaration"}, {"full_name": "Hindman.FP_drop_subset_FP", "code": "@[to_additive FS_iter_tail_sub_FS]\ntheorem FP_drop_subset_FP {M} [Semigroup M] (a : Stream' M) (n : \u2115) : FP (a.drop n) \u2286 FP a", "start": [243, 1], "end": [248, 36], "kind": "commanddeclaration"}, {"full_name": "Hindman.FP.singleton", "code": "@[to_additive]\ntheorem FP.singleton {M} [Semigroup M] (a : Stream' M) (i : \u2115) : a.get i \u2208 FP a", "start": [254, 1], "end": [259, 13], "kind": "commanddeclaration"}, {"full_name": "Hindman.FP.mul_two", "code": "@[to_additive]\ntheorem FP.mul_two {M} [Semigroup M] (a : Stream' M) (i j : \u2115) (ij : i < j) :\n    a.get i * a.get j \u2208 FP a", "start": [265, 1], "end": [277, 48], "kind": "commanddeclaration"}, {"full_name": "Hindman.FP.finset_prod", "code": "@[to_additive]\ntheorem FP.finset_prod {M} [CommMonoid M] (a : Stream' M) (s : Finset \u2115) (hs : s.Nonempty) :\n    (s.prod fun i => a.get i) \u2208 FP a", "start": [283, 1], "end": [299, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Intervals.lean", "imports": ["Mathlib/Data/List/Range.lean", "Mathlib/Data/Bool/Basic.lean", "Mathlib/Data/List/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.Ico", "code": "def Ico (n m : \u2115) : List \u2115 :=\n  range' n (m - n)", "start": [30, 1], "end": [37, 19], "kind": "commanddeclaration"}, {"full_name": "List.Ico.zero_bot", "code": "theorem zero_bot (n : \u2115) : Ico 0 n = range n", "start": [42, 1], "end": [42, 88], "kind": "commanddeclaration"}, {"full_name": "List.Ico.length", "code": "@[simp]\ntheorem length (n m : \u2115) : length (Ico n m) = m - n", "start": [45, 1], "end": [48, 28], "kind": "commanddeclaration"}, {"full_name": "List.Ico.pairwise_lt", "code": "theorem pairwise_lt (n m : \u2115) : Pairwise (\u00b7 < \u00b7) (Ico n m)", "start": [51, 1], "end": [53, 33], "kind": "commanddeclaration"}, {"full_name": "List.Ico.nodup", "code": "theorem nodup (n m : \u2115) : Nodup (Ico n m)", "start": [56, 1], "end": [58, 27], "kind": "commanddeclaration"}, {"full_name": "List.Ico.mem", "code": "@[simp]\ntheorem mem {n m l : \u2115} : l \u2208 Ico n m \u2194 n \u2264 l \u2227 l < m", "start": [61, 1], "end": [69, 93], "kind": "commanddeclaration"}, {"full_name": "List.Ico.eq_nil_of_le", "code": "theorem eq_nil_of_le {n m : \u2115} (h : m \u2264 n) : Ico n m = []", "start": [72, 1], "end": [73, 40], "kind": "commanddeclaration"}, {"full_name": "List.Ico.map_add", "code": "theorem map_add (n m k : \u2115) : (Ico n m).map ((\u00b7 + \u00b7) k) = Ico (n + k) (m + k)", "start": [76, 1], "end": [77, 78], "kind": "commanddeclaration"}, {"full_name": "List.Ico.map_sub", "code": "theorem map_sub (n m k : \u2115) (h\u2081 : k \u2264 n) :\n    ((Ico n m).map fun x => x - k) = Ico (n - k) (m - k)", "start": [80, 1], "end": [82, 73], "kind": "commanddeclaration"}, {"full_name": "List.Ico.self_empty", "code": "@[simp]\ntheorem self_empty {n : \u2115} : Ico n n = []", "start": [85, 1], "end": [87, 27], "kind": "commanddeclaration"}, {"full_name": "List.Ico.eq_empty_iff", "code": "@[simp]\ntheorem eq_empty_iff {n m : \u2115} : Ico n m = [] \u2194 m \u2264 n", "start": [90, 1], "end": [92, 95], "kind": "commanddeclaration"}, {"full_name": "List.Ico.append_consecutive", "code": "theorem append_consecutive {n m l : \u2115} (hnm : n \u2264 m) (hml : m \u2264 l) :\n    Ico n m ++ Ico m l = Ico n l", "start": [95, 1], "end": [100, 38], "kind": "commanddeclaration"}, {"full_name": "List.Ico.inter_consecutive", "code": "@[simp]\ntheorem inter_consecutive (n m l : \u2115) : Ico n m \u2229 Ico m l = []", "start": [103, 1], "end": [110, 27], "kind": "commanddeclaration"}, {"full_name": "List.Ico.bagInter_consecutive", "code": "@[simp]\ntheorem bagInter_consecutive (n m l : Nat) :  @List.bagInter \u2115 instBEq (Ico n m) (Ico m l) = []", "start": [113, 1], "end": [115, 63], "kind": "commanddeclaration"}, {"full_name": "List.Ico.succ_singleton", "code": "@[simp]\ntheorem succ_singleton {n : \u2115} : Ico n (n + 1) = [n]", "start": [118, 1], "end": [121, 38], "kind": "commanddeclaration"}, {"full_name": "List.Ico.succ_top", "code": "theorem succ_top {n m : \u2115} (h : n \u2264 m) : Ico n (m + 1) = Ico n m ++ [m]", "start": [124, 1], "end": [126, 22], "kind": "commanddeclaration"}, {"full_name": "List.Ico.eq_cons", "code": "theorem eq_cons {n m : \u2115} (h : n < m) : Ico n m = n :: Ico (n + 1) m", "start": [129, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "List.Ico.pred_singleton", "code": "@[simp]\ntheorem pred_singleton {m : \u2115} (h : 0 < m) : Ico (m - 1) m = [m - 1]", "start": [134, 1], "end": [138, 32], "kind": "commanddeclaration"}, {"full_name": "List.Ico.chain'_succ", "code": "theorem chain'_succ (n m : \u2115) : Chain' (fun a b => b = succ a) (Ico n m)", "start": [142, 1], "end": [147, 12], "kind": "commanddeclaration"}, {"full_name": "List.Ico.not_mem_top", "code": "theorem not_mem_top {n m : \u2115} : m \u2209 Ico n m", "start": [152, 1], "end": [152, 55], "kind": "commanddeclaration"}, {"full_name": "List.Ico.filter_lt_of_top_le", "code": "theorem filter_lt_of_top_le {n m l : \u2115} (hml : m \u2264 l) :\n    ((Ico n m).filter fun x => x < l) = Ico n m", "start": [155, 1], "end": [158, 63], "kind": "commanddeclaration"}, {"full_name": "List.Ico.filter_lt_of_le_bot", "code": "theorem filter_lt_of_le_bot {n m l : \u2115} (hln : l \u2264 n) : ((Ico n m).filter fun x => x < l) = []", "start": [161, 1], "end": [165, 24], "kind": "commanddeclaration"}, {"full_name": "List.Ico.filter_lt_of_ge", "code": "theorem filter_lt_of_ge {n m l : \u2115} (hlm : l \u2264 m) :\n    ((Ico n m).filter fun x => x < l) = Ico n l", "start": [168, 1], "end": [173, 51], "kind": "commanddeclaration"}, {"full_name": "List.Ico.filter_lt", "code": "@[simp]\ntheorem filter_lt (n m l : \u2115) :\n    ((Ico n m).filter fun x => x < l) = Ico n (min m l)", "start": [176, 1], "end": [181, 47], "kind": "commanddeclaration"}, {"full_name": "List.Ico.filter_le_of_le_bot", "code": "theorem filter_le_of_le_bot {n m l : \u2115} (hln : l \u2264 n) :\n    ((Ico n m).filter fun x => l \u2264 x) = Ico n m", "start": [184, 1], "end": [188, 36], "kind": "commanddeclaration"}, {"full_name": "List.Ico.filter_le_of_top_le", "code": "theorem filter_le_of_top_le {n m l : \u2115} (hml : m \u2264 l) : ((Ico n m).filter fun x => l \u2264 x) = []", "start": [191, 1], "end": [194, 57], "kind": "commanddeclaration"}, {"full_name": "List.Ico.filter_le_of_le", "code": "theorem filter_le_of_le {n m l : \u2115} (hnl : n \u2264 l) :\n    ((Ico n m).filter fun x => l \u2264 x) = Ico l m", "start": [197, 1], "end": [202, 51], "kind": "commanddeclaration"}, {"full_name": "List.Ico.filter_le", "code": "@[simp]\ntheorem filter_le (n m l : \u2115) : ((Ico n m).filter fun x => l \u2264 x) = Ico (max n l) m", "start": [205, 1], "end": [209, 50], "kind": "commanddeclaration"}, {"full_name": "List.Ico.filter_lt_of_succ_bot", "code": "theorem filter_lt_of_succ_bot {n m : \u2115} (hnm : n < m) :\n    ((Ico n m).filter fun x => x < n + 1) = [n]", "start": [212, 1], "end": [215, 34], "kind": "commanddeclaration"}, {"full_name": "List.Ico.filter_le_of_bot", "code": "@[simp]\ntheorem filter_le_of_bot {n m : \u2115} (hnm : n < m) : ((Ico n m).filter fun x => x \u2264 n) = [n]", "start": [218, 1], "end": [223, 27], "kind": "commanddeclaration"}, {"full_name": "List.Ico.trichotomy", "code": "theorem trichotomy (n a b : \u2115) : n < a \u2228 b \u2264 n \u2228 n \u2208 Ico a b", "start": [226, 1], "end": [241, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/LegendreSymbol/GaussEisensteinLemmas.lean", "imports": ["Mathlib/NumberTheory/LegendreSymbol/QuadraticReciprocity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ZMod.Ico_map_valMinAbs_natAbs_eq_Ico_map_id", "code": "theorem Ico_map_valMinAbs_natAbs_eq_Ico_map_id (p : \u2115) [hp : Fact p.Prime] (a : ZMod p)\n    (hap : a \u2260 0) : ((Ico 1 (p / 2).succ).1.map fun (x : \u2115) => (a * x).valMinAbs.natAbs) =\n    (Ico 1 (p / 2).succ).1.map fun a => a", "start": [28, 1], "end": [62, 61], "kind": "commanddeclaration"}, {"full_name": "ZMod.gauss_lemma_aux\u2081", "code": "private theorem gauss_lemma_aux\u2081 (p : \u2115) [Fact p.Prime] {a : \u2124}\n    (hap : (a : ZMod p) \u2260 0) : (a ^ (p / 2) * (p / 2)! : ZMod p) =\n    (-1 : ZMod p) ^ ((Ico 1 (p / 2).succ).filter fun x : \u2115 =>\n      \u00ac(a * x : ZMod p).val \u2264 p / 2).card * (p / 2)!", "start": [65, 1], "end": [94, 34], "kind": "commanddeclaration"}, {"full_name": "ZMod.gauss_lemma_aux", "code": "theorem gauss_lemma_aux (p : \u2115) [hp : Fact p.Prime] {a : \u2124}\n    (hap : (a : ZMod p) \u2260 0) : (\u2191a ^ (p / 2) : ZMod p) =\n    (-1) ^ ((Ico 1 (p / 2).succ).filter fun x : \u2115 => p / 2 < (a * x : ZMod p).val).card", "start": [96, 1], "end": [102, 41], "kind": "commanddeclaration"}, {"full_name": "ZMod.gauss_lemma", "code": "theorem gauss_lemma {p : \u2115} [h : Fact p.Prime] {a : \u2124} (hp : p \u2260 2) (ha0 : (a : ZMod p) \u2260 0) :\n    legendreSym p a = (-1) ^ ((Ico 1 (p / 2).succ).filter fun x : \u2115 =>\n      p / 2 < (a * x : ZMod p).val).card", "start": [105, 1], "end": [117, 75], "kind": "commanddeclaration"}, {"full_name": "ZMod.eisenstein_lemma_aux\u2081", "code": "private theorem eisenstein_lemma_aux\u2081 (p : \u2115) [Fact p.Prime] [hp2 : Fact (p % 2 = 1)] {a : \u2115}\n    (hap : (a : ZMod p) \u2260 0) : ((\u2211 x in Ico 1 (p / 2).succ, a * x : \u2115) : ZMod 2) =\n    ((Ico 1 (p / 2).succ).filter fun x : \u2115 => p / 2 < (a * x : ZMod p).val).card +\n      \u2211 x in Ico 1 (p / 2).succ, x + (\u2211 x in Ico 1 (p / 2).succ, a * x / p : \u2115)", "start": [120, 1], "end": [146, 12], "kind": "commanddeclaration"}, {"full_name": "ZMod.eisenstein_lemma_aux", "code": "theorem eisenstein_lemma_aux (p : \u2115) [Fact p.Prime] [Fact (p % 2 = 1)] {a : \u2115} (ha2 : a % 2 = 1)\n    (hap : (a : ZMod p) \u2260 0) :\n    ((Ico 1 (p / 2).succ).filter fun x : \u2115 => p / 2 < (a * x : ZMod p).val).card \u2261\n      \u2211 x in Ico 1 (p / 2).succ, x * a / p [MOD 2]", "start": [148, 1], "end": [156, 44], "kind": "commanddeclaration"}, {"full_name": "ZMod.div_eq_filter_card", "code": "theorem div_eq_filter_card {a b c : \u2115} (hb0 : 0 < b) (hc : a / b \u2264 c) :\n    a / b = ((Ico 1 c.succ).filter fun x => x * b \u2264 a).card", "start": [159, 1], "end": [166, 57], "kind": "commanddeclaration"}, {"full_name": "ZMod.sum_Ico_eq_card_lt", "code": "private theorem sum_Ico_eq_card_lt {p q : \u2115} :\n    \u2211 a in Ico 1 (p / 2).succ, a * q / p =\n    ((Ico 1 (p / 2).succ \u00d7\u02e2 Ico 1 (q / 2).succ).filter fun x : \u2115 \u00d7 \u2115 =>\n      x.2 * p \u2264 x.1 * q).card", "start": [169, 1], "end": [196, 91], "kind": "commanddeclaration"}, {"full_name": "ZMod.sum_mul_div_add_sum_mul_div_eq_mul", "code": "theorem sum_mul_div_add_sum_mul_div_eq_mul (p q : \u2115) [hp : Fact p.Prime] (hq0 : (q : ZMod p) \u2260 0) :\n    \u2211 a in Ico 1 (p / 2).succ, a * q / p + \u2211 a in Ico 1 (q / 2).succ, a * p / q =\n    p / 2 * (q / 2)", "start": [198, 1], "end": [241, 56], "kind": "commanddeclaration"}, {"full_name": "ZMod.eisenstein_lemma", "code": "theorem eisenstein_lemma {p : \u2115} [Fact p.Prime] (hp : p \u2260 2) {a : \u2115} (ha1 : a % 2 = 1)\n    (ha0 : (a : ZMod p) \u2260 0) : legendreSym p a = (-1) ^ \u2211 x in Ico 1 (p / 2).succ, x * a / p", "start": [244, 1], "end": [250, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/UnivLE.lean", "imports": ["Mathlib/CategoryTheory/EssentialImage.lean", "Mathlib/CategoryTheory/Types.lean", "Mathlib/Logic/UnivLE.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UnivLE.ofEssSurj", "code": "theorem UnivLE.ofEssSurj.{u, v} (w : EssSurj (uliftFunctor.{u, v} : Type v \u2964 Type max u v)) :\n    UnivLE.{u, v}", "start": [22, 1], "end": [26, 57], "kind": "commanddeclaration"}, {"full_name": "UnivLE_iff_essSurj", "code": "theorem UnivLE_iff_essSurj.{u, v} :\n    UnivLE.{u, v} \u2194 EssSurj (uliftFunctor.{u, v} : Type v \u2964 Type max u v)", "start": [32, 1], "end": [34, 56], "kind": "commanddeclaration"}, {"full_name": "UnivLE.witness", "code": "def UnivLE.witness.{u, v} [UnivLE.{u, v}] : Type u \u2964 Type v :=\n  uliftFunctor.{v, u} \u22d9 (uliftFunctor.{u, v}).inv", "start": [39, 1], "end": [40, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Group/OpenMapping.lean", "imports": ["Mathlib/Topology/MetricSpace/Baire.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "smul_singleton_mem_nhds_of_sigmaCompact", "code": "@[to_additive \"Consider a sigma-compact additive group acting continuously and transitively on a\nBaire space. Then the orbit map is open around zero. It follows in\n`isOpenMap_vadd_of_sigmaCompact` that it is open around any point.\"]\ntheorem smul_singleton_mem_nhds_of_sigmaCompact\n    {U : Set G} (hU : U \u2208 \ud835\udcdd 1) (x : X) : U \u2022 {x} \u2208 \ud835\udcdd x", "start": [30, 1], "end": [87, 38], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_smul_of_sigmaCompact", "code": "@[to_additive \"Consider a sigma-compact additive group acting continuously and transitively on a\nBaire space. Then the orbit map is open. This is a version of the open mapping theorem, valid\nnotably for the action of a sigma-compact locally compact group on a locally compact space.\"]\ntheorem isOpenMap_smul_of_sigmaCompact (x : X) : IsOpenMap (fun (g : G) \u21a6 g \u2022 x)", "start": [89, 1], "end": [106, 59], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.isOpenMap_of_sigmaCompact", "code": "@[to_additive]\ntheorem MonoidHom.isOpenMap_of_sigmaCompact\n    {H : Type*} [Group H] [TopologicalSpace H] [BaireSpace H] [T2Space H] [ContinuousMul H]\n    (f : G \u2192* H) (hf : Function.Surjective f) (h'f : Continuous f) :\n    IsOpenMap f", "start": [108, 1], "end": [120, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/WellFounded.lean", "imports": ["Mathlib/Data/DFinsupp/WellFounded.lean", "Mathlib/Data/Finsupp/Lex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp.Lex.acc", "code": "theorem Lex.acc (x : \u03b1 \u2192\u2080 N) (h : \u2200 a \u2208 x.support, Acc (r\u1d9c \u2293 (\u00b7 \u2260 \u00b7)) a) :\n    Acc (Finsupp.Lex r s) x", "start": [35, 1], "end": [42, 44], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.wellFounded", "code": "theorem Lex.wellFounded (hr : WellFounded <| r\u1d9c \u2293 (\u00b7 \u2260 \u00b7)) : WellFounded (Finsupp.Lex r s)", "start": [45, 1], "end": [46, 53], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.wellFounded'", "code": "theorem Lex.wellFounded' [IsTrichotomous \u03b1 r] (hr : WellFounded (Function.swap r)) :\n    WellFounded (Finsupp.Lex r s)", "start": [49, 1], "end": [52, 79], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.wellFoundedLT", "code": "instance Lex.wellFoundedLT {\u03b1 N} [LT \u03b1] [IsTrichotomous \u03b1 (\u00b7 < \u00b7)] [h\u03b1 : WellFoundedGT \u03b1]\n    [CanonicallyOrderedAddCommMonoid N] [hN : WellFoundedLT N] : WellFoundedLT (Lex (\u03b1 \u2192\u2080 N)) :=\n  \u27e8Lex.wellFounded' (fun n => (zero_le n).not_lt) hN.wf h\u03b1.wf\u27e9", "start": [55, 1], "end": [57, 63], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.wellFounded_of_finite", "code": "theorem Lex.wellFounded_of_finite [IsStrictTotalOrder \u03b1 r] [Finite \u03b1] [Zero N]\n    (hs : WellFounded s) : WellFounded (Finsupp.Lex r s)", "start": [62, 1], "end": [64, 77], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.wellFoundedLT_of_finite", "code": "theorem Lex.wellFoundedLT_of_finite [LinearOrder \u03b1] [Finite \u03b1] [Zero N] [LT N]\n    [hwf : WellFoundedLT N] : WellFoundedLT (Lex (\u03b1 \u2192\u2080 N))", "start": [67, 1], "end": [69, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.wellFoundedLT", "code": "protected theorem wellFoundedLT [Zero N] [Preorder N] [WellFoundedLT N] (hbot : \u2200 n : N, \u00acn < 0) :\n    WellFoundedLT (\u03b1 \u2192\u2080 N)", "start": [72, 1], "end": [74, 73], "kind": "commanddeclaration"}, {"full_name": "Finsupp.wellFoundedLT'", "code": "instance wellFoundedLT' {N} [CanonicallyOrderedAddCommMonoid N] [WellFoundedLT N] :\n    WellFoundedLT (\u03b1 \u2192\u2080 N) :=\n  Finsupp.wellFoundedLT fun a => (zero_le a).not_lt", "start": [77, 1], "end": [79, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.wellFoundedLT_of_finite", "code": "instance wellFoundedLT_of_finite [Finite \u03b1] [Zero N] [Preorder N] [WellFoundedLT N] :\n    WellFoundedLT (\u03b1 \u2192\u2080 N) :=\n  \u27e8InvImage.wf equivFunOnFinite Function.wellFoundedLT.wf\u27e9", "start": [82, 1], "end": [84, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Mathport/Syntax.lean", "imports": ["Mathlib/Tactic/Positivity.lean", "Mathlib/Tactic/Abel.lean", "Mathlib/Tactic/Cases.lean", "Mathlib/Tactic/ModCases.lean", "Mathlib/Tactic/Find.lean", "Mathlib/Tactic/DefEqTransformations.lean", "Mathlib/Tactic/ApplyFun.lean", "Mathlib/Tactic/RunCmd.lean", "Mathlib/Tactic/Tauto.lean", "Mathlib/Tactic/Classical.lean", "Mathlib/Tactic/SimpRw.lean", "Mathlib/Tactic/Use.lean", "Mathlib/Order/Filter/Basic.lean", "Mathlib/Tactic/Clear_.lean", "Mathlib/Tactic/Lift.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "Mathlib/Tactic/PushNeg.lean", "Mathlib/Tactic/LinearCombination.lean", "Mathlib/Tactic/ClearExcept.lean", "Mathlib/Tactic/Linarith.lean", "Mathlib/Tactic/Continuity.lean", "lake-packages/lean4/src/lean/Lean/Elab/Quotation.lean", "Mathlib/Tactic/ApplyCongr.lean", "Mathlib/Tactic/CategoryTheory/Slice.lean", "Mathlib/Tactic/Polyrith.lean", "Mathlib/Tactic/Nontriviality.lean", "Mathlib/Tactic/Substs.lean", "Mathlib/Tactic/Relation/Symm.lean", "Mathlib/Tactic/NthRewrite.lean", "Mathlib/Tactic/Clean.lean", "Mathlib/Tactic/IntervalCases.lean", "Mathlib/Data/Matrix/Notation.lean", "lake-packages/std/Std/Tactic/Ext.lean", "Mathlib/SetTheory/Game/PGame.lean", "Mathlib/Tactic/CategoryTheory/Coherence.lean", "Mathlib/Tactic/RenameBVar.lean", "Mathlib/Tactic/MkIffOfInductiveProp.lean", "Mathlib/Tactic/CancelDenoms.lean", "Mathlib/Tactic/Convert.lean", "Mathlib/Tactic/InferParam.lean", "Mathlib/Tactic/ByContra.lean", "Mathlib/Tactic/CasesM.lean", "Mathlib/Tactic/ScopedNS.lean", "Mathlib/Tactic/RSuffices.lean", "Mathlib/Tactic/Set.lean", "Mathlib/Util/Syntax.lean", "Mathlib/RingTheory/WittVector/Basic.lean", "Mathlib/Tactic/Inhabit.lean", "Mathlib/Tactic/GuardHypNums.lean", "Mathlib/Tactic/Qify.lean", "Mathlib/Tactic/Measurability.lean", "Mathlib/Tactic/IrreducibleDef.lean", "Mathlib/Logic/Equiv/LocalEquiv.lean", "Mathlib/Tactic/Group.lean", "Mathlib/Tactic/LeftRight.lean", "Mathlib/Tactic/Core.lean", "Mathlib/Tactic/ExtractGoal.lean", "Mathlib/Tactic/PermuteGoals.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/CategoryTheory/Elementwise.lean", "Mathlib/Tactic/NormNum.lean", "Mathlib/Tactic/ApplyWith.lean", "Mathlib/Tactic/SwapVar.lean", "Mathlib/Tactic/Ring.lean", "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "Mathlib/Tactic/GeneralizeProofs.lean", "Mathlib/Tactic/Recover.lean", "Mathlib/Tactic/TFAE.lean", "Mathlib/Tactic/Conv.lean", "Mathlib/Tactic/Congrm.lean", "Mathlib/Tactic/Monotonicity.lean", "Mathlib/Tactic/Trace.lean", "Mathlib/Util/WithWeakNamespace.lean", "Mathlib/Tactic/Clear!.lean", "Mathlib/Tactic/Simps/Basic.lean", "Mathlib/Tactic/Replace.lean", "Mathlib/Tactic/NormCast.lean", "Mathlib/Mathport/Notation.lean", "Mathlib/Tactic/Existsi.lean", "Mathlib/Tactic/TypeCheck.lean", "Mathlib/Tactic/Contrapose.lean", "Mathlib/Tactic/Zify.lean", "Mathlib/Tactic/FinCases.lean", "Mathlib/RingTheory/WittVector/IsPoly.lean", "Mathlib/Tactic/Choose.lean", "Mathlib/Tactic/SolveByElim.lean", "Mathlib/Tactic/LibrarySearch.lean", "Mathlib/Tactic/Rename.lean", "Mathlib/Tactic/SplitIfs.lean", "lake-packages/std/Std/Tactic/Where.lean", "Mathlib/Tactic/Relation/Trans.lean", "Mathlib/Tactic/WLOG.lean", "Mathlib/Tactic/FieldSimp.lean", "lake-packages/std/Std/Tactic/RCases.lean", "Mathlib/Tactic/SimpIntro.lean", "Mathlib/Tactic/Constructor.lean"], "premises": []}
{"path": "Mathlib/Combinatorics/SimpleGraph/Matching.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/DegreeSum.lean", "Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.Subgraph.IsMatching", "code": "def IsMatching : Prop := \u2200 \u2983v\u2984, v \u2208 M.verts \u2192 \u2203! w, M.Adj v w", "start": [51, 1], "end": [55, 62], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.IsMatching.toEdge", "code": "noncomputable def IsMatching.toEdge {M : Subgraph G} (h : M.IsMatching) (v : M.verts) : M.edgeSet :=\n  \u27e8\u27e6(v, (h v.property).choose)\u27e7, (h v.property).choose_spec.1\u27e9", "start": [58, 1], "end": [60, 63], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.IsMatching.toEdge_eq_of_adj", "code": "theorem IsMatching.toEdge_eq_of_adj {M : Subgraph G} (h : M.IsMatching) {v w : V} (hv : v \u2208 M.verts)\n    (hvw : M.Adj v w) : h.toEdge \u27e8v, hv\u27e9 = \u27e8\u27e6(v, w)\u27e7, hvw\u27e9", "start": [63, 1], "end": [67, 57], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.IsMatching.toEdge.surjective", "code": "theorem IsMatching.toEdge.surjective {M : Subgraph G} (h : M.IsMatching) :\n    Function.Surjective h.toEdge", "start": [70, 1], "end": [74, 55], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.IsMatching.toEdge_eq_toEdge_of_adj", "code": "theorem IsMatching.toEdge_eq_toEdge_of_adj {M : Subgraph G} {v w : V} (h : M.IsMatching)\n    (hv : v \u2208 M.verts) (hw : w \u2208 M.verts) (ha : M.Adj v w) :\n    h.toEdge \u27e8v, hv\u27e9 = h.toEdge \u27e8w, hw\u27e9", "start": [77, 1], "end": [80, 99], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.IsPerfectMatching", "code": "def IsPerfectMatching : Prop := M.IsMatching \u2227 M.IsSpanning", "start": [83, 1], "end": [87, 60], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.IsMatching.support_eq_verts", "code": "theorem IsMatching.support_eq_verts {M : Subgraph G} (h : M.IsMatching) : M.support = M.verts", "start": [90, 1], "end": [93, 17], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.isMatching_iff_forall_degree", "code": "theorem isMatching_iff_forall_degree {M : Subgraph G} [\u2200 v : V, Fintype (M.neighborSet v)] :\n    M.IsMatching \u2194 \u2200 v : V, v \u2208 M.verts \u2192 M.degree v = 1", "start": [96, 1], "end": [98, 55], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.IsMatching.even_card", "code": "theorem IsMatching.even_card {M : Subgraph G} [Fintype M.verts] (h : M.IsMatching) :\n    Even M.verts.toFinset.card", "start": [101, 1], "end": [111, 29], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.isPerfectMatching_iff", "code": "theorem isPerfectMatching_iff : M.IsPerfectMatching \u2194 \u2200 v, \u2203! w, M.Adj v w", "start": [114, 1], "end": [119, 25], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.isPerfectMatching_iff_forall_degree", "code": "theorem isPerfectMatching_iff_forall_degree {M : Subgraph G} [\u2200 v, Fintype (M.neighborSet v)] :\n    M.IsPerfectMatching \u2194 \u2200 v, M.degree v = 1", "start": [122, 1], "end": [124, 61], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Subgraph.IsPerfectMatching.even_card", "code": "theorem IsPerfectMatching.even_card {M : Subgraph G} [Fintype V] (h : M.IsPerfectMatching) :\n    Even (Fintype.card V)", "start": [127, 1], "end": [130, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Matrix/DualNumber.lean", "imports": ["Mathlib/Data/Matrix/Basic.lean", "Mathlib/Algebra/DualNumber.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.dualNumberEquiv", "code": "@[simps]\ndef Matrix.dualNumberEquiv : Matrix n n (DualNumber R) \u2243\u2090[R] DualNumber (Matrix n n R) where\n  toFun A := \u27e8of fun i j => (A i j).fst, of fun i j => (A i j).snd\u27e9\n  invFun d := of fun i j => (d.fst i j, d.snd i j)\n  left_inv A := Matrix.ext fun i j => TrivSqZeroExt.ext rfl rfl\n  right_inv d := TrivSqZeroExt.ext (Matrix.ext fun i j => rfl) (Matrix.ext fun i j => rfl)\n  map_mul' A B := by\n    ext\n    \u00b7 dsimp [mul_apply]\n      simp_rw [fst_sum]\n      rfl\n    \u00b7 simp_rw [snd_mul, smul_eq_mul, op_smul_eq_mul]\n      simp only [mul_apply, snd_sum, DualNumber.snd_mul, snd_mk, of_apply, fst_mk, add_apply]\n      rw [\u2190 Finset.sum_add_distrib]\n  map_add' A B := TrivSqZeroExt.ext rfl rfl\n  commutes' r := by\n    simp_rw [algebraMap_eq_inl', algebraMap_eq_diagonal, Pi.algebraMap_def,\n      Algebra.id.map_eq_self, algebraMap_eq_inl, \u2190 diagonal_map (inl_zero R), map_apply, fst_inl,\n      snd_inl]\n    rfl", "start": [23, 1], "end": [43, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Ideal/IdempotentFG.lean", "imports": ["Mathlib/RingTheory/Finiteness.lean", "Mathlib/Algebra/Ring/Idempotents.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ideal.isIdempotentElem_iff_of_fg", "code": "theorem isIdempotentElem_iff_of_fg {R : Type*} [CommRing R] (I : Ideal R) (h : I.FG) :\n    IsIdempotentElem I \u2194 \u2203 e : R, IsIdempotentElem e \u2227 I = R \u2219 e", "start": [18, 1], "end": [34, 76], "kind": "commanddeclaration"}, {"full_name": "Ideal.isIdempotentElem_iff_eq_bot_or_top", "code": "theorem isIdempotentElem_iff_eq_bot_or_top {R : Type*} [CommRing R] [IsDomain R] (I : Ideal R)\n    (h : I.FG) : IsIdempotentElem I \u2194 I = \u22a5 \u2228 I = \u22a4", "start": [37, 1], "end": [46, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rbtree/Find.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/NumberTheory/Zsqrtd/ToReal.lean", "imports": ["Mathlib/NumberTheory/Zsqrtd/Basic.lean", "Mathlib/Data/Real/Sqrt.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Zsqrtd.toReal", "code": "@[simps!]\nnoncomputable def toReal {d : \u2124} (h : 0 \u2264 d) : \u2124\u221ad \u2192+* \u211d :=\n  lift \u27e8Real.sqrt d, Real.mul_self_sqrt (Int.cast_nonneg.mpr h)\u27e9", "start": [21, 1], "end": [26, 65], "kind": "commanddeclaration"}, {"full_name": "Zsqrtd.toReal_injective", "code": "theorem toReal_injective {d : \u2124} (h0d : 0 \u2264 d) (hd : \u2200 n : \u2124, d \u2260 n * n) :\n    Function.Injective (toReal h0d)", "start": [29, 1], "end": [31, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/AlgebraicCard.lean", "imports": ["Mathlib/Data/Polynomial/Cardinal.lean", "Mathlib/RingTheory/Algebraic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Algebraic.infinite_of_charZero", "code": "theorem infinite_of_charZero (R A : Type*) [CommRing R] [IsDomain R] [Ring A] [Algebra R A]\n    [CharZero A] : { x : A | IsAlgebraic R x }.Infinite", "start": [30, 1], "end": [32, 70], "kind": "commanddeclaration"}, {"full_name": "Algebraic.aleph0_le_cardinal_mk_of_charZero", "code": "theorem aleph0_le_cardinal_mk_of_charZero (R A : Type*) [CommRing R] [IsDomain R] [Ring A]\n    [Algebra R A] [CharZero A] : \u2135\u2080 \u2264 #{ x : A // IsAlgebraic R x }", "start": [35, 1], "end": [37, 70], "kind": "commanddeclaration"}, {"full_name": "Algebraic.cardinal_mk_lift_le_mul", "code": "theorem cardinal_mk_lift_le_mul :\n    Cardinal.lift.{u} #{ x : A // IsAlgebraic R x } \u2264 Cardinal.lift.{v} #R[X] * \u2135\u2080", "start": [45, 1], "end": [54, 37], "kind": "commanddeclaration"}, {"full_name": "Algebraic.cardinal_mk_lift_le_max", "code": "theorem cardinal_mk_lift_le_max :\n    Cardinal.lift.{u} #{ x : A // IsAlgebraic R x } \u2264 max (Cardinal.lift.{v} #R) \u2135\u2080", "start": [57, 1], "end": [60, 74], "kind": "commanddeclaration"}, {"full_name": "Algebraic.cardinal_mk_lift_of_infinite", "code": "@[simp]\ntheorem cardinal_mk_lift_of_infinite [Infinite R] :\n    Cardinal.lift.{u} #{ x : A // IsAlgebraic R x } = Cardinal.lift.{v} #R", "start": [63, 1], "end": [68, 74], "kind": "commanddeclaration"}, {"full_name": "Algebraic.countable", "code": "@[simp]\nprotected theorem countable : Set.Countable { x : A | IsAlgebraic R x }", "start": [73, 1], "end": [77, 7], "kind": "commanddeclaration"}, {"full_name": "Algebraic.cardinal_mk_of_countable_of_charZero", "code": "@[simp]\ntheorem cardinal_mk_of_countable_of_charZero [CharZero A] [IsDomain R] :\n    #{ x : A // IsAlgebraic R x } = \u2135\u2080", "start": [80, 1], "end": [83, 87], "kind": "commanddeclaration"}, {"full_name": "Algebraic.cardinal_mk_le_mul", "code": "theorem cardinal_mk_le_mul : #{ x : A // IsAlgebraic R x } \u2264 #R[X] * \u2135\u2080", "start": [93, 1], "end": [95, 36], "kind": "commanddeclaration"}, {"full_name": "Algebraic.cardinal_mk_le_max", "code": "theorem cardinal_mk_le_max : #{ x : A // IsAlgebraic R x } \u2264 max #R \u2135\u2080", "start": [98, 1], "end": [100, 36], "kind": "commanddeclaration"}, {"full_name": "Algebraic.cardinal_mk_of_infinite", "code": "@[simp]\ntheorem cardinal_mk_of_infinite [Infinite R] : #{ x : A // IsAlgebraic R x } = #R", "start": [103, 1], "end": [105, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/FreeMonoid/Count.lean", "imports": ["Mathlib/Data/List/Count.lean", "Mathlib/Algebra/FreeMonoid/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FreeAddMonoid.countP", "code": "def countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _", "start": [25, 1], "end": [29, 35], "kind": "commanddeclaration"}, {"full_name": "FreeAddMonoid.countP_of", "code": "theorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0", "start": [32, 1], "end": [33, 45], "kind": "commanddeclaration"}, {"full_name": "FreeAddMonoid.countP_apply", "code": "theorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l", "start": [36, 1], "end": [36, 81], "kind": "commanddeclaration"}, {"full_name": "FreeAddMonoid.count", "code": "def count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)", "start": [39, 1], "end": [41, 75], "kind": "commanddeclaration"}, {"full_name": "FreeAddMonoid.count_of", "code": "theorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y", "start": [44, 1], "end": [46, 27], "kind": "commanddeclaration"}, {"full_name": "FreeAddMonoid.count_apply", "code": "theorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l", "start": [49, 1], "end": [50, 6], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.countP", "code": "def countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)", "start": [57, 1], "end": [59, 59], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.countP_of'", "code": "theorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0", "start": [62, 1], "end": [65, 54], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.countP_of", "code": "theorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1", "start": [68, 1], "end": [69, 30], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.countP_apply", "code": "theorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l)", "start": [73, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.count", "code": "def count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)", "start": [77, 1], "end": [78, 87], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.count_apply", "code": "theorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l)", "start": [81, 1], "end": [82, 61], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.count_of", "code": "theorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y", "start": [85, 1], "end": [87, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Localization/Adjunction.lean", "imports": ["Mathlib/CategoryTheory/CatCommSq.lean", "Mathlib/CategoryTheory/Localization/Predicate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Adjunction.Localization.\u03b5", "code": "noncomputable def \u03b5 : \ud835\udfed D\u2081 \u27f6 G' \u22d9 F' := by\n  letI : Lifting L\u2081 W\u2081 ((G \u22d9 F) \u22d9 L\u2081) (G' \u22d9 F') :=\n    Lifting.mk (CatCommSq.hComp G F L\u2081 L\u2082 L\u2081 G' F').iso'.symm\n  exact Localization.liftNatTrans L\u2081 W\u2081 L\u2081 ((G \u22d9 F) \u22d9 L\u2081) (\ud835\udfed D\u2081) (G' \u22d9 F')\n    (whiskerRight adj.unit L\u2081)", "start": [37, 1], "end": [42, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.Localization.\u03b5_app", "code": "lemma \u03b5_app (X\u2081 : C\u2081) :\n    (\u03b5 adj L\u2081 W\u2081 L\u2082 G' F').app (L\u2081.obj X\u2081) =\n      L\u2081.map (adj.unit.app X\u2081) \u226b (CatCommSq.iso F L\u2082 L\u2081 F').hom.app (G.obj X\u2081) \u226b\n        F'.map ((CatCommSq.iso G L\u2081 L\u2082 G').hom.app X\u2081) := by\n  letI : Lifting L\u2081 W\u2081 ((G \u22d9 F) \u22d9 L\u2081) (G' \u22d9 F') :=\n    Lifting.mk (CatCommSq.hComp G F L\u2081 L\u2082 L\u2081 G' F').iso'.symm\n  simp only [\u03b5, liftNatTrans_app, Lifting.iso, Iso.symm,\n    Functor.id_obj, Functor.comp_obj, Lifting.id_iso', Functor.rightUnitor_hom_app,\n      whiskerRight_app, CatCommSq.hComp_iso'_hom_app, id_comp]", "start": [44, 1], "end": [52, 63], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Adjunction.Localization.\u03b7", "code": "noncomputable def \u03b7 : F' \u22d9 G' \u27f6 \ud835\udfed D\u2082 := by\n  letI : Lifting L\u2082 W\u2082 ((F \u22d9 G) \u22d9 L\u2082) (F' \u22d9 G') :=\n    Lifting.mk (CatCommSq.hComp F G L\u2082 L\u2081 L\u2082 F' G').iso'.symm\n  exact liftNatTrans L\u2082 W\u2082 ((F \u22d9 G) \u22d9 L\u2082) L\u2082 (F' \u22d9 G') (\ud835\udfed D\u2082) (whiskerRight adj.counit L\u2082)", "start": [54, 1], "end": [58, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.Localization.\u03b7_app", "code": "lemma \u03b7_app (X\u2082 : C\u2082) :\n    (\u03b7 adj L\u2081 L\u2082 W\u2082 G' F').app (L\u2082.obj X\u2082) =\n      G'.map ((CatCommSq.iso F L\u2082 L\u2081 F').inv.app X\u2082) \u226b\n        (CatCommSq.iso G L\u2081 L\u2082 G').inv.app (F.obj X\u2082) \u226b\n        L\u2082.map (adj.counit.app X\u2082) := by\n  letI : Lifting L\u2082 W\u2082 ((F \u22d9 G) \u22d9 L\u2082) (F' \u22d9 G') :=\n    Lifting.mk (CatCommSq.hComp F G L\u2082 L\u2081 L\u2082 F' G').iso'.symm\n  simp only [\u03b7, liftNatTrans_app, Lifting.iso, Iso.symm, CatCommSq.hComp_iso'_inv_app,\n    whiskerRight_app, Lifting.id_iso', Functor.rightUnitor_inv_app, comp_id, assoc]", "start": [60, 1], "end": [68, 84], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Adjunction.localization", "code": "noncomputable def localization : G' \u22a3 F' :=\n  Adjunction.mkOfUnitCounit\n    { unit := Localization.\u03b5 adj L\u2081 W\u2081 L\u2082 G' F'\n      counit := Localization.\u03b7 adj L\u2081 L\u2082 W\u2082 G' F'\n      left_triangle := by\n        apply natTrans_ext L\u2081 W\u2081\n        intro X\u2081\n        have eq := congr_app adj.left_triangle X\u2081\n        dsimp at eq\n        rw [NatTrans.comp_app, NatTrans.comp_app, whiskerRight_app, Localization.\u03b5_app,\n          Functor.associator_hom_app, id_comp, whiskerLeft_app, G'.map_comp, G'.map_comp,\n          assoc, assoc]\n        erw [(Localization.\u03b7 adj L\u2081 L\u2082 W\u2082 G' F').naturality, Localization.\u03b7_app,\n          assoc, assoc, \u2190 G'.map_comp_assoc, \u2190 G'.map_comp_assoc, assoc, Iso.hom_inv_id_app,\n          comp_id, (CatCommSq.iso G L\u2081 L\u2082 G').inv.naturality_assoc, \u2190 L\u2082.map_comp_assoc, eq,\n          L\u2082.map_id, id_comp, Iso.inv_hom_id_app]\n        rfl\n      right_triangle := by\n        apply natTrans_ext L\u2082 W\u2082\n        intro X\u2082\n        have eq := congr_app adj.right_triangle X\u2082\n        dsimp at eq\n        rw [NatTrans.comp_app, NatTrans.comp_app, whiskerLeft_app, whiskerRight_app,\n          Localization.\u03b7_app, Functor.associator_inv_app, id_comp, F'.map_comp, F'.map_comp]\n        erw [\u2190 (Localization.\u03b5 _ _ _ _ _ _).naturality_assoc, Localization.\u03b5_app,\n          assoc, assoc, \u2190 F'.map_comp_assoc, Iso.hom_inv_id_app, F'.map_id, id_comp,\n          \u2190 NatTrans.naturality, \u2190 L\u2081.map_comp_assoc, eq, L\u2081.map_id, id_comp,\n          Iso.inv_hom_id_app]\n        rfl }", "start": [72, 1], "end": [106, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.localization_unit_app", "code": "@[simp]\nlemma localization_unit_app (X\u2081 : C\u2081) :\n    (adj.localization L\u2081 W\u2081 L\u2082 W\u2082 G' F').unit.app (L\u2081.obj X\u2081) =\n    L\u2081.map (adj.unit.app X\u2081) \u226b (CatCommSq.iso F L\u2082 L\u2081 F').hom.app (G.obj X\u2081) \u226b\n      F'.map ((CatCommSq.iso G L\u2081 L\u2082 G').hom.app X\u2081) := by\n  apply Localization.\u03b5_app", "start": [108, 1], "end": [113, 27], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Adjunction.localization_counit_app", "code": "@[simp]\nlemma localization_counit_app (X\u2082 : C\u2082) :\n    (adj.localization L\u2081 W\u2081 L\u2082 W\u2082 G' F').counit.app (L\u2082.obj X\u2082) =\n    G'.map ((CatCommSq.iso F L\u2082 L\u2081 F').inv.app X\u2082) \u226b\n      (CatCommSq.iso G L\u2081 L\u2082 G').inv.app (F.obj X\u2082) \u226b\n      L\u2082.map (adj.counit.app X\u2082) := by\n  apply Localization.\u03b7_app", "start": [115, 1], "end": [121, 27], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus.lean", "imports": ["Mathlib/Analysis/NormedSpace/Star/GelfandDuality.lean", "Mathlib/Topology/Algebra/StarSubalgebra.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "spectrum_star_mul_self_of_isStarNormal", "code": "theorem spectrum_star_mul_self_of_isStarNormal :\n    spectrum \u2102 (star a * a) \u2286 Set.Icc (0 : \u2102) \u2016star a * a\u2016", "start": [78, 1], "end": [97, 77], "kind": "commanddeclaration"}, {"full_name": "elementalStarAlgebra.isUnit_of_isUnit_of_isStarNormal", "code": "theorem elementalStarAlgebra.isUnit_of_isUnit_of_isStarNormal (h : IsUnit a) :\n    IsUnit (\u27e8a, self_mem \u2102 a\u27e9 : elementalStarAlgebra \u2102 a)", "start": [102, 1], "end": [177, 73], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.isUnit_coe_inv_mem", "code": "theorem StarSubalgebra.isUnit_coe_inv_mem {S : StarSubalgebra \u2102 A} (hS : IsClosed (S : Set A))\n    {x : A} (h : IsUnit x) (hxS : x \u2208 S) : \u2191h.unit\u207b\u00b9 \u2208 S", "start": [180, 1], "end": [194, 51], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.coe_isUnit", "code": "theorem StarSubalgebra.coe_isUnit {S : StarSubalgebra \u2102 A} (hS : IsClosed (S : Set A)) {x : S} :\n    IsUnit (x : A) \u2194 IsUnit x", "start": [197, 1], "end": [204, 86], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.mem_spectrum_iff", "code": "theorem StarSubalgebra.mem_spectrum_iff {S : StarSubalgebra \u2102 A} (hS : IsClosed (S : Set A)) {x : S}\n    {z : \u2102} : z \u2208 spectrum \u2102 x \u2194 z \u2208 spectrum \u2102 (x : A)", "start": [207, 1], "end": [209, 52], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.spectrum_eq", "code": "theorem StarSubalgebra.spectrum_eq {S : StarSubalgebra \u2102 A} (hS : IsClosed (S : Set A)) (x : S) :\n    spectrum \u2102 x = spectrum \u2102 (x : A)", "start": [212, 1], "end": [216, 55], "kind": "commanddeclaration"}, {"full_name": "elementalStarAlgebra.characterSpaceToSpectrum", "code": "@[simps]\nnoncomputable def elementalStarAlgebra.characterSpaceToSpectrum (x : A)\n    (\u03c6 : characterSpace \u2102 (elementalStarAlgebra \u2102 x)) : spectrum \u2102 x where\n  val := \u03c6 \u27e8x, self_mem \u2102 x\u27e9\n  property := by\n    simpa only [StarSubalgebra.spectrum_eq (elementalStarAlgebra.isClosed \u2102 x)\n        \u27e8x, self_mem \u2102 x\u27e9] using\n      AlgHom.apply_mem_spectrum \u03c6 \u27e8x, self_mem \u2102 x\u27e9", "start": [221, 1], "end": [232, 52], "kind": "commanddeclaration"}, {"full_name": "elementalStarAlgebra.continuous_characterSpaceToSpectrum", "code": "theorem elementalStarAlgebra.continuous_characterSpaceToSpectrum (x : A) :\n    Continuous (elementalStarAlgebra.characterSpaceToSpectrum x)", "start": [235, 1], "end": [238, 88], "kind": "commanddeclaration"}, {"full_name": "elementalStarAlgebra.bijective_characterSpaceToSpectrum", "code": "theorem elementalStarAlgebra.bijective_characterSpaceToSpectrum :\n    Function.Bijective (elementalStarAlgebra.characterSpaceToSpectrum a)", "start": [241, 1], "end": [253, 19], "kind": "commanddeclaration"}, {"full_name": "elementalStarAlgebra.characterSpaceHomeo", "code": "noncomputable def elementalStarAlgebra.characterSpaceHomeo :\n    characterSpace \u2102 (elementalStarAlgebra \u2102 a) \u2243\u209c spectrum \u2102 a :=\n  @Continuous.homeoOfEquivCompactToT2 _ _ _ _ _ _\n    (Equiv.ofBijective (elementalStarAlgebra.characterSpaceToSpectrum a)\n      (elementalStarAlgebra.bijective_characterSpaceToSpectrum a))\n    (elementalStarAlgebra.continuous_characterSpaceToSpectrum a)", "start": [256, 1], "end": [263, 65], "kind": "commanddeclaration"}, {"full_name": "continuousFunctionalCalculus", "code": "noncomputable def continuousFunctionalCalculus :\n    C(spectrum \u2102 a, \u2102) \u2243\u22c6\u2090[\u2102] elementalStarAlgebra \u2102 a :=\n  ((elementalStarAlgebra.characterSpaceHomeo a).compStarAlgEquiv' \u2102 \u2102).trans\n    (gelfandStarTransform (elementalStarAlgebra \u2102 a)).symm", "start": [266, 1], "end": [274, 59], "kind": "commanddeclaration"}, {"full_name": "continuousFunctionalCalculus_map_id", "code": "theorem continuousFunctionalCalculus_map_id :\n    continuousFunctionalCalculus a ((ContinuousMap.id \u2102).restrict (spectrum \u2102 a)) =\n      \u27e8a, self_mem \u2102 a\u27e9", "start": [277, 1], "end": [280, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/KrullDimension.lean", "imports": ["Mathlib/Order/WithBot.lean", "Mathlib/Data/Nat/Lattice.lean", "Mathlib/Order/RelSeries.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "krullDim", "code": "noncomputable def krullDim : WithBot (WithTop \u2115) :=\n  \u2a06 (p : LTSeries \u03b1), p.length", "start": [31, 1], "end": [38, 31], "kind": "commanddeclaration"}, {"full_name": "height", "code": "noncomputable def height (a : \u03b1) : WithBot (WithTop \u2115) := krullDim (Set.Iic a)", "start": [40, 1], "end": [43, 79], "kind": "commanddeclaration"}, {"full_name": "coheight", "code": "noncomputable def coheight (a : \u03b1) : WithBot (WithTop \u2115) := krullDim (Set.Ici a)", "start": [45, 1], "end": [48, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Polynomial/Hermite/Gaussian.lean", "imports": ["Mathlib/Analysis/Calculus/Deriv/Polynomial.lean", "Mathlib/RingTheory/Polynomial/Hermite/Basic.lean", "Mathlib/Analysis/SpecialFunctions/Exp.lean", "Mathlib/Analysis/Calculus/Deriv/Add.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/SpecialFunctions/ExpDeriv.lean"], "premises": [{"full_name": "Polynomial.deriv_gaussian_eq_hermite_mul_gaussian", "code": "theorem deriv_gaussian_eq_hermite_mul_gaussian (n : \u2115) (x : \u211d) :\n    deriv^[n] (fun y => Real.exp (-(y ^ 2 / 2))) x =\n    (-1 : \u211d) ^ n * aeval x (hermite n) * Real.exp (-(x ^ 2 / 2))", "start": [39, 1], "end": [54, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hermite_eq_deriv_gaussian", "code": "theorem hermite_eq_deriv_gaussian (n : \u2115) (x : \u211d) : aeval x (hermite n) =\n    (-1 : \u211d) ^ n * deriv^[n] (fun y => Real.exp (-(y ^ 2 / 2))) x / Real.exp (-(x ^ 2 / 2))", "start": [57, 1], "end": [63, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hermite_eq_deriv_gaussian'", "code": "theorem hermite_eq_deriv_gaussian' (n : \u2115) (x : \u211d) : aeval x (hermite n) =\n    (-1 : \u211d) ^ n * deriv^[n] (fun y => Real.exp (-(y ^ 2 / 2))) x * Real.exp (x ^ 2 / 2)", "start": [66, 1], "end": [69, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Additive/Energy.lean", "imports": ["Mathlib/Data/Finset/Prod.lean", "Mathlib/Data/Fintype/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.multiplicativeEnergy", "code": "@[to_additive additiveEnergy\n      \"The additive energy of two finsets `s` and `t` in a group is the\n      number of quadruples `(a\u2081, a\u2082, b\u2081, b\u2082) \u2208 s \u00d7 s \u00d7 t \u00d7 t` such that `a\u2081 + b\u2081 = a\u2082 + b\u2082`.\"]\ndef multiplicativeEnergy (s t : Finset \u03b1) : \u2115 :=\n  (((s \u00d7\u02e2 s) \u00d7\u02e2 t \u00d7\u02e2 t).filter fun x : (\u03b1 \u00d7 \u03b1) \u00d7 \u03b1 \u00d7 \u03b1 => x.1.1 * x.2.1 = x.1.2 * x.2.2).card", "start": [38, 1], "end": [44, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.multiplicativeEnergy_mono", "code": "@[to_additive additiveEnergy_mono]\ntheorem multiplicativeEnergy_mono (hs : s\u2081 \u2286 s\u2082) (ht : t\u2081 \u2286 t\u2082) :\n    multiplicativeEnergy s\u2081 t\u2081 \u2264 multiplicativeEnergy s\u2082 t\u2082", "start": [48, 1], "end": [53, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.multiplicativeEnergy_mono_left", "code": "@[to_additive additiveEnergy_mono_left]\ntheorem multiplicativeEnergy_mono_left (hs : s\u2081 \u2286 s\u2082) :\n    multiplicativeEnergy s\u2081 t \u2264 multiplicativeEnergy s\u2082 t", "start": [57, 1], "end": [60, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.multiplicativeEnergy_mono_right", "code": "@[to_additive additiveEnergy_mono_right]\ntheorem multiplicativeEnergy_mono_right (ht : t\u2081 \u2286 t\u2082) :\n    multiplicativeEnergy s t\u2081 \u2264 multiplicativeEnergy s t\u2082", "start": [64, 1], "end": [67, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.le_multiplicativeEnergy", "code": "@[to_additive le_additiveEnergy]\ntheorem le_multiplicativeEnergy : s.card * t.card \u2264 multiplicativeEnergy s t", "start": [71, 1], "end": [80, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.multiplicativeEnergy_pos", "code": "@[to_additive additiveEnergy_pos]\ntheorem multiplicativeEnergy_pos (hs : s.Nonempty) (ht : t.Nonempty) :\n    0 < multiplicativeEnergy s t", "start": [84, 1], "end": [87, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.multiplicativeEnergy_empty_left", "code": "@[to_additive (attr := simp) additiveEnergy_empty_left]\ntheorem multiplicativeEnergy_empty_left : multiplicativeEnergy \u2205 t = 0", "start": [93, 1], "end": [95, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.multiplicativeEnergy_empty_right", "code": "@[to_additive (attr := simp) additiveEnergy_empty_right]\ntheorem multiplicativeEnergy_empty_right : multiplicativeEnergy s \u2205 = 0", "start": [99, 1], "end": [101, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.multiplicativeEnergy_pos_iff", "code": "@[to_additive (attr := simp) additiveEnergy_pos_iff]\ntheorem multiplicativeEnergy_pos_iff : 0 < multiplicativeEnergy s t \u2194 s.Nonempty \u2227 t.Nonempty", "start": [107, 1], "end": [113, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.multiplicativeEnergy_eq_zero_iff", "code": "@[to_additive (attr := simp) additive_energy_eq_zero_iff]\ntheorem multiplicativeEnergy_eq_zero_iff : multiplicativeEnergy s t = 0 \u2194 s = \u2205 \u2228 t = \u2205", "start": [117, 1], "end": [119, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.multiplicativeEnergy_comm", "code": "@[to_additive additiveEnergy_comm]\ntheorem multiplicativeEnergy_comm (s t : Finset \u03b1) :\n    multiplicativeEnergy s t = multiplicativeEnergy t s", "start": [129, 1], "end": [133, 96], "kind": "commanddeclaration"}, {"full_name": "Finset.multiplicativeEnergy_univ_left", "code": "@[to_additive (attr := simp) additiveEnergy_univ_left]\ntheorem multiplicativeEnergy_univ_left :\n    multiplicativeEnergy univ t = Fintype.card \u03b1 * t.card ^ 2", "start": [143, 1], "end": [159, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.multiplicativeEnergy_univ_right", "code": "@[to_additive (attr := simp) additiveEnergy_univ_right]\ntheorem multiplicativeEnergy_univ_right :\n    multiplicativeEnergy s univ = Fintype.card \u03b1 * s.card ^ 2", "start": [163, 1], "end": [166, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Rdrop.lean", "imports": ["Mathlib/Data/List/Basic.lean", "Mathlib/Data/List/Infix.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.rdrop", "code": "def rdrop : List \u03b1 :=\n  l.take (l.length - n)", "start": [40, 1], "end": [42, 24], "kind": "commanddeclaration"}, {"full_name": "List.rdrop_nil", "code": "@[simp]\ntheorem rdrop_nil : rdrop ([] : List \u03b1) n = []", "start": [45, 1], "end": [46, 66], "kind": "commanddeclaration"}, {"full_name": "List.rdrop_zero", "code": "@[simp]\ntheorem rdrop_zero : rdrop l 0 = l", "start": [49, 1], "end": [50, 54], "kind": "commanddeclaration"}, {"full_name": "List.rdrop_eq_reverse_drop_reverse", "code": "theorem rdrop_eq_reverse_drop_reverse : l.rdrop n = reverse (l.reverse.drop n)", "start": [53, 1], "end": [59, 44], "kind": "commanddeclaration"}, {"full_name": "List.rdrop_concat_succ", "code": "@[simp]\ntheorem rdrop_concat_succ (x : \u03b1) : rdrop (l ++ [x]) (n + 1) = rdrop l n", "start": [62, 1], "end": [64, 39], "kind": "commanddeclaration"}, {"full_name": "List.rtake", "code": "def rtake : List \u03b1 :=\n  l.drop (l.length - n)", "start": [67, 1], "end": [69, 24], "kind": "commanddeclaration"}, {"full_name": "List.rtake_nil", "code": "@[simp]\ntheorem rtake_nil : rtake ([] : List \u03b1) n = []", "start": [72, 1], "end": [73, 66], "kind": "commanddeclaration"}, {"full_name": "List.rtake_zero", "code": "@[simp]\ntheorem rtake_zero : rtake l 0 = []", "start": [76, 1], "end": [77, 55], "kind": "commanddeclaration"}, {"full_name": "List.rtake_eq_reverse_take_reverse", "code": "theorem rtake_eq_reverse_take_reverse : l.rtake n = reverse (l.reverse.take n)", "start": [80, 1], "end": [86, 44], "kind": "commanddeclaration"}, {"full_name": "List.rtake_concat_succ", "code": "@[simp]\ntheorem rtake_concat_succ (x : \u03b1) : rtake (l ++ [x]) (n + 1) = rtake l n ++ [x]", "start": [89, 1], "end": [91, 39], "kind": "commanddeclaration"}, {"full_name": "List.rdropWhile", "code": "def rdropWhile : List \u03b1 :=\n  reverse (l.reverse.dropWhile p)", "start": [94, 1], "end": [97, 34], "kind": "commanddeclaration"}, {"full_name": "List.rdropWhile_nil", "code": "@[simp]\ntheorem rdropWhile_nil : rdropWhile p ([] : List \u03b1) = []", "start": [100, 1], "end": [101, 92], "kind": "commanddeclaration"}, {"full_name": "List.rdropWhile_concat", "code": "theorem rdropWhile_concat (x : \u03b1) :\n    rdropWhile p (l ++ [x]) = if p x then rdropWhile p l else l ++ [x]", "start": [104, 1], "end": [107, 32], "kind": "commanddeclaration"}, {"full_name": "List.rdropWhile_concat_pos", "code": "@[simp]\ntheorem rdropWhile_concat_pos (x : \u03b1) (h : p x) : rdropWhile p (l ++ [x]) = rdropWhile p l", "start": [110, 1], "end": [112, 35], "kind": "commanddeclaration"}, {"full_name": "List.rdropWhile_concat_neg", "code": "@[simp]\ntheorem rdropWhile_concat_neg (x : \u03b1) (h : \u00acp x) : rdropWhile p (l ++ [x]) = l ++ [x]", "start": [115, 1], "end": [117, 35], "kind": "commanddeclaration"}, {"full_name": "List.rdropWhile_singleton", "code": "theorem rdropWhile_singleton (x : \u03b1) : rdropWhile p [x] = if p x then [] else [x]", "start": [120, 1], "end": [121, 59], "kind": "commanddeclaration"}, {"full_name": "List.rdropWhile_last_not", "code": "theorem rdropWhile_last_not (hl : l.rdropWhile p \u2260 []) : \u00acp ((rdropWhile p l).getLast hl)", "start": [124, 1], "end": [127, 39], "kind": "commanddeclaration"}, {"full_name": "List.rdropWhile_prefix", "code": "theorem rdropWhile_prefix : l.rdropWhile p <+: l", "start": [130, 1], "end": [132, 27], "kind": "commanddeclaration"}, {"full_name": "List.rdropWhile_eq_nil_iff", "code": "@[simp]\ntheorem rdropWhile_eq_nil_iff : rdropWhile p l = [] \u2194 \u2200 x \u2208 l, p x", "start": [137, 1], "end": [138, 91], "kind": "commanddeclaration"}, {"full_name": "List.dropWhile_eq_self_iff", "code": "@[simp]\ntheorem dropWhile_eq_self_iff : dropWhile p l = l \u2194 \u2200 hl : 0 < l.length, \u00acp (l.nthLe 0 hl)", "start": [142, 1], "end": [159, 21], "kind": "commanddeclaration"}, {"full_name": "List.rdropWhile_eq_self_iff", "code": "@[simp]\ntheorem rdropWhile_eq_self_iff : rdropWhile p l = l \u2194 \u2200 hl : l \u2260 [], \u00acp (l.getLast hl)", "start": [164, 1], "end": [173, 30], "kind": "commanddeclaration"}, {"full_name": "List.dropWhile_idempotent", "code": "theorem dropWhile_idempotent : dropWhile p (dropWhile p l) = dropWhile p l", "start": [178, 1], "end": [180, 48], "kind": "commanddeclaration"}, {"full_name": "List.rdropWhile_idempotent", "code": "theorem rdropWhile_idempotent : rdropWhile p (rdropWhile p l) = rdropWhile p l", "start": [183, 1], "end": [184, 55], "kind": "commanddeclaration"}, {"full_name": "List.rtakeWhile", "code": "def rtakeWhile : List \u03b1 :=\n  reverse (l.reverse.takeWhile p)", "start": [187, 1], "end": [190, 34], "kind": "commanddeclaration"}, {"full_name": "List.rtakeWhile_nil", "code": "@[simp]\ntheorem rtakeWhile_nil : rtakeWhile p ([] : List \u03b1) = []", "start": [193, 1], "end": [194, 92], "kind": "commanddeclaration"}, {"full_name": "List.rtakeWhile_concat", "code": "theorem rtakeWhile_concat (x : \u03b1) :\n    rtakeWhile p (l ++ [x]) = if p x then rtakeWhile p l ++ [x] else []", "start": [197, 1], "end": [200, 32], "kind": "commanddeclaration"}, {"full_name": "List.rtakeWhile_concat_pos", "code": "@[simp]\ntheorem rtakeWhile_concat_pos (x : \u03b1) (h : p x) :\n    rtakeWhile p (l ++ [x]) = rtakeWhile p l ++ [x]", "start": [203, 1], "end": [205, 91], "kind": "commanddeclaration"}, {"full_name": "List.rtakeWhile_concat_neg", "code": "@[simp]\ntheorem rtakeWhile_concat_neg (x : \u03b1) (h : \u00acp x) : rtakeWhile p (l ++ [x]) = []", "start": [208, 1], "end": [210, 35], "kind": "commanddeclaration"}, {"full_name": "List.rtakeWhile_suffix", "code": "theorem rtakeWhile_suffix : l.rtakeWhile p <:+ l", "start": [213, 1], "end": [215, 27], "kind": "commanddeclaration"}, {"full_name": "List.rtakeWhile_eq_self_iff", "code": "@[simp]\ntheorem rtakeWhile_eq_self_iff : rtakeWhile p l = l \u2194 \u2200 x \u2208 l, p x", "start": [220, 1], "end": [222, 36], "kind": "commanddeclaration"}, {"full_name": "List.rtakeWhile_eq_nil_iff", "code": "@[simp]\ntheorem rtakeWhile_eq_nil_iff : rtakeWhile p l = [] \u2194 \u2200 hl : l \u2260 [], \u00acp (l.getLast hl)", "start": [226, 1], "end": [235, 20], "kind": "commanddeclaration"}, {"full_name": "List.mem_rtakeWhile_imp", "code": "theorem mem_rtakeWhile_imp {x : \u03b1} (hx : x \u2208 rtakeWhile p l) : p x", "start": [238, 1], "end": [240, 29], "kind": "commanddeclaration"}, {"full_name": "List.rtakeWhile_idempotent", "code": "theorem rtakeWhile_idempotent : rtakeWhile p (rtakeWhile p l) = rtakeWhile p l", "start": [245, 1], "end": [246, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Filtration.lean", "imports": ["Mathlib/RingTheory/Noetherian.lean", "Mathlib/RingTheory/Ideal/LocalRing.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Hom/Lattice.lean", "Mathlib/Data/Polynomial/Module.lean", "Mathlib/RingTheory/ReesAlgebra.lean", "Mathlib/RingTheory/Finiteness.lean"], "premises": [{"full_name": "Ideal.Filtration", "code": "@[ext]\nstructure Ideal.Filtration (M : Type u) [AddCommGroup M] [Module R M] where\n  N : \u2115 \u2192 Submodule R M\n  mono : \u2200 i, N (i + 1) \u2264 N i\n  smul_le : \u2200 i, I \u2022 N i \u2264 N (i + 1)", "start": [51, 1], "end": [57, 37], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.pow_smul_le", "code": "theorem pow_smul_le (i j : \u2115) : I ^ i \u2022 F.N j \u2264 F.N (i + j)", "start": [64, 1], "end": [68, 61], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.pow_smul_le_pow_smul", "code": "theorem pow_smul_le_pow_smul (i j k : \u2115) : I ^ (i + k) \u2022 F.N j \u2264 I ^ k \u2022 F.N (i + j)", "start": [71, 1], "end": [73, 54], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.antitone", "code": "protected theorem antitone : Antitone F.N", "start": [76, 1], "end": [77, 33], "kind": "commanddeclaration"}, {"full_name": "Ideal.trivialFiltration", "code": "@[simps]\ndef _root_.Ideal.trivialFiltration (I : Ideal R) (N : Submodule R M) : I.Filtration M where\n  N _ := N\n  mono _ := le_of_eq rfl\n  smul_le _ := Submodule.smul_le_right", "start": [80, 1], "end": [85, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.sup_N", "code": "@[simp]\ntheorem sup_N : (F \u2294 F').N = F.N \u2294 F'.N", "start": [135, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.sSup_N", "code": "@[simp]\ntheorem sSup_N (S : Set (I.Filtration M)) : (sSup S).N = sSup (Ideal.Filtration.N '' S)", "start": [141, 1], "end": [143, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.inf_N", "code": "@[simp]\ntheorem inf_N : (F \u2293 F').N = F.N \u2293 F'.N", "start": [147, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.sInf_N", "code": "@[simp]\ntheorem sInf_N (S : Set (I.Filtration M)) : (sInf S).N = sInf (Ideal.Filtration.N '' S)", "start": [153, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.top_N", "code": "@[simp]\ntheorem top_N : (\u22a4 : I.Filtration M).N = \u22a4", "start": [159, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.bot_N", "code": "@[simp]\ntheorem bot_N : (\u22a5 : I.Filtration M).N = \u22a5", "start": [165, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.iSup_N", "code": "@[simp]\ntheorem iSup_N {\u03b9 : Sort*} (f : \u03b9 \u2192 I.Filtration M) : (iSup f).N = \u2a06 i, (f i).N", "start": [171, 1], "end": [173, 43], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.iInf_N", "code": "@[simp]\ntheorem iInf_N {\u03b9 : Sort*} (f : \u03b9 \u2192 I.Filtration M) : (iInf f).N = \u2a05 i, (f i).N", "start": [177, 1], "end": [179, 43], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.Stable", "code": "def Stable : Prop :=\n  \u2203 n\u2080, \u2200 n \u2265 n\u2080, I \u2022 F.N n = F.N (n + 1)", "start": [190, 1], "end": [192, 42], "kind": "commanddeclaration"}, {"full_name": "Ideal.stableFiltration", "code": "@[simps]\ndef _root_.Ideal.stableFiltration (I : Ideal R) (N : Submodule R M) : I.Filtration M where\n  N i := I ^ i \u2022 N\n  mono i := by dsimp only; rw [add_comm, pow_add, mul_smul]; exact Submodule.smul_le_right\n  smul_le i := by dsimp only; rw [add_comm, pow_add, mul_smul, pow_one]", "start": [195, 1], "end": [200, 72], "kind": "commanddeclaration"}, {"full_name": "Ideal.stableFiltration_stable", "code": "theorem _root_.Ideal.stableFiltration_stable (I : Ideal R) (N : Submodule R M) :\n    (I.stableFiltration N).Stable", "start": [203, 1], "end": [208, 44], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.Stable.exists_pow_smul_eq", "code": "theorem Stable.exists_pow_smul_eq : \u2203 n\u2080, \u2200 k, F.N (n\u2080 + k) = I ^ k \u2022 F.N n\u2080", "start": [213, 1], "end": [220, 13], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.Stable.exists_pow_smul_eq_of_ge", "code": "theorem Stable.exists_pow_smul_eq_of_ge : \u2203 n\u2080, \u2200 n \u2265 n\u2080, F.N n = I ^ (n - n\u2080) \u2022 F.N n\u2080", "start": [223, 1], "end": [228, 42], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.stable_iff_exists_pow_smul_eq_of_ge", "code": "theorem stable_iff_exists_pow_smul_eq_of_ge :\n    F.Stable \u2194 \u2203 n\u2080, \u2200 n \u2265 n\u2080, F.N n = I ^ (n - n\u2080) \u2022 F.N n\u2080", "start": [231, 1], "end": [235, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.Stable.exists_forall_le", "code": "theorem Stable.exists_forall_le (h : F.Stable) (e : F.N 0 \u2264 F'.N 0) :\n    \u2203 n\u2080, \u2200 n, F.N (n + n\u2080) \u2264 F'.N n", "start": [238, 1], "end": [247, 9], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.Stable.bounded_difference", "code": "theorem Stable.bounded_difference (h : F.Stable) (h' : F'.Stable) (e : F.N 0 = F'.N 0) :\n    \u2203 n\u2080, \u2200 n, F.N (n + n\u2080) \u2264 F'.N n \u2227 F'.N (n + n\u2080) \u2264 F.N n", "start": [250, 1], "end": [256, 79], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.submodule", "code": "protected def submodule : Submodule (reesAlgebra I) (PolynomialModule R M) where\n  carrier := { f | \u2200 i, f i \u2208 F.N i }\n  add_mem' hf hg i := Submodule.add_mem _ (hf i) (hg i)\n  zero_mem' i := Submodule.zero_mem _\n  smul_mem' r f hf i := by\n    rw [Subalgebra.smul_def, PolynomialModule.smul_apply]\n    apply Submodule.sum_mem\n    rintro \u27e8j, k\u27e9 e\n    rw [Finset.Nat.mem_antidiagonal] at e\n    subst e\n    exact F.pow_smul_le j k (Submodule.smul_mem_smul (r.2 j) (hf k))", "start": [263, 1], "end": [274, 69], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.mem_submodule", "code": "@[simp]\ntheorem mem_submodule (f : PolynomialModule R M) : f \u2208 F.submodule \u2194 \u2200 i, f i \u2208 F.N i", "start": [277, 1], "end": [279, 10], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.inf_submodule", "code": "theorem inf_submodule : (F \u2293 F').submodule = F.submodule \u2293 F'.submodule", "start": [282, 1], "end": [284, 19], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.submoduleInfHom", "code": "def submoduleInfHom :\n    InfHom (I.Filtration M) (Submodule (reesAlgebra I) (PolynomialModule R M)) where\n  toFun := Ideal.Filtration.submodule\n  map_inf' := inf_submodule", "start": [289, 1], "end": [293, 28], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.submodule_closure_single", "code": "theorem submodule_closure_single :\n    AddSubmonoid.closure (\u22c3 i, single R i '' (F.N i : Set M)) = F.submodule.toAddSubmonoid", "start": [298, 1], "end": [311, 95], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.submodule_span_single", "code": "theorem submodule_span_single :\n    Submodule.span (reesAlgebra I) (\u22c3 i, single R i '' (F.N i : Set M)) = F.submodule", "start": [314, 1], "end": [317, 51], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.submodule_eq_span_le_iff_stable_ge", "code": "theorem submodule_eq_span_le_iff_stable_ge (n\u2080 : \u2115) :\n    F.submodule = Submodule.span _ (\u22c3 i \u2264 n\u2080, single R i '' (F.N i : Set M)) \u2194\n      \u2200 n \u2265 n\u2080, I \u2022 F.N n = F.N (n + 1)", "start": [320, 1], "end": [363, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.submodule_fg_iff_stable", "code": "theorem submodule_fg_iff_stable (hF' : \u2200 i, (F.N i).FG) : F.submodule.FG \u2194 F.Stable", "start": [366, 1], "end": [400, 19], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.Stable.of_le", "code": "theorem Stable.of_le [IsNoetherianRing R] [Module.Finite R M] (hF : F.Stable)\n    {F' : I.Filtration M} (hf : F' \u2264 F) : F'.Stable", "start": [405, 1], "end": [412, 61], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.Stable.inter_right", "code": "theorem Stable.inter_right [IsNoetherianRing R] [Module.Finite R M] (hF : F.Stable) :\n    (F \u2293 F').Stable", "start": [415, 1], "end": [417, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.Filtration.Stable.inter_left", "code": "theorem Stable.inter_left [IsNoetherianRing R] [Module.Finite R M] (hF : F.Stable) :\n    (F' \u2293 F).Stable", "start": [420, 1], "end": [422, 24], "kind": "commanddeclaration"}, {"full_name": "Ideal.exists_pow_inf_eq_pow_smul", "code": "theorem Ideal.exists_pow_inf_eq_pow_smul [IsNoetherianRing R] [Module.Finite R M]\n    (N : Submodule R M) : \u2203 k : \u2115, \u2200 n \u2265 k, I ^ n \u2022 \u22a4 \u2293 N = I ^ (n - k) \u2022 (I ^ k \u2022 \u22a4 \u2293 N)", "start": [429, 1], "end": [432, 95], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_iInf_smul_pow_eq_bot_iff", "code": "theorem Ideal.mem_iInf_smul_pow_eq_bot_iff [IsNoetherianRing R] [Module.Finite R M] (x : M) :\n    x \u2208 (\u2a05 i : \u2115, I ^ i \u2022 \u22a4 : Submodule R M) \u2194 \u2203 r : I, (r : R) \u2022 x = x", "start": [435, 1], "end": [456, 46], "kind": "commanddeclaration"}, {"full_name": "Ideal.iInf_pow_smul_eq_bot_of_localRing", "code": "theorem Ideal.iInf_pow_smul_eq_bot_of_localRing [IsNoetherianRing R] [LocalRing R]\n    [Module.Finite R M] (h : I \u2260 \u22a4) : (\u2a05 i : \u2115, I ^ i \u2022 \u22a4 : Submodule R M) = \u22a5", "start": [459, 1], "end": [466, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.iInf_pow_eq_bot_of_localRing", "code": "theorem Ideal.iInf_pow_eq_bot_of_localRing [IsNoetherianRing R] [LocalRing R] (h : I \u2260 \u22a4) :\n    \u2a05 i : \u2115, I ^ i = \u22a5", "start": [469, 1], "end": [474, 48], "kind": "commanddeclaration"}, {"full_name": "Ideal.iInf_pow_eq_bot_of_isDomain", "code": "theorem Ideal.iInf_pow_eq_bot_of_isDomain [IsNoetherianRing R] [IsDomain R] (h : I \u2260 \u22a4) :\n    \u2a05 i : \u2115, I ^ i = \u22a5", "start": [477, 1], "end": [487, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Heyting/Boundary.lean", "imports": ["Mathlib/Order/BooleanAlgebra.lean", "Mathlib/Tactic/Common.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Coheyting.boundary", "code": "def boundary (a : \u03b1) : \u03b1 :=\n  a \u2293 \uffe2a", "start": [34, 1], "end": [37, 9], "kind": "commanddeclaration"}, {"full_name": "Coheyting.inf_hnot_self", "code": "theorem inf_hnot_self (a : \u03b1) : a \u2293 \uffe2a = \u2202 a", "start": [46, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "Coheyting.boundary_le", "code": "theorem boundary_le : \u2202 a \u2264 a", "start": [50, 1], "end": [51, 14], "kind": "commanddeclaration"}, {"full_name": "Coheyting.boundary_le_hnot", "code": "theorem boundary_le_hnot : \u2202 a \u2264 \uffe2a", "start": [54, 1], "end": [55, 15], "kind": "commanddeclaration"}, {"full_name": "Coheyting.boundary_bot", "code": "@[simp]\ntheorem boundary_bot : \u2202 (\u22a5 : \u03b1) = \u22a5", "start": [58, 1], "end": [60, 13], "kind": "commanddeclaration"}, {"full_name": "Coheyting.boundary_top", "code": "@[simp]\ntheorem boundary_top : \u2202 (\u22a4 : \u03b1) = \u22a5", "start": [63, 1], "end": [64, 79], "kind": "commanddeclaration"}, {"full_name": "Coheyting.boundary_hnot_le", "code": "theorem boundary_hnot_le (a : \u03b1) : \u2202 (\uffe2a) \u2264 \u2202 a", "start": [67, 1], "end": [68, 55], "kind": "commanddeclaration"}, {"full_name": "Coheyting.boundary_hnot_hnot", "code": "@[simp]\ntheorem boundary_hnot_hnot (a : \u03b1) : \u2202 (\uffe2\uffe2a) = \u2202 (\uffe2a)", "start": [71, 1], "end": [73, 47], "kind": "commanddeclaration"}, {"full_name": "Coheyting.hnot_boundary", "code": "@[simp]\ntheorem hnot_boundary (a : \u03b1) : \uffe2\u2202 a = \u22a4", "start": [76, 1], "end": [77, 94], "kind": "commanddeclaration"}, {"full_name": "Coheyting.boundary_inf", "code": "theorem boundary_inf (a b : \u03b1) : \u2202 (a \u2293 b) = \u2202 a \u2293 b \u2294 a \u2293 \u2202 b", "start": [80, 1], "end": [83, 67], "kind": "commanddeclaration"}, {"full_name": "Coheyting.boundary_inf_le", "code": "theorem boundary_inf_le : \u2202 (a \u2293 b) \u2264 \u2202 a \u2294 \u2202 b", "start": [86, 1], "end": [87, 69], "kind": "commanddeclaration"}, {"full_name": "Coheyting.boundary_sup_le", "code": "theorem boundary_sup_le : \u2202 (a \u2294 b) \u2264 \u2202 a \u2294 \u2202 b", "start": [90, 1], "end": [94, 52], "kind": "commanddeclaration"}, {"full_name": "Coheyting.boundary_le_boundary_sup_sup_boundary_inf_left", "code": "theorem boundary_le_boundary_sup_sup_boundary_inf_left : \u2202 a \u2264 \u2202 (a \u2294 b) \u2294 \u2202 (a \u2293 b)", "start": [106, 1], "end": [118, 67], "kind": "commanddeclaration"}, {"full_name": "Coheyting.boundary_le_boundary_sup_sup_boundary_inf_right", "code": "theorem boundary_le_boundary_sup_sup_boundary_inf_right : \u2202 b \u2264 \u2202 (a \u2294 b) \u2294 \u2202 (a \u2293 b)", "start": [121, 1], "end": [123, 55], "kind": "commanddeclaration"}, {"full_name": "Coheyting.boundary_sup_sup_boundary_inf", "code": "theorem boundary_sup_sup_boundary_inf (a b : \u03b1) : \u2202 (a \u2294 b) \u2294 \u2202 (a \u2293 b) = \u2202 a \u2294 \u2202 b", "start": [126, 1], "end": [129, 54], "kind": "commanddeclaration"}, {"full_name": "Coheyting.boundary_idem", "code": "@[simp]\ntheorem boundary_idem (a : \u03b1) : \u2202 \u2202 a = \u2202 a", "start": [132, 1], "end": [133, 91], "kind": "commanddeclaration"}, {"full_name": "Coheyting.hnot_hnot_sup_boundary", "code": "theorem hnot_hnot_sup_boundary (a : \u03b1) : \uffe2\uffe2a \u2294 \u2202 a = a", "start": [136, 1], "end": [138, 21], "kind": "commanddeclaration"}, {"full_name": "Coheyting.hnot_eq_top_iff_exists_boundary", "code": "theorem hnot_eq_top_iff_exists_boundary : \uffe2a = \u22a4 \u2194 \u2203 b, \u2202 b = a", "start": [141, 1], "end": [144, 27], "kind": "commanddeclaration"}, {"full_name": "Coheyting.boundary_eq_bot", "code": "@[simp]\ntheorem Coheyting.boundary_eq_bot (a : \u03b1) : \u2202 a = \u22a5", "start": [155, 1], "end": [157, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Log/Monotone.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.log_mul_self_monotoneOn", "code": "theorem log_mul_self_monotoneOn : MonotoneOn (fun x : \u211d => log x * x) { x | 1 \u2264 x }", "start": [32, 1], "end": [39, 47], "kind": "commanddeclaration"}, {"full_name": "Real.log_div_self_antitoneOn", "code": "theorem log_div_self_antitoneOn : AntitoneOn (fun x : \u211d => log x / x) { x | exp 1 \u2264 x }", "start": [42, 1], "end": [54, 41], "kind": "commanddeclaration"}, {"full_name": "Real.log_div_self_rpow_antitoneOn", "code": "theorem log_div_self_rpow_antitoneOn {a : \u211d} (ha : 0 < a) :\n    AntitoneOn (fun x : \u211d => log x / x ^ a) { x | exp (1 / a) \u2264 x }", "start": [57, 1], "end": [83, 50], "kind": "commanddeclaration"}, {"full_name": "Real.log_div_sqrt_antitoneOn", "code": "theorem log_div_sqrt_antitoneOn : AntitoneOn (fun x : \u211d => log x / sqrt x) { x | exp 2 \u2264 x }", "start": [86, 1], "end": [89, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Internal/Types.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/Types/Symmetric.lean", "Mathlib/CategoryTheory/Monoidal/CommMon_.lean", "Mathlib/Algebra/Category/MonCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MonTypeEquivalenceMon.monMonoid", "code": "instance monMonoid (A : Mon_ (Type u)) : Monoid A.X where\n  one := A.one PUnit.unit\n  mul x y := A.mul (x, y)\n  one_mul x := by convert congr_fun A.one_mul (PUnit.unit, x)\n  mul_one x := by convert congr_fun A.mul_one (x, PUnit.unit)\n  mul_assoc x y z := by convert congr_fun A.mul_assoc ((x, y), z)", "start": [28, 1], "end": [33, 66], "kind": "commanddeclaration"}, {"full_name": "MonTypeEquivalenceMon.functor", "code": "noncomputable def functor : Mon_ (Type u) \u2964 MonCat.{u} where\n  obj A := MonCat.of A.X\n  map f :=\n    { toFun := f.hom\n      map_one' := congr_fun f.one_hom PUnit.unit\n      map_mul' := fun x y => congr_fun f.mul_hom (x, y) }", "start": [37, 1], "end": [44, 58], "kind": "commanddeclaration"}, {"full_name": "MonTypeEquivalenceMon.inverse", "code": "noncomputable def inverse : MonCat.{u} \u2964 Mon_ (Type u) where\n  obj A :=\n    { X := A\n      one := fun _ => 1\n      mul := fun p => p.1 * p.2\n      one_mul := by ext \u27e8_, _\u27e9; dsimp; simp\n      mul_one := by ext \u27e8_, _\u27e9; dsimp; simp\n      mul_assoc := by ext \u27e8\u27e8x, y\u27e9, z\u27e9; simp [mul_assoc] }\n  map f := { hom := f }", "start": [48, 1], "end": [58, 24], "kind": "commanddeclaration"}, {"full_name": "monTypeEquivalenceMon", "code": "noncomputable def monTypeEquivalenceMon : Mon_ (Type u) \u224c MonCat.{u} where\n  functor := functor\n  inverse := inverse\n  unitIso :=\n    NatIso.ofComponents\n      (fun A =>\n        { hom := { hom := \ud835\udfd9 _ }\n          inv := { hom := \ud835\udfd9 _ } })\n      (by aesop_cat)\n  counitIso :=\n    NatIso.ofComponents\n      (fun A =>\n        { hom :=\n            { toFun := id\n              map_one' := rfl\n              map_mul' := fun x y => rfl }\n          inv :=\n            { toFun := id\n              map_one' := rfl\n              map_mul' := fun x y => rfl } })\n      (by aesop_cat)", "start": [66, 1], "end": [89, 21], "kind": "commanddeclaration"}, {"full_name": "monTypeEquivalenceMonForget", "code": "noncomputable def monTypeEquivalenceMonForget :\n    MonTypeEquivalenceMon.functor \u22d9 forget MonCat \u2245 Mon_.forget (Type u) :=\n  NatIso.ofComponents (fun A => Iso.refl _) (by aesop_cat)", "start": [93, 1], "end": [98, 59], "kind": "commanddeclaration"}, {"full_name": "monTypeInhabited", "code": "noncomputable instance monTypeInhabited : Inhabited (Mon_ (Type u)) :=\n  \u27e8MonTypeEquivalenceMon.inverse.obj (MonCat.of PUnit)\u27e9", "start": [102, 1], "end": [103, 56], "kind": "commanddeclaration"}, {"full_name": "CommMonTypeEquivalenceCommMon.commMonCommMonoid", "code": "instance commMonCommMonoid (A : CommMon_ (Type u)) : CommMonoid A.X :=\n  { MonTypeEquivalenceMon.monMonoid A.toMon_ with\n    mul_comm := fun x y => by convert congr_fun A.mul_comm (y, x) }", "start": [109, 1], "end": [111, 68], "kind": "commanddeclaration"}, {"full_name": "CommMonTypeEquivalenceCommMon.functor", "code": "noncomputable def functor : CommMon_ (Type u) \u2964 CommMonCat.{u} where\n  obj A := CommMonCat.of A.X\n  map f := MonTypeEquivalenceMon.functor.map f", "start": [115, 1], "end": [119, 47], "kind": "commanddeclaration"}, {"full_name": "CommMonTypeEquivalenceCommMon.inverse", "code": "noncomputable def inverse : CommMonCat.{u} \u2964 CommMon_ (Type u) where\n  obj A :=\n    { MonTypeEquivalenceMon.inverse.obj ((forget\u2082 CommMonCat MonCat).obj A) with\n      mul_comm := by\n        ext \u27e8x : A, y : A\u27e9\n        exact CommMonoid.mul_comm y x }\n  map f := MonTypeEquivalenceMon.inverse.map ((forget\u2082 CommMonCat MonCat).map f)", "start": [123, 1], "end": [131, 81], "kind": "commanddeclaration"}, {"full_name": "commMonTypeEquivalenceCommMon", "code": "noncomputable def commMonTypeEquivalenceCommMon : CommMon_ (Type u) \u224c CommMonCat.{u} where\n  functor := functor\n  inverse := inverse\n  unitIso :=\n    NatIso.ofComponents\n      (fun A =>\n        { hom := { hom := \ud835\udfd9 _ }\n          inv := { hom := \ud835\udfd9 _ } })\n      (by aesop_cat)\n  counitIso :=\n    NatIso.ofComponents\n      (fun A =>\n        { hom :=\n            { toFun := id\n              map_one' := rfl\n              map_mul' := fun x y => rfl }\n          inv :=\n            { toFun := id\n              map_one' := rfl\n              map_mul' := fun x y => rfl } })\n      (by aesop_cat)", "start": [139, 1], "end": [162, 21], "kind": "commanddeclaration"}, {"full_name": "commMonTypeEquivalenceCommMonForget", "code": "noncomputable def commMonTypeEquivalenceCommMonForget :\n    CommMonTypeEquivalenceCommMon.functor \u22d9 forget\u2082 CommMonCat MonCat \u2245\n      CommMon_.forget\u2082Mon_ (Type u) \u22d9 MonTypeEquivalenceMon.functor :=\n  NatIso.ofComponents (fun A => Iso.refl _) (by aesop_cat)", "start": [166, 1], "end": [172, 59], "kind": "commanddeclaration"}, {"full_name": "commMonTypeInhabited", "code": "noncomputable instance commMonTypeInhabited : Inhabited (CommMon_ (Type u)) :=\n  \u27e8CommMonTypeEquivalenceCommMon.inverse.obj (CommMonCat.of PUnit)\u27e9", "start": [176, 1], "end": [177, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/AxGrothendieck.lean", "imports": ["Mathlib/Data/MvPolynomial/Basic.lean", "Mathlib/Data/Fintype/Card.lean", "Mathlib/RingTheory/Algebraic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ax_grothendieck_of_locally_finite", "code": "theorem ax_grothendieck_of_locally_finite {\u03b9 K R : Type*} [Field K] [Finite K] [CommRing R]\n    [Finite \u03b9] [Algebra K R] (alg : Algebra.IsAlgebraic K R) (ps : \u03b9 \u2192 MvPolynomial \u03b9 R)\n    (hinj : Injective fun v i => MvPolynomial.eval v (ps i)) :\n    Surjective fun v i => MvPolynomial.eval v (ps i)", "start": [32, 1], "end": [67, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/Nerve.lean", "imports": ["Mathlib/AlgebraicTopology/SimplicialSet.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.nerve", "code": "@[simps]\ndef nerve (C : Type u) [Category.{v} C] : SSet.{max u v} where\n  obj \u0394 := SimplexCategory.toCat.obj \u0394.unop \u2964 C\n  map f x := SimplexCategory.toCat.map f.unop \u22d9 x", "start": [29, 1], "end": [33, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.nerveFunctor", "code": "@[simps]\ndef nerveFunctor : Cat \u2964 SSet where\n  obj C := nerve C\n  map F := { app := fun \u0394 x => x \u22d9 F }", "start": [39, 1], "end": [43, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/QuadraticForm/Real.lean", "imports": ["Mathlib/LinearAlgebra/QuadraticForm/IsometryEquiv.lean", "Mathlib/Data/Real/Sign.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "QuadraticForm.isometryEquivSignWeightedSumSquares", "code": "noncomputable def isometryEquivSignWeightedSumSquares [DecidableEq \u03b9] (w : \u03b9 \u2192 \u211d) :\n    IsometryEquiv (weightedSumSquares \u211d w) (weightedSumSquares \u211d (Real.sign \u2218 w)) := by\n  let u i := if h : w i = 0 then (1 : \u211d\u02e3) else Units.mk0 (w i) h\n  have hu' : \u2200 i : \u03b9, (Real.sign (u i) * u i) ^ (-(1 / 2 : \u211d)) \u2260 0 := by\n    intro i\n    refine' (ne_of_lt (Real.rpow_pos_of_pos (sign_mul_pos_of_ne_zero _ <| Units.ne_zero _) _)).symm\n  convert\n    (weightedSumSquares \u211d w).isometryEquivBasisRepr\n      ((Pi.basisFun \u211d \u03b9).unitsSMul fun i => (isUnit_iff_ne_zero.2 <| hu' i).unit)\n  ext1 v\n  rw [basisRepr_apply, weightedSumSquares_apply, weightedSumSquares_apply]\n  refine' sum_congr rfl fun j hj => _\n  have hsum :\n    (\u2211 i : \u03b9, v i \u2022 ((isUnit_iff_ne_zero.2 <| hu' i).unit : \u211d) \u2022 (Pi.basisFun \u211d \u03b9) i) j =\n      v j \u2022 (Real.sign (u j) * u j) ^ (-(1 / 2 : \u211d)) := by\n    rw [Finset.sum_apply, sum_eq_single j, Pi.basisFun_apply, IsUnit.unit_spec,\n      LinearMap.stdBasis_apply, Pi.smul_apply, Pi.smul_apply, Function.update_same, smul_eq_mul,\n      smul_eq_mul, smul_eq_mul, mul_one]\n    intro i _ hij\n    rw [Pi.basisFun_apply, LinearMap.stdBasis_apply, Pi.smul_apply, Pi.smul_apply,\n      Function.update_noteq hij.symm, Pi.zero_apply, smul_eq_mul, smul_eq_mul,\n      mul_zero, mul_zero]\n    intro hj'; exact False.elim (hj' hj)\n  simp_rw [Basis.unitsSMul_apply]\n  erw [hsum]\n  simp only [Function.comp, smul_eq_mul]\n  split_ifs with h\n  \u00b7 simp only [h, zero_smul, zero_mul, Real.sign_zero]\n  have hwu : w j = u j := by simp only [dif_neg h, Units.val_mk0]\n  simp only [Units.val_mk0]\n  rw [hwu]\n  suffices\n    (u j : \u211d).sign * v j * v j =\n      (Real.sign (u j) * u j) ^ (-(1 / 2 : \u211d)) * (Real.sign (u j) * u j) ^ (-(1 / 2 : \u211d)) *\n            u j *\n          v j *\n        v j\n    by erw [\u2190 mul_assoc, this]; ring\n  rw [\u2190 Real.rpow_add (sign_mul_pos_of_ne_zero _ <| Units.ne_zero _),\n    show -(1 / 2 : \u211d) + -(1 / 2) = -1 by ring, Real.rpow_neg_one, mul_inv, inv_sign,\n    mul_assoc (Real.sign (u j)) (u j)\u207b\u00b9, inv_mul_cancel (Units.ne_zero _), mul_one]", "start": [33, 1], "end": [75, 84], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.equivalent_one_neg_one_weighted_sum_squared", "code": "theorem equivalent_one_neg_one_weighted_sum_squared {M : Type*} [AddCommGroup M] [Module \u211d M]\n    [FiniteDimensional \u211d M] (Q : QuadraticForm \u211d M) (hQ : (associated (R := \u211d) Q).Nondegenerate) :\n    \u2203 w : Fin (FiniteDimensional.finrank \u211d M) \u2192 \u211d,\n      (\u2200 i, w i = -1 \u2228 w i = 1) \u2227 Equivalent Q (weightedSumSquares \u211d w)", "start": [78, 1], "end": [86, 76], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.equivalent_one_zero_neg_one_weighted_sum_squared", "code": "theorem equivalent_one_zero_neg_one_weighted_sum_squared {M : Type*} [AddCommGroup M] [Module \u211d M]\n    [FiniteDimensional \u211d M] (Q : QuadraticForm \u211d M) :\n    \u2203 w : Fin (FiniteDimensional.finrank \u211d M) \u2192 \u211d,\n      (\u2200 i, w i = -1 \u2228 w i = 0 \u2228 w i = 1) \u2227 Equivalent Q (weightedSumSquares \u211d w)", "start": [89, 1], "end": [97, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/UpperLower/LocallyFinite.lean", "imports": ["Mathlib/Order/UpperLower/Basic.lean", "Mathlib/Order/LocallyFinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.Finite.upperClosure", "code": "protected theorem Finite.upperClosure [LocallyFiniteOrderTop \u03b1] (hs : s.Finite) :\n    (upperClosure s : Set \u03b1).Finite", "start": [22, 1], "end": [25, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.lowerClosure", "code": "protected theorem Finite.lowerClosure [LocallyFiniteOrderBot \u03b1] (hs : s.Finite) :\n    (lowerClosure s : Set \u03b1).Finite", "start": [28, 1], "end": [31, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/ModEq.lean", "imports": ["Mathlib/Order/Filter/AtTopBot.lean", "Mathlib/Data/Nat/Parity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.frequently_modEq", "code": "theorem frequently_modEq {n : \u2115} (h : n \u2260 0) (d : \u2115) : \u2203\u1da0 m in atTop, m \u2261 d [MOD n]", "start": [22, 1], "end": [25, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.frequently_mod_eq", "code": "theorem frequently_mod_eq {d n : \u2115} (h : d < n) : \u2203\u1da0 m in atTop, m % n = d", "start": [28, 1], "end": [29, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.frequently_even", "code": "theorem frequently_even : \u2203\u1da0 m : \u2115 in atTop, Even m", "start": [32, 1], "end": [33, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.frequently_odd", "code": "theorem frequently_odd : \u2203\u1da0 m : \u2115 in atTop, Odd m", "start": [36, 1], "end": [37, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/ODE/Gronwall.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/ExpDeriv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "gronwallBound", "code": "noncomputable def gronwallBound (\u03b4 K \u03b5 x : \u211d) : \u211d :=\n  if K = 0 then \u03b4 + \u03b5 * x else \u03b4 * exp (K * x) + \u03b5 / K * (exp (K * x) - 1)", "start": [43, 1], "end": [45, 75], "kind": "commanddeclaration"}, {"full_name": "gronwallBound_K0", "code": "theorem gronwallBound_K0 (\u03b4 \u03b5 : \u211d) : gronwallBound \u03b4 0 \u03b5 = fun x => \u03b4 + \u03b5 * x", "start": [48, 1], "end": [49, 29], "kind": "commanddeclaration"}, {"full_name": "gronwallBound_of_K_ne_0", "code": "theorem gronwallBound_of_K_ne_0 {\u03b4 K \u03b5 : \u211d} (hK : K \u2260 0) :\n    gronwallBound \u03b4 K \u03b5 = fun x => \u03b4 * exp (K * x) + \u03b5 / K * (exp (K * x) - 1)", "start": [53, 1], "end": [55, 28], "kind": "commanddeclaration"}, {"full_name": "hasDerivAt_gronwallBound", "code": "theorem hasDerivAt_gronwallBound (\u03b4 K \u03b5 x : \u211d) :\n    HasDerivAt (gronwallBound \u03b4 K \u03b5) (K * gronwallBound \u03b4 K \u03b5 x + \u03b5) x", "start": [59, 1], "end": [70, 9], "kind": "commanddeclaration"}, {"full_name": "hasDerivAt_gronwallBound_shift", "code": "theorem hasDerivAt_gronwallBound_shift (\u03b4 K \u03b5 x a : \u211d) :\n    HasDerivAt (fun y => gronwallBound \u03b4 K \u03b5 (y - a)) (K * gronwallBound \u03b4 K \u03b5 (x - a) + \u03b5) x", "start": [73, 1], "end": [76, 19], "kind": "commanddeclaration"}, {"full_name": "gronwallBound_x0", "code": "theorem gronwallBound_x0 (\u03b4 K \u03b5 : \u211d) : gronwallBound \u03b4 K \u03b5 0 = \u03b4", "start": [79, 1], "end": [83, 16], "kind": "commanddeclaration"}, {"full_name": "gronwallBound_\u03b50", "code": "theorem gronwallBound_\u03b50 (\u03b4 K x : \u211d) : gronwallBound \u03b4 K 0 x = \u03b4 * exp (K * x)", "start": [86, 1], "end": [89, 73], "kind": "commanddeclaration"}, {"full_name": "gronwallBound_\u03b50_\u03b40", "code": "theorem gronwallBound_\u03b50_\u03b40 (K x : \u211d) : gronwallBound 0 K 0 x = 0", "start": [92, 1], "end": [93, 41], "kind": "commanddeclaration"}, {"full_name": "gronwallBound_continuous_\u03b5", "code": "theorem gronwallBound_continuous_\u03b5 (\u03b4 K x : \u211d) : Continuous fun \u03b5 => gronwallBound \u03b4 K \u03b5 x", "start": [96, 1], "end": [101, 91], "kind": "commanddeclaration"}, {"full_name": "le_gronwallBound_of_liminf_deriv_right_le", "code": "theorem le_gronwallBound_of_liminf_deriv_right_le {f f' : \u211d \u2192 \u211d} {\u03b4 K \u03b5 : \u211d} {a b : \u211d}\n    (hf : ContinuousOn f (Icc a b))\n    (hf' : \u2200 x \u2208 Ico a b, \u2200 r, f' x < r \u2192 \u2203\u1da0 z in \ud835\udcdd[>] x, (z - x)\u207b\u00b9 * (f z - f x) < r)\n    (ha : f a \u2264 \u03b4) (bound : \u2200 x \u2208 Ico a b, f' x \u2264 K * f x + \u03b5) :\n    \u2200 x \u2208 Icc a b, f x \u2264 gronwallBound \u03b4 K \u03b5 (x - a)", "start": [106, 1], "end": [132, 68], "kind": "commanddeclaration"}, {"full_name": "norm_le_gronwallBound_of_norm_deriv_right_le", "code": "theorem norm_le_gronwallBound_of_norm_deriv_right_le {f f' : \u211d \u2192 E} {\u03b4 K \u03b5 : \u211d} {a b : \u211d}\n    (hf : ContinuousOn f (Icc a b)) (hf' : \u2200 x \u2208 Ico a b, HasDerivWithinAt f (f' x) (Ici x) x)\n    (ha : \u2016f a\u2016 \u2264 \u03b4) (bound : \u2200 x \u2208 Ico a b, \u2016f' x\u2016 \u2264 K * \u2016f x\u2016 + \u03b5) :\n    \u2200 x \u2208 Icc a b, \u2016f x\u2016 \u2264 gronwallBound \u03b4 K \u03b5 (x - a)", "start": [135, 1], "end": [144, 74], "kind": "commanddeclaration"}, {"full_name": "dist_le_of_approx_trajectories_ODE_of_mem_set", "code": "theorem dist_le_of_approx_trajectories_ODE_of_mem_set {v : \u211d \u2192 E \u2192 E} {s : \u211d \u2192 Set E} {K : \u211d}\n    (hv : \u2200 t, \u2200\u1d49 (x \u2208 s t) (y \u2208 s t), dist (v t x) (v t y) \u2264 K * dist x y)\n    {f g f' g' : \u211d \u2192 E} {a b : \u211d} {\u03b5f \u03b5g \u03b4 : \u211d} (hf : ContinuousOn f (Icc a b))\n    (hf' : \u2200 t \u2208 Ico a b, HasDerivWithinAt f (f' t) (Ici t) t)\n    (f_bound : \u2200 t \u2208 Ico a b, dist (f' t) (v t (f t)) \u2264 \u03b5f) (hfs : \u2200 t \u2208 Ico a b, f t \u2208 s t)\n    (hg : ContinuousOn g (Icc a b)) (hg' : \u2200 t \u2208 Ico a b, HasDerivWithinAt g (g' t) (Ici t) t)\n    (g_bound : \u2200 t \u2208 Ico a b, dist (g' t) (v t (g t)) \u2264 \u03b5g) (hgs : \u2200 t \u2208 Ico a b, g t \u2208 s t)\n    (ha : dist (f a) (g a) \u2264 \u03b4) :\n    \u2200 t \u2208 Icc a b, dist (f t) (g t) \u2264 gronwallBound \u03b4 K (\u03b5f + \u03b5g) (t - a)", "start": [147, 1], "end": [171, 30], "kind": "commanddeclaration"}, {"full_name": "dist_le_of_approx_trajectories_ODE", "code": "theorem dist_le_of_approx_trajectories_ODE {v : \u211d \u2192 E \u2192 E} {K : \u211d\u22650}\n    (hv : \u2200 t, LipschitzWith K (v t)) {f g f' g' : \u211d \u2192 E} {a b : \u211d} {\u03b5f \u03b5g \u03b4 : \u211d}\n    (hf : ContinuousOn f (Icc a b)) (hf' : \u2200 t \u2208 Ico a b, HasDerivWithinAt f (f' t) (Ici t) t)\n    (f_bound : \u2200 t \u2208 Ico a b, dist (f' t) (v t (f t)) \u2264 \u03b5f) (hg : ContinuousOn g (Icc a b))\n    (hg' : \u2200 t \u2208 Ico a b, HasDerivWithinAt g (g' t) (Ici t) t)\n    (g_bound : \u2200 t \u2208 Ico a b, dist (g' t) (v t (g t)) \u2264 \u03b5g) (ha : dist (f a) (g a) \u2264 \u03b4) :\n    \u2200 t \u2208 Icc a b, dist (f t) (g t) \u2264 gronwallBound \u03b4 K (\u03b5f + \u03b5g) (t - a)", "start": [175, 1], "end": [189, 55], "kind": "commanddeclaration"}, {"full_name": "dist_le_of_trajectories_ODE_of_mem_set", "code": "theorem dist_le_of_trajectories_ODE_of_mem_set {v : \u211d \u2192 E \u2192 E} {s : \u211d \u2192 Set E} {K : \u211d}\n    (hv : \u2200 t, \u2200\u1d49 (x \u2208 s t) (y \u2208 s t), dist (v t x) (v t y) \u2264 K * dist x y)\n    {f g : \u211d \u2192 E} {a b : \u211d} {\u03b4 : \u211d} (hf : ContinuousOn f (Icc a b))\n    (hf' : \u2200 t \u2208 Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t) (hfs : \u2200 t \u2208 Ico a b, f t \u2208 s t)\n    (hg : ContinuousOn g (Icc a b)) (hg' : \u2200 t \u2208 Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t)\n    (hgs : \u2200 t \u2208 Ico a b, g t \u2208 s t) (ha : dist (f a) (g a) \u2264 \u03b4) :\n    \u2200 t \u2208 Icc a b, dist (f t) (g t) \u2264 \u03b4 * exp (K * (t - a))", "start": [193, 1], "end": [211, 43], "kind": "commanddeclaration"}, {"full_name": "dist_le_of_trajectories_ODE", "code": "theorem dist_le_of_trajectories_ODE {v : \u211d \u2192 E \u2192 E} {K : \u211d\u22650} (hv : \u2200 t, LipschitzWith K (v t))\n    {f g : \u211d \u2192 E} {a b : \u211d} {\u03b4 : \u211d} (hf : ContinuousOn f (Icc a b))\n    (hf' : \u2200 t \u2208 Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t) (hg : ContinuousOn g (Icc a b))\n    (hg' : \u2200 t \u2208 Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t) (ha : dist (f a) (g a) \u2264 \u03b4) :\n    \u2200 t \u2208 Icc a b, dist (f t) (g t) \u2264 \u03b4 * exp (K * (t - a))", "start": [215, 1], "end": [227, 32], "kind": "commanddeclaration"}, {"full_name": "ODE_solution_unique_of_mem_set", "code": "theorem ODE_solution_unique_of_mem_set {v : \u211d \u2192 E \u2192 E} {s : \u211d \u2192 Set E} {K : \u211d}\n    (hv : \u2200 t, \u2200\u1d49 (x \u2208 s t) (y \u2208 s t), dist (v t x) (v t y) \u2264 K * dist x y)\n    {f g : \u211d \u2192 E} {a b : \u211d} (hf : ContinuousOn f (Icc a b))\n    (hf' : \u2200 t \u2208 Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t) (hfs : \u2200 t \u2208 Ico a b, f t \u2208 s t)\n    (hg : ContinuousOn g (Icc a b)) (hg' : \u2200 t \u2208 Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t)\n    (hgs : \u2200 t \u2208 Ico a b, g t \u2208 s t) (ha : f a = g a) : \u2200 t \u2208 Icc a b, f t = g t", "start": [231, 1], "end": [241, 39], "kind": "commanddeclaration"}, {"full_name": "ODE_solution_unique", "code": "theorem ODE_solution_unique {v : \u211d \u2192 E \u2192 E} {K : \u211d\u22650} (hv : \u2200 t, LipschitzWith K (v t))\n    {f g : \u211d \u2192 E} {a b : \u211d} (hf : ContinuousOn f (Icc a b))\n    (hf' : \u2200 t \u2208 Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t) (hg : ContinuousOn g (Icc a b))\n    (hg' : \u2200 t \u2208 Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t) (ha : f a = g a) :\n    \u2200 t \u2208 Icc a b, f t = g t", "start": [245, 1], "end": [254, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Bicategory/FunctorBicategory.lean", "imports": ["Mathlib/CategoryTheory/Bicategory/NaturalTransformation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.OplaxNatTrans.whiskerLeft", "code": "@[simps]\ndef whiskerLeft (\u03b7 : F \u27f6 G) {\u03b8 \u03b9 : G \u27f6 H} (\u0393 : \u03b8 \u27f6 \u03b9) : \u03b7 \u226b \u03b8 \u27f6 \u03b7 \u226b \u03b9 where\n  app a := \u03b7.app a \u25c1 \u0393.app a\n  naturality {a b} f := by\n    dsimp\n    rw [associator_inv_naturality_right_assoc, whisker_exchange_assoc]\n    simp", "start": [34, 1], "end": [41, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.whiskerRight", "code": "@[simps]\ndef whiskerRight {\u03b7 \u03b8 : F \u27f6 G} (\u0393 : \u03b7 \u27f6 \u03b8) (\u03b9 : G \u27f6 H) : \u03b7 \u226b \u03b9 \u27f6 \u03b8 \u226b \u03b9 where\n  app a := \u0393.app a \u25b7 \u03b9.app a\n  naturality {a b} f := by\n    dsimp\n    simp_rw [assoc, \u2190 associator_inv_naturality_left, whisker_exchange_assoc]\n    simp", "start": [44, 1], "end": [51, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.associator", "code": "@[simps!]\ndef associator (\u03b7 : F \u27f6 G) (\u03b8 : G \u27f6 H) (\u03b9 : H \u27f6 I) : (\u03b7 \u226b \u03b8) \u226b \u03b9 \u2245 \u03b7 \u226b \u03b8 \u226b \u03b9 :=\n  ModificationIso.ofComponents (fun a => \u03b1_ (\u03b7.app a) (\u03b8.app a) (\u03b9.app a)) (by aesop_cat)", "start": [54, 1], "end": [58, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.leftUnitor", "code": "@[simps!]\ndef leftUnitor (\u03b7 : F \u27f6 G) : \ud835\udfd9 F \u226b \u03b7 \u2245 \u03b7 :=\n  ModificationIso.ofComponents (fun a => \u03bb_ (\u03b7.app a)) (by aesop_cat)", "start": [61, 1], "end": [65, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.rightUnitor", "code": "@[simps!]\ndef rightUnitor (\u03b7 : F \u27f6 G) : \u03b7 \u226b \ud835\udfd9 G \u2245 \u03b7 :=\n  ModificationIso.ofComponents (fun a => \u03c1_ (\u03b7.app a)) (by aesop_cat)", "start": [68, 1], "end": [72, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxFunctor.bicategory", "code": "@[simps!]\ninstance OplaxFunctor.bicategory : Bicategory (OplaxFunctor B C) where\n  whiskerLeft {F G H} \u03b7 _ _ \u0393 := OplaxNatTrans.whiskerLeft \u03b7 \u0393\n  whiskerRight {F G H} _ _ \u0393 \u03b7 := OplaxNatTrans.whiskerRight \u0393 \u03b7\n  associator {F G H} I := OplaxNatTrans.associator\n  leftUnitor {F G} := OplaxNatTrans.leftUnitor\n  rightUnitor {F G} := OplaxNatTrans.rightUnitor\n  whisker_exchange {a b c f g h i} \u03b7 \u03b8 := by\n    ext\n    exact whisker_exchange _ _", "start": [79, 1], "end": [90, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Group/ControlledClosure.lean", "imports": ["Mathlib/Analysis/Normed/Group/Hom.lean", "Mathlib/Analysis/SpecificLimits/Normed.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "controlled_closure_of_complete", "code": "theorem controlled_closure_of_complete {f : NormedAddGroupHom G H} {K : AddSubgroup H} {C \u03b5 : \u211d}\n    (hC : 0 < C) (h\u03b5 : 0 < \u03b5) (hyp : f.SurjectiveOnWith K C) :\n    f.SurjectiveOnWith K.topologicalClosure (C + \u03b5)", "start": [28, 1], "end": [111, 35], "kind": "commanddeclaration"}, {"full_name": "controlled_closure_range_of_complete", "code": "theorem controlled_closure_range_of_complete {f : NormedAddGroupHom G H} {K : Type*}\n    [SeminormedAddCommGroup K] {j : NormedAddGroupHom K H} (hj : \u2200 x, \u2016j x\u2016 = \u2016x\u2016) {C \u03b5 : \u211d}\n    (hC : 0 < C) (h\u03b5 : 0 < \u03b5) (hyp : \u2200 k, \u2203 g, f g = j k \u2227 \u2016g\u2016 \u2264 C * \u2016k\u2016) :\n    f.SurjectiveOnWith j.range.topologicalClosure (C + \u03b5)", "start": [114, 1], "end": [130, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/Deriv/Pi.lean", "imports": ["Mathlib/Analysis/Calculus/Deriv/Basic.lean", "Mathlib/Analysis/Calculus/FDeriv/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "hasDerivAt_update", "code": "theorem hasDerivAt_update (x : \u03b9 \u2192 \ud835\udd5c) (i : \u03b9) (y : \ud835\udd5c) :\n    HasDerivAt (Function.update x i) (Pi.single i (1 : \ud835\udd5c)) y", "start": [15, 1], "end": [22, 32], "kind": "commanddeclaration"}, {"full_name": "hasDerivAt_single", "code": "theorem hasDerivAt_single (i : \u03b9) (y : \ud835\udd5c) :\n    HasDerivAt (Pi.single (f := fun _ \u21a6 \ud835\udd5c) i) (Pi.single i (1 : \ud835\udd5c)) y", "start": [24, 1], "end": [26, 26], "kind": "commanddeclaration"}, {"full_name": "deriv_update", "code": "theorem deriv_update (x : \u03b9 \u2192 \ud835\udd5c) (i : \u03b9) (y : \ud835\udd5c) :\n    deriv (Function.update x i) y = Pi.single i (1 : \ud835\udd5c)", "start": [28, 1], "end": [30, 34], "kind": "commanddeclaration"}, {"full_name": "deriv_single", "code": "theorem deriv_single (i : \u03b9) (y : \ud835\udd5c) :\n    deriv (Pi.single (f := fun _ \u21a6 \ud835\udd5c) i) y = Pi.single i (1 : \ud835\udd5c)", "start": [32, 1], "end": [34, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Field/Power.lean", "imports": ["Mathlib/Algebra/Parity.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Field/Defs.lean", "Mathlib/Algebra/GroupWithZero/Power.lean", "Mathlib/Algebra/GroupWithZero/Bitwise.lean"], "premises": [{"full_name": "zpow_bit1_neg", "code": "@[simp]\ntheorem zpow_bit1_neg (a : \u03b1) (n : \u2124) : (-a) ^ bit1 n = -a ^ bit1 n", "start": [29, 1], "end": [31, 63], "kind": "commanddeclaration"}, {"full_name": "Odd.neg_zpow", "code": "theorem Odd.neg_zpow (h : Odd n) (a : \u03b1) : (-a) ^ n = -a ^ n", "start": [34, 1], "end": [36, 26], "kind": "commanddeclaration"}, {"full_name": "Odd.neg_one_zpow", "code": "theorem Odd.neg_one_zpow (h : Odd n) : (-1 : \u03b1) ^ n = -1", "start": [39, 1], "end": [39, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/HomotopyCategory/Shift.lean", "imports": ["Mathlib/Tactic/Linarith.lean", "Mathlib/Algebra/Homology/HomotopyCategory.lean", "Mathlib/CategoryTheory/Shift/Quotient.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/GroupPower/NegOnePow.lean"], "premises": [{"full_name": "CochainComplex.shiftFunctor", "code": "@[simps]\ndef shiftFunctor (n : \u2124) : CochainComplex C \u2124 \u2964 CochainComplex C \u2124 where\n  obj K :=\n    { X := fun i => K.X (i + n)\n      d := fun i j => n.negOnePow \u2022 K.d _ _\n      d_comp_d' := by\n        intros\n        simp only [Preadditive.comp_zsmul, Preadditive.zsmul_comp, d_comp_d, smul_zero]\n      shape := fun i j hij => by\n        dsimp\n        rw [K.shape, smul_zero]\n        intro hij'\n        apply hij\n        dsimp at hij' \u22a2\n        linarith }\n  map \u03c6 :=\n    { f := fun i => \u03c6.f _\n      comm' := by\n        intros\n        dsimp\n        simp only [Preadditive.comp_zsmul, Hom.comm, Preadditive.zsmul_comp] }\n  map_id := by intros; rfl\n  map_comp := by intros; rfl", "start": [33, 1], "end": [58, 29], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.shiftFunctorObjXIso", "code": "@[simp]\ndef shiftFunctorObjXIso (K : CochainComplex C \u2124) (n i m : \u2124) (hm : m = i + n) :\n    ((shiftFunctor C n).obj K).X i \u2245 K.X m := K.XIsoOfEq hm.symm", "start": [64, 1], "end": [67, 65], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.shiftFunctorZero'", "code": "@[simps!]\ndef shiftFunctorZero' (n : \u2124) (h : n = 0) :\n    shiftFunctor C n \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents (fun K => Hom.isoOfComponents\n    (fun i => K.shiftFunctorObjXIso _ _ _ (by linarith))\n    (fun _ _ _ => by simp [h])) (by aesop_cat)", "start": [71, 1], "end": [78, 47], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.shiftFunctorAdd'", "code": "@[simps!]\ndef shiftFunctorAdd' (n\u2081 n\u2082 n\u2081\u2082 : \u2124) (h : n\u2081 + n\u2082 = n\u2081\u2082 ) :\n    shiftFunctor C n\u2081\u2082 \u2245 shiftFunctor C n\u2081 \u22d9 shiftFunctor C n\u2082 :=\n  NatIso.ofComponents (fun K => Hom.isoOfComponents\n    (fun i => K.shiftFunctorObjXIso _ _ _ (by linarith))\n    (fun _ _ _ => by\n      subst h\n      dsimp\n      simp only [add_comm n\u2081 n\u2082, Int.negOnePow_add, Preadditive.zsmul_comp,\n        Preadditive.comp_zsmul, d_comp_XIsoOfEq_hom, smul_smul, XIsoOfEq_hom_comp_d]))\n    (by aesop_cat)", "start": [80, 1], "end": [92, 19], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.shiftFunctor_map_f'", "code": "@[simp]\nlemma shiftFunctor_map_f' {K L : CochainComplex C \u2124} (\u03c6 : K \u27f6 L) (n p : \u2124) :\n    ((CategoryTheory.shiftFunctor (CochainComplex C \u2124) n).map \u03c6).f p = \u03c6.f (p+n) := rfl", "start": [107, 1], "end": [109, 88], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.shiftFunctor_obj_d'", "code": "@[simp]\nlemma shiftFunctor_obj_d' (K : CochainComplex C \u2124) (n i j : \u2124) :\n    ((CategoryTheory.shiftFunctor (CochainComplex C \u2124) n).obj K).d i j =\n      n.negOnePow \u2022 K.d _ _ := rfl", "start": [111, 1], "end": [114, 35], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.shiftFunctorAdd_inv_app_f", "code": "lemma shiftFunctorAdd_inv_app_f (K : CochainComplex C \u2124) (a b n : \u2124) :\n    ((shiftFunctorAdd (CochainComplex C \u2124) a b).inv.app K).f n =\n      (K.XIsoOfEq (by dsimp; rw [add_comm a, add_assoc])).hom := rfl", "start": [116, 1], "end": [118, 69], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.shiftFunctorAdd_hom_app_f", "code": "lemma shiftFunctorAdd_hom_app_f (K : CochainComplex C \u2124) (a b n : \u2124) :\n    ((shiftFunctorAdd (CochainComplex C \u2124) a b).hom.app K).f n =\n      (K.XIsoOfEq (by dsimp; rw [add_comm a, add_assoc])).hom := by\n  have : IsIso (((shiftFunctorAdd (CochainComplex C \u2124) a b).inv.app K).f n) := by\n    rw [shiftFunctorAdd_inv_app_f]\n    infer_instance\n  rw [\u2190 cancel_mono (((shiftFunctorAdd (CochainComplex C \u2124) a b).inv.app K).f n),\n    \u2190 comp_f, Iso.hom_inv_id_app, id_f, shiftFunctorAdd_inv_app_f]\n  simp only [XIsoOfEq, eqToIso.hom, eqToHom_trans, eqToHom_refl]", "start": [120, 1], "end": [128, 65], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.shiftFunctorAdd'_inv_app_f'", "code": "lemma shiftFunctorAdd'_inv_app_f' (K : CochainComplex C \u2124) (a b ab : \u2124) (h : a + b = ab) (n : \u2124) :\n    ((CategoryTheory.shiftFunctorAdd' (CochainComplex C \u2124) a b ab h).inv.app K).f n =\n      (K.XIsoOfEq (by dsimp; rw [\u2190 h, add_assoc, add_comm a])).hom := by\n  subst h\n  rw [shiftFunctorAdd'_eq_shiftFunctorAdd, shiftFunctorAdd_inv_app_f]", "start": [130, 1], "end": [134, 70], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.shiftFunctorAdd'_hom_app_f'", "code": "lemma shiftFunctorAdd'_hom_app_f' (K : CochainComplex C \u2124) (a b ab : \u2124) (h : a + b = ab) (n : \u2124) :\n    ((CategoryTheory.shiftFunctorAdd' (CochainComplex C \u2124) a b ab h).hom.app K).f n =\n      (K.XIsoOfEq (by dsimp; rw [\u2190 h, add_assoc, add_comm a])).hom := by\n  subst h\n  rw [shiftFunctorAdd'_eq_shiftFunctorAdd, shiftFunctorAdd_hom_app_f]", "start": [136, 1], "end": [140, 70], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.shiftFunctorZero_inv_app_f", "code": "lemma shiftFunctorZero_inv_app_f (K : CochainComplex C \u2124) (n : \u2124) :\n    ((CategoryTheory.shiftFunctorZero (CochainComplex C \u2124) \u2124).inv.app K).f n =\n      (K.XIsoOfEq (by dsimp; rw [add_zero])).hom := rfl", "start": [142, 1], "end": [144, 56], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.shiftFunctorZero_hom_app_f", "code": "lemma shiftFunctorZero_hom_app_f (K : CochainComplex C \u2124) (n : \u2124) :\n    ((CategoryTheory.shiftFunctorZero (CochainComplex C \u2124) \u2124).hom.app K).f n =\n      (K.XIsoOfEq (by dsimp; rw [add_zero])).hom := by\n  have : IsIso (((shiftFunctorZero (CochainComplex C \u2124) \u2124).inv.app K).f n) := by\n    rw [shiftFunctorZero_inv_app_f]\n    infer_instance\n  rw [\u2190 cancel_mono (((shiftFunctorZero (CochainComplex C \u2124) \u2124).inv.app K).f n), \u2190 comp_f,\n    Iso.hom_inv_id_app, id_f, shiftFunctorZero_inv_app_f]\n  simp only [XIsoOfEq, eqToIso.hom, eqToHom_trans, eqToHom_refl]", "start": [146, 1], "end": [154, 65], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.XIsoOfEq_shift", "code": "lemma XIsoOfEq_shift (K : CochainComplex C \u2124) (n : \u2124) {p q : \u2124} (hpq : p = q) :\n    (K\u27e6n\u27e7).XIsoOfEq hpq = K.XIsoOfEq (show p + n = q + n by rw [hpq]) := rfl", "start": [156, 1], "end": [157, 77], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.shiftFunctorAdd'_eq", "code": "lemma shiftFunctorAdd'_eq (a b c : \u2124) (h : a + b = c) :\n    CategoryTheory.shiftFunctorAdd' (CochainComplex C \u2124) a b c h =\n      shiftFunctorAdd' C a b c h := by\n  ext\n  simp only [shiftFunctorAdd'_hom_app_f', XIsoOfEq, eqToIso.hom, shiftFunctorAdd'_hom_app_f]", "start": [161, 1], "end": [165, 93], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.shiftFunctorAdd_eq", "code": "lemma shiftFunctorAdd_eq (a b : \u2124) :\n    CategoryTheory.shiftFunctorAdd (CochainComplex C \u2124) a b = shiftFunctorAdd' C a b _ rfl := by\n  rw [\u2190 CategoryTheory.shiftFunctorAdd'_eq_shiftFunctorAdd, shiftFunctorAdd'_eq]", "start": [167, 1], "end": [169, 81], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.shiftFunctorZero_eq", "code": "lemma shiftFunctorZero_eq :\n    CategoryTheory.shiftFunctorZero (CochainComplex C \u2124) \u2124 = shiftFunctorZero' C 0 rfl := by\n  ext\n  rw [shiftFunctorZero_hom_app_f, shiftFunctorZero'_hom_app_f]", "start": [171, 1], "end": [174, 63], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.shiftFunctorComm_hom_app_f", "code": "lemma shiftFunctorComm_hom_app_f (K : CochainComplex C \u2124) (a b p : \u2124) :\n    ((shiftFunctorComm (CochainComplex C \u2124) a b).hom.app K).f p =\n      (K.XIsoOfEq (show p + b + a = p + a + b\n        by rw [add_assoc, add_comm b, add_assoc])).hom := by\n  rw [shiftFunctorComm_eq _ _ _ _ rfl]\n  dsimp\n  rw [shiftFunctorAdd'_inv_app_f', shiftFunctorAdd'_hom_app_f']\n  simp only [XIsoOfEq, eqToIso.hom, eqToHom_trans]", "start": [178, 1], "end": [185, 51], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.mapCochainComplexShiftIso", "code": "@[simps!]\ndef mapCochainComplexShiftIso (n : \u2124) :\n    shiftFunctor _ n \u22d9 F.mapHomologicalComplex (ComplexShape.up \u2124) \u2245\n      F.mapHomologicalComplex (ComplexShape.up \u2124) \u22d9 shiftFunctor _ n :=\n  NatIso.ofComponents (fun K => HomologicalComplex.Hom.isoOfComponents (fun _ => Iso.refl _)\n    (by aesop_cat)) (fun _ => by ext; dsimp; rw [id_comp, comp_id])", "start": [200, 1], "end": [207, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.commShiftMapCochainComplex", "code": "instance commShiftMapCochainComplex :\n    (F.mapHomologicalComplex (ComplexShape.up \u2124)).CommShift \u2124 where\n  iso := F.mapCochainComplexShiftIso\n  zero := by\n    ext\n    rw [CommShift.isoZero_hom_app]\n    dsimp\n    simp only [mapCochainComplexShiftIso_hom_app_f, CochainComplex.shiftFunctorZero_inv_app_f,\n       CochainComplex.shiftFunctorZero_hom_app_f, HomologicalComplex.XIsoOfEq, eqToIso,\n       eqToHom_map, eqToHom_trans, eqToHom_refl]\n  add := fun a b => by\n    ext\n    rw [CommShift.isoAdd_hom_app]\n    dsimp\n    erw [id_comp, id_comp]\n    simp only [CochainComplex.shiftFunctorAdd_hom_app_f,\n      CochainComplex.shiftFunctorAdd_inv_app_f, HomologicalComplex.XIsoOfEq, eqToIso,\n      eqToHom_map, eqToHom_trans, eqToHom_refl]", "start": [209, 1], "end": [226, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapHomologicalComplex_commShiftIso_eq", "code": "lemma mapHomologicalComplex_commShiftIso_eq (n : \u2124) :\n    (F.mapHomologicalComplex (ComplexShape.up \u2124)).commShiftIso n =\n      F.mapCochainComplexShiftIso n := rfl", "start": [228, 1], "end": [230, 43], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.mapHomologicalComplex_commShiftIso_hom_app_f", "code": "@[simp]\nlemma mapHomologicalComplex_commShiftIso_hom_app_f (K : CochainComplex C \u2124) (n i : \u2124) :\n    (((F.mapHomologicalComplex (ComplexShape.up \u2124)).commShiftIso n).hom.app K).f i = \ud835\udfd9 _ := rfl", "start": [232, 1], "end": [234, 96], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.mapHomologicalComplex_commShiftIso_inv_app_f", "code": "@[simp]\nlemma mapHomologicalComplex_commShiftIso_inv_app_f (K : CochainComplex C \u2124) (n i : \u2124) :\n    (((F.mapHomologicalComplex (ComplexShape.up \u2124)).commShiftIso n).inv.app K).f i = \ud835\udfd9 _ := rfl", "start": [236, 1], "end": [238, 96], "kind": "mathlibtacticlemma"}, {"full_name": "Homotopy.shift", "code": "def shift {K L : CochainComplex C \u2124} {\u03c6\u2081 \u03c6\u2082 : K \u27f6 L} (h : Homotopy \u03c6\u2081 \u03c6\u2082) (n : \u2124) :\n    Homotopy (\u03c6\u2081\u27e6n\u27e7') (\u03c6\u2082\u27e6n\u27e7') where\n  hom i j := n.negOnePow \u2022 h.hom _ _\n  zero i j hij := by\n    dsimp\n    rw [h.zero, zsmul_zero]\n    intro hij'\n    dsimp at hij hij'\n    exact hij (by linarith)\n  comm := fun i => by\n    rw [dNext_eq _ (show (ComplexShape.up \u2124).Rel i (i + 1) by simp),\n      prevD_eq _ (show (ComplexShape.up \u2124).Rel (i - 1) i by simp)]\n    dsimp\n    simpa only [Preadditive.zsmul_comp, Preadditive.comp_zsmul, smul_smul,\n      Int.negOnePow_mul_self, one_smul,\n      dNext_eq _ (show (ComplexShape.up \u2124).Rel (i + n) (i + 1 + n) by dsimp; linarith),\n      prevD_eq _ (show (ComplexShape.up \u2124).Rel (i - 1 + n) (i + n) by dsimp; linarith)]\n        using h.comm (i + n)", "start": [248, 1], "end": [267, 29], "kind": "commanddeclaration"}, {"full_name": "HomotopyCategory.hasShift", "code": "noncomputable instance hasShift :\n    HasShift (HomotopyCategory C (ComplexShape.up \u2124)) \u2124 := by\n  dsimp only [HomotopyCategory]\n  infer_instance", "start": [276, 1], "end": [279, 17], "kind": "commanddeclaration"}, {"full_name": "HomotopyCategory.commShiftQuotient", "code": "noncomputable instance commShiftQuotient :\n    (HomotopyCategory.quotient C (ComplexShape.up \u2124)).CommShift \u2124 :=\n  Quotient.functor_commShift (homotopic C (ComplexShape.up \u2124)) \u2124", "start": [281, 1], "end": [283, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Padics/Hensel.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/SpecificLimits/Basic.lean", "Mathlib/Topology/Algebra/Polynomial.lean", "Mathlib/NumberTheory/Padics/PadicIntegers.lean", "Mathlib/Data/Polynomial/Identities.lean", "Mathlib/Topology/MetricSpace/CauSeqFilter.lean"], "premises": [{"full_name": "padic_polynomial_dist", "code": "theorem padic_polynomial_dist {p : \u2115} [Fact p.Prime] (F : Polynomial \u2124_[p]) (x y : \u2124_[p]) :\n    \u2016F.eval x - F.eval y\u2016 \u2264 \u2016x - y\u2016", "start": [42, 1], "end": [48, 27], "kind": "commanddeclaration"}, {"full_name": "comp_tendsto_lim", "code": "private theorem comp_tendsto_lim {p : \u2115} [Fact p.Prime] {F : Polynomial \u2124_[p]}\n    (ncs : CauSeq \u2124_[p] norm) : Tendsto (fun i => F.eval (ncs i)) atTop (\ud835\udcdd (F.eval ncs.lim))", "start": [54, 1], "end": [56, 79], "kind": "commanddeclaration"}, {"full_name": "ncs_tendsto_const", "code": "private theorem ncs_tendsto_const :\n    Tendsto (fun i => \u2016F.derivative.eval (ncs i)\u2016) atTop (\ud835\udcdd \u2016F.derivative.eval a\u2016)", "start": [64, 1], "end": [66, 58], "kind": "commanddeclaration"}, {"full_name": "ncs_tendsto_lim", "code": "private theorem ncs_tendsto_lim :\n    Tendsto (fun i => \u2016F.derivative.eval (ncs i)\u2016) atTop (\ud835\udcdd \u2016F.derivative.eval ncs.lim\u2016)", "start": [68, 1], "end": [70, 86], "kind": "commanddeclaration"}, {"full_name": "norm_deriv_eq", "code": "private theorem norm_deriv_eq : \u2016F.derivative.eval ncs.lim\u2016 = \u2016F.derivative.eval a\u2016", "start": [72, 1], "end": [73, 70], "kind": "commanddeclaration"}, {"full_name": "tendsto_zero_of_norm_tendsto_zero", "code": "private theorem tendsto_zero_of_norm_tendsto_zero : Tendsto (fun i => F.eval (ncs i)) atTop (\ud835\udcdd 0)", "start": [83, 1], "end": [84, 61], "kind": "commanddeclaration"}, {"full_name": "limit_zero_of_norm_tendsto_zero", "code": "theorem limit_zero_of_norm_tendsto_zero : F.eval ncs.lim = 0", "start": [86, 1], "end": [87, 85], "kind": "commanddeclaration"}, {"full_name": "T_gen", "code": "private def T_gen : \u211d := \u2016F.eval a / ((F.derivative.eval a ^ 2 : \u2124_[p]) : \u211a_[p])\u2016", "start": [101, 1], "end": [102, 82], "kind": "commanddeclaration"}, {"full_name": "deriv_sq_norm_pos", "code": "private theorem deriv_sq_norm_pos : 0 < \u2016F.derivative.eval a\u2016 ^ 2", "start": [108, 1], "end": [109, 39], "kind": "commanddeclaration"}, {"full_name": "deriv_sq_norm_ne_zero", "code": "private theorem deriv_sq_norm_ne_zero : \u2016F.derivative.eval a\u2016 ^ 2 \u2260 0", "start": [111, 1], "end": [112, 37], "kind": "commanddeclaration"}, {"full_name": "deriv_norm_ne_zero", "code": "private theorem deriv_norm_ne_zero : \u2016F.derivative.eval a\u2016 \u2260 0", "start": [114, 1], "end": [115, 48], "kind": "commanddeclaration"}, {"full_name": "deriv_norm_pos", "code": "private theorem deriv_norm_pos : 0 < \u2016F.derivative.eval a\u2016", "start": [117, 1], "end": [118, 70], "kind": "commanddeclaration"}, {"full_name": "deriv_ne_zero", "code": "private theorem deriv_ne_zero : F.derivative.eval a \u2260 0", "start": [120, 1], "end": [121, 47], "kind": "commanddeclaration"}, {"full_name": "T_def", "code": "private theorem T_def : T = \u2016F.eval a\u2016 / \u2016F.derivative.eval a\u2016 ^ 2", "start": [123, 1], "end": [124, 36], "kind": "commanddeclaration"}, {"full_name": "T_lt_one", "code": "private theorem T_lt_one : T < 1", "start": [126, 1], "end": [128, 22], "kind": "commanddeclaration"}, {"full_name": "T_nonneg", "code": "private theorem T_nonneg : 0 \u2264 T", "start": [130, 1], "end": [130, 50], "kind": "commanddeclaration"}, {"full_name": "T_pow_nonneg", "code": "private theorem T_pow_nonneg (n : \u2115) : 0 \u2264 T ^ n", "start": [132, 1], "end": [132, 74], "kind": "commanddeclaration"}, {"full_name": "T_pow", "code": "private theorem T_pow {n : \u2115} (hn : n \u2260 0) : T ^ n < 1", "start": [134, 1], "end": [134, 98], "kind": "commanddeclaration"}, {"full_name": "T_pow'", "code": "private theorem T_pow' (n : \u2115) : T ^ 2 ^ n < 1", "start": [136, 1], "end": [136, 90], "kind": "commanddeclaration"}, {"full_name": "ih_gen", "code": "private def ih_gen (n : \u2115) (z : \u2124_[p]) : Prop :=\n  \u2016F.derivative.eval z\u2016 = \u2016F.derivative.eval a\u2016 \u2227 \u2016F.eval z\u2016 \u2264 \u2016F.derivative.eval a\u2016 ^ 2 * T ^ 2 ^ n", "start": [139, 1], "end": [141, 101], "kind": "commanddeclaration"}, {"full_name": "ih_0", "code": "private theorem ih_0 : ih 0 a", "start": [145, 1], "end": [146, 81], "kind": "commanddeclaration"}, {"full_name": "calc_norm_le_one", "code": "private theorem calc_norm_le_one {n : \u2115} {z : \u2124_[p]} (hz : ih n z) :\n    \u2016(\u2191(F.eval z) : \u211a_[p]) / \u2191(F.derivative.eval z)\u2016 \u2264 1", "start": [148, 1], "end": [159, 94], "kind": "commanddeclaration"}, {"full_name": "calc_deriv_dist", "code": "private theorem calc_deriv_dist {z z' z1 : \u2124_[p]} (hz' : z' = z - z1)\n    (hz1 : \u2016z1\u2016 = \u2016F.eval z\u2016 / \u2016F.derivative.eval a\u2016) {n} (hz : ih n z) :\n    \u2016F.derivative.eval z' - F.derivative.eval z\u2016 < \u2016F.derivative.eval a\u2016", "start": [162, 1], "end": [174, 23], "kind": "commanddeclaration"}, {"full_name": "calc_eval_z'", "code": "private def calc_eval_z' {z z' z1 : \u2124_[p]} (hz' : z' = z - z1) {n} (hz : ih n z)\n    (h1 : \u2016(\u2191(F.eval z) : \u211a_[p]) / \u2191(F.derivative.eval z)\u2016 \u2264 1) (hzeq : z1 = \u27e8_, h1\u27e9) :\n    { q : \u2124_[p] // F.eval z' = q * z1 ^ 2 } := by\n  have hdzne : F.derivative.eval z \u2260 0 :=\n    mt norm_eq_zero.2 (by rw [hz.1]; apply deriv_norm_ne_zero; assumption)\n  have hdzne' : (\u2191(F.derivative.eval z) : \u211a_[p]) \u2260 0 := fun h => hdzne (Subtype.ext_iff_val.2 h)\n  obtain \u27e8q, hq\u27e9 := F.binomExpansion z (-z1)\n  have : \u2016(\u2191(F.derivative.eval z) * (\u2191(F.eval z) / \u2191(F.derivative.eval z)) : \u211a_[p])\u2016 \u2264 1 := by\n    rw [padicNormE.mul]\n    exact mul_le_one (PadicInt.norm_le_one _) (norm_nonneg _) h1\n  have : F.derivative.eval z * -z1 = -F.eval z := by\n    calc\n      F.derivative.eval z * -z1 =\n          F.derivative.eval z * -\u27e8\u2191(F.eval z) / \u2191(F.derivative.eval z), h1\u27e9 :=\n        by rw [hzeq]\n      _ = -(F.derivative.eval z * \u27e8\u2191(F.eval z) / \u2191(F.derivative.eval z), h1\u27e9) := (mul_neg _ _)\n      _ = -\u27e8F.derivative.eval z * (F.eval z / (F.derivative.eval z : \u2124_[p]) : \u211a_[p]), this\u27e9 :=\n        (Subtype.ext <| by simp only [PadicInt.coe_neg, PadicInt.coe_mul, Subtype.coe_mk])\n      _ = -F.eval z := by simp only [mul_div_cancel' _ hdzne', Subtype.coe_eta]\n\n  exact \u27e8q, by simpa only [sub_eq_add_neg, this, hz', add_right_neg, neg_sq, zero_add] using hq\u27e9", "start": [177, 1], "end": [197, 97], "kind": "commanddeclaration"}, {"full_name": "calc_eval_z'_norm", "code": "private def calc_eval_z'_norm {z z' z1 : \u2124_[p]} {n} (hz : ih n z) {q} (heq : F.eval z' = q * z1 ^ 2)\n    (h1 : \u2016(\u2191(F.eval z) : \u211a_[p]) / \u2191(F.derivative.eval z)\u2016 \u2264 1) (hzeq : z1 = \u27e8_, h1\u27e9) :\n    \u2016F.eval z'\u2016 \u2264 \u2016F.derivative.eval a\u2016 ^ 2 * T ^ 2 ^ (n + 1) := by\n  calc\n    \u2016F.eval z'\u2016 = \u2016q\u2016 * \u2016z1\u2016 ^ 2 := by simp [heq]\n    _ \u2264 1 * \u2016z1\u2016 ^ 2 := by gcongr; apply PadicInt.norm_le_one\n    _ = \u2016F.eval z\u2016 ^ 2 / \u2016F.derivative.eval a\u2016 ^ 2 := by simp [hzeq, hz.1, div_pow]\n    _ \u2264 (\u2016F.derivative.eval a\u2016 ^ 2 * T ^ 2 ^ n) ^ 2 / \u2016F.derivative.eval a\u2016 ^ 2 := by\n      gcongr\n      exact hz.2\n    _ = (\u2016F.derivative.eval a\u2016 ^ 2) ^ 2 * (T ^ 2 ^ n) ^ 2 / \u2016F.derivative.eval a\u2016 ^ 2 := by\n      simp only [mul_pow]\n    _ = \u2016F.derivative.eval a\u2016 ^ 2 * (T ^ 2 ^ n) ^ 2 := (div_sq_cancel _ _)\n    _ = \u2016F.derivative.eval a\u2016 ^ 2 * T ^ 2 ^ (n + 1) := by rw [\u2190 pow_mul, pow_succ' 2]", "start": [200, 1], "end": [213, 86], "kind": "commanddeclaration"}, {"full_name": "ih_n", "code": "private def ih_n {n : \u2115} {z : \u2124_[p]} (hz : ih n z) : { z' : \u2124_[p] // ih (n + 1) z' } :=\n  have h1 : \u2016(\u2191(F.eval z) : \u211a_[p]) / \u2191(F.derivative.eval z)\u2016 \u2264 1 := calc_norm_le_one hnorm hz\n  let z1 : \u2124_[p] := \u27e8_, h1\u27e9\n  let z' : \u2124_[p] := z - z1\n  \u27e8z',\n    have hdist : \u2016F.derivative.eval z' - F.derivative.eval z\u2016 < \u2016F.derivative.eval a\u2016 :=\n      calc_deriv_dist hnorm rfl (by simp [hz.1]) hz\n    have hfeq : \u2016F.derivative.eval z'\u2016 = \u2016F.derivative.eval a\u2016 := by\n      rw [sub_eq_add_neg, \u2190 hz.1, \u2190 norm_neg (F.derivative.eval z)] at hdist\n      have := PadicInt.norm_eq_of_norm_add_lt_right hdist\n      rwa [norm_neg, hz.1] at this\n    let \u27e8q, heq\u27e9 := calc_eval_z' hnorm rfl hz h1 rfl\n    have hnle : \u2016F.eval z'\u2016 \u2264 \u2016F.derivative.eval a\u2016 ^ 2 * T ^ 2 ^ (n + 1) :=\n      calc_eval_z'_norm hz heq h1 rfl\n    \u27e8hfeq, hnle\u27e9\u27e9", "start": [219, 1], "end": [235, 18], "kind": "commanddeclaration"}, {"full_name": "newton_seq_aux", "code": "private def newton_seq_aux : \u2200 n : \u2115, { z : \u2124_[p] // ih n z }\n  | 0 => \u27e8a, ih_0 hnorm\u27e9\n  | k + 1 => ih_n hnorm (newton_seq_aux k).2", "start": [240, 1], "end": [242, 45], "kind": "commanddeclaration"}, {"full_name": "newton_seq_gen", "code": "private def newton_seq_gen (n : \u2115) : \u2124_[p] :=\n  (newton_seq_aux hnorm n).1", "start": [245, 1], "end": [246, 29], "kind": "commanddeclaration"}, {"full_name": "newton_seq_deriv_norm", "code": "private theorem newton_seq_deriv_norm (n : \u2115) :\n    \u2016F.derivative.eval (newton_seq n)\u2016 = \u2016F.derivative.eval a\u2016", "start": [250, 1], "end": [252, 31], "kind": "commanddeclaration"}, {"full_name": "newton_seq_norm_le", "code": "private theorem newton_seq_norm_le (n : \u2115) :\n    \u2016F.eval (newton_seq n)\u2016 \u2264 \u2016F.derivative.eval a\u2016 ^ 2 * T ^ 2 ^ n", "start": [254, 1], "end": [256, 31], "kind": "commanddeclaration"}, {"full_name": "newton_seq_norm_eq", "code": "private theorem newton_seq_norm_eq (n : \u2115) :\n    \u2016newton_seq (n + 1) - newton_seq n\u2016 =\n    \u2016F.eval (newton_seq n)\u2016 / \u2016F.derivative.eval (newton_seq n)\u2016", "start": [258, 1], "end": [262, 34], "kind": "commanddeclaration"}, {"full_name": "newton_seq_succ_dist", "code": "private theorem newton_seq_succ_dist (n : \u2115) :\n    \u2016newton_seq (n + 1) - newton_seq n\u2016 \u2264 \u2016F.derivative.eval a\u2016 * T ^ 2 ^ n", "start": [264, 1], "end": [273, 63], "kind": "commanddeclaration"}, {"full_name": "T_pos", "code": "private theorem T_pos : T > 0", "start": [275, 1], "end": [277, 65], "kind": "commanddeclaration"}, {"full_name": "newton_seq_succ_dist_weak", "code": "private theorem newton_seq_succ_dist_weak (n : \u2115) :\n    \u2016newton_seq (n + 2) - newton_seq (n + 1)\u2016 < \u2016F.eval a\u2016 / \u2016F.derivative.eval a\u2016", "start": [279, 1], "end": [297, 43], "kind": "commanddeclaration"}, {"full_name": "newton_seq_dist_aux", "code": "private theorem newton_seq_dist_aux (n : \u2115) :\n    \u2200 k : \u2115, \u2016newton_seq (n + k) - newton_seq n\u2016 \u2264 \u2016F.derivative.eval a\u2016 * T ^ 2 ^ n", "start": [299, 1], "end": [319, 62], "kind": "commanddeclaration"}, {"full_name": "newton_seq_dist", "code": "private theorem newton_seq_dist {n k : \u2115} (hnk : n \u2264 k) :\n    \u2016newton_seq k - newton_seq n\u2016 \u2264 \u2016F.derivative.eval a\u2016 * T ^ 2 ^ n", "start": [322, 1], "end": [326, 39], "kind": "commanddeclaration"}, {"full_name": "newton_seq_dist_to_a", "code": "private theorem newton_seq_dist_to_a :\n    \u2200 n : \u2115, 0 < n \u2192 \u2016newton_seq n - a\u2016 = \u2016F.eval a\u2016 / \u2016F.derivative.eval a\u2016", "start": [328, 1], "end": [344, 50], "kind": "commanddeclaration"}, {"full_name": "bound'", "code": "private theorem bound' : Tendsto (fun n : \u2115 => \u2016F.derivative.eval a\u2016 * T ^ 2 ^ n) atTop (\ud835\udcdd 0)", "start": [346, 1], "end": [351, 63], "kind": "commanddeclaration"}, {"full_name": "bound", "code": "private theorem bound :\n    \u2200 {\u03b5}, \u03b5 > 0 \u2192 \u2203 N : \u2115, \u2200 {n}, n \u2265 N \u2192 \u2016F.derivative.eval a\u2016 * T ^ 2 ^ n < \u03b5", "start": [353, 1], "end": [360, 47], "kind": "commanddeclaration"}, {"full_name": "bound'_sq", "code": "private theorem bound'_sq :\n    Tendsto (fun n : \u2115 => \u2016F.derivative.eval a\u2016 ^ 2 * T ^ 2 ^ n) atTop (\ud835\udcdd 0)", "start": [362, 1], "end": [369, 15], "kind": "commanddeclaration"}, {"full_name": "newton_seq_is_cauchy", "code": "private theorem newton_seq_is_cauchy : IsCauSeq norm newton_seq", "start": [371, 1], "end": [379, 17], "kind": "commanddeclaration"}, {"full_name": "newton_cau_seq", "code": "private def newton_cau_seq : CauSeq \u2124_[p] norm := \u27e8_, newton_seq_is_cauchy hnorm\u27e9", "start": [381, 1], "end": [381, 82], "kind": "commanddeclaration"}, {"full_name": "soln_gen", "code": "private def soln_gen : \u2124_[p] := (newton_cau_seq hnorm).lim", "start": [384, 1], "end": [384, 59], "kind": "commanddeclaration"}, {"full_name": "soln_spec", "code": "private theorem soln_spec {\u03b5 : \u211d} (h\u03b5 : \u03b5 > 0) :\n    \u2203 N : \u2115, \u2200 {i : \u2115}, i \u2265 N \u2192 \u2016soln - newton_cau_seq hnorm i\u2016 < \u03b5", "start": [388, 1], "end": [390, 61], "kind": "commanddeclaration"}, {"full_name": "soln_deriv_norm", "code": "private theorem soln_deriv_norm : \u2016F.derivative.eval soln\u2016 = \u2016F.derivative.eval a\u2016", "start": [392, 1], "end": [393, 46], "kind": "commanddeclaration"}, {"full_name": "newton_seq_norm_tendsto_zero", "code": "private theorem newton_seq_norm_tendsto_zero :\n    Tendsto (fun i => \u2016F.eval (newton_cau_seq hnorm i)\u2016) atTop (\ud835\udcdd 0)", "start": [395, 1], "end": [397, 85], "kind": "commanddeclaration"}, {"full_name": "newton_seq_dist_tendsto", "code": "private theorem newton_seq_dist_tendsto :\n    Tendsto (fun n => \u2016newton_cau_seq hnorm n - a\u2016)\n    atTop (\ud835\udcdd (\u2016F.eval a\u2016 / \u2016F.derivative.eval a\u2016))", "start": [399, 1], "end": [403, 67], "kind": "commanddeclaration"}, {"full_name": "newton_seq_dist_tendsto'", "code": "private theorem newton_seq_dist_tendsto' :\n    Tendsto (fun n => \u2016newton_cau_seq hnorm n - a\u2016) atTop (\ud835\udcdd \u2016soln - a\u2016)", "start": [405, 1], "end": [407, 97], "kind": "commanddeclaration"}, {"full_name": "soln_dist_to_a", "code": "private theorem soln_dist_to_a : \u2016soln - a\u2016 = \u2016F.eval a\u2016 / \u2016F.derivative.eval a\u2016", "start": [409, 1], "end": [410, 93], "kind": "commanddeclaration"}, {"full_name": "soln_dist_to_a_lt_deriv", "code": "private theorem soln_dist_to_a_lt_deriv : \u2016soln - a\u2016 < \u2016F.derivative.eval a\u2016", "start": [412, 1], "end": [417, 16], "kind": "commanddeclaration"}, {"full_name": "eval_soln", "code": "private theorem eval_soln : F.eval soln = 0", "start": [419, 1], "end": [420, 71], "kind": "commanddeclaration"}, {"full_name": "soln_unique", "code": "private theorem soln_unique (z : \u2124_[p]) (hev : F.eval z = 0)\n    (hnlt : \u2016z - a\u2016 < \u2016F.derivative.eval a\u2016) : z = soln", "start": [422, 1], "end": [454, 37], "kind": "commanddeclaration"}, {"full_name": "a_soln_is_unique", "code": "private theorem a_soln_is_unique (ha : F.eval a = 0) (z' : \u2124_[p]) (hz' : F.eval z' = 0)\n    (hnormz' : \u2016z' - a\u2016 < \u2016F.derivative.eval a\u2016) : z' = a", "start": [460, 1], "end": [482, 37], "kind": "commanddeclaration"}, {"full_name": "a_is_soln", "code": "private theorem a_is_soln (ha : F.eval a = 0) :\n    F.eval a = 0 \u2227\n      \u2016a - a\u2016 < \u2016F.derivative.eval a\u2016 \u2227\n        \u2016F.derivative.eval a\u2016 = \u2016F.derivative.eval a\u2016 \u2227\n          \u2200 z', F.eval z' = 0 \u2192 \u2016z' - a\u2016 < \u2016F.derivative.eval a\u2016 \u2192 z' = a", "start": [486, 1], "end": [491, 64], "kind": "commanddeclaration"}, {"full_name": "hensels_lemma", "code": "theorem hensels_lemma :\n    \u2203 z : \u2124_[p],\n      F.eval z = 0 \u2227\n        \u2016z - a\u2016 < \u2016F.derivative.eval a\u2016 \u2227\n          \u2016F.derivative.eval z\u2016 = \u2016F.derivative.eval a\u2016 \u2227\n            \u2200 z', F.eval z' = 0 \u2192 \u2016z' - a\u2016 < \u2016F.derivative.eval a\u2016 \u2192 z' = z", "start": [493, 1], "end": [502, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Additive/PluenneckeRuzsa.lean", "imports": ["Mathlib/Data/Finset/Pointwise.lean", "Mathlib/Data/Rat/NNRat.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/GCongr.lean", "Mathlib/Combinatorics/DoubleCounting.lean"], "premises": [{"full_name": "Finset.card_div_mul_le_card_div_mul_card_div", "code": "@[to_additive card_sub_mul_le_card_sub_mul_card_sub\n      \"**Ruzsa's triangle inequality**. Subtraction version.\"]\ntheorem card_div_mul_le_card_div_mul_card_div (A B C : Finset \u03b1) :\n    (A / C).card * B.card \u2264 (A / B).card * (B / C).card", "start": [41, 1], "end": [54, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.card_div_mul_le_card_mul_mul_card_mul", "code": "@[to_additive card_sub_mul_le_card_add_mul_card_add\n      \"**Ruzsa's triangle inequality**. Sub-add-add version.\"]\ntheorem card_div_mul_le_card_mul_mul_card_mul (A B C : Finset \u03b1) :\n    (A / C).card * B.card \u2264 (A * B).card * (B * C).card", "start": [58, 1], "end": [64, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.card_mul_mul_le_card_div_mul_card_mul", "code": "@[to_additive card_add_mul_le_card_sub_mul_card_add\n      \"**Ruzsa's triangle inequality**. Add-sub-sub version.\"]\ntheorem card_mul_mul_le_card_div_mul_card_mul (A B C : Finset \u03b1) :\n    (A * C).card * B.card \u2264 (A / B).card * (B * C).card", "start": [68, 1], "end": [74, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.card_mul_mul_le_card_mul_mul_card_div", "code": "@[to_additive card_add_mul_le_card_add_mul_card_sub\n      \"**Ruzsa's triangle inequality**. Add-add-sub version.\"]\ntheorem card_mul_mul_le_card_mul_mul_card_div (A B C : Finset \u03b1) :\n    (A * C).card * B.card \u2264 (A * B).card * (B / C).card", "start": [78, 1], "end": [84, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_pluennecke_petridis", "code": "@[to_additive]\ntheorem mul_pluennecke_petridis (C : Finset \u03b1)\n    (hA : \u2200 (A') (_ : A' \u2286 A), (A * B).card * A'.card \u2264 (A' * B).card * A.card) :\n    (A * B * C).card * A.card \u2264 (A * B).card * (A * C).card", "start": [88, 1], "end": [115, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_aux", "code": "@[to_additive]\nprivate theorem mul_aux (hA : A.Nonempty) (hAB : A \u2286 B)\n    (h : \u2200 A' \u2208 B.powerset.erase \u2205, ((A * C).card : \u211a\u22650) / \u2191A.card \u2264 (A' * C).card / \u2191A'.card) :\n    \u2200 (A') (_ : A' \u2286 A), (A * C).card * A'.card \u2264 (A' * C).card * A.card", "start": [123, 1], "end": [134, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.card_mul_mul_card_le_card_mul_mul_card_mul", "code": "@[to_additive card_add_mul_card_le_card_add_mul_card_add\n      \"**Ruzsa's triangle inequality**. Addition version.\"]\ntheorem card_mul_mul_card_le_card_mul_mul_card_mul (A B C : Finset \u03b1) :\n    (A * C).card * B.card \u2264 (A * B).card * (B * C).card", "start": [136, 1], "end": [157, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.card_mul_mul_le_card_div_mul_card_div", "code": "theorem card_mul_mul_le_card_div_mul_card_div (A B C : Finset \u03b1) :\n    (A * C).card * B.card \u2264 (A / B).card * (B / C).card", "start": [161, 1], "end": [165, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.card_div_mul_le_card_mul_mul_card_div", "code": "theorem card_div_mul_le_card_mul_mul_card_div (A B C : Finset \u03b1) :\n    (A / C).card * B.card \u2264 (A * B).card * (B / C).card", "start": [168, 1], "end": [172, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.card_div_mul_le_card_div_mul_card_mul", "code": "theorem card_div_mul_le_card_div_mul_card_mul (A B C : Finset \u03b1) :\n    (A / C).card * B.card \u2264 (A / B).card * (B * C).card", "start": [175, 1], "end": [179, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.card_add_nsmul_le", "code": "theorem card_add_nsmul_le {\u03b1 : Type*} [AddCommGroup \u03b1] [DecidableEq \u03b1] {A B : Finset \u03b1}\n    (hAB : \u2200 (A') (_ : A' \u2286 A), (A + B).card * A'.card \u2264 (A' + B).card * A.card) (n : \u2115) :\n    (A + n \u2022 B).card \u2264 ((A + B).card / A.card : \u211a\u22650) ^ n * A.card", "start": [182, 1], "end": [194, 9], "kind": "commanddeclaration"}, {"full_name": "Finset.card_mul_pow_le", "code": "@[to_additive existing]\ntheorem card_mul_pow_le (hAB : \u2200 (A') (_ : A' \u2286 A), (A * B).card * A'.card \u2264 (A' * B).card * A.card)\n    (n : \u2115) : (A * B ^ n).card \u2264 ((A * B).card / A.card : \u211a\u22650) ^ n * A.card", "start": [197, 1], "end": [209, 9], "kind": "commanddeclaration"}, {"full_name": "Finset.card_pow_div_pow_le", "code": "@[to_additive \"The **Pl\u00fcnnecke-Ruzsa inequality**. Addition version. Note that this is genuinely\nharder than the subtraction version because we cannot use a double counting argument.\"]\ntheorem card_pow_div_pow_le (hA : A.Nonempty) (B : Finset \u03b1) (m n : \u2115) :\n    ((B ^ m / B ^ n).card) \u2264 ((A * B).card / A.card : \u211a\u22650) ^ (m + n) * A.card", "start": [212, 1], "end": [232, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.card_pow_div_pow_le'", "code": "@[to_additive \"The **Pl\u00fcnnecke-Ruzsa inequality**. Subtraction version.\"]\ntheorem card_pow_div_pow_le' (hA : A.Nonempty) (B : Finset \u03b1) (m n : \u2115) :\n    (B ^ m / B ^ n).card \u2264 ((A / B).card / A.card : \u211a\u22650) ^ (m + n) * A.card", "start": [236, 1], "end": [241, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.card_pow_le", "code": "@[to_additive \"Special case of the **Pl\u00fcnnecke-Ruzsa inequality**. Addition version.\"]\ntheorem card_pow_le (hA : A.Nonempty) (B : Finset \u03b1) (n : \u2115) :\n    (B ^ n).card \u2264 ((A * B).card / A.card : \u211a\u22650) ^ n * A.card", "start": [245, 1], "end": [249, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.card_pow_le'", "code": "@[to_additive \"Special case of the **Pl\u00fcnnecke-Ruzsa inequality**. Subtraction version.\"]\ntheorem card_pow_le' (hA : A.Nonempty) (B : Finset \u03b1) (n : \u2115) :\n    (B ^ n).card \u2264 ((A / B).card / A.card : \u211a\u22650) ^ n * A.card", "start": [253, 1], "end": [257, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Preserves/Opposites.lean", "imports": ["Mathlib/CategoryTheory/Limits/Preserves/Finite.lean", "Mathlib/CategoryTheory/Limits/Opposites.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.preservesLimitOp", "code": "def preservesLimitOp (K : J \u2964 C\u1d52\u1d56) (F : C \u2964 D) [PreservesColimit K.leftOp F] :\n    PreservesLimit K F.op where\n  preserves {_} hc :=\n    isLimitConeRightOpOfCocone _ (isColimitOfPreserves F (isColimitCoconeLeftOpOfCone _ hc))", "start": [39, 1], "end": [44, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitLeftOp", "code": "def preservesLimitLeftOp (K : J \u2964 C\u1d52\u1d56) (F : C \u2964 D\u1d52\u1d56) [PreservesColimit K.leftOp F] :\n    PreservesLimit K F.leftOp where\n  preserves {_} hc :=\n    isLimitConeUnopOfCocone _ (isColimitOfPreserves F (isColimitCoconeLeftOpOfCone _ hc))", "start": [47, 1], "end": [52, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitRightOp", "code": "def preservesLimitRightOp (K : J \u2964 C) (F : C\u1d52\u1d56 \u2964 D) [PreservesColimit K.op F] :\n    PreservesLimit K F.rightOp where\n  preserves {_} hc :=\n    isLimitConeRightOpOfCocone _ (isColimitOfPreserves F (isColimitConeOp _ hc))", "start": [55, 1], "end": [60, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitUnop", "code": "def preservesLimitUnop (K : J \u2964 C) (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) [PreservesColimit K.op F] :\n    PreservesLimit K F.unop where\n  preserves {_} hc :=\n    isLimitConeUnopOfCocone _ (isColimitOfPreserves F (isColimitConeOp _ hc))", "start": [63, 1], "end": [68, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitOp", "code": "def preservesColimitOp (K : J \u2964 C\u1d52\u1d56) (F : C \u2964 D) [PreservesLimit K.leftOp F] :\n    PreservesColimit K F.op where\n  preserves {_} hc :=\n    isColimitCoconeRightOpOfCone _ (isLimitOfPreserves F (isLimitConeLeftOpOfCocone _ hc))", "start": [71, 1], "end": [76, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitLeftOp", "code": "def preservesColimitLeftOp (K : J \u2964 C\u1d52\u1d56) (F : C \u2964 D\u1d52\u1d56) [PreservesLimit K.leftOp F] :\n    PreservesColimit K F.leftOp where\n  preserves {_} hc :=\n    isColimitCoconeUnopOfCone _ (isLimitOfPreserves F (isLimitConeLeftOpOfCocone _ hc))", "start": [79, 1], "end": [84, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitRightOp", "code": "def preservesColimitRightOp (K : J \u2964 C) (F : C\u1d52\u1d56 \u2964 D) [PreservesLimit K.op F] :\n    PreservesColimit K F.rightOp where\n  preserves {_} hc :=\n    isColimitCoconeRightOpOfCone _ (isLimitOfPreserves F (isLimitCoconeOp _ hc))", "start": [87, 1], "end": [92, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitUnop", "code": "def preservesColimitUnop (K : J \u2964 C) (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) [PreservesLimit K.op F] :\n    PreservesColimit K F.unop where\n  preserves {_} hc :=\n    isColimitCoconeUnopOfCone _ (isLimitOfPreserves F (isLimitCoconeOp _ hc))", "start": [95, 1], "end": [100, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOfShapeOp", "code": "def preservesLimitsOfShapeOp (F : C \u2964 D) [PreservesColimitsOfShape J\u1d52\u1d56 F] :\n    PreservesLimitsOfShape J F.op where preservesLimit {K} := preservesLimitOp K F", "start": [107, 1], "end": [110, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOfShapeLeftOp", "code": "def preservesLimitsOfShapeLeftOp (F : C \u2964 D\u1d52\u1d56) [PreservesColimitsOfShape J\u1d52\u1d56 F] :\n    PreservesLimitsOfShape J F.leftOp where preservesLimit {K} := preservesLimitLeftOp K F", "start": [113, 1], "end": [116, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOfShapeRightOp", "code": "def preservesLimitsOfShapeRightOp (F : C\u1d52\u1d56 \u2964 D) [PreservesColimitsOfShape J\u1d52\u1d56 F] :\n    PreservesLimitsOfShape J F.rightOp where preservesLimit {K} := preservesLimitRightOp K F", "start": [119, 1], "end": [122, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOfShapeUnop", "code": "def preservesLimitsOfShapeUnop (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) [PreservesColimitsOfShape J\u1d52\u1d56 F] :\n    PreservesLimitsOfShape J F.unop where preservesLimit {K} := preservesLimitUnop K F", "start": [125, 1], "end": [128, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsOfShapeOp", "code": "def preservesColimitsOfShapeOp (F : C \u2964 D) [PreservesLimitsOfShape J\u1d52\u1d56 F] :\n    PreservesColimitsOfShape J F.op where preservesColimit {K} := preservesColimitOp K F", "start": [131, 1], "end": [134, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsOfShapeLeftOp", "code": "def preservesColimitsOfShapeLeftOp (F : C \u2964 D\u1d52\u1d56) [PreservesLimitsOfShape J\u1d52\u1d56 F] :\n    PreservesColimitsOfShape J F.leftOp where preservesColimit {K} := preservesColimitLeftOp K F", "start": [137, 1], "end": [140, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsOfShapeRightOp", "code": "def preservesColimitsOfShapeRightOp (F : C\u1d52\u1d56 \u2964 D) [PreservesLimitsOfShape J\u1d52\u1d56 F] :\n    PreservesColimitsOfShape J F.rightOp where preservesColimit {K} := preservesColimitRightOp K F", "start": [143, 1], "end": [146, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsOfShapeUnop", "code": "def preservesColimitsOfShapeUnop (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) [PreservesLimitsOfShape J\u1d52\u1d56 F] :\n    PreservesColimitsOfShape J F.unop where preservesColimit {K} := preservesColimitUnop K F", "start": [149, 1], "end": [152, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsOp", "code": "def preservesLimitsOp (F : C \u2964 D) [PreservesColimits F] : PreservesLimits F.op where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShapeOp _ _", "start": [157, 1], "end": [159, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsLeftOp", "code": "def preservesLimitsLeftOp (F : C \u2964 D\u1d52\u1d56) [PreservesColimits F] : PreservesLimits F.leftOp where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShapeLeftOp _ _", "start": [162, 1], "end": [164, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsRightOp", "code": "def preservesLimitsRightOp (F : C\u1d52\u1d56 \u2964 D) [PreservesColimits F] : PreservesLimits F.rightOp where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShapeRightOp _ _", "start": [167, 1], "end": [169, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesLimitsUnop", "code": "def preservesLimitsUnop (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) [PreservesColimits F] : PreservesLimits F.unop where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShapeUnop _ _", "start": [172, 1], "end": [174, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.perservesColimitsOp", "code": "def perservesColimitsOp (F : C \u2964 D) [PreservesLimits F] : PreservesColimits F.op where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShapeOp _ _", "start": [177, 1], "end": [179, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsLeftOp", "code": "def preservesColimitsLeftOp (F : C \u2964 D\u1d52\u1d56) [PreservesLimits F] : PreservesColimits F.leftOp where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShapeLeftOp _ _", "start": [182, 1], "end": [184, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsRightOp", "code": "def preservesColimitsRightOp (F : C\u1d52\u1d56 \u2964 D) [PreservesLimits F] : PreservesColimits F.rightOp where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShapeRightOp _ _", "start": [187, 1], "end": [189, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesColimitsUnop", "code": "def preservesColimitsUnop (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) [PreservesLimits F] : PreservesColimits F.unop where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShapeUnop _ _", "start": [192, 1], "end": [194, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesFiniteLimitsOp", "code": "def preservesFiniteLimitsOp (F : C \u2964 D) [PreservesFiniteColimits F] :\n    PreservesFiniteLimits F.op where\n  preservesFiniteLimits J (_ : SmallCategory J) _ := preservesLimitsOfShapeOp J F", "start": [205, 1], "end": [209, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesFiniteLimitsLeftOp", "code": "def preservesFiniteLimitsLeftOp (F : C \u2964 D\u1d52\u1d56) [PreservesFiniteColimits F] :\n    PreservesFiniteLimits F.leftOp where\n  preservesFiniteLimits J (_ : SmallCategory J) _ := preservesLimitsOfShapeLeftOp J F", "start": [212, 1], "end": [216, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesFiniteLimitsRightOp", "code": "def preservesFiniteLimitsRightOp (F : C\u1d52\u1d56 \u2964 D) [PreservesFiniteColimits F] :\n    PreservesFiniteLimits F.rightOp where\n  preservesFiniteLimits J (_ : SmallCategory J) _ := preservesLimitsOfShapeRightOp J F", "start": [219, 1], "end": [223, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesFiniteLimitsUnop", "code": "def preservesFiniteLimitsUnop (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) [PreservesFiniteColimits F] :\n    PreservesFiniteLimits F.unop where\n  preservesFiniteLimits J (_ : SmallCategory J) _ := preservesLimitsOfShapeUnop J F", "start": [226, 1], "end": [230, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesFiniteColimitsOp", "code": "def preservesFiniteColimitsOp (F : C \u2964 D) [PreservesFiniteLimits F] :\n    PreservesFiniteColimits F.op where\n  preservesFiniteColimits J (_ : SmallCategory J) _ := preservesColimitsOfShapeOp J F", "start": [233, 1], "end": [237, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesFiniteColimitsLeftOp", "code": "def preservesFiniteColimitsLeftOp (F : C \u2964 D\u1d52\u1d56) [PreservesFiniteLimits F] :\n    PreservesFiniteColimits F.leftOp where\n  preservesFiniteColimits J (_ : SmallCategory J) _ := preservesColimitsOfShapeLeftOp J F", "start": [240, 1], "end": [244, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesFiniteColimitsRightOp", "code": "def preservesFiniteColimitsRightOp (F : C\u1d52\u1d56 \u2964 D) [PreservesFiniteLimits F] :\n    PreservesFiniteColimits F.rightOp where\n  preservesFiniteColimits J (_ : SmallCategory J) _ := preservesColimitsOfShapeRightOp J F", "start": [247, 1], "end": [251, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesFiniteColimitsUnop", "code": "def preservesFiniteColimitsUnop (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) [PreservesFiniteLimits F] :\n    PreservesFiniteColimits F.unop where\n  preservesFiniteColimits J (_ : SmallCategory J) _ := preservesColimitsOfShapeUnop J F", "start": [254, 1], "end": [258, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Extension/Well.lean", "imports": ["Mathlib/SetTheory/Ordinal/Arithmetic.lean", "Mathlib/Data/Prod/Lex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WellFounded.wellOrderExtension", "code": "noncomputable def wellOrderExtension : LinearOrder \u03b1 :=\n  @LinearOrder.lift' \u03b1 (Ordinal \u00d7\u2097 Cardinal) _ (fun a : \u03b1 => (hwf.rank a, embeddingToCardinal a))\n    fun _ _ h => embeddingToCardinal.injective <| congr_arg Prod.snd h", "start": [47, 1], "end": [59, 71], "kind": "commanddeclaration"}, {"full_name": "WellFounded.wellOrderExtension.isWellFounded_lt", "code": "instance wellOrderExtension.isWellFounded_lt : IsWellFounded \u03b1 hwf.wellOrderExtension.lt :=\n  \u27e8InvImage.wf (fun a : \u03b1 => (hwf.rank a, embeddingToCardinal a)) <|\n    Ordinal.lt_wf.prod_lex Cardinal.lt_wf\u27e9", "start": [62, 1], "end": [64, 43], "kind": "commanddeclaration"}, {"full_name": "WellFounded.exists_well_order_ge", "code": "theorem exists_well_order_ge : \u2203 s, r \u2264 s \u2227 IsWellOrder \u03b1 s", "start": [67, 1], "end": [69, 89], "kind": "commanddeclaration"}, {"full_name": "WellOrderExtension", "code": "def WellOrderExtension (\u03b1 : Type*) : Type _ := \u03b1", "start": [74, 1], "end": [75, 49], "kind": "commanddeclaration"}, {"full_name": "toWellOrderExtension", "code": "def toWellOrderExtension : \u03b1 \u2243 WellOrderExtension \u03b1 :=\n  Equiv.refl _", "start": [80, 1], "end": [82, 15], "kind": "commanddeclaration"}, {"full_name": "WellOrderExtension.wellFoundedLT", "code": "instance WellOrderExtension.wellFoundedLT [LT \u03b1] [WellFoundedLT \u03b1] :\n    WellFoundedLT (WellOrderExtension \u03b1) :=\n  WellFounded.wellOrderExtension.isWellFounded_lt _", "start": [88, 1], "end": [90, 52], "kind": "commanddeclaration"}, {"full_name": "toWellOrderExtension_strictMono", "code": "theorem toWellOrderExtension_strictMono [Preorder \u03b1] [WellFoundedLT \u03b1] :\n    StrictMono (toWellOrderExtension : \u03b1 \u2192 WellOrderExtension \u03b1)", "start": [93, 1], "end": [95, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/DoldKan/Equivalence.lean", "imports": ["Mathlib/AlgebraicTopology/DoldKan/Normalized.lean", "Mathlib/AlgebraicTopology/DoldKan/EquivalencePseudoabelian.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Abelian.DoldKan.N", "code": "def N : SimplicialObject A \u2964 ChainComplex A \u2115 :=\n  AlgebraicTopology.normalizedMooreComplex A", "start": [139, 1], "end": [141, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.DoldKan.\u0393", "code": "def \u0393 : ChainComplex A \u2115 \u2964 SimplicialObject A :=\n  Idempotents.DoldKan.\u0393", "start": [145, 1], "end": [147, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.DoldKan.comparisonN", "code": "@[simps!]\ndef comparisonN : (N : SimplicialObject A \u2964 _) \u2245 Idempotents.DoldKan.N :=\n  calc\n    N \u2245 N \u22d9 \ud835\udfed _ := Functor.leftUnitor N\n    _ \u2245 N \u22d9 (toKaroubiEquivalence _).functor \u22d9 (toKaroubiEquivalence _).inverse :=\n          isoWhiskerLeft _ (toKaroubiEquivalence _).unitIso\n    _ \u2245 (N \u22d9 (toKaroubiEquivalence _).functor) \u22d9 (toKaroubiEquivalence _).inverse :=\n          Iso.refl _\n    _ \u2245 N\u2081 \u22d9 (toKaroubiEquivalence _).inverse :=\n          isoWhiskerRight (N\u2081_iso_normalizedMooreComplex_comp_toKaroubi A).symm _\n    _ \u2245 Idempotents.DoldKan.N := Iso.refl _", "start": [150, 1], "end": [162, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.DoldKan.equivalence", "code": "@[simps! functor]\ndef equivalence : SimplicialObject A \u224c ChainComplex A \u2115 := by\n  let F : SimplicialObject A \u2964 _ := Idempotents.DoldKan.N\n  let hF : IsEquivalence F := IsEquivalence.ofEquivalence Idempotents.DoldKan.equivalence\n  letI : IsEquivalence (N : SimplicialObject A \u2964 _) := IsEquivalence.ofIso comparisonN.symm hF\n  exact N.asEquivalence", "start": [166, 1], "end": [172, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.DoldKan.equivalence_inverse", "code": "theorem equivalence_inverse : (equivalence : SimplicialObject A \u224c _).inverse = \u0393", "start": [175, 1], "end": [176, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/Superscript.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.Superscript.Mapping", "code": "structure Mapping where\n  \n  toNormal : HashMap Char Char := {}\n  \n  toSpecial : HashMap Char Char := {}\n  deriving Inhabited", "start": [36, 1], "end": [42, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Superscript.mkMapping", "code": "def mkMapping (s\u2081 s\u2082 : String) : Mapping := Id.run do\n  let mut toNormal := {}\n  let mut toSpecial := {}\n  assert! s\u2081.length == s\u2082.length\n  for sp in s\u2081.toSubstring, nm in s\u2082 do\n    assert! !toNormal.contains sp\n    assert! !toSpecial.contains nm\n    toNormal := toNormal.insert sp nm\n    toSpecial := toSpecial.insert nm sp\n  pure { toNormal, toSpecial }", "start": [44, 1], "end": [54, 31], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Superscript.Mapping.superscript", "code": "def Mapping.superscript := mkMapping\n  \"\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079\u1d43\u1d47\u1d9c\u1d48\u1d49\u1da0\u1d4d\u02b0\u2071\u02b2\u1d4f\u02e1\u1d50\u207f\u1d52\u1d56\ud801\udfa5\u02b3\u02e2\u1d57\u1d58\u1d5b\u02b7\u02e3\u02b8\u1dbb\u1d2c\u1d2e\u1d30\u1d31\u1d33\u1d34\u1d35\u1d36\u1d37\u1d38\u1d39\u1d3a\u1d3c\u1d3e\ua7f4\u1d3f\u1d40\u1d41\u2c7d\u1d42\u1d5d\u1d5e\u1d5f\u1d4b\u1dbf\u1da5\u1db9\u1d60\u1d61\u207a\u207b\u207c\u207d\u207e\"\n  \"0123456789abcdefghijklmnopqrstuvwxyzABDEGHIJKLMNOPQRTUVW\u03b2\u03b3\u03b4\u03b5\u03b8\u03b9\u03c5\u03c6\u03c7+-=()\"", "start": [56, 1], "end": [59, 75], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Superscript.Mapping.subscript", "code": "def Mapping.subscript := mkMapping\n  \"\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089\u2090\u2091\u2095\u1d62\u2c7c\u2096\u2097\u2098\u2099\u2092\u209a\u1d63\u209b\u209c\u1d64\u1d65\u2093\u1d00\u0299\u1d04\u1d05\u1d07\ua730\u0262\u029c\u026a\u1d0a\u1d0b\u029f\u1d0d\u0274\u1d0f\u1d18\ua7af\u0280\ua731\u1d1b\u1d1c\u1d20\u1d21\u028f\u1d22\u1d66\u1d67\u1d68\u1d69\u1d6a\u208a\u208b\u208c\u208d\u208e\"\n  \"0123456789aehijklmnoprstuvxABCDEFGHIJKLMNOPQRSTUVWYZ\u03b2\u03b3\u03c1\u03c6\u03c7+-=()\"", "start": [61, 1], "end": [64, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Superscript.satisfyTokensFn", "code": "partial def satisfyTokensFn (p : Char \u2192 Bool) (errorMsg : String) (many := true)\n    (k : Array (String.Pos \u00d7 String.Pos \u00d7 String.Pos) \u2192 ParserState \u2192 ParserState) :\n    ParserFn := fun c s =>\n  let start := s.pos\n  let s := takeWhile1Fn p errorMsg c s\n  if s.hasError then s else\n  let stop := s.pos\n  let s := whitespace c s\n  let toks := #[(start, stop, s.pos)]\n  if many then\n    let rec \n    loop (toks) (s : ParserState) : ParserState :=\n      let start := s.pos\n      let s := takeWhileFn p c s\n      if s.pos == start then k toks s else\n        let stop := s.pos\n        let s := whitespace c s\n        let toks := toks.push (start, stop, s.pos)\n        loop toks s\n    loop toks s\n  else k toks s", "start": [66, 1], "end": [91, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Superscript.partitionPoint", "code": "@[specialize] partial def partitionPoint (lo := 0) (hi := as.size) : Nat :=\n  if lo < hi then\n    let m := (lo + hi)/2\n    let a := as.get! m\n    if leftOfPartition a then\n      partitionPoint (m+1) hi\n    else\n      partitionPoint lo m\n  else lo", "start": [94, 1], "end": [104, 10], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Superscript.scriptFnNoAntiquot", "code": "partial def scriptFnNoAntiquot (m : Mapping) (errorMsg : String) (p : ParserFn)\n    (many := true) : ParserFn := fun c s =>\n  let start := s.pos\n  satisfyTokensFn m.toNormal.contains errorMsg many c s (k := fun toks s => Id.run do\n    let input := c.input\n    let mut newStr := \"\"\n    let mut aligns := #[((0 : String.Pos), start)]\n    for (start, stopTk, stopWs) in toks do\n      let mut pos := start\n      while pos < stopTk do\n        let c := input.get pos\n        let c' := m.toNormal.find! c\n        newStr := newStr.push c'\n        pos := pos + c\n        if String.csize c != String.csize c' then\n          aligns := aligns.push (newStr.endPos, pos)\n      newStr := newStr.push ' '\n      if stopWs.1 - stopTk.1 != 1 then\n        aligns := aligns.push (newStr.endPos, stopWs)\n    let ictx := mkInputContext newStr \"<superscript>\"\n    let s' := p.run ictx c.toParserModuleContext c.tokens (mkParserState newStr)\n    let rec \n    align (pos : String.Pos) :=\n      let i := partitionPoint aligns (\u00b7.1 \u2264 pos)\n      let (a, b) := aligns[i - 1]!\n      pos - a + b\n    let s := { s with pos := align s'.pos, errorMsg := s'.errorMsg }\n    if s.hasError then return s\n    let rec\n    \n    alignSubstr : Substring \u2192 Substring\n      | \u27e8_newStr, start, stop\u27e9 => \u27e8input, align start, align stop\u27e9,\n    \n    alignInfo : SourceInfo \u2192 SourceInfo\n      | .original leading pos trailing endPos =>\n        .original (alignSubstr leading) (align pos) (alignSubstr trailing) (align endPos)\n      | .synthetic pos endPos canonical =>\n        .synthetic (align pos) (align endPos) canonical\n      | .none => .none,\n     \n     alignSyntax : Syntax \u2192 Syntax\n      | .missing => .missing\n      | .node info kind args => .node (alignInfo info) kind (args.map alignSyntax)\n      | .atom info val =>\n        .atom (alignInfo info) val\n      | .ident info rawVal val preresolved =>\n        .ident (alignInfo info) (alignSubstr rawVal) val preresolved\n    s.pushSyntax (alignSyntax s'.stxStack.back)\n  )", "start": [106, 1], "end": [170, 4], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Superscript.scriptParser", "code": "def scriptParser (m : Mapping) (antiquotName errorMsg : String) (p : Parser)\n    (many := true) (kind : SyntaxNodeKind := by exact decl_name%) : Parser :=\n  let tokens := \"$\" :: (m.toNormal.toArray.map (\u00b7.1.toString) |>.qsort (\u00b7<\u00b7)).toList\n  let antiquotP := mkAntiquot antiquotName `term (isPseudoKind := true)\n  let p := Superscript.scriptFnNoAntiquot m errorMsg p.fn many\n  node kind {\n    info.firstTokens := .tokens tokens\n    info.collectTokens := (tokens ++ \u00b7)\n    fn := withAntiquotFn antiquotP.fn p (isCatAntiquot := true)\n  }", "start": [172, 1], "end": [191, 4], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Superscript.scriptParser.parenthesizer", "code": "def scriptParser.parenthesizer (k : SyntaxNodeKind) (p : Parenthesizer) : Parenthesizer :=\n  Parenthesizer.node.parenthesizer k p", "start": [193, 1], "end": [195, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Superscript.scriptParser.formatter", "code": "def scriptParser.formatter (k : SyntaxNodeKind) (p : Formatter) : Formatter :=\n  Formatter.node.formatter k p", "start": [197, 1], "end": [200, 31], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.superscript", "code": "def superscript (p : Parser) : Parser :=\n  Superscript.scriptParser .superscript \"superscript\" \"expected superscript character\" p", "start": [204, 1], "end": [219, 89], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.superscript.parenthesizer", "code": "@[combinator_parenthesizer superscript]\ndef superscript.parenthesizer := Superscript.scriptParser.parenthesizer ``superscript", "start": [220, 1], "end": [222, 86], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.superscript.formatter", "code": "@[combinator_formatter superscript]\ndef superscript.formatter := Superscript.scriptParser.formatter ``superscript", "start": [223, 1], "end": [225, 78], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.subscript", "code": "def subscript (p : Parser) : Parser :=\n  Superscript.scriptParser .subscript \"subscript\" \"expected subscript character\" p", "start": [228, 1], "end": [244, 83], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.subscript.parenthesizer", "code": "@[combinator_parenthesizer subscript]\ndef subscript.parenthesizer := Superscript.scriptParser.parenthesizer ``subscript", "start": [245, 1], "end": [247, 82], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.subscript.formatter", "code": "@[combinator_formatter subscript]\ndef subscript.formatter := Superscript.scriptParser.formatter ``subscript", "start": [248, 1], "end": [250, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.registerAliasCore", "code": "@[nolint docBlame]\ndef registerAliasCore {\u03b1} (mapRef : IO.Ref (AliasTable \u03b1)) (aliasName : Name)\n    (value : AliasValue \u03b1) : IO Unit := do\n  if (\u2190 mapRef.get).contains aliasName then\n    throw \u2191s!\"alias '{aliasName}' has already been declared\"\n  mapRef.modify (\u00b7.insert aliasName value)", "start": [254, 1], "end": [259, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.registerAlias", "code": "@[nolint docBlame]\ndef registerAlias (aliasName declName : Name) (p : ParserAliasValue)\n    (kind? : Option SyntaxNodeKind := none) (info : ParserAliasInfo := {}) : IO Unit := do\n  registerAliasCore parserAliasesRef aliasName p\n  if let some kind := kind? then\n    parserAlias2kindRef.modify (\u00b7.insert aliasName kind)\n  parserAliases2infoRef.modify (\u00b7.insert aliasName { info with declName })", "start": [261, 1], "end": [267, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Multiplicity.lean", "imports": ["Mathlib/Data/Int/Parity.lean", "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "Mathlib/Data/ZMod/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/NumberTheory/Padics/PadicVal.lean", "Mathlib/Init/Meta/WellFoundedTactics.lean", "Mathlib/Algebra/GeomSum.lean"], "premises": [{"full_name": "dvd_geom_sum\u2082_iff_of_dvd_sub", "code": "theorem dvd_geom_sum\u2082_iff_of_dvd_sub {x y p : R} (h : p \u2223 x - y) :\n    (p \u2223 \u2211 i in range n, x ^ i * y ^ (n - 1 - i)) \u2194 p \u2223 n * y ^ (n - 1)", "start": [42, 1], "end": [46, 42], "kind": "commanddeclaration"}, {"full_name": "dvd_geom_sum\u2082_iff_of_dvd_sub'", "code": "theorem dvd_geom_sum\u2082_iff_of_dvd_sub' {x y p : R} (h : p \u2223 x - y) :\n    (p \u2223 \u2211 i in range n, x ^ i * y ^ (n - 1 - i)) \u2194 p \u2223 n * x ^ (n - 1)", "start": [49, 1], "end": [51, 77], "kind": "commanddeclaration"}, {"full_name": "dvd_geom_sum\u2082_self", "code": "theorem dvd_geom_sum\u2082_self {x y : R} (h : \u2191n \u2223 x - y) :\n    \u2191n \u2223 \u2211 i in range n, x ^ i * y ^ (n - 1 - i)", "start": [54, 1], "end": [56, 59], "kind": "commanddeclaration"}, {"full_name": "sq_dvd_add_pow_sub_sub", "code": "theorem sq_dvd_add_pow_sub_sub (p x : R) (n : \u2115) :\n    p ^ 2 \u2223 (x + p) ^ n - x ^ (n - 1) * p * n - x ^ n", "start": [59, 1], "end": [74, 51], "kind": "commanddeclaration"}, {"full_name": "not_dvd_geom_sum\u2082", "code": "theorem not_dvd_geom_sum\u2082 {p : R} (hp : Prime p) (hxy : p \u2223 x - y) (hx : \u00acp \u2223 x) (hn : \u00acp \u2223 n) :\n    \u00acp \u2223 \u2211 i in range n, x ^ i * y ^ (n - 1 - i)", "start": [77, 1], "end": [80, 101], "kind": "commanddeclaration"}, {"full_name": "odd_sq_dvd_geom_sum\u2082_sub", "code": "theorem odd_sq_dvd_geom_sum\u2082_sub (hp : Odd p) :\n    (p : R) ^ 2 \u2223 (\u2211 i in range p, (a + p * b) ^ i * a ^ (p - 1 - i)) - p * a ^ (p - 1)", "start": [85, 1], "end": [149, 32], "kind": "commanddeclaration"}, {"full_name": "multiplicity.pow_sub_pow_of_prime", "code": "theorem pow_sub_pow_of_prime {p : R} (hp : Prime p) {x y : R} (hxy : p \u2223 x - y) (hx : \u00acp \u2223 x)\n    {n : \u2115} (hn : \u00acp \u2223 n) : multiplicity p (x ^ n - y ^ n) = multiplicity p (x - y)", "start": [158, 1], "end": [161, 14], "kind": "commanddeclaration"}, {"full_name": "multiplicity.geom_sum\u2082_eq_one", "code": "theorem geom_sum\u2082_eq_one : multiplicity (\u2191p) (\u2211 i in range p, x ^ i * y ^ (p - 1 - i)) = 1", "start": [166, 1], "end": [176, 32], "kind": "commanddeclaration"}, {"full_name": "multiplicity.pow_prime_sub_pow_prime", "code": "theorem pow_prime_sub_pow_prime :\n    multiplicity (\u2191p) (x ^ p - y ^ p) = multiplicity (\u2191p) (x - y) + 1", "start": [179, 1], "end": [181, 86], "kind": "commanddeclaration"}, {"full_name": "multiplicity.pow_prime_pow_sub_pow_prime_pow", "code": "theorem pow_prime_pow_sub_pow_prime_pow (a : \u2115) :\n    multiplicity (\u2191p) (x ^ p ^ a - y ^ p ^ a) = multiplicity (\u2191p) (x - y) + a", "start": [184, 1], "end": [192, 44], "kind": "commanddeclaration"}, {"full_name": "multiplicity.Int.pow_sub_pow", "code": "theorem Int.pow_sub_pow {x y : \u2124} (hxy : \u2191p \u2223 x - y) (hx : \u00ac\u2191p \u2223 x) (n : \u2115) :\n    multiplicity (\u2191p) (x ^ n - y ^ n) = multiplicity (\u2191p) (x - y) + multiplicity p n", "start": [201, 1], "end": [217, 31], "kind": "commanddeclaration"}, {"full_name": "multiplicity.Int.pow_add_pow", "code": "theorem Int.pow_add_pow {x y : \u2124} (hxy : \u2191p \u2223 x + y) (hx : \u00ac\u2191p \u2223 x) {n : \u2115} (hn : Odd n) :\n    multiplicity (\u2191p) (x ^ n + y ^ n) = multiplicity (\u2191p) (x + y) + multiplicity p n", "start": [220, 1], "end": [224, 40], "kind": "commanddeclaration"}, {"full_name": "multiplicity.Nat.pow_sub_pow", "code": "theorem Nat.pow_sub_pow {x y : \u2115} (hxy : p \u2223 x - y) (hx : \u00acp \u2223 x) (n : \u2115) :\n    multiplicity p (x ^ n - y ^ n) = multiplicity p (x - y) + multiplicity p n", "start": [227, 1], "end": [238, 24], "kind": "commanddeclaration"}, {"full_name": "multiplicity.Nat.pow_add_pow", "code": "theorem Nat.pow_add_pow {x y : \u2115} (hxy : p \u2223 x + y) (hx : \u00acp \u2223 x) {n : \u2115} (hn : Odd n) :\n    multiplicity p (x ^ n + y ^ n) = multiplicity p (x + y) + multiplicity p n", "start": [241, 1], "end": [246, 41], "kind": "commanddeclaration"}, {"full_name": "pow_two_pow_sub_pow_two_pow", "code": "theorem pow_two_pow_sub_pow_two_pow [CommRing R] {x y : R} (n : \u2115) :\n    x ^ 2 ^ n - y ^ 2 ^ n = (\u220f i in Finset.range n, (x ^ 2 ^ i + y ^ 2 ^ i)) * (x - y)", "start": [255, 1], "end": [262, 11], "kind": "commanddeclaration"}, {"full_name": "Int.sq_mod_four_eq_one_of_odd", "code": "theorem Int.sq_mod_four_eq_one_of_odd {x : \u2124} : Odd x \u2192 x ^ 2 % 4 = 1", "start": [266, 1], "end": [272, 11], "kind": "commanddeclaration"}, {"full_name": "Int.two_pow_two_pow_add_two_pow_two_pow", "code": "theorem Int.two_pow_two_pow_add_two_pow_two_pow {x y : \u2124} (hx : \u00ac2 \u2223 x) (hxy : 4 \u2223 x - y) (i : \u2115) :\n    multiplicity 2 (x ^ 2 ^ i + y ^ 2 ^ i) = \u2191(1 : \u2115)", "start": [275, 1], "end": [297, 73], "kind": "commanddeclaration"}, {"full_name": "Int.two_pow_two_pow_sub_pow_two_pow", "code": "theorem Int.two_pow_two_pow_sub_pow_two_pow {x y : \u2124} (n : \u2115) (hxy : 4 \u2223 x - y) (hx : \u00ac2 \u2223 x) :\n    multiplicity 2 (x ^ 2 ^ n - y ^ 2 ^ n) = multiplicity 2 (x - y) + n", "start": [300, 1], "end": [304, 82], "kind": "commanddeclaration"}, {"full_name": "Int.two_pow_sub_pow'", "code": "theorem Int.two_pow_sub_pow' {x y : \u2124} (n : \u2115) (hxy : 4 \u2223 x - y) (hx : \u00ac2 \u2223 x) :\n    multiplicity 2 (x ^ n - y ^ n) = multiplicity 2 (x - y) + multiplicity (2 : \u2124) n", "start": [307, 1], "end": [327, 31], "kind": "commanddeclaration"}, {"full_name": "Int.two_pow_sub_pow", "code": "theorem Int.two_pow_sub_pow {x y : \u2124} {n : \u2115} (hxy : 2 \u2223 x - y) (hx : \u00ac2 \u2223 x) (hn : Even n) :\n    multiplicity 2 (x ^ n - y ^ n) + 1 =\n      multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity (2 : \u2124) n", "start": [330, 1], "end": [357, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.two_pow_sub_pow", "code": "theorem Nat.two_pow_sub_pow {x y : \u2115} (hxy : 2 \u2223 x - y) (hx : \u00ac2 \u2223 x) {n : \u2115} (hn : Even n) :\n    multiplicity 2 (x ^ n - y ^ n) + 1 =\n      multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 n", "start": [360, 1], "end": [374, 42], "kind": "commanddeclaration"}, {"full_name": "padicValNat.pow_two_sub_pow", "code": "theorem pow_two_sub_pow (hyx : y < x) (hxy : 2 \u2223 x - y) (hx : \u00ac2 \u2223 x) {n : \u2115} (hn : 0 < n)\n    (hneven : Even n) :\n    padicValNat 2 (x ^ n - y ^ n) + 1 =\n      padicValNat 2 (x + y) + padicValNat 2 (x - y) + padicValNat 2 n", "start": [381, 1], "end": [391, 80], "kind": "commanddeclaration"}, {"full_name": "padicValNat.pow_sub_pow", "code": "theorem pow_sub_pow (hyx : y < x) (hxy : p \u2223 x - y) (hx : \u00acp \u2223 x) {n : \u2115} (hn : 0 < n) :\n    padicValNat p (x ^ n - y ^ n) = padicValNat p (x - y) + padicValNat p n", "start": [396, 1], "end": [403, 63], "kind": "commanddeclaration"}, {"full_name": "padicValNat.pow_add_pow", "code": "theorem pow_add_pow (hxy : p \u2223 x + y) (hx : \u00acp \u2223 x) {n : \u2115} (hn : Odd n) :\n    padicValNat p (x ^ n + y ^ n) = padicValNat p (x + y) + padicValNat p n", "start": [406, 1], "end": [415, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Quotient/Preadditive.lean", "imports": ["Mathlib/CategoryTheory/Preadditive/AdditiveFunctor.lean", "Mathlib/CategoryTheory/Quotient.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Quotient.Preadditive.add", "code": "def add {X Y : Quotient r} (f g : X \u27f6 Y) : X \u27f6 Y :=\n  Quot.liftOn\u2082 f g (fun a b => Quot.mk _ (a + b))\n    (fun f g\u2081 g\u2082 h\u2081\u2082 => by\n      simp only [compClosure_iff_self] at h\u2081\u2082\n      erw [functor_map_eq_iff]\n      exact hr _ _ _ _ (Congruence.equivalence.refl f) h\u2081\u2082)\n    (fun f\u2081 f\u2082 g h\u2081\u2082 => by\n      simp only [compClosure_iff_self] at h\u2081\u2082\n      erw [functor_map_eq_iff]\n      exact hr _ _ _ _ h\u2081\u2082 (Congruence.equivalence.refl g))", "start": [27, 1], "end": [38, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Quotient.Preadditive.neg", "code": "def neg {X Y : Quotient r} (f : X \u27f6 Y) : X \u27f6 Y :=\n  Quot.liftOn f (fun a => Quot.mk _ (-a))\n    (fun f g => by\n      intro hfg\n      simp only [compClosure_iff_self] at hfg\n      erw [functor_map_eq_iff]\n      apply Congruence.equivalence.symm\n      convert hr f g _ _ hfg (Congruence.equivalence.refl (-f-g)) using 1 <;> abel)", "start": [40, 1], "end": [49, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Quotient.preadditive", "code": "def preadditive : Preadditive (Quotient r) where\n  homGroup P Q :=\n    { add := Preadditive.add r hr\n      add_assoc := by rintro \u27e8_\u27e9 \u27e8_\u27e9 \u27e8_\u27e9; exact congr_arg (functor r).map (add_assoc _ _ _)\n      zero := Quot.mk _ 0\n      zero_add := by rintro \u27e8_\u27e9; exact congr_arg (functor r).map (zero_add _)\n      add_zero := by rintro \u27e8_\u27e9; exact congr_arg (functor r).map (add_zero _)\n      add_comm := by rintro \u27e8_\u27e9 \u27e8_\u27e9; exact congr_arg (functor r).map (add_comm _ _)\n      neg := Preadditive.neg r hr\n      add_left_neg := by rintro \u27e8_\u27e9; exact congr_arg (functor r).map (add_left_neg _) }\n  add_comp := by\n    rintro _ _ _ \u27e8_\u27e9 \u27e8_\u27e9 \u27e8_\u27e9\n    exact congr_arg (functor r).map (by apply Preadditive.add_comp)\n  comp_add := by\n    rintro _ _ _ \u27e8_\u27e9 \u27e8_\u27e9 \u27e8_\u27e9\n    exact congr_arg (functor r).map (by apply Preadditive.comp_add)", "start": [53, 1], "end": [70, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Quotient.functor_additive", "code": "lemma functor_additive :\n    letI := preadditive r hr\n    (functor r).Additive :=\n  letI := preadditive r hr\n  { map_add := rfl }", "start": [72, 1], "end": [76, 21], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean", "imports": ["Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean", "Mathlib/MeasureTheory/Integral/Layercake.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "sqrt_one_add_norm_sq_le", "code": "theorem sqrt_one_add_norm_sq_le (x : E) : Real.sqrt ((1 : \u211d) + \u2016x\u2016 ^ 2) \u2264 1 + \u2016x\u2016", "start": [36, 1], "end": [38, 16], "kind": "commanddeclaration"}, {"full_name": "one_add_norm_le_sqrt_two_mul_sqrt", "code": "theorem one_add_norm_le_sqrt_two_mul_sqrt (x : E) :\n    (1 : \u211d) + \u2016x\u2016 \u2264 Real.sqrt 2 * sqrt ((1 : \u211d) + \u2016x\u2016 ^ 2)", "start": [41, 1], "end": [46, 11], "kind": "commanddeclaration"}, {"full_name": "rpow_neg_one_add_norm_sq_le", "code": "theorem rpow_neg_one_add_norm_sq_le {r : \u211d} (x : E) (hr : 0 < r) :\n    ((1 : \u211d) + \u2016x\u2016 ^ 2) ^ (-r / 2) \u2264 (2 : \u211d) ^ (r / 2) * (1 + \u2016x\u2016) ^ (-r)", "start": [49, 1], "end": [59, 77], "kind": "commanddeclaration"}, {"full_name": "le_rpow_one_add_norm_iff_norm_le", "code": "theorem le_rpow_one_add_norm_iff_norm_le {r t : \u211d} (hr : 0 < r) (ht : 0 < t) (x : E) :\n    t \u2264 (1 + \u2016x\u2016) ^ (-r) \u2194 \u2016x\u2016 \u2264 t ^ (-r\u207b\u00b9) - 1", "start": [62, 1], "end": [65, 83], "kind": "commanddeclaration"}, {"full_name": "closedBall_rpow_sub_one_eq_empty_aux", "code": "theorem closedBall_rpow_sub_one_eq_empty_aux {r t : \u211d} (hr : 0 < r) (ht : 1 < t) :\n    Metric.closedBall (0 : E) (t ^ (-r\u207b\u00b9) - 1) = \u2205", "start": [70, 1], "end": [73, 93], "kind": "commanddeclaration"}, {"full_name": "finite_integral_rpow_sub_one_pow_aux", "code": "theorem finite_integral_rpow_sub_one_pow_aux {r : \u211d} (n : \u2115) (hnr : (n : \u211d) < r) :\n    (\u222b\u207b x : \u211d in Ioc 0 1, ENNReal.ofReal ((x ^ (-r\u207b\u00b9) - 1) ^ n)) < \u221e", "start": [80, 1], "end": [96, 52], "kind": "commanddeclaration"}, {"full_name": "finite_integral_one_add_norm", "code": "theorem finite_integral_one_add_norm [MeasureSpace E] [BorelSpace E]\n    [(volume : Measure E).IsAddHaarMeasure] {r : \u211d} (hnr : (finrank \u211d E : \u211d) < r) :\n    (\u222b\u207b x : E, ENNReal.ofReal ((1 + \u2016x\u2016) ^ (-r))) < \u221e", "start": [99, 1], "end": [139, 30], "kind": "commanddeclaration"}, {"full_name": "integrable_one_add_norm", "code": "theorem integrable_one_add_norm [MeasureSpace E] [BorelSpace E] [(@volume E _).IsAddHaarMeasure]\n    {r : \u211d} (hnr : (finrank \u211d E : \u211d) < r) : Integrable fun x : E => (1 + \u2016x\u2016) ^ (-r)", "start": [142, 1], "end": [151, 41], "kind": "commanddeclaration"}, {"full_name": "integrable_rpow_neg_one_add_norm_sq", "code": "theorem integrable_rpow_neg_one_add_norm_sq [MeasureSpace E] [BorelSpace E]\n    [(@volume E _).IsAddHaarMeasure] {r : \u211d} (hnr : (finrank \u211d E : \u211d) < r) :\n    Integrable fun x : E => ((1 : \u211d) + \u2016x\u2016 ^ 2) ^ (-r / 2)", "start": [154, 1], "end": [163, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Buffer/Parser.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Analysis/Convex/Body.lean", "imports": ["Mathlib/Analysis/NormedSpace/Basic.lean", "Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "Mathlib/Analysis/Convex/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ConvexBody", "code": "structure ConvexBody (V : Type*) [TopologicalSpace V] [AddCommMonoid V] [SMul \u211d V] where\n  carrier : Set V\n  convex' : Convex \u211d carrier\n  isCompact' : IsCompact carrier\n  nonempty' : carrier.Nonempty", "start": [41, 1], "end": [48, 31], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.convex", "code": "protected theorem convex (K : ConvexBody V) : Convex \u211d (K : Set V)", "start": [64, 1], "end": [65, 12], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.isCompact", "code": "protected theorem isCompact (K : ConvexBody V) : IsCompact (K : Set V)", "start": [68, 1], "end": [69, 15], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.isClosed", "code": "protected theorem isClosed [T2Space V] (K : ConvexBody V) : IsClosed (K : Set V)", "start": [73, 1], "end": [74, 23], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.nonempty", "code": "protected theorem nonempty (K : ConvexBody V) : (K : Set V).Nonempty", "start": [76, 1], "end": [77, 14], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.ext", "code": "@[ext]\nprotected theorem ext {K L : ConvexBody V} (h : (K : Set V) = L) : K = L", "start": [80, 1], "end": [82, 17], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.coe_mk", "code": "@[simp]\ntheorem coe_mk (s : Set V) (h\u2081 h\u2082 h\u2083) : (mk s h\u2081 h\u2082 h\u2083 : Set V) = s", "start": [85, 1], "end": [87, 6], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.coe_nsmul", "code": "theorem coe_nsmul : \u2200 (n : \u2115) (K : ConvexBody V), \u2191(n \u2022 K) = n \u2022 (K : Set V)", "start": [108, 1], "end": [110, 70], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.coe_add", "code": "@[simp] theorem coe_add (K L : ConvexBody V) : (\u2191(K + L) : Set V) = (K : Set V) + L", "start": [115, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.coe_zero", "code": "@[simp] theorem coe_zero : (\u2191(0 : ConvexBody V) : Set V) = 0", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.coe_smul", "code": "@[simp] theorem coe_smul (c : \u211d) (K : ConvexBody V) : (\u2191(c \u2022 K) : Set V) = c \u2022 (K : Set V)", "start": [138, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.coe_smul'", "code": "@[simp] theorem coe_smul' (c : \u211d\u22650) (K : ConvexBody V) : (\u2191(c \u2022 K) : Set V) = c \u2022 (K : Set V)", "start": [148, 1], "end": [150, 6], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.isBounded", "code": "protected theorem isBounded : Bornology.IsBounded (K : Set V)", "start": [165, 1], "end": [166, 24], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.hausdorffEdist_ne_top", "code": "theorem hausdorffEdist_ne_top {K L : ConvexBody V} : EMetric.hausdorffEdist (K : Set V) L \u2260 \u22a4", "start": [169, 1], "end": [171, 26], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.hausdorffDist_coe", "code": "@[simp, norm_cast]\ntheorem hausdorffDist_coe : Metric.hausdorffDist (K : Set V) L = dist K L", "start": [183, 1], "end": [185, 6], "kind": "commanddeclaration"}, {"full_name": "ConvexBody.hausdorffEdist_coe", "code": "@[simp, norm_cast]\ntheorem hausdorffEdist_coe : EMetric.hausdorffEdist (K : Set V) L = edist K L", "start": [188, 1], "end": [191, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Matrix/ColumnRowPartitioned.lean", "imports": ["Mathlib/Data/Matrix/Block.lean", "Mathlib/Data/Matrix/Basic.lean", "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.fromRows", "code": "def fromRows (A\u2081 : Matrix m\u2081 n R) (A\u2082 : Matrix m\u2082 n R) : Matrix (m\u2081 \u2295 m\u2082) n R :=\n  of (Sum.elim A\u2081 A\u2082)", "start": [34, 1], "end": [37, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromColumns", "code": "def fromColumns (B\u2081 : Matrix m n\u2081 R) (B\u2082 : Matrix m n\u2082 R) : Matrix m (n\u2081 \u2295 n\u2082) R :=\n  of fun i => Sum.elim (B\u2081 i) (B\u2082 i)", "start": [39, 1], "end": [42, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.toColumns\u2081", "code": "def toColumns\u2081 (A : Matrix m (n\u2081 \u2295 n\u2082) R) : Matrix m n\u2081 R := of fun i j => (A i (Sum.inl j))", "start": [44, 1], "end": [45, 93], "kind": "commanddeclaration"}, {"full_name": "Matrix.toColumns\u2082", "code": "def toColumns\u2082 (A : Matrix m (n\u2081 \u2295 n\u2082) R) : Matrix m n\u2082 R := of fun i j => (A i (Sum.inr j))", "start": [47, 1], "end": [48, 93], "kind": "commanddeclaration"}, {"full_name": "Matrix.toRows\u2081", "code": "def toRows\u2081 (A : Matrix (m\u2081 \u2295 m\u2082) n R) : Matrix m\u2081 n R := of fun i j => (A (Sum.inl i) j)", "start": [50, 1], "end": [51, 90], "kind": "commanddeclaration"}, {"full_name": "Matrix.toRows\u2082", "code": "def toRows\u2082 (A : Matrix (m\u2081 \u2295 m\u2082) n R) : Matrix m\u2082 n R := of fun i j => (A (Sum.inr i) j)", "start": [53, 1], "end": [54, 90], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromRows_apply_inl", "code": "@[simp]\nlemma fromRows_apply_inl (A\u2081 : Matrix m\u2081 n R) (A\u2082 : Matrix m\u2082 n R) (i : m\u2081) (j : n) :\n    (fromRows A\u2081 A\u2082) (Sum.inl i) j = A\u2081 i j := rfl", "start": [56, 1], "end": [58, 51], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromRows_apply_inr", "code": "@[simp]\nlemma fromRows_apply_inr (A\u2081 : Matrix m\u2081 n R) (A\u2082 : Matrix m\u2082 n R) (i : m\u2082) (j : n) :\n    (fromRows A\u2081 A\u2082) (Sum.inr i) j = A\u2082 i j := rfl", "start": [60, 1], "end": [62, 51], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromColumns_apply_inl", "code": "@[simp]\nlemma fromColumns_apply_inl (A\u2081 : Matrix m n\u2081 R) (A\u2082 : Matrix m n\u2082 R) (i : m) (j : n\u2081) :\n    (fromColumns A\u2081 A\u2082) i (Sum.inl j) = A\u2081 i j := rfl", "start": [64, 1], "end": [66, 54], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromColumns_apply_inr", "code": "@[simp]\nlemma fromColumns_apply_inr (A\u2081 : Matrix m n\u2081 R) (A\u2082 : Matrix m n\u2082 R) (i : m) (j : n\u2082) :\n    (fromColumns A\u2081 A\u2082) i (Sum.inr j) = A\u2082 i j := rfl", "start": [68, 1], "end": [70, 54], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.toRows\u2081_apply", "code": "@[simp]\nlemma toRows\u2081_apply (A : Matrix (m\u2081 \u2295 m\u2082) n R) (i : m\u2081) (j : n) :\n    (toRows\u2081 A) i j = A (Sum.inl i) j := rfl", "start": [72, 1], "end": [74, 45], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.toRows\u2082_apply", "code": "@[simp]\nlemma toRows\u2082_apply (A : Matrix (m\u2081 \u2295 m\u2082) n R) (i : m\u2082) (j : n) :\n    (toRows\u2082 A) i j = A (Sum.inr i) j := rfl", "start": [76, 1], "end": [78, 45], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.toRows\u2081_fromRows", "code": "@[simp]\nlemma toRows\u2081_fromRows  (A\u2081 : Matrix m\u2081 n R) (A\u2082 : Matrix m\u2082 n R) :\n    toRows\u2081 (fromRows A\u2081 A\u2082) = A\u2081 := rfl", "start": [80, 1], "end": [82, 41], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.toRows\u2082_fromRows", "code": "@[simp]\nlemma toRows\u2082_fromRows  (A\u2081 : Matrix m\u2081 n R) (A\u2082 : Matrix m\u2082 n R) :\n    toRows\u2082 (fromRows A\u2081 A\u2082) = A\u2082 := rfl", "start": [84, 1], "end": [86, 41], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.toColumns\u2081_apply", "code": "@[simp]\nlemma toColumns\u2081_apply (A : Matrix m (n\u2081 \u2295 n\u2082) R) (i : m) (j : n\u2081) :\n    (toColumns\u2081 A) i j = A i (Sum.inl j) := rfl", "start": [88, 1], "end": [90, 48], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.toColumns\u2082_apply", "code": "@[simp]\nlemma toColumns\u2082_apply (A : Matrix m (n\u2081 \u2295 n\u2082) R) (i : m) (j : n\u2082) :\n    (toColumns\u2082 A) i j = A i (Sum.inr j) := rfl", "start": [92, 1], "end": [94, 48], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.toColumns\u2081_fromColumns", "code": "@[simp]\nlemma toColumns\u2081_fromColumns  (A\u2081 : Matrix m n\u2081 R) (A\u2082 : Matrix m n\u2082 R) :\n    toColumns\u2081 (fromColumns A\u2081 A\u2082) = A\u2081 := rfl", "start": [96, 1], "end": [98, 47], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.toColumns\u2082_fromColumns", "code": "@[simp]\nlemma toColumns\u2082_fromColumns  (A\u2081 : Matrix m n\u2081 R) (A\u2082 : Matrix m n\u2082 R) :\n    toColumns\u2082 (fromColumns A\u2081 A\u2082) = A\u2082 := rfl", "start": [100, 1], "end": [102, 47], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromColumns_toColumns", "code": "@[simp]\nlemma fromColumns_toColumns (A : Matrix m (n\u2081 \u2295 n\u2082) R) :\n    fromColumns A.toColumns\u2081 A.toColumns\u2082 = A := by\n  ext i (j | j) <;> simp", "start": [104, 1], "end": [107, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromRows_toRows", "code": "@[simp]\nlemma fromRows_toRows (A : Matrix (m\u2081 \u2295 m\u2082) n R) : fromRows A.toRows\u2081 A.toRows\u2082 = A := by\n  ext (i | i) j <;> simp", "start": [109, 1], "end": [111, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromRows_inj", "code": "lemma fromRows_inj : Function.Injective2 (@fromRows R m\u2081 m\u2082 n) := by\n  intros x1 x2 y1 y2\n  simp only [Function.funext_iff, \u2190 Matrix.ext_iff]\n  aesop", "start": [113, 1], "end": [116, 8], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromColumns_inj", "code": "lemma fromColumns_inj : Function.Injective2 (@fromColumns R m n\u2081 n\u2082) := by\n  intros x1 x2 y1 y2\n  simp only [Function.funext_iff, \u2190 Matrix.ext_iff]\n  aesop", "start": [118, 1], "end": [121, 8], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromColumns_ext_iff", "code": "lemma fromColumns_ext_iff (A\u2081 : Matrix m n\u2081 R) (A\u2082 : Matrix m n\u2082 R) (B\u2081 : Matrix m n\u2081 R)\n    (B\u2082 : Matrix m n\u2082 R) :\n    fromColumns A\u2081 A\u2082 = fromColumns B\u2081 B\u2082 \u2194 A\u2081 = B\u2081 \u2227 A\u2082 = B\u2082 := fromColumns_inj.eq_iff", "start": [123, 1], "end": [125, 88], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromRows_ext_iff", "code": "lemma fromRows_ext_iff (A\u2081 : Matrix m\u2081 n R) (A\u2082 : Matrix m\u2082 n R) (B\u2081 : Matrix m\u2081 n R)\n    (B\u2082 : Matrix m\u2082 n R) :\n    fromRows A\u2081 A\u2082 = fromRows B\u2081 B\u2082 \u2194 A\u2081 = B\u2081 \u2227 A\u2082 = B\u2082 := fromRows_inj.eq_iff", "start": [127, 1], "end": [129, 79], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.transpose_fromColumns", "code": "lemma transpose_fromColumns (A\u2081 : Matrix m n\u2081 R) (A\u2082 : Matrix m n\u2082 R) :\n    transpose (fromColumns A\u2081 A\u2082) = fromRows (transpose A\u2081) (transpose A\u2082) := by\n  ext (i | i) j <;> simp", "start": [133, 1], "end": [135, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.transpose_fromRows", "code": "lemma transpose_fromRows (A\u2081 : Matrix m\u2081 n R) (A\u2082 : Matrix m\u2082 n R) :\n    transpose (fromRows A\u2081 A\u2082) = fromColumns (transpose A\u2081) (transpose A\u2082) := by\n  ext i (j | j) <;> simp", "start": [139, 1], "end": [141, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromRows_mul", "code": "@[simp]\nlemma fromRows_mul (A\u2081 : Matrix m\u2081 n R) (A\u2082 : Matrix m\u2082 n R) (B : Matrix n m R) :\n    (fromRows A\u2081 A\u2082) * B = fromRows (A\u2081 * B) (A\u2082 * B) := by\n  ext (_ | _) _ <;> simp [mul_apply]", "start": [147, 1], "end": [150, 37], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.mul_fromColumns", "code": "@[simp]\nlemma mul_fromColumns (A : Matrix m n R) (B\u2081 : Matrix n n\u2081 R) (B\u2082 : Matrix n n\u2082 R) :\n    A * (fromColumns B\u2081 B\u2082) = fromColumns (A * B\u2081) (A * B\u2082) := by\n  ext _ (_ | _) <;> simp [mul_apply]", "start": [152, 1], "end": [155, 37], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromRows_zero", "code": "@[simp]\nlemma fromRows_zero : fromRows (0 : Matrix m\u2081 n R) (0 : Matrix m\u2082 n R) = 0 := by\n  ext (_ | _) _ <;> simp", "start": [157, 1], "end": [159, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromColumns_zero", "code": "@[simp]\nlemma fromColumns_zero : fromColumns (0 : Matrix m n\u2081 R) (0 : Matrix m n\u2082 R) = 0 := by\n  ext _ (_ | _) <;> simp", "start": [161, 1], "end": [163, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromColumns_fromRows_eq_fromBlocks", "code": "@[simp]\nlemma fromColumns_fromRows_eq_fromBlocks (B\u2081\u2081 : Matrix m\u2081 n\u2081 R) (B\u2081\u2082 : Matrix m\u2081 n\u2082 R)\n    (B\u2082\u2081 : Matrix m\u2082 n\u2081 R) (B\u2082\u2082 : Matrix m\u2082 n\u2082 R) :\n    fromColumns (fromRows B\u2081\u2081 B\u2082\u2081) (fromRows B\u2081\u2082 B\u2082\u2082) = fromBlocks B\u2081\u2081 B\u2081\u2082 B\u2082\u2081 B\u2082\u2082 := by\n  ext (_ | _) (_ | _) <;> simp", "start": [165, 1], "end": [169, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromRows_fromColumn_eq_fromBlocks", "code": "@[simp]\nlemma fromRows_fromColumn_eq_fromBlocks (B\u2081\u2081 : Matrix m\u2081 n\u2081 R) (B\u2081\u2082 : Matrix m\u2081 n\u2082 R)\n    (B\u2082\u2081 : Matrix m\u2082 n\u2081 R) (B\u2082\u2082 : Matrix m\u2082 n\u2082 R) :\n    fromRows (fromColumns B\u2081\u2081 B\u2081\u2082) (fromColumns B\u2082\u2081 B\u2082\u2082) = fromBlocks B\u2081\u2081 B\u2081\u2082 B\u2082\u2081 B\u2082\u2082 := by\n  ext (_ | _) (_ | _) <;> simp", "start": [171, 1], "end": [175, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromRows_mul_fromColumns", "code": "lemma fromRows_mul_fromColumns (A\u2081 : Matrix m\u2081 n R) (A\u2082 : Matrix m\u2082 n R)\n    (B\u2081 : Matrix n n\u2081 R) (B\u2082 : Matrix n n\u2082 R) :\n    (fromRows A\u2081 A\u2082) * (fromColumns B\u2081 B\u2082) =\n      fromBlocks (A\u2081 * B\u2081) (A\u2081 * B\u2082) (A\u2082 * B\u2081) (A\u2082 * B\u2082) := by\n  ext (_ | _) (_ | _) <;> simp", "start": [177, 1], "end": [182, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromColumns_mul_fromRows", "code": "lemma fromColumns_mul_fromRows (A\u2081 : Matrix m n\u2081 R) (A\u2082 : Matrix m n\u2082 R)\n    (B\u2081 : Matrix n\u2081 n R) (B\u2082 : Matrix n\u2082 n R) :\n    fromColumns A\u2081 A\u2082 * fromRows B\u2081 B\u2082 = (A\u2081 * B\u2081 + A\u2082 * B\u2082) := by\n  ext\n  simp [mul_apply]", "start": [184, 1], "end": [190, 19], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromColumns_mul_fromBlocks", "code": "lemma fromColumns_mul_fromBlocks (A\u2081 : Matrix m m\u2081 R) (A\u2082 : Matrix m m\u2082 R)\n    (B\u2081\u2081 : Matrix m\u2081 n\u2081 R) (B\u2081\u2082 : Matrix m\u2081 n\u2082 R) (B\u2082\u2081 : Matrix m\u2082 n\u2081 R) (B\u2082\u2082 : Matrix m\u2082 n\u2082 R) :\n    (fromColumns A\u2081 A\u2082) * fromBlocks B\u2081\u2081 B\u2081\u2082 B\u2082\u2081 B\u2082\u2082 =\n      fromColumns (A\u2081 * B\u2081\u2081 + A\u2082 * B\u2082\u2081) (A\u2081 * B\u2081\u2082 + A\u2082 * B\u2082\u2082) := by\n  ext _ (_ | _) <;> simp [mul_apply]", "start": [192, 1], "end": [197, 37], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromBlocks_mul_fromRows", "code": "lemma fromBlocks_mul_fromRows (A\u2081 : Matrix n\u2081 n R) (A\u2082 : Matrix n\u2082 n R)\n    (B\u2081\u2081 : Matrix m\u2081 n\u2081 R) (B\u2081\u2082 : Matrix m\u2081 n\u2082 R) (B\u2082\u2081 : Matrix m\u2082 n\u2081 R) (B\u2082\u2082 : Matrix m\u2082 n\u2082 R) :\n    fromBlocks B\u2081\u2081 B\u2081\u2082 B\u2082\u2081 B\u2082\u2082 * (fromRows A\u2081 A\u2082) =\n      fromRows (B\u2081\u2081 * A\u2081 + B\u2081\u2082 * A\u2082) (B\u2082\u2081 * A\u2081 + B\u2082\u2082 * A\u2082) := by\n  ext (_ | _) _ <;> simp [mul_apply]", "start": [199, 1], "end": [204, 37], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromColumns_mul_fromRows_eq_one_comm", "code": "lemma fromColumns_mul_fromRows_eq_one_comm (e : n \u2243 n\u2081 \u2295 n\u2082)\n    (A\u2081 : Matrix n n\u2081 R) (A\u2082 : Matrix n n\u2082 R) (B\u2081 : Matrix n\u2081 n R) (B\u2082 : Matrix n\u2082 n R) :\n    fromColumns A\u2081 A\u2082 * fromRows B\u2081 B\u2082 = 1 \u2194 fromRows B\u2081 B\u2082 * fromColumns A\u2081 A\u2082 = 1 := by\n  calc fromColumns A\u2081 A\u2082 * fromRows B\u2081 B\u2082 = 1\n  _ \u2194 submatrix (fromColumns A\u2081 A\u2082) id e * submatrix (fromRows B\u2081 B\u2082) e id = 1 := by\n    simp\n  _ \u2194 submatrix (fromRows B\u2081 B\u2082) e id * submatrix (fromColumns A\u2081 A\u2082) id e = 1 :=\n    mul_eq_one_comm\n  _ \u2194 reindex e.symm e.symm (fromRows B\u2081 B\u2082 * fromColumns A\u2081 A\u2082) = reindex e.symm e.symm 1 := by\n    simp only [reindex_apply, Equiv.symm_symm, submatrix_one_equiv,\n        submatrix_mul (he\u2082 := Function.bijective_id)]\n  _ \u2194 fromRows B\u2081 B\u2082 * fromColumns A\u2081 A\u2082 = 1 :=\n    (reindex _ _).injective.eq_iff", "start": [212, 1], "end": [229, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.equiv_compl_fromColumns_mul_fromRows_eq_one_comm", "code": "lemma equiv_compl_fromColumns_mul_fromRows_eq_one_comm (p : n \u2192 Prop)[DecidablePred p]\n    (A\u2081 : Matrix n {i // p i} R) (A\u2082 : Matrix n {i // \u00acp i} R)\n    (B\u2081 : Matrix {i // p i} n R) (B\u2082 : Matrix {i // \u00acp i} n R) :\n    fromColumns A\u2081 A\u2082 * fromRows B\u2081 B\u2082 = 1 \u2194 fromRows B\u2081 B\u2082 * fromColumns A\u2081 A\u2082 = 1 :=\n  fromColumns_mul_fromRows_eq_one_comm (id (Equiv.sumCompl p).symm) A\u2081 A\u2082 B\u2081 B\u2082", "start": [233, 1], "end": [237, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.conjTranspose_fromColumns_eq_fromRows_conjTranspose", "code": "lemma conjTranspose_fromColumns_eq_fromRows_conjTranspose (A\u2081 : Matrix m n\u2081 R)\n    (A\u2082 : Matrix m n\u2082 R) :\n    conjTranspose (fromColumns A\u2081 A\u2082) = fromRows (conjTranspose A\u2081) (conjTranspose A\u2082) := by\n  ext (_ | _) _ <;> simp", "start": [246, 1], "end": [249, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.conjTranspose_fromRows_eq_fromColumns_conjTranspose", "code": "lemma conjTranspose_fromRows_eq_fromColumns_conjTranspose (A\u2081 : Matrix m\u2081 n R)\n    (A\u2082 : Matrix m\u2082 n R) : conjTranspose (fromRows A\u2081 A\u2082) =\n      fromColumns (conjTranspose A\u2081) (conjTranspose A\u2082) := by\n  ext _ (_ | _) <;> simp", "start": [253, 1], "end": [256, 25], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Topology/ContinuousFunction/Sigma.lean", "imports": ["Mathlib/Topology/CompactOpen.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousMap.embedding_sigmaMk_comp", "code": "theorem embedding_sigmaMk_comp [Nonempty X] :\n    Embedding (fun g : \u03a3 i, C(X, Y i) \u21a6 (sigmaMk g.1).comp g.2) where", "start": [44, 1], "end": [54, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.exists_lift_sigma", "code": "theorem exists_lift_sigma (f : C(X, \u03a3 i, Y i)) : \u2203 i g, f = (sigmaMk i).comp g", "start": [60, 1], "end": [67, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.sigmaCodHomeomorph", "code": "@[simps! symm_apply]\ndef sigmaCodHomeomorph : C(X, \u03a3 i, Y i) \u2243\u209c \u03a3 i, C(X, Y i) :=\n  .symm <| Equiv.toHomeomorphOfInducing\n    (.ofBijective _ \u27e8embedding_sigmaMk_comp.inj, fun f \u21a6\n      let \u27e8i, g, hg\u27e9 := f.exists_lift_sigma; \u27e8\u27e8i, g\u27e9, hg.symm\u27e9\u27e9)\n    embedding_sigmaMk_comp.toInducing", "start": [71, 1], "end": [81, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/CompleteField.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "Mathlib/Algebra/Order/Pointwise.lean", "Mathlib/Algebra/Order/Hom/Ring.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ConditionallyCompleteLinearOrderedField", "code": "class ConditionallyCompleteLinearOrderedField (\u03b1 : Type*) extends\n    LinearOrderedField \u03b1, ConditionallyCompleteLinearOrder \u03b1", "start": [56, 1], "end": [60, 61], "kind": "commanddeclaration"}, {"full_name": "ConditionallyCompleteLinearOrderedField.to_archimedean", "code": "instance (priority := 100) ConditionallyCompleteLinearOrderedField.to_archimedean\n    [ConditionallyCompleteLinearOrderedField \u03b1] : Archimedean \u03b1 :=\n  archimedean_iff_nat_lt.2\n    (by\n      by_contra' h\n      obtain \u27e8x, h\u27e9 := h\n      have := csSup_le _ _ (range_nonempty Nat.cast)\n        (forall_range_iff.2 fun m =>\n          le_sub_iff_add_le.2 <| le_csSup _ _ \u27e8x, forall_range_iff.2 h\u27e9 \u27e8m+1, Nat.cast_succ m\u27e9)\n      linarith)", "start": [64, 1], "end": [74, 16], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.cutMap", "code": "def cutMap (a : \u03b1) : Set \u03b2 :=\n  (Rat.cast : \u211a \u2192 \u03b2) '' {t | \u2191t < a}", "start": [101, 1], "end": [104, 37], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.cutMap_mono", "code": "theorem cutMap_mono (h : a\u2081 \u2264 a\u2082) : cutMap \u03b2 a\u2081 \u2286 cutMap \u03b2 a\u2082", "start": [107, 1], "end": [107, 101], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.mem_cutMap_iff", "code": "@[simp]\ntheorem mem_cutMap_iff : b \u2208 cutMap \u03b2 a \u2194 \u2203 q : \u211a, (q : \u03b1) < a \u2227 (q : \u03b2) = b", "start": [112, 1], "end": [113, 88], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.coe_mem_cutMap_iff", "code": "theorem coe_mem_cutMap_iff [CharZero \u03b2] : (q : \u03b2) \u2208 cutMap \u03b2 a \u2194 (q : \u03b1) < a", "start": [117, 1], "end": [118, 35], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.cutMap_self", "code": "theorem cutMap_self (a : \u03b1) : cutMap \u03b1 a = Iio a \u2229 range (Rat.cast : \u211a \u2192 \u03b1)", "start": [121, 1], "end": [127, 22], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.cutMap_coe", "code": "theorem cutMap_coe (q : \u211a) : cutMap \u03b2 (q : \u03b1) = Rat.cast '' {r : \u211a | (r : \u03b2) < q}", "start": [134, 1], "end": [135, 32], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.cutMap_nonempty", "code": "theorem cutMap_nonempty (a : \u03b1) : (cutMap \u03b2 a).Nonempty", "start": [140, 1], "end": [141, 38], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.cutMap_bddAbove", "code": "theorem cutMap_bddAbove (a : \u03b1) : BddAbove (cutMap \u03b2 a)", "start": [144, 1], "end": [146, 78], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.cutMap_add", "code": "theorem cutMap_add (a b : \u03b1) : cutMap \u03b2 (a + b) = cutMap \u03b2 a + cutMap \u03b2 b", "start": [149, 1], "end": [160, 27], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedMap", "code": "def inducedMap (x : \u03b1) : \u03b2 :=\n  sSup <| cutMap \u03b2 x", "start": [177, 1], "end": [181, 21], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedMap_mono", "code": "theorem inducedMap_mono : Monotone (inducedMap \u03b1 \u03b2)", "start": [186, 1], "end": [187, 79], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedMap_rat", "code": "theorem inducedMap_rat (q : \u211a) : inducedMap \u03b1 \u03b2 (q : \u03b1) = q", "start": [190, 1], "end": [198, 34], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedMap_zero", "code": "@[simp]\ntheorem inducedMap_zero : inducedMap \u03b1 \u03b2 0 = 0", "start": [201, 1], "end": [202, 89], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedMap_one", "code": "@[simp]\ntheorem inducedMap_one : inducedMap \u03b1 \u03b2 1 = 1", "start": [205, 1], "end": [206, 88], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedMap_nonneg", "code": "theorem inducedMap_nonneg (ha : 0 \u2264 a) : 0 \u2264 inducedMap \u03b1 \u03b2 a", "start": [211, 1], "end": [212, 59], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.coe_lt_inducedMap_iff", "code": "theorem coe_lt_inducedMap_iff : (q : \u03b2) < inducedMap \u03b1 \u03b2 a \u2194 (q : \u03b1) < a", "start": [215, 1], "end": [221, 22], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.lt_inducedMap_iff", "code": "theorem lt_inducedMap_iff : b < inducedMap \u03b1 \u03b2 a \u2194 \u2203 q : \u211a, b < q \u2227 (q : \u03b1) < a", "start": [224, 1], "end": [226, 70], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedMap_self", "code": "@[simp]\ntheorem inducedMap_self (b : \u03b2) : inducedMap \u03b2 \u03b2 b = b", "start": [229, 1], "end": [231, 60], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedMap_inducedMap", "code": "@[simp]\ntheorem inducedMap_inducedMap (a : \u03b1) : inducedMap \u03b2 \u03b3 (inducedMap \u03b1 \u03b2 a) = inducedMap \u03b1 \u03b3 a", "start": [236, 1], "end": [239, 87], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedMap_inv_self", "code": "theorem inducedMap_inv_self (b : \u03b2) : inducedMap \u03b3 \u03b2 (inducedMap \u03b2 \u03b3 b) = b", "start": [243, 1], "end": [244, 46], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedMap_add", "code": "theorem inducedMap_add (x y : \u03b1) :\n    inducedMap \u03b1 \u03b2 (x + y) = inducedMap \u03b1 \u03b2 x + inducedMap \u03b1 \u03b2 y", "start": [247, 1], "end": [251, 26], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.le_inducedMap_mul_self_of_mem_cutMap", "code": "theorem le_inducedMap_mul_self_of_mem_cutMap (ha : 0 < a) (b : \u03b2) (hb : b \u2208 cutMap \u03b2 (a * a)) :\n    b \u2264 inducedMap \u03b1 \u03b2 a * inducedMap \u03b1 \u03b2 a", "start": [256, 1], "end": [266, 70], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.exists_mem_cutMap_mul_self_of_lt_inducedMap_mul_self", "code": "theorem exists_mem_cutMap_mul_self_of_lt_inducedMap_mul_self (ha : 0 < a) (b : \u03b2)\n    (hba : b < inducedMap \u03b1 \u03b2 a * inducedMap \u03b1 \u03b2 a) : \u2203 c \u2208 cutMap \u03b2 (a * a), b < c", "start": [269, 1], "end": [283, 95], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedAddHom", "code": "def inducedAddHom : \u03b1 \u2192+ \u03b2 :=\n  \u27e8\u27e8inducedMap \u03b1 \u03b2, inducedMap_zero \u03b1 \u03b2\u27e9, inducedMap_add \u03b1 \u03b2\u27e9", "start": [288, 1], "end": [290, 62], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedOrderRingHom", "code": "@[simps!]\ndef inducedOrderRingHom : \u03b1 \u2192+*o \u03b2 :=\n  { AddMonoidHom.mkRingHomOfMulSelfOfTwoNeZero (inducedAddHom \u03b1 \u03b2) (by\n      suffices : \u2200 x, 0 < x \u2192 inducedAddHom \u03b1 \u03b2 (x * x)\n          = inducedAddHom \u03b1 \u03b2 x * inducedAddHom \u03b1 \u03b2 x\n      \u00b7 intro x\n        obtain h | rfl | h := lt_trichotomy x 0\n        \u00b7 convert this (-x) (neg_pos.2 h) using 1\n          \u00b7 rw [neg_mul, mul_neg, neg_neg]\n          \u00b7 simp_rw [AddMonoidHom.map_neg, neg_mul, mul_neg, neg_neg]\n        \u00b7 simp only [mul_zero, AddMonoidHom.map_zero]\n        \u00b7 exact this x h\n        refine fun x hx => csSup_eq_of_forall_le_of_forall_lt_exists_gt (cutMap_nonempty \u03b2 _) ?_ ?_\n      \u00b7 exact le_inducedMap_mul_self_of_mem_cutMap hx\n      \u00b7 exact exists_mem_cutMap_mul_self_of_lt_inducedMap_mul_self hx)\n      (two_ne_zero) (inducedMap_one _ _) with\n    monotone' := inducedMap_mono _ _ }", "start": [293, 1], "end": [312, 39], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedOrderRingIso", "code": "def inducedOrderRingIso : \u03b2 \u2243+*o \u03b3 :=\n  { inducedOrderRingHom \u03b2 \u03b3 with\n    invFun := inducedMap \u03b3 \u03b2\n    left_inv := inducedMap_inv_self _ _\n    right_inv := inducedMap_inv_self _ _\n    map_le_map_iff' := by\n      dsimp\n      refine \u27e8fun h => ?_, fun h => inducedMap_mono _ _ h\u27e9\n      convert inducedMap_mono \u03b3 \u03b2 h <;>\n      \u00b7 rw [inducedOrderRingHom, AddMonoidHom.coe_fn_mkRingHomOfMulSelfOfTwoNeZero, inducedAddHom]\n        dsimp\n        rw [inducedMap_inv_self \u03b2 \u03b3 _] }", "start": [315, 1], "end": [327, 41], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.coe_inducedOrderRingIso", "code": "@[simp]\ntheorem coe_inducedOrderRingIso : \u21d1(inducedOrderRingIso \u03b2 \u03b3) = inducedMap \u03b2 \u03b3", "start": [330, 1], "end": [331, 85], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedOrderRingIso_symm", "code": "@[simp]\ntheorem inducedOrderRingIso_symm : (inducedOrderRingIso \u03b2 \u03b3).symm = inducedOrderRingIso \u03b3 \u03b2", "start": [334, 1], "end": [335, 99], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.inducedOrderRingIso_self", "code": "@[simp]\ntheorem inducedOrderRingIso_self : inducedOrderRingIso \u03b2 \u03b2 = OrderRingIso.refl \u03b2", "start": [338, 1], "end": [340, 35], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.uniqueOrderRingHom", "code": "instance uniqueOrderRingHom : Unique (\u03b1 \u2192+*o \u03b2) :=\n  uniqueOfSubsingleton <| inducedOrderRingHom \u03b1 \u03b2", "start": [345, 1], "end": [348, 50], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.uniqueOrderRingIso", "code": "instance uniqueOrderRingIso : Unique (\u03b2 \u2243+*o \u03b3) :=\n  uniqueOfSubsingleton <| inducedOrderRingIso \u03b2 \u03b3", "start": [350, 1], "end": [353, 50], "kind": "commanddeclaration"}, {"full_name": "ringHom_monotone", "code": "theorem ringHom_monotone (hR : \u2200 r : R, 0 \u2264 r \u2192 \u2203 s : R, s ^ 2 = r) (f : R \u2192+* S) : Monotone f", "start": [363, 1], "end": [365, 61], "kind": "commanddeclaration"}, {"full_name": "Real.RingHom.unique", "code": "instance Real.RingHom.unique : Unique (\u211d \u2192+* \u211d) where\n  default := RingHom.id \u211d\n  uniq f := congr_arg OrderRingHom.toRingHom (@Subsingleton.elim (\u211d \u2192+*o \u211d) _\n      \u27e8f, ringHom_monotone (fun r hr => \u27e8Real.sqrt r, sq_sqrt hr\u27e9) f\u27e9 default)", "start": [368, 1], "end": [372, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/KrullTopology.lean", "imports": ["Mathlib/Topology/Algebra/OpenSubgroup.lean", "Mathlib/FieldTheory/Galois.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Algebra/FilterBasis.lean", "Mathlib/Tactic/ByContra.lean"], "premises": [{"full_name": "IntermediateField.map_id", "code": "theorem IntermediateField.map_id {K L : Type*} [Field K] [Field L] [Algebra K L]\n    (E : IntermediateField K L) : E.map (AlgHom.id K L) = E", "start": [60, 1], "end": [63, 42], "kind": "commanddeclaration"}, {"full_name": "im_finiteDimensional", "code": "instance im_finiteDimensional {K L : Type*} [Field K] [Field L] [Algebra K L]\n    {E : IntermediateField K L} (\u03c3 : L \u2243\u2090[K] L) [FiniteDimensional K E] :\n    FiniteDimensional K (E.map \u03c3.toAlgHom) :=\n  LinearEquiv.finiteDimensional (IntermediateField.intermediateFieldMap \u03c3 E).toLinearEquiv", "start": [66, 1], "end": [71, 91], "kind": "commanddeclaration"}, {"full_name": "finiteExts", "code": "def finiteExts (K : Type*) [Field K] (L : Type*) [Field L] [Algebra K L] :\n    Set (IntermediateField K L) :=\n  {E | FiniteDimensional K E}", "start": [74, 1], "end": [78, 30], "kind": "commanddeclaration"}, {"full_name": "fixedByFinite", "code": "def fixedByFinite (K L : Type*) [Field K] [Field L] [Algebra K L] : Set (Subgroup (L \u2243\u2090[K] L)) :=\n  IntermediateField.fixingSubgroup '' finiteExts K L", "start": [81, 1], "end": [84, 53], "kind": "commanddeclaration"}, {"full_name": "IntermediateField.finiteDimensional_bot", "code": "theorem IntermediateField.finiteDimensional_bot (K L : Type*) [Field K] [Field L] [Algebra K L] :\n    FiniteDimensional K (\u22a5 : IntermediateField K L)", "start": [87, 1], "end": [90, 62], "kind": "commanddeclaration"}, {"full_name": "IntermediateField.fixingSubgroup.bot", "code": "theorem IntermediateField.fixingSubgroup.bot {K L : Type*} [Field K] [Field L] [Algebra K L] :\n    IntermediateField.fixingSubgroup (\u22a5 : IntermediateField K L) = \u22a4", "start": [93, 1], "end": [101, 21], "kind": "commanddeclaration"}, {"full_name": "top_fixedByFinite", "code": "theorem top_fixedByFinite {K L : Type*} [Field K] [Field L] [Algebra K L] :\n    \u22a4 \u2208 fixedByFinite K L", "start": [104, 1], "end": [107, 89], "kind": "commanddeclaration"}, {"full_name": "finiteDimensional_sup", "code": "theorem finiteDimensional_sup {K L : Type*} [Field K] [Field L] [Algebra K L]\n    (E1 E2 : IntermediateField K L) (_ : FiniteDimensional K E1) (_ : FiniteDimensional K E2) :\n    FiniteDimensional K (\u21a5(E1 \u2294 E2))", "start": [110, 1], "end": [115, 48], "kind": "commanddeclaration"}, {"full_name": "IntermediateField.mem_fixingSubgroup_iff", "code": "theorem IntermediateField.mem_fixingSubgroup_iff {K L : Type*} [Field K] [Field L] [Algebra K L]\n    (E : IntermediateField K L) (\u03c3 : L \u2243\u2090[K] L) : \u03c3 \u2208 E.fixingSubgroup \u2194 \u2200 x : L, x \u2208 E \u2192 \u03c3 x = x", "start": [118, 1], "end": [121, 55], "kind": "commanddeclaration"}, {"full_name": "IntermediateField.fixingSubgroup.antimono", "code": "theorem IntermediateField.fixingSubgroup.antimono {K L : Type*} [Field K] [Field L] [Algebra K L]\n    {E1 E2 : IntermediateField K L} (h12 : E1 \u2264 E2) : E2.fixingSubgroup \u2264 E1.fixingSubgroup", "start": [124, 1], "end": [128, 23], "kind": "commanddeclaration"}, {"full_name": "galBasis", "code": "def galBasis (K L : Type*) [Field K] [Field L] [Algebra K L] : FilterBasis (L \u2243\u2090[K] L) where\n  sets := (fun g => g.carrier) '' fixedByFinite K L\n  nonempty := \u27e8\u22a4, \u22a4, top_fixedByFinite, rfl\u27e9\n  inter_sets := by\n    rintro X Y \u27e8H1, \u27e8E1, h_E1, rfl\u27e9, rfl\u27e9 \u27e8H2, \u27e8E2, h_E2, rfl\u27e9, rfl\u27e9\n    use (IntermediateField.fixingSubgroup (E1 \u2294 E2)).carrier\n    refine' \u27e8\u27e8_, \u27e8_, finiteDimensional_sup E1 E2 h_E1 h_E2, rfl\u27e9, rfl\u27e9, _\u27e9\n    rw [Set.subset_inter_iff]\n    exact\n      \u27e8IntermediateField.fixingSubgroup.antimono le_sup_left,\n        IntermediateField.fixingSubgroup.antimono le_sup_right\u27e9", "start": [131, 1], "end": [143, 64], "kind": "commanddeclaration"}, {"full_name": "mem_galBasis_iff", "code": "theorem mem_galBasis_iff (K L : Type*) [Field K] [Field L] [Algebra K L] (U : Set (L \u2243\u2090[K] L)) :\n    U \u2208 galBasis K L \u2194 U \u2208 (fun g => g.carrier) '' fixedByFinite K L", "start": [146, 1], "end": [150, 10], "kind": "commanddeclaration"}, {"full_name": "galGroupBasis", "code": "def galGroupBasis (K L : Type*) [Field K] [Field L] [Algebra K L] :\n    GroupFilterBasis (L \u2243\u2090[K] L) where\n  toFilterBasis := galBasis K L\n  one' := fun \u27e8H, _, h2\u27e9 => h2 \u25b8 H.one_mem\n  mul' {U} hU :=\n    \u27e8U, hU, by\n      rcases hU with \u27e8H, _, rfl\u27e9\n      rintro x \u27e8a, b, haH, hbH, rfl\u27e9\n      exact H.mul_mem haH hbH\u27e9\n  inv' {U} hU :=\n    \u27e8U, hU, by\n      rcases hU with \u27e8H, _, rfl\u27e9\n      exact fun _ => H.inv_mem'\u27e9\n  conj' := by\n    rintro \u03c3 U \u27e8H, \u27e8E, hE, rfl\u27e9, rfl\u27e9\n    let F : IntermediateField K L := E.map \u03c3.symm.toAlgHom\n    refine' \u27e8F.fixingSubgroup.carrier, \u27e8\u27e8F.fixingSubgroup, \u27e8F, _, rfl\u27e9, rfl\u27e9, fun g hg => _\u27e9\u27e9\n    \u00b7 have : FiniteDimensional K E := hE\n      apply im_finiteDimensional \u03c3.symm\n    change \u03c3 * g * \u03c3\u207b\u00b9 \u2208 E.fixingSubgroup\n    rw [IntermediateField.mem_fixingSubgroup_iff]\n    intro x hx\n    change \u03c3 (g (\u03c3\u207b\u00b9 x)) = x\n    have h_in_F : \u03c3\u207b\u00b9 x \u2208 F := \u27e8x, hx, by dsimp; rw [\u2190 AlgEquiv.invFun_eq_symm]; rfl\u27e9\n    have h_g_fix : g (\u03c3\u207b\u00b9 x) = \u03c3\u207b\u00b9 x := by\n      rw [Subgroup.mem_carrier, IntermediateField.mem_fixingSubgroup_iff F g] at hg\n      exact hg (\u03c3\u207b\u00b9 x) h_in_F\n    rw [h_g_fix]\n    change \u03c3 (\u03c3\u207b\u00b9 x) = x\n    exact AlgEquiv.apply_symm_apply \u03c3 x", "start": [153, 1], "end": [184, 40], "kind": "commanddeclaration"}, {"full_name": "krullTopology", "code": "instance krullTopology (K L : Type*) [Field K] [Field L] [Algebra K L] :\n    TopologicalSpace (L \u2243\u2090[K] L) :=\n  GroupFilterBasis.topology (galGroupBasis K L)", "start": [187, 1], "end": [191, 48], "kind": "commanddeclaration"}, {"full_name": "IntermediateField.fixingSubgroup_isOpen", "code": "theorem IntermediateField.fixingSubgroup_isOpen {K L : Type*} [Field K] [Field L] [Algebra K L]\n    (E : IntermediateField K L) [FiniteDimensional K E] :\n    IsOpen (E.fixingSubgroup : Set (L \u2243\u2090[K] L))", "start": [202, 1], "end": [210, 44], "kind": "commanddeclaration"}, {"full_name": "IntermediateField.fixingSubgroup_isClosed", "code": "theorem IntermediateField.fixingSubgroup_isClosed {K L : Type*} [Field K] [Field L] [Algebra K L]\n    (E : IntermediateField K L) [FiniteDimensional K E] :\n    IsClosed (E.fixingSubgroup : Set (L \u2243\u2090[K] L))", "start": [213, 1], "end": [218, 68], "kind": "commanddeclaration"}, {"full_name": "krullTopology_t2", "code": "theorem krullTopology_t2 {K L : Type*} [Field K] [Field L] [Algebra K L]\n    (h_int : Algebra.IsIntegral K L) : T2Space (L \u2243\u2090[K] L)", "start": [221, 1], "end": [252, 31], "kind": "commanddeclaration"}, {"full_name": "krullTopology_totallyDisconnected", "code": "theorem krullTopology_totallyDisconnected {K L : Type*} [Field K] [Field L] [Algebra K L]\n    (h_int : Algebra.IsIntegral K L) : IsTotallyDisconnected (Set.univ : Set (L \u2243\u2090[K] L))", "start": [259, 1], "end": [274, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GCDMonoid/Div.lean", "imports": ["Mathlib/RingTheory/Polynomial/Content.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/GCDMonoid/Basic.lean", "Mathlib/RingTheory/Int/Basic.lean", "Mathlib/Algebra/GCDMonoid/Finset.lean"], "premises": [{"full_name": "Finset.Nat.gcd_div_eq_one", "code": "theorem gcd_div_eq_one {\u03b2 : Type*} {f : \u03b2 \u2192 \u2115} (s : Finset \u03b2) {x : \u03b2} (hx : x \u2208 s)\n    (hfz : f x \u2260 0) : (s.gcd fun b => f b / s.gcd f) = 1", "start": [35, 1], "end": [42, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.gcd_div_id_eq_one", "code": "theorem gcd_div_id_eq_one {s : Finset \u2115} {x : \u2115} (hx : x \u2208 s) (hnz : x \u2260 0) :\n    (s.gcd fun b => b / s.gcd id) = 1", "start": [45, 1], "end": [47, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Int.gcd_div_eq_one", "code": "theorem gcd_div_eq_one {\u03b2 : Type*} {f : \u03b2 \u2192 \u2124} (s : Finset \u03b2) {x : \u03b2} (hx : x \u2208 s)\n    (hfz : f x \u2260 0) : (s.gcd fun b => f b / s.gcd f) = 1", "start": [54, 1], "end": [61, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.Int.gcd_div_id_eq_one", "code": "theorem gcd_div_id_eq_one {s : Finset \u2124} {x : \u2124} (hx : x \u2208 s) (hnz : x \u2260 0) :\n    (s.gcd fun b => b / s.gcd id) = 1", "start": [64, 1], "end": [66, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Polynomial.gcd_div_eq_one", "code": "theorem gcd_div_eq_one {\u03b2 : Type*} {f : \u03b2 \u2192 Polynomial K} (s : Finset \u03b2) {x : \u03b2} (hx : x \u2208 s)\n    (hfz : f x \u2260 0) : (s.gcd fun b => f b / s.gcd f) = 1", "start": [79, 1], "end": [86, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.Polynomial.gcd_div_id_eq_one", "code": "theorem gcd_div_id_eq_one {s : Finset (Polynomial K)} {x : Polynomial K}\n    (hx : x \u2208 s) (hnz : x \u2260 0) : (s.gcd fun b => b / s.gcd id) = 1", "start": [89, 1], "end": [91, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/GromovHausdorff.lean", "imports": ["Mathlib/Topology/MetricSpace/Closeds.lean", "Mathlib/Topology/MetricSpace/Kuratowski.lean", "Mathlib/Topology/MetricSpace/Completion.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/SetTheory/Cardinal/Basic.lean", "Mathlib/Topology/MetricSpace/GromovHausdorffRealized.lean"], "premises": [{"full_name": "GromovHausdorff.IsometryRel", "code": "private def IsometryRel (x : NonemptyCompacts \u2113_infty_\u211d) (y : NonemptyCompacts \u2113_infty_\u211d) : Prop :=\n  Nonempty (x \u2243\u1d62 y)", "start": [71, 1], "end": [73, 20], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.equivalence_isometryRel", "code": "private theorem equivalence_isometryRel : Equivalence IsometryRel", "start": [75, 1], "end": [77, 100], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.IsometryRel.setoid", "code": "instance IsometryRel.setoid : Setoid (NonemptyCompacts \u2113_infty_\u211d) :=\n  Setoid.mk IsometryRel equivalence_isometryRel", "start": [79, 1], "end": [81, 48], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.GHSpace", "code": "def GHSpace : Type :=\n  Quotient IsometryRel.setoid", "start": [84, 1], "end": [86, 30], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.toGHSpace", "code": "def toGHSpace (X : Type u) [MetricSpace X] [CompactSpace X] [Nonempty X] : GHSpace :=\n  \u27e6NonemptyCompacts.kuratowskiEmbedding X\u27e7", "start": [89, 1], "end": [91, 43], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.GHSpace.Rep", "code": "def GHSpace.Rep (p : GHSpace) : Type :=\n  (Quotient.out p : NonemptyCompacts \u2113_infty_\u211d)", "start": [97, 1], "end": [100, 48], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.eq_toGHSpace_iff", "code": "theorem eq_toGHSpace_iff {X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X]\n    {p : NonemptyCompacts \u2113_infty_\u211d} :\n    \u27e6p\u27e7 = toGHSpace X \u2194 \u2203 \u03a8 : X \u2192 \u2113_infty_\u211d, Isometry \u03a8 \u2227 range \u03a8 = p", "start": [103, 1], "end": [119, 21], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.eq_toGHSpace", "code": "theorem eq_toGHSpace {p : NonemptyCompacts \u2113_infty_\u211d} : \u27e6p\u27e7 = toGHSpace p", "start": [122, 1], "end": [123, 75], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.repGHSpaceMetricSpace", "code": "instance repGHSpaceMetricSpace {p : GHSpace} : MetricSpace p.Rep :=\n  inferInstanceAs <| MetricSpace p.out", "start": [128, 1], "end": [129, 39], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.rep_gHSpace_compactSpace", "code": "instance rep_gHSpace_compactSpace {p : GHSpace} : CompactSpace p.Rep :=\n  inferInstanceAs <| CompactSpace p.out", "start": [132, 1], "end": [133, 40], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.rep_gHSpace_nonempty", "code": "instance rep_gHSpace_nonempty {p : GHSpace} : Nonempty p.Rep :=\n  inferInstanceAs <| Nonempty p.out", "start": [136, 1], "end": [137, 36], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.GHSpace.toGHSpace_rep", "code": "theorem GHSpace.toGHSpace_rep (p : GHSpace) : toGHSpace p.Rep = p", "start": [142, 1], "end": [145, 22], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.toGHSpace_eq_toGHSpace_iff_isometryEquiv", "code": "theorem toGHSpace_eq_toGHSpace_iff_isometryEquiv {X : Type u} [MetricSpace X] [CompactSpace X]\n    [Nonempty X] {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] :\n    toGHSpace X = toGHSpace Y \u2194 Nonempty (X \u2243\u1d62 Y)", "start": [148, 1], "end": [173, 42], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.ghDist", "code": "def ghDist (X : Type u) (Y : Type v) [MetricSpace X] [Nonempty X] [CompactSpace X] [MetricSpace Y]\n    [Nonempty Y] [CompactSpace Y] : \u211d :=\n  dist (toGHSpace X) (toGHSpace Y)", "start": [183, 1], "end": [187, 35], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.dist_ghDist", "code": "theorem dist_ghDist (p q : GHSpace) : dist p q = ghDist p.Rep q.Rep", "start": [190, 1], "end": [191, 48], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.ghDist_le_hausdorffDist", "code": "theorem ghDist_le_hausdorffDist {X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X]\n    {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] {\u03b3 : Type w} [MetricSpace \u03b3]\n    {\u03a6 : X \u2192 \u03b3} {\u03a8 : Y \u2192 \u03b3} (ha : Isometry \u03a6) (hb : Isometry \u03a8) :\n    ghDist X Y \u2264 hausdorffDist (range \u03a6) (range \u03a8)", "start": [194, 1], "end": [248, 76], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.hausdorffDist_optimal", "code": "theorem hausdorffDist_optimal {X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X]\n    {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] :\n    hausdorffDist (range (optimalGHInjl X Y)) (range (optimalGHInjr X Y)) = ghDist X Y", "start": [252, 1], "end": [394, 92], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.ghDist_eq_hausdorffDist", "code": "theorem ghDist_eq_hausdorffDist (X : Type u) [MetricSpace X] [CompactSpace X] [Nonempty X]\n    (Y : Type v) [MetricSpace Y] [CompactSpace Y] [Nonempty Y] :\n    \u2203 \u03a6 : X \u2192 \u2113_infty_\u211d,\n      \u2203 \u03a8 : Y \u2192 \u2113_infty_\u211d,\n        Isometry \u03a6 \u2227 Isometry \u03a8 \u2227 ghDist X Y = hausdorffDist (range \u03a6) (range \u03a8)", "start": [397, 1], "end": [412, 70], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.NonemptyCompacts.toGHSpace", "code": "def TopologicalSpace.NonemptyCompacts.toGHSpace {X : Type u} [MetricSpace X]\n    (p : NonemptyCompacts X) : GromovHausdorff.GHSpace :=\n  GromovHausdorff.toGHSpace p", "start": [523, 1], "end": [528, 30], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.ghDist_le_nonemptyCompacts_dist", "code": "theorem ghDist_le_nonemptyCompacts_dist (p q : NonemptyCompacts X) :\n    dist p.toGHSpace q.toGHSpace \u2264 dist p q", "start": [539, 1], "end": [547, 38], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.toGHSpace_lipschitz", "code": "theorem toGHSpace_lipschitz :\n    LipschitzWith 1 (NonemptyCompacts.toGHSpace : NonemptyCompacts X \u2192 GHSpace)", "start": [550, 1], "end": [552, 55], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.toGHSpace_continuous", "code": "theorem toGHSpace_continuous :\n    Continuous (NonemptyCompacts.toGHSpace : NonemptyCompacts X \u2192 GHSpace)", "start": [555, 1], "end": [557, 33], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.ghDist_le_of_approx_subsets", "code": "theorem ghDist_le_of_approx_subsets {s : Set X} (\u03a6 : s \u2192 Y) {\u03b5\u2081 \u03b5\u2082 \u03b5\u2083 : \u211d}\n    (hs : \u2200 x : X, \u2203 y \u2208 s, dist x y \u2264 \u03b5\u2081) (hs' : \u2200 x : Y, \u2203 y : s, dist x (\u03a6 y) \u2264 \u03b5\u2083)\n    (H : \u2200 x y : s, |dist x y - dist (\u03a6 x) (\u03a6 y)| \u2264 \u03b5\u2082) : ghDist X Y \u2264 \u03b5\u2081 + \u03b5\u2082 / 2 + \u03b5\u2083", "start": [572, 1], "end": [647, 11], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.totallyBounded", "code": "theorem totallyBounded {t : Set GHSpace} {C : \u211d} {u : \u2115 \u2192 \u211d} {K : \u2115 \u2192 \u2115}\n    (ulim : Tendsto u atTop (\ud835\udcdd 0)) (hdiam : \u2200 p \u2208 t, diam (univ : Set (GHSpace.Rep p)) \u2264 C)\n    (hcov : \u2200 p \u2208 t, \u2200 n : \u2115, \u2203 s : Set (GHSpace.Rep p),\n      (#s) \u2264 K n \u2227 univ \u2286 \u22c3 x \u2208 s, ball x (u n)) :\n    TotallyBounded t", "start": [785, 1], "end": [954, 31], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.AuxGluingStruct", "code": "structure AuxGluingStruct (A : Type) [MetricSpace A] : Type 1 where\n  Space : Type\n  metric : MetricSpace Space\n  embed : A \u2192 Space\n  isom : Isometry embed", "start": [975, 1], "end": [981, 24], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.auxGluing", "code": "def auxGluing (n : \u2115) : AuxGluingStruct (X n) :=\n  Nat.recOn n default fun n Y =>\n    { Space := GlueSpace Y.isom (isometry_optimalGHInjl (X n) (X (n + 1)))\n      metric := by infer_instance\n      embed :=\n        toGlueR Y.isom (isometry_optimalGHInjl (X n) (X (n + 1))) \u2218 optimalGHInjr (X n) (X (n + 1))\n      isom := (toGlueR_isometry _ _).comp (isometry_optimalGHInjr (X n) (X (n + 1))) }", "start": [993, 1], "end": [1002, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/PiNotation.lean", "imports": ["lake-packages/std/Std/Classes/SetNotation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PiNotation.piNotation", "code": "@[term_parser]\ndef piNotation := leading_parser:leadPrec\n  unicodeSymbol \"\u03a0\" \"Pi\" >>\n  many1 (ppSpace >> (binderIdent <|> bracketedBinder)) >>\n  optType >> \", \" >> termParser", "start": [21, 1], "end": [28, 32], "kind": "commanddeclaration"}, {"full_name": "PiNotation.replacePiNotation", "code": "@[macro PiNotation.piNotation] def replacePiNotation : Lean.Macro\n  | .node info _ args => return .node info ``Lean.Parser.Term.forall args\n  | _ => Lean.Macro.throwUnsupported", "start": [39, 1], "end": [43, 37], "kind": "commanddeclaration"}, {"full_name": "PiNotation.delabPi", "code": "@[delab forallE]\ndef delabPi : Delab := whenPPOption Lean.getPPNotation do\n  let stx \u2190 delabForall\n  match stx with\n  | `(\u2200 ($i:ident : $_), $j:ident \u2208 $s \u2192 $body) =>\n    if i == j then `(\u2200 $i:ident \u2208 $s, $body) else pure stx\n  | `(\u2200 ($x:ident : $_), $y:ident > $z \u2192 $body) =>\n    if x == y then `(\u2200 $x:ident > $z, $body) else pure stx\n  | `(\u2200 ($x:ident : $_), $y:ident < $z \u2192 $body) =>\n    if x == y then `(\u2200 $x:ident < $z, $body) else pure stx\n  | `(\u2200 ($x:ident : $_), $y:ident \u2265 $z \u2192 $body) =>\n    if x == y then `(\u2200 $x:ident \u2265 $z, $body) else pure stx\n  | `(\u2200 ($x:ident : $_), $y:ident \u2264 $z \u2192 $body) =>\n    if x == y then `(\u2200 $x:ident \u2264 $z, $body) else pure stx\n  | `(\u03a0 ($i:ident : $_), $j:ident \u2208 $s \u2192 $body) =>\n    if i == j then `(\u03a0 $i:ident \u2208 $s, $body) else pure stx\n  | _ => pure stx", "start": [45, 1], "end": [63, 18], "kind": "commanddeclaration"}, {"full_name": "PiNotation.delabPi'", "code": "@[scoped delab forallE]\ndef delabPi' : Delab := whenPPOption Lean.getPPNotation do\n  let stx \u2190 delabPi\n  let stx : Term \u2190\n    match stx with\n    | `($group:bracketedBinder \u2192 $body) => `(\u03a0 $group:bracketedBinder, $body)\n    | _ => pure stx\n  match stx with\n  | `(\u03a0 $group, \u03a0 $groups*, $body) => `(\u03a0 $group $groups*, $body)\n  | _ => pure stx", "start": [65, 1], "end": [80, 18], "kind": "commanddeclaration"}, {"full_name": "exists_delab", "code": "@[delab app.Exists]\ndef exists_delab : Delab := whenPPOption Lean.getPPNotation do\n  let #[\u03b9, f] := (\u2190 SubExpr.getExpr).getAppArgs | failure\n  unless f.isLambda do failure\n  let prop \u2190 Meta.isProp \u03b9\n  let dep := f.bindingBody!.hasLooseBVar 0\n  let ppTypes \u2190 getPPOption getPPFunBinderTypes\n  let stx \u2190 SubExpr.withAppArg do\n    let dom \u2190 SubExpr.withBindingDomain delab\n    withBindingBodyUnusedName $ fun x => do\n      let x : TSyntax `ident := .mk x\n      let body \u2190 delab\n      if prop && !dep then\n        `(\u2203 (_ : $dom), $body)\n      else if prop || ppTypes then\n        `(\u2203 ($x:ident : $dom), $body)\n      else\n        `(\u2203 $x:ident, $body)\n  let stx : Term \u2190\n    match stx with\n    | `(\u2203 $i:ident, $j:ident \u2208 $s \u2227 $body)\n    | `(\u2203 ($i:ident : $_), $j:ident \u2208 $s \u2227 $body) =>\n      if i == j then `(\u2203 $i:ident \u2208 $s, $body) else pure stx\n    | `(\u2203 $x:ident, $y:ident > $z \u2227 $body)\n    | `(\u2203 ($x:ident : $_), $y:ident > $z \u2227 $body) =>\n      if x == y then `(\u2203 $x:ident > $z, $body) else pure stx\n    | `(\u2203 $x:ident, $y:ident < $z \u2227 $body)\n    | `(\u2203 ($x:ident : $_), $y:ident < $z \u2227 $body) =>\n      if x == y then `(\u2203 $x:ident < $z, $body) else pure stx\n    | `(\u2203 $x:ident, $y:ident \u2265 $z \u2227 $body)\n    | `(\u2203 ($x:ident : $_), $y:ident \u2265 $z \u2227 $body) =>\n      if x == y then `(\u2203 $x:ident \u2265 $z, $body) else pure stx\n    | `(\u2203 $x:ident, $y:ident \u2264 $z \u2227 $body)\n    | `(\u2203 ($x:ident : $_), $y:ident \u2264 $z \u2227 $body) =>\n      if x == y then `(\u2203 $x:ident \u2264 $z, $body) else pure stx\n    | _ => pure stx\n  match stx with\n  | `(\u2203 $group:bracketedExplicitBinders, \u2203 $groups*, $body) => `(\u2203 $group $groups*, $body)\n  | _ => pure stx", "start": [87, 1], "end": [129, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/ConformalGroupoid.lean", "imports": ["Mathlib/Geometry/Manifold/ChartedSpace.lean", "Mathlib/Analysis/Calculus/Conformal/NormedSpace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "conformalPregroupoid", "code": "def conformalPregroupoid : Pregroupoid X where\n  property f u := \u2200 x, x \u2208 u \u2192 ConformalAt f x\n  comp {f _} _ _ hf hg _ _ _ x hx := (hg (f x) hx.2).comp x (hf x hx.1)\n  id_mem x _ := conformalAt_id x\n  locality _ h x hx :=\n    let \u27e8_, _, h\u2082, h\u2083\u27e9 := h x hx\n    h\u2083 x \u27e8hx, h\u2082\u27e9\n  congr hu h hf x hx := (hf x hx).congr hx hu h", "start": [28, 1], "end": [36, 48], "kind": "commanddeclaration"}, {"full_name": "conformalGroupoid", "code": "def conformalGroupoid : StructureGroupoid X :=\n  conformalPregroupoid.groupoid", "start": [39, 1], "end": [41, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/Commute/Basic.lean", "imports": ["Mathlib/Algebra/Group/Commute/Defs.lean", "Mathlib/Algebra/Group/Semiconj/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Commute.inv_inv", "code": "@[to_additive]\nprotected theorem inv_inv : Commute a b \u2192 Commute a\u207b\u00b9 b\u207b\u00b9", "start": [25, 1], "end": [27, 26], "kind": "commanddeclaration"}, {"full_name": "Commute.inv_inv_iff", "code": "@[to_additive (attr := simp)]\ntheorem inv_inv_iff : Commute a\u207b\u00b9 b\u207b\u00b9 \u2194 Commute a b", "start": [31, 1], "end": [33, 30], "kind": "commanddeclaration"}, {"full_name": "Commute.div_mul_div_comm", "code": "@[to_additive]\nprotected theorem div_mul_div_comm (hbd : Commute b d) (hbc : Commute b\u207b\u00b9 c) :\n    a / b * (c / d) = a * c / (b * d)", "start": [37, 1], "end": [40, 83], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_div_mul_comm", "code": "@[to_additive]\nprotected theorem mul_div_mul_comm (hcd : Commute c d) (hbc : Commute b c\u207b\u00b9) :\n    a * b / (c * d) = a / c * (b / d)", "start": [44, 1], "end": [47, 39], "kind": "commanddeclaration"}, {"full_name": "Commute.div_div_div_comm", "code": "@[to_additive]\nprotected theorem div_div_div_comm (hbc : Commute b c) (hbd : Commute b\u207b\u00b9 d) (hcd : Commute c\u207b\u00b9 d) :\n    a / b / (c / d) = a / c / (b / d)", "start": [51, 1], "end": [55, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Caratheodory.lean", "imports": ["Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "Mathlib/Analysis/Convex/Combination.lean", "Mathlib/Tactic/FieldSimp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Caratheodory.mem_convexHull_erase", "code": "theorem mem_convexHull_erase [DecidableEq E] {t : Finset E} (h : \u00acAffineIndependent \ud835\udd5c ((\u2191) : t \u2192 E))\n    {x : E} (m : x \u2208 convexHull \ud835\udd5c (\u2191t : Set E)) :\n    \u2203 y : (\u2191t : Set E), x \u2208 convexHull \ud835\udd5c (\u2191(t.erase y) : Set E)", "start": [52, 1], "end": [100, 55], "kind": "commanddeclaration"}, {"full_name": "Caratheodory.minCardFinsetOfMemConvexHull", "code": "noncomputable def minCardFinsetOfMemConvexHull : Finset E :=\n  Function.argminOn Finset.card Nat.lt_wfRel.2 { t | \u2191t \u2286 s \u2227 x \u2208 convexHull \ud835\udd5c (t : Set E) } <| by\n    simpa only [convexHull_eq_union_convexHull_finite_subsets s, exists_prop, mem_iUnion] using hx", "start": [105, 1], "end": [109, 99], "kind": "commanddeclaration"}, {"full_name": "Caratheodory.minCardFinsetOfMemConvexHull_subseteq", "code": "theorem minCardFinsetOfMemConvexHull_subseteq : \u2191(minCardFinsetOfMemConvexHull hx) \u2286 s", "start": [112, 1], "end": [113, 91], "kind": "commanddeclaration"}, {"full_name": "Caratheodory.mem_minCardFinsetOfMemConvexHull", "code": "theorem mem_minCardFinsetOfMemConvexHull :\n    x \u2208 convexHull \ud835\udd5c (minCardFinsetOfMemConvexHull hx : Set E)", "start": [116, 1], "end": [118, 91], "kind": "commanddeclaration"}, {"full_name": "Caratheodory.minCardFinsetOfMemConvexHull_nonempty", "code": "theorem minCardFinsetOfMemConvexHull_nonempty : (minCardFinsetOfMemConvexHull hx).Nonempty", "start": [121, 1], "end": [123, 49], "kind": "commanddeclaration"}, {"full_name": "Caratheodory.minCardFinsetOfMemConvexHull_card_le_card", "code": "theorem minCardFinsetOfMemConvexHull_card_le_card {t : Finset E} (ht\u2081 : \u2191t \u2286 s)\n    (ht\u2082 : x \u2208 convexHull \ud835\udd5c (t : Set E)) : (minCardFinsetOfMemConvexHull hx).card \u2264 t.card", "start": [126, 1], "end": [128, 51], "kind": "commanddeclaration"}, {"full_name": "Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull", "code": "theorem affineIndependent_minCardFinsetOfMemConvexHull :\n    AffineIndependent \ud835\udd5c ((\u2191) : minCardFinsetOfMemConvexHull hx \u2192 E)", "start": [131, 1], "end": [145, 21], "kind": "commanddeclaration"}, {"full_name": "convexHull_eq_union", "code": "theorem convexHull_eq_union : convexHull \ud835\udd5c s =\n    \u22c3 (t : Finset E) (hss : \u2191t \u2286 s) (hai : AffineIndependent \ud835\udd5c ((\u2191) : t \u2192 E)), convexHull \ud835\udd5c \u2191t", "start": [152, 1], "end": [163, 30], "kind": "commanddeclaration"}, {"full_name": "eq_pos_convex_span_of_mem_convexHull", "code": "theorem eq_pos_convex_span_of_mem_convexHull {x : E} (hx : x \u2208 convexHull \ud835\udd5c s) :\n    \u2203 (\u03b9 : Sort (u + 1)) (_ : Fintype \u03b9),\n      \u2203 (z : \u03b9 \u2192 E) (w : \u03b9 \u2192 \ud835\udd5c) (_ : Set.range z \u2286 s) (_ : AffineIndependent \ud835\udd5c z)\n        (_ : \u2200 i, 0 < w i), \u2211 i, w i = 1 \u2227 \u2211 i, w i \u2022 z i = x", "start": [166, 1], "end": [190, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/W/Cardinal.lean", "imports": ["Mathlib/SetTheory/Cardinal/Ordinal.lean", "Mathlib/Data/W/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WType.cardinal_mk_eq_sum", "code": "theorem cardinal_mk_eq_sum : #(WType \u03b2) = sum (fun a : \u03b1 => #(WType \u03b2) ^ #(\u03b2 a))", "start": [41, 1], "end": [43, 32], "kind": "commanddeclaration"}, {"full_name": "WType.cardinal_mk_le_of_le", "code": "theorem cardinal_mk_le_of_le {\u03ba : Cardinal.{u}} (h\u03ba : (sum fun a : \u03b1 => \u03ba ^ #(\u03b2 a)) \u2264 \u03ba) :\n    #(WType \u03b2) \u2264 \u03ba", "start": [46, 1], "end": [52, 65], "kind": "commanddeclaration"}, {"full_name": "WType.cardinal_mk_le_max_aleph0_of_finite", "code": "theorem cardinal_mk_le_max_aleph0_of_finite [\u2200 a, Finite (\u03b2 a)] : #(WType \u03b2) \u2264 max #\u03b1 \u2135\u2080", "start": [55, 1], "end": [81, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Category/TwoP.lean", "imports": ["Mathlib/Data/TwoPointing.lean", "Mathlib/CategoryTheory/Category/Bipointed.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TwoP", "code": "structure TwoP : Type (u + 1) where\n  protected X : Type u\n  toTwoPointing : TwoPointing X", "start": [31, 1], "end": [34, 32], "kind": "commanddeclaration"}, {"full_name": "TwoP.of", "code": "def of {X : Type*} (toTwoPointing : TwoPointing X) : TwoP :=\n  \u27e8X, toTwoPointing\u27e9", "start": [42, 1], "end": [44, 21], "kind": "commanddeclaration"}, {"full_name": "TwoP.coe_of", "code": "@[simp]\ntheorem coe_of {X : Type*} (toTwoPointing : TwoPointing X) : \u21a5(of toTwoPointing) = X", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.TwoP", "code": "alias _root_.TwoPointing.TwoP := of", "start": [52, 1], "end": [52, 36], "kind": "stdtacticaliasalias"}, {"full_name": "TwoP.toBipointed", "code": "noncomputable def toBipointed (X : TwoP) : Bipointed :=\n  X.toTwoPointing.toProd.Bipointed", "start": [58, 1], "end": [61, 35], "kind": "commanddeclaration"}, {"full_name": "TwoP.coe_toBipointed", "code": "@[simp]\ntheorem coe_toBipointed (X : TwoP) : \u21a5X.toBipointed = \u21a5X", "start": [64, 1], "end": [66, 6], "kind": "commanddeclaration"}, {"full_name": "TwoP.largeCategory", "code": "noncomputable instance largeCategory : LargeCategory TwoP :=\n  InducedCategory.category toBipointed", "start": [69, 1], "end": [70, 39], "kind": "commanddeclaration"}, {"full_name": "TwoP.concreteCategory", "code": "noncomputable instance concreteCategory : ConcreteCategory TwoP :=\n  InducedCategory.concreteCategory toBipointed", "start": [73, 1], "end": [74, 47], "kind": "commanddeclaration"}, {"full_name": "TwoP.hasForgetToBipointed", "code": "noncomputable instance hasForgetToBipointed : HasForget\u2082 TwoP Bipointed :=\n  InducedCategory.hasForget\u2082 toBipointed", "start": [77, 1], "end": [78, 41], "kind": "commanddeclaration"}, {"full_name": "TwoP.swap", "code": "@[simps]\nnoncomputable def swap : TwoP \u2964 TwoP where\n  obj X := \u27e8X, X.toTwoPointing.swap\u27e9\n  map f := \u27e8f.toFun, f.map_snd, f.map_fst\u27e9", "start": [82, 1], "end": [86, 43], "kind": "commanddeclaration"}, {"full_name": "TwoP.swapEquiv", "code": "@[simps!]\nnoncomputable def swapEquiv : TwoP \u224c TwoP :=\n  CategoryTheory.Equivalence.mk swap swap\n    (NatIso.ofComponents fun X =>\n      { hom := \u27e8id, rfl, rfl\u27e9\n        inv := \u27e8id, rfl, rfl\u27e9 })\n    (NatIso.ofComponents fun X =>\n      { hom := \u27e8id, rfl, rfl\u27e9\n        inv := \u27e8id, rfl, rfl\u27e9 })", "start": [89, 1], "end": [98, 33], "kind": "commanddeclaration"}, {"full_name": "TwoP.swapEquiv_symm", "code": "@[simp]\ntheorem swapEquiv_symm : swapEquiv.symm = swapEquiv", "start": [101, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "TwoP_swap_comp_forget_to_Bipointed", "code": "@[simp]\ntheorem TwoP_swap_comp_forget_to_Bipointed :\n    TwoP.swap \u22d9 forget\u2082 TwoP Bipointed = forget\u2082 TwoP Bipointed \u22d9 Bipointed.swap", "start": [108, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "pointedToTwoPFst", "code": "@[simps]\nnoncomputable def pointedToTwoPFst : Pointed.{u} \u2964 TwoP where\n  obj X := \u27e8Option X, \u27e8X.point, none\u27e9, some_ne_none _\u27e9\n  map f := \u27e8Option.map f.toFun, congr_arg _ f.map_point, rfl\u27e9\n  map_id _ := Bipointed.Hom.ext _ _ Option.map_id\n  map_comp f g := Bipointed.Hom.ext _ _ (Option.map_comp_map f.1 g.1).symm", "start": [114, 1], "end": [120, 75], "kind": "commanddeclaration"}, {"full_name": "pointedToTwoPSnd", "code": "@[simps]\nnoncomputable def pointedToTwoPSnd : Pointed.{u} \u2964 TwoP where\n  obj X := \u27e8Option X, \u27e8none, X.point\u27e9, (some_ne_none _).symm\u27e9\n  map f := \u27e8Option.map f.toFun, rfl, congr_arg _ f.map_point\u27e9\n  map_id _ := Bipointed.Hom.ext _ _ Option.map_id\n  map_comp f g := Bipointed.Hom.ext _ _ (Option.map_comp_map f.1 g.1).symm", "start": [123, 1], "end": [129, 75], "kind": "commanddeclaration"}, {"full_name": "pointedToTwoPFst_comp_swap", "code": "@[simp]\ntheorem pointedToTwoPFst_comp_swap : pointedToTwoPFst \u22d9 TwoP.swap = pointedToTwoPSnd", "start": [132, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "pointedToTwoPSnd_comp_swap", "code": "@[simp]\ntheorem pointedToTwoPSnd_comp_swap : pointedToTwoPSnd \u22d9 TwoP.swap = pointedToTwoPFst", "start": [137, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "pointedToTwoPFst_comp_forget_to_bipointed", "code": "@[simp]\ntheorem pointedToTwoPFst_comp_forget_to_bipointed :\n    pointedToTwoPFst \u22d9 forget\u2082 TwoP Bipointed = pointedToBipointedFst", "start": [142, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "pointedToTwoPSnd_comp_forget_to_bipointed", "code": "@[simp]\ntheorem pointedToTwoPSnd_comp_forget_to_bipointed :\n    pointedToTwoPSnd \u22d9 forget\u2082 TwoP Bipointed = pointedToBipointedSnd", "start": [148, 1], "end": [151, 6], "kind": "commanddeclaration"}, {"full_name": "pointedToTwoPFstForgetCompBipointedToPointedFstAdjunction", "code": "noncomputable def pointedToTwoPFstForgetCompBipointedToPointedFstAdjunction :\n    pointedToTwoPFst \u22a3 forget\u2082 TwoP Bipointed \u22d9 bipointedToPointedFst :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y =>\n        { toFun := fun f => \u27e8f.toFun \u2218 Option.some, f.map_fst\u27e9\n          invFun := fun f => \u27e8fun o => o.elim Y.toTwoPointing.toProd.2 f.toFun, f.map_point, rfl\u27e9\n          left_inv := fun f => by\n            apply Bipointed.Hom.ext\n            funext x\n            cases x\n            exact f.map_snd.symm\n            rfl\n          right_inv := fun f => Pointed.Hom.ext _ _ rfl }\n      homEquiv_naturality_left_symm := fun f g => by\n        apply Bipointed.Hom.ext\n        funext x\n        cases x <;> rfl }", "start": [154, 1], "end": [171, 26], "kind": "commanddeclaration"}, {"full_name": "pointedToTwoPSndForgetCompBipointedToPointedSndAdjunction", "code": "noncomputable def pointedToTwoPSndForgetCompBipointedToPointedSndAdjunction :\n    pointedToTwoPSnd \u22a3 forget\u2082 TwoP Bipointed \u22d9 bipointedToPointedSnd :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y =>\n        { toFun := fun f => \u27e8f.toFun \u2218 Option.some, f.map_snd\u27e9\n          invFun := fun f => \u27e8fun o => o.elim Y.toTwoPointing.toProd.1 f.toFun, rfl, f.map_point\u27e9\n          left_inv := fun f => by\n            apply Bipointed.Hom.ext\n            funext x\n            cases x\n            exact f.map_fst.symm\n            rfl\n          right_inv := fun f => Pointed.Hom.ext _ _ rfl }\n      homEquiv_naturality_left_symm := fun f g => by\n        apply Bipointed.Hom.ext\n        funext x\n        cases x <;> rfl }", "start": [174, 1], "end": [191, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/CliffordAlgebra/EvenEquiv.lean", "imports": ["Mathlib/LinearAlgebra/QuadraticForm/Prod.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Even.lean", "Mathlib/Tactic/LiftLets.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Conjugation.lean"], "premises": [{"full_name": "CliffordAlgebra.EquivEven.Q'", "code": "@[reducible]\ndef Q' : QuadraticForm R (M \u00d7 R) :=\n  Q.prod <| -@QuadraticForm.sq R _", "start": [49, 1], "end": [52, 35], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EquivEven.Q'_apply", "code": "theorem Q'_apply (m : M \u00d7 R) : Q' Q m = Q m.1 - m.2 * m.2", "start": [56, 1], "end": [57, 28], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EquivEven.e0", "code": "def e0 : CliffordAlgebra (Q' Q) :=\n  \u03b9 (Q' Q) (0, 1)", "start": [61, 1], "end": [63, 18], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EquivEven.v", "code": "def v : M \u2192\u2097[R] CliffordAlgebra (Q' Q) :=\n  \u03b9 (Q' Q) \u2218\u2097 LinearMap.inl _ _ _", "start": [66, 1], "end": [68, 34], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EquivEven.\u03b9_eq_v_add_smul_e0", "code": "theorem \u03b9_eq_v_add_smul_e0 (m : M) (r : R) : \u03b9 (Q' Q) (m, r) = v Q m + r \u2022 e0 Q", "start": [71, 1], "end": [73, 94], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EquivEven.e0_mul_e0", "code": "theorem e0_mul_e0 : e0 Q * e0 Q = -1", "start": [76, 1], "end": [77, 37], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EquivEven.v_sq_scalar", "code": "theorem v_sq_scalar (m : M) : v Q m * v Q m = algebraMap _ _ (Q m)", "start": [80, 1], "end": [81, 37], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EquivEven.neg_e0_mul_v", "code": "theorem neg_e0_mul_v (m : M) : -(e0 Q * v Q m) = v Q m * e0 Q", "start": [84, 1], "end": [88, 50], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EquivEven.neg_v_mul_e0", "code": "theorem neg_v_mul_e0 (m : M) : -(v Q m * e0 Q) = e0 Q * v Q m", "start": [91, 1], "end": [93, 32], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EquivEven.e0_mul_v_mul_e0", "code": "@[simp]\ntheorem e0_mul_v_mul_e0 (m : M) : e0 Q * v Q m * e0 Q = v Q m", "start": [96, 1], "end": [98, 77], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EquivEven.reverse_v", "code": "@[simp]\ntheorem reverse_v (m : M) : reverse (Q := Q' Q) (v Q m) = v Q m", "start": [101, 1], "end": [103, 14], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EquivEven.involute_v", "code": "@[simp]\ntheorem involute_v (m : M) : involute (v Q m) = -v Q m", "start": [106, 1], "end": [108, 15], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EquivEven.reverse_e0", "code": "@[simp]\ntheorem reverse_e0 : reverse (Q := Q' Q) (e0 Q) = e0 Q", "start": [111, 1], "end": [113, 14], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EquivEven.involute_e0", "code": "@[simp]\ntheorem involute_e0 : involute (e0 Q) = -e0 Q", "start": [116, 1], "end": [118, 15], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.toEven", "code": "def toEven : CliffordAlgebra Q \u2192\u2090[R] CliffordAlgebra.even (Q' Q) := by\n  refine' CliffordAlgebra.lift Q \u27e8_, fun m => _\u27e9\n  \u00b7 refine' LinearMap.codRestrict _ _ fun m => Submodule.mem_iSup_of_mem \u27e82, rfl\u27e9 _\n    \u00b7 exact (LinearMap.mulLeft R <| e0 Q).comp (v Q)\n    rw [Subtype.coe_mk, pow_two]\n    exact Submodule.mul_mem_mul (LinearMap.mem_range_self _ _) (LinearMap.mem_range_self _ _)\n  \u00b7 ext1\n    rw [Subalgebra.coe_mul]  erw [LinearMap.codRestrict_apply] dsimp only [LinearMap.comp_apply, LinearMap.mulLeft_apply, Subalgebra.coe_algebraMap]\n    rw [\u2190 mul_assoc, e0_mul_v_mul_e0, v_sq_scalar]", "start": [125, 1], "end": [136, 51], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.toEven_\u03b9", "code": "@[simp]\ntheorem toEven_\u03b9 (m : M) : (toEven Q (\u03b9 Q m) : CliffordAlgebra (Q' Q)) = e0 Q * v Q m", "start": [139, 1], "end": [144, 72], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.ofEven", "code": "def ofEven : CliffordAlgebra.even (Q' Q) \u2192\u2090[R] CliffordAlgebra Q := by\n  \n  let f : M \u00d7 R \u2192\u2097[R] M \u00d7 R \u2192\u2097[R] CliffordAlgebra Q :=\n    ((Algebra.lmul R (CliffordAlgebra Q)).toLinearMap.comp <|\n          (\u03b9 Q).comp (LinearMap.fst _ _ _) +\n            (Algebra.linearMap R _).comp (LinearMap.snd _ _ _)).compl\u2082\n      ((\u03b9 Q).comp (LinearMap.fst _ _ _) - (Algebra.linearMap R _).comp (LinearMap.snd _ _ _))\n  haveI f_apply : \u2200 x y, f x y = (\u03b9 Q x.1 + algebraMap R _ x.2) * (\u03b9 Q y.1 - algebraMap R _ y.2) :=\n    fun x y => by rfl\n  haveI hc : \u2200 (r : R) (x : CliffordAlgebra Q), Commute (algebraMap _ _ r) x := Algebra.commutes\n  haveI hm :\n    \u2200 m : M \u00d7 R,\n      \u03b9 Q m.1 * \u03b9 Q m.1 - algebraMap R _ m.2 * algebraMap R _ m.2 = algebraMap R _ (Q' Q m) := by\n    intro m\n    rw [\u03b9_sq_scalar, \u2190 RingHom.map_mul, \u2190 RingHom.map_sub, sub_eq_add_neg, Q'_apply, sub_eq_add_neg]\n  refine' even.lift (Q' Q) \u27e8f, _, _\u27e9 <;> simp_rw [f_apply]\n  \u00b7 intro m\n    rw [\u2190 (hc _ _).symm.mul_self_sub_mul_self_eq, hm]\n  \u00b7 intro m\u2081 m\u2082 m\u2083\n    rw [\u2190 mul_smul_comm, \u2190 mul_assoc, mul_assoc (_ + _), \u2190 (hc _ _).symm.mul_self_sub_mul_self_eq',\n      Algebra.smul_def, \u2190 mul_assoc, hm]", "start": [147, 1], "end": [174, 41], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.ofEven_\u03b9", "code": "theorem ofEven_\u03b9 (x y : M \u00d7 R) :\n    ofEven Q ((even.\u03b9 (Q' Q)).bilin x y) =\n      (\u03b9 Q x.1 + algebraMap R _ x.2) * (\u03b9 Q y.1 - algebraMap R _ y.2)", "start": [177, 1], "end": [185, 67], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.toEven_comp_ofEven", "code": "theorem toEven_comp_ofEven : (toEven Q).comp (ofEven Q) = AlgHom.id R _", "start": [188, 1], "end": [218, 98], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.ofEven_comp_toEven", "code": "theorem ofEven_comp_toEven : (ofEven Q).comp (toEven Q) = AlgHom.id R _", "start": [221, 1], "end": [230, 86], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.equivEven", "code": "@[simps!]\ndef equivEven : CliffordAlgebra Q \u2243\u2090[R] CliffordAlgebra.even (Q' Q) :=\n  AlgEquiv.ofAlgHom (toEven Q) (ofEven Q) (toEven_comp_ofEven Q) (ofEven_comp_toEven Q)", "start": [233, 1], "end": [238, 88], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.coe_toEven_reverse_involute", "code": "theorem coe_toEven_reverse_involute (x : CliffordAlgebra Q) :\n    \u2191(toEven Q (reverse (involute x))) =\n      reverse (Q := Q' Q) (toEven Q x : CliffordAlgebra (Q' Q))", "start": [244, 1], "end": [257, 74], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.evenToNeg", "code": "def evenToNeg (Q' : QuadraticForm R M) (h : Q' = -Q) :\n    CliffordAlgebra.even Q \u2192\u2090[R] CliffordAlgebra.even Q' :=\n  even.lift Q <|\n    letI : AddCommGroup (even Q') := AddSubgroupClass.toAddCommGroup _;\n    letI : HasDistribNeg (even Q') := NonUnitalNonAssocRing.toHasDistribNeg;\n    { bilin := -(even.\u03b9 Q' : _).bilin\n      contract := fun m => by\n        simp_rw [LinearMap.neg_apply, EvenHom.contract, h, QuadraticForm.neg_apply, map_neg,\n          neg_neg]\n      contract_mid := fun m\u2081 m\u2082 m\u2083 => by\n        simp_rw [LinearMap.neg_apply, neg_mul_neg, EvenHom.contract_mid, h,\n          QuadraticForm.neg_apply, smul_neg, neg_smul] }", "start": [262, 1], "end": [275, 57], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.evenToNeg_\u03b9", "code": "@[simp, nolint simpNF]\ntheorem evenToNeg_\u03b9 (Q' : QuadraticForm R M) (h : Q' = -Q) (m\u2081 m\u2082 : M) :\n    evenToNeg Q Q' h ((even.\u03b9 Q).bilin m\u2081 m\u2082) = -(even.\u03b9 Q').bilin m\u2081 m\u2082", "start": [279, 1], "end": [282, 24], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.evenToNeg_comp_evenToNeg", "code": "theorem evenToNeg_comp_evenToNeg (Q' : QuadraticForm R M) (h : Q' = -Q) (h' : Q = -Q') :\n    (evenToNeg Q' Q h').comp (evenToNeg Q Q' h) = AlgHom.id R _", "start": [286, 1], "end": [291, 50], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.evenEquivEvenNeg", "code": "@[simps!]\ndef evenEquivEvenNeg : CliffordAlgebra.even Q \u2243\u2090[R] CliffordAlgebra.even (-Q) :=\n  AlgEquiv.ofAlgHom (evenToNeg Q _ rfl) (evenToNeg (-Q) _ (neg_neg _).symm)\n    (evenToNeg_comp_evenToNeg _ _ _ _) (evenToNeg_comp_evenToNeg _ _ _ _)", "start": [294, 1], "end": [300, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Tactic.lean", "imports": ["Mathlib/Tactic/Continuity.lean", "Mathlib/Topology/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Algebra/Homology/LocalCohomology.lean", "imports": ["Mathlib/RingTheory/Ideal/Basic.lean", "Mathlib/Algebra/Category/ModuleCat/Colimits.lean", "Mathlib/RingTheory/Noetherian.lean", "Mathlib/CategoryTheory/Abelian/Ext.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Final.lean", "Mathlib/RingTheory/Finiteness.lean", "Mathlib/Algebra/Category/ModuleCat/Projective.lean"], "premises": [{"full_name": "localCohomology.ringModIdeals", "code": "def ringModIdeals (I : D \u2964 Ideal R) : D \u2964 ModuleCat.{u} R where\n  obj t := ModuleCat.of R <| R \u29f8 I.obj t\n  map w := Submodule.mapQ _ _ LinearMap.id (I.map w).down.down\n  map_comp f g := by apply Submodule.linearMap_qext; rfl", "start": [68, 1], "end": [74, 57], "kind": "commanddeclaration"}, {"full_name": "localCohomology.moduleCat_enoughProjectives'", "code": "instance moduleCat_enoughProjectives' : EnoughProjectives (ModuleCat.{u} R) :=\n  ModuleCat.moduleCat_enoughProjectives.{u}", "start": [78, 1], "end": [79, 44], "kind": "commanddeclaration"}, {"full_name": "localCohomology.diagram", "code": "def diagram (I : D \u2964 Ideal R) (i : \u2115) : D\u1d52\u1d56 \u2964 ModuleCat.{u} R \u2964 ModuleCat.{u} R :=\n  (ringModIdeals I).op \u22d9 Ext R (ModuleCat.{u} R) i", "start": [83, 1], "end": [86, 51], "kind": "commanddeclaration"}, {"full_name": "localCohomology.hasColimitDiagram", "code": "lemma hasColimitDiagram (I : D \u2964 Ideal R) (i : \u2115) :\n    HasColimit (diagram I i) := by\n  have : HasColimitsOfShape D\u1d52\u1d56 (AddCommGroupCatMax.{u, v}) := inferInstance\n  infer_instance", "start": [97, 1], "end": [100, 17], "kind": "mathlibtacticlemma"}, {"full_name": "localCohomology.ofDiagram", "code": "def ofDiagram (I : D \u2964 Ideal R) (i : \u2115) : ModuleCatMax.{u, v} R \u2964 ModuleCatMax.{u, v} R :=\n  have := hasColimitDiagram.{u, v} I i\n  colimit (diagram I i)", "start": [109, 1], "end": [114, 24], "kind": "commanddeclaration"}, {"full_name": "localCohomology.diagramComp", "code": "def diagramComp (i : \u2115) : diagram (I' \u22d9 I) i \u2245 I'.op \u22d9 diagram I i :=\n  Iso.refl _", "start": [125, 1], "end": [127, 13], "kind": "commanddeclaration"}, {"full_name": "localCohomology.isoOfFinal", "code": "@[nolint unusedHavesSuffices]\ndef isoOfFinal [Functor.Initial I'] (i : \u2115) :\n    ofDiagram.{max u v, v'} (I' \u22d9 I) i \u2245 ofDiagram.{max u v', v} I i :=\n  have := hasColimitDiagram.{max u v', v} I i\n  have := hasColimitDiagram.{max u v, v'} (I' \u22d9 I) i\n  HasColimit.isoOfNatIso (diagramComp.{u} I' I i) \u226a\u226b Functor.Final.colimitIso _ _", "start": [130, 1], "end": [136, 82], "kind": "commanddeclaration"}, {"full_name": "localCohomology.idealPowersDiagram", "code": "def idealPowersDiagram (J : Ideal R) : \u2115\u1d52\u1d56 \u2964 Ideal R where\n  obj t := J ^ unop t\n  map w := \u27e8\u27e8Ideal.pow_le_pow w.unop.down.down\u27e9\u27e9", "start": [145, 1], "end": [148, 49], "kind": "commanddeclaration"}, {"full_name": "localCohomology.SelfLERadical", "code": "def SelfLERadical (J : Ideal R) : Type u :=\n  FullSubcategory fun J' : Ideal R => J \u2264 J'.radical", "start": [151, 1], "end": [153, 53], "kind": "commanddeclaration"}, {"full_name": "localCohomology.SelfLERadical.inhabited", "code": "instance SelfLERadical.inhabited (J : Ideal R) : Inhabited (SelfLERadical J) where\n  default := \u27e8J, Ideal.le_radical\u27e9", "start": [161, 1], "end": [162, 35], "kind": "commanddeclaration"}, {"full_name": "localCohomology.selfLERadicalDiagram", "code": "def selfLERadicalDiagram (J : Ideal R) : SelfLERadical J \u2964 Ideal R :=\n  fullSubcategoryInclusion _", "start": [165, 1], "end": [168, 29], "kind": "commanddeclaration"}, {"full_name": "localCohomology", "code": "def localCohomology (J : Ideal R) (i : \u2115) : ModuleCat.{u} R \u2964 ModuleCat.{u} R :=\n  ofDiagram (idealPowersDiagram J) i", "start": [186, 1], "end": [190, 37], "kind": "commanddeclaration"}, {"full_name": "localCohomology.ofSelfLERadical", "code": "def localCohomology.ofSelfLERadical (J : Ideal R) (i : \u2115) : ModuleCat.{u} R \u2964 ModuleCat.{u} R :=\n  ofDiagram.{u} (selfLERadicalDiagram.{u} J) i", "start": [193, 1], "end": [196, 47], "kind": "commanddeclaration"}, {"full_name": "localCohomology.idealPowersToSelfLERadical", "code": "def idealPowersToSelfLERadical (J : Ideal R) : \u2115\u1d52\u1d56 \u2964 SelfLERadical J :=\n  FullSubcategory.lift _ (idealPowersDiagram J) fun k => by\n    change _ \u2264 (J ^ unop k).radical\n    cases' unop k with n\n    \u00b7 simp [Ideal.radical_top, pow_zero, Ideal.one_eq_top, le_top, Nat.zero_eq]\n    \u00b7 simp only [J.radical_pow _ n.succ_pos, Ideal.le_radical]", "start": [215, 1], "end": [222, 63], "kind": "commanddeclaration"}, {"full_name": "localCohomology.Ideal.exists_pow_le_of_le_radical_of_fG", "code": "theorem Ideal.exists_pow_le_of_le_radical_of_fG (hIJ : I \u2264 J.radical) (hJ : J.radical.FG) :\n    \u2203 k : \u2115, I ^ k \u2264 J", "start": [227, 1], "end": [238, 16], "kind": "commanddeclaration"}, {"full_name": "localCohomology.ideal_powers_initial", "code": "instance ideal_powers_initial [hR : IsNoetherian R R] :\n    Functor.Initial (idealPowersToSelfLERadical J) where\n  out J' := by\n    apply (config := {allowSynthFailures := true }) zigzag_isConnected\n    \u00b7 obtain \u27e8k, hk\u27e9 := Ideal.exists_pow_le_of_le_radical_of_fG J'.2 (isNoetherian_def.mp hR _)\n      exact \u27e8CostructuredArrow.mk (\u27e8\u27e8hk\u27e9\u27e9 : (idealPowersToSelfLERadical J).obj (op k) \u27f6 J')\u27e9\n    \u00b7 intro j1 j2\n      apply Relation.ReflTransGen.single\n      cases' le_total (unop j1.left) (unop j2.left) with h h\n      right; exact \u27e8CostructuredArrow.homMk (homOfLE h).op (AsTrue.get trivial)\u27e9\n      left; exact \u27e8CostructuredArrow.homMk (homOfLE h).op (AsTrue.get trivial)\u27e9", "start": [241, 1], "end": [255, 80], "kind": "commanddeclaration"}, {"full_name": "localCohomology.isoSelfLERadical", "code": "def isoSelfLERadical (J : Ideal.{u} R) [IsNoetherian.{u,u} R R] (i : \u2115) :\n    localCohomology.ofSelfLERadical.{u} J i \u2245 localCohomology.{u} J i :=\n  (localCohomology.isoOfFinal.{u, u, 0} (idealPowersToSelfLERadical.{u} J)\n    (selfLERadicalDiagram.{u} J) i).symm \u226a\u226b\n      HasColimit.isoOfNatIso.{0,0,u+1,u+1} (Iso.refl.{u+1,u+1} _)", "start": [259, 1], "end": [265, 66], "kind": "commanddeclaration"}, {"full_name": "localCohomology.SelfLERadical.cast", "code": "def SelfLERadical.cast (hJK : J.radical = K.radical) : SelfLERadical J \u2964 SelfLERadical K :=\n  FullSubcategory.map fun L hL => by\n    rw [\u2190 Ideal.radical_le_radical_iff] at hL \u22a2\n    exact hJK.symm.trans_le hL", "start": [268, 1], "end": [273, 31], "kind": "commanddeclaration"}, {"full_name": "localCohomology.SelfLERadical.castIsEquivalence", "code": "instance SelfLERadical.castIsEquivalence (hJK : J.radical = K.radical) :\n    IsEquivalence (SelfLERadical.cast hJK) where\n  inverse := SelfLERadical.cast hJK.symm\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _", "start": [277, 1], "end": [281, 26], "kind": "commanddeclaration"}, {"full_name": "localCohomology.SelfLERadical.isoOfSameRadical", "code": "def SelfLERadical.isoOfSameRadical (hJK : J.radical = K.radical) (i : \u2115) :\n    ofSelfLERadical J i \u2245 ofSelfLERadical K i :=\n  (isoOfFinal.{u, u, u} (SelfLERadical.cast hJK.symm) _ _).symm", "start": [284, 1], "end": [288, 64], "kind": "commanddeclaration"}, {"full_name": "localCohomology.isoOfSameRadical", "code": "def isoOfSameRadical [IsNoetherian R R] (hJK : J.radical = K.radical) (i : \u2115) :\n    localCohomology J i \u2245 localCohomology K i :=\n  (isoSelfLERadical J i).symm \u226a\u226b SelfLERadical.isoOfSameRadical hJK i \u226a\u226b isoSelfLERadical K i", "start": [291, 1], "end": [294, 94], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/DomAct/ActionHom.lean", "imports": ["Mathlib/GroupTheory/GroupAction/DomAct/Basic.lean", "Mathlib/Algebra/Hom/GroupAction.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DomMulAct.smul_mulActionHom_apply", "code": "theorem smul_mulActionHom_apply (c : M\u1d48\u1d50\u1d43) (f : \u03b1 \u2192[N] \u03b2) (a : \u03b1) :\n    (c \u2022 f) a = f (mk.symm c \u2022 a)", "start": [38, 1], "end": [40, 6], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.mk_smul_mulActionHom_apply", "code": "@[simp]\ntheorem mk_smul_mulActionHom_apply (c : M) (f : \u03b1 \u2192[N] \u03b2) (a : \u03b1) : (mk c \u2022 f) a = f (c \u2022 a)", "start": [42, 1], "end": [43, 100], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.smul_mulDistribActionHom_apply", "code": "theorem smul_mulDistribActionHom_apply (c : M\u1d48\u1d50\u1d43) (f : A \u2192+[N] B) (a : A) :\n    (c \u2022 f) a = f (mk.symm c \u2022 a)", "start": [67, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.mk_smul_mulDistribActionHom_apply", "code": "@[simp]\ntheorem mk_smul_mulDistribActionHom_apply (c : M) (f : A \u2192+[N] B) (a : A) :\n    (mk c \u2022 f) a = f (c \u2022 a)", "start": [71, 1], "end": [73, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Closed/FunctorCategory.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/FunctorCategory.lean", "Mathlib/CategoryTheory/Closed/Monoidal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.closedIhom", "code": "@[simps!]\ndef closedIhom (F : D \u2964 C) : (D \u2964 C) \u2964 D \u2964 C :=\n  ((whiskeringRight\u2082 D C\u1d52\u1d56 C C).obj internalHom).obj (Groupoid.invFunctor D \u22d9 F.op)", "start": [26, 1], "end": [30, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.closedUnit", "code": "@[simps]\ndef closedUnit (F : D \u2964 C) : \ud835\udfed (D \u2964 C) \u27f6 tensorLeft F \u22d9 closedIhom F where\n  app G :=\n  { app := fun X => (ihom.coev (F.obj X)).app (G.obj X)\n    naturality := by\n      intro X Y f\n      dsimp\n      simp only [ihom.coev_naturality, closedIhom_obj_map, Monoidal.tensorObj_map]\n      dsimp\n      rw [coev_app_comp_pre_app_assoc, \u2190 Functor.map_comp]\n      simp }", "start": [33, 1], "end": [45, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.closedCounit", "code": "@[simps]\ndef closedCounit (F : D \u2964 C) : closedIhom F \u22d9 tensorLeft F \u27f6 \ud835\udfed (D \u2964 C) where\n  app G :=\n  { app := fun X => (ihom.ev (F.obj X)).app (G.obj X)\n    naturality := by\n      intro X Y f\n      dsimp\n      simp only [closedIhom_obj_map, pre_comm_ihom_map]\n      rw [\u2190 tensor_id_comp_id_tensor, id_tensor_comp]\n      simp }", "start": [48, 1], "end": [59, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.closed", "code": "instance closed (F : D \u2964 C) : Closed F where\n  isAdj :=\n  { right := closedIhom F\n    adj := Adjunction.mkOfUnitCounit\n      { unit := closedUnit F\n        counit := closedCounit F } }", "start": [62, 1], "end": [71, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.monoidalClosed", "code": "@[simps!]\ninstance monoidalClosed : MonoidalClosed (D \u2964 C) where\n  closed := by infer_instance", "start": [74, 1], "end": [78, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.ihom_map", "code": "theorem ihom_map (F : D \u2964 C) {G H : D \u2964 C} (f : G \u27f6 H) : (ihom F).map f = (closedIhom F).map f", "start": [85, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.ihom_ev_app", "code": "theorem ihom_ev_app (F G : D \u2964 C) : (ihom.ev F).app G = (closedCounit F).app G", "start": [89, 1], "end": [90, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.ihom_coev_app", "code": "theorem ihom_coev_app (F G : D \u2964 C) : (ihom.coev F).app G = (closedUnit F).app G", "start": [93, 1], "end": [94, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/MonCat/Adjunctions.lean", "imports": ["Mathlib/Algebra/Group/WithOne/Basic.lean", "Mathlib/Algebra/Category/SemigroupCat/Basic.lean", "Mathlib/Algebra/Category/MonCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/FreeMonoid/Basic.lean"], "premises": [{"full_name": "adjoinOne", "code": "@[to_additive (attr := simps) \"The functor of adjoining a neutral element `zero` to a semigroup\"]\ndef adjoinOne : SemigroupCat.{u} \u2964 MonCat.{u} where\n  obj S := MonCat.of (WithOne S)\n  map := WithOne.map\n  map_id _ := WithOne.map_id\n  map_comp := WithOne.map_comp", "start": [30, 1], "end": [37, 31], "kind": "commanddeclaration"}, {"full_name": "hasForgetToSemigroup", "code": "@[to_additive]\ninstance hasForgetToSemigroup : HasForget\u2082 MonCat SemigroupCat where\n  forget\u2082 :=\n    { obj := fun M => SemigroupCat.of M\n      map := MonoidHom.toMulHom }", "start": [41, 1], "end": [45, 34], "kind": "commanddeclaration"}, {"full_name": "adjoinOneAdj", "code": "@[to_additive \"The `adjoinZero`-forgetful adjunction from `AddSemigroupCat` to `AddMonCat`\"]\ndef adjoinOneAdj : adjoinOne \u22a3 forget\u2082 MonCat.{u} SemigroupCat.{u} :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun S M => WithOne.lift.symm\n      homEquiv_naturality_left_symm := by\n        intro S T M f g\n        ext x\n        simp only [Equiv.symm_symm, adjoinOne_map, coe_comp]\n        simp_rw [WithOne.map]\n        cases x\n        \u00b7 rfl\n        \u00b7 simp\n          rfl }", "start": [51, 1], "end": [64, 16], "kind": "commanddeclaration"}, {"full_name": "free", "code": "def free : Type u \u2964 MonCat.{u} where\n  obj \u03b1 := MonCat.of (FreeMonoid \u03b1)\n  map := FreeMonoid.map\n  map_id _ := FreeMonoid.hom_eq (fun _ => rfl)\n  map_comp _ _ := FreeMonoid.hom_eq (fun _ => rfl)", "start": [68, 1], "end": [73, 51], "kind": "commanddeclaration"}, {"full_name": "adj", "code": "def adj : free \u22a3 forget MonCat.{u} :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X G => FreeMonoid.lift.symm\n      homEquiv_naturality_left_symm := fun _ _ => FreeMonoid.hom_eq (fun _ => rfl) }", "start": [76, 1], "end": [80, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/MatrixExponential.lean", "imports": ["Mathlib/Topology/UniformSpace/Matrix.lean", "Mathlib/Analysis/NormedSpace/Exponential.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Matrix/Symmetric.lean", "Mathlib/Analysis/Matrix.lean", "Mathlib/LinearAlgebra/Matrix/ZPow.lean", "Mathlib/LinearAlgebra/Matrix/Hermitian.lean"], "premises": [{"full_name": "Matrix.exp_diagonal", "code": "theorem exp_diagonal (v : m \u2192 \ud835\udd38) : exp \ud835\udd42 (diagonal v) = diagonal (exp \ud835\udd42 v)", "start": [77, 1], "end": [78, 72], "kind": "commanddeclaration"}, {"full_name": "Matrix.exp_blockDiagonal", "code": "theorem exp_blockDiagonal (v : m \u2192 Matrix n n \ud835\udd38) :\n    exp \ud835\udd42 (blockDiagonal v) = blockDiagonal (exp \ud835\udd42 v)", "start": [81, 1], "end": [83, 89], "kind": "commanddeclaration"}, {"full_name": "Matrix.exp_blockDiagonal'", "code": "theorem exp_blockDiagonal' (v : \u2200 i, Matrix (n' i) (n' i) \ud835\udd38) :\n    exp \ud835\udd42 (blockDiagonal' v) = blockDiagonal' (exp \ud835\udd42 v)", "start": [86, 1], "end": [88, 92], "kind": "commanddeclaration"}, {"full_name": "Matrix.exp_conjTranspose", "code": "theorem exp_conjTranspose [StarRing \ud835\udd38] [ContinuousStar \ud835\udd38] (A : Matrix m m \ud835\udd38) :\n    exp \ud835\udd42 A\u1d34 = (exp \ud835\udd42 A)\u1d34", "start": [91, 1], "end": [93, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.exp", "code": "theorem IsHermitian.exp [StarRing \ud835\udd38] [ContinuousStar \ud835\udd38] {A : Matrix m m \ud835\udd38} (h : A.IsHermitian) :\n    (exp \ud835\udd42 A).IsHermitian", "start": [96, 1], "end": [98, 54], "kind": "commanddeclaration"}, {"full_name": "Matrix.exp_transpose", "code": "theorem exp_transpose (A : Matrix m m \ud835\udd38) : exp \ud835\udd42 A\u1d40 = (exp \ud835\udd42 A)\u1d40", "start": [108, 1], "end": [109, 71], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsSymm.exp", "code": "theorem IsSymm.exp {A : Matrix m m \ud835\udd38} (h : A.IsSymm) : (exp \ud835\udd42 A).IsSymm", "start": [112, 1], "end": [113, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.exp_add_of_commute", "code": "nonrec theorem exp_add_of_commute (A B : Matrix m m \ud835\udd38) (h : Commute A B) :\n    exp \ud835\udd42 (A + B) = exp \ud835\udd42 A * exp \ud835\udd42 B", "start": [125, 1], "end": [130, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.exp_sum_of_commute", "code": "nonrec theorem exp_sum_of_commute {\u03b9} (s : Finset \u03b9) (f : \u03b9 \u2192 Matrix m m \ud835\udd38)\n    (h : (s : Set \u03b9).Pairwise fun i j => Commute (f i) (f j)) :\n    exp \ud835\udd42 (\u2211 i in s, f i) =\n      s.noncommProd (fun i => exp \ud835\udd42 (f i)) fun i hi j hj _ => (h.of_refl hi hj).exp \ud835\udd42", "start": [133, 1], "end": [140, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.exp_nsmul", "code": "nonrec theorem exp_nsmul (n : \u2115) (A : Matrix m m \ud835\udd38) : exp \ud835\udd42 (n \u2022 A) = exp \ud835\udd42 A ^ n", "start": [143, 1], "end": [147, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_exp", "code": "nonrec theorem isUnit_exp (A : Matrix m m \ud835\udd38) : IsUnit (exp \ud835\udd42 A)", "start": [150, 1], "end": [154, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.exp_units_conj", "code": "nonrec theorem exp_units_conj (U : (Matrix m m \ud835\udd38)\u02e3) (A : Matrix m m \ud835\udd38) :\n    exp \ud835\udd42 (U.val * A * (U\u207b\u00b9).val) = U.val * exp \ud835\udd42 A * (U\u207b\u00b9).val", "start": [158, 1], "end": [163, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.exp_units_conj'", "code": "theorem exp_units_conj' (U : (Matrix m m \ud835\udd38)\u02e3) (A : Matrix m m \ud835\udd38) :\n    exp \ud835\udd42 ((U\u207b\u00b9).val * A * U.val) = (U\u207b\u00b9).val * exp \ud835\udd42 A * U.val", "start": [167, 1], "end": [169, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.exp_neg", "code": "theorem exp_neg (A : Matrix m m \ud835\udd38) : exp \ud835\udd42 (-A) = (exp \ud835\udd42 A)\u207b\u00b9", "start": [179, 1], "end": [184, 36], "kind": "commanddeclaration"}, {"full_name": "Matrix.exp_zsmul", "code": "theorem exp_zsmul (z : \u2124) (A : Matrix m m \ud835\udd38) : exp \ud835\udd42 (z \u2022 A) = exp \ud835\udd42 A ^ z", "start": [187, 1], "end": [191, 87], "kind": "commanddeclaration"}, {"full_name": "Matrix.exp_conj", "code": "theorem exp_conj (U : Matrix m m \ud835\udd38) (A : Matrix m m \ud835\udd38) (hy : IsUnit U) :\n    exp \ud835\udd42 (U * A * U\u207b\u00b9) = U * exp \ud835\udd42 A * U\u207b\u00b9", "start": [194, 1], "end": [197, 71], "kind": "commanddeclaration"}, {"full_name": "Matrix.exp_conj'", "code": "theorem exp_conj' (U : Matrix m m \ud835\udd38) (A : Matrix m m \ud835\udd38) (hy : IsUnit U) :\n    exp \ud835\udd42 (U\u207b\u00b9 * A * U) = U\u207b\u00b9 * exp \ud835\udd42 A * U", "start": [200, 1], "end": [203, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Order/Hom/Esakia.lean", "imports": ["Mathlib/Order/Hom/Bounded.lean", "Mathlib/Topology/Order/Hom/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PseudoEpimorphism", "code": "structure PseudoEpimorphism (\u03b1 \u03b2 : Type*) [Preorder \u03b1] [Preorder \u03b2] extends \u03b1 \u2192o \u03b2 where\n  exists_map_eq_of_map_le' \u2983a : \u03b1\u2984 \u2983b : \u03b2\u2984 : toFun a \u2264 b \u2192 \u2203 c, a \u2264 c \u2227 toFun c = b", "start": [40, 1], "end": [42, 84], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom", "code": "structure EsakiaHom (\u03b1 \u03b2 : Type*) [TopologicalSpace \u03b1] [Preorder \u03b1] [TopologicalSpace \u03b2]\n  [Preorder \u03b2] extends \u03b1 \u2192Co \u03b2 where\n  exists_map_eq_of_map_le' \u2983a : \u03b1\u2984 \u2983b : \u03b2\u2984 : toFun a \u2264 b \u2192 \u2203 c, a \u2264 c \u2227 toFun c = b", "start": [45, 1], "end": [48, 84], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphismClass", "code": "class PseudoEpimorphismClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Preorder \u03b1] [Preorder \u03b2]\n    extends RelHomClass F ((\u00b7 \u2264 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) ((\u00b7 \u2264 \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop) where\n  exists_map_eq_of_map_le (f : F) \u2983a : \u03b1\u2984 \u2983b : \u03b2\u2984 : f a \u2264 b \u2192 \u2203 c, a \u2264 c \u2227 f c = b", "start": [53, 1], "end": [58, 83], "kind": "commanddeclaration"}, {"full_name": "EsakiaHomClass", "code": "class EsakiaHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [TopologicalSpace \u03b1] [Preorder \u03b1]\n    [TopologicalSpace \u03b2] [Preorder \u03b2] extends ContinuousOrderHomClass F \u03b1 \u03b2 where\n  exists_map_eq_of_map_le (f : F) \u2983a : \u03b1\u2984 \u2983b : \u03b2\u2984 : f a \u2264 b \u2192 \u2203 c, a \u2264 c \u2227 f c = b", "start": [61, 1], "end": [66, 83], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphismClass.toTopHomClass", "code": "instance (priority := 100) PseudoEpimorphismClass.toTopHomClass [PartialOrder \u03b1] [OrderTop \u03b1]\n    [Preorder \u03b2] [OrderTop \u03b2] [PseudoEpimorphismClass F \u03b1 \u03b2] : TopHomClass F \u03b1 \u03b2 where\n  map_top f := by\n    let \u27e8b, h\u27e9 := exists_map_eq_of_map_le f (@le_top _ _ _ <| f \u22a4)\n    rw [\u2190 top_le_iff.1 h.1, h.2]", "start": [74, 1], "end": [78, 33], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toPseudoEpimorphismClass", "code": "instance (priority := 100) OrderIsoClass.toPseudoEpimorphismClass [Preorder \u03b1] [Preorder \u03b2]\n    [OrderIsoClass F \u03b1 \u03b2] : PseudoEpimorphismClass F \u03b1 \u03b2 where\n  exists_map_eq_of_map_le f _a b h :=\n    \u27e8EquivLike.inv f b, (le_map_inv_iff f).2 h, EquivLike.right_inv _ _\u27e9", "start": [82, 1], "end": [85, 73], "kind": "commanddeclaration"}, {"full_name": "EsakiaHomClass.toPseudoEpimorphismClass", "code": "instance (priority := 100) EsakiaHomClass.toPseudoEpimorphismClass [TopologicalSpace \u03b1] [Preorder \u03b1]\n    [TopologicalSpace \u03b2] [Preorder \u03b2] [EsakiaHomClass F \u03b1 \u03b2] : PseudoEpimorphismClass F \u03b1 \u03b2 :=\n  { \u2039EsakiaHomClass F \u03b1 \u03b2\u203a with\n    map_rel := ContinuousOrderHomClass.map_monotone }", "start": [89, 1], "end": [92, 54], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.toOrderHom_eq_coe", "code": "@[simp]\ntheorem toOrderHom_eq_coe (f : PseudoEpimorphism \u03b1 \u03b2) : \u21d1f.toOrderHom = f", "start": [124, 1], "end": [125, 81], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.toFun_eq_coe", "code": "theorem toFun_eq_coe {f : PseudoEpimorphism \u03b1 \u03b2} : f.toFun = (f : \u03b1 \u2192 \u03b2)", "start": [127, 1], "end": [127, 80], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.ext", "code": "@[ext]\ntheorem ext {f g : PseudoEpimorphism \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [130, 1], "end": [132, 20], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.copy", "code": "protected def copy (f : PseudoEpimorphism \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : PseudoEpimorphism \u03b1 \u03b2 :=\n  \u27e8f.toOrderHom.copy f' h, by simpa only [h.symm, toFun_eq_coe] using f.exists_map_eq_of_map_le'\u27e9", "start": [135, 1], "end": [138, 98], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : PseudoEpimorphism \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [141, 1], "end": [142, 100], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.copy_eq", "code": "theorem copy_eq (f : PseudoEpimorphism \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [145, 1], "end": [146, 17], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.id", "code": "protected def id : PseudoEpimorphism \u03b1 \u03b1 :=\n  \u27e8OrderHom.id, fun _ b h => \u27e8b, h, rfl\u27e9\u27e9", "start": [151, 1], "end": [153, 42], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(PseudoEpimorphism.id \u03b1) = id", "start": [159, 1], "end": [160, 55], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.coe_id_orderHom", "code": "@[simp]\ntheorem coe_id_orderHom : (PseudoEpimorphism.id \u03b1 : \u03b1 \u2192o \u03b1) = OrderHom.id", "start": [163, 1], "end": [164, 81], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : PseudoEpimorphism.id \u03b1 a = a", "start": [169, 1], "end": [170, 63], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.comp", "code": "def comp (g : PseudoEpimorphism \u03b2 \u03b3) (f : PseudoEpimorphism \u03b1 \u03b2) : PseudoEpimorphism \u03b1 \u03b3 :=\n  \u27e8g.toOrderHom.comp f.toOrderHom, fun a b h\u2080 => by\n    obtain \u27e8b, h\u2081, rfl\u27e9 := g.exists_map_eq_of_map_le' h\u2080\n    obtain \u27e8b, h\u2082, rfl\u27e9 := f.exists_map_eq_of_map_le' h\u2081\n    exact \u27e8b, h\u2082, rfl\u27e9\u27e9", "start": [173, 1], "end": [178, 24], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.coe_comp", "code": "@[simp]\ntheorem coe_comp (g : PseudoEpimorphism \u03b2 \u03b3) (f : PseudoEpimorphism \u03b1 \u03b2) :\n    (g.comp f : \u03b1 \u2192 \u03b3) = g \u2218 f", "start": [181, 1], "end": [183, 38], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.coe_comp_orderHom", "code": "@[simp]\ntheorem coe_comp_orderHom (g : PseudoEpimorphism \u03b2 \u03b3) (f : PseudoEpimorphism \u03b1 \u03b2) :\n    (g.comp f : \u03b1 \u2192o \u03b3) = (g : \u03b2 \u2192o \u03b3).comp f", "start": [186, 1], "end": [188, 53], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.comp_apply", "code": "@[simp]\ntheorem comp_apply (g : PseudoEpimorphism \u03b2 \u03b3) (f : PseudoEpimorphism \u03b1 \u03b2) (a : \u03b1) :\n    (g.comp f) a = g (f a)", "start": [191, 1], "end": [193, 34], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (h : PseudoEpimorphism \u03b3 \u03b4) (g : PseudoEpimorphism \u03b2 \u03b3)\n    (f : PseudoEpimorphism \u03b1 \u03b2) : (h.comp g).comp f = h.comp (g.comp f)", "start": [196, 1], "end": [198, 79], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.comp_id", "code": "@[simp]\ntheorem comp_id (f : PseudoEpimorphism \u03b1 \u03b2) : f.comp (PseudoEpimorphism.id \u03b1) = f", "start": [201, 1], "end": [203, 19], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.id_comp", "code": "@[simp]\ntheorem id_comp (f : PseudoEpimorphism \u03b1 \u03b2) : (PseudoEpimorphism.id \u03b2).comp f = f", "start": [206, 1], "end": [208, 19], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : PseudoEpimorphism \u03b2 \u03b3} {f : PseudoEpimorphism \u03b1 \u03b2}\n    (hf : Surjective f) : g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [211, 1], "end": [214, 77], "kind": "commanddeclaration"}, {"full_name": "PseudoEpimorphism.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : PseudoEpimorphism \u03b2 \u03b3} {f\u2081 f\u2082 : PseudoEpimorphism \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [217, 1], "end": [220, 81], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.toPseudoEpimorphism", "code": "def toPseudoEpimorphism (f : EsakiaHom \u03b1 \u03b2) : PseudoEpimorphism \u03b1 \u03b2 :=\n  { f with }", "start": [233, 1], "end": [234, 13], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.toContinuousOrderHom_coe", "code": "@[simp]\ntheorem toContinuousOrderHom_coe {f : EsakiaHom \u03b1 \u03b2} :\n    f.toContinuousOrderHom = (f : \u03b1 \u2192 \u03b2)", "start": [253, 1], "end": [255, 48], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.toFun_eq_coe", "code": "theorem toFun_eq_coe {f : EsakiaHom \u03b1 \u03b2} : f.toFun = (f : \u03b1 \u2192 \u03b2)", "start": [258, 1], "end": [258, 72], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.ext", "code": "@[ext]\ntheorem ext {f g : EsakiaHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [261, 1], "end": [263, 20], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.copy", "code": "protected def copy (f : EsakiaHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : EsakiaHom \u03b1 \u03b2 :=\n  \u27e8f.toContinuousOrderHom.copy f' h, by\n    simpa only [h.symm, toFun_eq_coe] using f.exists_map_eq_of_map_le'\u27e9", "start": [266, 1], "end": [270, 72], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : EsakiaHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [273, 1], "end": [274, 92], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.copy_eq", "code": "theorem copy_eq (f : EsakiaHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [277, 1], "end": [278, 17], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.id", "code": "protected def id : EsakiaHom \u03b1 \u03b1 :=\n  \u27e8ContinuousOrderHom.id \u03b1, fun _ b h => \u27e8b, h, rfl\u27e9\u27e9", "start": [283, 1], "end": [285, 54], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(EsakiaHom.id \u03b1) = id", "start": [291, 1], "end": [292, 47], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.coe_id_pseudoEpimorphism", "code": "@[simp]\ntheorem coe_id_pseudoEpimorphism :\n    (EsakiaHom.id \u03b1 : PseudoEpimorphism \u03b1 \u03b1) = PseudoEpimorphism.id \u03b1", "start": [295, 1], "end": [297, 77], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : EsakiaHom.id \u03b1 a = a", "start": [302, 1], "end": [303, 55], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.coe_id_continuousOrderHom", "code": "@[simp]\ntheorem coe_id_continuousOrderHom : (EsakiaHom.id \u03b1 : \u03b1 \u2192Co \u03b1) = ContinuousOrderHom.id \u03b1", "start": [306, 1], "end": [307, 96], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.comp", "code": "def comp (g : EsakiaHom \u03b2 \u03b3) (f : EsakiaHom \u03b1 \u03b2) : EsakiaHom \u03b1 \u03b3 :=\n  \u27e8g.toContinuousOrderHom.comp f.toContinuousOrderHom, fun a b h\u2080 => by\n    obtain \u27e8b, h\u2081, rfl\u27e9 := g.exists_map_eq_of_map_le' h\u2080\n    obtain \u27e8b, h\u2082, rfl\u27e9 := f.exists_map_eq_of_map_le' h\u2081\n    exact \u27e8b, h\u2082, rfl\u27e9\u27e9", "start": [310, 1], "end": [315, 24], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.coe_comp_continuousOrderHom", "code": "@[simp]\ntheorem coe_comp_continuousOrderHom (g : EsakiaHom \u03b2 \u03b3) (f : EsakiaHom \u03b1 \u03b2) :\n    (g.comp f : \u03b1 \u2192Co \u03b3) = (g: \u03b2 \u2192Co \u03b3).comp f", "start": [318, 1], "end": [320, 54], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.coe_comp_pseudoEpimorphism", "code": "@[simp]\ntheorem coe_comp_pseudoEpimorphism (g : EsakiaHom \u03b2 \u03b3) (f : EsakiaHom \u03b1 \u03b2) :\n    (g.comp f : PseudoEpimorphism \u03b1 \u03b3) = (g : PseudoEpimorphism \u03b2 \u03b3).comp f", "start": [323, 1], "end": [325, 83], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (g : EsakiaHom \u03b2 \u03b3) (f : EsakiaHom \u03b1 \u03b2) : (g.comp f : \u03b1 \u2192 \u03b3) = g \u2218 f", "start": [328, 1], "end": [329, 93], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (g : EsakiaHom \u03b2 \u03b3) (f : EsakiaHom \u03b1 \u03b2) (a : \u03b1) : (g.comp f) a = g (f a)", "start": [332, 1], "end": [333, 99], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (h : EsakiaHom \u03b3 \u03b4) (g : EsakiaHom \u03b2 \u03b3) (f : EsakiaHom \u03b1 \u03b2) :\n    (h.comp g).comp f = h.comp (g.comp f)", "start": [336, 1], "end": [338, 49], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : EsakiaHom \u03b1 \u03b2) : f.comp (EsakiaHom.id \u03b1) = f", "start": [341, 1], "end": [343, 19], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : EsakiaHom \u03b1 \u03b2) : (EsakiaHom.id \u03b2).comp f = f", "start": [346, 1], "end": [348, 19], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : EsakiaHom \u03b2 \u03b3} {f : EsakiaHom \u03b1 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [351, 1], "end": [354, 77], "kind": "commanddeclaration"}, {"full_name": "EsakiaHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : EsakiaHom \u03b2 \u03b3} {f\u2081 f\u2082 : EsakiaHom \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [357, 1], "end": [360, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Algebra/Subalgebra/Unitization.lean", "imports": ["Mathlib/Algebra/Algebra/Unitization.lean", "Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean", "Mathlib/Algebra/Star/NonUnitalSubalgebra.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Star/Subalgebra.lean"], "premises": [{"full_name": "Subalgebra.toNonUnitalSubalgebra", "code": "def Subalgebra.toNonUnitalSubalgebra (S : Subalgebra R A) : NonUnitalSubalgebra R A :=\n  { S with\n    smul_mem' := fun r _x hx => S.smul_mem hx r }", "start": [54, 1], "end": [57, 50], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.one_mem_toNonUnitalSubalgebra", "code": "theorem Subalgebra.one_mem_toNonUnitalSubalgebra (S : Subalgebra R A) :\n    (1 : A) \u2208 S.toNonUnitalSubalgebra", "start": [59, 1], "end": [61, 12], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toSubalgebra", "code": "def NonUnitalSubalgebra.toSubalgebra (S : NonUnitalSubalgebra R A) (h1 : (1 : A) \u2208 S) :\n    Subalgebra R A :=\n  { S with\n    one_mem' := h1\n    algebraMap_mem' := fun r =>\n      (Algebra.algebraMap_eq_smul_one (R := R) (A := A) r).symm \u25b8 SMulMemClass.smul_mem r h1 }", "start": [63, 1], "end": [69, 95], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toNonUnitalSubalgebra_toSubalgebra", "code": "theorem Subalgebra.toNonUnitalSubalgebra_toSubalgebra (S : Subalgebra R A) :\n    S.toNonUnitalSubalgebra.toSubalgebra S.one_mem = S", "start": [71, 1], "end": [72, 74], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toSubalgebra_toNonUnitalSubalgebra", "code": "theorem NonUnitalSubalgebra.toSubalgebra_toNonUnitalSubalgebra (S : NonUnitalSubalgebra R A)\n    (h1 : (1 : A) \u2208 S) : (NonUnitalSubalgebra.toSubalgebra S h1).toNonUnitalSubalgebra = S", "start": [74, 1], "end": [76, 15], "kind": "commanddeclaration"}, {"full_name": "Unitization.lift_range_le", "code": "theorem lift_range_le {f : A \u2192\u2099\u2090[R] C} {S : Subalgebra R C} :\n    (lift f).range \u2264 S \u2194 NonUnitalAlgHom.range f \u2264 S.toNonUnitalSubalgebra", "start": [85, 1], "end": [92, 69], "kind": "commanddeclaration"}, {"full_name": "Unitization.lift_range", "code": "theorem lift_range (f : A \u2192\u2099\u2090[R] C) :\n    (lift f).range = Algebra.adjoin R (NonUnitalAlgHom.range f : Set C)", "start": [94, 1], "end": [96, 80], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.unitization", "code": "def unitization : Unitization R s \u2192\u2090[R] A :=\n  Unitization.lift (NonUnitalSubalgebraClass.subtype s)", "start": [107, 1], "end": [110, 56], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.unitization_apply", "code": "@[simp]\ntheorem unitization_apply (x : Unitization R s) :\n    unitization s x = algebraMap R A x.fst + x.snd", "start": [112, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.unitization_range", "code": "theorem unitization_range : (unitization s).range = Algebra.adjoin R (s : Set A)", "start": [117, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHomClass.unitization_injective'", "code": "theorem _root_.AlgHomClass.unitization_injective' {F R S A : Type*} [CommRing R] [Ring A]\n    [Algebra R A] [SetLike S A] [hSA : NonUnitalSubringClass S A] [hSRA : SMulMemClass S R A]\n    (s : S) (h : \u2200 r, r \u2260 0 \u2192 algebraMap R A r \u2209 s) [AlgHomClass F R (Unitization R s) A] (f : F)\n    (hf : \u2200 x : s, f x = x) : Function.Injective f", "start": [125, 1], "end": [139, 53], "kind": "commanddeclaration"}, {"full_name": "AlgHomClass.unitization_injective", "code": "theorem _root_.AlgHomClass.unitization_injective {F R S A : Type*} [Field R] [Ring A]\n    [Algebra R A] [SetLike S A] [hSA : NonUnitalSubringClass S A] [hSRA : SMulMemClass S R A]\n    (s : S) (h1 : 1 \u2209 s) [AlgHomClass F R (Unitization R s) A] (f : F)\n    (hf : \u2200 x : s, f x = x) : Function.Injective f", "start": [141, 1], "end": [149, 72], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.unitization_injective", "code": "theorem unitization_injective (h1 : (1 : A) \u2209 s) : Function.Injective (unitization s)", "start": [156, 1], "end": [157, 73], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.unitizationAlgEquiv", "code": "@[simps! apply_coe]\nnoncomputable def unitizationAlgEquiv (h1 : (1 : A) \u2209 s) :\n    Unitization R s \u2243\u2090[R] Algebra.adjoin R (s : Set A) :=\n  let algHom : Unitization R s \u2192\u2090[R] Algebra.adjoin R (s : Set A) :=\n    ((unitization s).codRestrict _\n      fun x \u21a6 (unitization_range s).le <| AlgHom.mem_range_self _ x)\n  AlgEquiv.ofBijective algHom <| by\n    refine \u27e8?_, fun x \u21a6 ?_\u27e9\n    \u00b7 have := AlgHomClass.unitization_injective s h1\n        ((Subalgebra.val _).comp algHom) fun _ \u21a6 by simp\n      rw [AlgHom.coe_comp] at this\n      exact this.of_comp\n    \u00b7 obtain (\u27e8a, ha\u27e9 : (x : A) \u2208 (unitization s).range) :=\n        (unitization_range s).ge x.property\n      exact \u27e8a, Subtype.ext ha\u27e9", "start": [159, 1], "end": [175, 32], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toNonUnitalSubsemiring", "code": "def Subsemiring.toNonUnitalSubsemiring (S : Subsemiring R) : NonUnitalSubsemiring R :=\n  { S with }", "start": [187, 1], "end": [189, 13], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.one_mem_toNonUnitalSubsemiring", "code": "theorem Subsemiring.one_mem_toNonUnitalSubsemiring (S : Subsemiring R) :\n    (1 : R) \u2208 S.toNonUnitalSubsemiring", "start": [191, 1], "end": [193, 12], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubsemiring.toSubsemiring", "code": "def NonUnitalSubsemiring.toSubsemiring (S : NonUnitalSubsemiring R) (h1 : (1 : R) \u2208 S) :\n    Subsemiring R :=\n  { S with\n    one_mem' := h1 }", "start": [195, 1], "end": [199, 21], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toNonUnitalSubsemiring_toSubsemiring", "code": "theorem Subsemiring.toNonUnitalSubsemiring_toSubsemiring (S : Subsemiring R) :\n    S.toNonUnitalSubsemiring.toSubsemiring S.one_mem = S", "start": [201, 1], "end": [202, 76], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubsemiring.toSubsemiring_toNonUnitalSubsemiring", "code": "theorem NonUnitalSubsemiring.toSubsemiring_toNonUnitalSubsemiring (S : NonUnitalSubsemiring R)\n    (h1 : (1 : R) \u2208 S) : (NonUnitalSubsemiring.toSubsemiring S h1).toNonUnitalSubsemiring = S", "start": [204, 1], "end": [206, 15], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubsemiring.unitization", "code": "def unitization : Unitization \u2115 s \u2192\u2090[\u2115] R :=\n  NonUnitalSubalgebra.unitization (hSRA := AddSubmonoidClass.nsmulMemClass) s", "start": [214, 1], "end": [217, 78], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubsemiring.unitization_apply", "code": "@[simp]\ntheorem unitization_apply (x : Unitization \u2115 s) : unitization s x = x.fst + x.snd", "start": [219, 1], "end": [221, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubsemiring.unitization_range", "code": "theorem unitization_range :\n    (unitization s).range = subalgebraOfSubsemiring (Subsemiring.closure s)", "start": [223, 1], "end": [226, 93], "kind": "commanddeclaration"}, {"full_name": "Subring.toNonUnitalSubring", "code": "def Subring.toNonUnitalSubring (S : Subring R) : NonUnitalSubring R :=\n  { S with }", "start": [237, 1], "end": [239, 13], "kind": "commanddeclaration"}, {"full_name": "Subring.one_mem_toNonUnitalSubring", "code": "theorem Subring.one_mem_toNonUnitalSubring (S : Subring R) : (1 : R) \u2208 S.toNonUnitalSubring", "start": [241, 1], "end": [242, 12], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.toSubring", "code": "def NonUnitalSubring.toSubring (S : NonUnitalSubring R) (h1 : (1 : R) \u2208 S) : Subring R :=\n  { S with\n    one_mem' := h1 }", "start": [244, 1], "end": [247, 21], "kind": "commanddeclaration"}, {"full_name": "Subring.toNonUnitalSubring_toSubring", "code": "theorem Subring.toNonUnitalSubring_toSubring (S : Subring R) :\n    S.toNonUnitalSubring.toSubring S.one_mem = S", "start": [249, 1], "end": [250, 68], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.toSubring_toNonUnitalSubring", "code": "theorem NonUnitalSubring.toSubring_toNonUnitalSubring (S : NonUnitalSubring R) (h1 : (1 : R) \u2208 S) :\n    (NonUnitalSubring.toSubring S h1).toNonUnitalSubring = S", "start": [252, 1], "end": [253, 80], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.unitization", "code": "def unitization : Unitization \u2124 s \u2192\u2090[\u2124] R :=\n  NonUnitalSubalgebra.unitization (hSRA := AddSubgroupClass.zsmulMemClass) s", "start": [261, 1], "end": [264, 77], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.unitization_apply", "code": "@[simp]\ntheorem unitization_apply (x : Unitization \u2124 s) : unitization s x = x.fst + x.snd", "start": [266, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.unitization_range", "code": "theorem unitization_range :\n    (unitization s).range = subalgebraOfSubring (Subring.closure s)", "start": [270, 1], "end": [273, 93], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.toNonUnitalStarSubalgebra", "code": "def StarSubalgebra.toNonUnitalStarSubalgebra (S : StarSubalgebra R A) :\n    NonUnitalStarSubalgebra R A :=\n  { S with\n    carrier := S.carrier\n    smul_mem' := fun r _x hx => S.smul_mem hx r }", "start": [284, 1], "end": [289, 50], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.one_mem_toNonUnitalStarSubalgebra", "code": "theorem StarSubalgebra.one_mem_toNonUnitalStarSubalgebra (S : StarSubalgebra R A) :\n    (1 : A) \u2208 S.toNonUnitalStarSubalgebra", "start": [291, 1], "end": [293, 13], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toStarSubalgebra", "code": "def NonUnitalStarSubalgebra.toStarSubalgebra (S : NonUnitalStarSubalgebra R A) (h1 : (1 : A) \u2208 S) :\n    StarSubalgebra R A :=\n  { S with\n    carrier := S.carrier\n    one_mem' := h1\n    algebraMap_mem' := fun r =>\n      (Algebra.algebraMap_eq_smul_one (R := R) (A := A) r).symm \u25b8 SMulMemClass.smul_mem r h1 }", "start": [295, 1], "end": [302, 95], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.toNonUnitalStarSubalgebra_toStarSubalgebra", "code": "theorem StarSubalgebra.toNonUnitalStarSubalgebra_toStarSubalgebra (S : StarSubalgebra R A) :\n    S.toNonUnitalStarSubalgebra.toStarSubalgebra S.one_mem' = S", "start": [304, 1], "end": [305, 83], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toStarSubalgebra_toNonUnitalStarSubalgebra", "code": "theorem NonUnitalStarSubalgebra.toStarSubalgebra_toNonUnitalStarSubalgebra\n    (S : NonUnitalStarSubalgebra R A) (h1 : (1 : A) \u2208 S) :\n    (S.toStarSubalgebra h1).toNonUnitalStarSubalgebra = S", "start": [307, 1], "end": [310, 15], "kind": "commanddeclaration"}, {"full_name": "Unitization.starLift_range_le", "code": "theorem starLift_range_le\n    {f : A \u2192\u22c6\u2099\u2090[R] C} {S : StarSubalgebra R C} :\n    (starLift f).range \u2264 S \u2194 NonUnitalStarAlgHom.range f \u2264 S.toNonUnitalStarSubalgebra", "start": [320, 1], "end": [328, 69], "kind": "commanddeclaration"}, {"full_name": "Unitization.starLift_range", "code": "theorem starLift_range (f : A \u2192\u22c6\u2099\u2090[R] C) :\n    (starLift f).range = StarSubalgebra.adjoin R (NonUnitalStarAlgHom.range f : Set C)", "start": [330, 1], "end": [334, 8], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.unitization", "code": "def unitization : Unitization R s \u2192\u22c6\u2090[R] A :=\n  Unitization.starLift <| NonUnitalStarSubalgebraClass.subtype s", "start": [345, 1], "end": [348, 65], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.unitization_apply", "code": "@[simp]\ntheorem unitization_apply (x : Unitization R s) : unitization s x = algebraMap R A x.fst + x.snd", "start": [350, 1], "end": [352, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.unitization_range", "code": "theorem unitization_range : (unitization s).range = StarSubalgebra.adjoin R s", "start": [354, 1], "end": [358, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.unitization_injective", "code": "theorem unitization_injective (h1 : (1 : A) \u2209 s) : Function.Injective (unitization s)", "start": [368, 1], "end": [369, 73], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.unitizationStarAlgEquiv", "code": "@[simps! apply_coe]\nnoncomputable def unitizationStarAlgEquiv (h1 : (1 : A) \u2209 s) :\n    Unitization R s \u2243\u22c6\u2090[R] StarSubalgebra.adjoin R (s : Set A) :=\n  let starAlgHom : Unitization R s \u2192\u22c6\u2090[R] StarSubalgebra.adjoin R (s : Set A) :=\n    ((unitization s).codRestrict _\n      fun x \u21a6 (unitization_range s).le <| Set.mem_range_self x)\n  StarAlgEquiv.ofBijective starAlgHom <| by\n    refine \u27e8?_, fun x \u21a6 ?_\u27e9\n    \u00b7 have := AlgHomClass.unitization_injective s h1 ((StarSubalgebra.subtype _).comp starAlgHom)\n        fun _ \u21a6 by simp\n      rw [StarAlgHom.coe_comp] at this\n      exact this.of_comp\n    \u00b7 obtain (\u27e8a, ha\u27e9 : (x : A) \u2208 (unitization s).range) :=\n        (unitization_range s).ge x.property\n      exact \u27e8a, Subtype.ext ha\u27e9", "start": [371, 1], "end": [387, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Finsubgraph.lean", "imports": ["Mathlib/CategoryTheory/CofilteredSystem.lean", "Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.Finsubgraph", "code": "abbrev Finsubgraph (G : SimpleGraph V) :=\n  { G' : G.Subgraph // G'.verts.Finite }", "start": [44, 1], "end": [46, 41], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.FinsubgraphHom", "code": "abbrev FinsubgraphHom (G' : G.Finsubgraph) (F : SimpleGraph W) :=\n  G'.val.coe \u2192g F", "start": [49, 1], "end": [51, 18], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.singletonFinsubgraph", "code": "def singletonFinsubgraph (v : V) : G.Finsubgraph :=\n  \u27e8SimpleGraph.singletonSubgraph _ v, by simp\u27e9", "start": [82, 1], "end": [84, 47], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.finsubgraphOfAdj", "code": "def finsubgraphOfAdj {u v : V} (e : G.Adj u v) : G.Finsubgraph :=\n  \u27e8SimpleGraph.subgraphOfAdj _ e, by simp\u27e9", "start": [87, 1], "end": [89, 43], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.singletonFinsubgraph_le_adj_left", "code": "theorem singletonFinsubgraph_le_adj_left {u v : V} {e : G.Adj u v} :\n    singletonFinsubgraph u \u2264 finsubgraphOfAdj e", "start": [93, 1], "end": [95, 48], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.singletonFinsubgraph_le_adj_right", "code": "theorem singletonFinsubgraph_le_adj_right {u v : V} {e : G.Adj u v} :\n    singletonFinsubgraph v \u2264 finsubgraphOfAdj e", "start": [98, 1], "end": [100, 48], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.FinsubgraphHom.restrict", "code": "def FinsubgraphHom.restrict {G' G'' : G.Finsubgraph} (h : G'' \u2264 G') (f : G' \u2192fg F) : G'' \u2192fg F := by\n  refine' \u27e8fun \u27e8v, hv\u27e9 => f.toFun \u27e8v, h.1 hv\u27e9, _\u27e9\n  rintro \u27e8u, hu\u27e9 \u27e8v, hv\u27e9 huv\n  exact f.map_rel' (h.2 huv)", "start": [103, 1], "end": [107, 29], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.finsubgraphHomFunctor", "code": "def finsubgraphHomFunctor (G : SimpleGraph V) (F : SimpleGraph W) : G.Finsubgraph\u1d52\u1d56 \u2964 Type max u v\n    where\n  obj G' := G'.unop \u2192fg F\n  map g f := f.restrict (CategoryTheory.leOfHom g.unop)", "start": [110, 1], "end": [114, 56], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.nonempty_hom_of_forall_finite_subgraph_hom", "code": "theorem nonempty_hom_of_forall_finite_subgraph_hom [Finite W]\n    (h : \u2200 G' : G.Subgraph, G'.verts.Finite \u2192 G'.coe \u2192g F) : Nonempty (G \u2192g F)", "start": [117, 1], "end": [153, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/Flip.lean", "imports": ["Mathlib/Algebra/Homology/HomologicalComplex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HomologicalComplex.flipObj", "code": "@[simps]\ndef flipObj (C : HomologicalComplex (HomologicalComplex V c) c') :\n    HomologicalComplex (HomologicalComplex V c') c where\n  X i :=\n    { X := fun j => (C.X j).X i\n      d := fun j j' => (C.d j j').f i\n      shape := fun j j' w => by\n        simp_all only [shape, zero_f]\n      d_comp_d' := fun j\u2081 j\u2082 j\u2083 _ _ => congr_hom (C.d_comp_d j\u2081 j\u2082 j\u2083) i }\n  d i i' :=\n    { f := fun j => (C.X j).d i i'\n      comm' := fun j j' _ => ((C.d j j').comm i i').symm }\n  shape i i' w := by\n    ext j\n    exact (C.X j).shape i i' w", "start": [32, 1], "end": [49, 31], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.flip", "code": "@[simps]\ndef flip :\n    HomologicalComplex (HomologicalComplex V c) c' \u2964 HomologicalComplex (HomologicalComplex V c') c\n    where\n  obj C := flipObj C\n  map {C D} f :=\n    { f := fun i =>\n        { f := fun j => (f.f j).f i\n          comm' := fun j j' _ => congr_hom (f.comm j j') i } }", "start": [54, 1], "end": [63, 63], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.flipEquivalenceUnitIso", "code": "@[simps!]\ndef flipEquivalenceUnitIso :\n    \ud835\udfed (HomologicalComplex (HomologicalComplex V c) c') \u2245 flip V c c' \u22d9 flip V c' c :=\n  NatIso.ofComponents\n    (fun C =>\n      { hom :=\n          { f := fun i => { f := fun j => \ud835\udfd9 ((C.X i).X j) }\n            comm' := fun i j _ => by\n              ext\n              dsimp\n              simp only [Category.id_comp, Category.comp_id] }\n        inv :=\n          { f := fun i => { f := fun j => \ud835\udfd9 ((C.X i).X j) }\n            comm' := fun i j _ => by\n              ext\n              dsimp\n              simp only [Category.id_comp, Category.comp_id] } })\n    fun {X Y} f => by\n      ext\n      dsimp\n      simp only [Category.id_comp, Category.comp_id]", "start": [66, 1], "end": [87, 53], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.flipEquivalenceCounitIso", "code": "@[simps!]\ndef flipEquivalenceCounitIso :\n    flip V c' c \u22d9 flip V c c' \u2245 \ud835\udfed (HomologicalComplex (HomologicalComplex V c') c) :=\n  NatIso.ofComponents\n    (fun C =>\n      { hom :=\n          { f := fun i => { f := fun j => \ud835\udfd9 ((C.X i).X j) }\n            comm' := fun i j _ => by\n              ext\n              dsimp\n              simp only [Category.id_comp, Category.comp_id] }\n        inv :=\n          { f := fun i => { f := fun j => \ud835\udfd9 ((C.X i).X j) }\n            comm' := fun i j _ => by\n              ext\n              dsimp\n              simp only [Category.id_comp, Category.comp_id] } })\n    fun {X Y} f => by\n      ext\n      dsimp\n      simp only [Category.id_comp, Category.comp_id]", "start": [90, 1], "end": [111, 53], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.flipEquivalence", "code": "@[simps]\ndef flipEquivalence :\n    HomologicalComplex (HomologicalComplex V c) c' \u224c HomologicalComplex (HomologicalComplex V c') c\n    where\n  functor := flip V c c'\n  inverse := flip V c' c\n  unitIso := flipEquivalenceUnitIso V c c'\n  counitIso := flipEquivalenceCounitIso V c c'", "start": [114, 1], "end": [122, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Bimodule.lean", "imports": ["Mathlib/RingTheory/TensorProduct.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subbimodule.mk", "code": "@[simps]\ndef mk (p : AddSubmonoid M) (hA : \u2200 (a : A) {m : M}, m \u2208 p \u2192 a \u2022 m \u2208 p)\n    (hB : \u2200 (b : B) {m : M}, m \u2208 p \u2192 b \u2022 m \u2208 p) : Submodule (A \u2297[R] B) M :=\n  { p with\n    carrier := p\n    smul_mem' := fun ab m =>\n      TensorProduct.induction_on ab (fun _ => by simpa only [zero_smul] using p.zero_mem)\n        (fun a b hm => by simpa only [TensorProduct.Algebra.smul_def] using hA a (hB b hm))\n        fun z w hz hw hm => by simpa only [add_smul] using p.add_mem (hz hm) (hw hm) }", "start": [79, 1], "end": [92, 87], "kind": "commanddeclaration"}, {"full_name": "Subbimodule.smul_mem", "code": "theorem smul_mem (p : Submodule (A \u2297[R] B) M) (a : A) {m : M} (hm : m \u2208 p) : a \u2022 m \u2208 p", "start": [95, 1], "end": [97, 40], "kind": "commanddeclaration"}, {"full_name": "Subbimodule.smul_mem'", "code": "theorem smul_mem' (p : Submodule (A \u2297[R] B) M) (b : B) {m : M} (hm : m \u2208 p) : b \u2022 m \u2208 p", "start": [100, 1], "end": [102, 40], "kind": "commanddeclaration"}, {"full_name": "Subbimodule.baseChange", "code": "@[simps!]\ndef baseChange (S : Type*) [CommSemiring S] [Module S M] [Algebra S A] [Algebra S B]\n    [IsScalarTower S A M] [IsScalarTower S B M] (p : Submodule (A \u2297[R] B) M) :\n    Submodule (A \u2297[S] B) M :=\n  mk p.toAddSubmonoid (smul_mem p) (smul_mem' p)", "start": [105, 1], "end": [111, 49], "kind": "commanddeclaration"}, {"full_name": "Subbimodule.toSubmodule", "code": "@[simps]\ndef toSubmodule (p : Submodule (A \u2297[R] B) M) : Submodule A M :=\n  { p with\n    carrier := p\n    smul_mem' := smul_mem p }", "start": [114, 1], "end": [119, 30], "kind": "commanddeclaration"}, {"full_name": "Subbimodule.toSubmodule'", "code": "@[simps]\ndef toSubmodule' (p : Submodule (A \u2297[R] B) M) : Submodule B M :=\n  { p with\n    carrier := p\n    smul_mem' := smul_mem' p }", "start": [122, 1], "end": [127, 31], "kind": "commanddeclaration"}, {"full_name": "Subbimodule.toSubbimoduleInt", "code": "@[simps!]\ndef toSubbimoduleInt (p : Submodule (R \u2297[\u2115] S) M) : Submodule (R \u2297[\u2124] S) M :=\n  baseChange \u2124 p", "start": [138, 1], "end": [142, 17], "kind": "commanddeclaration"}, {"full_name": "Subbimodule.toSubbimoduleNat", "code": "@[simps!]\ndef toSubbimoduleNat (p : Submodule (R \u2297[\u2124] S) M) : Submodule (R \u2297[\u2115] S) M :=\n  baseChange \u2115 p", "start": [145, 1], "end": [149, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Ordinal/Notation.lean", "imports": ["Mathlib/SetTheory/Ordinal/Principal.lean", "Mathlib/Init/Data/Ordering/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ONote", "code": "inductive ONote : Type\n  | zero : ONote\n  | oadd : ONote \u2192 \u2115+ \u2192 ONote \u2192 ONote\n  deriving DecidableEq", "start": [33, 1], "end": [41, 23], "kind": "commanddeclaration"}, {"full_name": "ONote.zero_def", "code": "@[simp]\ntheorem zero_def : zero = 0", "start": [52, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "ONote.omega", "code": "def omega : ONote :=\n  oadd 1 1 0", "start": [64, 1], "end": [66, 13], "kind": "commanddeclaration"}, {"full_name": "ONote.repr", "code": "@[simp]\nnoncomputable def repr : ONote \u2192 Ordinal.{0}\n  | 0 => 0\n  | oadd e n a => \u03c9 ^ repr e * n + repr a", "start": [69, 1], "end": [73, 42], "kind": "commanddeclaration"}, {"full_name": "ONote.toStringAux1", "code": "def toStringAux1 (e : ONote) (n : \u2115) (s : String) : String :=\n  if e = 0 then toString n\n  else (if e = 1 then \"\u03c9\" else \"\u03c9^(\" ++ s ++ \")\") ++ if n = 1 then \"\" else \"*\" ++ toString n", "start": [76, 1], "end": [79, 93], "kind": "commanddeclaration"}, {"full_name": "ONote.toString", "code": "def toString : ONote \u2192 String\n  | zero => \"0\"\n  | oadd e n 0 => toStringAux1 e n (toString e)\n  | oadd e n a => toStringAux1 e n (toString e) ++ \" + \" ++ toString a", "start": [82, 1], "end": [86, 71], "kind": "commanddeclaration"}, {"full_name": "ONote.repr'", "code": "def repr' (prec : \u2115) : ONote \u2192 Format\n  | zero => \"0\"\n  | oadd e n a =>\n    Repr.addAppParen\n      (\"oadd \" ++ (repr' max_prec e) ++ \" \" ++ Nat.repr (n : \u2115) ++ \" \" ++ (repr' max_prec a))\n      prec", "start": [90, 1], "end": [96, 11], "kind": "commanddeclaration"}, {"full_name": "ONote.lt_def", "code": "theorem lt_def {x y : ONote} : x < y \u2194 repr x < repr y", "start": [112, 1], "end": [113, 10], "kind": "commanddeclaration"}, {"full_name": "ONote.le_def", "code": "theorem le_def {x y : ONote} : x \u2264 y \u2194 repr x \u2264 repr y", "start": [116, 1], "end": [117, 10], "kind": "commanddeclaration"}, {"full_name": "ONote.ofNat", "code": "@[coe]\ndef ofNat : \u2115 \u2192 ONote\n  | 0 => 0\n  | Nat.succ n => oadd 0 n.succPNat 0", "start": [123, 1], "end": [127, 38], "kind": "commanddeclaration"}, {"full_name": "ONote.ofNat_zero", "code": "theorem ofNat_zero : ofNat 0 = 0", "start": [132, 1], "end": [133, 6], "kind": "commanddeclaration"}, {"full_name": "ONote.ofNat_succ", "code": "theorem ofNat_succ (n) : ofNat (Nat.succ n) = oadd 0 n.succPNat 0", "start": [135, 1], "end": [136, 6], "kind": "commanddeclaration"}, {"full_name": "ONote.nat", "code": "instance nat (n : \u2115) : OfNat ONote n where\n  ofNat := ofNat n", "start": [142, 1], "end": [143, 19], "kind": "commanddeclaration"}, {"full_name": "ONote.ofNat_one", "code": "@[simp 1200]\ntheorem ofNat_one : ofNat 1 = 1", "start": [145, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "ONote.repr_ofNat", "code": "@[simp]\ntheorem repr_ofNat (n : \u2115) : repr (ofNat n) = n", "start": [150, 1], "end": [151, 71], "kind": "commanddeclaration"}, {"full_name": "ONote.repr_one", "code": "theorem repr_one : repr (ofNat 1) = (1 : \u2115)", "start": [155, 1], "end": [155, 60], "kind": "commanddeclaration"}, {"full_name": "ONote.omega_le_oadd", "code": "theorem omega_le_oadd (e n a) : \u03c9 ^ repr e \u2264 repr (oadd e n a)", "start": [158, 1], "end": [160, 97], "kind": "commanddeclaration"}, {"full_name": "ONote.oadd_pos", "code": "theorem oadd_pos (e n a) : 0 < oadd e n a", "start": [163, 1], "end": [164, 91], "kind": "commanddeclaration"}, {"full_name": "ONote.cmp", "code": "def cmp : ONote \u2192 ONote \u2192 Ordering\n  | 0, 0 => Ordering.eq\n  | _, 0 => Ordering.gt\n  | 0, _ => Ordering.lt\n  | _o\u2081@(oadd e\u2081 n\u2081 a\u2081), _o\u2082@(oadd e\u2082 n\u2082 a\u2082) =>\n    (cmp e\u2081 e\u2082).orElse <| (_root_.cmp (n\u2081 : \u2115) n\u2082).orElse (cmp a\u2081 a\u2082)", "start": [167, 1], "end": [173, 70], "kind": "commanddeclaration"}, {"full_name": "ONote.eq_of_cmp_eq", "code": "theorem eq_of_cmp_eq : \u2200 {o\u2081 o\u2082}, cmp o\u2081 o\u2082 = Ordering.eq \u2192 o\u2081 = o\u2082", "start": [176, 1], "end": [188, 9], "kind": "commanddeclaration"}, {"full_name": "ONote.zero_lt_one", "code": "protected theorem zero_lt_one : (0 : ONote) < 1", "start": [191, 1], "end": [192, 81], "kind": "commanddeclaration"}, {"full_name": "ONote.NFBelow", "code": "inductive NFBelow : ONote \u2192 Ordinal.{0} \u2192 Prop\n  | zero {b} : NFBelow 0 b\n  | oadd' {e n a eb b} : NFBelow e eb \u2192 NFBelow a (repr e) \u2192 repr e < b \u2192 NFBelow (oadd e n a) b", "start": [195, 1], "end": [199, 97], "kind": "commanddeclaration"}, {"full_name": "ONote.NF", "code": "class NF (o : ONote) : Prop where\n  out : Exists (NFBelow o)", "start": [202, 1], "end": [213, 27], "kind": "commanddeclaration"}, {"full_name": "ONote.NF.zero", "code": "instance NF.zero : NF 0 :=\n  \u27e8\u27e80, NFBelow.zero\u27e9\u27e9", "start": [216, 1], "end": [217, 22], "kind": "commanddeclaration"}, {"full_name": "ONote.NFBelow.oadd", "code": "theorem NFBelow.oadd {e n a b} : NF e \u2192 NFBelow a (repr e) \u2192 repr e < b \u2192 NFBelow (oadd e n a) b", "start": [220, 1], "end": [221, 32], "kind": "commanddeclaration"}, {"full_name": "ONote.NFBelow.fst", "code": "theorem NFBelow.fst {e n a b} (h : NFBelow (ONote.oadd e n a) b) : NF e", "start": [224, 1], "end": [225, 57], "kind": "commanddeclaration"}, {"full_name": "ONote.NF.fst", "code": "theorem NF.fst {e n a} : NF (oadd e n a) \u2192 NF e", "start": [228, 1], "end": [229, 22], "kind": "commanddeclaration"}, {"full_name": "ONote.NFBelow.snd", "code": "theorem NFBelow.snd {e n a b} (h : NFBelow (ONote.oadd e n a) b) : NFBelow a (repr e)", "start": [232, 1], "end": [233, 50], "kind": "commanddeclaration"}, {"full_name": "ONote.NF.snd'", "code": "theorem NF.snd' {e n a} : NF (oadd e n a) \u2192 NFBelow a (repr e)", "start": [236, 1], "end": [237, 22], "kind": "commanddeclaration"}, {"full_name": "ONote.NF.snd", "code": "theorem NF.snd {e n a} (h : NF (oadd e n a)) : NF a", "start": [240, 1], "end": [241, 16], "kind": "commanddeclaration"}, {"full_name": "ONote.NF.oadd", "code": "theorem NF.oadd {e a} (h\u2081 : NF e) (n) (h\u2082 : NFBelow a (repr e)) : NF (oadd e n a)", "start": [244, 1], "end": [245, 40], "kind": "commanddeclaration"}, {"full_name": "ONote.NF.oadd_zero", "code": "instance NF.oadd_zero (e n) [h : NF e] : NF (ONote.oadd e n 0) :=\n  h.oadd _ NFBelow.zero", "start": [248, 1], "end": [249, 24], "kind": "commanddeclaration"}, {"full_name": "ONote.NFBelow.lt", "code": "theorem NFBelow.lt {e n a b} (h : NFBelow (ONote.oadd e n a) b) : repr e < b", "start": [252, 1], "end": [253, 50], "kind": "commanddeclaration"}, {"full_name": "ONote.NFBelow_zero", "code": "theorem NFBelow_zero : \u2200 {o}, NFBelow o 0 \u2194 o = 0", "start": [256, 1], "end": [259, 92], "kind": "commanddeclaration"}, {"full_name": "ONote.NF.zero_of_zero", "code": "theorem NF.zero_of_zero {e n a} (h : NF (ONote.oadd e n a)) (e0 : e = 0) : a = 0", "start": [262, 1], "end": [263, 40], "kind": "commanddeclaration"}, {"full_name": "ONote.NFBelow.repr_lt", "code": "theorem NFBelow.repr_lt {o b} (h : NFBelow o b) : repr o < \u03c9 ^ b", "start": [266, 1], "end": [274, 58], "kind": "commanddeclaration"}, {"full_name": "ONote.NFBelow.mono", "code": "theorem NFBelow.mono {o b\u2081 b\u2082} (bb : b\u2081 \u2264 b\u2082) (h : NFBelow o b\u2081) : NFBelow o b\u2082", "start": [277, 1], "end": [279, 39], "kind": "commanddeclaration"}, {"full_name": "ONote.NF.below_of_lt", "code": "theorem NF.below_of_lt {e n a b} (H : repr e < b) :\n    NF (ONote.oadd e n a) \u2192 NFBelow (ONote.oadd e n a) b", "start": [282, 1], "end": [284, 87], "kind": "commanddeclaration"}, {"full_name": "ONote.NF.below_of_lt'", "code": "theorem NF.below_of_lt' : \u2200 {o b}, repr o < \u03c9 ^ b \u2192 NF o \u2192 NFBelow o b", "start": [287, 1], "end": [291, 88], "kind": "commanddeclaration"}, {"full_name": "ONote.nfBelow_ofNat", "code": "theorem nfBelow_ofNat : \u2200 n, NFBelow (ofNat n) 1", "start": [294, 1], "end": [296, 64], "kind": "commanddeclaration"}, {"full_name": "ONote.nf_ofNat", "code": "instance nf_ofNat (n) : NF (ofNat n) :=\n  \u27e8\u27e8_, nfBelow_ofNat n\u27e9\u27e9", "start": [299, 1], "end": [300, 25], "kind": "commanddeclaration"}, {"full_name": "ONote.nf_one", "code": "instance nf_one : NF 1 := by (rw [\u2190 ofNat_one]; infer_instance)", "start": [303, 1], "end": [303, 64], "kind": "commanddeclaration"}, {"full_name": "ONote.oadd_lt_oadd_1", "code": "theorem oadd_lt_oadd_1 {e\u2081 n\u2081 o\u2081 e\u2082 n\u2082 o\u2082} (h\u2081 : NF (oadd e\u2081 n\u2081 o\u2081)) (h : e\u2081 < e\u2082) :\n    oadd e\u2081 n\u2081 o\u2081 < oadd e\u2082 n\u2082 o\u2082", "start": [306, 1], "end": [309, 59], "kind": "commanddeclaration"}, {"full_name": "ONote.oadd_lt_oadd_2", "code": "theorem oadd_lt_oadd_2 {e o\u2081 o\u2082 : ONote} {n\u2081 n\u2082 : \u2115+} (h\u2081 : NF (oadd e n\u2081 o\u2081)) (h : (n\u2081 : \u2115) < n\u2082) :\n    oadd e n\u2081 o\u2081 < oadd e n\u2082 o\u2082", "start": [312, 1], "end": [316, 96], "kind": "commanddeclaration"}, {"full_name": "ONote.oadd_lt_oadd_3", "code": "theorem oadd_lt_oadd_3 {e n a\u2081 a\u2082} (h : a\u2081 < a\u2082) : oadd e n a\u2081 < oadd e n a\u2082", "start": [319, 1], "end": [321, 49], "kind": "commanddeclaration"}, {"full_name": "ONote.cmp_compares", "code": "theorem cmp_compares : \u2200 (a b : ONote) [NF a] [NF b], (cmp a b).Compares a b", "start": [324, 1], "end": [361, 27], "kind": "commanddeclaration"}, {"full_name": "ONote.repr_inj", "code": "theorem repr_inj {a b} [NF a] [NF b] : repr a = repr b \u2194 a = b", "start": [364, 1], "end": [369, 17], "kind": "commanddeclaration"}, {"full_name": "ONote.NF.of_dvd_omega_opow", "code": "theorem NF.of_dvd_omega_opow {b e n a} (h : NF (ONote.oadd e n a))\n    (d : \u03c9 ^ b \u2223 repr (ONote.oadd e n a)) :\n    b \u2264 repr e \u2227 \u03c9 ^ b \u2223 repr a", "start": [372, 1], "end": [378, 66], "kind": "commanddeclaration"}, {"full_name": "ONote.NF.of_dvd_omega", "code": "theorem NF.of_dvd_omega {e n a} (h : NF (ONote.oadd e n a)) :\n    \u03c9 \u2223 repr (ONote.oadd e n a) \u2192 repr e \u2260 0 \u2227 \u03c9 \u2223 repr a", "start": [381, 1], "end": [383, 71], "kind": "commanddeclaration"}, {"full_name": "ONote.TopBelow", "code": "def TopBelow (b : ONote) : ONote \u2192 Prop\n  | 0 => True\n  | oadd e _ _ => cmp e b = Ordering.lt", "start": [386, 1], "end": [391, 40], "kind": "commanddeclaration"}, {"full_name": "ONote.decidableTopBelow", "code": "instance decidableTopBelow : DecidableRel TopBelow := by\n  intro b o\n  cases o <;> delta TopBelow <;> infer_instance", "start": [394, 1], "end": [396, 48], "kind": "commanddeclaration"}, {"full_name": "ONote.nfBelow_iff_topBelow", "code": "theorem nfBelow_iff_topBelow {b} [NF b] : \u2200 {o}, NFBelow o (repr b) \u2194 NF o \u2227 TopBelow b o", "start": [399, 1], "end": [403, 65], "kind": "commanddeclaration"}, {"full_name": "ONote.decidableNF", "code": "instance decidableNF : DecidablePred NF\n  | 0 => isTrue NF.zero\n  | oadd e n a => by\n    have := decidableNF e\n    have := decidableNF a\n    apply decidable_of_iff (NF e \u2227 NF a \u2227 TopBelow e a)\n    rw [\u2190 and_congr_right fun h => @nfBelow_iff_topBelow _ h _]\n    exact \u27e8fun \u27e8h\u2081, h\u2082\u27e9 => NF.oadd h\u2081 n h\u2082, fun h => \u27e8h.fst, h.snd'\u27e9\u27e9", "start": [406, 1], "end": [413, 70], "kind": "commanddeclaration"}, {"full_name": "ONote.addAux", "code": "def addAux (e : ONote) (n : \u2115+) (o : ONote) : ONote :=\n    match o with\n    | 0 => oadd e n 0\n    | o'@(oadd e' n' a') =>\n      match cmp e e' with\n      | Ordering.lt => o'\n      | Ordering.eq => oadd e (n + n') a'\n      | Ordering.gt => oadd e n o'", "start": [416, 1], "end": [424, 35], "kind": "commanddeclaration"}, {"full_name": "ONote.add", "code": "def add : ONote \u2192 ONote \u2192 ONote\n  | 0, o => o\n  | oadd e n a, o => addAux e n (add a o)", "start": [426, 1], "end": [429, 42], "kind": "commanddeclaration"}, {"full_name": "ONote.zero_add", "code": "@[simp]\ntheorem zero_add (o : ONote) : 0 + o = o", "start": [435, 1], "end": [437, 6], "kind": "commanddeclaration"}, {"full_name": "ONote.oadd_add", "code": "theorem oadd_add (e n a o) : oadd e n a + o = addAux e n (a + o)", "start": [440, 1], "end": [441, 6], "kind": "commanddeclaration"}, {"full_name": "ONote.sub", "code": "def sub : ONote \u2192 ONote \u2192 ONote\n  | 0, _ => 0\n  | o, 0 => o\n  | o\u2081@(oadd e\u2081 n\u2081 a\u2081), oadd e\u2082 n\u2082 a\u2082 =>\n    match cmp e\u2081 e\u2082 with\n    | Ordering.lt => 0\n    | Ordering.gt => o\u2081\n    | Ordering.eq =>\n      match (n\u2081 : \u2115) - n\u2082 with\n      | 0 => if n\u2081 = n\u2082 then sub a\u2081 a\u2082 else 0\n      | Nat.succ k => oadd e\u2081 k.succPNat a\u2081", "start": [444, 1], "end": [455, 44], "kind": "commanddeclaration"}, {"full_name": "ONote.add_nfBelow", "code": "theorem add_nfBelow {b} : \u2200 {o\u2081 o\u2082}, NFBelow o\u2081 b \u2192 NFBelow o\u2082 b \u2192 NFBelow (o\u2081 + o\u2082) b", "start": [461, 1], "end": [474, 70], "kind": "commanddeclaration"}, {"full_name": "ONote.add_nf", "code": "instance add_nf (o\u2081 o\u2082) : \u2200 [NF o\u2081] [NF o\u2082], NF (o\u2081 + o\u2082)\n  | \u27e8\u27e8b\u2081, h\u2081\u27e9\u27e9, \u27e8\u27e8b\u2082, h\u2082\u27e9\u27e9 =>\n    \u27e8(le_total b\u2081 b\u2082).elim (fun h => \u27e8b\u2082, add_nfBelow (h\u2081.mono h) h\u2082\u27e9) fun h =>\n        \u27e8b\u2081, add_nfBelow h\u2081 (h\u2082.mono h)\u27e9\u27e9", "start": [477, 1], "end": [480, 42], "kind": "commanddeclaration"}, {"full_name": "ONote.repr_add", "code": "@[simp]\ntheorem repr_add : \u2200 (o\u2081 o\u2082) [NF o\u2081] [NF o\u2082], repr (o\u2081 + o\u2082) = repr o\u2081 + repr o\u2082", "start": [483, 1], "end": [503, 54], "kind": "commanddeclaration"}, {"full_name": "ONote.sub_nfBelow", "code": "theorem sub_nfBelow : \u2200 {o\u2081 o\u2082 b}, NFBelow o\u2081 b \u2192 NF o\u2082 \u2192 NFBelow (o\u2081 - o\u2082) b", "start": [506, 1], "end": [522, 15], "kind": "commanddeclaration"}, {"full_name": "ONote.sub_nf", "code": "instance sub_nf (o\u2081 o\u2082) : \u2200 [NF o\u2081] [NF o\u2082], NF (o\u2081 - o\u2082)\n  | \u27e8\u27e8b\u2081, h\u2081\u27e9\u27e9, h\u2082 => \u27e8\u27e8b\u2081, sub_nfBelow h\u2081 h\u2082\u27e9\u27e9", "start": [525, 1], "end": [526, 48], "kind": "commanddeclaration"}, {"full_name": "ONote.repr_sub", "code": "@[simp]\ntheorem repr_sub : \u2200 (o\u2081 o\u2082) [NF o\u2081] [NF o\u2082], repr (o\u2081 - o\u2082) = repr o\u2081 - repr o\u2082", "start": [529, 1], "end": [563, 80], "kind": "commanddeclaration"}, {"full_name": "ONote.mul", "code": "def mul : ONote \u2192 ONote \u2192 ONote\n  | 0, _ => 0\n  | _, 0 => 0\n  | o\u2081@(oadd e\u2081 n\u2081 a\u2081), oadd e\u2082 n\u2082 a\u2082 =>\n    if e\u2082 = 0 then oadd e\u2081 (n\u2081 * n\u2082) a\u2081 else oadd (e\u2081 + e\u2082) n\u2082 (mul o\u2081 a\u2082)", "start": [566, 1], "end": [571, 75], "kind": "commanddeclaration"}, {"full_name": "ONote.oadd_mul", "code": "theorem oadd_mul (e\u2081 n\u2081 a\u2081 e\u2082 n\u2082 a\u2082) :\n    oadd e\u2081 n\u2081 a\u2081 * oadd e\u2082 n\u2082 a\u2082 =\n      if e\u2082 = 0 then oadd e\u2081 (n\u2081 * n\u2082) a\u2081 else oadd (e\u2081 + e\u2082) n\u2082 (oadd e\u2081 n\u2081 a\u2081 * a\u2082)", "start": [583, 1], "end": [586, 6], "kind": "commanddeclaration"}, {"full_name": "ONote.oadd_mul_nfBelow", "code": "theorem oadd_mul_nfBelow {e\u2081 n\u2081 a\u2081 b\u2081} (h\u2081 : NFBelow (oadd e\u2081 n\u2081 a\u2081) b\u2081) :\n    \u2200 {o\u2082 b\u2082}, NFBelow o\u2082 b\u2082 \u2192 NFBelow (oadd e\u2081 n\u2081 a\u2081 * o\u2082) (repr e\u2081 + b\u2082)", "start": [589, 1], "end": [603, 20], "kind": "commanddeclaration"}, {"full_name": "ONote.mul_nf", "code": "instance mul_nf : \u2200 (o\u2081 o\u2082) [NF o\u2081] [NF o\u2082], NF (o\u2081 * o\u2082)\n  | 0, o, _, h\u2082 => by cases o <;> exact NF.zero\n  | oadd e n a, o, \u27e8\u27e8b\u2081, hb\u2081\u27e9\u27e9, \u27e8\u27e8b\u2082, hb\u2082\u27e9\u27e9 => \u27e8\u27e8_, oadd_mul_nfBelow hb\u2081 hb\u2082\u27e9\u27e9", "start": [606, 1], "end": [608, 79], "kind": "commanddeclaration"}, {"full_name": "ONote.repr_mul", "code": "@[simp]\ntheorem repr_mul : \u2200 (o\u2081 o\u2082) [NF o\u2081] [NF o\u2082], repr (o\u2081 * o\u2082) = repr o\u2081 * repr o\u2082", "start": [611, 1], "end": [635, 62], "kind": "commanddeclaration"}, {"full_name": "ONote.split'", "code": "def split' : ONote \u2192 ONote \u00d7 \u2115\n  | 0 => (0, 0)\n  | oadd e n a =>\n    if e = 0 then (0, n)\n    else\n      let (a', m) := split' a\n      (oadd (e - 1) n a', m)", "start": [638, 1], "end": [646, 29], "kind": "commanddeclaration"}, {"full_name": "ONote.split", "code": "def split : ONote \u2192 ONote \u00d7 \u2115\n  | 0 => (0, 0)\n  | oadd e n a =>\n    if e = 0 then (0, n)\n    else\n      let (a', m) := split a\n      (oadd e n a', m)", "start": [649, 1], "end": [657, 23], "kind": "commanddeclaration"}, {"full_name": "ONote.scale", "code": "def scale (x : ONote) : ONote \u2192 ONote\n  | 0 => 0\n  | oadd e n a => oadd (x + e) n (scale x a)", "start": [660, 1], "end": [663, 45], "kind": "commanddeclaration"}, {"full_name": "ONote.mulNat", "code": "def mulNat : ONote \u2192 \u2115 \u2192 ONote\n  | 0, _ => 0\n  | _, 0 => 0\n  | oadd e n a, m + 1 => oadd e (n * m.succPNat) a", "start": [666, 1], "end": [670, 51], "kind": "commanddeclaration"}, {"full_name": "ONote.opowAux", "code": "def opowAux (e a0 a : ONote) : \u2115 \u2192 \u2115 \u2192 ONote\n  | _, 0 => 0\n  | 0, m + 1 => oadd e m.succPNat 0\n  | k + 1, m => scale (e + mulNat a0 k) a + (opowAux e a0 a k m)", "start": [673, 1], "end": [678, 65], "kind": "commanddeclaration"}, {"full_name": "ONote.opowAux2", "code": "def opowAux2 (o\u2082 : ONote) (o\u2081 : ONote \u00d7 \u2115) : ONote :=\n  match o\u2081 with\n  | (0, 0) => if o\u2082 = 0 then 1 else 0\n  | (0, 1) => 1\n  | (0, m + 1) =>\n    let (b', k) := split' o\u2082\n    oadd b' (HPow.hPow (\u03b1 := \u2115+) m.succPNat k) 0\n  | (a@(oadd a0 _ _), m) =>\n    match split o\u2082 with\n    | (b, 0) => oadd (a0 * b) 1 0\n    | (b, k + 1) =>\n      let eb := a0 * b\n      scale (eb + mulNat a0 k) a + opowAux eb a0 (mulNat a m) k m", "start": [681, 1], "end": [695, 66], "kind": "commanddeclaration"}, {"full_name": "ONote.opow", "code": "def opow (o\u2081 o\u2082 : ONote) : ONote := opowAux2 o\u2082 (split o\u2081)", "start": [697, 1], "end": [699, 59], "kind": "commanddeclaration"}, {"full_name": "ONote.opow_def", "code": "theorem opow_def (o\u2081 o\u2082 : ONote) : o\u2081 ^ o\u2082 = opowAux2 o\u2082 (split o\u2081)", "start": [705, 1], "end": [706, 6], "kind": "commanddeclaration"}, {"full_name": "ONote.split_eq_scale_split'", "code": "theorem split_eq_scale_split' : \u2200 {o o' m} [NF o], split' o = (o', m) \u2192 split o = (scale 1 o', m)", "start": [709, 1], "end": [730, 25], "kind": "commanddeclaration"}, {"full_name": "ONote.nf_repr_split'", "code": "theorem nf_repr_split' : \u2200 {o o' m} [NF o], split' o = (o', m) \u2192 NF o' \u2227 repr o = \u03c9 * repr o' + m", "start": [733, 1], "end": [758, 45], "kind": "commanddeclaration"}, {"full_name": "ONote.scale_eq_mul", "code": "theorem scale_eq_mul (x) [NF x] : \u2200 (o) [NF o], scale x o = oadd x 1 0 * o", "start": [761, 1], "end": [770, 53], "kind": "commanddeclaration"}, {"full_name": "ONote.nf_scale", "code": "instance nf_scale (x) [NF x] (o) [NF o] : NF (scale x o) := by\n  rw [scale_eq_mul]\n  infer_instance", "start": [773, 1], "end": [775, 17], "kind": "commanddeclaration"}, {"full_name": "ONote.repr_scale", "code": "@[simp]\ntheorem repr_scale (x) [NF x] (o) [NF o] : repr (scale x o) = \u03c9 ^ repr x * repr o", "start": [778, 1], "end": [780, 90], "kind": "commanddeclaration"}, {"full_name": "ONote.nf_repr_split", "code": "theorem nf_repr_split {o o' m} [NF o] (h : split o = (o', m)) : NF o' \u2227 repr o = repr o' + m", "start": [783, 1], "end": [790, 17], "kind": "commanddeclaration"}, {"full_name": "ONote.split_dvd", "code": "theorem split_dvd {o o' m} [NF o] (h : split o = (o', m)) : \u03c9 \u2223 repr o'", "start": [793, 1], "end": [797, 37], "kind": "commanddeclaration"}, {"full_name": "ONote.split_add_lt", "code": "theorem split_add_lt {o e n a m} [NF o] (h : split o = (oadd e n a, m)) :\n    repr a + m < \u03c9 ^ repr e", "start": [800, 1], "end": [805, 69], "kind": "commanddeclaration"}, {"full_name": "ONote.mulNat_eq_mul", "code": "@[simp]\ntheorem mulNat_eq_mul (n o) : mulNat o n = o * ofNat n", "start": [808, 1], "end": [809, 89], "kind": "commanddeclaration"}, {"full_name": "ONote.nf_mulNat", "code": "instance nf_mulNat (o) [NF o] (n) : NF (mulNat o n) := by simp; exact ONote.mul_nf o (ofNat n)", "start": [812, 1], "end": [812, 95], "kind": "commanddeclaration"}, {"full_name": "ONote.nf_opowAux", "code": "instance nf_opowAux (e a0 a) [NF e] [NF a0] [NF a] : \u2200 k m, NF (opowAux e a0 a k m) := by\n  intro k m\n  unfold opowAux\n  cases' m with m m\n  \u00b7 cases k <;> exact NF.zero\n  cases' k with k k\n  \u00b7 exact NF.oadd_zero _ _\n  \u00b7 haveI := nf_opowAux e a0 a k\n    simp only [Nat.succ_ne_zero m]; infer_instance", "start": [815, 1], "end": [823, 51], "kind": "commanddeclaration"}, {"full_name": "ONote.nf_opow", "code": "instance nf_opow (o\u2081 o\u2082) [NF o\u2081] [NF o\u2082] : NF (o\u2081 ^ o\u2082) := by\n  cases' e\u2081 : split o\u2081 with a m\n  have na := (nf_repr_split e\u2081).1\n  cases' e\u2082 : split' o\u2082 with b' k\n  haveI := (nf_repr_split' e\u2082).1\n  cases' a with a0 n a'\n  \u00b7 cases' m with m\n    \u00b7 by_cases o\u2082 = 0 <;> simp [(\u00b7 ^ \u00b7), Pow.pow, pow, opow, opowAux2, *]\n    \u00b7 by_cases m = 0\n      \u00b7 simp only [(\u00b7 ^ \u00b7), Pow.pow, pow, opow, opowAux2, *, zero_def]\n      \u00b7 simp only [(\u00b7 ^ \u00b7), Pow.pow, pow, opow, opowAux2, mulNat_eq_mul, ofNat, *]\n        infer_instance\n  \u00b7 simp [(\u00b7 ^ \u00b7),Pow.pow,pow, opow, opowAux2, e\u2081, e\u2082, split_eq_scale_split' e\u2082]\n    have := na.fst\n    cases' k with k <;> simp\n    \u00b7 infer_instance\n    \u00b7 cases k <;> cases m <;> infer_instance", "start": [826, 1], "end": [842, 45], "kind": "commanddeclaration"}, {"full_name": "ONote.scale_opowAux", "code": "theorem scale_opowAux (e a0 a : ONote) [NF e] [NF a0] [NF a] :\n    \u2200 k m, repr (opowAux e a0 a k m) = \u03c9 ^ repr e * repr (opowAux 0 a0 a k m)", "start": [845, 1], "end": [855, 79], "kind": "commanddeclaration"}, {"full_name": "ONote.repr_opow_aux\u2081", "code": "theorem repr_opow_aux\u2081 {e a} [Ne : NF e] [Na : NF a] {a' : Ordinal} (e0 : repr e \u2260 0)\n    (h : a' < (\u03c9 : Ordinal.{0}) ^ repr e) (aa : repr a = a') (n : \u2115+) :\n    ((\u03c9 : Ordinal.{0}) ^ repr e * (n : \u2115) + a') ^ (\u03c9 : Ordinal.{0}) =\n      (\u03c9 ^ repr e) ^ (\u03c9 : Ordinal.{0})", "start": [858, 1], "end": [880, 62], "kind": "commanddeclaration"}, {"full_name": "ONote.repr_opow_aux\u2082", "code": "theorem repr_opow_aux\u2082 {a0 a'} [N0 : NF a0] [Na' : NF a'] (m : \u2115) (d : \u03c9 \u2223 repr a')\n    (e0 : repr a0 \u2260 0) (h : repr a' + m < (\u03c9 ^ repr a0)) (n : \u2115+) (k : \u2115) :\n    let R := repr (opowAux 0 a0 (oadd a0 n a' * ofNat m) k m)\n    (k \u2260 0 \u2192 R < ((\u03c9 ^ repr a0) ^ succ \u2191k)) \u2227\n      ((\u03c9 ^ repr a0) ^ k) * ((\u03c9 ^ repr a0) * (n : \u2115) + repr a') + R =\n        ((\u03c9 ^ repr a0) * (n : \u2115) + repr a' + m) ^ succ \u2191k", "start": [887, 1], "end": [959, 47], "kind": "commanddeclaration"}, {"full_name": "ONote.repr_opow", "code": "theorem repr_opow (o\u2081 o\u2082) [NF o\u2081] [NF o\u2082] : repr (o\u2081 ^ o\u2082) = repr o\u2081 ^ repr o\u2082", "start": [964, 1], "end": [1007, 47], "kind": "commanddeclaration"}, {"full_name": "ONote.fundamentalSequence", "code": "def fundamentalSequence : ONote \u2192 Sum (Option ONote) (\u2115 \u2192 ONote)\n  | zero => Sum.inl none\n  | oadd a m b =>\n    match fundamentalSequence b with\n    | Sum.inr f => Sum.inr fun i => oadd a m (f i)\n    | Sum.inl (some b') => Sum.inl (some (oadd a m b'))\n    | Sum.inl none =>\n      match fundamentalSequence a, m.natPred with\n      | Sum.inl none, 0 => Sum.inl (some zero)\n      | Sum.inl none, m + 1 => Sum.inl (some (oadd zero m.succPNat zero))\n      | Sum.inl (some a'), 0 => Sum.inr fun i => oadd a' i.succPNat zero\n      | Sum.inl (some a'), m + 1 => Sum.inr fun i => oadd a m.succPNat (oadd a' i.succPNat zero)\n      | Sum.inr f, 0 => Sum.inr fun i => oadd (f i) 1 zero\n      | Sum.inr f, m + 1 => Sum.inr fun i => oadd a m.succPNat (oadd (f i) 1 zero)", "start": [1010, 1], "end": [1025, 83], "kind": "commanddeclaration"}, {"full_name": "ONote.exists_lt_add", "code": "private theorem exists_lt_add {\u03b1} [h\u03b1 : Nonempty \u03b1] {o : Ordinal} {f : \u03b1 \u2192 Ordinal}\n    (H : \u2200 \u2983a\u2984, a < o \u2192 \u2203 i, a < f i) {b : Ordinal} \u2983a\u2984 (h : a < b + o) : \u2203 i, a < b + f i", "start": [1028, 1], "end": [1035, 65], "kind": "commanddeclaration"}, {"full_name": "ONote.exists_lt_mul_omega'", "code": "private theorem exists_lt_mul_omega' {o : Ordinal} \u2983a\u2984 (h : a < o * \u03c9) :\n    \u2203 i : \u2115, a < o * \u2191i + o", "start": [1037, 1], "end": [1041, 44], "kind": "commanddeclaration"}, {"full_name": "ONote.exists_lt_omega_opow'", "code": "private theorem exists_lt_omega_opow' {\u03b1} {o b : Ordinal} (hb : 1 < b) (ho : o.IsLimit)\n    {f : \u03b1 \u2192 Ordinal} (H : \u2200 \u2983a\u2984, a < o \u2192 \u2203 i, a < f i) \u2983a\u2984 (h : a < b ^ o) :\n        \u2203 i, a < b ^ f i", "start": [1043, 1], "end": [1047, 76], "kind": "commanddeclaration"}, {"full_name": "ONote.FundamentalSequenceProp", "code": "def FundamentalSequenceProp (o : ONote) : Sum (Option ONote) (\u2115 \u2192 ONote) \u2192 Prop\n  | Sum.inl none => o = 0\n  | Sum.inl (some a) => o.repr = succ a.repr \u2227 (o.NF \u2192 a.NF)\n  | Sum.inr f =>\n    o.repr.IsLimit \u2227\n      (\u2200 i, f i < f (i + 1) \u2227 f i < o \u2227 (o.NF \u2192 (f i).NF)) \u2227 \u2200 a, a < o.repr \u2192 \u2203 i, a < (f i).repr", "start": [1049, 1], "end": [1059, 99], "kind": "commanddeclaration"}, {"full_name": "ONote.fundamentalSequenceProp_inl_none", "code": "theorem fundamentalSequenceProp_inl_none (o) :\n    FundamentalSequenceProp o (Sum.inl none) \u2194 o = 0", "start": [1062, 1], "end": [1064, 10], "kind": "commanddeclaration"}, {"full_name": "ONote.fundamentalSequenceProp_inl_some", "code": "theorem fundamentalSequenceProp_inl_some (o a) :\n    FundamentalSequenceProp o (Sum.inl (some a)) \u2194 o.repr = succ a.repr \u2227 (o.NF \u2192 a.NF)", "start": [1066, 1], "end": [1068, 10], "kind": "commanddeclaration"}, {"full_name": "ONote.fundamentalSequenceProp_inr", "code": "theorem fundamentalSequenceProp_inr (o f) :\n    FundamentalSequenceProp o (Sum.inr f) \u2194\n      o.repr.IsLimit \u2227\n        (\u2200 i, f i < f (i + 1) \u2227 f i < o \u2227 (o.NF \u2192 (f i).NF)) \u2227\n        \u2200 a, a < o.repr \u2192 \u2203 i, a < (f i).repr", "start": [1070, 1], "end": [1075, 10], "kind": "commanddeclaration"}, {"full_name": "ONote.fundamentalSequence_has_prop", "code": "theorem fundamentalSequence_has_prop (o) : FundamentalSequenceProp o (fundamentalSequence o)", "start": [1084, 1], "end": [1140, 26], "kind": "commanddeclaration"}, {"full_name": "ONote.fastGrowing", "code": "def fastGrowing : ONote \u2192 \u2115 \u2192 \u2115\n  | o =>\n    match fundamentalSequence o, fundamentalSequence_has_prop o with\n    | Sum.inl none, _ => Nat.succ\n    | Sum.inl (some a), h =>\n      have : a < o := by rw [lt_def, h.1]; apply lt_succ\n      fun i => (fastGrowing a)^[i] i\n    | Sum.inr f, h => fun i =>\n      have : f i < o := (h.2.1 i).2.1\n      fastGrowing (f i) i\n  termination_by fastGrowing o => o", "start": [1143, 1], "end": [1159, 36], "kind": "commanddeclaration"}, {"full_name": "ONote.fastGrowing_def", "code": "@[nolint unusedHavesSuffices]\ntheorem fastGrowing_def {o : ONote} {x} (e : fundamentalSequence o = x) :\n    fastGrowing o =\n      match\n        (motive := (x : Option ONote \u2295 (\u2115 \u2192 ONote)) \u2192 FundamentalSequenceProp o x \u2192 \u2115 \u2192 \u2115)\n        x, e \u25b8 fundamentalSequence_has_prop o with\n      | Sum.inl none, _ => Nat.succ\n      | Sum.inl (some a), _ =>\n        fun i => (fastGrowing a)^[i] i\n      | Sum.inr f, _ => fun i =>\n        fastGrowing (f i) i", "start": [1163, 1], "end": [1175, 19], "kind": "commanddeclaration"}, {"full_name": "ONote.fastGrowing_zero'", "code": "theorem fastGrowing_zero' (o : ONote) (h : fundamentalSequence o = Sum.inl none) :\n    fastGrowing o = Nat.succ", "start": [1178, 1], "end": [1180, 25], "kind": "commanddeclaration"}, {"full_name": "ONote.fastGrowing_succ", "code": "theorem fastGrowing_succ (o) {a} (h : fundamentalSequence o = Sum.inl (some a)) :\n    fastGrowing o = fun i => (fastGrowing a)^[i] i", "start": [1183, 1], "end": [1185, 25], "kind": "commanddeclaration"}, {"full_name": "ONote.fastGrowing_limit", "code": "theorem fastGrowing_limit (o) {f} (h : fundamentalSequence o = Sum.inr f) :\n    fastGrowing o = fun i => fastGrowing (f i) i", "start": [1188, 1], "end": [1190, 25], "kind": "commanddeclaration"}, {"full_name": "ONote.fastGrowing_zero", "code": "@[simp]\ntheorem fastGrowing_zero : fastGrowing 0 = Nat.succ", "start": [1193, 1], "end": [1195, 26], "kind": "commanddeclaration"}, {"full_name": "ONote.fastGrowing_one", "code": "@[simp]\ntheorem fastGrowing_one : fastGrowing 1 = fun n => 2 * n", "start": [1198, 1], "end": [1202, 100], "kind": "commanddeclaration"}, {"full_name": "ONote.fastGrowing_two", "code": "@[simp]\ntheorem fastGrowing_two : fastGrowing 2 = fun n => (2 ^ n) * n", "start": [1207, 1], "end": [1212, 82], "kind": "commanddeclaration"}, {"full_name": "ONote.fastGrowing\u03b5\u2080", "code": "def fastGrowing\u03b5\u2080 (i : \u2115) : \u2115 :=\n  fastGrowing ((fun a => a.oadd 1 0)^[i] 0) i", "start": [1217, 1], "end": [1222, 46], "kind": "commanddeclaration"}, {"full_name": "ONote.fastGrowing\u03b5\u2080_zero", "code": "theorem fastGrowing\u03b5\u2080_zero : fastGrowing\u03b5\u2080 0 = 1", "start": [1225, 1], "end": [1225, 76], "kind": "commanddeclaration"}, {"full_name": "ONote.fastGrowing\u03b5\u2080_one", "code": "theorem fastGrowing\u03b5\u2080_one : fastGrowing\u03b5\u2080 1 = 2", "start": [1228, 1], "end": [1229, 53], "kind": "commanddeclaration"}, {"full_name": "ONote.fastGrowing\u03b5\u2080_two", "code": "theorem fastGrowing\u03b5\u2080_two : fastGrowing\u03b5\u2080 2 = 2048", "start": [1232, 1], "end": [1234, 78], "kind": "commanddeclaration"}, {"full_name": "NONote", "code": "def NONote :=\n  { o : ONote // o.NF }", "start": [1239, 1], "end": [1245, 24], "kind": "commanddeclaration"}, {"full_name": "NONote.NF", "code": "instance NF (o : NONote) : NF o.1 :=\n  o.2", "start": [1254, 1], "end": [1255, 6], "kind": "commanddeclaration"}, {"full_name": "NONote.mk", "code": "def mk (o : ONote) [h : ONote.NF o] : NONote :=\n  \u27e8o, h\u27e9", "start": [1258, 1], "end": [1261, 9], "kind": "commanddeclaration"}, {"full_name": "NONote.repr", "code": "noncomputable def repr (o : NONote) : Ordinal :=\n  o.1.repr", "start": [1264, 1], "end": [1271, 11], "kind": "commanddeclaration"}, {"full_name": "NONote.lt_wf", "code": "theorem lt_wf : @WellFounded NONote (\u00b7 < \u00b7)", "start": [1293, 1], "end": [1294, 33], "kind": "commanddeclaration"}, {"full_name": "NONote.ofNat", "code": "def ofNat (n : \u2115) : NONote :=\n  \u27e8ONote.ofNat n, \u27e8\u27e8_, nfBelow_ofNat _\u27e9\u27e9\u27e9", "start": [1303, 1], "end": [1305, 42], "kind": "commanddeclaration"}, {"full_name": "NONote.cmp", "code": "def cmp (a b : NONote) : Ordering :=\n  ONote.cmp a.1 b.1", "start": [1308, 1], "end": [1310, 20], "kind": "commanddeclaration"}, {"full_name": "NONote.cmp_compares", "code": "theorem cmp_compares : \u2200 a b : NONote, (cmp a b).Compares a b", "start": [1313, 1], "end": [1318, 34], "kind": "commanddeclaration"}, {"full_name": "NONote.below", "code": "def below (a b : NONote) : Prop :=\n  NFBelow a.1 (repr b)", "start": [1326, 1], "end": [1328, 23], "kind": "commanddeclaration"}, {"full_name": "NONote.oadd", "code": "def oadd (e : NONote) (n : \u2115+) (a : NONote) (h : below a e) : NONote :=\n  \u27e8_, NF.oadd e.2 n h\u27e9", "start": [1331, 1], "end": [1333, 23], "kind": "commanddeclaration"}, {"full_name": "NONote.recOn", "code": "@[elab_as_elim]\ndef recOn {C : NONote \u2192 Sort*} (o : NONote) (H0 : C 0)\n    (H1 : \u2200 e n a h, C e \u2192 C a \u2192 C (oadd e n a h)) : C o := by\n  cases' o with o h; induction' o with e n a IHe IHa\n  \u00b7 exact H0\n  \u00b7 exact H1 \u27e8e, h.fst\u27e9 n \u27e8a, h.snd\u27e9 h.snd' (IHe _) (IHa _)", "start": [1336, 1], "end": [1344, 60], "kind": "commanddeclaration"}, {"full_name": "NONote.repr_add", "code": "theorem repr_add (a b) : repr (a + b) = repr a + repr b", "start": [1351, 1], "end": [1352, 25], "kind": "commanddeclaration"}, {"full_name": "NONote.repr_sub", "code": "theorem repr_sub (a b) : repr (a - b) = repr a - repr b", "start": [1359, 1], "end": [1360, 25], "kind": "commanddeclaration"}, {"full_name": "NONote.repr_mul", "code": "theorem repr_mul (a b) : repr (a * b) = repr a * repr b", "start": [1367, 1], "end": [1368, 25], "kind": "commanddeclaration"}, {"full_name": "NONote.opow", "code": "def opow (x y : NONote) :=\n  mk (x.1 ^ y.1)", "start": [1371, 1], "end": [1373, 17], "kind": "commanddeclaration"}, {"full_name": "NONote.repr_opow", "code": "theorem repr_opow (a b) : repr (opow a b) = repr a ^ repr b", "start": [1376, 1], "end": [1377, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/BanachSteinhaus.lean", "imports": ["Mathlib/Analysis/NormedSpace/OperatorNorm.lean", "Mathlib/Analysis/LocallyConvex/Barrelled.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "banach_steinhaus", "code": "theorem banach_steinhaus {\u03b9 : Type*} [CompleteSpace E] {g : \u03b9 \u2192 E \u2192SL[\u03c3\u2081\u2082] F}\n    (h : \u2200 x, \u2203 C, \u2200 i, \u2016g i x\u2016 \u2264 C) : \u2203 C', \u2200 i, \u2016g i\u2016 \u2264 C'", "start": [28, 1], "end": [37, 51], "kind": "commanddeclaration"}, {"full_name": "banach_steinhaus_iSup_nnnorm", "code": "theorem banach_steinhaus_iSup_nnnorm {\u03b9 : Type*} [CompleteSpace E] {g : \u03b9 \u2192 E \u2192SL[\u03c3\u2081\u2082] F}\n    (h : \u2200 x, (\u2a06 i, \u2191\u2016g i x\u2016\u208a) < \u221e) : (\u2a06 i, \u2191\u2016g i\u2016\u208a) < \u221e", "start": [44, 1], "end": [50, 88], "kind": "commanddeclaration"}, {"full_name": "continuousLinearMapOfTendsto", "code": "abbrev continuousLinearMapOfTendsto {\u03b1 : Type*} [CompleteSpace E] [T2Space F] {l : Filter \u03b1}\n    [l.IsCountablyGenerated] [l.NeBot] (g : \u03b1 \u2192 E \u2192SL[\u03c3\u2081\u2082] F) {f : E \u2192 F}\n    (h : Tendsto (fun n x \u21a6 g n x) l (\ud835\udcdd f)) :\n    E \u2192SL[\u03c3\u2081\u2082] F :=\n  (norm_withSeminorms \ud835\udd5c\u2082 F).continuousLinearMapOfTendsto g h", "start": [57, 1], "end": [64, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Fib/Zeckendorf.lean", "imports": ["Mathlib/Data/Nat/Fib.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.IsZeckendorfRep", "code": "def IsZeckendorfRep (l : List \u2115) : Prop := (l ++ [0]).Chain' (fun a b \u21a6 b + 2 \u2264 a)", "start": [43, 1], "end": [49, 83], "kind": "commanddeclaration"}, {"full_name": "List.IsZeckendorfRep.sum_fib_lt", "code": "lemma IsZeckendorfRep.sum_fib_lt : \u2200 {n l}, IsZeckendorfRep l \u2192 (\u2200 a \u2208 (l ++ [0]).head?, a < n) \u2192\n    (l.map fib).sum < fib n\n  | n, [], _, hn => fib_pos.2 $ hn _ rfl\n  | n, a :: l, hl, hn => by\n    simp only [IsZeckendorfRep, cons_append, chain'_iff_pairwise, pairwise_cons] at hl\n    have : \u2200 b, b \u2208 head? (l ++ [0]) \u2192 b < a - 1 :=\n      fun b hb \u21a6 lt_tsub_iff_right.2 $ hl.1 _ $ mem_of_mem_head? hb\n    simp only [mem_append, mem_singleton, \u2190chain'_iff_pairwise, or_imp, forall_and, forall_eq,\n      zero_add] at hl\n    simp only [map, List.sum_cons]\n    refine (add_lt_add_left (sum_fib_lt hl.2 this) _).trans_le ?_\n    rw [add_comm, \u2190fib_add_one (hl.1.2.trans_lt' zero_lt_two).ne']\n    exact fib_mono (hn _ rfl)", "start": [51, 1], "end": [63, 30], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.greatestFib", "code": "def greatestFib (n : \u2115) : \u2115 := (n + 1).findGreatest (fun k \u21a6 fib k \u2264 n)", "start": [70, 1], "end": [71, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.fib_greatestFib_le", "code": "lemma fib_greatestFib_le (n : \u2115) : fib (greatestFib n) \u2264 n :=\n  findGreatest_spec (P := (fun k \u21a6 fib k \u2264 n)) (zero_le _) $ zero_le _", "start": [73, 1], "end": [74, 71], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.greatestFib_mono", "code": "lemma greatestFib_mono : Monotone greatestFib :=\n  fun _a _b hab \u21a6 findGreatest_mono (fun _k \u21a6 hab.trans') $ add_le_add_right hab _", "start": [76, 1], "end": [77, 83], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.le_greatestFib", "code": "@[simp] lemma le_greatestFib : m \u2264 greatestFib n \u2194 fib m \u2264 n :=\n  \u27e8fun h \u21a6 (fib_mono h).trans $ fib_greatestFib_le _,\n    fun h \u21a6 le_findGreatest (m.le_fib_add_one.trans $ add_le_add_right h _) h\u27e9", "start": [79, 1], "end": [81, 79], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.greatestFib_lt", "code": "@[simp] lemma greatestFib_lt : greatestFib m < n \u2194 m < fib n :=\n  lt_iff_lt_of_le_iff_le le_greatestFib", "start": [83, 1], "end": [84, 40], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.lt_fib_greatestFib_add_one", "code": "lemma lt_fib_greatestFib_add_one (n : \u2115) : n < fib (greatestFib n + 1) :=\n  greatestFib_lt.1 $ lt_succ_self _", "start": [86, 1], "end": [87, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.greatestFib_fib", "code": "@[simp] lemma greatestFib_fib : \u2200 {n}, n \u2260 1 \u2192 greatestFib (fib n) = n\n  | 0, _ => rfl\n  | _n + 2, _ => findGreatest_eq_iff.2\n    \u27e8le_fib_add_one _, fun _ \u21a6 le_rfl, fun _m hnm _ \u21a6 ((fib_lt_fib le_add_self).2 hnm).not_le\u27e9", "start": [89, 1], "end": [92, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.greatestFib_eq_zero", "code": "@[simp] lemma greatestFib_eq_zero : greatestFib n = 0 \u2194 n = 0 :=\n  \u27e8fun h \u21a6 by simpa using findGreatest_eq_zero_iff.1 h zero_lt_one le_add_self, by rintro rfl; rfl\u27e9", "start": [94, 1], "end": [95, 100], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.greatestFib_ne_zero", "code": "lemma greatestFib_ne_zero : greatestFib n \u2260 0 \u2194 n \u2260 0 := greatestFib_eq_zero.not", "start": [97, 1], "end": [97, 81], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.greatestFib_pos", "code": "@[simp] lemma greatestFib_pos : 0 < greatestFib n \u2194 0 < n := by simp [pos_iff_ne_zero]", "start": [99, 1], "end": [99, 87], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.greatestFib_sub_fib_greatestFib_le_greatestFib", "code": "lemma greatestFib_sub_fib_greatestFib_le_greatestFib (hn : n \u2260 0) :\n    greatestFib (n - fib (greatestFib n)) \u2264 greatestFib n - 2 := by\n  rw [\u2190lt_succ_iff, greatestFib_lt, tsub_lt_iff_right n.fib_greatestFib_le, Nat.sub_succ, succ_pred,\n    \u2190fib_add_one]\n  exact n.lt_fib_greatestFib_add_one\n  \u00b7 simpa\n  \u00b7 simpa [\u2190succ_le_iff] using hn.bot_lt", "start": [101, 1], "end": [107, 41], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.zeckendorf_aux", "code": "private lemma zeckendorf_aux (hm : 0 < m) : m - fib (greatestFib m) < m :=\ntsub_lt_self hm $ fib_pos.2 $ findGreatest_pos.2 \u27e81, zero_lt_one, le_add_self, hm\u27e9", "start": [109, 1], "end": [110, 83], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.zeckendorf", "code": "def zeckendorf : \u2115 \u2192 List \u2115\n  | 0 => []\n  | m@(n + 1) => let a := greatestFib m\n    have := zeckendorf_aux (n.succ_pos.trans_eq $ Eq.symm \u2039_\u203a)\n    a :: zeckendorf (m - fib a)", "start": [112, 1], "end": [120, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.zeckendorf_zero", "code": "@[simp] lemma zeckendorf_zero : zeckendorf 0 = [] := rfl", "start": [122, 1], "end": [122, 57], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.zeckendorf_succ", "code": "@[simp, nolint unusedHavesSuffices] lemma zeckendorf_succ (n : \u2115) :\n    zeckendorf (n + 1) = greatestFib (n + 1) :: zeckendorf (n + 1 - fib (greatestFib (n + 1))) := by\n  simp [zeckendorf]", "start": [124, 1], "end": [126, 20], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.zeckendorf_of_pos", "code": "@[simp] lemma zeckendorf_of_pos : \u2200 {n}, 0 < n \u2192\n    zeckendorf n = greatestFib n :: zeckendorf (n - fib (greatestFib n))\n  | _n + 1, _ => zeckendorf_succ _", "start": [128, 1], "end": [130, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.isZeckendorfRep_zeckendorf", "code": "lemma isZeckendorfRep_zeckendorf : \u2200 n, (zeckendorf n).IsZeckendorfRep\n  | 0 => Chain.nil\n  | n + 1 => by\n    rw [zeckendorf_succ, IsZeckendorfRep, List.cons_append]\n    have := zeckendorf_aux n.succ_pos\n    refine (isZeckendorfRep_zeckendorf _).cons' (fun a ha \u21a6 ?_)\n    obtain h | h := eq_zero_or_pos (n + 1 - fib (greatestFib (n + 1)))\n    \u00b7 simp only [h, zeckendorf_zero, nil_append, head?_cons, Option.mem_some_iff] at ha\n      subst ha\n      exact le_greatestFib.2 le_add_self\n    rw [zeckendorf_of_pos h, cons_append, head?_cons, Option.mem_some_iff] at ha\n    subst a\n    exact add_le_of_le_tsub_right_of_le (le_greatestFib.2 le_add_self)\n      (greatestFib_sub_fib_greatestFib_le_greatestFib n.succ_ne_zero)", "start": [132, 1], "end": [145, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.zeckendorf_sum_fib", "code": "lemma zeckendorf_sum_fib : \u2200 {l}, IsZeckendorfRep l \u2192 zeckendorf (l.map fib).sum = l\n  | [], _ => rfl\n  | a :: l, hl => by\n    have hl' := hl\n    simp only [IsZeckendorfRep, cons_append, chain'_iff_pairwise, pairwise_cons, mem_append,\n      mem_singleton, or_imp, forall_and, forall_eq, zero_add] at hl\n    rw [\u2190chain'_iff_pairwise] at hl\n    have ha : 0 < a := hl.1.2.trans_lt' zero_lt_two\n    suffices h : greatestFib (fib a + sum (map fib l)) = a\n    \u00b7 simp only [map, List.sum_cons, add_pos_iff, fib_pos.2 ha, true_or, zeckendorf_of_pos, h,\n      add_tsub_cancel_left, zeckendorf_sum_fib hl.2]\n    simp only [add_comm, add_assoc, greatestFib, findGreatest_eq_iff, ne_eq, ha.ne',\n      not_false_eq_true, le_add_iff_nonneg_left, _root_.zero_le, forall_true_left, not_le, true_and]\n    refine \u27e8le_add_of_le_right $ le_fib_add_one _, fun n hn _ \u21a6 ?_\u27e9\n    rw [add_comm, \u2190List.sum_cons, \u2190map_cons]\n    exact hl'.sum_fib_lt (by simpa)", "start": [147, 1], "end": [162, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.sum_zeckendorf_fib", "code": "@[simp] lemma sum_zeckendorf_fib : \u2200 n : \u2115, (n.zeckendorf.map fib).sum = n\n  | 0 => rfl\n  | n + 1 => by\n    have := zeckendorf_aux n.succ_pos\n    rw [zeckendorf_succ, map, List.sum_cons, sum_zeckendorf_fib (n + 1 - _), add_tsub_cancel_iff_le]\n    exact fib_greatestFib_le _", "start": [164, 1], "end": [169, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.zeckendorfEquiv", "code": "def zeckendorfEquiv : \u2115 \u2243 {l // IsZeckendorfRep l} where\n  toFun n := \u27e8zeckendorf n, isZeckendorfRep_zeckendorf _\u27e9\n  invFun l := (map fib l).sum\n  left_inv := sum_zeckendorf_fib\n  right_inv l := Subtype.ext $ zeckendorf_sum_fib l.2", "start": [171, 1], "end": [178, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/Deriv/Support.lean", "imports": ["Mathlib/Analysis/Calculus/Deriv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "support_deriv_subset", "code": "theorem support_deriv_subset : support (deriv f) \u2286 tsupport f", "start": [38, 1], "end": [43, 64], "kind": "commanddeclaration"}, {"full_name": "HasCompactSupport.deriv", "code": "theorem HasCompactSupport.deriv (hf : HasCompactSupport f) : HasCompactSupport (deriv f)", "start": [46, 1], "end": [47, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/CondCount.lean", "imports": ["Mathlib/Probability/ConditionalProbability.lean", "Mathlib/MeasureTheory/Measure/Count.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.condCount", "code": "def condCount (s : Set \u03a9) : Measure \u03a9 :=\n  Measure.count[|s]", "start": [49, 1], "end": [55, 20], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_empty_meas", "code": "@[simp]\ntheorem condCount_empty_meas : (condCount \u2205 : Measure \u03a9) = 0", "start": [58, 1], "end": [59, 84], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_empty", "code": "theorem condCount_empty {s : Set \u03a9} : condCount s \u2205 = 0", "start": [62, 1], "end": [62, 67], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.finite_of_condCount_ne_zero", "code": "theorem finite_of_condCount_ne_zero {s t : Set \u03a9} (h : condCount s t \u2260 0) : s.Finite", "start": [65, 1], "end": [67, 64], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_univ", "code": "theorem condCount_univ [Fintype \u03a9] {s : Set \u03a9} :\n    condCount Set.univ s = Measure.count s / Fintype.card \u03a9", "start": [70, 1], "end": [76, 59], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_isProbabilityMeasure", "code": "theorem condCount_isProbabilityMeasure {s : Set \u03a9} (hs : s.Finite) (hs' : s.Nonempty) :\n    IsProbabilityMeasure (condCount s)", "start": [81, 1], "end": [86, 53], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_singleton", "code": "theorem condCount_singleton (\u03c9 : \u03a9) (t : Set \u03a9) [Decidable (\u03c9 \u2208 t)] :\n    condCount {\u03c9} t = if \u03c9 \u2208 t then 1 else 0", "start": [89, 1], "end": [95, 65], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_inter_self", "code": "theorem condCount_inter_self (hs : s.Finite) : condCount s (s \u2229 t) = condCount s t", "start": [100, 1], "end": [101, 53], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_self", "code": "theorem condCount_self (hs : s.Finite) (hs' : s.Nonempty) : condCount s s = 1", "start": [104, 1], "end": [107, 47], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_eq_one_of", "code": "theorem condCount_eq_one_of (hs : s.Finite) (hs' : s.Nonempty) (ht : s \u2286 t) :\n    condCount s t = 1", "start": [110, 1], "end": [115, 24], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.pred_true_of_condCount_eq_one", "code": "theorem pred_true_of_condCount_eq_one (h : condCount s t = 1) : s \u2286 t", "start": [118, 1], "end": [126, 96], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_eq_zero_iff", "code": "theorem condCount_eq_zero_iff (hs : s.Finite) : condCount s t = 0 \u2194 s \u2229 t = \u2205", "start": [129, 1], "end": [131, 55], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_of_univ", "code": "theorem condCount_of_univ (hs : s.Finite) (hs' : s.Nonempty) : condCount s Set.univ = 1", "start": [134, 1], "end": [135, 43], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_inter", "code": "theorem condCount_inter (hs : s.Finite) :\n    condCount s (t \u2229 u) = condCount (s \u2229 t) u * condCount s t", "start": [138, 1], "end": [148, 66], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_inter'", "code": "theorem condCount_inter' (hs : s.Finite) :\n    condCount s (t \u2229 u) = condCount (s \u2229 u) t * condCount s u", "start": [151, 1], "end": [154, 27], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_union", "code": "theorem condCount_union (hs : s.Finite) (htu : Disjoint t u) :\n    condCount s (t \u222a u) = condCount s t + condCount s u", "start": [157, 1], "end": [161, 82], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_compl", "code": "theorem condCount_compl (t : Set \u03a9) (hs : s.Finite) (hs' : s.Nonempty) :\n    condCount s t + condCount s t\u1d9c = 1", "start": [164, 1], "end": [167, 58], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_disjoint_union", "code": "theorem condCount_disjoint_union (hs : s.Finite) (ht : t.Finite) (hst : Disjoint s t) :\n    condCount s u * condCount (s \u222a t) s + condCount t u * condCount (s \u222a t) t =\n      condCount (s \u222a t) u", "start": [170, 1], "end": [189, 42], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCount_add_compl_eq", "code": "theorem condCount_add_compl_eq (u t : Set \u03a9) (hs : s.Finite) :\n    condCount (s \u2229 u) t * condCount s u + condCount (s \u2229 u\u1d9c) t * condCount s u\u1d9c =\n      condCount s t", "start": [192, 1], "end": [202, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/Definability.lean", "imports": ["Mathlib/Data/SetLike/Basic.lean", "Mathlib/ModelTheory/Semantics.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.Definable", "code": "def Definable (s : Set (\u03b1 \u2192 M)) : Prop :=\n  \u2203 \u03c6 : L[[A]].Formula \u03b1, s = setOf \u03c6.Realize", "start": [43, 1], "end": [46, 46], "kind": "commanddeclaration"}, {"full_name": "Set.Definable.map_expansion", "code": "theorem Definable.map_expansion {L' : FirstOrder.Language} [L'.Structure M] (h : A.Definable L s)\n    (\u03c6 : L \u2192\u1d38 L') [\u03c6.IsExpansionOn M] : A.Definable L' s", "start": [51, 1], "end": [56, 51], "kind": "commanddeclaration"}, {"full_name": "Set.definable_iff_exists_formula_sum", "code": "theorem definable_iff_exists_formula_sum :\n    A.Definable L s \u2194 \u2203 \u03c6 : L.Formula (A \u2295 \u03b1), s = {v | \u03c6.Realize (Sum.elim (\u2191) v)}", "start": [59, 1], "end": [72, 36], "kind": "commanddeclaration"}, {"full_name": "Set.empty_definable_iff", "code": "theorem empty_definable_iff :\n    (\u2205 : Set M).Definable L s \u2194 \u2203 \u03c6 : L.Formula \u03b1, s = setOf \u03c6.Realize", "start": [74, 1], "end": [77, 22], "kind": "commanddeclaration"}, {"full_name": "Set.definable_iff_empty_definable_with_params", "code": "theorem definable_iff_empty_definable_with_params :\n    A.Definable L s \u2194 (\u2205 : Set M).Definable (L[[A]]) s", "start": [80, 1], "end": [82, 27], "kind": "commanddeclaration"}, {"full_name": "Set.Definable.mono", "code": "theorem Definable.mono (hAs : A.Definable L s) (hAB : A \u2286 B) : B.Definable L s", "start": [85, 1], "end": [87, 71], "kind": "commanddeclaration"}, {"full_name": "Set.definable_empty", "code": "@[simp]\ntheorem definable_empty : A.Definable L (\u2205 : Set (\u03b1 \u2192 M))", "start": [90, 1], "end": [94, 10], "kind": "commanddeclaration"}, {"full_name": "Set.definable_univ", "code": "@[simp]\ntheorem definable_univ : A.Definable L (univ : Set (\u03b1 \u2192 M))", "start": [97, 1], "end": [101, 10], "kind": "commanddeclaration"}, {"full_name": "Set.Definable.inter", "code": "@[simp]\ntheorem Definable.inter {f g : Set (\u03b1 \u2192 M)} (hf : A.Definable L f) (hg : A.Definable L g) :\n    A.Definable L (f \u2229 g)", "start": [104, 1], "end": [111, 7], "kind": "commanddeclaration"}, {"full_name": "Set.Definable.union", "code": "@[simp]\ntheorem Definable.union {f g : Set (\u03b1 \u2192 M)} (hf : A.Definable L f) (hg : A.Definable L g) :\n    A.Definable L (f \u222a g)", "start": [114, 1], "end": [121, 88], "kind": "commanddeclaration"}, {"full_name": "Set.definable_finset_inf", "code": "theorem definable_finset_inf {\u03b9 : Type*} {f : \u2200 _ : \u03b9, Set (\u03b1 \u2192 M)} (hf : \u2200 i, A.Definable L (f i))\n    (s : Finset \u03b9) : A.Definable L (s.inf f)", "start": [124, 1], "end": [129, 25], "kind": "commanddeclaration"}, {"full_name": "Set.definable_finset_sup", "code": "theorem definable_finset_sup {\u03b9 : Type*} {f : \u2200 _ : \u03b9, Set (\u03b1 \u2192 M)} (hf : \u2200 i, A.Definable L (f i))\n    (s : Finset \u03b9) : A.Definable L (s.sup f)", "start": [132, 1], "end": [137, 25], "kind": "commanddeclaration"}, {"full_name": "Set.definable_finset_biInter", "code": "theorem definable_finset_biInter {\u03b9 : Type*} {f : \u2200 _ : \u03b9, Set (\u03b1 \u2192 M)}\n    (hf : \u2200 i, A.Definable L (f i)) (s : Finset \u03b9) : A.Definable L (\u22c2 i \u2208 s, f i)", "start": [140, 1], "end": [143, 34], "kind": "commanddeclaration"}, {"full_name": "Set.definable_finset_biUnion", "code": "theorem definable_finset_biUnion {\u03b9 : Type*} {f : \u2200 _ : \u03b9, Set (\u03b1 \u2192 M)}\n    (hf : \u2200 i, A.Definable L (f i)) (s : Finset \u03b9) : A.Definable L (\u22c3 i \u2208 s, f i)", "start": [146, 1], "end": [149, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Definable.compl", "code": "@[simp]\ntheorem Definable.compl {s : Set (\u03b1 \u2192 M)} (hf : A.Definable L s) : A.Definable L s\u1d9c", "start": [152, 1], "end": [157, 66], "kind": "commanddeclaration"}, {"full_name": "Set.Definable.sdiff", "code": "@[simp]\ntheorem Definable.sdiff {s t : Set (\u03b1 \u2192 M)} (hs : A.Definable L s) (ht : A.Definable L t) :\n    A.Definable L (s \\ t)", "start": [160, 1], "end": [163, 20], "kind": "commanddeclaration"}, {"full_name": "Set.Definable.preimage_comp", "code": "theorem Definable.preimage_comp (f : \u03b1 \u2192 \u03b2) {s : Set (\u03b1 \u2192 M)} (h : A.Definable L s) :\n    A.Definable L ((fun g : \u03b2 \u2192 M => g \u2218 f) \u207b\u00b9' s)", "start": [166, 1], "end": [171, 75], "kind": "commanddeclaration"}, {"full_name": "Set.Definable.image_comp_equiv", "code": "theorem Definable.image_comp_equiv {s : Set (\u03b2 \u2192 M)} (h : A.Definable L s) (f : \u03b1 \u2243 \u03b2) :\n    A.Definable L ((fun g : \u03b2 \u2192 M => g \u2218 f) '' s)", "start": [174, 1], "end": [183, 9], "kind": "commanddeclaration"}, {"full_name": "Set.definable_iff_finitely_definable", "code": "theorem definable_iff_finitely_definable :\n    A.Definable L s \u2194 \u2203 (A0 : Finset M), (A0 : Set M) \u2286 A \u2227\n      (A0 : Set M).Definable L s", "start": [186, 1], "end": [210, 32], "kind": "commanddeclaration"}, {"full_name": "Set.Definable.image_comp_sum_inl_fin", "code": "theorem Definable.image_comp_sum_inl_fin (m : \u2115) {s : Set (Sum \u03b1 (Fin m) \u2192 M)}\n    (h : A.Definable L s) : A.Definable L ((fun g : Sum \u03b1 (Fin m) \u2192 M => g \u2218 Sum.inl) '' s)", "start": [212, 1], "end": [225, 88], "kind": "commanddeclaration"}, {"full_name": "Set.Definable.image_comp_embedding", "code": "theorem Definable.image_comp_embedding {s : Set (\u03b2 \u2192 M)} (h : A.Definable L s) (f : \u03b1 \u21aa \u03b2)\n    [Finite \u03b2] : A.Definable L ((fun g : \u03b2 \u2192 M => g \u2218 f) '' s)", "start": [228, 1], "end": [241, 9], "kind": "commanddeclaration"}, {"full_name": "Set.Definable.image_comp", "code": "theorem Definable.image_comp {s : Set (\u03b2 \u2192 M)} (h : A.Definable L s) (f : \u03b1 \u2192 \u03b2) [Finite \u03b1]\n    [Finite \u03b2] : A.Definable L ((fun g : \u03b2 \u2192 M => g \u2218 f) '' s)", "start": [244, 1], "end": [278, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Definable\u2081", "code": "def Definable\u2081 (s : Set M) : Prop :=\n  A.Definable L { x : Fin 1 \u2192 M | x 0 \u2208 s }", "start": [283, 1], "end": [285, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Definable\u2082", "code": "def Definable\u2082 (s : Set (M \u00d7 M)) : Prop :=\n  A.Definable L { x : Fin 2 \u2192 M | (x 0, x 1) \u2208 s }", "start": [288, 1], "end": [290, 51], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet", "code": "def DefinableSet :=\n  { s : Set (\u03b1 \u2192 M) // A.Definable L s }", "start": [303, 1], "end": [306, 41], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.instSetLike", "code": "instance instSetLike : SetLike (L.DefinableSet A \u03b1) (\u03b1 \u2192 M) where\n  coe := Subtype.val\n  coe_injective' := Subtype.val_injective", "start": [313, 1], "end": [315, 42], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.instTop", "code": "instance instTop : Top (L.DefinableSet A \u03b1) :=\n  \u27e8\u27e8\u22a4, definable_univ\u27e9\u27e9", "start": [318, 1], "end": [319, 24], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.instBot", "code": "instance instBot : Bot (L.DefinableSet A \u03b1) :=\n  \u27e8\u27e8\u22a5, definable_empty\u27e9\u27e9", "start": [322, 1], "end": [323, 25], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.instSup", "code": "instance instSup : Sup (L.DefinableSet A \u03b1) :=\n  \u27e8fun s t => \u27e8s \u222a t, s.2.union t.2\u27e9\u27e9", "start": [326, 1], "end": [327, 38], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.instInf", "code": "instance instInf : Inf (L.DefinableSet A \u03b1) :=\n  \u27e8fun s t => \u27e8s \u2229 t, s.2.inter t.2\u27e9\u27e9", "start": [330, 1], "end": [331, 38], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.instHasCompl", "code": "instance instHasCompl : HasCompl (L.DefinableSet A \u03b1) :=\n  \u27e8fun s => \u27e8s\u1d9c, s.2.compl\u27e9\u27e9", "start": [334, 1], "end": [335, 29], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.instSDiff", "code": "instance instSDiff : SDiff (L.DefinableSet A \u03b1) :=\n  \u27e8fun s t => \u27e8s \\ t, s.2.sdiff t.2\u27e9\u27e9", "start": [338, 1], "end": [339, 38], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.instInhabited", "code": "instance instInhabited : Inhabited (L.DefinableSet A \u03b1) :=\n  \u27e8\u22a5\u27e9", "start": [342, 1], "end": [343, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.le_iff", "code": "theorem le_iff : s \u2264 t \u2194 (s : Set (\u03b1 \u2192 M)) \u2264 (t : Set (\u03b1 \u2192 M))", "start": [346, 1], "end": [347, 10], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.mem_top", "code": "@[simp]\ntheorem mem_top : x \u2208 (\u22a4 : L.DefinableSet A \u03b1)", "start": [350, 1], "end": [352, 13], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.not_mem_bot", "code": "@[simp]\ntheorem not_mem_bot {x : \u03b1 \u2192 M} : \u00acx \u2208 (\u22a5 : L.DefinableSet A \u03b1)", "start": [355, 1], "end": [357, 18], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.mem_sup", "code": "@[simp]\ntheorem mem_sup : x \u2208 s \u2294 t \u2194 x \u2208 s \u2228 x \u2208 t", "start": [360, 1], "end": [362, 10], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.mem_inf", "code": "@[simp]\ntheorem mem_inf : x \u2208 s \u2293 t \u2194 x \u2208 s \u2227 x \u2208 t", "start": [365, 1], "end": [367, 10], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.mem_compl", "code": "@[simp]\ntheorem mem_compl : x \u2208 s\u1d9c \u2194 \u00acx \u2208 s", "start": [370, 1], "end": [372, 10], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.mem_sdiff", "code": "@[simp]\ntheorem mem_sdiff : x \u2208 s \\ t \u2194 x \u2208 s \u2227 \u00acx \u2208 t", "start": [375, 1], "end": [377, 10], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.coe_top", "code": "@[simp, norm_cast]\ntheorem coe_top : ((\u22a4 : L.DefinableSet A \u03b1) : Set (\u03b1 \u2192 M)) = univ", "start": [380, 1], "end": [382, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.coe_bot", "code": "@[simp, norm_cast]\ntheorem coe_bot : ((\u22a5 : L.DefinableSet A \u03b1) : Set (\u03b1 \u2192 M)) = \u2205", "start": [385, 1], "end": [387, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.coe_sup", "code": "@[simp, norm_cast]\ntheorem coe_sup (s t : L.DefinableSet A \u03b1) :\n    ((s \u2294 t : L.DefinableSet A \u03b1) : Set (\u03b1 \u2192 M)) = (s : Set (\u03b1 \u2192 M)) \u222a (t : Set (\u03b1 \u2192 M))", "start": [390, 1], "end": [393, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf (s t : L.DefinableSet A \u03b1) :\n    ((s \u2293 t : L.DefinableSet A \u03b1) : Set (\u03b1 \u2192 M)) = (s : Set (\u03b1 \u2192 M)) \u2229 (t : Set (\u03b1 \u2192 M))", "start": [396, 1], "end": [399, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.coe_compl", "code": "@[simp, norm_cast]\ntheorem coe_compl (s : L.DefinableSet A \u03b1) :\n    ((s\u1d9c : L.DefinableSet A \u03b1) : Set (\u03b1 \u2192 M)) = (s : Set (\u03b1 \u2192 M))\u1d9c", "start": [402, 1], "end": [405, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.coe_sdiff", "code": "@[simp, norm_cast]\ntheorem coe_sdiff (s t : L.DefinableSet A \u03b1) :\n    ((s \\ t : L.DefinableSet A \u03b1) : Set (\u03b1 \u2192 M)) = (s : Set (\u03b1 \u2192 M)) \\ (t : Set (\u03b1 \u2192 M))", "start": [408, 1], "end": [411, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DefinableSet.instBooleanAlgebra", "code": "instance instBooleanAlgebra : BooleanAlgebra (L.DefinableSet A \u03b1) :=\n  Function.Injective.booleanAlgebra (\u03b1 := L.DefinableSet A \u03b1) _ Subtype.coe_injective\n    coe_sup coe_inf coe_top coe_bot coe_compl coe_sdiff", "start": [414, 1], "end": [416, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/SeparableDegree.lean", "imports": ["Mathlib/FieldTheory/Separable.lean", "Mathlib/Algebra/CharP/ExpChar.lean", "Mathlib/Algebra/Algebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.IsSeparableContraction", "code": "def IsSeparableContraction (f : F[X]) (g : F[X]) : Prop :=\n  g.Separable \u2227 \u2203 m : \u2115, expand F (q ^ m) g = f", "start": [49, 1], "end": [52, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.HasSeparableContraction", "code": "def HasSeparableContraction (f : F[X]) : Prop :=\n  \u2203 g : F[X], IsSeparableContraction q f g", "start": [55, 1], "end": [57, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.HasSeparableContraction.contraction", "code": "def HasSeparableContraction.contraction : F[X] :=\n  Classical.choose hf", "start": [62, 1], "end": [64, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.HasSeparableContraction.degree", "code": "def HasSeparableContraction.degree : \u2115 :=\n  hf.contraction.natDegree", "start": [67, 1], "end": [69, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsSeparableContraction.dvd_degree'", "code": "theorem IsSeparableContraction.dvd_degree' {g} (hf : IsSeparableContraction q f g) :\n    \u2203 m : \u2115, g.natDegree * q ^ m = f.natDegree", "start": [72, 1], "end": [77, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.HasSeparableContraction.dvd_degree'", "code": "theorem HasSeparableContraction.dvd_degree' : \u2203 m : \u2115, hf.degree * q ^ m = f.natDegree", "start": [80, 1], "end": [81, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.HasSeparableContraction.dvd_degree", "code": "theorem HasSeparableContraction.dvd_degree : hf.degree \u2223 f.natDegree", "start": [84, 1], "end": [87, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.HasSeparableContraction.eq_degree", "code": "theorem HasSeparableContraction.eq_degree {f : F[X]} (hf : HasSeparableContraction 1 f) :\n    hf.degree = f.natDegree", "start": [90, 1], "end": [94, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Irreducible.hasSeparableContraction", "code": "theorem Irreducible.hasSeparableContraction (q : \u2115) [hF : ExpChar F q] (f : F[X])\n    (irred : Irreducible f) : HasSeparableContraction q f", "start": [105, 1], "end": [112, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.contraction_degree_eq_or_insep", "code": "theorem contraction_degree_eq_or_insep [hq : NeZero q] [CharP F q] (g g' : F[X]) (m m' : \u2115)\n    (h_expand : expand F (q ^ m) g = expand F (q ^ m') g') (hg : g.Separable) (hg' : g'.Separable) :\n    g.natDegree = g'.natDegree", "start": [115, 1], "end": [127, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsSeparableContraction.degree_eq", "code": "theorem IsSeparableContraction.degree_eq [hF : ExpChar F q] (g : F[X])\n    (hg : IsSeparableContraction q f g) : g.natDegree = hf.degree", "start": [130, 1], "end": [142, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean", "imports": ["Mathlib/LinearAlgebra/QuadraticForm/IsometryEquiv.lean", "Mathlib/LinearAlgebra/QuadraticForm/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "BilinForm.dualProd", "code": "@[simps!]\ndef dualProd : BilinForm R (Module.Dual R M \u00d7 M) :=\n  LinearMap.toBilin <|\n    (LinearMap.apply\u2097.comp (LinearMap.snd R (Module.Dual R M) M)).compl\u2082\n        (LinearMap.fst R (Module.Dual R M) M) +\n      ((LinearMap.apply\u2097.comp (LinearMap.snd R (Module.Dual R M) M)).compl\u2082\n          (LinearMap.fst R (Module.Dual R M) M)).flip", "start": [34, 1], "end": [42, 54], "kind": "commanddeclaration"}, {"full_name": "BilinForm.isSymm_dualProd", "code": "theorem isSymm_dualProd : (dualProd R M).IsSymm", "start": [45, 1], "end": [45, 77], "kind": "commanddeclaration"}, {"full_name": "BilinForm.nondenerate_dualProd", "code": "theorem nondenerate_dualProd :\n    (dualProd R M).Nondegenerate \u2194 Function.Injective (Module.Dual.eval R M)", "start": [54, 1], "end": [75, 44], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.dualProd", "code": "@[simps]\ndef dualProd : QuadraticForm R (Module.Dual R M \u00d7 M) where\n  toFun p := p.1 p.2\n  toFun_smul a p := by\n    dsimp only  rw [Prod.smul_fst, Prod.smul_snd, LinearMap.smul_apply, LinearMap.map_smul, smul_eq_mul,\n      smul_eq_mul, mul_assoc]\n  exists_companion' :=\n    \u27e8BilinForm.dualProd R M, fun p q => by\n      dsimp only  rw [BilinForm.dualProd_apply, Prod.fst_add, Prod.snd_add, LinearMap.add_apply, map_add,\n        map_add, add_right_comm _ (q.1 q.2), add_comm (q.1 p.2) (p.1 q.2), \u2190 add_assoc, \u2190\n        add_assoc]\u27e9", "start": [88, 1], "end": [101, 20], "kind": "commanddeclaration"}, {"full_name": "BilinForm.dualProd.toQuadraticForm", "code": "@[simp]\ntheorem _root_.BilinForm.dualProd.toQuadraticForm :\n    (BilinForm.dualProd R M).toQuadraticForm = 2 \u2022 dualProd R M", "start": [104, 1], "end": [107, 35], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.dualProdIsometry", "code": "@[simps!]\ndef dualProdIsometry (f : M \u2243\u2097[R] N) : (dualProd R M).IsometryEquiv (dualProd R N) where\n  toLinearEquiv := f.dualMap.symm.prod f\n  map_app' x := FunLike.congr_arg x.fst <| f.symm_apply_apply _", "start": [112, 1], "end": [116, 64], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.dualProdProdIsometry", "code": "@[simps!]\ndef dualProdProdIsometry : (dualProd R (M \u00d7 N)).IsometryEquiv ((dualProd R M).prod (dualProd R N))\n    where\n  toLinearEquiv :=\n    (Module.dualProdDualEquivDual R M N).symm.prod (LinearEquiv.refl R (M \u00d7 N)) \u226a\u226b\u2097\n      LinearEquiv.prodProdProdComm R _ _ M N\n  map_app' m :=\n    (m.fst.map_add _ _).symm.trans <| FunLike.congr_arg m.fst <| Prod.ext (add_zero _) (zero_add _)", "start": [119, 1], "end": [127, 100], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.toDualProd", "code": "@[simps!]\ndef toDualProd (Q : QuadraticForm R M) [Invertible (2 : R)] :\n    (Q.prod <| -Q) \u2192q\u1d62 QuadraticForm.dualProd R M where\n  toLinearMap := LinearMap.prod\n    (Q.associated.toLin.comp (LinearMap.fst _ _ _) + Q.associated.toLin.comp (LinearMap.snd _ _ _))\n    (LinearMap.fst _ _ _ - LinearMap.snd _ _ _)\n  map_app' x := by\n    dsimp only [associated, associatedHom]\n    dsimp\n    simp [polar_comm _ x.1 x.2, \u2190 sub_add, mul_sub, sub_mul, smul_sub, (Submonoid.smul_def), \u2190\n      sub_eq_add_neg (Q x.1) (Q x.2)]", "start": [138, 1], "end": [154, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Schreier.lean", "imports": ["Mathlib/GroupTheory/Transfer.lean", "Mathlib/GroupTheory/Abelianization.lean", "Mathlib/GroupTheory/Exponent.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subgroup.closure_mul_image_mul_eq_top", "code": "theorem closure_mul_image_mul_eq_top\n    (hR : R \u2208 rightTransversals (H : Set G)) (hR1 : (1 : G) \u2208 R) (hS : closure S = \u22a4) :\n    (closure ((R * S).image fun g => g * (toFun hR g : G)\u207b\u00b9)) * R = \u22a4", "start": [37, 1], "end": [58, 41], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_mul_image_eq", "code": "theorem closure_mul_image_eq (hR : R \u2208 rightTransversals (H : Set G)) (hR1 : (1 : G) \u2208 R)\n    (hS : closure S = \u22a4) : closure ((R * S).image fun g => g * (toFun hR g : G)\u207b\u00b9) = H", "start": [61, 1], "end": [79, 48], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_mul_image_eq_top", "code": "theorem closure_mul_image_eq_top (hR : R \u2208 rightTransversals (H : Set G)) (hR1 : (1 : G) \u2208 R)\n    (hS : closure S = \u22a4) : closure ((R * S).image fun g =>\n      \u27e8g * (toFun hR g : G)\u207b\u00b9, mul_inv_toFun_mem hR g\u27e9 : Set H) = \u22a4", "start": [82, 1], "end": [89, 77], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_mul_image_eq_top'", "code": "theorem closure_mul_image_eq_top' [DecidableEq G] {R S : Finset G}\n    (hR : (R : Set G) \u2208 rightTransversals (H : Set G)) (hR1 : (1 : G) \u2208 R)\n    (hS : closure (S : Set G) = \u22a4) :\n    closure (((R * S).image fun g => \u27e8_, mul_inv_toFun_mem hR g\u27e9 : Finset H) : Set H) = \u22a4", "start": [92, 1], "end": [100, 43], "kind": "commanddeclaration"}, {"full_name": "Subgroup.exists_finset_card_le_mul", "code": "theorem exists_finset_card_le_mul [FiniteIndex H] {S : Finset G} (hS : closure (S : Set G) = \u22a4) :\n    \u2203 T : Finset H, T.card \u2264 H.index * S.card \u2227 closure (T : Set H) = \u22a4", "start": [105, 1], "end": [124, 40], "kind": "commanddeclaration"}, {"full_name": "Subgroup.fg_of_index_ne_zero", "code": "instance fg_of_index_ne_zero [hG : Group.FG G] [FiniteIndex H] : Group.FG H := by\n  obtain \u27e8S, hS\u27e9 := hG.1\n  obtain \u27e8T, -, hT\u27e9 := exists_finset_card_le_mul H hS\n  exact \u27e8\u27e8T, hT\u27e9\u27e9", "start": [127, 1], "end": [132, 18], "kind": "commanddeclaration"}, {"full_name": "Subgroup.rank_le_index_mul_rank", "code": "theorem rank_le_index_mul_rank [hG : Group.FG G] [FiniteIndex H] :\n    Group.rank H \u2264 H.index * Group.rank G", "start": [135, 1], "end": [143, 66], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_commutator_dvd_index_center_pow", "code": "theorem card_commutator_dvd_index_center_pow [Finite (commutatorSet G)] :\n    Nat.card (_root_.commutator G) \u2223\n      (center G).index ^ ((center G).index * Nat.card (commutatorSet G) + 1)", "start": [148, 1], "end": [178, 61], "kind": "commanddeclaration"}, {"full_name": "Subgroup.cardCommutatorBound", "code": "def cardCommutatorBound (n : \u2115) :=\n  (n ^ (2 * n)) ^ (n ^ (2 * n + 1) + 1)", "start": [181, 1], "end": [183, 40], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_commutator_le_of_finite_commutatorSet", "code": "theorem card_commutator_le_of_finite_commutatorSet [Finite (commutatorSet G)] :\n    Nat.card (_root_.commutator G) \u2264 cardCommutatorBound (Nat.card (commutatorSet G))", "start": [186, 1], "end": [200, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Subgroup/Saturated.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subgroup.Saturated", "code": "@[to_additive\n      \"An additive subgroup `H` of `G` is *saturated* if for all `n : \u2115` and `g : G` with `n\u2022g \u2208 H`\n      we have `n = 0` or `g \u2208 H`.\"]\ndef Saturated (H : Subgroup G) : Prop :=\n  \u2200 \u2983n g\u2984, g ^ n \u2208 H \u2192 n = 0 \u2228 g \u2208 H", "start": [23, 1], "end": [29, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.saturated_iff_npow", "code": "@[to_additive]\ntheorem saturated_iff_npow {H : Subgroup G} :\n    Saturated H \u2194 \u2200 (n : \u2115) (g : G), g ^ n \u2208 H \u2192 n = 0 \u2228 g \u2208 H", "start": [33, 1], "end": [36, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.saturated_iff_zpow", "code": "@[to_additive]\ntheorem saturated_iff_zpow {H : Subgroup G} :\n    Saturated H \u2194 \u2200 (n : \u2124) (g : G), g ^ n \u2208 H \u2192 n = 0 \u2228 g \u2208 H", "start": [40, 1], "end": [55, 16], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.ker_saturated", "code": "theorem ker_saturated {A\u2081 A\u2082 : Type*} [AddCommGroup A\u2081] [AddCommGroup A\u2082] [NoZeroSMulDivisors \u2115 A\u2082]\n    (f : A\u2081 \u2192+ A\u2082) : f.ker.Saturated", "start": [63, 1], "end": [66, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean", "imports": ["Mathlib/Analysis/Calculus/Deriv/Pow.lean", "Mathlib/Analysis/Calculus/MeanValue.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Convex.taylor_approx_two_segment", "code": "theorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v \u2208 interior s)\n    (hw : x + v + w \u2208 interior s) :\n    (fun h : \u211d => f (x + h \u2022 v + h \u2022 w)\n        - f (x + h \u2022 v) - h \u2022 f' x w - h ^ 2 \u2022 f'' v w - (h ^ 2 / 2) \u2022 f'' w w) =o[\ud835\udcdd[>] 0]\n      fun h => h ^ 2", "start": [61, 1], "end": [172, 62], "kind": "commanddeclaration"}, {"full_name": "Convex.isLittleO_alternate_sum_square", "code": "theorem Convex.isLittleO_alternate_sum_square {v w : E} (h4v : x + (4 : \u211d) \u2022 v \u2208 interior s)\n    (h4w : x + (4 : \u211d) \u2022 w \u2208 interior s) :\n    (fun h : \u211d => f (x + h \u2022 (2 \u2022 v + 2 \u2022 w)) + f (x + h \u2022 (v + w))\n        - f (x + h \u2022 (2 \u2022 v + w)) - f (x + h \u2022 (v + 2 \u2022 w)) - h ^ 2 \u2022 f'' v w) =o[\ud835\udcdd[>] 0]\n      fun h => h ^ 2", "start": [175, 1], "end": [226, 7], "kind": "commanddeclaration"}, {"full_name": "Convex.second_derivative_within_at_symmetric_of_mem_interior", "code": "theorem Convex.second_derivative_within_at_symmetric_of_mem_interior {v w : E}\n    (h4v : x + (4 : \u211d) \u2022 v \u2208 interior s) (h4w : x + (4 : \u211d) \u2022 w \u2208 interior s) :\n    f'' w v = f'' v w", "start": [229, 1], "end": [253, 63], "kind": "commanddeclaration"}, {"full_name": "Convex.second_derivative_within_at_symmetric", "code": "theorem Convex.second_derivative_within_at_symmetric {s : Set E} (s_conv : Convex \u211d s)\n    (hne : (interior s).Nonempty) {f : E \u2192 F} {f' : E \u2192 E \u2192L[\u211d] F} {f'' : E \u2192L[\u211d] E \u2192L[\u211d] F}\n    (hf : \u2200 x \u2208 interior s, HasFDerivAt f (f' x) x) {x : E} (xs : x \u2208 s)\n    (hx : HasFDerivWithinAt f' f'' (interior s) x) (v w : E) : f'' v w = f'' w v", "start": [256, 1], "end": [303, 36], "kind": "commanddeclaration"}, {"full_name": "second_derivative_symmetric_of_eventually", "code": "theorem second_derivative_symmetric_of_eventually {f : E \u2192 F} {f' : E \u2192 E \u2192L[\u211d] F}\n    {f'' : E \u2192L[\u211d] E \u2192L[\u211d] F} (hf : \u2200\u1da0 y in \ud835\udcdd x, HasFDerivAt f (f' y) y) (hx : HasFDerivAt f' f'' x)\n    (v w : E) : f'' v w = f'' w v", "start": [306, 1], "end": [316, 97], "kind": "commanddeclaration"}, {"full_name": "second_derivative_symmetric", "code": "theorem second_derivative_symmetric {f : E \u2192 F} {f' : E \u2192 E \u2192L[\u211d] F} {f'' : E \u2192L[\u211d] E \u2192L[\u211d] F}\n    (hf : \u2200 y, HasFDerivAt f (f' y) y) (hx : HasFDerivAt f' f'' x) (v w : E) : f'' v w = f'' w v", "start": [319, 1], "end": [323, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/Complex.lean", "imports": ["Mathlib/Topology/LocallyConstant/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Geometry/Manifold/MFDeriv.lean", "Mathlib/Analysis/Complex/AbsMax.lean", "Mathlib/Analysis/LocallyConvex/WithSeminorms.lean"], "premises": [{"full_name": "Complex.norm_eventually_eq_of_mdifferentiableAt_of_isLocalMax", "code": "theorem Complex.norm_eventually_eq_of_mdifferentiableAt_of_isLocalMax {f : M \u2192 F} {c : M}\n    (hd : \u2200\u1da0 z in \ud835\udcdd c, MDifferentiableAt I \ud835\udcd8(\u2102, F) f z) (hc : IsLocalMax (norm \u2218 f) c) :\n    \u2200\u1da0 y in \ud835\udcdd c, \u2016f y\u2016 = \u2016f c\u2016", "start": [53, 1], "end": [77, 84], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableOn.norm_eqOn_of_isPreconnected_of_isMaxOn", "code": "theorem norm_eqOn_of_isPreconnected_of_isMaxOn {f : M \u2192 F} {U : Set M} {c : M}\n    (hd : MDifferentiableOn I \ud835\udcd8(\u2102, F) f U) (hc : IsPreconnected U) (ho : IsOpen U)\n    (hcU : c \u2208 U) (hm : IsMaxOn (norm \u2218 f) U c) : EqOn (norm \u2218 f) (const M \u2016f c\u2016) U", "start": [85, 1], "end": [106, 62], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableOn.eqOn_of_isPreconnected_of_isMaxOn_norm", "code": "theorem eqOn_of_isPreconnected_of_isMaxOn_norm [StrictConvexSpace \u211d F] {f : M \u2192 F} {U : Set M}\n    {c : M} (hd : MDifferentiableOn I \ud835\udcd8(\u2102, F) f U) (hc : IsPreconnected U) (ho : IsOpen U)\n    (hcU : c \u2208 U) (hm : IsMaxOn (norm \u2218 f) U c) : EqOn f (const M (f c)) U", "start": [108, 1], "end": [122, 97], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableOn.apply_eq_of_isPreconnected_isCompact_isOpen", "code": "theorem apply_eq_of_isPreconnected_isCompact_isOpen {f : M \u2192 F} {U : Set M} {a b : M}\n    (hd : MDifferentiableOn I \ud835\udcd8(\u2102, F) f U) (hpc : IsPreconnected U) (hc : IsCompact U)\n    (ho : IsOpen U) (ha : a \u2208 U) (hb : b \u2208 U) : f a = f b", "start": [124, 1], "end": [138, 67], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.isLocallyConstant", "code": "protected theorem isLocallyConstant {f : M \u2192 F} (hf : MDifferentiable I \ud835\udcd8(\u2102, F) f) :\n    IsLocallyConstant f", "start": [154, 1], "end": [161, 48], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.apply_eq_of_compactSpace", "code": "theorem apply_eq_of_compactSpace [PreconnectedSpace M] {f : M \u2192 F}\n    (hf : MDifferentiable I \ud835\udcd8(\u2102, F) f) (a b : M) : f a = f b", "start": [164, 1], "end": [167, 57], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.exists_eq_const_of_compactSpace", "code": "theorem exists_eq_const_of_compactSpace [PreconnectedSpace M] {f : M \u2192 F}\n    (hf : MDifferentiable I \ud835\udcd8(\u2102, F) f) : \u2203 v : F, f = Function.const M v", "start": [170, 1], "end": [174, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Computability/TMToPartrec.lean", "imports": ["Mathlib/Computability/TuringMachine.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Computability/Halting.lean", "Mathlib/Data/Num/Lemmas.lean", "Mathlib/Tactic/DeriveFintype.lean"], "premises": [{"full_name": "Turing.ToPartrec.Code", "code": "inductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code \u2192 Code \u2192 Code\n  | comp : Code \u2192 Code \u2192 Code\n  | case : Code \u2192 Code \u2192 Code\n  | fix : Code \u2192 Code\n  deriving DecidableEq, Inhabited", "start": [73, 1], "end": [83, 34], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.eval", "code": "def Code.eval : Code \u2192 List \u2115 \u2192. List \u2115\n  | Code.zero' => fun v => pure (0 :: v)\n  | Code.succ => fun v => pure [v.headI.succ]\n  | Code.tail => fun v => pure v.tail\n  | Code.cons f fs => fun v => do\n    let n \u2190 Code.eval f v\n    let ns \u2190 Code.eval fs v\n    pure (n.headI :: ns)\n  | Code.comp f g => fun v => g.eval v >>= f.eval\n  | Code.case f g => fun v => v.headI.rec (f.eval v.tail) fun y _ => g.eval (y::v.tail)\n  | Code.fix f =>\n    PFun.fix fun v => (f.eval v).map fun v => if v.headI = 0 then Sum.inl v.tail else Sum.inr v.tail", "start": [93, 1], "end": [130, 101], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.zero'_eval", "code": "@[simp]\ntheorem zero'_eval : zero'.eval = fun v => pure (0 :: v)", "start": [139, 1], "end": [140, 75], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.succ_eval", "code": "@[simp]\ntheorem succ_eval : succ.eval = fun v => pure [v.headI.succ]", "start": [142, 1], "end": [143, 79], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.tail_eval", "code": "@[simp]\ntheorem tail_eval : tail.eval = fun v => pure v.tail", "start": [145, 1], "end": [146, 71], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.cons_eval", "code": "@[simp]\ntheorem cons_eval (f fs) : (cons f fs).eval = fun v => do {\n    let n \u2190 Code.eval f v\n    let ns \u2190 Code.eval fs v\n    pure (n.headI :: ns) }", "start": [148, 1], "end": [152, 45], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.comp_eval", "code": "@[simp]\ntheorem comp_eval (f g) : (comp f g).eval = fun v => g.eval v >>= f.eval", "start": [154, 1], "end": [155, 91], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.case_eval", "code": "@[simp]\ntheorem case_eval (f g) :\n    (case f g).eval = fun v => v.headI.rec (f.eval v.tail) fun y _ => g.eval (y::v.tail)", "start": [157, 1], "end": [160, 14], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.fix_eval", "code": "@[simp]\ntheorem fix_eval (f) : (fix f).eval =\n    PFun.fix fun v => (f.eval v).map fun v =>\n      if v.headI = 0 then Sum.inl v.tail else Sum.inr v.tail", "start": [162, 1], "end": [166, 14], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.nil", "code": "def nil : Code :=\n  tail.comp succ", "start": [168, 1], "end": [170, 17], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.nil_eval", "code": "@[simp]\ntheorem nil_eval (v) : nil.eval v = pure []", "start": [173, 1], "end": [174, 61], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.id", "code": "def id : Code :=\n  tail.comp zero'", "start": [177, 1], "end": [179, 18], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.id_eval", "code": "@[simp]\ntheorem id_eval (v) : id.eval v = pure v", "start": [182, 1], "end": [183, 57], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.head", "code": "def head : Code :=\n  cons id nil", "start": [186, 1], "end": [188, 14], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.head_eval", "code": "@[simp]\ntheorem head_eval (v) : head.eval v = pure [v.headI]", "start": [191, 1], "end": [192, 71], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.zero", "code": "def zero : Code :=\n  cons zero' nil", "start": [195, 1], "end": [197, 17], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.zero_eval", "code": "@[simp]\ntheorem zero_eval (v) : zero.eval v = pure [0]", "start": [200, 1], "end": [201, 65], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.pred", "code": "def pred : Code :=\n  case zero head", "start": [204, 1], "end": [207, 17], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.pred_eval", "code": "@[simp]\ntheorem pred_eval (v) : pred.eval v = pure [v.headI.pred]", "start": [210, 1], "end": [212, 38], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.rfind", "code": "def rfind (f : Code) : Code :=\n  comp pred <| comp (fix <| cons f <| cons succ tail) zero'", "start": [215, 1], "end": [227, 60], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.prec", "code": "def prec (f g : Code) : Code :=\n  let G :=\n    cons tail <|\n      cons succ <|\n        cons (comp pred tail) <|\n          cons (comp g <| cons id <| comp tail tail) <| comp tail <| comp tail tail\n  let F := case id <| comp (comp (comp tail tail) (fix G)) zero'\n  cons (comp F (cons head <| cons (comp f tail) tail)) nil", "start": [230, 1], "end": [259, 59], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.exists_code.comp", "code": "theorem exists_code.comp {m n} {f : Vector \u2115 n \u2192. \u2115} {g : Fin n \u2192 Vector \u2115 m \u2192. \u2115}\n    (hf : \u2203 c : Code, \u2200 v : Vector \u2115 n, c.eval v.1 = pure <$> f v)\n    (hg : \u2200 i, \u2203 c : Code, \u2200 v : Vector \u2115 m, c.eval v.1 = pure <$> g i v) :\n    \u2203 c : Code, \u2200 v : Vector \u2115 m, c.eval v.1 = pure <$> ((Vector.mOfFn fun i => g i v) >>= f)", "start": [264, 1], "end": [282, 13], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.exists_code", "code": "theorem exists_code {n} {f : Vector \u2115 n \u2192. \u2115} (hf : Nat.Partrec' f) :\n    \u2203 c : Code, \u2200 v : Vector \u2115 n, c.eval v.1 = pure <$> f v", "start": [285, 1], "end": [389, 57], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Cont", "code": "inductive Cont\n  | halt\n  | cons\u2081 : Code \u2192 List \u2115 \u2192 Cont \u2192 Cont\n  | cons\u2082 : List \u2115 \u2192 Cont \u2192 Cont\n  | comp : Code \u2192 Cont \u2192 Cont\n  | fix : Code \u2192 Cont \u2192 Cont\n  deriving Inhabited", "start": [431, 1], "end": [438, 21], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Cont.eval", "code": "def Cont.eval : Cont \u2192 List \u2115 \u2192. List \u2115\n  | Cont.halt => pure\n  | Cont.cons\u2081 fs as k => fun v => do\n    let ns \u2190 Code.eval fs as\n    Cont.eval k (v.headI :: ns)\n  | Cont.cons\u2082 ns k => fun v => Cont.eval k (ns.headI :: v)\n  | Cont.comp f k => fun v => Code.eval f v >>= Cont.eval k\n  | Cont.fix f k => fun v => if v.headI = 0 then k.eval v.tail else f.fix.eval v.tail >>= k.eval", "start": [446, 1], "end": [454, 97], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Cfg", "code": "inductive Cfg\n  | halt : List \u2115 \u2192 Cfg\n  | ret : Cont \u2192 List \u2115 \u2192 Cfg\n  deriving Inhabited", "start": [457, 1], "end": [467, 21], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.stepNormal", "code": "def stepNormal : Code \u2192 Cont \u2192 List \u2115 \u2192 Cfg\n  | Code.zero' => fun k v => Cfg.ret k (0::v)\n  | Code.succ => fun k v => Cfg.ret k [v.headI.succ]\n  | Code.tail => fun k v => Cfg.ret k v.tail\n  | Code.cons f fs => fun k v => stepNormal f (Cont.cons\u2081 fs v k) v\n  | Code.comp f g => fun k v => stepNormal g (Cont.comp f k) v\n  | Code.case f g => fun k v =>\n    v.headI.rec (stepNormal f k v.tail) fun y _ => stepNormal g k (y::v.tail)\n  | Code.fix f => fun k v => stepNormal f (Cont.fix f k) v", "start": [472, 1], "end": [497, 59], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.stepRet", "code": "def stepRet : Cont \u2192 List \u2115 \u2192 Cfg\n  | Cont.halt, v => Cfg.halt v\n  | Cont.cons\u2081 fs as k, v => stepNormal fs (Cont.cons\u2082 v k) as\n  | Cont.cons\u2082 ns k, v => stepRet k (ns.headI :: v)\n  | Cont.comp f k, v => stepNormal f k v\n  | Cont.fix f k, v => if v.headI = 0 then stepRet k v.tail else stepNormal f (Cont.fix f k) v.tail", "start": [500, 1], "end": [518, 100], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.step", "code": "def step : Cfg \u2192 Option Cfg\n  | Cfg.halt _ => none\n  | Cfg.ret k v => some (stepRet k v)", "start": [521, 1], "end": [526, 38], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Cont.then", "code": "def Cont.then : Cont \u2192 Cont \u2192 Cont\n  | Cont.halt => fun k' => k'\n  | Cont.cons\u2081 fs as k => fun k' => Cont.cons\u2081 fs as (k.then k')\n  | Cont.cons\u2082 ns k => fun k' => Cont.cons\u2082 ns (k.then k')\n  | Cont.comp f k => fun k' => Cont.comp f (k.then k')\n  | Cont.fix f k => fun k' => Cont.fix f (k.then k')", "start": [529, 1], "end": [546, 53], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Cont.then_eval", "code": "theorem Cont.then_eval {k k' : Cont} {v} : (k.then k').eval v = k.eval v >>= k'.eval", "start": [549, 1], "end": [553, 56], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Cfg.then", "code": "def Cfg.then : Cfg \u2192 Cont \u2192 Cfg\n  | Cfg.halt v => fun k' => stepRet k' v\n  | Cfg.ret k v => fun k' => Cfg.ret (k.then k') v", "start": [556, 1], "end": [561, 51], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.stepNormal_then", "code": "theorem stepNormal_then (c) (k k' : Cont) (v) :\n    stepNormal c (k.then k') v = (stepNormal c k v).then k'", "start": [564, 1], "end": [574, 40], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.stepRet_then", "code": "theorem stepRet_then {k k' : Cont} {v} : stepRet (k.then k') v = (stepRet k v).then k'", "start": [577, 1], "end": [592, 10], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.Ok", "code": "def Code.Ok (c : Code) :=\n  \u2200 k v, Turing.eval step (stepNormal c k v) =\n    Code.eval c v >>= fun v => Turing.eval step (Cfg.ret k v)", "start": [595, 1], "end": [604, 62], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.Code.Ok.zero", "code": "theorem Code.Ok.zero {c} (h : Code.Ok c) {v} :\n    Turing.eval step (stepNormal c Cont.halt v) = Cfg.halt <$> Code.eval c v", "start": [607, 1], "end": [610, 71], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.stepNormal.is_ret", "code": "theorem stepNormal.is_ret (c k v) : \u2203 k' v', stepNormal c k v = Cfg.ret k' v'", "start": [613, 1], "end": [622, 30], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.cont_eval_fix", "code": "theorem cont_eval_fix {f k v} (fok : Code.Ok f) :\n    Turing.eval step (stepNormal f (Cont.fix f k) v) =\n      f.fix.eval v >>= fun v => Turing.eval step (Cfg.ret k v)", "start": [625, 1], "end": [695, 67], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.code_is_ok", "code": "theorem code_is_ok (c) : Code.Ok c", "start": [698, 1], "end": [715, 43], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.stepNormal_eval", "code": "theorem stepNormal_eval (c v) : eval step (stepNormal c Cont.halt v) = Cfg.halt <$> c.eval v", "start": [718, 1], "end": [719, 22], "kind": "commanddeclaration"}, {"full_name": "Turing.ToPartrec.stepRet_eval", "code": "theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v", "start": [722, 1], "end": [743, 49], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.\u0393'", "code": "inductive \u0393'\n  | cons\u2097\n  | cons\n  | bit0\n  | bit1\n  deriving DecidableEq, Inhabited, Fintype", "start": [864, 1], "end": [872, 43], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.K'", "code": "inductive K'\n  | main\n  | rev\n  | aux\n  | stack\n  deriving DecidableEq, Inhabited", "start": [879, 1], "end": [888, 34], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.Cont'", "code": "inductive Cont'\n  | halt\n  | cons\u2081 : Code \u2192 Cont' \u2192 Cont'\n  | cons\u2082 : Cont' \u2192 Cont'\n  | comp : Code \u2192 Cont' \u2192 Cont'\n  | fix : Code \u2192 Cont' \u2192 Cont'\n  deriving DecidableEq, Inhabited", "start": [897, 1], "end": [907, 34], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.\u039b'", "code": "inductive \u039b'\n  | move (p : \u0393' \u2192 Bool) (k\u2081 k\u2082 : K') (q : \u039b')\n  | clear (p : \u0393' \u2192 Bool) (k : K') (q : \u039b')\n  | copy (q : \u039b')\n  | push (k : K') (s : Option \u0393' \u2192 Option \u0393') (q : \u039b')\n  | read (f : Option \u0393' \u2192 \u039b')\n  | succ (q : \u039b')\n  | pred (q\u2081 q\u2082 : \u039b')\n  | ret (k : Cont')", "start": [915, 1], "end": [928, 20], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.\u039b'.instInhabited", "code": "instance \u039b'.instInhabited : Inhabited \u039b' :=\n  \u27e8\u039b'.ret Cont'.halt\u27e9", "start": [945, 1], "end": [946, 22], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.\u039b'.instDecidableEq", "code": "instance \u039b'.instDecidableEq : DecidableEq \u039b' := fun a b => by\n  induction a generalizing b <;> cases b <;> try apply Decidable.isFalse; rintro \u27e8\u27e8\u27e9\u27e9; done\n  case move.move _ _ _ _ I _ _ _ _ =>\n    letI := I\n    exact decidable_of_iff' _ (by simp [Function.funext_iff]; rfl)\n  case clear.clear _ _ _ I _ _ _ =>\n    letI := I\n    exact decidable_of_iff' _ (by simp [Function.funext_iff]; rfl)\n  case copy.copy _ I _ =>\n    letI := I\n    exact decidable_of_iff' _ (by simp [Function.funext_iff]; rfl)\n  case push.push _ _ _ I _ _ _ =>\n    letI := I\n    exact decidable_of_iff' _ (by simp [Function.funext_iff]; rfl)\n  case read.read _ I _ =>\n    letI := I\n    exact decidable_of_iff' _ (by simp [Function.funext_iff]; rfl)\n  case succ.succ _ I _ =>\n    letI := I\n    exact decidable_of_iff' _ (by simp [Function.funext_iff]; rfl)\n  case pred.pred _ _ I\u2081 I\u2082 _ _ =>\n    letI := I\u2081\n    letI := I\u2082\n    exact decidable_of_iff' _ (by simp [Function.funext_iff]; rfl)\n  case ret.ret _ _ =>\n    exact decidable_of_iff' _ (by simp [Function.funext_iff]; rfl)", "start": [949, 1], "end": [974, 67], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.Stmt'", "code": "def Stmt' :=\n  TM2.Stmt (fun _ : K' => \u0393') \u039b' (Option \u0393') deriving Inhabited", "start": [977, 1], "end": [979, 64], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.Cfg'", "code": "def Cfg' :=\n  TM2.Cfg (fun _ : K' => \u0393') \u039b' (Option \u0393') deriving Inhabited", "start": [982, 1], "end": [984, 63], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.natEnd", "code": "@[simp]\ndef natEnd : \u0393' \u2192 Bool\n  | \u0393'.cons\u2097 => true\n  | \u0393'.cons => true\n  | _ => false", "start": [989, 1], "end": [995, 15], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.pop'", "code": "@[simp]\ndef pop' (k : K') : Stmt' \u2192 Stmt' :=\n  pop k fun _ v => v", "start": [998, 1], "end": [1001, 21], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.peek'", "code": "@[simp]\ndef peek' (k : K') : Stmt' \u2192 Stmt' :=\n  peek k fun _ v => v", "start": [1004, 1], "end": [1007, 22], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.push'", "code": "@[simp]\ndef push' (k : K') : Stmt' \u2192 Stmt' :=\n  push k fun x => x.iget", "start": [1010, 1], "end": [1013, 25], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.unrev", "code": "def unrev :=\n  \u039b'.move (fun _ => false) rev main", "start": [1016, 1], "end": [1018, 36], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.moveExcl", "code": "def moveExcl (p k\u2081 k\u2082 q) :=\n  \u039b'.move p k\u2081 k\u2082 <| \u039b'.push k\u2081 id q", "start": [1021, 1], "end": [1023, 37], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.move\u2082", "code": "def move\u2082 (p k\u2081 k\u2082 q) :=\n  moveExcl p k\u2081 rev <| \u039b'.move (fun _ => false) rev k\u2082 q", "start": [1026, 1], "end": [1029, 57], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.head", "code": "def head (k : K') (q : \u039b') : \u039b' :=\n  \u039b'.move natEnd k rev <|\n    (\u039b'.push rev fun _ => some \u0393'.cons) <|\n      \u039b'.read fun s =>\n        (if s = some \u0393'.cons\u2097 then id else \u039b'.clear (fun x => x = \u0393'.cons\u2097) k) <| unrev q", "start": [1032, 1], "end": [1038, 90], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trNormal", "code": "@[simp]\ndef trNormal : Code \u2192 Cont' \u2192 \u039b'\n  | Code.zero', k => (\u039b'.push main fun _ => some \u0393'.cons) <| \u039b'.ret k\n  | Code.succ, k => head main <| \u039b'.succ <| \u039b'.ret k\n  | Code.tail, k => \u039b'.clear natEnd main <| \u039b'.ret k\n  | Code.cons f fs, k =>\n    (\u039b'.push stack fun _ => some \u0393'.cons\u2097) <|\n      \u039b'.move (fun _ => false) main rev <| \u039b'.copy <| trNormal f (Cont'.cons\u2081 fs k)\n  | Code.comp f g, k => trNormal g (Cont'.comp f k)\n  | Code.case f g, k => \u039b'.pred (trNormal f k) (trNormal g k)\n  | Code.fix f, k => trNormal f (Cont'.fix f k)", "start": [1041, 1], "end": [1054, 48], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr", "code": "def tr : \u039b' \u2192 Stmt'\n  | \u039b'.move p k\u2081 k\u2082 q =>\n    pop' k\u2081 <|\n      branch (fun s => s.elim true p) (goto fun _ => q)\n        (push' k\u2082 <| goto fun _ => \u039b'.move p k\u2081 k\u2082 q)\n  | \u039b'.push k f q =>\n    branch (fun s => (f s).isSome) ((push k fun s => (f s).iget) <| goto fun _ => q)\n      (goto fun _ => q)\n  | \u039b'.read q => goto q\n  | \u039b'.clear p k q =>\n    pop' k <| branch (fun s => s.elim true p) (goto fun _ => q) (goto fun _ => \u039b'.clear p k q)\n  | \u039b'.copy q =>\n    pop' rev <|\n      branch Option.isSome (push' main <| push' stack <| goto fun _ => \u039b'.copy q) (goto fun _ => q)\n  | \u039b'.succ q =>\n    pop' main <|\n      branch (fun s => s = some \u0393'.bit1) ((push rev fun _ => \u0393'.bit0) <| goto fun _ => \u039b'.succ q) <|\n        branch (fun s => s = some \u0393'.cons)\n          ((push main fun _ => \u0393'.cons) <| (push main fun _ => \u0393'.bit1) <| goto fun _ => unrev q)\n          ((push main fun _ => \u0393'.bit1) <| goto fun _ => unrev q)\n  | \u039b'.pred q\u2081 q\u2082 =>\n    pop' main <|\n      branch (fun s => s = some \u0393'.bit0)\n          ((push rev fun _ => \u0393'.bit1) <| goto fun _ => \u039b'.pred q\u2081 q\u2082) <|\n        branch (fun s => natEnd s.iget) (goto fun _ => q\u2081)\n          (peek' main <|\n            branch (fun s => natEnd s.iget) (goto fun _ => unrev q\u2082)\n              ((push rev fun _ => \u0393'.bit0) <| goto fun _ => unrev q\u2082))\n  | \u039b'.ret (Cont'.cons\u2081 fs k) =>\n    goto fun _ =>\n      move\u2082 (fun _ => false) main aux <|\n        move\u2082 (fun s => s = \u0393'.cons\u2097) stack main <|\n          move\u2082 (fun _ => false) aux stack <| trNormal fs (Cont'.cons\u2082 k)\n  | \u039b'.ret (Cont'.cons\u2082 k) => goto fun _ => head stack <| \u039b'.ret k\n  | \u039b'.ret (Cont'.comp f k) => goto fun _ => trNormal f k\n  | \u039b'.ret (Cont'.fix f k) =>\n    pop' main <|\n      goto fun s =>\n        cond (natEnd s.iget) (\u039b'.ret k) <| \u039b'.clear natEnd main <| trNormal f (Cont'.fix f k)\n  | \u039b'.ret Cont'.halt => (load fun _ => none) <| halt", "start": [1057, 1], "end": [1097, 54], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_move", "code": "theorem tr_move (p k\u2081 k\u2082 q) : tr (\u039b'.move p k\u2081 k\u2082 q) =\n    pop' k\u2081 (branch (fun s => s.elim true p) (goto fun _ => q)\n      (push' k\u2082 <| goto fun _ => \u039b'.move p k\u2081 k\u2082 q))", "start": [1103, 1], "end": [1105, 60], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_push", "code": "theorem tr_push (k f q) : tr (\u039b'.push k f q) = branch (fun s => (f s).isSome)\n    ((push k fun s => (f s).iget) <| goto fun _ => q) (goto fun _ => q)", "start": [1107, 1], "end": [1108, 79], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_read", "code": "theorem tr_read (q) : tr (\u039b'.read q) = goto q", "start": [1110, 1], "end": [1110, 53], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_clear", "code": "theorem tr_clear (p k q) : tr (\u039b'.clear p k q) = pop' k (branch\n    (fun s => s.elim true p) (goto fun _ => q) (goto fun _ => \u039b'.clear p k q))", "start": [1112, 1], "end": [1113, 86], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_copy", "code": "theorem tr_copy (q) : tr (\u039b'.copy q) = pop' rev (branch Option.isSome\n    (push' main <| push' stack <| goto fun _ => \u039b'.copy q) (goto fun _ => q))", "start": [1115, 1], "end": [1116, 85], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_succ", "code": "theorem tr_succ (q) : tr (\u039b'.succ q) = pop' main (branch (fun s => s = some \u0393'.bit1)\n    ((push rev fun _ => \u0393'.bit0) <| goto fun _ => \u039b'.succ q) <|\n      branch (fun s => s = some \u0393'.cons)\n        ((push main fun _ => \u0393'.cons) <| (push main fun _ => \u0393'.bit1) <| goto fun _ => unrev q)\n        ((push main fun _ => \u0393'.bit1) <| goto fun _ => unrev q))", "start": [1118, 1], "end": [1122, 72], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_pred", "code": "theorem tr_pred (q\u2081 q\u2082) : tr (\u039b'.pred q\u2081 q\u2082) = pop' main (branch (fun s => s = some \u0393'.bit0)\n    ((push rev fun _ => \u0393'.bit1) <| goto fun _ => \u039b'.pred q\u2081 q\u2082) <|\n    branch (fun s => natEnd s.iget) (goto fun _ => q\u2081)\n      (peek' main <|\n        branch (fun s => natEnd s.iget) (goto fun _ => unrev q\u2082)\n          ((push rev fun _ => \u0393'.bit0) <| goto fun _ => unrev q\u2082)))", "start": [1124, 1], "end": [1129, 75], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_ret_cons\u2081", "code": "theorem tr_ret_cons\u2081 (fs k) : tr (\u039b'.ret (Cont'.cons\u2081 fs k)) = goto fun _ =>\n    move\u2082 (fun _ => false) main aux <|\n      move\u2082 (fun s => s = \u0393'.cons\u2097) stack main <|\n        move\u2082 (fun _ => false) aux stack <| trNormal fs (Cont'.cons\u2082 k)", "start": [1131, 1], "end": [1134, 79], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_ret_cons\u2082", "code": "theorem tr_ret_cons\u2082 (k) : tr (\u039b'.ret (Cont'.cons\u2082 k)) =\n    goto fun _ => head stack <| \u039b'.ret k", "start": [1136, 1], "end": [1137, 48], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_ret_comp", "code": "theorem tr_ret_comp (f k) : tr (\u039b'.ret (Cont'.comp f k)) = goto fun _ => trNormal f k", "start": [1139, 1], "end": [1139, 93], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_ret_fix", "code": "theorem tr_ret_fix (f k) : tr (\u039b'.ret (Cont'.fix f k)) = pop' main (goto fun s =>\n    cond (natEnd s.iget) (\u039b'.ret k) <| \u039b'.clear natEnd main <| trNormal f (Cont'.fix f k))", "start": [1141, 1], "end": [1142, 98], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_ret_halt", "code": "theorem tr_ret_halt : tr (\u039b'.ret Cont'.halt) = (load fun _ => none) halt", "start": [1144, 1], "end": [1144, 80], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trCont", "code": "def trCont : Cont \u2192 Cont'\n  | Cont.halt => Cont'.halt\n  | Cont.cons\u2081 c _ k => Cont'.cons\u2081 c (trCont k)\n  | Cont.cons\u2082 _ k => Cont'.cons\u2082 (trCont k)\n  | Cont.comp c k => Cont'.comp c (trCont k)\n  | Cont.fix c k => Cont'.fix c (trCont k)", "start": [1151, 1], "end": [1158, 43], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trPosNum", "code": "def trPosNum : PosNum \u2192 List \u0393'\n  | PosNum.one => [\u0393'.bit1]\n  | PosNum.bit0 n => \u0393'.bit0 :: trPosNum n\n  | PosNum.bit1 n => \u0393'.bit1 :: trPosNum n", "start": [1161, 1], "end": [1173, 43], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trNum", "code": "def trNum : Num \u2192 List \u0393'\n  | Num.zero => []\n  | Num.pos n => trPosNum n", "start": [1176, 1], "end": [1188, 28], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trNat", "code": "def trNat (n : \u2115) : List \u0393' :=\n  trNum n", "start": [1191, 1], "end": [1195, 10], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trNat_zero", "code": "@[simp]\ntheorem trNat_zero : trNat 0 = []", "start": [1198, 1], "end": [1199, 71], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trNat_default", "code": "@[simp]\ntheorem trNat_default : trNat default = []", "start": [1202, 1], "end": [1204, 13], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trList", "code": "@[simp]\ndef trList : List \u2115 \u2192 List \u0393'\n  | [] => []\n  | n::ns => trNat n ++ \u0393'.cons :: trList ns", "start": [1207, 1], "end": [1218, 45], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trLList", "code": "@[simp]\ndef trLList : List (List \u2115) \u2192 List \u0393'\n  | [] => []\n  | l::ls => trList l ++ \u0393'.cons\u2097 :: trLList ls", "start": [1221, 1], "end": [1233, 48], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.contStack", "code": "@[simp]\ndef contStack : Cont \u2192 List (List \u2115)\n  | Cont.halt => []\n  | Cont.cons\u2081 _ ns k => ns :: contStack k\n  | Cont.cons\u2082 ns k => ns :: contStack k\n  | Cont.comp _ k => contStack k\n  | Cont.fix _ k => contStack k", "start": [1236, 1], "end": [1244, 32], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trContStack", "code": "def trContStack (k : Cont) :=\n  trLList (contStack k)", "start": [1247, 1], "end": [1250, 24], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.K'.elim", "code": "def K'.elim (a b c d : List \u0393') : K' \u2192 List \u0393'\n  | K'.main => a\n  | K'.rev => b\n  | K'.aux => c\n  | K'.stack => d", "start": [1253, 1], "end": [1261, 18], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.K'.elim_main", "code": "theorem K'.elim_main (a b c d) : K'.elim a b c d K'.main = a", "start": [1267, 1], "end": [1267, 68], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.K'.elim_rev", "code": "theorem K'.elim_rev (a b c d) : K'.elim a b c d K'.rev = b", "start": [1269, 1], "end": [1269, 66], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.K'.elim_aux", "code": "theorem K'.elim_aux (a b c d) : K'.elim a b c d K'.aux = c", "start": [1271, 1], "end": [1271, 66], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.K'.elim_stack", "code": "theorem K'.elim_stack (a b c d) : K'.elim a b c d K'.stack = d", "start": [1273, 1], "end": [1273, 70], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.K'.elim_update_main", "code": "@[simp]\ntheorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d", "start": [1278, 1], "end": [1280, 28], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.K'.elim_update_rev", "code": "@[simp]\ntheorem K'.elim_update_rev {a b c d b'} : update (K'.elim a b c d) rev b' = K'.elim a b' c d", "start": [1283, 1], "end": [1285, 28], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.K'.elim_update_aux", "code": "@[simp]\ntheorem K'.elim_update_aux {a b c d c'} : update (K'.elim a b c d) aux c' = K'.elim a b c' d", "start": [1288, 1], "end": [1290, 28], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.K'.elim_update_stack", "code": "@[simp]\ntheorem K'.elim_update_stack {a b c d d'} : update (K'.elim a b c d) stack d' = K'.elim a b c d'", "start": [1293, 1], "end": [1295, 31], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.halt", "code": "def halt (v : List \u2115) : Cfg' :=\n  \u27e8none, none, K'.elim (trList v) [] [] []\u27e9", "start": [1298, 1], "end": [1300, 44], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.TrCfg", "code": "def TrCfg : Cfg \u2192 Cfg' \u2192 Prop\n  | Cfg.ret k v, c' =>\n    \u2203 s, c' = \u27e8some (\u039b'.ret (trCont k)), s, K'.elim (trList v) [] [] (trContStack k)\u27e9\n  | Cfg.halt v, c' => c' = halt v", "start": [1303, 1], "end": [1310, 34], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.splitAtPred", "code": "def splitAtPred {\u03b1} (p : \u03b1 \u2192 Bool) : List \u03b1 \u2192 List \u03b1 \u00d7 Option \u03b1 \u00d7 List \u03b1\n  | [] => ([], none, [])\n  | a :: as =>\n    cond (p a) ([], some a, as) <|\n      let \u27e8l\u2081, o, l\u2082\u27e9 := splitAtPred p as\n      \u27e8a::l\u2081, o, l\u2082\u27e9", "start": [1313, 1], "end": [1322, 21], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.splitAtPred_eq", "code": "theorem splitAtPred_eq {\u03b1} (p : \u03b1 \u2192 Bool) :\n    \u2200 L l\u2081 o l\u2082,\n      (\u2200 x \u2208 l\u2081, p x = false) \u2192\n        Option.elim' (L = l\u2081 \u2227 l\u2082 = []) (fun a => p a = true \u2227 L = l\u2081 ++ a::l\u2082) o \u2192\n          splitAtPred p L = (l\u2081, o, l\u2082)", "start": [1325, 1], "end": [1342, 48], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.splitAtPred_false", "code": "theorem splitAtPred_false {\u03b1} (L : List \u03b1) : splitAtPred (fun _ => false) L = (L, none, [])", "start": [1345, 1], "end": [1346, 55], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.move_ok", "code": "theorem move_ok {p k\u2081 k\u2082 q s L\u2081 o L\u2082} {S : K' \u2192 List \u0393'} (h\u2081 : k\u2081 \u2260 k\u2082)\n    (e : splitAtPred p (S k\u2081) = (L\u2081, o, L\u2082)) :\n    Reaches\u2081 (TM2.step tr) \u27e8some (\u039b'.move p k\u2081 k\u2082 q), s, S\u27e9\n      \u27e8some q, o, update (update S k\u2081 L\u2082) k\u2082 (L\u2081.reverseAux (S k\u2082))\u27e9", "start": [1349, 1], "end": [1381, 40], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.unrev_ok", "code": "theorem unrev_ok {q s} {S : K' \u2192 List \u0393'} :\n    Reaches\u2081 (TM2.step tr) \u27e8some (unrev q), s, S\u27e9\n      \u27e8some q, none, update (update S rev []) main (List.reverseAux (S rev) (S main))\u27e9", "start": [1384, 1], "end": [1387, 45], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.move\u2082_ok", "code": "theorem move\u2082_ok {p k\u2081 k\u2082 q s L\u2081 o L\u2082} {S : K' \u2192 List \u0393'} (h\u2081 : k\u2081 \u2260 rev \u2227 k\u2082 \u2260 rev \u2227 k\u2081 \u2260 k\u2082)\n    (h\u2082 : S rev = []) (e : splitAtPred p (S k\u2081) = (L\u2081, o, L\u2082)) :\n    Reaches\u2081 (TM2.step tr) \u27e8some (move\u2082 p k\u2081 k\u2082 q), s, S\u27e9\n      \u27e8some q, none, update (update S k\u2081 (o.elim id List.cons L\u2082)) k\u2082 (L\u2081 ++ S k\u2082)\u27e9", "start": [1390, 1], "end": [1410, 80], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.clear_ok", "code": "theorem clear_ok {p k q s L\u2081 o L\u2082} {S : K' \u2192 List \u0393'} (e : splitAtPred p (S k) = (L\u2081, o, L\u2082)) :\n    Reaches\u2081 (TM2.step tr) \u27e8some (\u039b'.clear p k q), s, S\u27e9 \u27e8some q, o, update S k L\u2082\u27e9", "start": [1413, 1], "end": [1437, 58], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.copy_ok", "code": "theorem copy_ok (q s a b c d) :\n    Reaches\u2081 (TM2.step tr) \u27e8some (\u039b'.copy q), s, K'.elim a b c d\u27e9\n      \u27e8some q, none, K'.elim (List.reverseAux b a) [] c (List.reverseAux b d)\u27e9", "start": [1440, 1], "end": [1450, 17], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trPosNum_natEnd", "code": "theorem trPosNum_natEnd : \u2200 (n), \u2200 x \u2208 trPosNum n, natEnd x = false", "start": [1453, 1], "end": [1458, 65], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trNum_natEnd", "code": "theorem trNum_natEnd : \u2200 (n), \u2200 x \u2208 trNum n, natEnd x = false", "start": [1461, 1], "end": [1462, 45], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trNat_natEnd", "code": "theorem trNat_natEnd (n) : \u2200 x \u2208 trNat n, natEnd x = false", "start": [1465, 1], "end": [1466, 17], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trList_ne_cons\u2097", "code": "theorem trList_ne_cons\u2097 : \u2200 (l), \u2200 x \u2208 trList l, x \u2260 \u0393'.cons\u2097", "start": [1469, 1], "end": [1476, 34], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.head_main_ok", "code": "theorem head_main_ok {q s L} {c d : List \u0393'} :\n    Reaches\u2081 (TM2.step tr) \u27e8some (head main q), s, K'.elim (trList L) [] c d\u27e9\n      \u27e8some q, none, K'.elim (trList [L.headI]) [] c d\u27e9", "start": [1479, 1], "end": [1493, 54], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.head_stack_ok", "code": "theorem head_stack_ok {q s L\u2081 L\u2082 L\u2083} :\n    Reaches\u2081 (TM2.step tr)\n      \u27e8some (head stack q), s, K'.elim (trList L\u2081) [] [] (trList L\u2082 ++ \u0393'.cons\u2097 :: L\u2083)\u27e9\n      \u27e8some q, none, K'.elim (trList (L\u2082.headI :: L\u2081)) [] [] L\u2083\u27e9", "start": [1496, 1], "end": [1527, 30], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.succ_ok", "code": "theorem succ_ok {q s n} {c d : List \u0393'} :\n    Reaches\u2081 (TM2.step tr) \u27e8some (\u039b'.succ q), s, K'.elim (trList [n]) [] c d\u27e9\n      \u27e8some q, none, K'.elim (trList [n.succ]) [] c d\u27e9", "start": [1530, 1], "end": [1562, 8], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.pred_ok", "code": "theorem pred_ok (q\u2081 q\u2082 s v) (c d : List \u0393') : \u2203 s',\n    Reaches\u2081 (TM2.step tr) \u27e8some (\u039b'.pred q\u2081 q\u2082), s, K'.elim (trList v) [] c d\u27e9\n      (v.headI.rec \u27e8some q\u2081, s', K'.elim (trList v.tail) [] c d\u27e9 fun n _ =>\n        \u27e8some q\u2082, s', K'.elim (trList (n::v.tail)) [] c d\u27e9)", "start": [1565, 1], "end": [1609, 8], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trNormal_respects", "code": "theorem trNormal_respects (c k v s) :\n    \u2203 b\u2082,\n      TrCfg (stepNormal c k v) b\u2082 \u2227\n        Reaches\u2081 (TM2.step tr)\n          \u27e8some (trNormal c (trCont k)), s, K'.elim (trList v) [] [] (trContStack k)\u27e9 b\u2082", "start": [1612, 1], "end": [1644, 28], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_ret_respects", "code": "theorem tr_ret_respects (k v s) : \u2203 b\u2082,\n    TrCfg (stepRet k v) b\u2082 \u2227\n      Reaches\u2081 (TM2.step tr)\n        \u27e8some (\u039b'.ret (trCont k)), s, K'.elim (trList v) [] [] (trContStack k)\u27e9 b\u2082", "start": [1647, 1], "end": [1703, 28], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_respects", "code": "theorem tr_respects : Respects step (TM2.step tr) TrCfg", "start": [1706, 1], "end": [1708, 30], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.init", "code": "def init (c : Code) (v : List \u2115) : Cfg' :=\n  \u27e8some (trNormal c Cont'.halt), none, K'.elim (trList v) [] [] []\u27e9", "start": [1711, 1], "end": [1713, 68], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_init", "code": "theorem tr_init (c v) :\n    \u2203 b, TrCfg (stepNormal c Cont.halt v) b \u2227 Reaches\u2081 (TM2.step tr) (init c v) b", "start": [1716, 1], "end": [1718, 28], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_eval", "code": "theorem tr_eval (c v) : eval (TM2.step tr) (init c v) = halt <$> Code.eval c v", "start": [1721, 1], "end": [1734, 12], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trStmts\u2081", "code": "def trStmts\u2081 : \u039b' \u2192 Finset \u039b'\n  | Q@(\u039b'.move _ _ _ q) => insert Q <| trStmts\u2081 q\n  | Q@(\u039b'.push _ _ q) => insert Q <| trStmts\u2081 q\n  | Q@(\u039b'.read q) => insert Q <| Finset.univ.biUnion fun s => trStmts\u2081 (q s)\n  | Q@(\u039b'.clear _ _ q) => insert Q <| trStmts\u2081 q\n  | Q@(\u039b'.copy q) => insert Q <| trStmts\u2081 q\n  | Q@(\u039b'.succ q) => insert Q <| insert (unrev q) <| trStmts\u2081 q\n  | Q@(\u039b'.pred q\u2081 q\u2082) => insert Q <| trStmts\u2081 q\u2081 \u222a insert (unrev q\u2082) (trStmts\u2081 q\u2082)\n  | Q@(\u039b'.ret _) => {Q}", "start": [1737, 1], "end": [1746, 24], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trStmts\u2081_trans", "code": "theorem trStmts\u2081_trans {q q'} : q' \u2208 trStmts\u2081 q \u2192 trStmts\u2081 q' \u2286 trStmts\u2081 q", "start": [1749, 1], "end": [1767, 52], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trStmts\u2081_self", "code": "theorem trStmts\u2081_self (q) : q \u2208 trStmts\u2081 q", "start": [1770, 1], "end": [1771, 88], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.codeSupp'", "code": "def codeSupp' : Code \u2192 Cont' \u2192 Finset \u039b'\n  | c@Code.zero', k => trStmts\u2081 (trNormal c k)\n  | c@Code.succ, k => trStmts\u2081 (trNormal c k)\n  | c@Code.tail, k => trStmts\u2081 (trNormal c k)\n  | c@(Code.cons f fs), k =>\n    trStmts\u2081 (trNormal c k) \u222a\n      (codeSupp' f (Cont'.cons\u2081 fs k) \u222a\n        (trStmts\u2081\n            (move\u2082 (fun _ => false) main aux <|\n              move\u2082 (fun s => s = \u0393'.cons\u2097) stack main <|\n                move\u2082 (fun _ => false) aux stack <| trNormal fs (Cont'.cons\u2082 k)) \u222a\n          (codeSupp' fs (Cont'.cons\u2082 k) \u222a trStmts\u2081 (head stack <| \u039b'.ret k))))\n  | c@(Code.comp f g), k =>\n    trStmts\u2081 (trNormal c k) \u222a\n      (codeSupp' g (Cont'.comp f k) \u222a (trStmts\u2081 (trNormal f k) \u222a codeSupp' f k))\n  | c@(Code.case f g), k => trStmts\u2081 (trNormal c k) \u222a (codeSupp' f k \u222a codeSupp' g k)\n  | c@(Code.fix f), k =>\n    trStmts\u2081 (trNormal c k) \u222a\n      (codeSupp' f (Cont'.fix f k) \u222a\n        (trStmts\u2081 (\u039b'.clear natEnd main <| trNormal f (Cont'.fix f k)) \u222a {\u039b'.ret k}))", "start": [1774, 1], "end": [1796, 86], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.codeSupp'_self", "code": "@[simp]\ntheorem codeSupp'_self (c k) : trStmts\u2081 (trNormal c k) \u2286 codeSupp' c k", "start": [1799, 1], "end": [1801, 60], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.contSupp", "code": "def contSupp : Cont' \u2192 Finset \u039b'\n  | Cont'.cons\u2081 fs k =>\n    trStmts\u2081\n        (move\u2082 (fun _ => false) main aux <|\n          move\u2082 (fun s => s = \u0393'.cons\u2097) stack main <|\n            move\u2082 (fun _ => false) aux stack <| trNormal fs (Cont'.cons\u2082 k)) \u222a\n      (codeSupp' fs (Cont'.cons\u2082 k) \u222a (trStmts\u2081 (head stack <| \u039b'.ret k) \u222a contSupp k))\n  | Cont'.cons\u2082 k => trStmts\u2081 (head stack <| \u039b'.ret k) \u222a contSupp k\n  | Cont'.comp f k => codeSupp' f k \u222a contSupp k\n  | Cont'.fix f k => codeSupp' (Code.fix f) k \u222a contSupp k\n  | Cont'.halt => \u2205", "start": [1804, 1], "end": [1816, 20], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.codeSupp", "code": "def codeSupp (c : Code) (k : Cont') : Finset \u039b' :=\n  codeSupp' c k \u222a contSupp k", "start": [1819, 1], "end": [1824, 29], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.codeSupp_self", "code": "@[simp]\ntheorem codeSupp_self (c k) : trStmts\u2081 (trNormal c k) \u2286 codeSupp c k", "start": [1827, 1], "end": [1829, 74], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.codeSupp_zero", "code": "@[simp]\ntheorem codeSupp_zero (k) : codeSupp Code.zero' k = trStmts\u2081 (trNormal Code.zero' k) \u222a contSupp k", "start": [1832, 1], "end": [1834, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.codeSupp_succ", "code": "@[simp]\ntheorem codeSupp_succ (k) : codeSupp Code.succ k = trStmts\u2081 (trNormal Code.succ k) \u222a contSupp k", "start": [1837, 1], "end": [1839, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.codeSupp_tail", "code": "@[simp]\ntheorem codeSupp_tail (k) : codeSupp Code.tail k = trStmts\u2081 (trNormal Code.tail k) \u222a contSupp k", "start": [1842, 1], "end": [1844, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.codeSupp_cons", "code": "@[simp]\ntheorem codeSupp_cons (f fs k) :\n    codeSupp (Code.cons f fs) k =\n      trStmts\u2081 (trNormal (Code.cons f fs) k) \u222a codeSupp f (Cont'.cons\u2081 fs k)", "start": [1847, 1], "end": [1851, 62], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.codeSupp_comp", "code": "@[simp]\ntheorem codeSupp_comp (f g k) :\n    codeSupp (Code.comp f g) k =\n      trStmts\u2081 (trNormal (Code.comp f g) k) \u222a codeSupp g (Cont'.comp f k)", "start": [1854, 1], "end": [1860, 50], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.codeSupp_case", "code": "@[simp]\ntheorem codeSupp_case (f g k) :\n    codeSupp (Code.case f g) k =\n      trStmts\u2081 (trNormal (Code.case f g) k) \u222a (codeSupp f k \u222a codeSupp g k)", "start": [1863, 1], "end": [1867, 86], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.codeSupp_fix", "code": "@[simp]\ntheorem codeSupp_fix (f k) :\n    codeSupp (Code.fix f) k = trStmts\u2081 (trNormal (Code.fix f) k) \u222a codeSupp f (Cont'.fix f k)", "start": [1870, 1], "end": [1874, 28], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.contSupp_cons\u2081", "code": "@[simp]\ntheorem contSupp_cons\u2081 (fs k) :\n    contSupp (Cont'.cons\u2081 fs k) =\n      trStmts\u2081\n          (move\u2082 (fun _ => false) main aux <|\n            move\u2082 (fun s => s = \u0393'.cons\u2097) stack main <|\n              move\u2082 (fun _ => false) aux stack <| trNormal fs (Cont'.cons\u2082 k)) \u222a\n        codeSupp fs (Cont'.cons\u2082 k)", "start": [1877, 1], "end": [1885, 62], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.contSupp_cons\u2082", "code": "@[simp]\ntheorem contSupp_cons\u2082 (k) :\n    contSupp (Cont'.cons\u2082 k) = trStmts\u2081 (head stack <| \u039b'.ret k) \u222a contSupp k", "start": [1888, 1], "end": [1891, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.contSupp_comp", "code": "@[simp]\ntheorem contSupp_comp (f k) : contSupp (Cont'.comp f k) = codeSupp f k", "start": [1894, 1], "end": [1896, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.contSupp_fix", "code": "theorem contSupp_fix (f k) : contSupp (Cont'.fix f k) = codeSupp f (Cont'.fix f k)", "start": [1899, 1], "end": [1901, 23], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.contSupp_halt", "code": "@[simp]\ntheorem contSupp_halt : contSupp Cont'.halt = \u2205", "start": [1904, 1], "end": [1906, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.\u039b'.Supports", "code": "def \u039b'.Supports (S : Finset \u039b') : \u039b' \u2192 Prop\n  | \u039b'.move _ _ _ q => \u039b'.Supports S q\n  | \u039b'.push _ _ q => \u039b'.Supports S q\n  | \u039b'.read q => \u2200 s, \u039b'.Supports S (q s)\n  | \u039b'.clear _ _ q => \u039b'.Supports S q\n  | \u039b'.copy q => \u039b'.Supports S q\n  | \u039b'.succ q => \u039b'.Supports S q\n  | \u039b'.pred q\u2081 q\u2082 => \u039b'.Supports S q\u2081 \u2227 \u039b'.Supports S q\u2082\n  | \u039b'.ret k => contSupp k \u2286 S", "start": [1909, 1], "end": [1920, 31], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.Supports", "code": "def Supports (K S : Finset \u039b') :=\n  \u2200 q \u2208 K, TM2.SupportsStmt S (tr q)", "start": [1923, 1], "end": [1930, 37], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.supports_insert", "code": "theorem supports_insert {K S q} :\n    Supports (insert q K) S \u2194 TM2.SupportsStmt S (tr q) \u2227 Supports K S", "start": [1933, 1], "end": [1934, 93], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.supports_singleton", "code": "theorem supports_singleton {S q} : Supports {q} S \u2194 TM2.SupportsStmt S (tr q)", "start": [1937, 1], "end": [1937, 100], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.supports_union", "code": "theorem supports_union {K\u2081 K\u2082 S} : Supports (K\u2081 \u222a K\u2082) S \u2194 Supports K\u2081 S \u2227 Supports K\u2082 S", "start": [1940, 1], "end": [1941, 38], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.supports_biUnion", "code": "theorem supports_biUnion {K : Option \u0393' \u2192 Finset \u039b'} {S} :\n    Supports (Finset.univ.biUnion K) S \u2194 \u2200 a, Supports (K a) S", "start": [1944, 1], "end": [1946, 37], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.head_supports", "code": "theorem head_supports {S k q} (H : (q : \u039b').Supports S) : (head k q).Supports S", "start": [1949, 1], "end": [1950, 36], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.ret_supports", "code": "theorem ret_supports {S k} (H\u2081 : contSupp k \u2286 S) : TM2.SupportsStmt S (tr (\u039b'.ret k))", "start": [1953, 1], "end": [1965, 80], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trStmts\u2081_supports", "code": "theorem trStmts\u2081_supports {S q} (H\u2081 : (q : \u039b').Supports S) (HS\u2081 : trStmts\u2081 q \u2286 S) :\n    Supports (trStmts\u2081 q) S", "start": [1968, 1], "end": [1990, 49], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trStmts\u2081_supports'", "code": "theorem trStmts\u2081_supports' {S q K} (H\u2081 : (q : \u039b').Supports S) (H\u2082 : trStmts\u2081 q \u222a K \u2286 S)\n    (H\u2083 : K \u2286 S \u2192 Supports K S) : Supports (trStmts\u2081 q \u222a K) S", "start": [1993, 1], "end": [1996, 62], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.trNormal_supports", "code": "theorem trNormal_supports {S c k} (Hk : codeSupp c k \u2286 S) : (trNormal c k).Supports S", "start": [1999, 1], "end": [2013, 91], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.codeSupp'_supports", "code": "theorem codeSupp'_supports {S c k} (H : codeSupp c k \u2286 S) : Supports (codeSupp' c k) S", "start": [2016, 1], "end": [2053, 77], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.contSupp_supports", "code": "theorem contSupp_supports {S k} (H : contSupp k \u2286 S) : Supports (contSupp k) S", "start": [2056, 1], "end": [2073, 84], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.codeSupp_supports", "code": "theorem codeSupp_supports {S c k} (H : codeSupp c k \u2286 S) : Supports (codeSupp c k) S", "start": [2076, 1], "end": [2077, 91], "kind": "commanddeclaration"}, {"full_name": "Turing.PartrecToTM2.tr_supports", "code": "theorem tr_supports (c k) : @TM2.Supports _ _ _ _ \u27e8trNormal c k\u27e9 tr (codeSupp c k)", "start": [2080, 1], "end": [2086, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/Portmanteau.lean", "imports": ["Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean", "Mathlib/MeasureTheory/Measure/ProbabilityMeasure.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.le_measure_compl_liminf_of_limsup_measure_le", "code": "theorem le_measure_compl_liminf_of_limsup_measure_le {\u03b9 : Type*} {L : Filter \u03b9} {\u03bc : Measure \u03a9}\n    {\u03bcs : \u03b9 \u2192 Measure \u03a9} [IsProbabilityMeasure \u03bc] [\u2200 i, IsProbabilityMeasure (\u03bcs i)] {E : Set \u03a9}\n    (E_mble : MeasurableSet E) (h : (L.limsup fun i => \u03bcs i E) \u2264 \u03bc E) :\n    \u03bc E\u1d9c \u2264 L.liminf fun i => \u03bcs i E\u1d9c", "start": [110, 1], "end": [128, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.le_measure_liminf_of_limsup_measure_compl_le", "code": "theorem le_measure_liminf_of_limsup_measure_compl_le {\u03b9 : Type*} {L : Filter \u03b9} {\u03bc : Measure \u03a9}\n    {\u03bcs : \u03b9 \u2192 Measure \u03a9} [IsProbabilityMeasure \u03bc] [\u2200 i, IsProbabilityMeasure (\u03bcs i)] {E : Set \u03a9}\n    (E_mble : MeasurableSet E) (h : (L.limsup fun i => \u03bcs i E\u1d9c) \u2264 \u03bc E\u1d9c) :\n    \u03bc E \u2264 L.liminf fun i => \u03bcs i E", "start": [131, 1], "end": [135, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.limsup_measure_compl_le_of_le_liminf_measure", "code": "theorem limsup_measure_compl_le_of_le_liminf_measure {\u03b9 : Type*} {L : Filter \u03b9} {\u03bc : Measure \u03a9}\n    {\u03bcs : \u03b9 \u2192 Measure \u03a9} [IsProbabilityMeasure \u03bc] [\u2200 i, IsProbabilityMeasure (\u03bcs i)] {E : Set \u03a9}\n    (E_mble : MeasurableSet E) (h : \u03bc E \u2264 L.liminf fun i => \u03bcs i E) :\n    (L.limsup fun i => \u03bcs i E\u1d9c) \u2264 \u03bc E\u1d9c", "start": [138, 1], "end": [156, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.limsup_measure_le_of_le_liminf_measure_compl", "code": "theorem limsup_measure_le_of_le_liminf_measure_compl {\u03b9 : Type*} {L : Filter \u03b9} {\u03bc : Measure \u03a9}\n    {\u03bcs : \u03b9 \u2192 Measure \u03a9} [IsProbabilityMeasure \u03bc] [\u2200 i, IsProbabilityMeasure (\u03bcs i)] {E : Set \u03a9}\n    (E_mble : MeasurableSet E) (h : \u03bc E\u1d9c \u2264 L.liminf fun i => \u03bcs i E\u1d9c) :\n    (L.limsup fun i => \u03bcs i E) \u2264 \u03bc E", "start": [159, 1], "end": [163, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.limsup_measure_closed_le_iff_liminf_measure_open_ge", "code": "theorem limsup_measure_closed_le_iff_liminf_measure_open_ge {\u03b9 : Type*} {L : Filter \u03b9}\n    {\u03bc : Measure \u03a9} {\u03bcs : \u03b9 \u2192 Measure \u03a9} [IsProbabilityMeasure \u03bc]\n    [\u2200 i, IsProbabilityMeasure (\u03bcs i)] :\n    (\u2200 F, IsClosed F \u2192 (L.limsup fun i => \u03bcs i F) \u2264 \u03bc F) \u2194\n      \u2200 G, IsOpen G \u2192 \u03bc G \u2264 L.liminf fun i => \u03bcs i G", "start": [168, 1], "end": [188, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_measure_of_le_liminf_measure_of_limsup_measure_le", "code": "theorem tendsto_measure_of_le_liminf_measure_of_limsup_measure_le {\u03b9 : Type*} {L : Filter \u03b9}\n    {\u03bc : Measure \u03a9} {\u03bcs : \u03b9 \u2192 Measure \u03a9} {E\u2080 E E\u2081 : Set \u03a9} (E\u2080_subset : E\u2080 \u2286 E) (subset_E\u2081 : E \u2286 E\u2081)\n    (nulldiff : \u03bc (E\u2081 \\ E\u2080) = 0) (h_E\u2080 : \u03bc E\u2080 \u2264 L.liminf fun i => \u03bcs i E\u2080)\n    (h_E\u2081 : (L.limsup fun i => \u03bcs i E\u2081) \u2264 \u03bc E\u2081) : L.Tendsto (fun i => \u03bcs i E) (\ud835\udcdd (\u03bc E))", "start": [214, 1], "end": [236, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_measure_of_null_frontier", "code": "theorem tendsto_measure_of_null_frontier {\u03b9 : Type*} {L : Filter \u03b9} {\u03bc : Measure \u03a9}\n    {\u03bcs : \u03b9 \u2192 Measure \u03a9} [IsProbabilityMeasure \u03bc] [\u2200 i, IsProbabilityMeasure (\u03bcs i)]\n    (h_opens : \u2200 G, IsOpen G \u2192 \u03bc G \u2264 L.liminf fun i => \u03bcs i G) {E : Set \u03a9}\n    (E_nullbdry : \u03bc (frontier E) = 0) : L.Tendsto (fun i => \u03bcs i E) (\ud835\udcdd (\u03bc E))", "start": [241, 1], "end": [254, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_of_cont_bdd_of_tendsto_filter_indicator", "code": "theorem measure_of_cont_bdd_of_tendsto_filter_indicator {\u03b9 : Type*} {L : Filter \u03b9}\n    [L.IsCountablyGenerated] [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9] (\u03bc : Measure \u03a9)\n    [IsFiniteMeasure \u03bc] {c : \u211d\u22650} {E : Set \u03a9} (E_mble : MeasurableSet E) (fs : \u03b9 \u2192 \u03a9 \u2192\u1d47 \u211d\u22650)\n    (fs_bdd : \u2200\u1da0 i in L, \u2200\u1d50 \u03c9 : \u03a9 \u2202\u03bc, fs i \u03c9 \u2264 c)\n    (fs_lim : \u2200\u1d50 \u03c9 : \u03a9 \u2202\u03bc, Tendsto (fun i : \u03b9 => ((\u21d1) : (\u03a9 \u2192\u1d47 \u211d\u22650) \u2192 \u03a9 \u2192 \u211d\u22650) (fs i) \u03c9) L\n      (\ud835\udcdd (indicator E (fun _ => (1 : \u211d\u22650)) \u03c9))) :\n    Tendsto (fun n => lintegral \u03bc fun \u03c9 => fs n \u03c9) L (\ud835\udcdd (\u03bc E))", "start": [284, 1], "end": [302, 84], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_of_cont_bdd_of_tendsto_indicator", "code": "theorem measure_of_cont_bdd_of_tendsto_indicator [TopologicalSpace \u03a9] [OpensMeasurableSpace \u03a9]\n    (\u03bc : Measure \u03a9) [IsFiniteMeasure \u03bc] {c : \u211d\u22650} {E : Set \u03a9} (E_mble : MeasurableSet E)\n    (fs : \u2115 \u2192 \u03a9 \u2192\u1d47 \u211d\u22650) (fs_bdd : \u2200 n \u03c9, fs n \u03c9 \u2264 c)\n    (fs_lim : Tendsto (fun n : \u2115 => ((\u21d1) : (\u03a9 \u2192\u1d47 \u211d\u22650) \u2192 \u03a9 \u2192 \u211d\u22650) (fs n)) atTop\n      (\ud835\udcdd (indicator E fun _ => (1 : \u211d\u22650)))) :\n    Tendsto (fun n => lintegral \u03bc fun \u03c9 => fs n \u03c9) atTop (\ud835\udcdd (\u03bc E))", "start": [305, 1], "end": [323, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_lintegral_thickenedIndicator_of_isClosed", "code": "theorem tendsto_lintegral_thickenedIndicator_of_isClosed {\u03a9 : Type*} [MeasurableSpace \u03a9]\n    [PseudoEMetricSpace \u03a9] [OpensMeasurableSpace \u03a9] (\u03bc : Measure \u03a9) [IsFiniteMeasure \u03bc] {F : Set \u03a9}\n    (F_closed : IsClosed F) {\u03b4s : \u2115 \u2192 \u211d} (\u03b4s_pos : \u2200 n, 0 < \u03b4s n)\n    (\u03b4s_lim : Tendsto \u03b4s atTop (\ud835\udcdd 0)) :\n    Tendsto (fun n => lintegral \u03bc fun \u03c9 => (thickenedIndicator (\u03b4s_pos n) F \u03c9 : \u211d\u22650\u221e)) atTop\n      (\ud835\udcdd (\u03bc F))", "start": [326, 1], "end": [338, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.limsup_measure_closed_le_of_tendsto", "code": "theorem FiniteMeasure.limsup_measure_closed_le_of_tendsto {\u03a9 \u03b9 : Type*} {L : Filter \u03b9}\n    [MeasurableSpace \u03a9] [PseudoEMetricSpace \u03a9] [OpensMeasurableSpace \u03a9] {\u03bc : FiniteMeasure \u03a9}\n    {\u03bcs : \u03b9 \u2192 FiniteMeasure \u03a9} (\u03bcs_lim : Tendsto \u03bcs L (\ud835\udcdd \u03bc)) {F : Set \u03a9} (F_closed : IsClosed F) :\n    (L.limsup fun i => (\u03bcs i : Measure \u03a9) F) \u2264 (\u03bc : Measure \u03a9) F", "start": [341, 1], "end": [377, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.limsup_measure_closed_le_of_tendsto", "code": "theorem ProbabilityMeasure.limsup_measure_closed_le_of_tendsto {\u03a9 \u03b9 : Type*} {L : Filter \u03b9}\n    [MeasurableSpace \u03a9] [PseudoEMetricSpace \u03a9] [OpensMeasurableSpace \u03a9] {\u03bc : ProbabilityMeasure \u03a9}\n    {\u03bcs : \u03b9 \u2192 ProbabilityMeasure \u03a9} (\u03bcs_lim : Tendsto \u03bcs L (\ud835\udcdd \u03bc)) {F : Set \u03a9}\n    (F_closed : IsClosed F) : (L.limsup fun i => (\u03bcs i : Measure \u03a9) F) \u2264 (\u03bc : Measure \u03a9) F", "start": [380, 1], "end": [389, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.le_liminf_measure_open_of_tendsto", "code": "theorem ProbabilityMeasure.le_liminf_measure_open_of_tendsto {\u03a9 \u03b9 : Type*} {L : Filter \u03b9}\n    [MeasurableSpace \u03a9] [PseudoEMetricSpace \u03a9] [OpensMeasurableSpace \u03a9] {\u03bc : ProbabilityMeasure \u03a9}\n    {\u03bcs : \u03b9 \u2192 ProbabilityMeasure \u03a9} (\u03bcs_lim : Tendsto \u03bcs L (\ud835\udcdd \u03bc)) {G : Set \u03a9} (G_open : IsOpen G) :\n    (\u03bc : Measure \u03a9) G \u2264 L.liminf fun i => (\u03bcs i : Measure \u03a9) G", "start": [392, 1], "end": [403, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto'", "code": "theorem ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto' {\u03a9 \u03b9 : Type*}\n    {L : Filter \u03b9} [MeasurableSpace \u03a9] [PseudoEMetricSpace \u03a9] [OpensMeasurableSpace \u03a9]\n    {\u03bc : ProbabilityMeasure \u03a9} {\u03bcs : \u03b9 \u2192 ProbabilityMeasure \u03a9} (\u03bcs_lim : Tendsto \u03bcs L (\ud835\udcdd \u03bc))\n    {E : Set \u03a9} (E_nullbdry : (\u03bc : Measure \u03a9) (frontier E) = 0) :\n    Tendsto (fun i => (\u03bcs i : Measure \u03a9) E) L (\ud835\udcdd ((\u03bc : Measure \u03a9) E))", "start": [406, 1], "end": [413, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto", "code": "theorem ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto {\u03a9 \u03b9 : Type*} {L : Filter \u03b9}\n    [MeasurableSpace \u03a9] [PseudoEMetricSpace \u03a9] [OpensMeasurableSpace \u03a9] {\u03bc : ProbabilityMeasure \u03a9}\n    {\u03bcs : \u03b9 \u2192 ProbabilityMeasure \u03a9} (\u03bcs_lim : Tendsto \u03bcs L (\ud835\udcdd \u03bc)) {E : Set \u03a9}\n    (E_nullbdry : \u03bc (frontier E) = 0) : Tendsto (fun i => \u03bcs i E) L (\ud835\udcdd (\u03bc E))", "start": [416, 1], "end": [431, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_null_frontier_thickening", "code": "theorem exists_null_frontier_thickening (\u03bc : Measure \u03a9) [SigmaFinite \u03bc] (s : Set \u03a9) {a b : \u211d}\n    (hab : a < b) : \u2203 r \u2208 Ioo a b, \u03bc (frontier (Metric.thickening r s)) = 0", "start": [463, 1], "end": [474, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_null_frontiers_thickening", "code": "theorem exists_null_frontiers_thickening (\u03bc : Measure \u03a9) [SigmaFinite \u03bc] (s : Set \u03a9) :\n    \u2203 rs : \u2115 \u2192 \u211d,\n      Tendsto rs atTop (\ud835\udcdd 0) \u2227 \u2200 n, 0 < rs n \u2227 \u03bc (frontier (Metric.thickening (rs n) s)) = 0", "start": [477, 1], "end": [485, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.limsup_measure_closed_le_of_forall_tendsto_measure", "code": "lemma limsup_measure_closed_le_of_forall_tendsto_measure\n    {\u03a9 \u03b9 : Type*} {L : Filter \u03b9} [NeBot L]\n    [MeasurableSpace \u03a9] [PseudoEMetricSpace \u03a9] [OpensMeasurableSpace \u03a9]\n    {\u03bc : Measure \u03a9} [IsFiniteMeasure \u03bc] {\u03bcs : \u03b9 \u2192 Measure \u03a9}\n    (h : \u2200 {E : Set \u03a9}, MeasurableSet E \u2192 \u03bc (frontier E) = 0 \u2192\n            Tendsto (fun i \u21a6 \u03bcs i E) L (\ud835\udcdd (\u03bc E)))\n    (F : Set \u03a9) (F_closed : IsClosed F) :\n    L.limsup (fun i \u21a6 \u03bcs i F) \u2264 \u03bc F := by\n  have ex := exists_null_frontiers_thickening \u03bc F\n  let rs := Classical.choose ex\n  have rs_lim : Tendsto rs atTop (\ud835\udcdd 0) := (Classical.choose_spec ex).1\n  have rs_pos : \u2200 n, 0 < rs n := fun n \u21a6 ((Classical.choose_spec ex).2 n).1\n  have rs_null : \u2200 n, \u03bc (frontier (Metric.thickening (rs n) F)) = 0 :=\n    fun n \u21a6 ((Classical.choose_spec ex).2 n).2\n  have Fthicks_open : \u2200 n, IsOpen (Metric.thickening (rs n) F) :=\n    fun n \u21a6 Metric.isOpen_thickening\n  have key := fun (n : \u2115) \u21a6 h (Fthicks_open n).measurableSet (rs_null n)\n  apply ENNReal.le_of_forall_pos_le_add\n  intros \u03b5 \u03b5_pos \u03bcF_finite\n  have keyB := tendsto_measure_cthickening_of_isClosed (\u03bc := \u03bc) (s := F)\n                \u27e81, \u27e8by simp only [gt_iff_lt, zero_lt_one], measure_ne_top _ _\u27e9\u27e9 F_closed\n  have nhd : Iio (\u03bc F + \u03b5) \u2208 \ud835\udcdd (\u03bc F) := by\n    apply Iio_mem_nhds\n    exact ENNReal.lt_add_right \u03bcF_finite.ne (ENNReal.coe_pos.mpr \u03b5_pos).ne'\n  specialize rs_lim (keyB nhd)\n  simp only [mem_map, mem_atTop_sets, ge_iff_le, mem_preimage, mem_Iio] at rs_lim\n  obtain \u27e8m, hm\u27e9 := rs_lim\n  have aux' := fun i \u21a6 measure_mono (\u03bc := \u03bcs i) (Metric.self_subset_thickening (rs_pos m) F)\n  have aux : (fun i \u21a6 (\u03bcs i F)) \u2264\u1da0[L] (fun i \u21a6 \u03bcs i (Metric.thickening (rs m) F)) :=\n    eventually_of_forall aux'\n  refine (limsup_le_limsup aux).trans ?_\n  rw [Tendsto.limsup_eq (key m)]\n  apply (measure_mono (Metric.thickening_subset_cthickening (rs m) F)).trans (hm m rfl.le).le", "start": [488, 1], "end": [524, 94], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.le_liminf_measure_open_of_forall_tendsto_measure", "code": "lemma le_liminf_measure_open_of_forall_tendsto_measure\n    {\u03a9 \u03b9 : Type*} {L : Filter \u03b9} [NeBot L]\n    [MeasurableSpace \u03a9] [PseudoEMetricSpace \u03a9] [OpensMeasurableSpace \u03a9]\n    {\u03bc : Measure \u03a9} [IsProbabilityMeasure \u03bc] {\u03bcs : \u03b9 \u2192 Measure \u03a9} [\u2200 i, IsProbabilityMeasure (\u03bcs i)]\n    (h : \u2200 {E}, MeasurableSet E \u2192 \u03bc (frontier E) = 0 \u2192 Tendsto (fun i \u21a6 \u03bcs i E) L (\ud835\udcdd (\u03bc E)))\n    (G : Set \u03a9) (G_open : IsOpen G) :\n    \u03bc G \u2264 L.liminf (fun i \u21a6 \u03bcs i G) := by\n  apply le_measure_liminf_of_limsup_measure_compl_le G_open.measurableSet\n  exact limsup_measure_closed_le_of_forall_tendsto_measure h _ (isClosed_compl_iff.mpr G_open)", "start": [526, 1], "end": [538, 95], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/CategoryTheory/Abelian/Injective.lean", "imports": ["Mathlib/CategoryTheory/Preadditive/Yoneda/Injective.lean", "Mathlib/CategoryTheory/Preadditive/Injective.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Preadditive/Yoneda/Limits.lean", "Mathlib/CategoryTheory/Abelian/Exact.lean"], "premises": [{"full_name": "CategoryTheory.preservesFiniteColimitsPreadditiveYonedaObjOfInjective", "code": "def preservesFiniteColimitsPreadditiveYonedaObjOfInjective (J : C) [hP : Injective J] :\n    PreservesFiniteColimits (preadditiveYonedaObj J) := by\n  letI := (injective_iff_preservesEpimorphisms_preadditive_yoneda_obj' J).mp hP\n  apply Functor.preservesFiniteColimitsOfPreservesEpisAndKernels", "start": [37, 1], "end": [41, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.injective_of_preservesFiniteColimits_preadditiveYonedaObj", "code": "theorem injective_of_preservesFiniteColimits_preadditiveYonedaObj (J : C)\n    [hP : PreservesFiniteColimits (preadditiveYonedaObj J)] : Injective J", "start": [44, 1], "end": [48, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Ordinal/CantorNormalForm.lean", "imports": ["Mathlib/SetTheory/Ordinal/Arithmetic.lean", "Mathlib/SetTheory/Ordinal/Exponential.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ordinal.CNFRec", "code": "@[elab_as_elim]\nnoncomputable def CNFRec (b : Ordinal) {C : Ordinal \u2192 Sort*} (H0 : C 0)\n    (H : \u2200 o, o \u2260 0 \u2192 C (o % b ^ log b o) \u2192 C o) : \u2200 o, C o := fun o \u21a6 by\n    by_cases h : o = 0\n    \u00b7 rw [h]; exact H0\n    \u00b7 exact H o h (CNFRec _ H0 H (o % b ^ log b o))\n    termination_by CNFRec b H0 H o => o\n    decreasing_by exact mod_opow_log_lt_self b h", "start": [42, 1], "end": [50, 49], "kind": "commanddeclaration"}, {"full_name": "Ordinal.CNFRec_zero", "code": "@[simp]\ntheorem CNFRec_zero {C : Ordinal \u2192 Sort*} (b : Ordinal) (H0 : C 0)\n    (H : \u2200 o, o \u2260 0 \u2192 C (o % b ^ log b o) \u2192 C o) : @CNFRec b C H0 H 0 = H0", "start": [54, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.CNFRec_pos", "code": "theorem CNFRec_pos (b : Ordinal) {o : Ordinal} {C : Ordinal \u2192 Sort*} (ho : o \u2260 0) (H0 : C 0)\n    (H : \u2200 o, o \u2260 0 \u2192 C (o % b ^ log b o) \u2192 C o) :\n    @CNFRec b C H0 H o = H o ho (@CNFRec b C H0 H _)", "start": [62, 1], "end": [64, 83], "kind": "commanddeclaration"}, {"full_name": "Ordinal.CNF", "code": "def CNF (b o : Ordinal) : List (Ordinal \u00d7 Ordinal) :=\n  CNFRec b [] (fun o _ho IH \u21a6 (log b o, o / b ^ log b o)::IH) o", "start": [69, 1], "end": [76, 64], "kind": "commanddeclaration"}, {"full_name": "Ordinal.CNF_zero", "code": "@[simp]\ntheorem CNF_zero (b : Ordinal) : CNF b 0 = []", "start": [80, 1], "end": [82, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.CNF_ne_zero", "code": "theorem CNF_ne_zero {b o : Ordinal} (ho : o \u2260 0) :\n    CNF b o = (log b o, o / b ^ log b o)::CNF b (o % b ^ log b o)", "start": [86, 1], "end": [89, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.zero_CNF", "code": "theorem zero_CNF {o : Ordinal} (ho : o \u2260 0) : CNF 0 o = [\u27e80, o\u27e9]", "start": [93, 1], "end": [93, 93], "kind": "commanddeclaration"}, {"full_name": "Ordinal.one_CNF", "code": "theorem one_CNF {o : Ordinal} (ho : o \u2260 0) : CNF 1 o = [\u27e80, o\u27e9]", "start": [97, 1], "end": [97, 92], "kind": "commanddeclaration"}, {"full_name": "Ordinal.CNF_of_le_one", "code": "theorem CNF_of_le_one {b o : Ordinal} (hb : b \u2264 1) (ho : o \u2260 0) : CNF b o = [\u27e80, o\u27e9]", "start": [101, 1], "end": [104, 21], "kind": "commanddeclaration"}, {"full_name": "Ordinal.CNF_of_lt", "code": "theorem CNF_of_lt {b o : Ordinal} (ho : o \u2260 0) (hb : o < b) : CNF b o = [\u27e80, o\u27e9]", "start": [108, 1], "end": [109, 84], "kind": "commanddeclaration"}, {"full_name": "Ordinal.CNF_foldr", "code": "theorem CNF_foldr (b o : Ordinal) : (CNF b o).foldr (fun p r \u21a6 b ^ p.1 * p.2 + r) 0 = o", "start": [113, 1], "end": [116, 74], "kind": "commanddeclaration"}, {"full_name": "Ordinal.CNF_fst_le_log", "code": "theorem CNF_fst_le_log {b o : Ordinal.{u}} {x : Ordinal \u00d7 Ordinal} :\n    x \u2208 CNF b o \u2192 x.1 \u2264 log b o", "start": [120, 1], "end": [129, 74], "kind": "commanddeclaration"}, {"full_name": "Ordinal.CNF_fst_le", "code": "theorem CNF_fst_le {b o : Ordinal.{u}} {x : Ordinal \u00d7 Ordinal} (h : x \u2208 CNF b o) : x.1 \u2264 o", "start": [133, 1], "end": [135, 46], "kind": "commanddeclaration"}, {"full_name": "Ordinal.CNF_lt_snd", "code": "theorem CNF_lt_snd {b o : Ordinal.{u}} {x : Ordinal \u00d7 Ordinal} : x \u2208 CNF b o \u2192 0 < x.2", "start": [139, 1], "end": [145, 15], "kind": "commanddeclaration"}, {"full_name": "Ordinal.CNF_snd_lt", "code": "theorem CNF_snd_lt {b o : Ordinal.{u}} (hb : 1 < b) {x : Ordinal \u00d7 Ordinal} :\n    x \u2208 CNF b o \u2192 x.2 < b", "start": [149, 1], "end": [158, 17], "kind": "commanddeclaration"}, {"full_name": "Ordinal.CNF_sorted", "code": "theorem CNF_sorted (b o : Ordinal) : ((CNF b o).map Prod.fst).Sorted (\u00b7 > \u00b7)", "start": [162, 1], "end": [174, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Skeleton.lean", "imports": ["Mathlib/CategoryTheory/Skeletal.lean", "Mathlib/CategoryTheory/Monoidal/Transport.lean", "Mathlib/CategoryTheory/Monoidal/Braided.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.monoidOfSkeletalMonoidal", "code": "@[reducible]\ndef monoidOfSkeletalMonoidal (hC : Skeletal C) : Monoid C where\n  mul X Y := (X \u2297 Y : C)\n  one := (\ud835\udfd9_ C : C)\n  one_mul X := hC \u27e8\u03bb_ X\u27e9\n  mul_one X := hC \u27e8\u03c1_ X\u27e9\n  mul_assoc X Y Z := hC \u27e8\u03b1_ X Y Z\u27e9", "start": [33, 1], "end": [41, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.commMonoidOfSkeletalBraided", "code": "def commMonoidOfSkeletalBraided [BraidedCategory C] (hC : Skeletal C) : CommMonoid C :=\n  { monoidOfSkeletalMonoidal hC with mul_comm := fun X Y => hC \u27e8\u03b2_ X Y\u27e9 }", "start": [44, 1], "end": [46, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Skeleton.instMonoidalCategory", "code": "noncomputable instance instMonoidalCategory : MonoidalCategory (Skeleton C) :=\n  Monoidal.transport (skeletonEquivalence C).symm", "start": [51, 1], "end": [54, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Skeleton.instMonoid", "code": "noncomputable instance instMonoid : Monoid (Skeleton C) :=\n  monoidOfSkeletalMonoidal (skeletonIsSkeleton _).skel", "start": [56, 1], "end": [61, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Skeleton.instBraidedCategory", "code": "noncomputable instance instBraidedCategory [BraidedCategory C] : BraidedCategory (Skeleton C) :=\n  letI := Monoidal.instIsEquivalence_fromTransported (skeletonEquivalence C).symm\n  braidedCategoryOfFullyFaithful (Monoidal.fromTransported (skeletonEquivalence C).symm)", "start": [63, 1], "end": [67, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Skeleton.instCommMonoid", "code": "noncomputable instance instCommMonoid [BraidedCategory C] : CommMonoid (Skeleton C) :=\n  commMonoidOfSkeletalBraided (skeletonIsSkeleton _).skel", "start": [69, 1], "end": [75, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/SleepHeartbeats.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "sleepAtLeastHeartbeats", "code": "def sleepAtLeastHeartbeats (n : Nat) : IO Unit := do\n  let i \u2190 IO.getNumHeartbeats\n  while (\u2190 IO.getNumHeartbeats) < i + n do\n    continue", "start": [16, 1], "end": [26, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/NumberField/ClassNumber.lean", "imports": ["Mathlib/NumberTheory/ClassNumber/AdmissibleAbs.lean", "Mathlib/NumberTheory/NumberField/Basic.lean", "Mathlib/NumberTheory/ClassNumber/Finite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NumberField.RingOfIntegers.instFintypeClassGroup", "code": "noncomputable instance instFintypeClassGroup : Fintype (ClassGroup (ringOfIntegers K)) :=\n  ClassGroup.fintypeOfAdmissibleOfFinite \u211a K AbsoluteValue.absIsAdmissible", "start": [31, 1], "end": [32, 75], "kind": "commanddeclaration"}, {"full_name": "NumberField.classNumber", "code": "noncomputable def classNumber : \u2115 :=\n  Fintype.card (ClassGroup (ringOfIntegers K))", "start": [36, 1], "end": [38, 47], "kind": "commanddeclaration"}, {"full_name": "NumberField.classNumber_eq_one_iff", "code": "theorem classNumber_eq_one_iff : classNumber K = 1 \u2194 IsPrincipalIdealRing (ringOfIntegers K)", "start": [43, 1], "end": [45, 29], "kind": "commanddeclaration"}, {"full_name": "Rat.classNumber_eq", "code": "theorem classNumber_eq : NumberField.classNumber \u211a = 1", "start": [54, 1], "end": [57, 101], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Module/Alternating.lean", "imports": ["Mathlib/LinearAlgebra/BilinearMap.lean", "Mathlib/Topology/Algebra/Module/Multilinear.lean", "Mathlib/LinearAlgebra/Alternating/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousAlternatingMap", "code": "structure ContinuousAlternatingMap (R M N \u03b9 : Type*) [Semiring R] [AddCommMonoid M] [Module R M]\n    [TopologicalSpace M] [AddCommMonoid N] [Module R N] [TopologicalSpace N] extends\n    ContinuousMultilinearMap R (fun _ : \u03b9 => M) N, AlternatingMap R M N \u03b9 where", "start": [30, 1], "end": [38, 80], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.toContinuousMultilinearMap_injective", "code": "theorem toContinuousMultilinearMap_injective :\n    Injective (ContinuousAlternatingMap.toContinuousMultilinearMap :\n      M [\u039b^\u03b9]\u2192L[R] N \u2192 ContinuousMultilinearMap R (fun _ : \u03b9 => M) N)", "start": [57, 1], "end": [60, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.range_toContinuousMultilinearMap", "code": "theorem range_toContinuousMultilinearMap :\n    Set.range\n        (toContinuousMultilinearMap :\n          M [\u039b^\u03b9]\u2192L[R] N \u2192 ContinuousMultilinearMap R (fun _ : \u03b9 => M) N) =\n      {f | \u2200 (v : \u03b9 \u2192 M) (i j : \u03b9), v i = v j \u2192 i \u2260 j \u2192 f v = 0}", "start": [62, 1], "end": [67, 69], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.continuousMapClass", "code": "instance continuousMapClass : ContinuousMapClass (M [\u039b^\u03b9]\u2192L[R] N) (\u03b9 \u2192 M) N where\n  coe f := f.toFun\n  coe_injective' _ _ h := toContinuousMultilinearMap_injective <| FunLike.ext' h\n  map_continuous f := f.cont", "start": [69, 1], "end": [72, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.coe_continuous", "code": "@[continuity]\ntheorem coe_continuous : Continuous f", "start": [76, 1], "end": [77, 48], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.coe_toContinuousMultilinearMap", "code": "@[simp]\ntheorem coe_toContinuousMultilinearMap : \u21d1f.toContinuousMultilinearMap = f", "start": [79, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : ContinuousMultilinearMap R (fun _ : \u03b9 => M) N) (h) : \u21d1(mk f h) = f", "start": [83, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.coe_toAlternatingMap", "code": "theorem coe_toAlternatingMap : \u21d1f.toAlternatingMap = f", "start": [89, 1], "end": [89, 62], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.ext", "code": "@[ext]\ntheorem ext {f g : M [\u039b^\u03b9]\u2192L[R] N} (H : \u2200 x, f x = g x) : f = g", "start": [91, 1], "end": [93, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.ext_iff", "code": "theorem ext_iff {f g : M [\u039b^\u03b9]\u2192L[R] N} : f = g \u2194 \u2200 x, f x = g x", "start": [95, 1], "end": [96, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.toAlternatingMap_injective", "code": "theorem toAlternatingMap_injective :\n    Injective (toAlternatingMap : M [\u039b^\u03b9]\u2192L[R] N \u2192 AlternatingMap R M N \u03b9)", "start": [98, 1], "end": [100, 50], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.range_toAlternatingMap", "code": "@[simp]\ntheorem range_toAlternatingMap :\n    Set.range (toAlternatingMap : M [\u039b^\u03b9]\u2192L[R] N \u2192 AlternatingMap R M N \u03b9) =\n      {f : AlternatingMap R M N \u03b9 | Continuous f}", "start": [102, 1], "end": [106, 99], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.map_add", "code": "@[simp]\ntheorem map_add [DecidableEq \u03b9] (m : \u03b9 \u2192 M) (i : \u03b9) (x y : M) :\n    f (update m i (x + y)) = f (update m i x) + f (update m i y)", "start": [108, 1], "end": [111, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.map_smul", "code": "@[simp]\ntheorem map_smul [DecidableEq \u03b9] (m : \u03b9 \u2192 M) (i : \u03b9) (c : R) (x : M) :\n    f (update m i (c \u2022 x)) = c \u2022 f (update m i x)", "start": [113, 1], "end": [116, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.map_coord_zero", "code": "theorem map_coord_zero {m : \u03b9 \u2192 M} (i : \u03b9) (h : m i = 0) : f m = 0", "start": [118, 1], "end": [119, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.map_update_zero", "code": "@[simp]\ntheorem map_update_zero [DecidableEq \u03b9] (m : \u03b9 \u2192 M) (i : \u03b9) : f (update m i 0) = 0", "start": [121, 1], "end": [123, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.map_zero", "code": "@[simp]\ntheorem map_zero [Nonempty \u03b9] : f 0 = 0", "start": [125, 1], "end": [127, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.map_eq_zero_of_eq", "code": "theorem map_eq_zero_of_eq (v : \u03b9 \u2192 M) {i j : \u03b9} (h : v i = v j) (hij : i \u2260 j) : f v = 0", "start": [129, 1], "end": [130, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.map_eq_zero_of_not_injective", "code": "theorem map_eq_zero_of_not_injective (v : \u03b9 \u2192 M) (hv : \u00acFunction.Injective v) : f v = 0", "start": [132, 1], "end": [133, 55], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.codRestrict", "code": "@[simps!]\ndef codRestrict (f : M [\u039b^\u03b9]\u2192L[R] N) (p : Submodule R N) (h : \u2200 v, f v \u2208 p) : M [\u039b^\u03b9]\u2192L[R] p :=\n  { f.toAlternatingMap.codRestrict p h with toContinuousMultilinearMap := f.1.codRestrict p h }", "start": [135, 1], "end": [138, 96], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : M [\u039b^\u03b9]\u2192L[R] N) = 0", "start": [146, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.toContinuousMultilinearMap_zero", "code": "@[simp]\ntheorem toContinuousMultilinearMap_zero : (0 : M [\u039b^\u03b9]\u2192L[R] N).toContinuousMultilinearMap = 0", "start": [150, 1], "end": [152, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.toAlternatingMap_zero", "code": "@[simp]\ntheorem toAlternatingMap_zero : (0 : M [\u039b^\u03b9]\u2192L[R] N).toAlternatingMap = 0", "start": [154, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.coe_smul", "code": "@[simp]\ntheorem coe_smul (f : M [\u039b^\u03b9]\u2192L[A] N) (c : R') : \u21d1(c \u2022 f) = c \u2022 \u21d1f", "start": [167, 1], "end": [169, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.smul_apply", "code": "theorem smul_apply (f : M [\u039b^\u03b9]\u2192L[A] N) (c : R') (v : \u03b9 \u2192 M) : (c \u2022 f) v = c \u2022 f v", "start": [171, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.toContinuousMultilinearMap_smul", "code": "@[simp]\ntheorem toContinuousMultilinearMap_smul (c : R') (f : M [\u039b^\u03b9]\u2192L[A] N) :\n    (c \u2022 f).toContinuousMultilinearMap = c \u2022 f.toContinuousMultilinearMap", "start": [174, 1], "end": [177, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.toAlternatingMap_smul", "code": "@[simp]\ntheorem toAlternatingMap_smul (c : R') (f : M [\u039b^\u03b9]\u2192L[A] N) :\n    (c \u2022 f).toAlternatingMap = c \u2022 f.toAlternatingMap", "start": [179, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.coe_add", "code": "@[simp]\ntheorem coe_add : \u21d1(f + g) = \u21d1f + \u21d1g", "start": [205, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.add_apply", "code": "@[simp]\ntheorem add_apply (v : \u03b9 \u2192 M) : (f + g) v = f v + g v", "start": [209, 1], "end": [211, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.toContinuousMultilinearMap_add", "code": "@[simp]\ntheorem toContinuousMultilinearMap_add (f g : M [\u039b^\u03b9]\u2192L[R] N) : (f + g).1 = f.1 + g.1", "start": [213, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.toAlternatingMap_add", "code": "@[simp]\ntheorem toAlternatingMap_add (f g : M [\u039b^\u03b9]\u2192L[R] N) :\n    (f + g).toAlternatingMap = f.toAlternatingMap + g.toAlternatingMap", "start": [217, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.addCommMonoid", "code": "instance addCommMonoid : AddCommMonoid (M [\u039b^\u03b9]\u2192L[R] N) :=\n  toContinuousMultilinearMap_injective.addCommMonoid _ rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [222, 1], "end": [223, 91], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.applyAddHom", "code": "def applyAddHom (v : \u03b9 \u2192 M) : M [\u039b^\u03b9]\u2192L[R] N \u2192+ N :=\n  \u27e8\u27e8fun f => f v, rfl\u27e9, fun _ _ => rfl\u27e9", "start": [225, 1], "end": [227, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.sum_apply", "code": "@[simp]\ntheorem sum_apply {\u03b1 : Type*} (f : \u03b1 \u2192 M [\u039b^\u03b9]\u2192L[R] N) (m : \u03b9 \u2192 M) {s : Finset \u03b1} :\n    (\u2211 a in s, f a) m = \u2211 a in s, f a m", "start": [229, 1], "end": [232, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.toMultilinearAddHom", "code": "@[simps]\ndef toMultilinearAddHom : M [\u039b^\u03b9]\u2192L[R] N \u2192+ ContinuousMultilinearMap R (fun _ : \u03b9 => M) N :=\n  \u27e8\u27e8fun f => f.1, rfl\u27e9, fun _ _ => rfl\u27e9", "start": [234, 1], "end": [237, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.toContinuousLinearMap", "code": "@[simps! apply]\ndef toContinuousLinearMap [DecidableEq \u03b9] (m : \u03b9 \u2192 M) (i : \u03b9) : M \u2192L[R] N :=\n  f.1.toContinuousLinearMap m i", "start": [241, 1], "end": [246, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.prod", "code": "@[simps!]\ndef prod (f : M [\u039b^\u03b9]\u2192L[R] N) (g : M [\u039b^\u03b9]\u2192L[R] N') : M [\u039b^\u03b9]\u2192L[R] (N \u00d7 N') :=\n  \u27e8f.1.prod g.1, (f.toAlternatingMap.prod g.toAlternatingMap).map_eq_zero_of_eq\u27e9", "start": [248, 1], "end": [251, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.pi", "code": "def pi {\u03b9' : Type*} {M' : \u03b9' \u2192 Type*} [\u2200 i, AddCommMonoid (M' i)] [\u2200 i, TopologicalSpace (M' i)]\n    [\u2200 i, Module R (M' i)] (f : \u2200 i, M [\u039b^\u03b9]\u2192L[R] M' i) : M [\u039b^\u03b9]\u2192L[R] \u2200 i, M' i :=\n  \u27e8ContinuousMultilinearMap.pi fun i => (f i).1,\n    (AlternatingMap.pi fun i => (f i).toAlternatingMap).map_eq_zero_of_eq\u27e9", "start": [253, 1], "end": [258, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.coe_pi", "code": "@[simp]\ntheorem coe_pi {\u03b9' : Type*} {M' : \u03b9' \u2192 Type*} [\u2200 i, AddCommMonoid (M' i)]\n    [\u2200 i, TopologicalSpace (M' i)] [\u2200 i, Module R (M' i)] (f : \u2200 i, M [\u039b^\u03b9]\u2192L[R] M' i) :\n    \u21d1(pi f) = fun m j => f j m", "start": [260, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.pi_apply", "code": "theorem pi_apply {\u03b9' : Type*} {M' : \u03b9' \u2192 Type*} [\u2200 i, AddCommMonoid (M' i)]\n    [\u2200 i, TopologicalSpace (M' i)] [\u2200 i, Module R (M' i)] (f : \u2200 i, M [\u039b^\u03b9]\u2192L[R] M' i) (m : \u03b9 \u2192 M)\n    (j : \u03b9') : pi f m j = f j m", "start": [266, 1], "end": [269, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.ofSubsingleton", "code": "@[simps! toContinuousMultilinearMap apply]\ndef ofSubsingleton [Subsingleton \u03b9] (i' : \u03b9) : M [\u039b^\u03b9]\u2192L[R] M :=\n  { AlternatingMap.ofSubsingleton R _ i' with\n    toContinuousMultilinearMap := ContinuousMultilinearMap.ofSubsingleton R _ i' }", "start": [275, 1], "end": [280, 83], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.ofSubsingleton_toAlternatingMap", "code": "@[simp]\ntheorem ofSubsingleton_toAlternatingMap [Subsingleton \u03b9] (i' : \u03b9) :\n    (ofSubsingleton R M i').toAlternatingMap = AlternatingMap.ofSubsingleton R M i'", "start": [282, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.constOfIsEmpty", "code": "@[simps! toContinuousMultilinearMap apply]\ndef constOfIsEmpty [IsEmpty \u03b9] (m : N) : M [\u039b^\u03b9]\u2192L[R] N :=\n  { AlternatingMap.constOfIsEmpty R M \u03b9 m with\n    toContinuousMultilinearMap := ContinuousMultilinearMap.constOfIsEmpty R (fun _ => M) m }", "start": [289, 1], "end": [293, 93], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.constOfIsEmpty_toAlternatingMap", "code": "@[simp]\ntheorem constOfIsEmpty_toAlternatingMap [IsEmpty \u03b9] (m : N) :\n    (constOfIsEmpty R M \u03b9 m).toAlternatingMap = AlternatingMap.constOfIsEmpty R M \u03b9 m", "start": [295, 1], "end": [298, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.compContinuousLinearMap", "code": "def compContinuousLinearMap (g : M [\u039b^\u03b9]\u2192L[R] N) (f : M' \u2192L[R] M) : M' [\u039b^\u03b9]\u2192L[R] N :=\n  { g.toAlternatingMap.compLinearMap (f : M' \u2192\u2097[R] M) with\n    toContinuousMultilinearMap := g.1.compContinuousLinearMap fun _ => f }", "start": [302, 1], "end": [306, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.compContinuousLinearMap_apply", "code": "@[simp]\ntheorem compContinuousLinearMap_apply (g : M [\u039b^\u03b9]\u2192L[R] N) (f : M' \u2192L[R] M) (m : \u03b9 \u2192 M') :\n    g.compContinuousLinearMap f m = g (f \u2218 m)", "start": [308, 1], "end": [311, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compContinuousAlternatingMap", "code": "def _root_.ContinuousLinearMap.compContinuousAlternatingMap (g : N \u2192L[R] N') (f : M [\u039b^\u03b9]\u2192L[R] N) :\n    M [\u039b^\u03b9]\u2192L[R] N' :=\n  { (g : N \u2192\u2097[R] N').compAlternatingMap f.toAlternatingMap with\n    toContinuousMultilinearMap := g.compContinuousMultilinearMap f.1 }", "start": [313, 1], "end": [318, 71], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compContinuousAlternatingMap_coe", "code": "@[simp]\ntheorem _root_.ContinuousLinearMap.compContinuousAlternatingMap_coe (g : N \u2192L[R] N')\n    (f : M [\u039b^\u03b9]\u2192L[R] N) : \u21d1(g.compContinuousAlternatingMap f) = g \u2218 f", "start": [320, 1], "end": [323, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.continuousAlternatingMapComp", "code": "def _root_.ContinuousLinearEquiv.continuousAlternatingMapComp (e : M \u2243L[R] M') :\n    M [\u039b^\u03b9]\u2192L[R] N \u2243 M' [\u039b^\u03b9]\u2192L[R] N where\n  toFun f := f.compContinuousLinearMap \u2191e.symm\n  invFun f := f.compContinuousLinearMap \u2191e\n  left_inv f := by ext; simp [(\u00b7 \u2218 \u00b7)]\n  right_inv f := by ext; simp [(\u00b7 \u2218 \u00b7)]", "start": [325, 1], "end": [332, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.compContinuousAlternatingMap", "code": "def _root_.ContinuousLinearEquiv.compContinuousAlternatingMap (e : N \u2243L[R] N') :\n    M [\u039b^\u03b9]\u2192L[R] N \u2243 M [\u039b^\u03b9]\u2192L[R] N' where\n  toFun := (e : N \u2192L[R] N').compContinuousAlternatingMap\n  invFun := (e.symm : N' \u2192L[R] N).compContinuousAlternatingMap\n  left_inv f := by ext; simp [(\u00b7 \u2218 \u00b7)]\n  right_inv f := by ext; simp [(\u00b7 \u2218 \u00b7)]", "start": [334, 1], "end": [341, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.compContinuousAlternatingMap_coe", "code": "@[simp]\ntheorem _root_.ContinuousLinearEquiv.compContinuousAlternatingMap_coe\n    (e : N \u2243L[R] N') (f : M [\u039b^\u03b9]\u2192L[R] N) : \u21d1(e.compContinuousAlternatingMap f) = e \u2218 f", "start": [343, 1], "end": [346, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.continuousAlternatingMapCongr", "code": "def _root_.ContinuousLinearEquiv.continuousAlternatingMapCongr (e : M \u2243L[R] M') (e' : N \u2243L[R] N') :\n    M [\u039b^\u03b9]\u2192L[R] N \u2243 M' [\u039b^\u03b9]\u2192L[R] N' :=\n  e.continuousAlternatingMapComp.trans e'.compContinuousAlternatingMap", "start": [348, 1], "end": [352, 71], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.piEquiv", "code": "@[simps]\ndef piEquiv {\u03b9' : Type*} {N : \u03b9' \u2192 Type*} [\u2200 i, AddCommMonoid (N i)] [\u2200 i, TopologicalSpace (N i)]\n    [\u2200 i, Module R (N i)] : (\u2200 i, M [\u039b^\u03b9]\u2192L[R] N i) \u2243 M [\u039b^\u03b9]\u2192L[R] \u2200 i, N i where\n  toFun := pi\n  invFun f i := (ContinuousLinearMap.proj i : _ \u2192L[R] N i).compContinuousAlternatingMap f\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl", "start": [354, 1], "end": [361, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.cons_add", "code": "theorem cons_add (f : ContinuousAlternatingMap R M N (Fin (n + 1))) (m : Fin n \u2192 M) (x y : M) :\n    f (Fin.cons (x + y) m) = f (Fin.cons x m) + f (Fin.cons y m)", "start": [363, 1], "end": [368, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.vecCons_add", "code": "theorem vecCons_add (f : ContinuousAlternatingMap R M N (Fin (n + 1))) (m : Fin n \u2192 M) (x y : M) :\n    f (vecCons (x + y) m) = f (vecCons x m) + f (vecCons y m)", "start": [370, 1], "end": [375, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.cons_smul", "code": "theorem cons_smul (f : ContinuousAlternatingMap R M N (Fin (n + 1))) (m : Fin n \u2192 M) (c : R)\n    (x : M) : f (Fin.cons (c \u2022 x) m) = c \u2022 f (Fin.cons x m)", "start": [377, 1], "end": [382, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.vecCons_smul", "code": "theorem vecCons_smul (f : ContinuousAlternatingMap R M N (Fin (n + 1))) (m : Fin n \u2192 M) (c : R)\n    (x : M) : f (vecCons (c \u2022 x) m) = c \u2022 f (vecCons x m)", "start": [384, 1], "end": [389, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.map_piecewise_add", "code": "theorem map_piecewise_add [DecidableEq \u03b9] (m m' : \u03b9 \u2192 M) (t : Finset \u03b9) :\n    f (t.piecewise (m + m') m') = \u2211 s in t.powerset, f (s.piecewise m m')", "start": [391, 1], "end": [393, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.map_add_univ", "code": "theorem map_add_univ [DecidableEq \u03b9] [Fintype \u03b9] (m m' : \u03b9 \u2192 M) :\n    f (m + m') = \u2211 s : Finset \u03b9, f (s.piecewise m m')", "start": [395, 1], "end": [399, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.map_sum_finset", "code": "theorem map_sum_finset :\n    (f fun i => \u2211 j in A i, g' i j) = \u2211 r in piFinset A, f fun i => g' i (r i)", "start": [407, 1], "end": [413, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.map_sum", "code": "theorem map_sum [\u2200 i, Fintype (\u03b1 i)] :\n    (f fun i => \u2211 j, g' i j) = \u2211 r : \u2200 i, \u03b1 i, f fun i => g' i (r i)", "start": [415, 1], "end": [420, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.restrictScalars", "code": "def restrictScalars (f : M [\u039b^\u03b9]\u2192L[A] N) : M [\u039b^\u03b9]\u2192L[R] N :=\n  { f with toContinuousMultilinearMap := f.1.restrictScalars R }", "start": [430, 1], "end": [433, 65], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.coe_restrictScalars", "code": "@[simp]\ntheorem coe_restrictScalars (f : M [\u039b^\u03b9]\u2192L[A] N) : \u21d1(f.restrictScalars R) = f", "start": [435, 1], "end": [437, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.map_sub", "code": "@[simp]\ntheorem map_sub [DecidableEq \u03b9] (m : \u03b9 \u2192 M) (i : \u03b9) (x y : M) :\n    f (update m i (x - y)) = f (update m i x) - f (update m i y)", "start": [450, 1], "end": [453, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.coe_neg", "code": "@[simp]\ntheorem coe_neg : \u21d1(-f) = -f", "start": [462, 1], "end": [464, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.neg_apply", "code": "theorem neg_apply (m : \u03b9 \u2192 M) : (-f) m = -f m", "start": [466, 1], "end": [467, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.coe_sub", "code": "@[simp] theorem coe_sub : \u21d1(f - g) = \u21d1f - \u21d1g", "start": [473, 1], "end": [473, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.sub_apply", "code": "theorem sub_apply (m : \u03b9 \u2192 M) : (f - g) m = f m - g m", "start": [475, 1], "end": [475, 61], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.map_piecewise_smul", "code": "theorem map_piecewise_smul [DecidableEq \u03b9] (c : \u03b9 \u2192 R) (m : \u03b9 \u2192 M) (s : Finset \u03b9) :\n    f (s.piecewise (fun i => c i \u2022 m i) m) = (\u220f i in s, c i) \u2022 f m", "start": [492, 1], "end": [494, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.map_smul_univ", "code": "theorem map_smul_univ [Fintype \u03b9] (c : \u03b9 \u2192 R) (m : \u03b9 \u2192 M) :\n    (f fun i => c i \u2022 m i) = (\u220f i, c i) \u2022 f m", "start": [496, 1], "end": [500, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.toContinuousMultilinearMapLinear", "code": "@[simps]\ndef toContinuousMultilinearMapLinear :\n    M [\u039b^\u03b9]\u2192L[A] N \u2192\u2097[R] ContinuousMultilinearMap A (fun _ : \u03b9 => M) N where\n  toFun := toContinuousMultilinearMap\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [528, 1], "end": [535, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.piLinearEquiv", "code": "@[simps (config := { simpRhs := true })]\ndef piLinearEquiv {\u03b9' : Type*} {M' : \u03b9' \u2192 Type*} [\u2200 i, AddCommMonoid (M' i)]\n    [\u2200 i, TopologicalSpace (M' i)] [\u2200 i, ContinuousAdd (M' i)] [\u2200 i, Module R (M' i)]\n    [\u2200 i, Module A (M' i)] [\u2200 i, SMulCommClass A R (M' i)] [\u2200 i, ContinuousConstSMul R (M' i)] :\n    (\u2200 i, M [\u039b^\u03b9]\u2192L[A] M' i) \u2243\u2097[R] M [\u039b^\u03b9]\u2192L[A] \u2200 i, M' i :=\n  { piEquiv with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }", "start": [537, 1], "end": [545, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.smulRight", "code": "@[simps! toContinuousMultilinearMap apply]\ndef smulRight : M [\u039b^\u03b9]\u2192L[R] N :=\n  { f.toAlternatingMap.smulRight z with toContinuousMultilinearMap := f.1.smulRight z }", "start": [555, 1], "end": [559, 88], "kind": "commanddeclaration"}, {"full_name": "ContinuousAlternatingMap.compContinuousLinearMap\u2097", "code": "@[simps]\ndef compContinuousLinearMap\u2097 (f : M \u2192L[R] M') : (M' [\u039b^\u03b9]\u2192L[R] N) \u2192\u2097[R] (M [\u039b^\u03b9]\u2192L[R] N) where\n  toFun g := g.compContinuousLinearMap f\n  map_add' g g' := by ext; simp\n  map_smul' c g := by ext; simp", "start": [570, 1], "end": [575, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.compContinuousAlternatingMap\u2097", "code": "def _root_.ContinuousLinearMap.compContinuousAlternatingMap\u2097 :\n    (N \u2192L[R] N') \u2192\u2097[R] (M [\u039b^\u03b9]\u2192L[R] N) \u2192\u2097[R] (M [\u039b^\u03b9]\u2192L[R] N') :=\n  LinearMap.mk\u2082 R ContinuousLinearMap.compContinuousAlternatingMap (fun f\u2081 f\u2082 g => rfl)\n    (fun c f g => rfl) (fun f g\u2081 g\u2082 => by ext1; apply f.map_add) fun c f g => by ext1; simp", "start": [579, 1], "end": [583, 92], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.alternatization", "code": "@[simps (config := { isSimp := false }) apply_toContinuousMultilinearMap]\ndef alternatization : ContinuousMultilinearMap R (fun _ : \u03b9 => M) N \u2192+ M [\u039b^\u03b9]\u2192L[R] N where\n  toFun f :=\n    { toContinuousMultilinearMap := \u2211 \u03c3 : Equiv.Perm \u03b9, Equiv.Perm.sign \u03c3 \u2022 f.domDomCongr \u03c3\n      map_eq_zero_of_eq' := fun v i j hv hne => by\n        simpa [MultilinearMap.alternatization_apply]\n          using f.1.alternatization.map_eq_zero_of_eq' v i j hv hne }\n  map_zero' := by ext; simp\n  map_add' _ _ := by ext; simp [Finset.sum_add_distrib]", "start": [595, 1], "end": [604, 56], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.alternatization_apply_apply", "code": "theorem alternatization_apply_apply (v : \u03b9 \u2192 M) :\n    alternatization f v = \u2211 \u03c3 : Equiv.Perm \u03b9, Equiv.Perm.sign \u03c3 \u2022 f (v \u2218 \u03c3)", "start": [606, 1], "end": [608, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousMultilinearMap.alternatization_apply_toAlternatingMap", "code": "@[simp]\ntheorem alternatization_apply_toAlternatingMap :\n    (alternatization f).toAlternatingMap = MultilinearMap.alternatization f.1", "start": [610, 1], "end": [614, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/MeasurableSpace/Invariants.lean", "imports": ["Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasurableSpace.invariants", "code": "def invariants [m : MeasurableSpace \u03b1] (f : \u03b1 \u2192 \u03b1) : MeasurableSpace \u03b1 :=\n  { m \u2293 \u27e8fun s \u21a6 f \u207b\u00b9' s = s, by simp, by simp, fun f hf \u21a6 by simp [hf]\u27e9 with\n    MeasurableSet' := fun s \u21a6 MeasurableSet[m] s \u2227 f \u207b\u00b9' s = s }", "start": [23, 1], "end": [30, 65], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurableSet_invariants", "code": "theorem measurableSet_invariants {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} :\n    MeasurableSet[invariants f] s \u2194 MeasurableSet s \u2227 f \u207b\u00b9' s = s", "start": [34, 1], "end": [38, 7], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.invariants_id", "code": "@[simp]\ntheorem invariants_id : invariants (id : \u03b1 \u2192 \u03b1) = \u2039MeasurableSpace \u03b1\u203a", "start": [40, 1], "end": [42, 43], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.invariants_le", "code": "theorem invariants_le (f : \u03b1 \u2192 \u03b1) : invariants f \u2264 \u2039MeasurableSpace \u03b1\u203a", "start": [44, 1], "end": [44, 91], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.inf_le_invariants_comp", "code": "theorem inf_le_invariants_comp (f g : \u03b1 \u2192 \u03b1) :\n    invariants f \u2293 invariants g \u2264 invariants (f \u2218 g)", "start": [46, 1], "end": [48, 50], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.le_invariants_iterate", "code": "theorem le_invariants_iterate (f : \u03b1 \u2192 \u03b1) (n : \u2115) :\n    invariants f \u2264 invariants (f^[n])", "start": [50, 1], "end": [54, 82], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurable_invariants_dom", "code": "theorem measurable_invariants_dom {f : \u03b1 \u2192 \u03b1} {g : \u03b1 \u2192 \u03b2} :\n    Measurable[invariants f] g \u2194 Measurable g \u2227 \u2200 s, MeasurableSet s \u2192 (g \u2218 f) \u207b\u00b9' s = g \u207b\u00b9' s", "start": [58, 1], "end": [60, 44], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurable_invariants_of_semiconj", "code": "theorem measurable_invariants_of_semiconj {fa : \u03b1 \u2192 \u03b1} {fb : \u03b2 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b2} (hg : Measurable g)\n    (hfg : Semiconj g fa fb) : @Measurable _ _ (invariants fa) (invariants fb) g", "start": [62, 1], "end": [64, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Polynomial/Selmer.lean", "imports": ["Mathlib/Data/Polynomial/UnitTrinomial.lean", "Mathlib/RingTheory/Polynomial/GaussLemma.lean", "Mathlib/Tactic/LinearCombination.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.X_pow_sub_X_sub_one_irreducible_aux", "code": "theorem X_pow_sub_X_sub_one_irreducible_aux (z : \u2102) : \u00ac(z ^ n = z + 1 \u2227 z ^ n + z ^ 2 = 0)", "start": [33, 1], "end": [47, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_pow_sub_X_sub_one_irreducible", "code": "theorem X_pow_sub_X_sub_one_irreducible (hn1 : n \u2260 1) : Irreducible (X ^ n - X - 1 : \u2124[X])", "start": [51, 1], "end": [69, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_pow_sub_X_sub_one_irreducible_rat", "code": "theorem X_pow_sub_X_sub_one_irreducible_rat (hn1 : n \u2260 1) : Irreducible (X ^ n - X - 1 : \u211a[X])", "start": [73, 1], "end": [84, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/ADEInequality.lean", "imports": ["Mathlib/Tactic/IntervalCases.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/PNat/Basic.lean", "Mathlib/Data/PNat/Interval.lean", "Mathlib/Data/Rat/Order.lean", "Mathlib/Tactic/NormNum.lean", "Mathlib/Data/Multiset/Sort.lean"], "premises": [{"full_name": "ADEInequality.A'", "code": "def A' (q r : \u2115+) : Multiset \u2115+ :=\n  {1, q, r}", "start": [47, 1], "end": [51, 12], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.A", "code": "def A (r : \u2115+) : Multiset \u2115+ :=\n  A' 1 r", "start": [54, 1], "end": [60, 9], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.D'", "code": "def D' (r : \u2115+) : Multiset \u2115+ :=\n  {2, 2, r}", "start": [63, 1], "end": [69, 12], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.E'", "code": "def E' (r : \u2115+) : Multiset \u2115+ :=\n  {2, 3, r}", "start": [72, 1], "end": [78, 12], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.E6", "code": "def E6 : Multiset \u2115+ :=\n  E' 3", "start": [81, 1], "end": [87, 7], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.E7", "code": "def E7 : Multiset \u2115+ :=\n  E' 4", "start": [90, 1], "end": [96, 7], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.E8", "code": "def E8 : Multiset \u2115+ :=\n  E' 5", "start": [99, 1], "end": [105, 7], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.sumInv", "code": "def sumInv (pqr : Multiset \u2115+) : \u211a :=\n  Multiset.sum (pqr.map fun (x : \u2115+) => x\u207b\u00b9)", "start": [108, 1], "end": [113, 45], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.sumInv_pqr", "code": "theorem sumInv_pqr (p q r : \u2115+) : sumInv {p, q, r} = (p : \u211a)\u207b\u00b9 + (q : \u211a)\u207b\u00b9 + (r : \u211a)\u207b\u00b9", "start": [116, 1], "end": [118, 34], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.Admissible", "code": "def Admissible (pqr : Multiset \u2115+) : Prop :=\n  (\u2203 q r, A' q r = pqr) \u2228 (\u2203 r, D' r = pqr) \u2228 E' 3 = pqr \u2228 E' 4 = pqr \u2228 E' 5 = pqr", "start": [121, 1], "end": [124, 83], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.admissible_A'", "code": "theorem admissible_A' (q r : \u2115+) : Admissible (A' q r)", "start": [127, 1], "end": [128, 21], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.admissible_D'", "code": "theorem admissible_D' (n : \u2115+) : Admissible (D' n)", "start": [131, 1], "end": [132, 28], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.admissible_E'3", "code": "theorem admissible_E'3 : Admissible (E' 3)", "start": [135, 1], "end": [136, 33], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.admissible_E'4", "code": "theorem admissible_E'4 : Admissible (E' 4)", "start": [139, 1], "end": [140, 43], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.admissible_E'5", "code": "theorem admissible_E'5 : Admissible (E' 5)", "start": [143, 1], "end": [144, 43], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.admissible_E6", "code": "theorem admissible_E6 : Admissible E6", "start": [147, 1], "end": [148, 17], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.admissible_E7", "code": "theorem admissible_E7 : Admissible E7", "start": [151, 1], "end": [152, 17], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.admissible_E8", "code": "theorem admissible_E8 : Admissible E8", "start": [155, 1], "end": [156, 17], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.Admissible.one_lt_sumInv", "code": "theorem Admissible.one_lt_sumInv {pqr : Multiset \u2115+} : Admissible pqr \u2192 1 < sumInv pqr", "start": [159, 1], "end": [170, 53], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.lt_three", "code": "theorem lt_three {p q r : \u2115+} (hpq : p \u2264 q) (hqr : q \u2264 r) (H : 1 < sumInv {p, q, r}) : p < 3", "start": [173, 1], "end": [193, 25], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.lt_four", "code": "theorem lt_four {q r : \u2115+} (hqr : q \u2264 r) (H : 1 < sumInv {2, q, r}) : q < 4", "start": [196, 1], "end": [211, 25], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.lt_six", "code": "theorem lt_six {r : \u2115+} (H : 1 < sumInv {2, 3, r}) : r < 6", "start": [214, 1], "end": [224, 25], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.admissible_of_one_lt_sumInv_aux'", "code": "theorem admissible_of_one_lt_sumInv_aux' {p q r : \u2115+} (hpq : p \u2264 q) (hqr : q \u2264 r)\n    (H : 1 < sumInv {p, q, r}) : Admissible {p, q, r}", "start": [227, 1], "end": [246, 24], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.admissible_of_one_lt_sumInv_aux", "code": "theorem admissible_of_one_lt_sumInv_aux :\n    \u2200 {pqr : List \u2115+} (_ : pqr.Sorted (\u00b7 \u2264 \u00b7)) (_ : pqr.length = 3) (_ : 1 < sumInv pqr),\n      Admissible pqr", "start": [249, 1], "end": [255, 53], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.admissible_of_one_lt_sumInv", "code": "theorem admissible_of_one_lt_sumInv {p q r : \u2115+} (H : 1 < sumInv {p, q, r}) :\n    Admissible {p, q, r}", "start": [258, 1], "end": [267, 80], "kind": "commanddeclaration"}, {"full_name": "ADEInequality.classification", "code": "theorem classification (p q r : \u2115+) : 1 < sumInv {p, q, r} \u2194 Admissible {p, q, r}", "start": [270, 1], "end": [279, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/DirichletCharacter/Basic.lean", "imports": ["Mathlib/Data/ZMod/Algebra.lean", "Mathlib/Data/ZMod/Units.lean", "Mathlib/NumberTheory/LegendreSymbol/MulCharacter.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Periodic.lean"], "premises": [{"full_name": "DirichletCharacter", "code": "abbrev DirichletCharacter (R : Type) [CommMonoidWithZero R] (n : \u2115) := MulChar (ZMod n) R", "start": [33, 1], "end": [34, 90], "kind": "commanddeclaration"}, {"full_name": "DirichletCharacter.toUnitHom_eq_char'", "code": "lemma toUnitHom_eq_char' {a : ZMod n} (ha : IsUnit a) : \u03c7 a = \u03c7.toUnitHom ha.unit := by simp", "start": [40, 1], "end": [40, 93], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.toUnitHom_eq_iff", "code": "lemma toUnitHom_eq_iff (\u03c8 : DirichletCharacter R n) : toUnitHom \u03c7 = toUnitHom \u03c8 \u2194 \u03c7 = \u03c8 := by simp", "start": [42, 1], "end": [42, 99], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.eval_modulus_sub", "code": "lemma eval_modulus_sub (x : ZMod n) : \u03c7 (n - x) = \u03c7 (-x) := by simp", "start": [44, 1], "end": [44, 68], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.periodic", "code": "lemma periodic {m : \u2115} (hm : n \u2223 m) : Function.Periodic \u03c7 m := by\n  intro a\n  rw [\u2190 ZMod.nat_cast_zmod_eq_zero_iff_dvd] at hm\n  simp only [hm, add_zero]", "start": [46, 1], "end": [49, 27], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.changeLevel", "code": "noncomputable def changeLevel {R : Type} [CommMonoidWithZero R] {n m : \u2115} (hm : n \u2223 m) :\n    DirichletCharacter R n \u2192* DirichletCharacter R m :=\n  { toFun := fun \u03c8 \u21a6 MulChar.ofUnitHom (\u03c8.toUnitHom.comp (ZMod.unitsMap hm)),\n    map_one' := by ext; simp,\n    map_mul' := fun \u03c8\u2081 \u03c8\u2082 \u21a6 by ext; simp }", "start": [51, 1], "end": [57, 43], "kind": "commanddeclaration"}, {"full_name": "DirichletCharacter.changeLevel_def", "code": "lemma changeLevel_def {m : \u2115} (hm : n \u2223 m) :\n    changeLevel hm \u03c7 = MulChar.ofUnitHom (\u03c7.toUnitHom.comp (ZMod.unitsMap hm)) := rfl", "start": [59, 1], "end": [60, 86], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.changeLevel_def'", "code": "lemma changeLevel_def' {m : \u2115} (hm : n \u2223 m) :\n    (changeLevel hm \u03c7).toUnitHom = \u03c7.toUnitHom.comp (ZMod.unitsMap hm) := by\n  simp [changeLevel]", "start": [62, 1], "end": [64, 21], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.changeLevel_self", "code": "@[simp]\nlemma changeLevel_self : changeLevel (dvd_refl n) \u03c7 = \u03c7 := by\n  simp [changeLevel, ZMod.unitsMap]", "start": [66, 1], "end": [68, 36], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.changeLevel_self_toUnitHom", "code": "lemma changeLevel_self_toUnitHom : (changeLevel (dvd_refl n) \u03c7).toUnitHom = \u03c7.toUnitHom := by\n  rw [changeLevel_self]", "start": [70, 1], "end": [71, 24], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.changeLevel_trans", "code": "lemma changeLevel_trans {m d : \u2115} (hm : n \u2223 m) (hd : m \u2223 d) :\n    changeLevel (dvd_trans hm hd) \u03c7 = changeLevel hd (changeLevel hm \u03c7) := by\n  simp [changeLevel_def, MonoidHom.comp_assoc, ZMod.unitsMap_comp]", "start": [73, 1], "end": [75, 67], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.changeLevel_eq_cast_of_dvd", "code": "lemma changeLevel_eq_cast_of_dvd {m : \u2115} (hm : n \u2223 m) (a : Units (ZMod m)) :\n    (changeLevel hm \u03c7) a = \u03c7 a := by\n  simpa [changeLevel_def, Function.comp_apply, MonoidHom.coe_comp] using\n      toUnitHom_eq_char' _ <| ZMod.IsUnit_cast_of_dvd hm a", "start": [77, 1], "end": [80, 59], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.FactorsThrough", "code": "def FactorsThrough (d : \u2115) : Prop :=\n  \u2203 (h : d \u2223 n) (\u03c7\u2080 : DirichletCharacter R d), \u03c7 = changeLevel h \u03c7\u2080", "start": [82, 1], "end": [85, 68], "kind": "commanddeclaration"}, {"full_name": "DirichletCharacter.FactorsThrough.dvd", "code": "lemma dvd {d : \u2115} (h : FactorsThrough \u03c7 d) : d \u2223 n := h.1", "start": [89, 1], "end": [90, 58], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.FactorsThrough.\u03c7\u2080", "code": "noncomputable\ndef \u03c7\u2080 {d : \u2115} (h : FactorsThrough \u03c7 d) : DirichletCharacter R d := Classical.choose h.2", "start": [92, 1], "end": [94, 89], "kind": "commanddeclaration"}, {"full_name": "DirichletCharacter.FactorsThrough.eq_changeLevel", "code": "lemma eq_changeLevel {d : \u2115} (h : FactorsThrough \u03c7 d) : \u03c7 = changeLevel h.dvd h.\u03c7\u2080 :=\n  Classical.choose_spec h.2", "start": [96, 1], "end": [98, 28], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.FactorsThrough.same_level", "code": "lemma same_level : FactorsThrough \u03c7 n := \u27e8dvd_refl n, \u03c7, (changeLevel_self \u03c7).symm\u27e9", "start": [100, 1], "end": [100, 84], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.conductorSet", "code": "def conductorSet : Set \u2115 := {x : \u2115 | FactorsThrough \u03c7 x}", "start": [104, 1], "end": [105, 57], "kind": "commanddeclaration"}, {"full_name": "DirichletCharacter.mem_conductorSet_iff", "code": "lemma mem_conductorSet_iff {x : \u2115} : x \u2208 conductorSet \u03c7 \u2194 FactorsThrough \u03c7 x := Iff.refl _", "start": [107, 1], "end": [107, 91], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.level_mem_conductorSet", "code": "lemma level_mem_conductorSet : n \u2208 conductorSet \u03c7 := FactorsThrough.same_level \u03c7", "start": [109, 1], "end": [109, 81], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.mem_conductorSet_dvd", "code": "lemma mem_conductorSet_dvd {x : \u2115} (hx : x \u2208 conductorSet \u03c7) : x \u2223 n := hx.dvd", "start": [111, 1], "end": [111, 79], "kind": "mathlibtacticlemma"}, {"full_name": "DirichletCharacter.conductor", "code": "noncomputable def conductor : \u2115 := sInf (conductorSet \u03c7)", "start": [113, 1], "end": [115, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/ModuleCat/Images.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Images.lean", "Mathlib/Algebra/Category/ModuleCat/Abelian.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ModuleCat.image", "code": "def image : ModuleCat R :=\n  ModuleCat.of R (LinearMap.range f)", "start": [37, 1], "end": [39, 37], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.image.\u03b9", "code": "def image.\u03b9 : image f \u27f6 H :=\n  f.range.subtype", "start": [42, 1], "end": [44, 18], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.factorThruImage", "code": "def factorThruImage : G \u27f6 image f :=\n  f.rangeRestrict", "start": [50, 1], "end": [52, 18], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.image.fac", "code": "theorem image.fac : factorThruImage f \u226b image.\u03b9 f = f", "start": [55, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.image.lift", "code": "noncomputable def image.lift (F' : MonoFactorisation f) : image f \u27f6 F'.I where\n  toFun := (fun x => F'.e (Classical.indefiniteDescription _ x.2).1 : image f \u2192 F'.I)\n  map_add' x y := by\n    apply (mono_iff_injective F'.m).1; infer_instance\n    rw [LinearMap.map_add]\n    change (F'.e \u226b F'.m) _ = (F'.e \u226b F'.m) _ + (F'.e \u226b F'.m) _\n    simp_rw [F'.fac, (Classical.indefiniteDescription (fun z => f z = _) _).2]\n    rfl\n  map_smul' c x := by\n    apply (mono_iff_injective F'.m).1; infer_instance\n    rw [LinearMap.map_smul]\n    change (F'.e \u226b F'.m) _ = _ \u2022 (F'.e \u226b F'.m) _\n    simp_rw [F'.fac, (Classical.indefiniteDescription (fun z => f z = _) _).2]\n    rfl", "start": [63, 1], "end": [77, 8], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.image.lift_fac", "code": "theorem image.lift_fac (F' : MonoFactorisation f) : image.lift F' \u226b F'.m = image.\u03b9 f", "start": [80, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.monoFactorisation", "code": "def monoFactorisation : MonoFactorisation f where\n  I := image f\n  m := image.\u03b9 f\n  e := factorThruImage f", "start": [89, 1], "end": [93, 25], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.isImage", "code": "noncomputable def isImage : IsImage (monoFactorisation f) where\n  lift := image.lift\n  lift_fac := image.lift_fac", "start": [96, 1], "end": [100, 29], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.imageIsoRange", "code": "noncomputable def imageIsoRange {G H : ModuleCat.{v} R} (f : G \u27f6 H) :\n    Limits.image f \u2245 ModuleCat.of R (LinearMap.range f) :=\n  IsImage.isoExt (Image.isImage f) (isImage f)", "start": [103, 1], "end": [106, 47], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.imageIsoRange_inv_image_\u03b9", "code": "@[simp, reassoc, elementwise]\ntheorem imageIsoRange_inv_image_\u03b9 {G H : ModuleCat.{v} R} (f : G \u27f6 H) :\n    (imageIsoRange f).inv \u226b Limits.image.\u03b9 f = ModuleCat.ofHom f.range.subtype", "start": [109, 1], "end": [112, 27], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.imageIsoRange_hom_subtype", "code": "@[simp, reassoc, elementwise]\ntheorem imageIsoRange_hom_subtype {G H : ModuleCat.{v} R} (f : G \u27f6 H) :\n    (imageIsoRange f).hom \u226b ModuleCat.ofHom f.range.subtype = Limits.image.\u03b9 f", "start": [115, 1], "end": [118, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/SimplicialComplex/Basic.lean", "imports": ["Mathlib/Analysis/Convex/Hull.lean", "Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Geometry.SimplicialComplex", "code": "@[ext]\nstructure SimplicialComplex where\n  faces : Set (Finset E)\n  not_empty_mem : \u2205 \u2209 faces\n  indep : \u2200 {s}, s \u2208 faces \u2192 AffineIndependent \ud835\udd5c ((\u2191) : s \u2192 E)\n  down_closed : \u2200 {s t}, s \u2208 faces \u2192 t \u2286 s \u2192 t \u2260 \u2205 \u2192 t \u2208 faces\n  inter_subset_convexHull : \u2200 {s t}, s \u2208 faces \u2192 t \u2208 faces \u2192\n    convexHull \ud835\udd5c \u2191s \u2229 convexHull \ud835\udd5c \u2191t \u2286 convexHull \ud835\udd5c (s \u2229 t : Set E)", "start": [53, 1], "end": [64, 69], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.space", "code": "def space (K : SimplicialComplex \ud835\udd5c E) : Set E :=\n  \u22c3 s \u2208 K.faces, convexHull \ud835\udd5c (s : Set E)", "start": [76, 1], "end": [78, 42], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.mem_space_iff", "code": "theorem mem_space_iff : x \u2208 K.space \u2194 \u2203 (s : _) (_ : s \u2208 K.faces), x \u2208 convexHull \ud835\udd5c (s : Set E)", "start": [82, 1], "end": [83, 14], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.convexHull_subset_space", "code": "theorem convexHull_subset_space (hs : s \u2208 K.faces) : convexHull \ud835\udd5c \u2191s \u2286 K.space", "start": [87, 1], "end": [89, 6], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.subset_space", "code": "protected theorem subset_space (hs : s \u2208 K.faces) : (s : Set E) \u2286 K.space", "start": [92, 1], "end": [93, 62], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.convexHull_inter_convexHull", "code": "theorem convexHull_inter_convexHull (hs : s \u2208 K.faces) (ht : t \u2208 K.faces) :\n    convexHull \ud835\udd5c \u2191s \u2229 convexHull \ud835\udd5c \u2191t = convexHull \ud835\udd5c (s \u2229 t : Set E)", "start": [96, 1], "end": [100, 52], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull", "code": "theorem disjoint_or_exists_inter_eq_convexHull (hs : s \u2208 K.faces) (ht : t \u2208 K.faces) :\n    Disjoint (convexHull \ud835\udd5c (s : Set E)) (convexHull \ud835\udd5c \u2191t) \u2228\n      \u2203 u \u2208 K.faces, convexHull \ud835\udd5c (s : Set E) \u2229 convexHull \ud835\udd5c \u2191t = convexHull \ud835\udd5c \u2191u", "start": [103, 1], "end": [115, 54], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.ofErase", "code": "@[simps]\ndef ofErase (faces : Set (Finset E)) (indep : \u2200 s \u2208 faces, AffineIndependent \ud835\udd5c ((\u2191) : s \u2192 E))\n    (down_closed : \u2200 s \u2208 faces, \u2200 (t) (_ : t \u2286 s), t \u2208 faces)\n    (inter_subset_convexHull : \u2200 (s) (_ : s \u2208 faces) (t) (_ : t \u2208 faces),\n      convexHull \ud835\udd5c \u2191s \u2229 convexHull \ud835\udd5c \u2191t \u2286 convexHull \ud835\udd5c (s \u2229 t : Set E)) :\n    SimplicialComplex \ud835\udd5c E where\n  faces := faces \\ {\u2205}\n  not_empty_mem h := h.2 (mem_singleton _)\n  indep hs := indep _ hs.1\n  down_closed hs hts ht := \u27e8down_closed _ hs.1 _ hts, ht\u27e9\n  inter_subset_convexHull hs ht := inter_subset_convexHull _ hs.1 _ ht.1", "start": [118, 1], "end": [129, 73], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.ofSubcomplex", "code": "@[simps]\ndef ofSubcomplex (K : SimplicialComplex \ud835\udd5c E) (faces : Set (Finset E)) (subset : faces \u2286 K.faces)\n    (down_closed : \u2200 {s t}, s \u2208 faces \u2192 t \u2286 s \u2192 t \u2208 faces) : SimplicialComplex \ud835\udd5c E :=\n  { faces\n    not_empty_mem := fun h => K.not_empty_mem (subset h)\n    indep := fun hs => K.indep (subset hs)\n    down_closed := fun hs hts _ => down_closed hs hts\n    inter_subset_convexHull := fun hs ht => K.inter_subset_convexHull (subset hs) (subset ht) }", "start": [132, 1], "end": [140, 96], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.vertices", "code": "def vertices (K : SimplicialComplex \ud835\udd5c E) : Set E :=\n  { x | {x} \u2208 K.faces }", "start": [146, 1], "end": [148, 24], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.mem_vertices", "code": "theorem mem_vertices : x \u2208 K.vertices \u2194 {x} \u2208 K.faces", "start": [151, 1], "end": [151, 65], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.vertices_eq", "code": "theorem vertices_eq : K.vertices = \u22c3 k \u2208 K.faces, (k : Set E)", "start": [154, 1], "end": [158, 96], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.vertices_subset_space", "code": "theorem vertices_subset_space : K.vertices \u2286 K.space", "start": [161, 1], "end": [162, 86], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.vertex_mem_convexHull_iff", "code": "theorem vertex_mem_convexHull_iff (hx : x \u2208 K.vertices) (hs : s \u2208 K.faces) :\n    x \u2208 convexHull \ud835\udd5c (s : Set E) \u2194 x \u2208 s", "start": [165, 1], "end": [172, 38], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.face_subset_face_iff", "code": "theorem face_subset_face_iff (hs : s \u2208 K.faces) (ht : t \u2208 K.faces) :\n    convexHull \ud835\udd5c (s : Set E) \u2286 convexHull \ud835\udd5c \u2191t \u2194 s \u2286 t", "start": [175, 1], "end": [182, 21], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.facets", "code": "def facets (K : SimplicialComplex \ud835\udd5c E) : Set (Finset E) :=\n  { s \u2208 K.faces | \u2200 \u2983t\u2984, t \u2208 K.faces \u2192 s \u2286 t \u2192 s = t }", "start": [188, 1], "end": [190, 55], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.mem_facets", "code": "theorem mem_facets : s \u2208 K.facets \u2194 s \u2208 K.faces \u2227 \u2200 t \u2208 K.faces, s \u2286 t \u2192 s = t", "start": [193, 1], "end": [194, 14], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.facets_subset", "code": "theorem facets_subset : K.facets \u2286 K.faces", "start": [197, 1], "end": [197, 63], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.not_facet_iff_subface", "code": "theorem not_facet_iff_subface (hs : s \u2208 K.faces) : s \u2209 K.facets \u2194 \u2203 t, t \u2208 K.faces \u2227 s \u2282 t", "start": [200, 1], "end": [208, 33], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.hasBot", "code": "instance hasBot : Bot (SimplicialComplex \ud835\udd5c E) :=\n  \u27e8{  faces := \u2205\n      not_empty_mem := Set.not_mem_empty \u2205\n      indep := fun hs => (Set.not_mem_empty _ hs).elim\n      down_closed := fun hs => (Set.not_mem_empty _ hs).elim\n      inter_subset_convexHull := fun hs => (Set.not_mem_empty _ hs).elim }\u27e9", "start": [237, 1], "end": [242, 76], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.faces_bot", "code": "theorem faces_bot : (\u22a5 : SimplicialComplex \ud835\udd5c E).faces = \u2205", "start": [252, 1], "end": [252, 65], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.space_bot", "code": "theorem space_bot : (\u22a5 : SimplicialComplex \ud835\udd5c E).space = \u2205", "start": [255, 1], "end": [256, 22], "kind": "commanddeclaration"}, {"full_name": "Geometry.SimplicialComplex.facets_bot", "code": "theorem facets_bot : (\u22a5 : SimplicialComplex \ud835\udd5c E).facets = \u2205", "start": [259, 1], "end": [260, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Catalan.lean", "imports": ["Mathlib/Data/Finset/NatAntidiagonal.lean", "Mathlib/Algebra/BigOperators/NatAntidiagonal.lean", "Mathlib/Data/Nat/Choose/Central.lean", "Mathlib/Tactic/FieldSimp.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Fin.lean", "Mathlib/Algebra/CharZero/Lemmas.lean", "Mathlib/Data/Tree.lean"], "premises": [{"full_name": "catalan", "code": "def catalan : \u2115 \u2192 \u2115\n  | 0 => 1\n  | n + 1 =>\n    \u2211 i : Fin n.succ,\n      catalan i * catalan (n - i)", "start": [55, 1], "end": [61, 34], "kind": "commanddeclaration"}, {"full_name": "catalan_zero", "code": "@[simp]\ntheorem catalan_zero : catalan 0 = 1", "start": [64, 1], "end": [65, 56], "kind": "commanddeclaration"}, {"full_name": "catalan_succ", "code": "theorem catalan_succ (n : \u2115) : catalan (n + 1) = \u2211 i : Fin n.succ, catalan i * catalan (n - i)", "start": [68, 1], "end": [69, 15], "kind": "commanddeclaration"}, {"full_name": "catalan_succ'", "code": "theorem catalan_succ' (n : \u2115) :\n    catalan (n + 1) = \u2211 ij in Nat.antidiagonal n, catalan ij.1 * catalan ij.2", "start": [72, 1], "end": [75, 15], "kind": "commanddeclaration"}, {"full_name": "catalan_one", "code": "@[simp]\ntheorem catalan_one : catalan 1 = 1", "start": [78, 1], "end": [79, 62], "kind": "commanddeclaration"}, {"full_name": "gosperCatalan", "code": "private def gosperCatalan (n j : \u2115) : \u211a :=\n  Nat.centralBinom j * Nat.centralBinom (n - j) * (2 * j - n) / (2 * n * (n + 1))", "start": [82, 1], "end": [85, 82], "kind": "commanddeclaration"}, {"full_name": "gosper_trick", "code": "private theorem gosper_trick {n i : \u2115} (h : i \u2264 n) :\n    gosperCatalan (n + 1) (i + 1) - gosperCatalan (n + 1) i =\n      Nat.centralBinom i / (i + 1) * Nat.centralBinom (n - i) / (n - i + 1)", "start": [87, 1], "end": [104, 7], "kind": "commanddeclaration"}, {"full_name": "gosper_catalan_sub_eq_central_binom_div", "code": "private theorem gosper_catalan_sub_eq_central_binom_div (n : \u2115) : gosperCatalan (n + 1) (n + 1) -\n    gosperCatalan (n + 1) 0 = Nat.centralBinom (n + 1) / (n + 2)", "start": [106, 1], "end": [113, 7], "kind": "commanddeclaration"}, {"full_name": "catalan_eq_centralBinom_div", "code": "theorem catalan_eq_centralBinom_div (n : \u2115) : catalan n = n.centralBinom / (n + 1)", "start": [115, 1], "end": [136, 18], "kind": "commanddeclaration"}, {"full_name": "succ_mul_catalan_eq_centralBinom", "code": "theorem succ_mul_catalan_eq_centralBinom (n : \u2115) : (n + 1) * catalan n = n.centralBinom", "start": [139, 1], "end": [140, 97], "kind": "commanddeclaration"}, {"full_name": "catalan_two", "code": "theorem catalan_two : catalan 2 = 2", "start": [143, 1], "end": [144, 71], "kind": "commanddeclaration"}, {"full_name": "catalan_three", "code": "theorem catalan_three : catalan 3 = 5", "start": [147, 1], "end": [148, 71], "kind": "commanddeclaration"}, {"full_name": "Tree.pairwiseNode", "code": "@[reducible]\ndef pairwiseNode (a b : Finset (Tree Unit)) : Finset (Tree Unit) :=\n  (a \u00d7\u02e2 b).map \u27e8fun x => x.1 \u25b3 x.2, fun \u27e8x\u2081, x\u2082\u27e9 \u27e8y\u2081, y\u2082\u27e9 => fun h => by simpa using h\u27e9", "start": [155, 1], "end": [159, 88], "kind": "commanddeclaration"}, {"full_name": "Tree.treesOfNumNodesEq", "code": "def treesOfNumNodesEq : \u2115 \u2192 Finset (Tree Unit)\n  | 0 => {nil}\n  | n + 1 =>\n    (Finset.Nat.antidiagonal n).attach.biUnion fun ijh =>\n      pairwiseNode (treesOfNumNodesEq ijh.1.1) (treesOfNumNodesEq ijh.1.2)\n  decreasing_by\n      simp_wf\n      try exact Nat.lt_succ_of_le (fst_le ijh.2)\n      try exact Nat.lt_succ_of_le (snd_le ijh.2)", "start": [162, 1], "end": [175, 49], "kind": "commanddeclaration"}, {"full_name": "Tree.treesOfNumNodesEq_zero", "code": "@[simp]\ntheorem treesOfNumNodesEq_zero : treesOfNumNodesEq 0 = {nil}", "start": [178, 1], "end": [179, 90], "kind": "commanddeclaration"}, {"full_name": "Tree.treesOfNumNodesEq_succ", "code": "theorem treesOfNumNodesEq_succ (n : \u2115) :\n    treesOfNumNodesEq (n + 1) =\n      (Nat.antidiagonal n).biUnion fun ij =>\n        pairwiseNode (treesOfNumNodesEq ij.1) (treesOfNumNodesEq ij.2)", "start": [182, 1], "end": [188, 7], "kind": "commanddeclaration"}, {"full_name": "Tree.mem_treesOfNumNodesEq", "code": "@[simp]\ntheorem mem_treesOfNumNodesEq {x : Tree Unit} {n : \u2115} :\n    x \u2208 treesOfNumNodesEq n \u2194 x.numNodes = n", "start": [191, 1], "end": [196, 34], "kind": "commanddeclaration"}, {"full_name": "Tree.mem_treesOfNumNodesEq_numNodes", "code": "theorem mem_treesOfNumNodesEq_numNodes (x : Tree Unit) : x \u2208 treesOfNumNodesEq x.numNodes", "start": [199, 1], "end": [200, 32], "kind": "commanddeclaration"}, {"full_name": "Tree.coe_treesOfNumNodesEq", "code": "@[simp, norm_cast]\ntheorem coe_treesOfNumNodesEq (n : \u2115) :\n    \u2191(treesOfNumNodesEq n) = { x : Tree Unit | x.numNodes = n }", "start": [203, 1], "end": [206, 20], "kind": "commanddeclaration"}, {"full_name": "Tree.treesOfNumNodesEq_card_eq_catalan", "code": "theorem treesOfNumNodesEq_card_eq_catalan (n : \u2115) : (treesOfNumNodesEq n).card = catalan n", "start": [209, 1], "end": [226, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Cyclotomic/Gal.lean", "imports": ["Mathlib/FieldTheory/PolynomialGaloisGroup.lean", "Mathlib/NumberTheory/Cyclotomic/PrimitiveRoots.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsPrimitiveRoot.autToPow_injective", "code": "theorem autToPow_injective : Function.Injective <| h\u03bc.autToPow K", "start": [53, 1], "end": [82, 39], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.Aut.commGroup", "code": "noncomputable def Aut.commGroup : CommGroup (L \u2243\u2090[K] L) :=\n  ((zeta_spec n K L).autToPow_injective K).commGroup _ (map_one _) (map_mul _) (map_inv _)\n    (map_div _) (map_pow _) (map_zpow _)", "start": [92, 1], "end": [95, 41], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.autEquivPow", "code": "@[simps]\nnoncomputable def autEquivPow : (L \u2243\u2090[K] L) \u2243* (ZMod n)\u02e3 :=\n  let h\u03b6 := zeta_spec n K L\n  let h\u03bc t := h\u03b6.pow_of_coprime _ (ZMod.val_coe_unit_coprime t)\n  { (zeta_spec n K L).autToPow K with\n    invFun := fun t =>\n      (h\u03b6.powerBasis K).equivOfMinpoly ((h\u03bc t).powerBasis K)\n        (by\n          haveI := IsCyclotomicExtension.neZero' n K L\n          simp only [IsPrimitiveRoot.powerBasis_gen]\n          have hr :=\n            IsPrimitiveRoot.minpoly_eq_cyclotomic_of_irreducible\n              ((zeta_spec n K L).pow_of_coprime _ (ZMod.val_coe_unit_coprime t)) h\n          exact ((zeta_spec n K L).minpoly_eq_cyclotomic_of_irreducible h).symm.trans hr)\n    left_inv := fun f => by\n      simp only [MonoidHom.toFun_eq_coe]\n      apply AlgEquiv.coe_algHom_injective\n      apply (h\u03b6.powerBasis K).algHom_ext\nsimp only [AlgHom.coe_coe]\n      rw [PowerBasis.equivOfMinpoly_gen]\n      simp only [IsPrimitiveRoot.powerBasis_gen, IsPrimitiveRoot.autToPow_spec]\n    right_inv := fun x => by\n      simp only [MonoidHom.toFun_eq_coe]\n      generalize_proofs _ h\n      have key := h\u03b6.autToPow_spec K ((h\u03b6.powerBasis K).equivOfMinpoly ((h\u03bc x).powerBasis K) h)\n      have := (h\u03b6.powerBasis K).equivOfMinpoly_gen ((h\u03bc x).powerBasis K) h\n      rw [h\u03b6.powerBasis_gen K] at this\n      rw [this, IsPrimitiveRoot.powerBasis_gen] at key\nconv at key =>\n        congr; congr\n        rw [\u2190 h\u03b6.val_toRootsOfUnity_coe]\n        rfl; rfl\n        rw [\u2190 h\u03b6.val_toRootsOfUnity_coe]\n      simp only [\u2190 rootsOfUnity.coe_pow] at key\n      replace key := rootsOfUnity.coe_injective key\n      rw [pow_eq_pow_iff_modEq, \u2190 orderOf_subgroup, \u2190 orderOf_units, h\u03b6.val_toRootsOfUnity_coe, \u2190\n        (zeta_spec n K L).eq_orderOf, \u2190 ZMod.eq_iff_modEq_nat] at key\n      simp only [ZMod.nat_cast_val, ZMod.cast_id', id.def] at key\n      exact Units.ext key }", "start": [100, 1], "end": [142, 28], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.fromZetaAut", "code": "noncomputable def fromZetaAut : L \u2243\u2090[K] L :=\n  let h\u03b6 := (zeta_spec n K L).eq_pow_of_pow_eq_one h\u03bc.pow_eq_one n.pos\n  (autEquivPow L h).symm <|\n    ZMod.unitOfCoprime h\u03b6.choose <|\n      ((zeta_spec n K L).pow_iff_coprime n.pos h\u03b6.choose).mp <| h\u03b6.choose_spec.2.symm \u25b8 h\u03bc", "start": [147, 1], "end": [152, 91], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.fromZetaAut_spec", "code": "theorem fromZetaAut_spec : fromZetaAut h\u03bc h (zeta n K L) = \u03bc", "start": [155, 1], "end": [163, 15], "kind": "commanddeclaration"}, {"full_name": "galCyclotomicEquivUnitsZMod", "code": "noncomputable def galCyclotomicEquivUnitsZMod : (cyclotomic n K).Gal \u2243* (ZMod n)\u02e3 :=\n  (AlgEquiv.autCongr\n          (IsSplittingField.algEquiv L _ : L \u2243\u2090[K] (cyclotomic n K).SplittingField)).symm.trans\n    (IsCyclotomicExtension.autEquivPow L h)", "start": [173, 1], "end": [179, 44], "kind": "commanddeclaration"}, {"full_name": "galXPowEquivUnitsZMod", "code": "noncomputable def galXPowEquivUnitsZMod : (X ^ (n : \u2115) - 1 : K[X]).Gal \u2243* (ZMod n)\u02e3 :=\n  (AlgEquiv.autCongr\n      (IsSplittingField.algEquiv L _ : L \u2243\u2090[K] (X ^ (n : \u2115) - 1 : K[X]).SplittingField)).symm.trans\n    (IsCyclotomicExtension.autEquivPow L h)", "start": [182, 1], "end": [188, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/VectorBundle/SmoothSection.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Basic.lean", "Mathlib/Geometry/Manifold/MFDeriv.lean", "Mathlib/Geometry/Manifold/Algebra/LieGroup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContMDiffSection", "code": "structure ContMDiffSection where\n  protected toFun : \u2200 x, V x\n  protected contMDiff_toFun : ContMDiff I (I.prod \ud835\udcd8(\ud835\udd5c, F)) n fun x \u21a6\n    TotalSpace.mk' F x (toFun x)", "start": [43, 1], "end": [47, 33], "kind": "commanddeclaration"}, {"full_name": "SmoothSection", "code": "@[reducible]\ndef SmoothSection :=\n  ContMDiffSection I F \u22a4 V", "start": [50, 1], "end": [53, 27], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.coeFn_mk", "code": "@[simp]\ntheorem coeFn_mk (s : \u2200 x, V x)\n    (hs : ContMDiff I (I.prod \ud835\udcd8(\ud835\udd5c, F)) n fun x => TotalSpace.mk x (s x)) :\n    (mk s hs : \u2200 x, V x) = s", "start": [68, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.contMDiff", "code": "protected theorem contMDiff (s : C\u209b^n\u27eeI; F, V\u27ef) :\n    ContMDiff I (I.prod \ud835\udcd8(\ud835\udd5c, F)) n fun x => TotalSpace.mk' F x (s x : V x)", "start": [75, 1], "end": [77, 20], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.smooth", "code": "protected theorem smooth (s : C\u209b^\u221e\u27eeI; F, V\u27ef) :\n    Smooth I (I.prod \ud835\udcd8(\ud835\udd5c, F)) fun x => TotalSpace.mk' F x (s x : V x)", "start": [80, 1], "end": [82, 20], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.mdifferentiable'", "code": "protected theorem mdifferentiable' (s : C\u209b^n\u27eeI; F, V\u27ef) (hn : 1 \u2264 n) :\n    MDifferentiable I (I.prod \ud835\udcd8(\ud835\udd5c, F)) fun x => TotalSpace.mk' F x (s x : V x)", "start": [85, 1], "end": [87, 33], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.mdifferentiable", "code": "protected theorem mdifferentiable (s : C\u209b^\u221e\u27eeI; F, V\u27ef) :\n    MDifferentiable I (I.prod \ud835\udcd8(\ud835\udd5c, F)) fun x => TotalSpace.mk' F x (s x : V x)", "start": [90, 1], "end": [92, 37], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.mdifferentiableAt", "code": "protected theorem mdifferentiableAt (s : C\u209b^\u221e\u27eeI; F, V\u27ef) {x} :\n    MDifferentiableAt I (I.prod \ud835\udcd8(\ud835\udd5c, F)) (fun x => TotalSpace.mk' F x (s x : V x)) x", "start": [95, 1], "end": [97, 22], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.coe_inj", "code": "theorem coe_inj \u2983s t : C\u209b^n\u27eeI; F, V\u27ef\u2984 (h : (s : \u2200 x, V x) = t) : s = t", "start": [100, 1], "end": [101, 17], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.coe_injective", "code": "theorem coe_injective : Injective ((\u2191) : C\u209b^n\u27eeI; F, V\u27ef \u2192 \u2200 x, V x)", "start": [104, 1], "end": [105, 10], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.ext", "code": "@[ext]\ntheorem ext (h : \u2200 x, s x = t x) : s = t", "start": [108, 1], "end": [109, 62], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.instAdd", "code": "instance instAdd : Add C\u209b^n\u27eeI; F, V\u27ef := by\n  refine' \u27e8fun s t => \u27e8s + t, _\u27e9\u27e9\n  intro x\u2080\n  have hs := s.contMDiff x\u2080\n  have ht := t.contMDiff x\u2080\n  rw [contMDiffAt_section] at hs ht \u22a2\n  set e := trivializationAt F V x\u2080\n  refine' (hs.add ht).congr_of_eventuallyEq _\n  refine' eventually_of_mem (e.open_baseSet.mem_nhds <| mem_baseSet_trivializationAt F V x\u2080) _\n  intro x hx\n  apply (e.linear \ud835\udd5c hx).1", "start": [112, 1], "end": [122, 26], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.coe_add", "code": "@[simp]\ntheorem coe_add (s t : C\u209b^n\u27eeI; F, V\u27ef) : \u21d1(s + t) = \u21d1s + t", "start": [125, 1], "end": [127, 6], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.instSub", "code": "instance instSub : Sub C\u209b^n\u27eeI; F, V\u27ef := by\n  refine' \u27e8fun s t => \u27e8s - t, _\u27e9\u27e9\n  intro x\u2080\n  have hs := s.contMDiff x\u2080\n  have ht := t.contMDiff x\u2080\n  rw [contMDiffAt_section] at hs ht \u22a2\n  set e := trivializationAt F V x\u2080\n  refine' (hs.sub ht).congr_of_eventuallyEq _\n  refine' eventually_of_mem (e.open_baseSet.mem_nhds <| mem_baseSet_trivializationAt F V x\u2080) _\n  intro x hx\n  apply (e.linear \ud835\udd5c hx).map_sub", "start": [130, 1], "end": [140, 32], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.coe_sub", "code": "@[simp]\ntheorem coe_sub (s t : C\u209b^n\u27eeI; F, V\u27ef) : \u21d1(s - t) = s - t", "start": [143, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.instZero", "code": "instance instZero : Zero C\u209b^n\u27eeI; F, V\u27ef :=\n  \u27e8\u27e8fun _ => 0, (smooth_zeroSection \ud835\udd5c V).of_le le_top\u27e9\u27e9", "start": [148, 1], "end": [149, 56], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.inhabited", "code": "instance inhabited : Inhabited C\u209b^n\u27eeI; F, V\u27ef :=\n  \u27e80\u27e9", "start": [152, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : C\u209b^n\u27eeI; F, V\u27ef) = 0", "start": [156, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.instSMul", "code": "instance instSMul : SMul \ud835\udd5c C\u209b^n\u27eeI; F, V\u27ef := by\n  refine' \u27e8fun c s => \u27e8c \u2022 \u21d1s, _\u27e9\u27e9\n  intro x\u2080\n  have hs := s.contMDiff x\u2080\n  rw [contMDiffAt_section] at hs \u22a2\n  set e := trivializationAt F V x\u2080\n  refine' (contMDiffAt_const.smul hs).congr_of_eventuallyEq _\n  \u00b7 exact c\n  refine' eventually_of_mem (e.open_baseSet.mem_nhds <| mem_baseSet_trivializationAt F V x\u2080) _\n  intro x hx\n  apply (e.linear \ud835\udd5c hx).2", "start": [161, 1], "end": [171, 26], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.coe_smul", "code": "@[simp]\ntheorem coe_smul (r : \ud835\udd5c) (s : C\u209b^n\u27eeI; F, V\u27ef) : \u21d1(r \u2022 s : C\u209b^n\u27eeI; F, V\u27ef) = r \u2022 \u21d1s", "start": [174, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.instNeg", "code": "instance instNeg : Neg C\u209b^n\u27eeI; F, V\u27ef := by\n  refine' \u27e8fun s => \u27e8-s, _\u27e9\u27e9\n  intro x\u2080\n  have hs := s.contMDiff x\u2080\n  rw [contMDiffAt_section] at hs \u22a2\n  set e := trivializationAt F V x\u2080\n  refine' hs.neg.congr_of_eventuallyEq _\n  refine' eventually_of_mem (e.open_baseSet.mem_nhds <| mem_baseSet_trivializationAt F V x\u2080) _\n  intro x hx\n  apply (e.linear \ud835\udd5c hx).map_neg", "start": [179, 1], "end": [188, 32], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.coe_neg", "code": "@[simp]\ntheorem coe_neg (s : C\u209b^n\u27eeI; F, V\u27ef) : \u21d1(-s : C\u209b^n\u27eeI; F, V\u27ef) = -s", "start": [191, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.instNSMul", "code": "instance instNSMul : SMul \u2115 C\u209b^n\u27eeI; F, V\u27ef :=\n  \u27e8nsmulRec\u27e9", "start": [196, 1], "end": [197, 13], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.coe_nsmul", "code": "@[simp]\ntheorem coe_nsmul (s : C\u209b^n\u27eeI; F, V\u27ef) (k : \u2115) : \u21d1(k \u2022 s : C\u209b^n\u27eeI; F, V\u27ef) = k \u2022 \u21d1s", "start": [200, 1], "end": [204, 34], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.instZSMul", "code": "instance instZSMul : SMul \u2124 C\u209b^n\u27eeI; F, V\u27ef :=\n  \u27e8zsmulRec\u27e9", "start": [207, 1], "end": [208, 13], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.coe_zsmul", "code": "@[simp]\ntheorem coe_zsmul (s : C\u209b^n\u27eeI; F, V\u27ef) (z : \u2124) : \u21d1(z \u2022 s : C\u209b^n\u27eeI; F, V\u27ef) = z \u2022 \u21d1s", "start": [211, 1], "end": [217, 37], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.instAddCommGroup", "code": "instance instAddCommGroup : AddCommGroup C\u209b^n\u27eeI; F, V\u27ef :=\n  coe_injective.addCommGroup _ coe_zero coe_add coe_neg coe_sub coe_nsmul coe_zsmul", "start": [220, 1], "end": [221, 84], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.coeAddHom", "code": "def coeAddHom : C\u209b^n\u27eeI; F, V\u27ef \u2192+ \u2200 x, V x where\n  toFun := (\u2191)\n  map_zero' := coe_zero\n  map_add' := coe_add", "start": [226, 1], "end": [230, 22], "kind": "commanddeclaration"}, {"full_name": "ContMDiffSection.instModule", "code": "instance instModule : Module \ud835\udd5c C\u209b^n\u27eeI; F, V\u27ef :=\n  coe_injective.module \ud835\udd5c (coeAddHom I F n V) coe_smul", "start": [235, 1], "end": [236, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Int/DivMod.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Data/Int/DivMod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Probability/Cdf.lean", "imports": ["Mathlib/Probability/Kernel/CondCdf.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.cdf", "code": "noncomputable\ndef cdf (\u03bc : Measure \u211d) : StieltjesFunction :=\n  condCdf ((Measure.dirac Unit.unit).prod \u03bc) Unit.unit", "start": [47, 1], "end": [52, 55], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cdf_nonneg", "code": "lemma cdf_nonneg (x : \u211d) : 0 \u2264 cdf \u03bc x := condCdf_nonneg _ _ _", "start": [57, 1], "end": [58, 63], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.cdf_le_one", "code": "lemma cdf_le_one (x : \u211d) : cdf \u03bc x \u2264 1 := condCdf_le_one _ _ _", "start": [60, 1], "end": [61, 63], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.monotone_cdf", "code": "lemma monotone_cdf : Monotone (cdf \u03bc) := (condCdf _ _).mono", "start": [63, 1], "end": [64, 60], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.tendsto_cdf_atBot", "code": "lemma tendsto_cdf_atBot : Tendsto (cdf \u03bc) atBot (\ud835\udcdd 0) := tendsto_condCdf_atBot _ _", "start": [66, 1], "end": [67, 83], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.tendsto_cdf_atTop", "code": "lemma tendsto_cdf_atTop : Tendsto (cdf \u03bc) atTop (\ud835\udcdd 1) := tendsto_condCdf_atTop _ _", "start": [69, 1], "end": [70, 83], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.ofReal_cdf", "code": "lemma ofReal_cdf [IsProbabilityMeasure \u03bc] (x : \u211d) : ENNReal.ofReal (cdf \u03bc x) = \u03bc (Iic x) := by\n  have h := lintegral_condCdf ((Measure.dirac Unit.unit).prod \u03bc) x\n  simpa only [MeasureTheory.Measure.fst_prod, Measure.prod_prod, measure_univ, one_mul,\n    lintegral_dirac] using h", "start": [72, 1], "end": [75, 29], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.cdf_eq_toReal", "code": "lemma cdf_eq_toReal [IsProbabilityMeasure \u03bc] (x : \u211d) : cdf \u03bc x = (\u03bc (Iic x)).toReal := by\n  rw [\u2190 ofReal_cdf \u03bc x, ENNReal.toReal_ofReal (cdf_nonneg \u03bc x)]", "start": [77, 1], "end": [78, 64], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.instIsProbabilityMeasurecdf", "code": "instance instIsProbabilityMeasurecdf : IsProbabilityMeasure (cdf \u03bc).measure := by\n  constructor\n  simp only [StieltjesFunction.measure_univ _ (tendsto_cdf_atBot \u03bc) (tendsto_cdf_atTop \u03bc), sub_zero,\n    ENNReal.ofReal_one]", "start": [80, 1], "end": [83, 24], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measure_cdf", "code": "lemma measure_cdf [IsProbabilityMeasure \u03bc] : (cdf \u03bc).measure = \u03bc := by\n  refine Measure.ext_of_Iic (cdf \u03bc).measure \u03bc (fun a \u21a6 ?_)\n  rw [StieltjesFunction.measure_Iic _ (tendsto_cdf_atBot \u03bc), sub_zero, ofReal_cdf]", "start": [85, 1], "end": [88, 83], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.cdf_measure_stieltjesFunction", "code": "lemma cdf_measure_stieltjesFunction (f : StieltjesFunction) (hf0 : Tendsto f atBot (\ud835\udcdd 0))\n    (hf1 : Tendsto f atTop (\ud835\udcdd 1)) :\n    cdf f.measure = f := by\n  refine (cdf f.measure).eq_of_measure_of_tendsto_atBot f ?_ (tendsto_cdf_atBot _) hf0\n  have h_prob : IsProbabilityMeasure f.measure :=\n    \u27e8by rw [f.measure_univ hf0 hf1, sub_zero, ENNReal.ofReal_one]\u27e9\n  exact measure_cdf f.measure", "start": [92, 1], "end": [98, 30], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.Measure.eq_of_cdf", "code": "lemma MeasureTheory.Measure.eq_of_cdf (\u03bc \u03bd : Measure \u211d) [IsProbabilityMeasure \u03bc]\n    [IsProbabilityMeasure \u03bd] (h : cdf \u03bc = cdf \u03bd) : \u03bc = \u03bd := by\n  rw [\u2190 measure_cdf \u03bc, \u2190 measure_cdf \u03bd, h]", "start": [104, 1], "end": [107, 43], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.Measure.cdf_eq_iff", "code": "@[simp] lemma MeasureTheory.Measure.cdf_eq_iff (\u03bc \u03bd : Measure \u211d) [IsProbabilityMeasure \u03bc]\n    [IsProbabilityMeasure \u03bd] :\n    cdf \u03bc = cdf \u03bd \u2194 \u03bc = \u03bd :=\n\u27e8MeasureTheory.Measure.eq_of_cdf \u03bc \u03bd, fun h \u21a6 by rw [h]\u27e9", "start": [109, 1], "end": [112, 57], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Int/Dvd/Pow.lean", "imports": ["Mathlib/Data/Nat/Pow.lean", "Mathlib/Data/Int/Dvd/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.sign_pow_bit1", "code": "@[simp]\ntheorem sign_pow_bit1 (k : \u2115) : \u2200 n : \u2124, n.sign ^ bit1 k = n.sign", "start": [21, 1], "end": [25, 84], "kind": "commanddeclaration"}, {"full_name": "Int.pow_dvd_of_le_of_pow_dvd", "code": "theorem pow_dvd_of_le_of_pow_dvd {p m n : \u2115} {k : \u2124} (hmn : m \u2264 n) (hdiv : \u2191(p ^ n) \u2223 k) :\n    \u2191(p ^ m) \u2223 k", "start": [29, 1], "end": [31, 41], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_of_pow_dvd", "code": "theorem dvd_of_pow_dvd {p k : \u2115} {m : \u2124} (hk : 1 \u2264 k) (hpk : \u2191(p ^ k) \u2223 m) : \u2191p \u2223 m", "start": [34, 1], "end": [35, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Strong.lean", "imports": ["Mathlib/Analysis/InnerProductSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UniformConvexOn", "code": "def UniformConvexOn (s : Set E) (\u03c6 : \u211d \u2192 \u211d) (f : E \u2192 \u211d) : Prop :=\n  Convex \u211d s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 \u2200 \u2983a b : \u211d\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192\n    f (a \u2022 x + b \u2022 y) \u2264 a \u2022 f x + b \u2022 f y - a * b * \u03c6 \u2016x - y\u2016", "start": [34, 1], "end": [40, 62], "kind": "commanddeclaration"}, {"full_name": "UniformConcaveOn", "code": "def UniformConcaveOn (s : Set E) (\u03c6 : \u211d \u2192 \u211d) (f : E \u2192 \u211d) : Prop :=\n  Convex \u211d s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 \u2200 \u2983a b : \u211d\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192\n    a \u2022 f x + b \u2022 f y + a * b * \u03c6 \u2016x - y\u2016 \u2264 f (a \u2022 x + b \u2022 y)", "start": [42, 1], "end": [48, 62], "kind": "commanddeclaration"}, {"full_name": "uniformConvexOn_zero", "code": "@[simp] lemma uniformConvexOn_zero : UniformConvexOn s 0 f \u2194 ConvexOn \u211d s f := by\n  simp [UniformConvexOn, ConvexOn]", "start": [50, 1], "end": [51, 35], "kind": "mathlibtacticlemma"}, {"full_name": "uniformConcaveOn_zero", "code": "@[simp] lemma uniformConcaveOn_zero : UniformConcaveOn s 0 f \u2194 ConcaveOn \u211d s f := by\n  simp [UniformConcaveOn, ConcaveOn]", "start": [53, 1], "end": [54, 37], "kind": "mathlibtacticlemma"}, {"full_name": "ConvexOn.uniformConvexOn_zero", "code": "protected alias \u27e8_, ConvexOn.uniformConvexOn_zero\u27e9 := uniformConvexOn_zero", "start": [56, 1], "end": [56, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "ConcaveOn.uniformConcaveOn_zero", "code": "protected alias \u27e8_, ConcaveOn.uniformConcaveOn_zero\u27e9 := uniformConcaveOn_zero", "start": [57, 1], "end": [57, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "UniformConvexOn.mono", "code": "lemma UniformConvexOn.mono (h\u03c8\u03c6 : \u03c8 \u2264 \u03c6) (hf : UniformConvexOn s \u03c6 f) : UniformConvexOn s \u03c8 f :=\n  \u27e8hf.1, fun x hx y hy a b ha hb hab \u21a6 (hf.2 hx hy ha hb hab).trans $\n    sub_le_sub_left (mul_le_mul_of_nonneg_left (h\u03c8\u03c6 _) $ by positivity) _\u27e9", "start": [59, 1], "end": [61, 75], "kind": "mathlibtacticlemma"}, {"full_name": "UniformConcaveOn.mono", "code": "lemma UniformConcaveOn.mono (h\u03c8\u03c6 : \u03c8 \u2264 \u03c6) (hf : UniformConcaveOn s \u03c6 f) : UniformConcaveOn s \u03c8 f :=\n  \u27e8hf.1, fun x hx y hy a b ha hb hab \u21a6 (hf.2 hx hy ha hb hab).trans' $\n    add_le_add_left (mul_le_mul_of_nonneg_left (h\u03c8\u03c6 _) $ by positivity) _\u27e9", "start": [63, 1], "end": [65, 75], "kind": "mathlibtacticlemma"}, {"full_name": "UniformConvexOn.convexOn", "code": "lemma UniformConvexOn.convexOn (hf : UniformConvexOn s \u03c6 f) (h\u03c6 : 0 \u2264 \u03c6) : ConvexOn \u211d s f := by\n  simpa using hf.mono h\u03c6", "start": [67, 1], "end": [68, 25], "kind": "mathlibtacticlemma"}, {"full_name": "UniformConcaveOn.concaveOn", "code": "lemma UniformConcaveOn.concaveOn (hf : UniformConcaveOn s \u03c6 f) (h\u03c6 : 0 \u2264 \u03c6) : ConcaveOn \u211d s f := by\n  simpa using hf.mono h\u03c6", "start": [70, 1], "end": [71, 25], "kind": "mathlibtacticlemma"}, {"full_name": "UniformConvexOn.strictConvexOn", "code": "lemma UniformConvexOn.strictConvexOn (hf : UniformConvexOn s \u03c6 f) (h\u03c6 : \u2200 r, r \u2260 0 \u2192 0 < \u03c6 r) :\n    StrictConvexOn \u211d s f := by\n  refine \u27e8hf.1, fun x hx y hy hxy a b ha hb hab \u21a6 (hf.2 hx hy ha.le hb.le hab).trans_lt $\n    sub_lt_self _ ?_\u27e9\n  rw [\u2190sub_ne_zero, \u2190norm_pos_iff] at hxy\n  have := h\u03c6 _ hxy.ne'\n  positivity", "start": [73, 1], "end": [79, 13], "kind": "mathlibtacticlemma"}, {"full_name": "UniformConcaveOn.strictConcaveOn", "code": "lemma UniformConcaveOn.strictConcaveOn (hf : UniformConcaveOn s \u03c6 f) (h\u03c6 : \u2200 r, r \u2260 0 \u2192 0 < \u03c6 r) :\n    StrictConcaveOn \u211d s f := by\n  refine \u27e8hf.1, fun x hx y hy hxy a b ha hb hab \u21a6 (hf.2 hx hy ha.le hb.le hab).trans_lt' $\n    lt_add_of_pos_right _ ?_\u27e9\n  rw [\u2190sub_ne_zero, \u2190norm_pos_iff] at hxy\n  have := h\u03c6 _ hxy.ne'\n  positivity", "start": [81, 1], "end": [87, 13], "kind": "mathlibtacticlemma"}, {"full_name": "UniformConvexOn.add", "code": "lemma UniformConvexOn.add (hf : UniformConvexOn s \u03c6 f) (hg : UniformConvexOn s \u03c8 g) :\n    UniformConvexOn s (\u03c6 + \u03c8) (f + g) := by\n  refine \u27e8hf.1, fun x hx y hy a b ha hb hab \u21a6 ?_\u27e9\n  simpa [mul_add, add_add_add_comm, sub_add_sub_comm]\n    using add_le_add (hf.2 hx hy ha hb hab) (hg.2 hx hy ha hb hab)", "start": [89, 1], "end": [93, 67], "kind": "mathlibtacticlemma"}, {"full_name": "UniformConcaveOn.add", "code": "lemma UniformConcaveOn.add (hf : UniformConcaveOn s \u03c6 f) (hg : UniformConcaveOn s \u03c8 g) :\n    UniformConcaveOn s (\u03c6 + \u03c8) (f + g) := by\n  refine \u27e8hf.1, fun x hx y hy a b ha hb hab \u21a6 ?_\u27e9\n  simpa [mul_add, add_add_add_comm] using add_le_add (hf.2 hx hy ha hb hab) (hg.2 hx hy ha hb hab)", "start": [95, 1], "end": [98, 99], "kind": "mathlibtacticlemma"}, {"full_name": "UniformConvexOn.neg", "code": "lemma UniformConvexOn.neg (hf : UniformConvexOn s \u03c6 f) : UniformConcaveOn s \u03c6 (-f) := by\n  refine \u27e8hf.1, fun x hx y hy a b ha hb hab \u21a6 le_of_neg_le_neg ?_\u27e9\n  simpa [add_comm, -neg_le_neg_iff, le_sub_iff_add_le'] using hf.2 hx hy ha hb hab", "start": [100, 1], "end": [102, 83], "kind": "mathlibtacticlemma"}, {"full_name": "UniformConcaveOn.neg", "code": "lemma UniformConcaveOn.neg (hf : UniformConcaveOn s \u03c6 f) : UniformConvexOn s \u03c6 (-f) := by\n  refine \u27e8hf.1, fun x hx y hy a b ha hb hab \u21a6 le_of_neg_le_neg ?_\u27e9\n  simpa [add_comm, -neg_le_neg_iff, \u2190le_sub_iff_add_le', sub_eq_add_neg, neg_add]\n    using hf.2 hx hy ha hb hab", "start": [104, 1], "end": [107, 31], "kind": "mathlibtacticlemma"}, {"full_name": "UniformConvexOn.sub", "code": "lemma UniformConvexOn.sub (hf : UniformConvexOn s \u03c6 f) (hg : UniformConcaveOn s \u03c8 g) :\n    UniformConvexOn s (\u03c6 + \u03c8) (f - g) := by simpa using hf.add hg.neg", "start": [109, 1], "end": [110, 70], "kind": "mathlibtacticlemma"}, {"full_name": "UniformConcaveOn.sub", "code": "lemma UniformConcaveOn.sub (hf : UniformConcaveOn s \u03c6 f) (hg : UniformConvexOn s \u03c8 g) :\n    UniformConcaveOn s (\u03c6 + \u03c8) (f - g) := by simpa using hf.add hg.neg", "start": [112, 1], "end": [113, 71], "kind": "mathlibtacticlemma"}, {"full_name": "StrongConvexOn", "code": "def StrongConvexOn (s : Set E) (m : \u211d) : (E \u2192 \u211d) \u2192 Prop :=\n  UniformConvexOn s fun r \u21a6 m / (2 : \u211d) * r ^ 2", "start": [115, 1], "end": [120, 48], "kind": "commanddeclaration"}, {"full_name": "StrongConcaveOn", "code": "def StrongConcaveOn (s : Set E) (m : \u211d) : (E \u2192 \u211d) \u2192 Prop :=\n  UniformConcaveOn s fun r \u21a6 m / (2 : \u211d) * r ^ 2", "start": [122, 1], "end": [127, 49], "kind": "commanddeclaration"}, {"full_name": "StrongConvexOn.mono", "code": "nonrec lemma StrongConvexOn.mono (hmn : m \u2264 n) (hf : StrongConvexOn s n f) : StrongConvexOn s m f :=\n  hf.mono fun r \u21a6 mul_le_mul_of_nonneg_right (div_le_div_of_le zero_le_two hmn) $ by positivity", "start": [131, 1], "end": [132, 96], "kind": "mathlibtacticlemma"}, {"full_name": "StrongConcaveOn.mono", "code": "nonrec lemma StrongConcaveOn.mono (hmn : m \u2264 n) (hf : StrongConcaveOn s n f) :\n    StrongConcaveOn s m f :=\n  hf.mono fun r \u21a6 mul_le_mul_of_nonneg_right (div_le_div_of_le zero_le_two hmn) $ by positivity", "start": [134, 1], "end": [136, 96], "kind": "mathlibtacticlemma"}, {"full_name": "strongConvexOn_zero", "code": "@[simp] lemma strongConvexOn_zero : StrongConvexOn s 0 f \u2194 ConvexOn \u211d s f := by\n  simp [StrongConvexOn, \u2190Pi.zero_def]", "start": [138, 1], "end": [139, 38], "kind": "mathlibtacticlemma"}, {"full_name": "strongConcaveOn_zero", "code": "@[simp] lemma strongConcaveOn_zero : StrongConcaveOn s 0 f \u2194 ConcaveOn \u211d s f := by\n  simp [StrongConcaveOn, \u2190Pi.zero_def]", "start": [141, 1], "end": [142, 39], "kind": "mathlibtacticlemma"}, {"full_name": "StrongConvexOn.strictConvexOn", "code": "nonrec lemma StrongConvexOn.strictConvexOn (hf : StrongConvexOn s m f) (hm : 0 < m) :\n    StrictConvexOn \u211d s f := hf.strictConvexOn fun r hr \u21a6 by positivity", "start": [144, 1], "end": [145, 71], "kind": "mathlibtacticlemma"}, {"full_name": "StrongConcaveOn.strictConcaveOn", "code": "nonrec lemma StrongConcaveOn.strictConcaveOn (hf : StrongConcaveOn s m f) (hm : 0 < m) :\n    StrictConcaveOn \u211d s f := hf.strictConcaveOn fun r hr \u21a6 by positivity", "start": [147, 1], "end": [148, 73], "kind": "mathlibtacticlemma"}, {"full_name": "aux_sub", "code": "private lemma aux_sub (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hab : a + b = 1) :\n    a * (f x - m / (2 : \u211d) * \u2016x\u2016 ^ 2) + b * (f y - m / (2 : \u211d) * \u2016y\u2016 ^ 2) +\n      m / (2 : \u211d) * \u2016a \u2022 x + b \u2022 y\u2016 ^ 2\n      = a * f x + b * f y - m / (2 : \u211d) * a * b * \u2016x - y\u2016 ^ 2 := by\n  rw [norm_add_sq_real, norm_sub_sq_real, norm_smul, norm_smul, real_inner_smul_left,\n    inner_smul_right, norm_of_nonneg ha, norm_of_nonneg hb, mul_pow, mul_pow]\n  obtain rfl := eq_sub_of_add_eq hab\n  ring_nf", "start": [155, 1], "end": [162, 10], "kind": "mathlibtacticlemma"}, {"full_name": "aux_add", "code": "private lemma aux_add (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hab : a + b = 1) :\n    a * (f x + m / (2 : \u211d) * \u2016x\u2016 ^ 2) + b * (f y + m / (2 : \u211d) * \u2016y\u2016 ^ 2) -\n      m / (2 : \u211d) * \u2016a \u2022 x + b \u2022 y\u2016 ^ 2\n      = a * f x + b * f y + m / (2 : \u211d) * a * b * \u2016x - y\u2016 ^ 2 := by\n  simpa [neg_div] using aux_sub (E := E) (m := -m) ha hb hab", "start": [164, 1], "end": [168, 61], "kind": "mathlibtacticlemma"}, {"full_name": "strongConvexOn_iff_convex", "code": "lemma strongConvexOn_iff_convex :\n    StrongConvexOn s m f \u2194 ConvexOn \u211d s fun x \u21a6 f x - m / (2 : \u211d) * \u2016x\u2016 ^ 2 := by\n  refine and_congr_right fun _ \u21a6 forall\u2084_congr fun x _ y _ \u21a6 forall\u2085_congr fun a b ha hb hab \u21a6 ?_\n  simp_rw [sub_le_iff_le_add, smul_eq_mul, aux_sub ha hb hab, mul_assoc, mul_left_comm]", "start": [170, 1], "end": [173, 88], "kind": "mathlibtacticlemma"}, {"full_name": "strongConcaveOn_iff_convex", "code": "lemma strongConcaveOn_iff_convex :\n    StrongConcaveOn s m f \u2194 ConcaveOn \u211d s fun x \u21a6 f x + m / (2 : \u211d) * \u2016x\u2016 ^ 2 := by\n  refine and_congr_right fun _ \u21a6 forall\u2084_congr fun x _ y _ \u21a6 forall\u2085_congr fun a b ha hb hab \u21a6 ?_\n  simp_rw [\u2190sub_le_iff_le_add, smul_eq_mul, aux_add ha hb hab, mul_assoc, mul_left_comm]", "start": [175, 1], "end": [178, 89], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Topology/Covering.lean", "imports": ["Mathlib/Topology/FiberBundle/Basic.lean", "Mathlib/Topology/IsLocallyHomeomorph.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsEvenlyCovered", "code": "def IsEvenlyCovered (x : X) (I : Type*) [TopologicalSpace I] :=\n  DiscreteTopology I \u2227 \u2203 t : Trivialization I f, x \u2208 t.baseSet", "start": [31, 1], "end": [33, 63], "kind": "commanddeclaration"}, {"full_name": "IsEvenlyCovered.toTrivialization", "code": "noncomputable def toTrivialization {x : X} {I : Type*} [TopologicalSpace I]\n    (h : IsEvenlyCovered f x I) : Trivialization (f \u207b\u00b9' {x}) f :=\n  (Classical.choose h.2).transFiberHomeomorph\n    ((Classical.choose h.2).preimageSingletonHomeomorph (Classical.choose_spec h.2)).symm", "start": [40, 1], "end": [44, 90], "kind": "commanddeclaration"}, {"full_name": "IsEvenlyCovered.mem_toTrivialization_baseSet", "code": "theorem mem_toTrivialization_baseSet {x : X} {I : Type*} [TopologicalSpace I]\n    (h : IsEvenlyCovered f x I) : x \u2208 h.toTrivialization.baseSet", "start": [47, 1], "end": [49, 28], "kind": "commanddeclaration"}, {"full_name": "IsEvenlyCovered.toTrivialization_apply", "code": "theorem toTrivialization_apply {x : E} {I : Type*} [TopologicalSpace I]\n    (h : IsEvenlyCovered f (f x) I) : (h.toTrivialization x).2 = \u27e8x, rfl\u27e9", "start": [52, 1], "end": [60, 22], "kind": "commanddeclaration"}, {"full_name": "IsEvenlyCovered.continuousAt", "code": "protected theorem continuousAt {x : E} {I : Type*} [TopologicalSpace I]\n    (h : IsEvenlyCovered f (f x) I) : ContinuousAt f x", "start": [63, 1], "end": [66, 74], "kind": "commanddeclaration"}, {"full_name": "IsEvenlyCovered.to_isEvenlyCovered_preimage", "code": "theorem to_isEvenlyCovered_preimage {x : X} {I : Type*} [TopologicalSpace I]\n    (h : IsEvenlyCovered f x I) : IsEvenlyCovered f x (f \u207b\u00b9' {x})", "start": [69, 1], "end": [74, 39], "kind": "commanddeclaration"}, {"full_name": "IsCoveringMapOn", "code": "def IsCoveringMapOn :=\n  \u2200 x \u2208 s, IsEvenlyCovered f x (f \u207b\u00b9' {x})", "start": [79, 1], "end": [82, 43], "kind": "commanddeclaration"}, {"full_name": "IsCoveringMapOn.mk", "code": "theorem mk (F : X \u2192 Type*) [\u2200 x, TopologicalSpace (F x)] [hF : \u2200 x, DiscreteTopology (F x)]\n    (e : \u2200 x \u2208 s, Trivialization (F x) f) (h : \u2200 (x : X) (hx : x \u2208 s), x \u2208 (e x hx).baseSet) :\n    IsCoveringMapOn f s", "start": [87, 1], "end": [90, 69], "kind": "commanddeclaration"}, {"full_name": "IsCoveringMapOn.continuousAt", "code": "protected theorem continuousAt (hf : IsCoveringMapOn f s) {x : E} (hx : f x \u2208 s) :\n    ContinuousAt f x", "start": [95, 1], "end": [97, 29], "kind": "commanddeclaration"}, {"full_name": "IsCoveringMapOn.continuousOn", "code": "protected theorem continuousOn (hf : IsCoveringMapOn f s) : ContinuousOn f (f \u207b\u00b9' s)", "start": [100, 1], "end": [101, 53], "kind": "commanddeclaration"}, {"full_name": "IsCoveringMapOn.isLocallyHomeomorphOn", "code": "protected theorem isLocallyHomeomorphOn (hf : IsCoveringMapOn f s) :\n    IsLocallyHomeomorphOn f (f \u207b\u00b9' s)", "start": [104, 1], "end": [127, 44], "kind": "commanddeclaration"}, {"full_name": "IsCoveringMap", "code": "def IsCoveringMap :=\n  \u2200 x, IsEvenlyCovered f x (f \u207b\u00b9' {x})", "start": [132, 1], "end": [135, 39], "kind": "commanddeclaration"}, {"full_name": "isCoveringMap_iff_isCoveringMapOn_univ", "code": "theorem isCoveringMap_iff_isCoveringMapOn_univ : IsCoveringMap f \u2194 IsCoveringMapOn f Set.univ", "start": [140, 1], "end": [141, 77], "kind": "commanddeclaration"}, {"full_name": "IsCoveringMap.isCoveringMapOn", "code": "protected theorem IsCoveringMap.isCoveringMapOn (hf : IsCoveringMap f) :\n    IsCoveringMapOn f Set.univ", "start": [144, 1], "end": [146, 47], "kind": "commanddeclaration"}, {"full_name": "IsCoveringMap.mk", "code": "theorem mk (F : X \u2192 Type*) [\u2200 x, TopologicalSpace (F x)] [\u2200 x, DiscreteTopology (F x)]\n    (e : \u2200 x, Trivialization (F x) f) (h : \u2200 x, x \u2208 (e x).baseSet) : IsCoveringMap f", "start": [153, 1], "end": [156, 70], "kind": "commanddeclaration"}, {"full_name": "IsCoveringMap.continuous", "code": "protected theorem continuous (hf : IsCoveringMap f) : Continuous f", "start": [161, 1], "end": [162, 71], "kind": "commanddeclaration"}, {"full_name": "IsCoveringMap.isLocallyHomeomorph", "code": "protected theorem isLocallyHomeomorph (hf : IsCoveringMap f) : IsLocallyHomeomorph f", "start": [165, 1], "end": [166, 98], "kind": "commanddeclaration"}, {"full_name": "IsCoveringMap.isOpenMap", "code": "protected theorem isOpenMap (hf : IsCoveringMap f) : IsOpenMap f", "start": [169, 1], "end": [170, 35], "kind": "commanddeclaration"}, {"full_name": "IsCoveringMap.quotientMap", "code": "protected theorem quotientMap (hf : IsCoveringMap f) (hf' : Function.Surjective f) :\n    QuotientMap f", "start": [173, 1], "end": [175, 48], "kind": "commanddeclaration"}, {"full_name": "IsFiberBundle.isCoveringMap", "code": "protected theorem IsFiberBundle.isCoveringMap {F : Type*} [TopologicalSpace F] [DiscreteTopology F]\n    (hf : \u2200 x : X, \u2203 e : Trivialization F f, x \u2208 e.baseSet) : IsCoveringMap f", "start": [182, 1], "end": [185, 33], "kind": "commanddeclaration"}, {"full_name": "FiberBundle.isCoveringMap", "code": "protected theorem FiberBundle.isCoveringMap {F : Type*} {E : X \u2192 Type*} [TopologicalSpace F]\n    [DiscreteTopology F] [TopologicalSpace (Bundle.TotalSpace F E)] [\u2200 x, TopologicalSpace (E x)]\n    [FiberBundle F E] : IsCoveringMap (\u03c0 F E)", "start": [188, 1], "end": [191, 100], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/GroupCat/Biproducts.lean", "imports": ["Mathlib/Algebra/Category/GroupCat/Preadditive.lean", "Mathlib/Algebra/Category/GroupCat/Limits.lean", "Mathlib/CategoryTheory/Preadditive/Biproducts.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Group/Pi.lean"], "premises": [{"full_name": "AddCommGroupCat.binaryProductLimitCone", "code": "@[simps cone_pt isLimit_lift]\ndef binaryProductLimitCone (G H : AddCommGroupCat.{u}) : Limits.LimitCone (pair G H) where\n  cone :=\n    { pt := AddCommGroupCat.of (G \u00d7 H)\n      \u03c0 :=\n        { app := fun j =>\n            Discrete.casesOn j fun j =>\n              WalkingPair.casesOn j (AddMonoidHom.fst G H) (AddMonoidHom.snd G H)\n          naturality := by rintro \u27e8\u27e8\u27e9\u27e9 \u27e8\u27e8\u27e9\u27e9 \u27e8\u27e8\u27e8\u27e9\u27e9\u27e9 <;> rfl } }\n  isLimit :=\n    { lift := fun s => AddMonoidHom.prod (s.\u03c0.app \u27e8WalkingPair.left\u27e9) (s.\u03c0.app \u27e8WalkingPair.right\u27e9)\n      fac := by rintro s (\u27e8\u27e9 | \u27e8\u27e9) <;> rfl\n      uniq := fun s m w => by\n        simp_rw [\u2190 w \u27e8WalkingPair.left\u27e9, \u2190 w \u27e8WalkingPair.right\u27e9]\n        rfl }", "start": [38, 1], "end": [55, 14], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.binaryProductLimitCone_cone_\u03c0_app_left", "code": "@[simp]\ntheorem binaryProductLimitCone_cone_\u03c0_app_left (G H : AddCommGroupCat.{u}) :\n    (binaryProductLimitCone G H).cone.\u03c0.app \u27e8WalkingPair.left\u27e9 = AddMonoidHom.fst G H", "start": [58, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.binaryProductLimitCone_cone_\u03c0_app_right", "code": "@[simp]\ntheorem binaryProductLimitCone_cone_\u03c0_app_right (G H : AddCommGroupCat.{u}) :\n    (binaryProductLimitCone G H).cone.\u03c0.app \u27e8WalkingPair.right\u27e9 = AddMonoidHom.snd G H", "start": [64, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.biprodIsoProd", "code": "@[simps! hom_apply]\nnoncomputable def biprodIsoProd (G H : AddCommGroupCat.{u}) :\n    (G \u229e H : AddCommGroupCat) \u2245 AddCommGroupCat.of (G \u00d7 H) :=\n  IsLimit.conePointUniqueUpToIso (BinaryBiproduct.isLimit G H) (binaryProductLimitCone G H).isLimit", "start": [70, 1], "end": [76, 100], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.biprodIsoProd_inv_comp_fst", "code": "@[simp, elementwise]\ntheorem biprodIsoProd_inv_comp_fst (G H : AddCommGroupCat.{u}) :\n    (biprodIsoProd G H).inv \u226b biprod.fst = AddMonoidHom.fst G H", "start": [82, 1], "end": [85, 77], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.biprodIsoProd_inv_comp_snd", "code": "@[simp, elementwise]\ntheorem biprodIsoProd_inv_comp_snd (G H : AddCommGroupCat.{u}) :\n    (biprodIsoProd G H).inv \u226b biprod.snd = AddMonoidHom.snd G H", "start": [88, 1], "end": [91, 78], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.HasLimit.lift", "code": "@[simps]\ndef lift (s : Fan f) : s.pt \u27f6 AddCommGroupCat.of (\u2200 j, f j) where\n  toFun x j := s.\u03c0.app \u27e8j\u27e9 x\n  map_zero' := by\n    simp only [Functor.const_obj_obj, map_zero]\n    rfl\n  map_add' x y := by\n    simp only [Functor.const_obj_obj, map_add]\n    rfl", "start": [98, 1], "end": [109, 8], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.HasLimit.productLimitCone", "code": "@[simps]\ndef productLimitCone : Limits.LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := AddCommGroupCat.of (\u2200 j, f j)\n      \u03c0 := Discrete.natTrans fun j => Pi.evalAddMonoidHom (fun j => f j) j.as }\n  isLimit :=\n    { lift := lift.{_, u} f\n      fac := fun s j => rfl\n      uniq := fun s m w => by\n        ext x\n        funext j\n        exact congr_arg (fun g : s.pt \u27f6 f j => (g : s.pt \u2192 f j) x) (w \u27e8j\u27e9) }", "start": [112, 1], "end": [126, 77], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.biproductIsoPi", "code": "@[simps! hom_apply]\nnoncomputable def biproductIsoPi (f : J \u2192 AddCommGroupCat.{u}) :\n    (\u2a01 f : AddCommGroupCat) \u2245 AddCommGroupCat.of (\u2200 j, f j) :=\n  IsLimit.conePointUniqueUpToIso (biproduct.isLimit f) (productLimitCone f).isLimit", "start": [135, 1], "end": [141, 84], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.biproductIsoPi_inv_comp_\u03c0", "code": "@[simp, elementwise]\ntheorem biproductIsoPi_inv_comp_\u03c0 (f : J \u2192 AddCommGroupCat.{u}) (j : J) :\n    (biproductIsoPi f).inv \u226b biproduct.\u03c0 f j = Pi.evalAddMonoidHom (fun j => f j) j", "start": [147, 1], "end": [150, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/IncludeStr.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Combinatorics/Quiver/Covering.lean", "imports": ["Mathlib/Data/Sigma/Basic.lean", "Mathlib/Combinatorics/Quiver/Symmetric.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Logic/Equiv/Basic.lean", "Mathlib/Tactic/Common.lean", "Mathlib/Combinatorics/Quiver/Cast.lean"], "premises": [{"full_name": "Quiver.Star", "code": "@[reducible]\ndef Quiver.Star (u : U) :=\n  \u03a3 v : U, u \u27f6 v", "start": [53, 1], "end": [57, 17], "kind": "commanddeclaration"}, {"full_name": "Quiver.Star.mk", "code": "@[reducible]\nprotected def Quiver.Star.mk {u v : U} (f : u \u27f6 v) : Quiver.Star u :=\n  \u27e8_, f\u27e9", "start": [60, 1], "end": [63, 9], "kind": "commanddeclaration"}, {"full_name": "Quiver.Costar", "code": "@[reducible]\ndef Quiver.Costar (v : U) :=\n  \u03a3 u : U, u \u27f6 v", "start": [66, 1], "end": [70, 17], "kind": "commanddeclaration"}, {"full_name": "Quiver.Costar.mk", "code": "@[reducible]\nprotected def Quiver.Costar.mk {u v : U} (f : u \u27f6 v) : Quiver.Costar v :=\n  \u27e8_, f\u27e9", "start": [73, 1], "end": [76, 9], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.star", "code": "@[simps]\ndef Prefunctor.star (u : U) : Quiver.Star u \u2192 Quiver.Star (\u03c6.obj u) := fun F =>\n  Quiver.Star.mk (\u03c6.map F.2)", "start": [79, 1], "end": [82, 29], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.costar", "code": "@[simps]\ndef Prefunctor.costar (u : U) : Quiver.Costar u \u2192 Quiver.Costar (\u03c6.obj u) := fun F =>\n  Quiver.Costar.mk (\u03c6.map F.2)", "start": [85, 1], "end": [88, 31], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.star_apply", "code": "@[simp]\ntheorem Prefunctor.star_apply {u v : U} (e : u \u27f6 v) :\n    \u03c6.star u (Quiver.Star.mk e) = Quiver.Star.mk (\u03c6.map e)", "start": [91, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.costar_apply", "code": "@[simp]\ntheorem Prefunctor.costar_apply {u v : U} (e : u \u27f6 v) :\n    \u03c6.costar v (Quiver.Costar.mk e) = Quiver.Costar.mk (\u03c6.map e)", "start": [97, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.star_comp", "code": "theorem Prefunctor.star_comp (u : U) : (\u03c6 \u22d9q \u03c8).star u = \u03c8.star (\u03c6.obj u) \u2218 \u03c6.star u", "start": [103, 1], "end": [104, 6], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.costar_comp", "code": "theorem Prefunctor.costar_comp (u : U) : (\u03c6 \u22d9q \u03c8).costar u = \u03c8.costar (\u03c6.obj u) \u2218 \u03c6.costar u", "start": [107, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.IsCovering", "code": "protected structure Prefunctor.IsCovering : Prop where\n  star_bijective : \u2200 u, Bijective (\u03c6.star u)\n  costar_bijective : \u2200 u, Bijective (\u03c6.costar u)", "start": [111, 1], "end": [114, 49], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.IsCovering.map_injective", "code": "@[simp]\ntheorem Prefunctor.IsCovering.map_injective (h\u03c6 : \u03c6.IsCovering) {u v : U} :\n    Injective fun f : u \u27f6 v => \u03c6.map f", "start": [117, 1], "end": [122, 46], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.IsCovering.comp", "code": "theorem Prefunctor.IsCovering.comp (h\u03c6 : \u03c6.IsCovering) (h\u03c8 : \u03c8.IsCovering) : (\u03c6 \u22d9q \u03c8).IsCovering", "start": [125, 1], "end": [127, 66], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.IsCovering.of_comp_right", "code": "theorem Prefunctor.IsCovering.of_comp_right (h\u03c8 : \u03c8.IsCovering) (h\u03c6\u03c8 : (\u03c6 \u22d9q \u03c8).IsCovering) :\n    \u03c6.IsCovering", "start": [130, 1], "end": [133, 92], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.IsCovering.of_comp_left", "code": "theorem Prefunctor.IsCovering.of_comp_left (h\u03c6 : \u03c6.IsCovering) (h\u03c6\u03c8 : (\u03c6 \u22d9q \u03c8).IsCovering)\n    (\u03c6sur : Surjective \u03c6.obj) : \u03c8.IsCovering", "start": [136, 1], "end": [140, 83], "kind": "commanddeclaration"}, {"full_name": "Quiver.symmetrifyStar", "code": "def Quiver.symmetrifyStar (u : U) :\n    Quiver.Star (Symmetrify.of.obj u) \u2243 Sum (Quiver.Star u) (Quiver.Costar u) :=\n  Equiv.sigmaSumDistrib _ _", "start": [143, 1], "end": [147, 28], "kind": "commanddeclaration"}, {"full_name": "Quiver.symmetrifyCostar", "code": "def Quiver.symmetrifyCostar (u : U) :\n    Quiver.Costar (Symmetrify.of.obj u) \u2243 Sum (Quiver.Costar u) (Quiver.Star u) :=\n  Equiv.sigmaSumDistrib _ _", "start": [150, 1], "end": [154, 28], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.symmetrifyStar", "code": "theorem Prefunctor.symmetrifyStar (u : U) :\n    \u03c6.symmetrify.star u =\n      (Quiver.symmetrifyStar _).symm \u2218 Sum.map (\u03c6.star u) (\u03c6.costar u) \u2218\n        Quiver.symmetrifyStar u", "start": [157, 1], "end": [167, 9], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.symmetrifyCostar", "code": "protected theorem Prefunctor.symmetrifyCostar (u : U) :\n    \u03c6.symmetrify.costar u =\n      (Quiver.symmetrifyCostar _).symm \u2218\n        Sum.map (\u03c6.costar u) (\u03c6.star u) \u2218 Quiver.symmetrifyCostar u", "start": [170, 1], "end": [180, 9], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.IsCovering.symmetrify", "code": "protected theorem Prefunctor.IsCovering.symmetrify (h\u03c6 : \u03c6.IsCovering) :\n    \u03c6.symmetrify.IsCovering", "start": [183, 1], "end": [190, 54], "kind": "commanddeclaration"}, {"full_name": "Quiver.PathStar", "code": "@[reducible]\ndef Quiver.PathStar (u : U) :=\n  \u03a3 v : U, Path u v", "start": [193, 1], "end": [197, 20], "kind": "commanddeclaration"}, {"full_name": "Quiver.PathStar.mk", "code": "@[reducible]\nprotected def Quiver.PathStar.mk {u v : U} (p : Path u v) : Quiver.PathStar u :=\n  \u27e8_, p\u27e9", "start": [200, 1], "end": [203, 9], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.pathStar", "code": "def Prefunctor.pathStar (u : U) : Quiver.PathStar u \u2192 Quiver.PathStar (\u03c6.obj u) := fun p =>\n  Quiver.PathStar.mk (\u03c6.mapPath p.2)", "start": [206, 1], "end": [208, 37], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.pathStar_apply", "code": "@[simp]\ntheorem Prefunctor.pathStar_apply {u v : U} (p : Path u v) :\n    \u03c6.pathStar u (Quiver.PathStar.mk p) = Quiver.PathStar.mk (\u03c6.mapPath p)", "start": [211, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.pathStar_injective", "code": "theorem Prefunctor.pathStar_injective (h\u03c6 : \u2200 u, Injective (\u03c6.star u)) (u : U) :\n    Injective (\u03c6.pathStar u)", "start": [217, 1], "end": [249, 8], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.pathStar_surjective", "code": "theorem Prefunctor.pathStar_surjective (h\u03c6 : \u2200 u, Surjective (\u03c6.star u)) (u : U) :\n    Surjective (\u03c6.pathStar u)", "start": [252, 1], "end": [269, 84], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.pathStar_bijective", "code": "theorem Prefunctor.pathStar_bijective (h\u03c6 : \u2200 u, Bijective (\u03c6.star u)) (u : U) :\n    Bijective (\u03c6.pathStar u)", "start": [272, 1], "end": [274, 92], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.IsCovering.pathStar_bijective", "code": "protected theorem pathStar_bijective (h\u03c6 : \u03c6.IsCovering) (u : U) : Bijective (\u03c6.pathStar u)", "start": [281, 1], "end": [282, 30], "kind": "commanddeclaration"}, {"full_name": "Quiver.starEquivCostar", "code": "@[simps]\ndef Quiver.starEquivCostar (u : U) : Quiver.Star u \u2243 Quiver.Costar u where\n  toFun e := \u27e8e.1, reverse e.2\u27e9\n  invFun e := \u27e8e.1, reverse e.2\u27e9\n  left_inv e := by simp [Sigma.ext_iff]\n  right_inv e := by simp [Sigma.ext_iff]", "start": [291, 1], "end": [298, 41], "kind": "commanddeclaration"}, {"full_name": "Quiver.starEquivCostar_apply", "code": "@[simp]\ntheorem Quiver.starEquivCostar_apply {u v : U} (e : u \u27f6 v) :\n    Quiver.starEquivCostar u (Quiver.Star.mk e) = Quiver.Costar.mk (reverse e)", "start": [301, 1], "end": [304, 6], "kind": "commanddeclaration"}, {"full_name": "Quiver.starEquivCostar_symm_apply", "code": "@[simp]\ntheorem Quiver.starEquivCostar_symm_apply {u v : U} (e : u \u27f6 v) :\n    (Quiver.starEquivCostar v).symm (Quiver.Costar.mk e) = Quiver.Star.mk (reverse e)", "start": [307, 1], "end": [310, 6], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.costar_conj_star", "code": "theorem Prefunctor.costar_conj_star (u : U) :\n    \u03c6.costar u = Quiver.starEquivCostar (\u03c6.obj u) \u2218 \u03c6.star u \u2218 (Quiver.starEquivCostar u).symm", "start": [313, 1], "end": [315, 22], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.bijective_costar_iff_bijective_star", "code": "theorem Prefunctor.bijective_costar_iff_bijective_star (u : U) :\n    Bijective (\u03c6.costar u) \u2194 Bijective (\u03c6.star u)", "start": [318, 1], "end": [320, 87], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.isCovering_of_bijective_star", "code": "theorem Prefunctor.isCovering_of_bijective_star (h : \u2200 u, Bijective (\u03c6.star u)) : \u03c6.IsCovering", "start": [323, 1], "end": [324, 66], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.isCovering_of_bijective_costar", "code": "theorem Prefunctor.isCovering_of_bijective_costar (h : \u2200 u, Bijective (\u03c6.costar u)) :\n    \u03c6.IsCovering", "start": [327, 1], "end": [329, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/ExteriorAlgebra/Grading.lean", "imports": ["Mathlib/RingTheory/GradedAlgebra/Basic.lean", "Mathlib/LinearAlgebra/ExteriorAlgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ExteriorAlgebra.GradedAlgebra.\u03b9", "code": "protected def GradedAlgebra.\u03b9 :\n    M \u2192\u2097[R] \u2a01 i : \u2115, \u21a5(LinearMap.range (\u03b9 R : M \u2192\u2097[R] ExteriorAlgebra R M) ^ i) :=\n  DirectSum.lof R \u2115 (fun i => \u21a5(LinearMap.range (\u03b9 R : M \u2192\u2097[R] ExteriorAlgebra R M) ^ i)) 1 \u2218\u2097\n    (\u03b9 R).codRestrict _ fun m => by simpa only [pow_one] using LinearMap.mem_range_self _ m", "start": [29, 1], "end": [35, 92], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.GradedAlgebra.\u03b9_apply", "code": "theorem GradedAlgebra.\u03b9_apply (m : M) :\n    GradedAlgebra.\u03b9 R M m =\n      DirectSum.of (fun i => {x // x \u2208 (LinearMap.range (\u03b9 R : M \u2192\u2097[R] ExteriorAlgebra R M) ^ i)}) 1\n        \u27e8\u03b9 R m, by simpa only [pow_one] using LinearMap.mem_range_self _ m\u27e9", "start": [39, 1], "end": [43, 6], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.GradedAlgebra.\u03b9_sq_zero", "code": "theorem GradedAlgebra.\u03b9_sq_zero (m : M) : GradedAlgebra.\u03b9 R M m * GradedAlgebra.\u03b9 R M m = 0", "start": [50, 1], "end": [52, 82], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.GradedAlgebra.lift\u03b9", "code": "def GradedAlgebra.lift\u03b9 :\n    ExteriorAlgebra R M \u2192\u2090[R] \u2a01 i : \u2115,\n    (LinearMap.range (\u03b9 R : M \u2192\u2097[R] ExteriorAlgebra R M) ^ i : Submodule R (ExteriorAlgebra R M)) :=\n  lift R \u27e8by apply GradedAlgebra.\u03b9 R M, GradedAlgebra.\u03b9_sq_zero R M\u27e9", "start": [55, 1], "end": [60, 69], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.GradedAlgebra.lift\u03b9_eq", "code": "theorem GradedAlgebra.lift\u03b9_eq (i : \u2115)\n    (x : (LinearMap.range (\u03b9 R : M \u2192\u2097[R] ExteriorAlgebra R M) ^ i :\n      Submodule R (ExteriorAlgebra R M))) :\n    GradedAlgebra.lift\u03b9 R M x =\n    DirectSum.of (fun i =>\n      \u21a5(LinearMap.range (\u03b9 R : M \u2192\u2097[R] ExteriorAlgebra R M) ^ i :\n      Submodule R (ExteriorAlgebra R M))) i x", "start": [63, 1], "end": [83, 86], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.gradedAlgebra", "code": "instance gradedAlgebra :\n    GradedAlgebra (LinearMap.range (\u03b9 R : M \u2192\u2097[R] ExteriorAlgebra R M) ^ \u00b7 : \u2115 \u2192 Submodule R _) :=\n  GradedAlgebra.ofAlgHom _\n    (by apply GradedAlgebra.lift\u03b9 R M)\n    (by\n      ext m\n      dsimp only [LinearMap.comp_apply, AlgHom.toLinearMap_apply, AlgHom.comp_apply,\n        AlgHom.id_apply, GradedAlgebra.lift\u03b9]\n      rw [lift_\u03b9_apply, GradedAlgebra.\u03b9_apply R M, DirectSum.coeAlgHom_of, Subtype.coe_mk])\n    (by apply GradedAlgebra.lift\u03b9_eq R M)", "start": [86, 1], "end": [98, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/Interval.lean", "imports": ["Mathlib/Data/Finset/LocallyFinite.lean", "Mathlib/Data/DFinsupp/Multiset.lean", "Mathlib/Data/DFinsupp/Interval.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Interval.lean"], "premises": [{"full_name": "Multiset.Icc_eq", "code": "theorem Icc_eq :\n    Finset.Icc s t = (Finset.Icc (toDFinsupp s) (toDFinsupp t)).map\n      Multiset.equivDFinsupp.toEquiv.symm.toEmbedding", "start": [45, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.uIcc_eq", "code": "theorem uIcc_eq :\n    uIcc s t =\n      (uIcc (toDFinsupp s) (toDFinsupp t)).map Multiset.equivDFinsupp.toEquiv.symm.toEmbedding", "start": [51, 1], "end": [54, 39], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_Icc", "code": "theorem card_Icc :\n    (Finset.Icc s t).card = \u220f i in s.toFinset \u222a t.toFinset, (t.count i + 1 - s.count i)", "start": [57, 1], "end": [60, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_Ico", "code": "theorem card_Ico :\n    (Finset.Ico s t).card = \u220f i in s.toFinset \u222a t.toFinset, (t.count i + 1 - s.count i) - 1", "start": [63, 1], "end": [65, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_Ioc", "code": "theorem card_Ioc :\n    (Finset.Ioc s t).card = \u220f i in s.toFinset \u222a t.toFinset, (t.count i + 1 - s.count i) - 1", "start": [68, 1], "end": [70, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_Ioo", "code": "theorem card_Ioo :\n    (Finset.Ioo s t).card = \u220f i in s.toFinset \u222a t.toFinset, (t.count i + 1 - s.count i) - 2", "start": [73, 1], "end": [75, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_uIcc", "code": "theorem card_uIcc :\n    (uIcc s t).card = \u220f i in s.toFinset \u222a t.toFinset, ((t.count i - s.count i : \u2124).natAbs + 1)", "start": [78, 1], "end": [81, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_Iic", "code": "theorem card_Iic : (Finset.Iic s).card = \u220f i in s.toFinset, (s.count i + 1)", "start": [84, 1], "end": [85, 97], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/Centroid.lean", "imports": ["Mathlib/Algebra/GroupPower/Lemmas.lean", "Mathlib/Algebra/Hom/GroupInstances.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CentroidHom", "code": "structure CentroidHom (\u03b1 : Type*) [NonUnitalNonAssocSemiring \u03b1] extends \u03b1 \u2192+ \u03b1 where\n  \n  map_mul_left' (a b : \u03b1) : toFun (a * b) = a * toFun b\n  \n  map_mul_right' (a b : \u03b1) : toFun (a * b) = toFun a * b", "start": [48, 1], "end": [53, 57], "kind": "commanddeclaration"}, {"full_name": "CentroidHomClass", "code": "class CentroidHomClass (F : Type*) (\u03b1 : outParam <| Type*) [NonUnitalNonAssocSemiring \u03b1] extends\n  AddMonoidHomClass F \u03b1 \u03b1 where\n  \n  map_mul_left (f : F) (a b : \u03b1) : f (a * b) = a * f b\n  \n  map_mul_right (f : F) (a b : \u03b1) : f (a * b) = f a * b", "start": [58, 1], "end": [66, 56], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toFun_eq_coe", "code": "theorem toFun_eq_coe {f : CentroidHom \u03b1} : f.toFun = f", "start": [110, 1], "end": [110, 62], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.ext", "code": "@[ext]\ntheorem ext {f g : CentroidHom \u03b1} (h : \u2200 a, f a = g a) : f = g", "start": [113, 1], "end": [115, 20], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_toAddMonoidHom", "code": "@[simp, norm_cast]\ntheorem coe_toAddMonoidHom (f : CentroidHom \u03b1) : \u21d1(f : \u03b1 \u2192+ \u03b1) = f", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toAddMonoidHom_eq_coe", "code": "@[simp]\ntheorem toAddMonoidHom_eq_coe (f : CentroidHom \u03b1) : f.toAddMonoidHom = f", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_toAddMonoidHom_injective", "code": "theorem coe_toAddMonoidHom_injective : Injective ((\u2191) : CentroidHom \u03b1 \u2192 \u03b1 \u2192+ \u03b1)", "start": [128, 1], "end": [131, 9], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toEnd", "code": "def toEnd (f : CentroidHom \u03b1) : AddMonoid.End \u03b1 :=\n  (f : \u03b1 \u2192+ \u03b1)", "start": [134, 1], "end": [136, 15], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toEnd_injective", "code": "theorem toEnd_injective : Injective (CentroidHom.toEnd : CentroidHom \u03b1 \u2192 AddMonoid.End \u03b1)", "start": [139, 1], "end": [140, 31], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.copy", "code": "protected def copy (f : CentroidHom \u03b1) (f' : \u03b1 \u2192 \u03b1) (h : f' = f) : CentroidHom \u03b1 :=\n  { f.toAddMonoidHom.copy f' <| h with\n    toFun := f'\n    map_mul_left' := fun a b \u21a6 by simp_rw [h, map_mul_left]\n    map_mul_right' := fun a b \u21a6 by simp_rw [h, map_mul_right] }", "start": [143, 1], "end": [149, 64], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : CentroidHom \u03b1) (f' : \u03b1 \u2192 \u03b1) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [152, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.copy_eq", "code": "theorem copy_eq (f : CentroidHom \u03b1) (f' : \u03b1 \u2192 \u03b1) (h : f' = f) : f.copy f' h = f", "start": [157, 1], "end": [158, 17], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.id", "code": "protected def id : CentroidHom \u03b1 :=\n  { AddMonoidHom.id \u03b1 with\n    map_mul_left' := fun _ _ \u21a6 rfl\n    map_mul_right' := fun _ _ \u21a6 rfl }", "start": [163, 1], "end": [167, 38], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_id", "code": "@[simp, norm_cast]\ntheorem coe_id : \u21d1(CentroidHom.id \u03b1) = id", "start": [173, 1], "end": [175, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toAddMonoidHom_id", "code": "@[simp, norm_cast]\ntheorem toAddMonoidHom_id : (CentroidHom.id \u03b1 : \u03b1 \u2192+ \u03b1) = AddMonoidHom.id \u03b1", "start": [178, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : CentroidHom.id \u03b1 a = a", "start": [185, 1], "end": [187, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.comp", "code": "def comp (g f : CentroidHom \u03b1) : CentroidHom \u03b1 :=\n  { g.toAddMonoidHom.comp f.toAddMonoidHom with\n    map_mul_left' := fun _a _b \u21a6 (congr_arg g <| f.map_mul_left' _ _).trans <| g.map_mul_left' _ _\n    map_mul_right' := fun _a _b \u21a6\n      (congr_arg g <| f.map_mul_right' _ _).trans <| g.map_mul_right' _ _ }", "start": [190, 1], "end": [195, 76], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_comp", "code": "@[simp, norm_cast]\ntheorem coe_comp (g f : CentroidHom \u03b1) : \u21d1(g.comp f) = g \u2218 f", "start": [198, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (g f : CentroidHom \u03b1) (a : \u03b1) : g.comp f a = g (f a)", "start": [203, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_comp_addMonoidHom", "code": "@[simp, norm_cast]\ntheorem coe_comp_addMonoidHom (g f : CentroidHom \u03b1) : (g.comp f : \u03b1 \u2192+ \u03b1) = (g : \u03b1 \u2192+ \u03b1).comp f", "start": [208, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (h g f : CentroidHom \u03b1) : (h.comp g).comp f = h.comp (g.comp f)", "start": [213, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : CentroidHom \u03b1) : f.comp (CentroidHom.id \u03b1) = f", "start": [218, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : CentroidHom \u03b1) : (CentroidHom.id \u03b1).comp f = f", "start": [223, 1], "end": [225, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 f : CentroidHom \u03b1} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [228, 1], "end": [231, 92], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g f\u2081 f\u2082 : CentroidHom \u03b1} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [234, 1], "end": [237, 79], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.hasNsmul", "code": "instance hasNsmul : SMul \u2115 (CentroidHom \u03b1) :=\n  \u27e8fun n f \u21a6\n    { ((SMul.smul n f) : \u03b1 \u2192+ \u03b1) with\n        map_mul_left' := fun a b \u21a6 by\n          change n \u2022 f (a * b) = a * n \u2022 f b\n          rw [map_mul_left f, \u2190 mul_smul_comm]\n        map_mul_right' := fun a b \u21a6 by\n          change n \u2022 f (a * b) = n \u2022 f a * b\n          rw [map_mul_right f, \u2190 smul_mul_assoc] }\u27e9", "start": [261, 1], "end": [269, 52], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.hasNpowNat", "code": "instance hasNpowNat : Pow (CentroidHom \u03b1) \u2115 :=\n  \u27e8fun f n \u21a6\n    { (f.toEnd ^ n : AddMonoid.End \u03b1) with\n      map_mul_left' := fun a b \u21a6 by\n        induction' n with n ih\n        \u00b7 exact rfl\n        \u00b7 simp\n          rw [pow_succ]\n          exact (congr_arg f.toEnd ih).trans (f.map_mul_left' _ _)\n      map_mul_right' := fun a b \u21a6 by\n        induction' n with n ih\n        \u00b7 exact rfl\n        \u00b7 simp\n          rw [pow_succ]\n          exact (congr_arg f.toEnd ih).trans (f.map_mul_right' _ _) }\u27e9", "start": [272, 1], "end": [286, 71], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : \u21d1(0 : CentroidHom \u03b1) = 0", "start": [289, 1], "end": [291, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one : \u21d1(1 : CentroidHom \u03b1) = id", "start": [294, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add (f g : CentroidHom \u03b1) : \u21d1(f + g) = f + g", "start": [299, 1], "end": [301, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (f g : CentroidHom \u03b1) : \u21d1(f * g) = f \u2218 g", "start": [304, 1], "end": [306, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_nsmul", "code": "@[simp, norm_cast, nolint simpNF]\ntheorem coe_nsmul (f : CentroidHom \u03b1) (n : \u2115) : \u21d1(n \u2022 f) = n \u2022 (\u21d1f)", "start": [310, 1], "end": [312, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.zero_apply", "code": "@[simp]\ntheorem zero_apply (a : \u03b1) : (0 : CentroidHom \u03b1) a = 0", "start": [315, 1], "end": [317, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.one_apply", "code": "@[simp]\ntheorem one_apply (a : \u03b1) : (1 : CentroidHom \u03b1) a = a", "start": [320, 1], "end": [322, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.add_apply", "code": "@[simp]\ntheorem add_apply (f g : CentroidHom \u03b1) (a : \u03b1) : (f + g) a = f a + g a", "start": [325, 1], "end": [327, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.mul_apply", "code": "@[simp]\ntheorem mul_apply (f g : CentroidHom \u03b1) (a : \u03b1) : (f * g) a = f (g a)", "start": [330, 1], "end": [332, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.nsmul_apply", "code": "@[simp, nolint simpNF]\ntheorem nsmul_apply (f : CentroidHom \u03b1) (n : \u2115) (a : \u03b1) : (n \u2022 f) a = n \u2022 f a", "start": [336, 1], "end": [338, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toEnd_zero", "code": "@[simp]\ntheorem toEnd_zero : (0 : CentroidHom \u03b1).toEnd = 0", "start": [341, 1], "end": [343, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toEnd_add", "code": "@[simp]\ntheorem toEnd_add (x y : CentroidHom \u03b1) : (x + y).toEnd = x.toEnd + y.toEnd", "start": [346, 1], "end": [348, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toEnd_nsmul", "code": "theorem toEnd_nsmul (x : CentroidHom \u03b1) (n : \u2115) : (n \u2022 x).toEnd = n \u2022 x.toEnd", "start": [351, 1], "end": [352, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_nat_cast", "code": "@[simp, norm_cast, nolint simpNF]\ntheorem coe_nat_cast (n : \u2115) : \u21d1(n : CentroidHom \u03b1) = n \u2022 (CentroidHom.id \u03b1)", "start": [363, 1], "end": [365, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.nat_cast_apply", "code": "theorem nat_cast_apply (n : \u2115) (m : \u03b1) : (n : CentroidHom \u03b1) m = n \u2022 m", "start": [368, 1], "end": [369, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toEnd_one", "code": "@[simp]\ntheorem toEnd_one : (1 : CentroidHom \u03b1).toEnd = 1", "start": [372, 1], "end": [374, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toEnd_mul", "code": "@[simp]\ntheorem toEnd_mul (x y : CentroidHom \u03b1) : (x * y).toEnd = x.toEnd * y.toEnd", "start": [377, 1], "end": [379, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toEnd_pow", "code": "@[simp]\ntheorem toEnd_pow (x : CentroidHom \u03b1) (n : \u2115) : (x ^ n).toEnd = x.toEnd ^ n", "start": [382, 1], "end": [384, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toEnd_nat_cast", "code": "@[simp, norm_cast]\ntheorem toEnd_nat_cast (n : \u2115) : (n : CentroidHom \u03b1).toEnd = \u2191n", "start": [387, 1], "end": [389, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.comp_mul_comm", "code": "theorem comp_mul_comm (T S : CentroidHom \u03b1) (a b : \u03b1) : (T \u2218 S) (a * b) = (S \u2218 T) (a * b)", "start": [397, 1], "end": [399, 68], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.hasZsmul", "code": "instance hasZsmul : SMul \u2124 (CentroidHom \u03b1) :=\n  \u27e8fun n f \u21a6\n    { (SMul.smul n f : \u03b1 \u2192+ \u03b1) with\n      map_mul_left' := fun a b \u21a6 by\n        change n \u2022 f (a * b) = a * n \u2022 f b\n        rw [map_mul_left f, \u2190 mul_smul_comm]\n      map_mul_right' := fun a b \u21a6 by\n        change n \u2022 f (a * b) = n \u2022 f a * b\n        rw [map_mul_right f, \u2190 smul_mul_assoc] }\u27e9", "start": [429, 1], "end": [437, 50], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_int_cast", "code": "@[simp, norm_cast, nolint simpNF]\ntheorem coe_int_cast (z : \u2124) : \u21d1(z : CentroidHom \u03b1) = z \u2022 (CentroidHom.id \u03b1)", "start": [443, 1], "end": [445, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.int_cast_apply", "code": "theorem int_cast_apply (z : \u2124) (m : \u03b1) : (z : CentroidHom \u03b1) m = z \u2022 m", "start": [448, 1], "end": [449, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toEnd_neg", "code": "@[simp]\ntheorem toEnd_neg (x : CentroidHom \u03b1) : (-x).toEnd = -x.toEnd", "start": [452, 1], "end": [454, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toEnd_sub", "code": "@[simp]\ntheorem toEnd_sub (x y : CentroidHom \u03b1) : (x - y).toEnd = x.toEnd - y.toEnd", "start": [457, 1], "end": [459, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toEnd_zsmul", "code": "theorem toEnd_zsmul (x : CentroidHom \u03b1) (n : \u2124) : (n \u2022 x).toEnd = n \u2022 x.toEnd", "start": [462, 1], "end": [463, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_neg", "code": "@[simp, norm_cast]\ntheorem coe_neg (f : CentroidHom \u03b1) : \u21d1(-f) = -f", "start": [469, 1], "end": [471, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.coe_sub", "code": "@[simp, norm_cast]\ntheorem coe_sub (f g : CentroidHom \u03b1) : \u21d1(f - g) = f - g", "start": [474, 1], "end": [476, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.neg_apply", "code": "@[simp]\ntheorem neg_apply (f : CentroidHom \u03b1) (a : \u03b1) : (-f) a = -f a", "start": [479, 1], "end": [481, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.sub_apply", "code": "@[simp]\ntheorem sub_apply (f g : CentroidHom \u03b1) (a : \u03b1) : (f - g) a = f a - g a", "start": [484, 1], "end": [486, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.toEnd_int_cast", "code": "@[simp, norm_cast]\ntheorem toEnd_int_cast (z : \u2124) : (z : CentroidHom \u03b1).toEnd = \u2191z", "start": [489, 1], "end": [491, 6], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.instRing", "code": "instance instRing : Ring (CentroidHom \u03b1) :=\n  toEnd_injective.ring _ toEnd_zero toEnd_one toEnd_add toEnd_mul toEnd_neg toEnd_sub\n    toEnd_nsmul toEnd_zsmul toEnd_pow toEnd_nat_cast toEnd_int_cast", "start": [494, 1], "end": [496, 68], "kind": "commanddeclaration"}, {"full_name": "CentroidHom.commRing", "code": "@[reducible]\ndef commRing (h : \u2200 a b : \u03b1, (\u2200 r : \u03b1, a * r * b = 0) \u2192 a = 0 \u2228 b = 0) : CommRing (CentroidHom \u03b1) :=\n  { CentroidHom.instRing with\n    mul_comm := fun f g \u21a6 by\n      ext\n      refine' sub_eq_zero.1 ((or_self_iff _).1 <| (h _ _) fun r \u21a6 _)\n      rw [mul_assoc, sub_mul, sub_eq_zero, \u2190 map_mul_right, \u2190 map_mul_right, coe_mul, coe_mul,\n        comp_mul_comm] }", "start": [506, 1], "end": [514, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/Implicit.lean", "imports": ["Mathlib/Analysis/NormedSpace/Complemented.lean", "Mathlib/Analysis/Calculus/Inverse.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ImplicitFunctionData", "code": "structure ImplicitFunctionData (\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [CompleteSpace E] (F : Type*) [NormedAddCommGroup F]\n    [NormedSpace \ud835\udd5c F] [CompleteSpace F] (G : Type*) [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]\n    [CompleteSpace G] where\n  leftFun : E \u2192 F\n  leftDeriv : E \u2192L[\ud835\udd5c] F\n  rightFun : E \u2192 G\n  rightDeriv : E \u2192L[\ud835\udd5c] G\n  pt : E\n  left_has_deriv : HasStrictFDerivAt leftFun leftDeriv pt\n  right_has_deriv : HasStrictFDerivAt rightFun rightDeriv pt\n  left_range : range leftDeriv = \u22a4\n  right_range : range rightDeriv = \u22a4\n  isCompl_ker : IsCompl (ker leftDeriv) (ker rightDeriv)", "start": [91, 1], "end": [111, 57], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.prodFun", "code": "def prodFun (x : E) : F \u00d7 G :=\n  (\u03c6.leftFun x, \u03c6.rightFun x)", "start": [121, 1], "end": [123, 30], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.prodFun_apply", "code": "@[simp]\ntheorem prodFun_apply (x : E) : \u03c6.prodFun x = (\u03c6.leftFun x, \u03c6.rightFun x)", "start": [126, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.hasStrictFDerivAt", "code": "protected theorem hasStrictFDerivAt :\n    HasStrictFDerivAt \u03c6.prodFun\n      (\u03c6.leftDeriv.equivProdOfSurjectiveOfIsCompl \u03c6.rightDeriv \u03c6.left_range \u03c6.right_range\n          \u03c6.isCompl_ker :\n        E \u2192L[\ud835\udd5c] F \u00d7 G)\n      \u03c6.pt", "start": [131, 1], "end": [137, 42], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.toLocalHomeomorph", "code": "def toLocalHomeomorph : LocalHomeomorph E (F \u00d7 G) :=\n  \u03c6.hasStrictFDerivAt.toLocalHomeomorph _", "start": [140, 1], "end": [145, 42], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.implicitFunction", "code": "def implicitFunction : F \u2192 G \u2192 E :=\n  Function.curry <| \u03c6.toLocalHomeomorph.symm", "start": [148, 1], "end": [153, 45], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.toLocalHomeomorph_coe", "code": "@[simp]\ntheorem toLocalHomeomorph_coe : \u21d1\u03c6.toLocalHomeomorph = \u03c6.prodFun", "start": [156, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.toLocalHomeomorph_apply", "code": "theorem toLocalHomeomorph_apply (x : E) : \u03c6.toLocalHomeomorph x = (\u03c6.leftFun x, \u03c6.rightFun x)", "start": [161, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.pt_mem_toLocalHomeomorph_source", "code": "theorem pt_mem_toLocalHomeomorph_source : \u03c6.pt \u2208 \u03c6.toLocalHomeomorph.source", "start": [165, 1], "end": [166, 51], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.map_pt_mem_toLocalHomeomorph_target", "code": "theorem map_pt_mem_toLocalHomeomorph_target :\n    (\u03c6.leftFun \u03c6.pt, \u03c6.rightFun \u03c6.pt) \u2208 \u03c6.toLocalHomeomorph.target", "start": [169, 1], "end": [171, 70], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.prod_map_implicitFunction", "code": "theorem prod_map_implicitFunction :\n    \u2200\u1da0 p : F \u00d7 G in \ud835\udcdd (\u03c6.prodFun \u03c6.pt), \u03c6.prodFun (\u03c6.implicitFunction p.1 p.2) = p", "start": [174, 1], "end": [176, 70], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.left_map_implicitFunction", "code": "theorem left_map_implicitFunction :\n    \u2200\u1da0 p : F \u00d7 G in \ud835\udcdd (\u03c6.prodFun \u03c6.pt), \u03c6.leftFun (\u03c6.implicitFunction p.1 p.2) = p.1", "start": [179, 1], "end": [181, 63], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.right_map_implicitFunction", "code": "theorem right_map_implicitFunction :\n    \u2200\u1da0 p : F \u00d7 G in \ud835\udcdd (\u03c6.prodFun \u03c6.pt), \u03c6.rightFun (\u03c6.implicitFunction p.1 p.2) = p.2", "start": [184, 1], "end": [186, 63], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.implicitFunction_apply_image", "code": "theorem implicitFunction_apply_image :\n    \u2200\u1da0 x in \ud835\udcdd \u03c6.pt, \u03c6.implicitFunction (\u03c6.leftFun x) (\u03c6.rightFun x) = x", "start": [189, 1], "end": [191, 46], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.map_nhds_eq", "code": "theorem map_nhds_eq : map \u03c6.leftFun (\ud835\udcdd \u03c6.pt) = \ud835\udcdd (\u03c6.leftFun \u03c6.pt)", "start": [194, 1], "end": [196, 75], "kind": "commanddeclaration"}, {"full_name": "ImplicitFunctionData.implicitFunction_hasStrictFDerivAt", "code": "theorem implicitFunction_hasStrictFDerivAt (g'inv : G \u2192L[\ud835\udd5c] E)\n    (hg'inv : \u03c6.rightDeriv.comp g'inv = ContinuousLinearMap.id \ud835\udd5c G)\n    (hg'invf : \u03c6.leftDeriv.comp g'inv = 0) :\n    HasStrictFDerivAt (\u03c6.implicitFunction (\u03c6.leftFun \u03c6.pt)) g'inv (\u03c6.rightFun \u03c6.pt)", "start": [199, 1], "end": [212, 11], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.implicitFunctionDataOfComplemented", "code": "@[simp]\ndef implicitFunctionDataOfComplemented (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4)\n    (hker : (ker f').ClosedComplemented) : ImplicitFunctionData \ud835\udd5c E F (ker f') where\n  leftFun := f\n  leftDeriv := f'\n  rightFun x := Classical.choose hker (x - a)\n  rightDeriv := Classical.choose hker\n  pt := a\n  left_has_deriv := hf\n  right_has_deriv :=\n    (Classical.choose hker).hasStrictFDerivAt.comp a ((hasStrictFDerivAt_id a).sub_const a)\n  left_range := hf'\n  right_range := LinearMap.range_eq_of_proj (Classical.choose_spec hker)\n  isCompl_ker := LinearMap.isCompl_of_proj (Classical.choose_spec hker)", "start": [243, 1], "end": [258, 72], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.implicitToLocalHomeomorphOfComplemented", "code": "def implicitToLocalHomeomorphOfComplemented (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4)\n    (hker : (ker f').ClosedComplemented) : LocalHomeomorph E (F \u00d7 ker f') :=\n  (implicitFunctionDataOfComplemented f f' hf hf' hker).toLocalHomeomorph", "start": [261, 1], "end": [265, 74], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.implicitFunctionOfComplemented", "code": "def implicitFunctionOfComplemented (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4)\n    (hker : (ker f').ClosedComplemented) : F \u2192 ker f' \u2192 E :=\n  (implicitFunctionDataOfComplemented f f' hf hf' hker).implicitFunction", "start": [268, 1], "end": [271, 73], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.implicitToLocalHomeomorphOfComplemented_fst", "code": "@[simp]\ntheorem implicitToLocalHomeomorphOfComplemented_fst (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = \u22a4) (hker : (ker f').ClosedComplemented) (x : E) :\n    (hf.implicitToLocalHomeomorphOfComplemented f f' hf' hker x).fst = f x", "start": [276, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.implicitToLocalHomeomorphOfComplemented_apply", "code": "theorem implicitToLocalHomeomorphOfComplemented_apply (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = \u22a4) (hker : (ker f').ClosedComplemented) (y : E) :\n    hf.implicitToLocalHomeomorphOfComplemented f f' hf' hker y =\n      (f y, Classical.choose hker (y - a))", "start": [283, 1], "end": [287, 6], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.implicitToLocalHomeomorphOfComplemented_apply_ker", "code": "@[simp]\ntheorem implicitToLocalHomeomorphOfComplemented_apply_ker (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = \u22a4) (hker : (ker f').ClosedComplemented) (y : ker f') :\n    hf.implicitToLocalHomeomorphOfComplemented f f' hf' hker (y + a) = (f (y + a), y)", "start": [290, 1], "end": [295, 32], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.implicitToLocalHomeomorphOfComplemented_self", "code": "@[simp]\ntheorem implicitToLocalHomeomorphOfComplemented_self (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = \u22a4) (hker : (ker f').ClosedComplemented) :\n    hf.implicitToLocalHomeomorphOfComplemented f f' hf' hker a = (f a, 0)", "start": [298, 1], "end": [302, 58], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.mem_implicitToLocalHomeomorphOfComplemented_source", "code": "theorem mem_implicitToLocalHomeomorphOfComplemented_source (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = \u22a4) (hker : (ker f').ClosedComplemented) :\n    a \u2208 (hf.implicitToLocalHomeomorphOfComplemented f f' hf' hker).source", "start": [305, 1], "end": [308, 57], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.mem_implicitToLocalHomeomorphOfComplemented_target", "code": "theorem mem_implicitToLocalHomeomorphOfComplemented_target (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = \u22a4) (hker : (ker f').ClosedComplemented) :\n    (f a, (0 : ker f')) \u2208 (hf.implicitToLocalHomeomorphOfComplemented f f' hf' hker).target", "start": [311, 1], "end": [316, 69], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.map_implicitFunctionOfComplemented_eq", "code": "theorem map_implicitFunctionOfComplemented_eq (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4)\n    (hker : (ker f').ClosedComplemented) :\n    \u2200\u1da0 p : F \u00d7 ker f' in \ud835\udcdd (f a, 0),\n      f (hf.implicitFunctionOfComplemented f f' hf' hker p.1 p.2) = p.1", "start": [319, 1], "end": [326, 41], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.eq_implicitFunctionOfComplemented", "code": "theorem eq_implicitFunctionOfComplemented (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4)\n    (hker : (ker f').ClosedComplemented) :\n    \u2200\u1da0 x in \ud835\udcdd a, hf.implicitFunctionOfComplemented f f' hf' hker (f x)\n      (hf.implicitToLocalHomeomorphOfComplemented f f' hf' hker x).snd = x", "start": [329, 1], "end": [335, 85], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.implicitFunctionOfComplemented_apply_image", "code": "@[simp]\ntheorem implicitFunctionOfComplemented_apply_image (hf : HasStrictFDerivAt f f' a)\n    (hf' : range f' = \u22a4) (hker : (ker f').ClosedComplemented) :\n    hf.implicitFunctionOfComplemented f f' hf' hker (f a) 0 = a", "start": [338, 1], "end": [344, 71], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.to_implicitFunctionOfComplemented", "code": "theorem to_implicitFunctionOfComplemented (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4)\n    (hker : (ker f').ClosedComplemented) :\n    HasStrictFDerivAt (hf.implicitFunctionOfComplemented f f' hf' hker (f a))\n      (ker f').subtypeL 0", "start": [347, 1], "end": [364, 68], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.implicitToLocalHomeomorph", "code": "def implicitToLocalHomeomorph (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4) :\n    LocalHomeomorph E (F \u00d7 ker f') :=\n  haveI := FiniteDimensional.complete \ud835\udd5c F\n  hf.implicitToLocalHomeomorphOfComplemented f f' hf'\n    f'.ker_closedComplemented_of_finiteDimensional_range", "start": [392, 1], "end": [398, 57], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.implicitFunction", "code": "def implicitFunction (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4) : F \u2192 ker f' \u2192 E :=\n  Function.curry <| (hf.implicitToLocalHomeomorph f f' hf').symm", "start": [401, 1], "end": [403, 65], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.implicitToLocalHomeomorph_fst", "code": "@[simp]\ntheorem implicitToLocalHomeomorph_fst (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4) (x : E) :\n    (hf.implicitToLocalHomeomorph f f' hf' x).fst = f x", "start": [408, 1], "end": [411, 6], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.implicitToLocalHomeomorph_apply_ker", "code": "@[simp]\ntheorem implicitToLocalHomeomorph_apply_ker (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4)\n    (y : ker f') : hf.implicitToLocalHomeomorph f f' hf' (y + a) = (f (y + a), y)", "start": [414, 1], "end": [419, 55], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.implicitToLocalHomeomorph_self", "code": "@[simp]\ntheorem implicitToLocalHomeomorph_self (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4) :\n    hf.implicitToLocalHomeomorph f f' hf' a = (f a, 0)", "start": [422, 1], "end": [426, 50], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.mem_implicitToLocalHomeomorph_source", "code": "theorem mem_implicitToLocalHomeomorph_source (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4) :\n    a \u2208 (hf.implicitToLocalHomeomorph f f' hf').source", "start": [429, 1], "end": [432, 57], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.mem_implicitToLocalHomeomorph_target", "code": "theorem mem_implicitToLocalHomeomorph_target (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4) :\n    (f a, (0 : ker f')) \u2208 (hf.implicitToLocalHomeomorph f f' hf').target", "start": [435, 1], "end": [438, 56], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.tendsto_implicitFunction", "code": "theorem tendsto_implicitFunction (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4) {\u03b1 : Type*}\n    {l : Filter \u03b1} {g\u2081 : \u03b1 \u2192 F} {g\u2082 : \u03b1 \u2192 ker f'} (h\u2081 : Tendsto g\u2081 l (\ud835\udcdd <| f a))\n    (h\u2082 : Tendsto g\u2082 l (\ud835\udcdd 0)) :\n    Tendsto (fun t => hf.implicitFunction f f' hf' (g\u2081 t) (g\u2082 t)) l (\ud835\udcdd a)", "start": [441, 1], "end": [448, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.implicitFunction", "code": "alias _root_.Filter.Tendsto.implicitFunction := tendsto_implicitFunction", "start": [451, 1], "end": [451, 73], "kind": "stdtacticaliasalias"}, {"full_name": "HasStrictFDerivAt.map_implicitFunction_eq", "code": "theorem map_implicitFunction_eq (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4) :\n    \u2200\u1da0 p : F \u00d7 ker f' in \ud835\udcdd (f a, 0), f (hf.implicitFunction f f' hf' p.1 p.2) = p.1", "start": [454, 1], "end": [458, 43], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.implicitFunction_apply_image", "code": "@[simp]\ntheorem implicitFunction_apply_image (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4) :\n    hf.implicitFunction f f' hf' (f a) 0 = a", "start": [461, 1], "end": [465, 51], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.eq_implicitFunction", "code": "theorem eq_implicitFunction (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4) :\n    \u2200\u1da0 x in \ud835\udcdd a,\n      hf.implicitFunction f f' hf' (f x) (hf.implicitToLocalHomeomorph f f' hf' x).snd = x", "start": [468, 1], "end": [474, 39], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.to_implicitFunction", "code": "theorem to_implicitFunction (hf : HasStrictFDerivAt f f' a) (hf' : range f' = \u22a4) :\n    HasStrictFDerivAt (hf.implicitFunction f f' hf' (f a)) (ker f').subtypeL 0", "start": [477, 1], "end": [480, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/EquivFunctor/Instances.lean", "imports": ["Mathlib/Control/EquivFunctor.lean", "Mathlib/Data/Fintype/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EquivFunctorUnique", "code": "instance EquivFunctorUnique : EquivFunctor Unique where\n  map e := Equiv.uniqueCongr e\n  map_refl' \u03b1 := by simp\n  map_trans' := by simp", "start": [20, 1], "end": [23, 24], "kind": "commanddeclaration"}, {"full_name": "EquivFunctorPerm", "code": "instance EquivFunctorPerm : EquivFunctor Perm where\n  map e p := (e.symm.trans p).trans e\n  map_refl' \u03b1 := by ext; simp\n  map_trans' _ _ := by ext; simp", "start": [26, 1], "end": [29, 33], "kind": "commanddeclaration"}, {"full_name": "EquivFunctorFinset", "code": "instance EquivFunctorFinset : EquivFunctor Finset where\n  map e s := s.map e.toEmbedding\n  map_refl' \u03b1 := by ext; simp\n  map_trans' k h := by\n    ext _ a; simp; constructor <;> intro h'\n    \u00b7 let \u27e8a, ha\u2081, ha\u2082\u27e9 := h'\n      rw [\u2190 ha\u2082]; simp; apply ha\u2081\n    \u00b7 exists (Equiv.symm k) ((Equiv.symm h) a)\n      simp [h']", "start": [34, 1], "end": [42, 16], "kind": "commanddeclaration"}, {"full_name": "EquivFunctorFintype", "code": "instance EquivFunctorFintype : EquivFunctor Fintype where\n  map e s := Fintype.ofBijective e e.bijective\n  map_refl' \u03b1 := by ext; simp\n  map_trans' := by simp", "start": [45, 1], "end": [48, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/GroupCat/Subobject.lean", "imports": ["Mathlib/Algebra/Category/ModuleCat/Subobject.lean", "Mathlib/Algebra/Category/GroupCat/ZModuleEquivalence.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddCommGroupCat.wellPowered_addCommGroupCat", "code": "instance wellPowered_addCommGroupCat : WellPowered AddCommGroupCat.{u} :=\n  wellPowered_of_equiv (forget\u2082 (ModuleCat.{u} \u2124) AddCommGroupCat.{u}).asEquivalence", "start": [22, 1], "end": [23, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/ENorm.lean", "imports": ["Mathlib/Analysis/NormedSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ENorm", "code": "structure ENorm (\ud835\udd5c : Type*) (V : Type*) [NormedField \ud835\udd5c] [AddCommGroup V] [Module \ud835\udd5c V] where\n  toFun : V \u2192 \u211d\u22650\u221e\n  eq_zero' : \u2200 x, toFun x = 0 \u2192 x = 0\n  map_add_le' : \u2200 x y : V, toFun (x + y) \u2264 toFun x + toFun y\n  map_smul_le' : \u2200 (c : \ud835\udd5c) (x : V), toFun (c \u2022 x) \u2264 \u2016c\u2016\u208a * toFun x", "start": [42, 1], "end": [48, 67], "kind": "commanddeclaration"}, {"full_name": "ENorm.coeFn_injective", "code": "theorem coeFn_injective : Function.Injective ((\u2191) : ENorm \ud835\udd5c V \u2192 V \u2192 \u211d\u22650\u221e)", "start": [61, 1], "end": [64, 8], "kind": "commanddeclaration"}, {"full_name": "ENorm.ext", "code": "@[ext]\ntheorem ext {e\u2081 e\u2082 : ENorm \ud835\udd5c V} (h : \u2200 x, e\u2081 x = e\u2082 x) : e\u2081 = e\u2082", "start": [67, 1], "end": [69, 30], "kind": "commanddeclaration"}, {"full_name": "ENorm.ext_iff", "code": "theorem ext_iff {e\u2081 e\u2082 : ENorm \ud835\udd5c V} : e\u2081 = e\u2082 \u2194 \u2200 x, e\u2081 x = e\u2082 x", "start": [72, 1], "end": [73, 28], "kind": "commanddeclaration"}, {"full_name": "ENorm.coe_inj", "code": "@[simp, norm_cast]\ntheorem coe_inj {e\u2081 e\u2082 : ENorm \ud835\udd5c V} : (e\u2081 : V \u2192 \u211d\u22650\u221e) = e\u2082 \u2194 e\u2081 = e\u2082", "start": [76, 1], "end": [78, 25], "kind": "commanddeclaration"}, {"full_name": "ENorm.map_smul", "code": "@[simp]\ntheorem map_smul (c : \ud835\udd5c) (x : V) : e (c \u2022 x) = \u2016c\u2016\u208a * e x", "start": [81, 1], "end": [92, 22], "kind": "commanddeclaration"}, {"full_name": "ENorm.map_zero", "code": "@[simp]\ntheorem map_zero : e 0 = 0", "start": [95, 1], "end": [98, 11], "kind": "commanddeclaration"}, {"full_name": "ENorm.eq_zero_iff", "code": "@[simp]\ntheorem eq_zero_iff {x : V} : e x = 0 \u2194 x = 0", "start": [101, 1], "end": [103, 47], "kind": "commanddeclaration"}, {"full_name": "ENorm.map_neg", "code": "@[simp]\ntheorem map_neg (x : V) : e (-x) = e x", "start": [106, 1], "end": [110, 23], "kind": "commanddeclaration"}, {"full_name": "ENorm.map_sub_rev", "code": "theorem map_sub_rev (x y : V) : e (x - y) = e (y - x)", "start": [113, 1], "end": [113, 86], "kind": "commanddeclaration"}, {"full_name": "ENorm.map_add_le", "code": "theorem map_add_le (x y : V) : e (x + y) \u2264 e x + e y", "start": [116, 1], "end": [117, 20], "kind": "commanddeclaration"}, {"full_name": "ENorm.map_sub_le", "code": "theorem map_sub_le (x y : V) : e (x - y) \u2264 e x + e y", "start": [120, 1], "end": [124, 39], "kind": "commanddeclaration"}, {"full_name": "ENorm.partialOrder", "code": "instance partialOrder : PartialOrder (ENorm \ud835\udd5c V) where\n  le e\u2081 e\u2082 := \u2200 x, e\u2081 x \u2264 e\u2082 x\n  le_refl e x := le_rfl\n  le_trans e\u2081 e\u2082 e\u2083 h\u2081\u2082 h\u2082\u2083 x := le_trans (h\u2081\u2082 x) (h\u2082\u2083 x)\n  le_antisymm e\u2081 e\u2082 h\u2081\u2082 h\u2082\u2081 := ext fun x => le_antisymm (h\u2081\u2082 x) (h\u2082\u2081 x)", "start": [127, 1], "end": [131, 72], "kind": "commanddeclaration"}, {"full_name": "ENorm.top_map", "code": "theorem top_map {x : V} (hx : x \u2260 0) : (\u22a4 : ENorm \ud835\udd5c V) x = \u22a4", "start": [153, 1], "end": [154, 12], "kind": "commanddeclaration"}, {"full_name": "ENorm.coe_max", "code": "@[simp, norm_cast]\ntheorem coe_max (e\u2081 e\u2082 : ENorm \ud835\udd5c V) : \u21d1(e\u2081 \u2294 e\u2082) = fun x => max (e\u2081 x) (e\u2082 x)", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "ENorm.max_map", "code": "@[norm_cast]\ntheorem max_map (e\u2081 e\u2082 : ENorm \ud835\udd5c V) (x : V) : (e\u2081 \u2294 e\u2082) x = max (e\u2081 x) (e\u2082 x)", "start": [181, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "ENorm.emetricSpace", "code": "@[reducible]\ndef emetricSpace : EMetricSpace V where\n  edist x y := e (x - y)\n  edist_self x := by simp\n  eq_of_edist_eq_zero {x y} := by simp [sub_eq_zero]\n  edist_comm := e.map_sub_rev\n  edist_triangle x y z :=\n    calc\n      e (x - z) = e (x - y + (y - z)) := by rw [sub_add_sub_cancel]\n      _ \u2264 e (x - y) + e (y - z) := e.map_add_le (x - y) (y - z)", "start": [186, 1], "end": [196, 64], "kind": "commanddeclaration"}, {"full_name": "ENorm.finiteSubspace", "code": "def finiteSubspace : Subspace \ud835\udd5c V where\n  carrier := { x | e x < \u22a4 }\n  zero_mem' := by simp\n  add_mem' {x y} hx hy := lt_of_le_of_lt (e.map_add_le x y) (ENNReal.add_lt_top.2 \u27e8hx, hy\u27e9)\n  smul_mem' c x (hx : _ < _) :=\n    calc\n      e (c \u2022 x) = \u2016c\u2016\u208a * e x := e.map_smul c x\n      _ < \u22a4 := ENNReal.mul_lt_top ENNReal.coe_ne_top hx.ne", "start": [199, 1], "end": [207, 59], "kind": "commanddeclaration"}, {"full_name": "ENorm.metricSpace", "code": "instance metricSpace : MetricSpace e.finiteSubspace := by\n  letI := e.emetricSpace\n  refine' EMetricSpace.toMetricSpace fun x y => _\n  change e (x - y) \u2260 \u22a4\n  exact ne_top_of_le_ne_top (ENNReal.add_lt_top.2 \u27e8x.2, y.2\u27e9).ne (e.map_sub_le x y)", "start": [210, 1], "end": [216, 84], "kind": "commanddeclaration"}, {"full_name": "ENorm.finite_dist_eq", "code": "theorem finite_dist_eq (x y : e.finiteSubspace) : dist x y = (e (x - y)).toReal", "start": [218, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "ENorm.finite_edist_eq", "code": "theorem finite_edist_eq (x y : e.finiteSubspace) : edist x y = e (x - y)", "start": [222, 1], "end": [223, 6], "kind": "commanddeclaration"}, {"full_name": "ENorm.normedAddCommGroup", "code": "instance normedAddCommGroup : NormedAddCommGroup e.finiteSubspace :=\n  { e.metricSpace with\n    norm := fun x => (e x).toReal\n    dist_eq := fun _ _ => rfl }", "start": [226, 1], "end": [230, 32], "kind": "commanddeclaration"}, {"full_name": "ENorm.finite_norm_eq", "code": "theorem finite_norm_eq (x : e.finiteSubspace) : \u2016x\u2016 = (e x).toReal", "start": [232, 1], "end": [233, 6], "kind": "commanddeclaration"}, {"full_name": "ENorm.normedSpace", "code": "instance normedSpace : NormedSpace \ud835\udd5c e.finiteSubspace where\n  norm_smul_le c x := le_of_eq <| by simp [finite_norm_eq, ENNReal.toReal_mul]", "start": [236, 1], "end": [238, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Hyperoperation.lean", "imports": ["Mathlib/Tactic/Ring.lean", "Mathlib/Data/Nat/Parity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "hyperoperation", "code": "def hyperoperation : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 \u2115\n  | 0, _, k => k + 1\n  | 1, m, 0 => m\n  | 2, _, 0 => 0\n  | _ + 3, _, 0 => 1\n  | n + 1, m, k + 1 => hyperoperation n m (hyperoperation (n + 1) m k)\n  termination_by hyperoperation a b c => (a, b, c)", "start": [32, 1], "end": [42, 51], "kind": "commanddeclaration"}, {"full_name": "hyperoperation_zero", "code": "@[simp]\ntheorem hyperoperation_zero (m : \u2115) : hyperoperation 0 m = Nat.succ", "start": [46, 1], "end": [48, 62], "kind": "commanddeclaration"}, {"full_name": "hyperoperation_ge_three_eq_one", "code": "theorem hyperoperation_ge_three_eq_one (n m : \u2115) : hyperoperation (n + 3) m 0 = 1", "start": [51, 1], "end": [52, 22], "kind": "commanddeclaration"}, {"full_name": "hyperoperation_recursion", "code": "theorem hyperoperation_recursion (n m k : \u2115) :\n    hyperoperation (n + 1) m (k + 1) = hyperoperation n m (hyperoperation (n + 1) m k)", "start": [55, 1], "end": [57, 22], "kind": "commanddeclaration"}, {"full_name": "hyperoperation_one", "code": "@[simp]\ntheorem hyperoperation_one : hyperoperation 1 = (\u00b7 + \u00b7)", "start": [61, 1], "end": [67, 31], "kind": "commanddeclaration"}, {"full_name": "hyperoperation_two", "code": "@[simp]\ntheorem hyperoperation_two : hyperoperation 2 = (\u00b7 * \u00b7)", "start": [70, 1], "end": [80, 50], "kind": "commanddeclaration"}, {"full_name": "hyperoperation_three", "code": "@[simp]\ntheorem hyperoperation_three : hyperoperation 3 = (\u00b7 ^ \u00b7)", "start": [83, 1], "end": [90, 31], "kind": "commanddeclaration"}, {"full_name": "hyperoperation_ge_two_eq_self", "code": "theorem hyperoperation_ge_two_eq_self (n m : \u2115) : hyperoperation (n + 2) m 1 = m", "start": [93, 1], "end": [97, 71], "kind": "commanddeclaration"}, {"full_name": "hyperoperation_two_two_eq_four", "code": "theorem hyperoperation_two_two_eq_four (n : \u2115) : hyperoperation (n + 1) 2 2 = 4", "start": [100, 1], "end": [103, 70], "kind": "commanddeclaration"}, {"full_name": "hyperoperation_ge_three_one", "code": "theorem hyperoperation_ge_three_one (n : \u2115) : \u2200 k : \u2115, hyperoperation (n + 3) 1 k = 1", "start": [106, 1], "end": [115, 41], "kind": "commanddeclaration"}, {"full_name": "hyperoperation_ge_four_zero", "code": "theorem hyperoperation_ge_four_zero (n k : \u2115) :\n    hyperoperation (n + 4) 0 k = if Even k then 1 else 0", "start": [118, 1], "end": [128, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Erased.lean", "imports": ["Mathlib/Logic/Equiv/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Erased", "code": "def Erased (\u03b1 : Sort u) : Sort max 1 u :=\n  \u03a3's : \u03b1 \u2192 Prop, \u2203 a, (fun b => a = b) = s", "start": [21, 1], "end": [26, 44], "kind": "commanddeclaration"}, {"full_name": "Erased.mk", "code": "@[inline]\ndef mk {\u03b1} (a : \u03b1) : Erased \u03b1 :=\n  \u27e8fun b => a = b, a, rfl\u27e9", "start": [31, 1], "end": [34, 27], "kind": "commanddeclaration"}, {"full_name": "Erased.out", "code": "noncomputable def out {\u03b1} : Erased \u03b1 \u2192 \u03b1\n  | \u27e8_, h\u27e9 => Classical.choose h", "start": [37, 1], "end": [39, 33], "kind": "commanddeclaration"}, {"full_name": "Erased.OutType", "code": "@[reducible]\ndef OutType (a : Erased (Sort u)) : Sort u :=\n  out a", "start": [42, 1], "end": [48, 8], "kind": "commanddeclaration"}, {"full_name": "Erased.out_proof", "code": "theorem out_proof {p : Prop} (a : Erased p) : p", "start": [51, 1], "end": [53, 8], "kind": "commanddeclaration"}, {"full_name": "Erased.out_mk", "code": "@[simp]\ntheorem out_mk {\u03b1} (a : \u03b1) : (mk a).out = a", "start": [56, 1], "end": [60, 41], "kind": "commanddeclaration"}, {"full_name": "Erased.mk_out", "code": "@[simp]\ntheorem mk_out {\u03b1} : \u2200 a : Erased \u03b1, mk (out a) = a", "start": [63, 1], "end": [65, 65], "kind": "commanddeclaration"}, {"full_name": "Erased.out_inj", "code": "@[ext]\ntheorem out_inj {\u03b1} (a b : Erased \u03b1) (h : a.out = b.out) : a = b", "start": [68, 1], "end": [69, 98], "kind": "commanddeclaration"}, {"full_name": "Erased.equiv", "code": "noncomputable def equiv (\u03b1) : Erased \u03b1 \u2243 \u03b1 :=\n  \u27e8out, mk, mk_out, out_mk\u27e9", "start": [72, 1], "end": [74, 28], "kind": "commanddeclaration"}, {"full_name": "Erased.choice", "code": "def choice {\u03b1} (h : Nonempty \u03b1) : Erased \u03b1 :=\n  mk (Classical.choice h)", "start": [85, 1], "end": [87, 26], "kind": "commanddeclaration"}, {"full_name": "Erased.nonempty_iff", "code": "@[simp]\ntheorem nonempty_iff {\u03b1} : Nonempty (Erased \u03b1) \u2194 Nonempty \u03b1", "start": [90, 1], "end": [92, 42], "kind": "commanddeclaration"}, {"full_name": "Erased.bind", "code": "def bind {\u03b1 \u03b2} (a : Erased \u03b1) (f : \u03b1 \u2192 Erased \u03b2) : Erased \u03b2 :=\n  \u27e8fun b => (f a.out).1 b, (f a.out).2\u27e9", "start": [98, 1], "end": [104, 40], "kind": "commanddeclaration"}, {"full_name": "Erased.bind_eq_out", "code": "@[simp]\ntheorem bind_eq_out {\u03b1 \u03b2} (a f) : @bind \u03b1 \u03b2 a f = f a.out", "start": [107, 1], "end": [108, 65], "kind": "commanddeclaration"}, {"full_name": "Erased.join", "code": "def join {\u03b1} (a : Erased (Erased \u03b1)) : Erased \u03b1 :=\n  bind a id", "start": [111, 1], "end": [114, 12], "kind": "commanddeclaration"}, {"full_name": "Erased.join_eq_out", "code": "@[simp]\ntheorem join_eq_out {\u03b1} (a) : @join \u03b1 a = a.out", "start": [117, 1], "end": [119, 18], "kind": "commanddeclaration"}, {"full_name": "Erased.map", "code": "def map {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (a : Erased \u03b1) : Erased \u03b2 :=\n  bind a (mk \u2218 f)", "start": [122, 1], "end": [128, 18], "kind": "commanddeclaration"}, {"full_name": "Erased.map_out", "code": "@[simp]\ntheorem map_out {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} (a : Erased \u03b1) : (a.map f).out = f a.out", "start": [131, 1], "end": [132, 92], "kind": "commanddeclaration"}, {"full_name": "Erased.Monad", "code": "protected instance Monad : Monad Erased where\n  pure := @mk\n  bind := @bind\n  map := @map", "start": [135, 1], "end": [138, 14], "kind": "commanddeclaration"}, {"full_name": "Erased.pure_def", "code": "@[simp]\ntheorem pure_def {\u03b1} : (pure : \u03b1 \u2192 Erased \u03b1) = @mk _", "start": [141, 1], "end": [143, 6], "kind": "commanddeclaration"}, {"full_name": "Erased.bind_def", "code": "@[simp]\ntheorem bind_def {\u03b1 \u03b2} : ((\u00b7 >>= \u00b7) : Erased \u03b1 \u2192 (\u03b1 \u2192 Erased \u03b2) \u2192 Erased \u03b2) = @bind _ _", "start": [146, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "Erased.map_def", "code": "@[simp]\ntheorem map_def {\u03b1 \u03b2} : ((\u00b7 <$> \u00b7) : (\u03b1 \u2192 \u03b2) \u2192 Erased \u03b1 \u2192 Erased \u03b2) = @map _ _", "start": [151, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "Erased.LawfulMonad", "code": "protected instance LawfulMonad : LawfulMonad Erased :=\n  { Erased.Monad with\n    id_map := by intros; ext; simp\n    map_const := by intros; ext; simp [Functor.mapConst]\n    pure_bind := by intros; ext; simp\n    bind_assoc := by intros; ext; simp\n    bind_pure_comp := by intros; ext; simp\n    bind_map := by intros; ext; simp [Seq.seq]\n    seqLeft_eq := by intros; ext; simp [Seq.seq, Functor.mapConst, SeqLeft.seqLeft]\n    seqRight_eq := by intros; ext; simp [Seq.seq, Functor.mapConst, SeqRight.seqRight]\n    pure_seq := by intros; ext; simp [Seq.seq, Functor.mapConst, SeqRight.seqRight] }", "start": [157, 1], "end": [167, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/CountableSeparatingOn.lean", "imports": ["Mathlib/Order/Filter/CountableSeparatingOn.lean", "Mathlib/Topology/Separation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/LinearAlgebra/CrossProduct.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Determinant.lean", "Mathlib/LinearAlgebra/BilinearMap.lean", "Mathlib/Data/Matrix/Notation.lean", "Mathlib/Algebra/Lie/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "crossProduct", "code": "def crossProduct : (Fin 3 \u2192 R) \u2192\u2097[R] (Fin 3 \u2192 R) \u2192\u2097[R] Fin 3 \u2192 R := by\n  apply LinearMap.mk\u2082 R fun a b : Fin 3 \u2192 R =>\n      ![a 1 * b 2 - a 2 * b 1, a 2 * b 0 - a 0 * b 2, a 0 * b 1 - a 1 * b 0]\n  \u00b7 intros\n    simp_rw [vec3_add, Pi.add_apply]\n    apply vec3_eq <;> ring\n  \u00b7 intros\n    simp_rw [smul_vec3, Pi.smul_apply, smul_sub, smul_mul_assoc]\n  \u00b7 intros\n    simp_rw [vec3_add, Pi.add_apply]\n    apply vec3_eq <;> ring\n  \u00b7 intros\n    simp_rw [smul_vec3, Pi.smul_apply, smul_sub, mul_smul_comm]", "start": [47, 1], "end": [60, 64], "kind": "commanddeclaration"}, {"full_name": "cross_apply", "code": "theorem cross_apply (a b : Fin 3 \u2192 R) :\n    a \u00d7\u2083 b = ![a 1 * b 2 - a 2 * b 1, a 2 * b 0 - a 0 * b 2, a 0 * b 1 - a 1 * b 0]", "start": [65, 1], "end": [66, 91], "kind": "commanddeclaration"}, {"full_name": "cross_anticomm", "code": "@[simp]\ntheorem cross_anticomm (v w : Fin 3 \u2192 R) : -(v \u00d7\u2083 w) = w \u00d7\u2083 v", "start": [71, 1], "end": [73, 31], "kind": "commanddeclaration"}, {"full_name": "neg_cross", "code": "alias neg_cross := cross_anticomm", "start": [76, 1], "end": [76, 34], "kind": "stdtacticaliasalias"}, {"full_name": "cross_anticomm'", "code": "@[simp]\ntheorem cross_anticomm' (v w : Fin 3 \u2192 R) : v \u00d7\u2083 w + w \u00d7\u2083 v = 0", "start": [79, 1], "end": [81, 46], "kind": "commanddeclaration"}, {"full_name": "cross_self", "code": "@[simp]\ntheorem cross_self (v : Fin 3 \u2192 R) : v \u00d7\u2083 v = 0", "start": [84, 1], "end": [88, 62], "kind": "commanddeclaration"}, {"full_name": "dot_self_cross", "code": "@[simp 1100] theorem dot_self_cross (v w : Fin 3 \u2192 R) : v \u2b1d\u1d65 v \u00d7\u2083 w = 0", "start": [91, 1], "end": [96, 7], "kind": "commanddeclaration"}, {"full_name": "dot_cross_self", "code": "@[simp 1100] theorem dot_cross_self (v w : Fin 3 \u2192 R) : w \u2b1d\u1d65 v \u00d7\u2083 w = 0", "start": [99, 1], "end": [102, 73], "kind": "commanddeclaration"}, {"full_name": "triple_product_permutation", "code": "theorem triple_product_permutation (u v w : Fin 3 \u2192 R) : u \u2b1d\u1d65 v \u00d7\u2083 w = v \u2b1d\u1d65 w \u00d7\u2083 u", "start": [105, 1], "end": [109, 7], "kind": "commanddeclaration"}, {"full_name": "triple_product_eq_det", "code": "theorem triple_product_eq_det (u v w : Fin 3 \u2192 R) : u \u2b1d\u1d65 v \u00d7\u2083 w = Matrix.det ![u, v, w]", "start": [112, 1], "end": [117, 7], "kind": "commanddeclaration"}, {"full_name": "cross_dot_cross", "code": "theorem cross_dot_cross (u v w x : Fin 3 \u2192 R) :\n    u \u00d7\u2083 v \u2b1d\u1d65 w \u00d7\u2083 x = u \u2b1d\u1d65 w * v \u2b1d\u1d65 x - u \u2b1d\u1d65 x * v \u2b1d\u1d65 w", "start": [120, 1], "end": [125, 7], "kind": "commanddeclaration"}, {"full_name": "leibniz_cross", "code": "theorem leibniz_cross (u v w : Fin 3 \u2192 R) : u \u00d7\u2083 (v \u00d7\u2083 w) = u \u00d7\u2083 v \u00d7\u2083 w + v \u00d7\u2083 (u \u00d7\u2083 w)", "start": [132, 1], "end": [135, 38], "kind": "commanddeclaration"}, {"full_name": "Cross.lieRing", "code": "def Cross.lieRing : LieRing (Fin 3 \u2192 R) :=\n  { Pi.addCommGroup with\n    bracket := fun u v => u \u00d7\u2083 v\n    add_lie := LinearMap.map_add\u2082 _\n    lie_add := fun _ => LinearMap.map_add _\n    lie_self := cross_self\n    leibniz_lie := leibniz_cross }", "start": [138, 1], "end": [147, 35], "kind": "commanddeclaration"}, {"full_name": "cross_cross", "code": "theorem cross_cross (u v w : Fin 3 \u2192 R) : u \u00d7\u2083 v \u00d7\u2083 w = u \u00d7\u2083 (v \u00d7\u2083 w) - v \u00d7\u2083 (u \u00d7\u2083 w)", "start": [152, 1], "end": [153, 16], "kind": "commanddeclaration"}, {"full_name": "jacobi_cross", "code": "theorem jacobi_cross (u v w : Fin 3 \u2192 R) : u \u00d7\u2083 (v \u00d7\u2083 w) + v \u00d7\u2083 (w \u00d7\u2083 u) + w \u00d7\u2083 (u \u00d7\u2083 v) = 0", "start": [156, 1], "end": [159, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Testing/SlimCheck/Functions.lean", "imports": ["Mathlib/Testing/SlimCheck/Testable.lean", "Mathlib/Data/Finsupp/ToDFinsupp.lean", "Mathlib/Data/List/Sigma.lean", "Mathlib/Testing/SlimCheck/Sampleable.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/LazyList.lean", "Mathlib/Data/Finsupp/Defs.lean", "Mathlib/Data/Int/Range.lean"], "premises": [{"full_name": "SlimCheck.TotalFunction", "code": "inductive TotalFunction (\u03b1 : Type u) (\u03b2 : Type v) : Type max u v\n  | withDefault : List (\u03a3 _ : \u03b1, \u03b2) \u2192 \u03b2 \u2192 TotalFunction \u03b1 \u03b2", "start": [59, 1], "end": [70, 60], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.inhabited", "code": "instance TotalFunction.inhabited [Inhabited \u03b2] : Inhabited (TotalFunction \u03b1 \u03b2) :=\n  \u27e8TotalFunction.withDefault \u2205 default\u27e9", "start": [74, 1], "end": [75, 40], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.comp", "code": "def comp {\u03b3 : Type w} (f : \u03b2 \u2192 \u03b3) : TotalFunction \u03b1 \u03b2 \u2192 TotalFunction \u03b1 \u03b3\n  | TotalFunction.withDefault m y => TotalFunction.withDefault\n    (m.map <| Sigma.map id <| fun _ => f) (f y)", "start": [81, 1], "end": [84, 48], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.apply", "code": "def apply [DecidableEq \u03b1] : TotalFunction \u03b1 \u03b2 \u2192 \u03b1 \u2192 \u03b2\n  | TotalFunction.withDefault m y, x => (m.dlookup x).getD y", "start": [86, 1], "end": [88, 61], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.reprAux", "code": "def reprAux [Repr \u03b1] [Repr \u03b2] (m : List (\u03a3 _ : \u03b1, \u03b2)) : String :=\n  String.join <|\n    Array.toList <| Array.qsort (lt := fun x y => x < y)\n      (m.map fun x => s!\"{(repr <| Sigma.fst x)} \u21a6 {repr <| Sigma.snd x}, \").toArray", "start": [91, 1], "end": [100, 85], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.repr", "code": "protected def repr [Repr \u03b1] [Repr \u03b2] : TotalFunction \u03b1 \u03b2 \u2192 String\n  | TotalFunction.withDefault m y => s!\"[{(reprAux m)}_ \u21a6 {repr y}]\"", "start": [103, 1], "end": [107, 69], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.List.toFinmap'", "code": "def List.toFinmap' (xs : List (\u03b1 \u00d7 \u03b2)) : List (\u03a3 _ : \u03b1, \u03b2) :=\n  xs.map Prod.toSigma", "start": [113, 1], "end": [115, 22], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.shrink", "code": "def shrink {\u03b1 \u03b2} [DecidableEq \u03b1] [Shrinkable \u03b1] [Shrinkable \u03b2] :\n    TotalFunction \u03b1 \u03b2 \u2192 List (TotalFunction \u03b1 \u03b2)\n  | \u27e8m, x\u27e9 => (Shrinkable.shrink (m, x)).map fun \u27e8m', x'\u27e9 => \u27e8List.dedupKeys m', x'\u27e9", "start": [136, 1], "end": [139, 85], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.Pi.sampleableExt", "code": "instance Pi.sampleableExt : SampleableExt (\u03b1 \u2192 \u03b2) where\n  proxy := TotalFunction \u03b1 (SampleableExt.proxy \u03b2)\n  interp f := SampleableExt.interp \u2218 f.apply\n  sample := do\n    let xs : List (_ \u00d7 _) \u2190 (SampleableExt.sample (\u03b1 := List (\u03b1 \u00d7 \u03b2)))\n    let \u27e8x\u27e9 \u2190 (ULiftable.up <|\n      SampleableExt.sample : Gen (ULift.{max u ub} (SampleableExt.proxy \u03b2)))\n    pure <| TotalFunction.withDefault (List.toFinmap' <| xs.map <|\n      Prod.map SampleableExt.interp id) x\n  shrink := { shrink := letI : Shrinkable \u03b1 := {}; TotalFunction.shrink }", "start": [144, 1], "end": [154, 74], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.zeroDefault", "code": "@[simp]\ndef zeroDefault : TotalFunction \u03b1 \u03b2 \u2192 TotalFunction \u03b1 \u03b2\n  | withDefault A _ => withDefault A 0", "start": [163, 1], "end": [166, 39], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.zeroDefaultSupp", "code": "@[simp]\ndef zeroDefaultSupp : TotalFunction \u03b1 \u03b2 \u2192 Finset \u03b1\n  | withDefault A _ =>\n    List.toFinset <| (A.dedupKeys.filter fun ab => Sigma.snd ab \u2260 0).map Sigma.fst", "start": [171, 1], "end": [175, 83], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.applyFinsupp", "code": "def applyFinsupp (tf : TotalFunction \u03b1 \u03b2) : \u03b1 \u2192\u2080 \u03b2 where\n  support := zeroDefaultSupp tf\n  toFun := tf.zeroDefault.apply\n  mem_support_toFun := by\n    intro a\n    rcases tf with \u27e8A, y\u27e9\n    simp only [apply, zeroDefaultSupp, List.mem_map, List.mem_filter, exists_and_right,\n      List.mem_toFinset, exists_eq_right, Sigma.exists, Ne.def, zeroDefault]\n    constructor\n    \u00b7 rintro \u27e8od, hval, hod\u27e9\n      have := List.mem_dlookup (List.nodupKeys_dedupKeys A) hval\n      rw [(_ : List.dlookup a A = od)]\n      \u00b7 simpa using hod\n      \u00b7 simpa [List.dlookup_dedupKeys, WithTop.some_eq_coe]\n    \u00b7 intro h\n      use (A.dlookup a).getD (0 : \u03b2)\n      rw [\u2190 List.dlookup_dedupKeys] at h \u22a2\n      simp only [h, \u2190 List.mem_dlookup_iff A.nodupKeys_dedupKeys, and_true_iff, not_false_iff,\n        Option.mem_def]\n      cases haA : List.dlookup a A.dedupKeys\n      \u00b7 simp [haA] at h\n      \u00b7 simp", "start": [178, 1], "end": [201, 13], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.Finsupp.sampleableExt", "code": "instance Finsupp.sampleableExt : SampleableExt (\u03b1 \u2192\u2080 \u03b2) where\n  proxy := TotalFunction \u03b1 (SampleableExt.proxy \u03b2)\n  interp := fun f => (f.comp SampleableExt.interp).applyFinsupp\n  sample := SampleableExt.sample (\u03b1 := \u03b1 \u2192 \u03b2)\n  shrink := { shrink := letI : Shrinkable \u03b1 := {}; TotalFunction.shrink }", "start": [206, 1], "end": [211, 74], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.DFinsupp.sampleableExt", "code": "instance DFinsupp.sampleableExt : SampleableExt (\u03a0\u2080 _ : \u03b1, \u03b2) where\n  proxy := TotalFunction \u03b1 (SampleableExt.proxy \u03b2)\n  interp := fun f => (f.comp SampleableExt.interp).applyFinsupp.toDFinsupp\n  sample := SampleableExt.sample (\u03b1 := \u03b1 \u2192 \u03b2)\n  shrink := { shrink := letI : Shrinkable \u03b1 := {}; TotalFunction.shrink }", "start": [215, 1], "end": [220, 74], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.PiPred.sampleableExt", "code": "instance (priority := 2000) PiPred.sampleableExt [SampleableExt (\u03b1 \u2192 Bool)] :\n    SampleableExt.{u + 1} (\u03b1 \u2192 Prop) where\n  proxy := proxy (\u03b1 \u2192 Bool)\n  interp m x := interp m x\n  sample := sample\n  shrink := SampleableExt.shrink", "start": [229, 1], "end": [234, 33], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TotalFunction.PiUncurry.sampleableExt", "code": "instance (priority := 2000) PiUncurry.sampleableExt [SampleableExt (\u03b1 \u00d7 \u03b2 \u2192 \u03b3)] :\n    SampleableExt.{imax (u + 1) (v + 1) w} (\u03b1 \u2192 \u03b2 \u2192 \u03b3) where\n  proxy := proxy (\u03b1 \u00d7 \u03b2 \u2192 \u03b3)\n  interp m x y := interp m (x, y)\n  sample := sample\n  shrink := SampleableExt.shrink", "start": [237, 1], "end": [242, 33], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction", "code": "inductive InjectiveFunction (\u03b1 : Type u) : Type u\n  | mapToSelf (xs : List (\u03a3 _ : \u03b1, \u03b1)) :\n      xs.map Sigma.fst ~ xs.map Sigma.snd \u2192 List.Nodup (xs.map Sigma.snd) \u2192 InjectiveFunction \u03b1", "start": [249, 1], "end": [261, 96], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.apply", "code": "def apply [DecidableEq \u03b1] : InjectiveFunction \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  | InjectiveFunction.mapToSelf m _ _, x => (m.dlookup x).getD x", "start": [270, 1], "end": [272, 65], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.repr", "code": "protected def repr [Repr \u03b1] : InjectiveFunction \u03b1 \u2192 String\n  | InjectiveFunction.mapToSelf m _ _ => s! \"[{TotalFunction.reprAux m}x \u21a6 x]\"", "start": [275, 1], "end": [281, 79], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.List.applyId", "code": "def List.applyId [DecidableEq \u03b1] (xs : List (\u03b1 \u00d7 \u03b1)) (x : \u03b1) : \u03b1 :=\n  ((xs.map Prod.toSigma).dlookup x).getD x", "start": [287, 1], "end": [290, 43], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.List.applyId_cons", "code": "@[simp]\ntheorem List.applyId_cons [DecidableEq \u03b1] (xs : List (\u03b1 \u00d7 \u03b1)) (x y z : \u03b1) :\n    List.applyId ((y, z)::xs) x = if y = x then z else List.applyId xs x", "start": [294, 1], "end": [298, 20], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.List.applyId_zip_eq", "code": "theorem List.applyId_zip_eq [DecidableEq \u03b1] {xs ys : List \u03b1} (h\u2080 : List.Nodup xs)\n    (h\u2081 : xs.length = ys.length) (x y : \u03b1) (i : \u2115) (h\u2082 : xs.get? i = some x) :\n    List.applyId.{u} (xs.zip ys) x = y \u2194 ys.get? i = some y", "start": [306, 1], "end": [326, 43], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.applyId_mem_iff", "code": "theorem applyId_mem_iff [DecidableEq \u03b1] {xs ys : List \u03b1} (h\u2080 : List.Nodup xs) (h\u2081 : xs ~ ys)\n    (x : \u03b1) : List.applyId.{u} (xs.zip ys) x \u2208 ys \u2194 x \u2208 xs", "start": [329, 1], "end": [360, 49], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.List.applyId_eq_self", "code": "theorem List.applyId_eq_self [DecidableEq \u03b1] {xs ys : List \u03b1} (x : \u03b1) :\n    x \u2209 xs \u2192 List.applyId.{u} (xs.zip ys) x = x", "start": [363, 1], "end": [371, 30], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.applyId_injective", "code": "theorem applyId_injective [DecidableEq \u03b1] {xs ys : List \u03b1} (h\u2080 : List.Nodup xs) (h\u2081 : xs ~ ys) :\n    Injective.{u + 1, u + 1} (List.applyId (xs.zip ys))", "start": [374, 1], "end": [398, 73], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.Perm.slice", "code": "def Perm.slice [DecidableEq \u03b1] (n m : \u2115) :\n    (\u03a3' xs ys : List \u03b1, xs ~ ys \u2227 ys.Nodup) \u2192 \u03a3' xs ys : List \u03b1, xs ~ ys \u2227 ys.Nodup\n  | \u27e8xs, ys, h, h'\u27e9 =>\n    let xs' := List.dropSlice n m xs\n    have h\u2080 : xs' ~ ys.inter xs' := List.Perm.dropSlice_inter _ _ h h'\n    \u27e8xs', ys.inter xs', h\u2080, h'.inter _\u27e9", "start": [405, 1], "end": [413, 40], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.sliceSizes", "code": "def sliceSizes : \u2115 \u2192 LazyList \u2115+\n  | n =>\n    if h : 0 < n then\n      have : n / 2 < n := Nat.div_lt_self h (by decide : 1 < 2)\n      LazyList.cons \u27e8_, h\u27e9 (sliceSizes <| n / 2)\n    else LazyList.nil", "start": [416, 1], "end": [424, 22], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.shrinkPerm", "code": "protected def shrinkPerm {\u03b1 : Type} [DecidableEq \u03b1] :\n    (\u03a3' xs ys : List \u03b1, xs ~ ys \u2227 ys.Nodup) \u2192 List (\u03a3' xs ys : List \u03b1, xs ~ ys \u2227 ys.Nodup)\n  | xs => do\n    let k := xs.1.length\n    let n \u2190 (sliceSizes k).toList\n    let i \u2190 List.finRange <| k / n\n    pure <| Perm.slice (i * n) n xs", "start": [427, 1], "end": [439, 36], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.shrink", "code": "protected def shrink {\u03b1 : Type} [DecidableEq \u03b1] :\n    InjectiveFunction \u03b1 \u2192 List (InjectiveFunction \u03b1)\n  | \u27e8xs, h\u2080, h\u2081\u27e9 => do\n    let \u27e8xs', ys', h\u2080, h\u2081\u27e9 \u2190 InjectiveFunction.shrinkPerm \u27e8_, _, h\u2080, h\u2081\u27e9\n    have h\u2083 : xs'.length \u2264 ys'.length := le_of_eq (List.Perm.length_eq h\u2080)\n    have h\u2084 : ys'.length \u2264 xs'.length := le_of_eq (List.Perm.length_eq h\u2080.symm)\n    pure\n      \u27e8(List.zip xs' ys').map Prod.toSigma,\n        by simp only [comp, List.map_fst_zip, List.map_snd_zip, *, Prod.fst_toSigma,\n          Prod.snd_toSigma, List.map_map],\n        by simp only [comp, List.map_snd_zip, *, Prod.snd_toSigma, List.map_map]\u27e9", "start": [448, 1], "end": [462, 82], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.mk", "code": "protected def mk (xs ys : List \u03b1) (h : xs ~ ys) (h' : ys.Nodup) : InjectiveFunction \u03b1 :=\n  have h\u2080 : xs.length \u2264 ys.length := le_of_eq h.length_eq\n  have h\u2081 : ys.length \u2264 xs.length := le_of_eq h.length_eq.symm\n  InjectiveFunction.mapToSelf (List.toFinmap' (xs.zip ys))\n    (by\n      simp only [List.toFinmap', comp, List.map_fst_zip, List.map_snd_zip, *, Prod.fst_toSigma,\n        Prod.snd_toSigma, List.map_map])\n    (by simp only [List.toFinmap', comp, List.map_snd_zip, *, Prod.snd_toSigma, List.map_map])", "start": [465, 1], "end": [473, 95], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.injective", "code": "protected theorem injective [DecidableEq \u03b1] (f : InjectiveFunction \u03b1) : Injective (apply f)", "start": [476, 1], "end": [494, 33], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.InjectiveFunction.PiInjective.sampleableExt", "code": "instance PiInjective.sampleableExt : SampleableExt { f : \u2124 \u2192 \u2124 // Function.Injective f } where\n  proxy := InjectiveFunction \u2124\n  interp f := \u27e8apply f, f.injective\u27e9\n  sample := do\n    let \u27e8sz\u27e9 \u2190 ULiftable.up Gen.getSize\n    let xs' := Int.range (-(2 * sz + 2)) (2 * sz + 2)\n    let ys \u2190 Gen.permutationOf xs'\n    have Hinj : Injective fun r : \u2115 => -(2 * sz + 2 : \u2124) + \u2191r := fun _x _y h =>\n        Int.ofNat.inj (add_right_injective _ h)\n    let r : InjectiveFunction \u2124 :=\n      InjectiveFunction.mk.{0} xs' ys.1 ys.2 (ys.2.nodup_iff.1 <| (List.nodup_range _).map Hinj)\n    pure r\n  shrink := {shrink := @InjectiveFunction.shrink \u2124 _ }", "start": [497, 1], "end": [509, 55], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Injective.testable", "code": "instance Injective.testable (f : \u03b1 \u2192 \u03b2)\n    [I : Testable (NamedBinder \"x\" <|\n      \u2200 x : \u03b1, NamedBinder \"y\" <| \u2200 y : \u03b1, NamedBinder \"H\" <| f x = f y \u2192 x = y)] :\n    Testable (Injective f) :=\n  I", "start": [516, 1], "end": [520, 4], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Monotone.testable", "code": "instance Monotone.testable [Preorder \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2)\n    [I : Testable (NamedBinder \"x\" <|\n      \u2200 x : \u03b1, NamedBinder \"y\" <| \u2200 y : \u03b1, NamedBinder \"H\" <| x \u2264 y \u2192 f x \u2264 f y)] :\n    Testable (Monotone f) :=\n  I", "start": [523, 1], "end": [527, 4], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Antitone.testable", "code": "instance Antitone.testable [Preorder \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2)\n    [I : Testable (NamedBinder \"x\" <|\n      \u2200 x : \u03b1, NamedBinder \"y\" <| \u2200 y : \u03b1, NamedBinder \"H\" <| x \u2264 y \u2192 f y \u2264 f x)] :\n    Testable (Antitone f) :=\n  I", "start": [530, 1], "end": [534, 4], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/TensorAlgebra/Grading.lean", "imports": ["Mathlib/RingTheory/GradedAlgebra/Basic.lean", "Mathlib/LinearAlgebra/TensorAlgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TensorAlgebra.GradedAlgebra.\u03b9", "code": "nonrec def GradedAlgebra.\u03b9 : M \u2192\u2097[R] \u2a01 i : \u2115, \u21a5(LinearMap.range (\u03b9 R : M \u2192\u2097[_] _) ^ i) :=\n  DirectSum.lof R \u2115 (fun i => \u21a5(LinearMap.range (\u03b9 R : M \u2192\u2097[_] _) ^ i)) 1 \u2218\u2097\n    (\u03b9 R).codRestrict _ fun m => by simpa only [pow_one] using LinearMap.mem_range_self _ m", "start": [27, 1], "end": [31, 92], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.GradedAlgebra.\u03b9_apply", "code": "theorem GradedAlgebra.\u03b9_apply (m : M) :\n    GradedAlgebra.\u03b9 R M m =\n      DirectSum.of (fun (i : \u2115) => \u21a5(LinearMap.range (TensorAlgebra.\u03b9 R : M \u2192\u2097[_] _) ^ i)) 1\n        \u27e8TensorAlgebra.\u03b9 R m, by simpa only [pow_one] using LinearMap.mem_range_self _ m\u27e9", "start": [34, 1], "end": [38, 6], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.gradedAlgebra", "code": "instance gradedAlgebra :\n    GradedAlgebra ((LinearMap.range (\u03b9 R : M \u2192\u2097[R] TensorAlgebra R M) ^ \u00b7) : \u2115 \u2192 Submodule R _) :=\n  GradedAlgebra.ofAlgHom _ (lift R <| GradedAlgebra.\u03b9 R M)\n    (by\n      ext m\n      dsimp only [LinearMap.comp_apply, AlgHom.toLinearMap_apply, AlgHom.comp_apply,\n        AlgHom.id_apply]\n      rw [lift_\u03b9_apply, GradedAlgebra.\u03b9_apply R M, DirectSum.coeAlgHom_of, Subtype.coe_mk])\n    fun i x => by\n    cases' x with x hx\n    dsimp only [Subtype.coe_mk, DirectSum.lof_eq_of]\n    induction hx using Submodule.pow_induction_on_left' with\n    | hr r =>\n      rw [AlgHom.commutes, DirectSum.algebraMap_apply]; rfl\n    | hadd x y i hx hy ihx ihy =>\n      rw [AlgHom.map_add, ihx, ihy, \u2190 map_add]; rfl\n    | hmul m hm i x hx ih =>\n      obtain \u27e8_, rfl\u27e9 := hm\n      rw [AlgHom.map_mul, ih, lift_\u03b9_apply, GradedAlgebra.\u03b9_apply R M, DirectSum.of_mul_of]\n      exact DirectSum.of_eq_of_gradedMonoid_eq (Sigma.subtype_ext (add_comm _ _) rfl)", "start": [43, 1], "end": [64, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Perm/Subgroup.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Finite.lean", "Mathlib/GroupTheory/Perm/Basic.lean", "Mathlib/Data/Fintype/Perm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Equiv.Perm.sumCongrHom.decidableMemRange", "code": "instance sumCongrHom.decidableMemRange {\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] [Fintype \u03b1]\n    [Fintype \u03b2] : DecidablePred (\u00b7 \u2208 (sumCongrHom \u03b1 \u03b2).range) := fun _ => inferInstance", "start": [32, 1], "end": [33, 88], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongrHom.card_range", "code": "@[simp]\ntheorem sumCongrHom.card_range {\u03b1 \u03b2 : Type*} [Fintype (sumCongrHom \u03b1 \u03b2).range]\n    [Fintype (Perm \u03b1 \u00d7 Perm \u03b2)] :\n    Fintype.card (sumCongrHom \u03b1 \u03b2).range = Fintype.card (Perm \u03b1 \u00d7 Perm \u03b2)", "start": [36, 1], "end": [40, 83], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sigmaCongrRightHom.decidableMemRange", "code": "instance sigmaCongrRightHom.decidableMemRange {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} [DecidableEq \u03b1]\n    [\u2200 a, DecidableEq (\u03b2 a)] [Fintype \u03b1] [\u2200 a, Fintype (\u03b2 a)] :\n    DecidablePred (\u00b7 \u2208 (sigmaCongrRightHom \u03b2).range) := fun _ => inferInstance", "start": [43, 1], "end": [45, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sigmaCongrRightHom.card_range", "code": "@[simp]\ntheorem sigmaCongrRightHom.card_range {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*}\n    [Fintype (sigmaCongrRightHom \u03b2).range] [Fintype (\u2200 a, Perm (\u03b2 a))] :\n    Fintype.card (sigmaCongrRightHom \u03b2).range = Fintype.card (\u2200 a, Perm (\u03b2 a))", "start": [48, 1], "end": [52, 95], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeCongrHom.decidableMemRange", "code": "instance subtypeCongrHom.decidableMemRange {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    [Fintype (Perm { a // p a } \u00d7 Perm { a // \u00acp a })] [DecidableEq (Perm \u03b1)] :\n    DecidablePred (\u00b7 \u2208 (subtypeCongrHom p).range) := fun _ => inferInstance", "start": [55, 1], "end": [57, 76], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeCongrHom.card_range", "code": "@[simp]\ntheorem subtypeCongrHom.card_range {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    [Fintype (subtypeCongrHom p).range] [Fintype (Perm { a // p a } \u00d7 Perm { a // \u00acp a })] :\n    Fintype.card (subtypeCongrHom p).range =\n      Fintype.card (Perm { a // p a } \u00d7 Perm { a // \u00acp a })", "start": [60, 1], "end": [65, 93], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subgroupOfMulAction", "code": "noncomputable def subgroupOfMulAction (G H : Type*) [Group G] [MulAction G H] [FaithfulSMul G H] :\n    G \u2243* (MulAction.toPermHom G H).range :=\n  MulEquiv.ofLeftInverse' _ (Classical.choose_spec MulAction.toPerm_injective.hasLeftInverse)", "start": [68, 1], "end": [73, 94], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Groupoid/FreeGroupoid.lean", "imports": ["Mathlib/CategoryTheory/Groupoid.lean", "Mathlib/Tactic/NthRewrite.lean", "Mathlib/CategoryTheory/Quotient.lean", "Mathlib/CategoryTheory/Category/Basic.lean", "Mathlib/Combinatorics/Quiver/Symmetric.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/PathCategory.lean", "Mathlib/CategoryTheory/Functor/Basic.lean"], "premises": [{"full_name": "Quiver.Hom.toPosPath", "code": "abbrev _root_.Quiver.Hom.toPosPath {X Y : V} (f : X \u27f6 Y) :\n    (CategoryTheory.Paths.categoryPaths <| Quiver.Symmetrify V).Hom X Y :=\n  f.toPos.toPath", "start": [55, 1], "end": [58, 17], "kind": "commanddeclaration"}, {"full_name": "Quiver.Hom.toNegPath", "code": "abbrev _root_.Quiver.Hom.toNegPath {X Y : V} (f : X \u27f6 Y) :\n    (CategoryTheory.Paths.categoryPaths <| Quiver.Symmetrify V).Hom Y X :=\n  f.toNeg.toPath", "start": [61, 1], "end": [64, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.Free.redStep", "code": "inductive redStep : HomRel (Paths (Quiver.Symmetrify V))\n  | step (X Z : Quiver.Symmetrify V) (f : X \u27f6 Z) :\n    redStep (\ud835\udfd9 (Paths.of.obj X)) (f.toPath \u226b (Quiver.reverse f).toPath)", "start": [67, 1], "end": [70, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FreeGroupoid", "code": "def _root_.CategoryTheory.FreeGroupoid (V) [Q : Quiver V] :=\n  Quotient (@redStep V Q)", "start": [73, 1], "end": [75, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.Free.congr_reverse", "code": "theorem congr_reverse {X Y : Paths <| Quiver.Symmetrify V} (p q : X \u27f6 Y) :\n    Quotient.CompClosure redStep p q \u2192 Quotient.CompClosure redStep p.reverse q.reverse", "start": [81, 1], "end": [90, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.Free.congr_comp_reverse", "code": "theorem congr_comp_reverse {X Y : Paths <| Quiver.Symmetrify V} (p : X \u27f6 Y) :\n    Quot.mk (@Quotient.CompClosure _ _ redStep _ _) (p \u226b p.reverse) =\n      Quot.mk (@Quotient.CompClosure _ _ redStep _ _) (\ud835\udfd9 X)", "start": [93, 1], "end": [117, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.Free.congr_reverse_comp", "code": "theorem congr_reverse_comp {X Y : Paths <| Quiver.Symmetrify V} (p : X \u27f6 Y) :\n    Quot.mk (@Quotient.CompClosure _ _ redStep _ _) (p.reverse \u226b p) =\n      Quot.mk (@Quotient.CompClosure _ _ redStep _ _) (\ud835\udfd9 Y)", "start": [120, 1], "end": [124, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.Free.quotInv", "code": "def quotInv {X Y : FreeGroupoid V} (f : X \u27f6 Y) : Y \u27f6 X :=\n  Quot.liftOn f (fun pp => Quot.mk _ <| pp.reverse) fun pp qq con =>\n    Quot.sound <| congr_reverse pp qq con", "start": [130, 1], "end": [133, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FreeGroupoid.instGroupoid", "code": "instance _root_.CategoryTheory.FreeGroupoid.instGroupoid : Groupoid (FreeGroupoid V) where\n  inv := quotInv\n  inv_comp p := Quot.inductionOn p fun pp => congr_reverse_comp pp\n  comp_inv p := Quot.inductionOn p fun pp => congr_comp_reverse pp", "start": [136, 1], "end": [139, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.Free.of", "code": "def of (V) [Quiver V] : V \u2964q FreeGroupoid V where\n  obj X := \u27e8X\u27e9\n  map f := Quot.mk _ f.toPosPath", "start": [142, 1], "end": [145, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.Free.of_eq", "code": "theorem of_eq :\n    of V = (Quiver.Symmetrify.of \u22d9q Paths.of).comp\n      (Quotient.functor <| @redStep V _).toPrefunctor", "start": [148, 1], "end": [150, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.Free.lift", "code": "def lift (\u03c6 : V \u2964q V') : FreeGroupoid V \u2964 V' :=\n  Quotient.lift _ (Paths.lift <| Quiver.Symmetrify.lift \u03c6) <| by\n    rintro _ _ _ _ \u27e8X, Y, f\u27e9\n    erw [Paths.lift_nil, Paths.lift_cons, Quiver.Path.comp_nil, Paths.lift_toPath,\n      Quiver.Symmetrify.lift_reverse]\n    symm\n    apply Groupoid.comp_inv", "start": [157, 1], "end": [165, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.Free.lift_spec", "code": "theorem lift_spec (\u03c6 : V \u2964q V') : of V \u22d9q (lift \u03c6).toPrefunctor = \u03c6", "start": [168, 1], "end": [171, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.Free.lift_unique", "code": "theorem lift_unique (\u03c6 : V \u2964q V') (\u03a6 : FreeGroupoid V \u2964 V') (h\u03a6 : of V \u22d9q \u03a6.toPrefunctor = \u03c6) :\n    \u03a6 = lift \u03c6", "start": [174, 1], "end": [186, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.freeGroupoidFunctor", "code": "def _root_.CategoryTheory.freeGroupoidFunctor (\u03c6 : V \u2964q V') : FreeGroupoid V \u2964 FreeGroupoid V' :=\n  lift (\u03c6 \u22d9q of V')", "start": [195, 1], "end": [197, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.Free.freeGroupoidFunctor_id", "code": "theorem freeGroupoidFunctor_id :\n    freeGroupoidFunctor (Prefunctor.id V) = Functor.id (FreeGroupoid V)", "start": [200, 1], "end": [203, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.Free.freeGroupoidFunctor_comp", "code": "theorem freeGroupoidFunctor_comp (\u03c6 : V \u2964q V') (\u03c6' : V' \u2964q V'') :\n    freeGroupoidFunctor (\u03c6 \u22d9q \u03c6') = freeGroupoidFunctor \u03c6 \u22d9 freeGroupoidFunctor \u03c6'", "start": [206, 1], "end": [209, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Bimod.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/Mon_.lean", "Mathlib/CategoryTheory/Bicategory/Basic.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Equalizers.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "id_tensor_\u03c0_preserves_coequalizer_inv_desc", "code": "theorem id_tensor_\u03c0_preserves_coequalizer_inv_desc {W X Y Z : C} (f g : X \u27f6 Y) (h : Z \u2297 Y \u27f6 W)\n    (wh : (\ud835\udfd9 Z \u2297 f) \u226b h = (\ud835\udfd9 Z \u2297 g) \u226b h) :\n    (\ud835\udfd9 Z \u2297 coequalizer.\u03c0 f g) \u226b\n        (PreservesCoequalizer.iso (tensorLeft Z) f g).inv \u226b coequalizer.desc h wh =\n      h", "start": [35, 1], "end": [40, 63], "kind": "commanddeclaration"}, {"full_name": "id_tensor_\u03c0_preserves_coequalizer_inv_colimMap_desc", "code": "theorem id_tensor_\u03c0_preserves_coequalizer_inv_colimMap_desc {X Y Z X' Y' Z' : C} (f g : X \u27f6 Y)\n    (f' g' : X' \u27f6 Y') (p : Z \u2297 X \u27f6 X') (q : Z \u2297 Y \u27f6 Y') (wf : (\ud835\udfd9 Z \u2297 f) \u226b q = p \u226b f')\n    (wg : (\ud835\udfd9 Z \u2297 g) \u226b q = p \u226b g') (h : Y' \u27f6 Z') (wh : f' \u226b h = g' \u226b h) :\n    (\ud835\udfd9 Z \u2297 coequalizer.\u03c0 f g) \u226b\n        (PreservesCoequalizer.iso (tensorLeft Z) f g).inv \u226b\n          colimMap (parallelPairHom (\ud835\udfd9 Z \u2297 f) (\ud835\udfd9 Z \u2297 g) f' g' p q wf wg) \u226b coequalizer.desc h wh =\n      q \u226b h", "start": [43, 1], "end": [50, 88], "kind": "commanddeclaration"}, {"full_name": "\u03c0_tensor_id_preserves_coequalizer_inv_desc", "code": "theorem \u03c0_tensor_id_preserves_coequalizer_inv_desc {W X Y Z : C} (f g : X \u27f6 Y) (h : Y \u2297 Z \u27f6 W)\n    (wh : (f \u2297 \ud835\udfd9 Z) \u226b h = (g \u2297 \ud835\udfd9 Z) \u226b h) :\n    (coequalizer.\u03c0 f g \u2297 \ud835\udfd9 Z) \u226b\n        (PreservesCoequalizer.iso (tensorRight Z) f g).inv \u226b coequalizer.desc h wh =\n      h", "start": [59, 1], "end": [64, 64], "kind": "commanddeclaration"}, {"full_name": "\u03c0_tensor_id_preserves_coequalizer_inv_colimMap_desc", "code": "theorem \u03c0_tensor_id_preserves_coequalizer_inv_colimMap_desc {X Y Z X' Y' Z' : C} (f g : X \u27f6 Y)\n    (f' g' : X' \u27f6 Y') (p : X \u2297 Z \u27f6 X') (q : Y \u2297 Z \u27f6 Y') (wf : (f \u2297 \ud835\udfd9 Z) \u226b q = p \u226b f')\n    (wg : (g \u2297 \ud835\udfd9 Z) \u226b q = p \u226b g') (h : Y' \u27f6 Z') (wh : f' \u226b h = g' \u226b h) :\n    (coequalizer.\u03c0 f g \u2297 \ud835\udfd9 Z) \u226b\n        (PreservesCoequalizer.iso (tensorRight Z) f g).inv \u226b\n          colimMap (parallelPairHom (f \u2297 \ud835\udfd9 Z) (g \u2297 \ud835\udfd9 Z) f' g' p q wf wg) \u226b coequalizer.desc h wh =\n      q \u226b h", "start": [67, 1], "end": [74, 89], "kind": "commanddeclaration"}, {"full_name": "Bimod", "code": "structure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X \u2297 X \u27f6 X\n  one_actLeft : (A.one \u2297 \ud835\udfd9 X) \u226b actLeft = (\u03bb_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul \u2297 \ud835\udfd9 X) \u226b actLeft = (\u03b1_ A.X A.X X).hom \u226b (\ud835\udfd9 A.X \u2297 actLeft) \u226b actLeft := by aesop_cat\n  actRight : X \u2297 B.X \u27f6 X\n  actRight_one : (\ud835\udfd9 X \u2297 B.one) \u226b actRight = (\u03c1_ X).hom := by aesop_cat\n  right_assoc :\n    (\ud835\udfd9 X \u2297 B.mul) \u226b actRight = (\u03b1_ X B.X B.X).inv \u226b (actRight \u2297 \ud835\udfd9 B.X) \u226b actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft \u2297 \ud835\udfd9 B.X) \u226b actRight = (\u03b1_ A.X X B.X).hom \u226b (\ud835\udfd9 A.X \u2297 actRight) \u226b actLeft := by\n    aesop_cat", "start": [81, 1], "end": [95, 14], "kind": "commanddeclaration"}, {"full_name": "Bimod.Hom", "code": "@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X \u27f6 N.X\n  left_act_hom : M.actLeft \u226b hom = (\ud835\udfd9 A.X \u2297 hom) \u226b N.actLeft := by aesop_cat\n  right_act_hom : M.actRight \u226b hom = (hom \u2297 \ud835\udfd9 B.X) \u226b N.actRight := by aesop_cat", "start": [106, 1], "end": [111, 80], "kind": "commanddeclaration"}, {"full_name": "Bimod.id'", "code": "@[simps]\ndef id' (M : Bimod A B) : Hom M M where hom := \ud835\udfd9 M.X", "start": [117, 1], "end": [119, 53], "kind": "commanddeclaration"}, {"full_name": "Bimod.homInhabited", "code": "instance homInhabited (M : Bimod A B) : Inhabited (Hom M M) :=\n  \u27e8id' M\u27e9", "start": [123, 1], "end": [124, 10], "kind": "commanddeclaration"}, {"full_name": "Bimod.comp", "code": "@[simps]\ndef comp {M N O : Bimod A B} (f : Hom M N) (g : Hom N O) : Hom M O where hom := f.hom \u226b g.hom", "start": [128, 1], "end": [130, 94], "kind": "commanddeclaration"}, {"full_name": "Bimod.hom_ext", "code": "@[ext]\nlemma hom_ext {M N : Bimod A B} (f g : M \u27f6 N) (h : f.hom = g.hom) : f = g :=\n  Hom.ext _ _ h", "start": [140, 1], "end": [142, 16], "kind": "mathlibtacticlemma"}, {"full_name": "Bimod.id_hom'", "code": "@[simp]\ntheorem id_hom' (M : Bimod A B) : (\ud835\udfd9 M : Hom M M).hom = \ud835\udfd9 M.X", "start": [144, 1], "end": [146, 6], "kind": "commanddeclaration"}, {"full_name": "Bimod.comp_hom'", "code": "@[simp]\ntheorem comp_hom' {M N K : Bimod A B} (f : M \u27f6 N) (g : N \u27f6 K) :\n    (f \u226b g : Hom M K).hom = f.hom \u226b g.hom", "start": [150, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "Bimod.isoOfIso", "code": "@[simps]\ndef isoOfIso {X Y : Mon_ C} {P Q : Bimod X Y} (f : P.X \u2245 Q.X)\n    (f_left_act_hom : P.actLeft \u226b f.hom = (\ud835\udfd9 X.X \u2297 f.hom) \u226b Q.actLeft)\n    (f_right_act_hom : P.actRight \u226b f.hom = (f.hom \u2297 \ud835\udfd9 Y.X) \u226b Q.actRight) : P \u2245 Q where\n  hom :=\n    { hom := f.hom }\n  inv :=\n    { hom := f.inv\n      left_act_hom := by\n        rw [\u2190 cancel_mono f.hom, Category.assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id,\n          f_left_act_hom, \u2190 Category.assoc, \u2190 id_tensor_comp, Iso.inv_hom_id,\n          MonoidalCategory.tensor_id, Category.id_comp]\n      right_act_hom := by\n        rw [\u2190 cancel_mono f.hom, Category.assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id,\n          f_right_act_hom, \u2190 Category.assoc, \u2190 comp_tensor_id, Iso.inv_hom_id,\n          MonoidalCategory.tensor_id, Category.id_comp] }\n  hom_inv_id := by ext; dsimp; rw [Iso.hom_inv_id]\n  inv_hom_id := by ext; dsimp; rw [Iso.inv_hom_id]", "start": [157, 1], "end": [177, 51], "kind": "commanddeclaration"}, {"full_name": "Bimod.regular", "code": "@[simps]\ndef regular : Bimod A A where\n  X := A.X\n  actLeft := A.mul\n  actRight := A.mul", "start": [183, 1], "end": [188, 20], "kind": "commanddeclaration"}, {"full_name": "Bimod.forget", "code": "def forget : Bimod A B \u2964 C where\n  obj A := A.X\n  map f := f.hom", "start": [195, 1], "end": [198, 17], "kind": "commanddeclaration"}, {"full_name": "Bimod.TensorBimod.X", "code": "noncomputable def X : C :=\n  coequalizer (P.actRight \u2297 \ud835\udfd9 Q.X) ((\u03b1_ _ _ _).hom \u226b (\ud835\udfd9 P.X \u2297 Q.actLeft))", "start": [210, 1], "end": [212, 74], "kind": "commanddeclaration"}, {"full_name": "Bimod.TensorBimod.actLeft", "code": "noncomputable def actLeft : R.X \u2297 X P Q \u27f6 X P Q :=\n  (PreservesCoequalizer.iso (tensorLeft R.X) _ _).inv \u226b\n    colimMap\n      (parallelPairHom _ _ _ _\n        ((\ud835\udfd9 _ \u2297 (\u03b1_ _ _ _).hom) \u226b (\u03b1_ _ _ _).inv \u226b (P.actLeft \u2297 \ud835\udfd9 S.X \u2297 \ud835\udfd9 Q.X) \u226b (\u03b1_ _ _ _).inv)\n        ((\u03b1_ _ _ _).inv \u226b (P.actLeft \u2297 \ud835\udfd9 Q.X))\n        (by\n          dsimp\n          slice_lhs 1 2 => rw [associator_inv_naturality]\n          slice_rhs 3 4 => rw [associator_inv_naturality]\n          slice_rhs 4 5 => rw [\u2190 tensor_comp, middle_assoc, tensor_comp, comp_tensor_id]\n          coherence)\n        (by\n          dsimp\n          slice_lhs 1 1 => rw [id_tensor_comp]\n          slice_lhs 2 3 => rw [associator_inv_naturality]\n          slice_lhs 3 4 => rw [tensor_id, id_tensor_comp_tensor_id]\n          slice_rhs 4 6 => rw [Iso.inv_hom_id_assoc]\n          slice_rhs 3 4 => rw [tensor_id, tensor_id_comp_id_tensor]))", "start": [220, 1], "end": [239, 70], "kind": "commanddeclaration"}, {"full_name": "Bimod.TensorBimod.id_tensor_\u03c0_actLeft", "code": "theorem id_tensor_\u03c0_actLeft :\n    (\ud835\udfd9 R.X \u2297 coequalizer.\u03c0 _ _) \u226b actLeft P Q =\n      (\u03b1_ _ _ _).inv \u226b (P.actLeft \u2297 \ud835\udfd9 Q.X) \u226b coequalizer.\u03c0 _ _", "start": [243, 1], "end": [247, 29], "kind": "commanddeclaration"}, {"full_name": "Bimod.TensorBimod.one_act_left'", "code": "theorem one_act_left' : (R.one \u2297 \ud835\udfd9 _) \u226b actLeft P Q = (\u03bb_ _).hom", "start": [251, 1], "end": [260, 12], "kind": "commanddeclaration"}, {"full_name": "Bimod.TensorBimod.left_assoc'", "code": "theorem left_assoc' :\n    (R.mul \u2297 \ud835\udfd9 _) \u226b actLeft P Q = (\u03b1_ R.X R.X _).hom \u226b (\ud835\udfd9 R.X \u2297 actLeft P Q) \u226b actLeft P Q", "start": [264, 1], "end": [277, 12], "kind": "commanddeclaration"}, {"full_name": "Bimod.TensorBimod.actRight", "code": "noncomputable def actRight : X P Q \u2297 T.X \u27f6 X P Q :=\n  (PreservesCoequalizer.iso (tensorRight T.X) _ _).inv \u226b\n    colimMap\n      (parallelPairHom _ _ _ _\n        ((\u03b1_ _ _ _).hom \u226b (\u03b1_ _ _ _).hom \u226b (\ud835\udfd9 P.X \u2297 \ud835\udfd9 S.X \u2297 Q.actRight) \u226b (\u03b1_ _ _ _).inv)\n        ((\u03b1_ _ _ _).hom \u226b (\ud835\udfd9 P.X \u2297 Q.actRight))\n        (by\n          dsimp\n          slice_lhs 1 2 => rw [associator_naturality]\n          slice_lhs 2 3 => rw [tensor_id, tensor_id_comp_id_tensor]\n          slice_rhs 3 4 => rw [associator_inv_naturality]\n          slice_rhs 2 4 => rw [Iso.hom_inv_id_assoc]\n          slice_rhs 2 3 => rw [tensor_id, id_tensor_comp_tensor_id])\n        (by\n          dsimp\n          slice_lhs 1 1 => rw [comp_tensor_id]\n          slice_lhs 2 3 => rw [associator_naturality]\n          slice_lhs 3 4 => rw [\u2190 id_tensor_comp, middle_assoc, id_tensor_comp]\n          slice_rhs 4 6 => rw [Iso.inv_hom_id_assoc]\n          slice_rhs 3 4 => rw [\u2190 id_tensor_comp]\n          coherence))", "start": [287, 1], "end": [308, 22], "kind": "commanddeclaration"}, {"full_name": "Bimod.TensorBimod.\u03c0_tensor_id_actRight", "code": "theorem \u03c0_tensor_id_actRight :\n    (coequalizer.\u03c0 _ _ \u2297 \ud835\udfd9 T.X) \u226b actRight P Q =\n      (\u03b1_ _ _ _).hom \u226b (\ud835\udfd9 P.X \u2297 Q.actRight) \u226b coequalizer.\u03c0 _ _", "start": [312, 1], "end": [316, 29], "kind": "commanddeclaration"}, {"full_name": "Bimod.TensorBimod.actRight_one'", "code": "theorem actRight_one' : (\ud835\udfd9 _ \u2297 T.one) \u226b actRight P Q = (\u03c1_ _).hom", "start": [320, 1], "end": [329, 12], "kind": "commanddeclaration"}, {"full_name": "Bimod.TensorBimod.right_assoc'", "code": "theorem right_assoc' :\n    (\ud835\udfd9 _ \u2297 T.mul) \u226b actRight P Q =\n      (\u03b1_ _ T.X T.X).inv \u226b (actRight P Q \u2297 \ud835\udfd9 T.X) \u226b actRight P Q", "start": [333, 1], "end": [347, 12], "kind": "commanddeclaration"}, {"full_name": "Bimod.TensorBimod.middle_assoc'", "code": "theorem middle_assoc' :\n    (actLeft P Q \u2297 \ud835\udfd9 T.X) \u226b actRight P Q =\n      (\u03b1_ R.X _ T.X).hom \u226b (\ud835\udfd9 R.X \u2297 actRight P Q) \u226b actLeft P Q", "start": [359, 1], "end": [374, 12], "kind": "commanddeclaration"}, {"full_name": "Bimod.tensorBimod", "code": "@[simps]\nnoncomputable def tensorBimod {X Y Z : Mon_ C} (M : Bimod X Y) (N : Bimod Y Z) : Bimod X Z where\n  X := TensorBimod.X M N\n  actLeft := TensorBimod.actLeft M N\n  actRight := TensorBimod.actRight M N\n  one_actLeft := TensorBimod.one_act_left' M N\n  actRight_one := TensorBimod.actRight_one' M N\n  left_assoc := TensorBimod.left_assoc' M N\n  right_assoc := TensorBimod.right_assoc' M N\n  middle_assoc := TensorBimod.middle_assoc' M N", "start": [388, 1], "end": [398, 48], "kind": "commanddeclaration"}, {"full_name": "Bimod.tensorHom", "code": "@[simps]\nnoncomputable def tensorHom {X Y Z : Mon_ C} {M\u2081 M\u2082 : Bimod X Y} {N\u2081 N\u2082 : Bimod Y Z} (f : M\u2081 \u27f6 M\u2082)\n    (g : N\u2081 \u27f6 N\u2082) : M\u2081.tensorBimod N\u2081 \u27f6 M\u2082.tensorBimod N\u2082 where\n  hom :=\n    colimMap\n      (parallelPairHom _ _ _ _ ((f.hom \u2297 \ud835\udfd9 Y.X) \u2297 g.hom) (f.hom \u2297 g.hom)\n        (by\n          rw [\u2190 tensor_comp, \u2190 tensor_comp, Hom.right_act_hom, Category.id_comp, Category.comp_id])\n        (by\n          slice_lhs 2 3 => rw [\u2190 tensor_comp, Hom.left_act_hom, Category.id_comp]\n          slice_rhs 1 2 => rw [associator_naturality]\n          slice_rhs 2 3 => rw [\u2190 tensor_comp, Category.comp_id]))\n  left_act_hom := by\n    refine' (cancel_epi ((tensorLeft _).map (coequalizer.\u03c0 _ _))).1 _\n    dsimp\n    slice_lhs 1 2 => rw [TensorBimod.id_tensor_\u03c0_actLeft]\n    slice_lhs 3 4 => rw [\u03b9_colimMap, parallelPairHom_app_one]\n    slice_lhs 2 3 => rw [\u2190 tensor_comp, Hom.left_act_hom, Category.id_comp]\n    slice_rhs 1 2 => rw [\u2190 id_tensor_comp, \u03b9_colimMap, parallelPairHom_app_one, id_tensor_comp]\n    slice_rhs 2 3 => rw [TensorBimod.id_tensor_\u03c0_actLeft]\n    slice_rhs 1 2 => rw [associator_inv_naturality]\n    slice_rhs 2 3 => rw [\u2190 tensor_comp, Category.comp_id]\n  right_act_hom := by\n    refine' (cancel_epi ((tensorRight _).map (coequalizer.\u03c0 _ _))).1 _\n    dsimp\n    slice_lhs 1 2 => rw [TensorBimod.\u03c0_tensor_id_actRight]\n    slice_lhs 3 4 => rw [\u03b9_colimMap, parallelPairHom_app_one]\n    slice_lhs 2 3 => rw [\u2190 tensor_comp, Category.id_comp, Hom.right_act_hom]\n    slice_rhs 1 2 => rw [\u2190 comp_tensor_id, \u03b9_colimMap, parallelPairHom_app_one, comp_tensor_id]\n    slice_rhs 2 3 => rw [TensorBimod.\u03c0_tensor_id_actRight]\n    slice_rhs 1 2 => rw [associator_naturality]\n    slice_rhs 2 3 => rw [\u2190 tensor_comp, Category.comp_id]", "start": [402, 1], "end": [434, 58], "kind": "commanddeclaration"}, {"full_name": "Bimod.tensor_id", "code": "theorem tensor_id {X Y Z : Mon_ C} {M : Bimod X Y} {N : Bimod Y Z} :\n    tensorHom (\ud835\udfd9 M) (\ud835\udfd9 N) = \ud835\udfd9 (M.tensorBimod N)", "start": [438, 1], "end": [445, 49], "kind": "commanddeclaration"}, {"full_name": "Bimod.tensor_comp", "code": "theorem tensor_comp {X Y Z : Mon_ C} {M\u2081 M\u2082 M\u2083 : Bimod X Y} {N\u2081 N\u2082 N\u2083 : Bimod Y Z} (f\u2081 : M\u2081 \u27f6 M\u2082)\n    (f\u2082 : M\u2082 \u27f6 M\u2083) (g\u2081 : N\u2081 \u27f6 N\u2082) (g\u2082 : N\u2082 \u27f6 N\u2083) :\n    tensorHom (f\u2081 \u226b f\u2082) (g\u2081 \u226b g\u2082) = tensorHom f\u2081 g\u2081 \u226b tensorHom f\u2082 g\u2082", "start": [449, 1], "end": [455, 75], "kind": "commanddeclaration"}, {"full_name": "Bimod.AssociatorBimod.homAux", "code": "noncomputable def homAux : (P.tensorBimod Q).X \u2297 L.X \u27f6 (P.tensorBimod (Q.tensorBimod L)).X :=\n  (PreservesCoequalizer.iso (tensorRight L.X) _ _).inv \u226b\n    coequalizer.desc ((\u03b1_ _ _ _).hom \u226b (\ud835\udfd9 P.X \u2297 coequalizer.\u03c0 _ _) \u226b coequalizer.\u03c0 _ _)\n      (by\n        dsimp; dsimp [TensorBimod.X]\n        slice_lhs 1 2 => rw [associator_naturality]\n        slice_lhs 2 3 =>\n          rw [MonoidalCategory.tensor_id, tensor_id_comp_id_tensor, \u2190 id_tensor_comp_tensor_id]\n        slice_lhs 3 4 => rw [coequalizer.condition]\n        slice_lhs 2 3 => rw [\u2190 MonoidalCategory.tensor_id, associator_naturality]\n        slice_lhs 3 4 => rw [\u2190 id_tensor_comp, TensorBimod.id_tensor_\u03c0_actLeft, id_tensor_comp]\n        slice_rhs 1 1 => rw [comp_tensor_id]\n        slice_rhs 2 3 => rw [associator_naturality]\n        slice_rhs 3 4 => rw [\u2190 id_tensor_comp]\n        coherence)", "start": [469, 1], "end": [485, 19], "kind": "commanddeclaration"}, {"full_name": "Bimod.AssociatorBimod.hom", "code": "noncomputable def hom :\n    ((P.tensorBimod Q).tensorBimod L).X \u27f6 (P.tensorBimod (Q.tensorBimod L)).X :=\n  coequalizer.desc (homAux P Q L)\n    (by\n      dsimp [homAux]\n      refine' (cancel_epi ((tensorRight _ \u22d9 tensorRight _).map (coequalizer.\u03c0 _ _))).1 _\n      dsimp [TensorBimod.X]\n      slice_lhs 1 2 =>\n        rw [\u2190 comp_tensor_id, TensorBimod.\u03c0_tensor_id_actRight, comp_tensor_id, comp_tensor_id]\n      slice_lhs 3 5 => rw [\u03c0_tensor_id_preserves_coequalizer_inv_desc]\n      slice_lhs 2 3 => rw [associator_naturality]\n      slice_lhs 3 4 => rw [\u2190 id_tensor_comp, coequalizer.condition, id_tensor_comp, id_tensor_comp]\n      slice_rhs 1 2 => rw [associator_naturality]\n      slice_rhs 2 3 =>\n        rw [MonoidalCategory.tensor_id, tensor_id_comp_id_tensor, \u2190 id_tensor_comp_tensor_id]\n      slice_rhs 3 5 => rw [\u03c0_tensor_id_preserves_coequalizer_inv_desc]\n      slice_rhs 2 3 => rw [\u2190 MonoidalCategory.tensor_id, associator_naturality]\n      coherence)", "start": [489, 1], "end": [507, 17], "kind": "commanddeclaration"}, {"full_name": "Bimod.AssociatorBimod.hom_left_act_hom'", "code": "theorem hom_left_act_hom' :\n    ((P.tensorBimod Q).tensorBimod L).actLeft \u226b hom P Q L =\n      (\ud835\udfd9 R.X \u2297 hom P Q L) \u226b (P.tensorBimod (Q.tensorBimod L)).actLeft", "start": [511, 1], "end": [534, 12], "kind": "commanddeclaration"}, {"full_name": "Bimod.AssociatorBimod.hom_right_act_hom'", "code": "theorem hom_right_act_hom' :\n    ((P.tensorBimod Q).tensorBimod L).actRight \u226b hom P Q L =\n      (hom P Q L \u2297 \ud835\udfd9 U.X) \u226b (P.tensorBimod (Q.tensorBimod L)).actRight", "start": [538, 1], "end": [562, 12], "kind": "commanddeclaration"}, {"full_name": "Bimod.AssociatorBimod.invAux", "code": "noncomputable def invAux : P.X \u2297 (Q.tensorBimod L).X \u27f6 ((P.tensorBimod Q).tensorBimod L).X :=\n  (PreservesCoequalizer.iso (tensorLeft P.X) _ _).inv \u226b\n    coequalizer.desc ((\u03b1_ _ _ _).inv \u226b (coequalizer.\u03c0 _ _ \u2297 \ud835\udfd9 L.X) \u226b coequalizer.\u03c0 _ _)\n      (by\n        dsimp; dsimp [TensorBimod.X]\n        slice_lhs 1 2 => rw [associator_inv_naturality]\n        rw [\u2190 Iso.inv_hom_id_assoc (\u03b1_ _ _ _) (\ud835\udfd9 P.X \u2297 Q.actRight), comp_tensor_id]\n        slice_lhs 3 4 =>\n          rw [\u2190 comp_tensor_id, Category.assoc, \u2190 TensorBimod.\u03c0_tensor_id_actRight,\n            comp_tensor_id]\n        slice_lhs 4 5 => rw [coequalizer.condition]\n        slice_lhs 3 4 => rw [associator_naturality]\n        slice_lhs 4 5 => rw [MonoidalCategory.tensor_id, tensor_id_comp_id_tensor]\n        slice_rhs 1 2 => rw [id_tensor_comp]\n        slice_rhs 2 3 => rw [associator_inv_naturality]\n        slice_rhs 3 4 => rw [MonoidalCategory.tensor_id, id_tensor_comp_tensor_id]\n        coherence)", "start": [566, 1], "end": [584, 19], "kind": "commanddeclaration"}, {"full_name": "Bimod.AssociatorBimod.inv", "code": "noncomputable def inv :\n    (P.tensorBimod (Q.tensorBimod L)).X \u27f6 ((P.tensorBimod Q).tensorBimod L).X :=\n  coequalizer.desc (invAux P Q L)\n    (by\n      dsimp [invAux]\n      refine' (cancel_epi ((tensorLeft _).map (coequalizer.\u03c0 _ _))).1 _\n      dsimp [TensorBimod.X]\n      slice_lhs 1 2 => rw [id_tensor_comp_tensor_id, \u2190 tensor_id_comp_id_tensor]\n      slice_lhs 2 4 => rw [id_tensor_\u03c0_preserves_coequalizer_inv_desc]\n      slice_lhs 1 2 => rw [\u2190 MonoidalCategory.tensor_id, associator_inv_naturality]\n      slice_lhs 2 3 => rw [\u2190 comp_tensor_id, coequalizer.condition, comp_tensor_id, comp_tensor_id]\n      slice_rhs 1 2 => rw [\u2190 MonoidalCategory.tensor_id, associator_naturality]\n      slice_rhs 2 3 =>\n        rw [\u2190 id_tensor_comp, TensorBimod.id_tensor_\u03c0_actLeft, id_tensor_comp, id_tensor_comp]\n      slice_rhs 4 6 => rw [id_tensor_\u03c0_preserves_coequalizer_inv_desc]\n      slice_rhs 3 4 => rw [associator_inv_naturality]\n      coherence)", "start": [588, 1], "end": [605, 17], "kind": "commanddeclaration"}, {"full_name": "Bimod.AssociatorBimod.hom_inv_id", "code": "theorem hom_inv_id : hom P Q L \u226b inv P Q L = \ud835\udfd9 _", "start": [609, 1], "end": [620, 41], "kind": "commanddeclaration"}, {"full_name": "Bimod.AssociatorBimod.inv_hom_id", "code": "theorem inv_hom_id : inv P Q L \u226b hom P Q L = \ud835\udfd9 _", "start": [624, 1], "end": [635, 41], "kind": "commanddeclaration"}, {"full_name": "Bimod.LeftUnitorBimod.hom", "code": "noncomputable def hom : TensorBimod.X (regular R) P \u27f6 P.X :=\n  coequalizer.desc P.actLeft (by dsimp; rw [Category.assoc, left_assoc])", "start": [645, 1], "end": [647, 73], "kind": "commanddeclaration"}, {"full_name": "Bimod.LeftUnitorBimod.inv", "code": "noncomputable def inv : P.X \u27f6 TensorBimod.X (regular R) P :=\n  (\u03bb_ P.X).inv \u226b (R.one \u2297 \ud835\udfd9 _) \u226b coequalizer.\u03c0 _ _", "start": [651, 1], "end": [653, 51], "kind": "commanddeclaration"}, {"full_name": "Bimod.LeftUnitorBimod.hom_inv_id", "code": "theorem hom_inv_id : hom P \u226b inv P = \ud835\udfd9 _", "start": [657, 1], "end": [668, 12], "kind": "commanddeclaration"}, {"full_name": "Bimod.LeftUnitorBimod.inv_hom_id", "code": "theorem inv_hom_id : inv P \u226b hom P = \ud835\udfd9 _", "start": [672, 1], "end": [675, 35], "kind": "commanddeclaration"}, {"full_name": "Bimod.LeftUnitorBimod.hom_left_act_hom'", "code": "theorem hom_left_act_hom' :\n    ((regular R).tensorBimod P).actLeft \u226b hom P = (\ud835\udfd9 R.X \u2297 hom P) \u226b P.actLeft", "start": [683, 1], "end": [691, 28], "kind": "commanddeclaration"}, {"full_name": "Bimod.LeftUnitorBimod.hom_right_act_hom'", "code": "theorem hom_right_act_hom' :\n    ((regular R).tensorBimod P).actRight \u226b hom P = (hom P \u2297 \ud835\udfd9 S.X) \u226b P.actRight", "start": [695, 1], "end": [703, 29], "kind": "commanddeclaration"}, {"full_name": "Bimod.RightUnitorBimod.hom", "code": "noncomputable def hom : TensorBimod.X P (regular S) \u27f6 P.X :=\n  coequalizer.desc P.actRight (by dsimp; rw [Category.assoc, right_assoc, Iso.hom_inv_id_assoc])", "start": [713, 1], "end": [715, 97], "kind": "commanddeclaration"}, {"full_name": "Bimod.RightUnitorBimod.inv", "code": "noncomputable def inv : P.X \u27f6 TensorBimod.X P (regular S) :=\n  (\u03c1_ P.X).inv \u226b (\ud835\udfd9 _ \u2297 S.one) \u226b coequalizer.\u03c0 _ _", "start": [719, 1], "end": [721, 51], "kind": "commanddeclaration"}, {"full_name": "Bimod.RightUnitorBimod.hom_inv_id", "code": "theorem hom_inv_id : hom P \u226b inv P = \ud835\udfd9 _", "start": [725, 1], "end": [735, 12], "kind": "commanddeclaration"}, {"full_name": "Bimod.RightUnitorBimod.inv_hom_id", "code": "theorem inv_hom_id : inv P \u226b hom P = \ud835\udfd9 _", "start": [739, 1], "end": [742, 36], "kind": "commanddeclaration"}, {"full_name": "Bimod.RightUnitorBimod.hom_left_act_hom'", "code": "theorem hom_left_act_hom' :\n    (P.tensorBimod (regular S)).actLeft \u226b hom P = (\ud835\udfd9 R.X \u2297 hom P) \u226b P.actLeft", "start": [750, 1], "end": [758, 28], "kind": "commanddeclaration"}, {"full_name": "Bimod.RightUnitorBimod.hom_right_act_hom'", "code": "theorem hom_right_act_hom' :\n    (P.tensorBimod (regular S)).actRight \u226b hom P = (hom P \u2297 \ud835\udfd9 S.X) \u226b P.actRight", "start": [762, 1], "end": [770, 28], "kind": "commanddeclaration"}, {"full_name": "Bimod.associatorBimod", "code": "noncomputable def associatorBimod {W X Y Z : Mon_ C} (L : Bimod W X) (M : Bimod X Y)\n    (N : Bimod Y Z) : (L.tensorBimod M).tensorBimod N \u2245 L.tensorBimod (M.tensorBimod N) :=\n  isoOfIso\n    { hom := AssociatorBimod.hom L M N\n      inv := AssociatorBimod.inv L M N\n      hom_inv_id := AssociatorBimod.hom_inv_id L M N\n      inv_hom_id := AssociatorBimod.inv_hom_id L M N } (AssociatorBimod.hom_left_act_hom' L M N)\n    (AssociatorBimod.hom_right_act_hom' L M N)", "start": [780, 1], "end": [788, 47], "kind": "commanddeclaration"}, {"full_name": "Bimod.leftUnitorBimod", "code": "noncomputable def leftUnitorBimod {X Y : Mon_ C} (M : Bimod X Y) : (regular X).tensorBimod M \u2245 M :=\n  isoOfIso\n    { hom := LeftUnitorBimod.hom M\n      inv := LeftUnitorBimod.inv M\n      hom_inv_id := LeftUnitorBimod.hom_inv_id M\n      inv_hom_id := LeftUnitorBimod.inv_hom_id M } (LeftUnitorBimod.hom_left_act_hom' M)\n    (LeftUnitorBimod.hom_right_act_hom' M)", "start": [792, 1], "end": [799, 43], "kind": "commanddeclaration"}, {"full_name": "Bimod.rightUnitorBimod", "code": "noncomputable def rightUnitorBimod {X Y : Mon_ C} (M : Bimod X Y) : M.tensorBimod (regular Y) \u2245 M :=\n  isoOfIso\n    { hom := RightUnitorBimod.hom M\n      inv := RightUnitorBimod.inv M\n      hom_inv_id := RightUnitorBimod.hom_inv_id M\n      inv_hom_id := RightUnitorBimod.inv_hom_id M } (RightUnitorBimod.hom_left_act_hom' M)\n    (RightUnitorBimod.hom_right_act_hom' M)", "start": [803, 1], "end": [810, 44], "kind": "commanddeclaration"}, {"full_name": "Bimod.whisker_left_comp_bimod", "code": "theorem whisker_left_comp_bimod {X Y Z : Mon_ C} (M : Bimod X Y) {N P Q : Bimod Y Z} (f : N \u27f6 P)\n    (g : P \u27f6 Q) : tensorHom (\ud835\udfd9 M) (f \u226b g) = tensorHom (\ud835\udfd9 M) f \u226b tensorHom (\ud835\udfd9 M) g", "start": [814, 1], "end": [816, 39], "kind": "commanddeclaration"}, {"full_name": "Bimod.id_whisker_left_bimod", "code": "theorem id_whisker_left_bimod {X Y : Mon_ C} {M N : Bimod X Y} (f : M \u27f6 N) :\n    tensorHom (\ud835\udfd9 (regular X)) f = (leftUnitorBimod M).hom \u226b f \u226b (leftUnitorBimod N).inv", "start": [820, 1], "end": [840, 41], "kind": "commanddeclaration"}, {"full_name": "Bimod.comp_whisker_left_bimod", "code": "theorem comp_whisker_left_bimod {W X Y Z : Mon_ C} (M : Bimod W X) (N : Bimod X Y)\n    {P P' : Bimod Y Z} (f : P \u27f6 P') :\n    tensorHom (\ud835\udfd9 (M.tensorBimod N)) f =\n      (associatorBimod M N P).hom \u226b\n        tensorHom (\ud835\udfd9 M) (tensorHom (\ud835\udfd9 N) f) \u226b (associatorBimod M N P').inv", "start": [844, 1], "end": [868, 77], "kind": "commanddeclaration"}, {"full_name": "Bimod.comp_whisker_right_bimod", "code": "theorem comp_whisker_right_bimod {X Y Z : Mon_ C} {M N P : Bimod X Y} (f : M \u27f6 N) (g : N \u27f6 P)\n    (Q : Bimod Y Z) : tensorHom (f \u226b g) (\ud835\udfd9 Q) = tensorHom f (\ud835\udfd9 Q) \u226b tensorHom g (\ud835\udfd9 Q)", "start": [872, 1], "end": [874, 39], "kind": "commanddeclaration"}, {"full_name": "Bimod.whisker_right_id_bimod", "code": "theorem whisker_right_id_bimod {X Y : Mon_ C} {M N : Bimod X Y} (f : M \u27f6 N) :\n    tensorHom f (\ud835\udfd9 (regular Y)) = (rightUnitorBimod M).hom \u226b f \u226b (rightUnitorBimod N).inv", "start": [878, 1], "end": [897, 41], "kind": "commanddeclaration"}, {"full_name": "Bimod.whisker_right_comp_bimod", "code": "theorem whisker_right_comp_bimod {W X Y Z : Mon_ C} {M M' : Bimod W X} (f : M \u27f6 M') (N : Bimod X Y)\n    (P : Bimod Y Z) :\n    tensorHom f (\ud835\udfd9 (N.tensorBimod P)) =\n      (associatorBimod M N P).inv \u226b\n        tensorHom (tensorHom f (\ud835\udfd9 N)) (\ud835\udfd9 P) \u226b (associatorBimod M' N P).hom", "start": [901, 1], "end": [925, 77], "kind": "commanddeclaration"}, {"full_name": "Bimod.whisker_assoc_bimod", "code": "theorem whisker_assoc_bimod {W X Y Z : Mon_ C} (M : Bimod W X) {N N' : Bimod X Y} (f : N \u27f6 N')\n    (P : Bimod Y Z) :\n    tensorHom (tensorHom (\ud835\udfd9 M) f) (\ud835\udfd9 P) =\n      (associatorBimod M N P).hom \u226b\n        tensorHom (\ud835\udfd9 M) (tensorHom f (\ud835\udfd9 P)) \u226b (associatorBimod M N' P).inv", "start": [929, 1], "end": [955, 39], "kind": "commanddeclaration"}, {"full_name": "Bimod.whisker_exchange_bimod", "code": "theorem whisker_exchange_bimod {X Y Z : Mon_ C} {M N : Bimod X Y} {P Q : Bimod Y Z} (f : M \u27f6 N)\n    (g : P \u27f6 Q) : tensorHom (\ud835\udfd9 M) g \u226b tensorHom f (\ud835\udfd9 Q) =\n      tensorHom f (\ud835\udfd9 P) \u226b tensorHom (\ud835\udfd9 N) g", "start": [959, 1], "end": [971, 49], "kind": "commanddeclaration"}, {"full_name": "Bimod.pentagon_bimod", "code": "theorem pentagon_bimod {V W X Y Z : Mon_ C} (M : Bimod V W) (N : Bimod W X) (P : Bimod X Y)\n    (Q : Bimod Y Z) :\n    tensorHom (associatorBimod M N P).hom (\ud835\udfd9 Q) \u226b\n      (associatorBimod M (N.tensorBimod P) Q).hom \u226b\n        tensorHom (\ud835\udfd9 M) (associatorBimod N P Q).hom =\n      (associatorBimod (M.tensorBimod N) P Q).hom \u226b\n        (associatorBimod M N (P.tensorBimod Q)).hom", "start": [975, 1], "end": [1014, 12], "kind": "commanddeclaration"}, {"full_name": "Bimod.triangle_bimod", "code": "theorem triangle_bimod {X Y Z : Mon_ C} (M : Bimod X Y) (N : Bimod Y Z) :\n    (associatorBimod M (regular Y) N).hom \u226b tensorHom (\ud835\udfd9 M) (leftUnitorBimod N).hom =\n      tensorHom (rightUnitorBimod M).hom (\ud835\udfd9 N)", "start": [1018, 1], "end": [1038, 29], "kind": "commanddeclaration"}, {"full_name": "Bimod.monBicategory", "code": "noncomputable def monBicategory : Bicategory (Mon_ C) where\n  Hom X Y := Bimod X Y\n  homCategory X Y := (inferInstance : Category (Bimod X Y))\n  id X := regular X\n  comp M N := tensorBimod M N\n  whiskerLeft L _ _ f := tensorHom (Bimod.id' L) f\n  whiskerRight f N := tensorHom f (Bimod.id' N)\n  associator := associatorBimod\n  leftUnitor := leftUnitorBimod\n  rightUnitor := rightUnitorBimod\n  whiskerLeft_id _ _ := tensor_id\n  whiskerLeft_comp M _ _ _ f g := whisker_left_comp_bimod M f g\n  id_whiskerLeft := id_whisker_left_bimod\n  comp_whiskerLeft M N _ _ f := comp_whisker_left_bimod M N f\n  id_whiskerRight _ _ := tensor_id\n  comp_whiskerRight f g Q := comp_whisker_right_bimod f g Q\n  whiskerRight_id := whisker_right_id_bimod\n  whiskerRight_comp := whisker_right_comp_bimod\n  whisker_assoc M _ _ f P := whisker_assoc_bimod M f P\n  whisker_exchange := whisker_exchange_bimod\n  pentagon := pentagon_bimod\n  triangle := triangle_bimod", "start": [1042, 1], "end": [1064, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/LocallyConvex/AbsConvex.lean", "imports": ["Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean", "Mathlib/Analysis/Convex/Gauge.lean", "Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "nhds_basis_abs_convex", "code": "theorem nhds_basis_abs_convex :\n    (\ud835\udcdd (0 : E)).HasBasis (fun s : Set E => s \u2208 \ud835\udcdd (0 : E) \u2227 Balanced \ud835\udd5c s \u2227 Convex \u211d s) id", "start": [55, 1], "end": [63, 47], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_abs_convex_open", "code": "theorem nhds_basis_abs_convex_open :\n    (\ud835\udcdd (0 : E)).HasBasis (fun s => (0 : E) \u2208 s \u2227 IsOpen s \u2227 Balanced \ud835\udd5c s \u2227 Convex \u211d s) id", "start": [68, 1], "end": [77, 76], "kind": "commanddeclaration"}, {"full_name": "AbsConvexOpenSets", "code": "def AbsConvexOpenSets :=\n  { s : Set E // (0 : E) \u2208 s \u2227 IsOpen s \u2227 Balanced \ud835\udd5c s \u2227 Convex \u211d s }", "start": [90, 1], "end": [92, 70], "kind": "commanddeclaration"}, {"full_name": "AbsConvexOpenSets.instCoeTC", "code": "noncomputable instance AbsConvexOpenSets.instCoeTC : CoeTC (AbsConvexOpenSets \ud835\udd5c E) (Set E) :=\n  \u27e8Subtype.val\u27e9", "start": [95, 1], "end": [96, 16], "kind": "commanddeclaration"}, {"full_name": "AbsConvexOpenSets.coe_zero_mem", "code": "theorem coe_zero_mem (s : AbsConvexOpenSets \ud835\udd5c E) : (0 : E) \u2208 (s : Set E)", "start": [103, 1], "end": [104, 8], "kind": "commanddeclaration"}, {"full_name": "AbsConvexOpenSets.coe_isOpen", "code": "theorem coe_isOpen (s : AbsConvexOpenSets \ud835\udd5c E) : IsOpen (s : Set E)", "start": [107, 1], "end": [108, 10], "kind": "commanddeclaration"}, {"full_name": "AbsConvexOpenSets.coe_nhds", "code": "theorem coe_nhds (s : AbsConvexOpenSets \ud835\udd5c E) : (s : Set E) \u2208 \ud835\udcdd (0 : E)", "start": [111, 1], "end": [112, 39], "kind": "commanddeclaration"}, {"full_name": "AbsConvexOpenSets.coe_balanced", "code": "theorem coe_balanced (s : AbsConvexOpenSets \ud835\udd5c E) : Balanced \ud835\udd5c (s : Set E)", "start": [115, 1], "end": [116, 12], "kind": "commanddeclaration"}, {"full_name": "AbsConvexOpenSets.coe_convex", "code": "theorem coe_convex (s : AbsConvexOpenSets \ud835\udd5c E) : Convex \u211d (s : Set E)", "start": [119, 1], "end": [120, 12], "kind": "commanddeclaration"}, {"full_name": "AbsConvexOpenSets.instNonempty", "code": "instance AbsConvexOpenSets.instNonempty : Nonempty (AbsConvexOpenSets \ud835\udd5c E) := by\n  rw [\u2190 exists_true_iff_nonempty]\n  dsimp only [AbsConvexOpenSets]\n  rw [Subtype.exists]\n  exact \u27e8Set.univ, \u27e8mem_univ 0, isOpen_univ, balanced_univ, convex_univ\u27e9, trivial\u27e9", "start": [125, 1], "end": [129, 83], "kind": "commanddeclaration"}, {"full_name": "gaugeSeminormFamily", "code": "noncomputable def gaugeSeminormFamily : SeminormFamily \ud835\udd5c E (AbsConvexOpenSets \ud835\udd5c E) := fun s =>\n  gaugeSeminorm s.coe_balanced s.coe_convex (absorbent_nhds_zero s.coe_nhds)", "start": [143, 1], "end": [145, 77], "kind": "commanddeclaration"}, {"full_name": "gaugeSeminormFamily_ball", "code": "theorem gaugeSeminormFamily_ball (s : AbsConvexOpenSets \ud835\udd5c E) :\n    (gaugeSeminormFamily \ud835\udd5c E s).ball 0 1 = (s : Set E)", "start": [150, 1], "end": [155, 78], "kind": "commanddeclaration"}, {"full_name": "with_gaugeSeminormFamily", "code": "theorem with_gaugeSeminormFamily : WithSeminorms (gaugeSeminormFamily \ud835\udd5c E)", "start": [162, 1], "end": [183, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/SimplyConnected.lean", "imports": ["Mathlib/AlgebraicTopology/FundamentalGroupoid/PUnit.lean", "Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean", "Mathlib/CategoryTheory/PUnit.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Homotopy/Contractible.lean"], "premises": [{"full_name": "SimplyConnectedSpace", "code": "@[mk_iff simply_connected_def]\nclass SimplyConnectedSpace (X : Type*) [TopologicalSpace X] : Prop where\n  equiv_unit : Nonempty (FundamentalGroupoid X \u224c Discrete Unit)", "start": [35, 1], "end": [38, 64], "kind": "commanddeclaration"}, {"full_name": "simply_connected_iff_unique_homotopic", "code": "theorem simply_connected_iff_unique_homotopic (X : Type*) [TopologicalSpace X] :\n    SimplyConnectedSpace X \u2194\n      Nonempty X \u2227 \u2200 x y : X, Nonempty (Unique (Path.Homotopic.Quotient x y))", "start": [42, 1], "end": [45, 57], "kind": "commanddeclaration"}, {"full_name": "SimplyConnectedSpace.paths_homotopic", "code": "theorem paths_homotopic {x y : X} (p\u2081 p\u2082 : Path x y) : Path.Homotopic p\u2081 p\u2082", "start": [63, 1], "end": [65, 74], "kind": "commanddeclaration"}, {"full_name": "SimplyConnectedSpace.ofContractible", "code": "instance (priority := 100) ofContractible (Y : Type u) [TopologicalSpace Y] [ContractibleSpace Y] :\n    SimplyConnectedSpace Y where\n  equiv_unit :=\n    let H : TopCat.of Y \u2243\u2095 TopCat.of PUnit.{u+1} := (ContractibleSpace.hequiv Y PUnit.{u+1}).some\n    \u27e8(FundamentalGroupoidFunctor.equivOfHomotopyEquiv H).trans\n      FundamentalGroupoid.punitEquivDiscretePUnit\u27e9", "start": [68, 1], "end": [73, 51], "kind": "commanddeclaration"}, {"full_name": "simply_connected_iff_paths_homotopic", "code": "theorem simply_connected_iff_paths_homotopic {Y : Type*} [TopologicalSpace Y] :\n    SimplyConnectedSpace Y \u2194\n      PathConnectedSpace Y \u2227 \u2200 x y : Y, Subsingleton (Path.Homotopic.Quotient x y)", "start": [80, 1], "end": [87, 96], "kind": "commanddeclaration"}, {"full_name": "simply_connected_iff_paths_homotopic'", "code": "theorem simply_connected_iff_paths_homotopic' {Y : Type*} [TopologicalSpace Y] :\n    SimplyConnectedSpace Y \u2194\n      PathConnectedSpace Y \u2227 \u2200 {x y : Y} (p\u2081 p\u2082 : Path x y), Path.Homotopic p\u2081 p\u2082", "start": [90, 1], "end": [95, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/StoneSeparation.lean", "imports": ["Mathlib/Analysis/Convex/Join.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "not_disjoint_segment_convexHull_triple", "code": "theorem not_disjoint_segment_convexHull_triple {p q u v x y z : E} (hz : z \u2208 segment \ud835\udd5c x y)\n    (hu : u \u2208 segment \ud835\udd5c x p) (hv : v \u2208 segment \ud835\udd5c y q) :\n    \u00acDisjoint (segment \ud835\udd5c u v) (convexHull \ud835\udd5c {p, q, z})", "start": [26, 1], "end": [79, 55], "kind": "commanddeclaration"}, {"full_name": "exists_convex_convex_compl_subset", "code": "theorem exists_convex_convex_compl_subset (hs : Convex \ud835\udd5c s) (ht : Convex \ud835\udd5c t) (hst : Disjoint s t) :\n    \u2203 C : Set E, Convex \ud835\udd5c C \u2227 Convex \ud835\udd5c C\u1d9c \u2227 s \u2286 C \u2227 t \u2286 C\u1d9c", "start": [82, 1], "end": [111, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/NeLocus.lean", "imports": ["Mathlib/Data/Finsupp/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp.neLocus", "code": "def neLocus (f g : \u03b1 \u2192\u2080 N) : Finset \u03b1 :=\n  (f.support \u222a g.support).filter fun x => f x \u2260 g x", "start": [35, 1], "end": [38, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_neLocus", "code": "@[simp]\ntheorem mem_neLocus {f g : \u03b1 \u2192\u2080 N} {a : \u03b1} : a \u2208 f.neLocus g \u2194 f a \u2260 g a", "start": [41, 1], "end": [44, 47], "kind": "commanddeclaration"}, {"full_name": "Finsupp.not_mem_neLocus", "code": "theorem not_mem_neLocus {f g : \u03b1 \u2192\u2080 N} {a : \u03b1} : a \u2209 f.neLocus g \u2194 f a = g a", "start": [47, 1], "end": [48, 35], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_neLocus", "code": "@[simp]\ntheorem coe_neLocus : \u2191(f.neLocus g) = { x | f x \u2260 g x }", "start": [51, 1], "end": [54, 20], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_eq_empty", "code": "@[simp]\ntheorem neLocus_eq_empty {f g : \u03b1 \u2192\u2080 N} : f.neLocus g = \u2205 \u2194 f = g", "start": [57, 1], "end": [61, 98], "kind": "commanddeclaration"}, {"full_name": "Finsupp.nonempty_neLocus_iff", "code": "@[simp]\ntheorem nonempty_neLocus_iff {f g : \u03b1 \u2192\u2080 N} : (f.neLocus g).Nonempty \u2194 f \u2260 g", "start": [64, 1], "end": [66, 58], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_comm", "code": "theorem neLocus_comm : f.neLocus g = g.neLocus f", "start": [69, 1], "end": [70, 48], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_zero_right", "code": "@[simp]\ntheorem neLocus_zero_right : f.neLocus 0 = f.support", "start": [73, 1], "end": [76, 61], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_zero_left", "code": "@[simp]\ntheorem neLocus_zero_left : (0 : \u03b1 \u2192\u2080 N).neLocus f = f.support", "start": [79, 1], "end": [81, 50], "kind": "commanddeclaration"}, {"full_name": "Finsupp.subset_mapRange_neLocus", "code": "theorem subset_mapRange_neLocus [DecidableEq N] [Zero N] [DecidableEq M] [Zero M] (f g : \u03b1 \u2192\u2080 N)\n    {F : N \u2192 M} (F0 : F 0 = 0) : (f.mapRange F F0).neLocus (g.mapRange F F0) \u2286 f.neLocus g", "start": [88, 1], "end": [90, 86], "kind": "commanddeclaration"}, {"full_name": "Finsupp.zipWith_neLocus_eq_left", "code": "theorem zipWith_neLocus_eq_left [DecidableEq N] [Zero M] [DecidableEq P] [Zero P] [Zero N]\n    {F : M \u2192 N \u2192 P} (F0 : F 0 0 = 0) (f : \u03b1 \u2192\u2080 M) (g\u2081 g\u2082 : \u03b1 \u2192\u2080 N)\n    (hF : \u2200 f, Function.Injective fun g => F f g) :\n    (zipWith F F0 f g\u2081).neLocus (zipWith F F0 f g\u2082) = g\u2081.neLocus g\u2082", "start": [93, 1], "end": [98, 47], "kind": "commanddeclaration"}, {"full_name": "Finsupp.zipWith_neLocus_eq_right", "code": "theorem zipWith_neLocus_eq_right [DecidableEq M] [Zero M] [DecidableEq P] [Zero P] [Zero N]\n    {F : M \u2192 N \u2192 P} (F0 : F 0 0 = 0) (f\u2081 f\u2082 : \u03b1 \u2192\u2080 M) (g : \u03b1 \u2192\u2080 N)\n    (hF : \u2200 g, Function.Injective fun f => F f g) :\n    (zipWith F F0 f\u2081 g).neLocus (zipWith F F0 f\u2082 g) = f\u2081.neLocus f\u2082", "start": [101, 1], "end": [106, 47], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_neLocus_eq", "code": "theorem mapRange_neLocus_eq [DecidableEq N] [DecidableEq M] [Zero M] [Zero N] (f g : \u03b1 \u2192\u2080 N)\n    {F : N \u2192 M} (F0 : F 0 = 0) (hF : Function.Injective F) :\n    (f.mapRange F F0).neLocus (g.mapRange F F0) = f.neLocus g", "start": [109, 1], "end": [113, 43], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_add_left", "code": "@[simp]\ntheorem neLocus_add_left [AddLeftCancelMonoid N] (f g h : \u03b1 \u2192\u2080 N) :\n    (f + g).neLocus (f + h) = g.neLocus h", "start": [120, 1], "end": [123, 54], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_add_right", "code": "@[simp]\ntheorem neLocus_add_right [AddRightCancelMonoid N] (f g h : \u03b1 \u2192\u2080 N) :\n    (f + h).neLocus (g + h) = f.neLocus g", "start": [126, 1], "end": [129, 54], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_neg_neg", "code": "@[simp]\ntheorem neLocus_neg_neg : neLocus (-f) (-g) = f.neLocus g", "start": [136, 1], "end": [138, 49], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_neg", "code": "theorem neLocus_neg : neLocus (-f) g = f.neLocus (-g)", "start": [141, 1], "end": [141, 92], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_eq_support_sub", "code": "theorem neLocus_eq_support_sub : f.neLocus g = (f - g).support", "start": [144, 1], "end": [145, 87], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_sub_left", "code": "@[simp]\ntheorem neLocus_sub_left : neLocus (f - g\u2081) (f - g\u2082) = neLocus g\u2081 g\u2082", "start": [148, 1], "end": [150, 64], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_sub_right", "code": "@[simp]\ntheorem neLocus_sub_right : neLocus (f\u2081 - g) (f\u2082 - g) = neLocus f\u2081 f\u2082", "start": [153, 1], "end": [155, 60], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_self_add_right", "code": "@[simp]\ntheorem neLocus_self_add_right : neLocus f (f + g) = g.support", "start": [158, 1], "end": [160, 63], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_self_add_left", "code": "@[simp]\ntheorem neLocus_self_add_left : neLocus (f + g) f = g.support", "start": [163, 1], "end": [165, 44], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_self_sub_right", "code": "@[simp]\ntheorem neLocus_self_sub_right : neLocus f (f - g) = g.support", "start": [168, 1], "end": [170, 59], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neLocus_self_sub_left", "code": "@[simp]\ntheorem neLocus_self_sub_left : neLocus (f - g) f = g.support", "start": [173, 1], "end": [175, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Lemmas.lean", "imports": ["Mathlib/Data/List/Basic.lean", "Mathlib/Init/Data/List/Lemmas.lean", "Mathlib/Data/Set/Function.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.injOn_insertNth_index_of_not_mem", "code": "theorem injOn_insertNth_index_of_not_mem (l : List \u03b1) (x : \u03b1) (hx : x \u2209 l) :\n    Set.InjOn (fun k => insertNth k x l) { n | n \u2264 l.length }", "start": [26, 1], "end": [44, 46], "kind": "commanddeclaration"}, {"full_name": "List.foldr_range_subset_of_range_subset", "code": "theorem foldr_range_subset_of_range_subset {f : \u03b2 \u2192 \u03b1 \u2192 \u03b1} {g : \u03b3 \u2192 \u03b1 \u2192 \u03b1}\n    (hfg : Set.range f \u2286 Set.range g) (a : \u03b1) : Set.range (foldr f a) \u2286 Set.range (foldr g a)", "start": [47, 1], "end": [55, 24], "kind": "commanddeclaration"}, {"full_name": "List.foldl_range_subset_of_range_subset", "code": "theorem foldl_range_subset_of_range_subset {f : \u03b1 \u2192 \u03b2 \u2192 \u03b1} {g : \u03b1 \u2192 \u03b3 \u2192 \u03b1}\n    (hfg : (Set.range fun a c => f c a) \u2286 Set.range fun b c => g c b) (a : \u03b1) :\n    Set.range (foldl f a) \u2286 Set.range (foldl g a)", "start": [58, 1], "end": [69, 49], "kind": "commanddeclaration"}, {"full_name": "List.foldr_range_eq_of_range_eq", "code": "theorem foldr_range_eq_of_range_eq {f : \u03b2 \u2192 \u03b1 \u2192 \u03b1} {g : \u03b3 \u2192 \u03b1 \u2192 \u03b1} (hfg : Set.range f = Set.range g)\n    (a : \u03b1) : Set.range (foldr f a) = Set.range (foldr g a)", "start": [72, 1], "end": [75, 50], "kind": "commanddeclaration"}, {"full_name": "List.foldl_range_eq_of_range_eq", "code": "theorem foldl_range_eq_of_range_eq {f : \u03b1 \u2192 \u03b2 \u2192 \u03b1} {g : \u03b1 \u2192 \u03b3 \u2192 \u03b1}\n    (hfg : (Set.range fun a c => f c a) = Set.range fun b c => g c b) (a : \u03b1) :\n    Set.range (foldl f a) = Set.range (foldl g a)", "start": [78, 1], "end": [82, 50], "kind": "commanddeclaration"}, {"full_name": "List.mapAccumr_eq_foldr", "code": "theorem mapAccumr_eq_foldr (f : \u03b1 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03b2) : \u2200 (as : List \u03b1) (s : \u03c3),\n    mapAccumr f as s = List.foldr (fun a s =>\n                                    let r := f a s.1\n                                    (r.1, r.2 :: s.2)\n                                  ) (s, []) as", "start": [93, 1], "end": [100, 58], "kind": "commanddeclaration"}, {"full_name": "List.mapAccumr\u2082_eq_foldr", "code": "theorem mapAccumr\u2082_eq_foldr (f : \u03b1 \u2192 \u03b2 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03c6) :\n    \u2200 (as : List \u03b1) (bs : List \u03b2) (s : \u03c3),\n    mapAccumr\u2082 f as bs s = foldr (fun ab s =>\n                              let r := f ab.1 ab.2 s.1\n                              (r.1, r.2 :: s.2)\n                            ) (s, []) (as.zip bs)", "start": [102, 1], "end": [113, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/FiniteDimensional.lean", "imports": ["Mathlib/LinearAlgebra/FiniteDimensional.lean", "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Matrix/Basic.lean"], "premises": [{"full_name": "Matrix.finiteDimensional", "code": "instance finiteDimensional [Finite m] [Finite n] : FiniteDimensional R (Matrix m n R) :=\n  Module.Finite.matrix", "start": [40, 1], "end": [41, 23], "kind": "commanddeclaration"}, {"full_name": "LinearMap.finiteDimensional", "code": "instance finiteDimensional : FiniteDimensional K (V \u2192\u2097[K] W) :=\n  Module.Finite.linearMap _ _", "start": [55, 1], "end": [56, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.finiteDimensional'", "code": "instance finiteDimensional' : FiniteDimensional K (V \u2192\u2097[A] W) :=\n  FiniteDimensional.of_injective (restrictScalarsLinearMap K A V W) (restrictScalars_injective _)", "start": [62, 1], "end": [65, 98], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/AlgebraCat/Limits.lean", "imports": ["Mathlib/Algebra/Category/Ring/Limits.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Category/AlgebraCat/Basic.lean", "Mathlib/Algebra/Category/ModuleCat/Limits.lean", "Mathlib/Algebra/Category/ModuleCat/Basic.lean"], "premises": [{"full_name": "AlgebraCat.semiringObj", "code": "instance semiringObj (F : J \u2964 AlgebraCatMax.{v, w} R) (j) :\n    Semiring ((F \u22d9 forget (AlgebraCat R)).obj j) :=\n  inferInstanceAs <| Semiring (F.obj j)", "start": [37, 1], "end": [39, 40], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.algebraObj", "code": "instance algebraObj (F : J \u2964 AlgebraCatMax.{v, w} R) (j) :\n    Algebra R ((F \u22d9 forget (AlgebraCat R)).obj j) :=\n  inferInstanceAs <| Algebra R (F.obj j)", "start": [42, 1], "end": [44, 41], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.sectionsSubalgebra", "code": "def sectionsSubalgebra (F : J \u2964 AlgebraCatMax.{v, w} R) : Subalgebra R (\u2200 j, F.obj j) :=\n  { SemiRingCat.sectionsSubsemiring\n      (F \u22d9 forget\u2082 (AlgebraCat R) RingCat.{max v w} \u22d9 forget\u2082 RingCat SemiRingCatMax.{v, w}) with\n    algebraMap_mem' := fun r _ _ f => (F.map f).commutes r }", "start": [47, 1], "end": [52, 61], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.limitSemiring", "code": "instance limitSemiring (F : J \u2964 AlgebraCatMax.{v, w} R) :\n    Ring.{max v w} (Types.limitCone.{v, w} (F \u22d9 forget (AlgebraCatMax.{v, w} R))).pt :=\n  inferInstanceAs <| Ring (sectionsSubalgebra F)", "start": [55, 1], "end": [57, 49], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.limitAlgebra", "code": "instance limitAlgebra (F : J \u2964 AlgebraCatMax.{v, w} R) :\n    Algebra R (Types.limitCone (F \u22d9 forget (AlgebraCatMax.{v, w} R))).pt :=\n  inferInstanceAs <| Algebra R (sectionsSubalgebra F)", "start": [60, 1], "end": [62, 54], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.limit\u03c0AlgHom", "code": "def limit\u03c0AlgHom (F : J \u2964 AlgebraCatMax.{v, w} R) (j) :\n    (Types.limitCone (F \u22d9 forget (AlgebraCat R))).pt \u2192\u2090[R]\n      (F \u22d9 forget (AlgebraCatMax.{v, w} R)).obj j :=\n  { SemiRingCat.limit\u03c0RingHom\n      (F \u22d9 forget\u2082 (AlgebraCat R) RingCat.{max v w} \u22d9 forget\u2082 RingCat SemiRingCat.{max v w}) j with\n    commutes' := fun _ => rfl }", "start": [65, 1], "end": [71, 32], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.HasLimits.limitCone", "code": "def limitCone (F : J \u2964 AlgebraCatMax.{v, w} R) : Cone F where\n  pt := AlgebraCat.of R (Types.limitCone (F \u22d9 forget _)).pt\n  \u03c0 :=\n    { app := limit\u03c0AlgHom F\n      naturality := fun _ _ f =>\n        AlgHom.coe_fn_injective ((Types.limitCone (F \u22d9 forget _)).\u03c0.naturality f) }", "start": [79, 1], "end": [87, 84], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.HasLimits.limitConeIsLimit", "code": "def limitConeIsLimit (F : J \u2964 AlgebraCatMax.{v, w} R) : IsLimit (limitCone.{v, w} F) := by\n  refine'\n    IsLimit.ofFaithful (forget (AlgebraCat R)) (Types.limitConeIsLimit.{v, w} _)\n      (fun s => \u27e8\u27e8\u27e8\u27e8fun v => \u27e8fun j => ((forget (AlgebraCat R)).mapCone s).\u03c0.app j v, _\u27e9,\n         _\u27e9, _\u27e9, _, _\u27e9, _\u27e9)\n      (fun s => _)\n  \u00b7 intro j j' f\n    exact FunLike.congr_fun (Cone.w s f) v\n  \u00b7 apply Subtype.ext\n    ext j\n    simp only [Functor.comp_obj, Functor.mapCone_pt, Functor.mapCone_\u03c0_app,\n      forget_map_eq_coe]\n    erw [map_one]\n    rfl\n  \u00b7 intro x y\n    apply Subtype.ext\n    ext j\n    simp only [Functor.comp_obj, Functor.mapCone_pt, Functor.mapCone_\u03c0_app,\n      forget_map_eq_coe]\n    erw [map_mul]\n    rfl\n  \u00b7 simp only [Functor.comp_obj, Functor.mapCone_pt, Functor.mapCone_\u03c0_app,\n      forget_map_eq_coe]\n    apply Subtype.ext\n    dsimp\n    funext u\n    erw [map_zero]\n    rfl\n  \u00b7 intro x y\n    simp only [Functor.comp_obj, Functor.mapCone_pt, Functor.mapCone_\u03c0_app,\n      forget_map_eq_coe]\n    apply Subtype.ext\n    dsimp\n    funext u\n    erw [map_add]\n    rfl\n  \u00b7 intro r\n    apply Subtype.ext\n    ext j\n    exact (s.\u03c0.app j).commutes r\n  \u00b7 rfl", "start": [90, 1], "end": [145, 8], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.hasLimitsOfSize", "code": "lemma hasLimitsOfSize : HasLimitsOfSize.{v, v} (AlgebraCatMax.{v, w} R) :=\n  { has_limits_of_shape := fun _ _ =>\n    { has_limit := fun F => HasLimit.mk\n        { cone := limitCone F\n          isLimit := limitConeIsLimit F } } }", "start": [154, 1], "end": [159, 46], "kind": "mathlibtacticlemma"}, {"full_name": "AlgebraCat.hasLimits", "code": "instance hasLimits : HasLimits (AlgebraCat.{w} R) :=\n  AlgebraCat.hasLimitsOfSize.{w, w, u}", "start": [162, 1], "end": [163, 39], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.forget\u2082RingPreservesLimitsOfSize", "code": "instance forget\u2082RingPreservesLimitsOfSize :\n    PreservesLimitsOfSize.{v, v} (forget\u2082 (AlgebraCatMax.{v, w} R) RingCatMax.{v, w}) where\n  preservesLimitsOfShape :=\n    { preservesLimit :=\n        preservesLimitOfPreservesLimitCone (limitConeIsLimit _)\n          (RingCat.limitConeIsLimit.{v, w}\n            (_ \u22d9 forget\u2082 (AlgebraCatMax.{v, w} R) RingCatMax.{v, w})) }", "start": [166, 1], "end": [174, 72], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.forget\u2082RingPreservesLimits", "code": "instance forget\u2082RingPreservesLimits : PreservesLimits (forget\u2082 (AlgebraCat R) RingCat.{w}) :=\n  AlgebraCat.forget\u2082RingPreservesLimitsOfSize.{w, w}", "start": [177, 1], "end": [178, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.forget\u2082ModulePreservesLimitsOfSize", "code": "instance forget\u2082ModulePreservesLimitsOfSize : PreservesLimitsOfSize.{v, v}\n    (forget\u2082 (AlgebraCatMax.{v, w} R) (ModuleCatMax.{v, w} R)) where\n  preservesLimitsOfShape :=\n    { preservesLimit :=\n        preservesLimitOfPreservesLimitCone (limitConeIsLimit _)\n          (ModuleCat.HasLimits.limitConeIsLimit\n            (_ \u22d9 forget\u2082 (AlgebraCatMax.{v, w} R) (ModuleCatMax.{v, w} R))) }", "start": [181, 1], "end": [189, 78], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.forget\u2082ModulePreservesLimits", "code": "instance forget\u2082ModulePreservesLimits :\n    PreservesLimits (forget\u2082 (AlgebraCat R) (ModuleCat.{w} R)) :=\n  AlgebraCat.forget\u2082ModulePreservesLimitsOfSize.{w, w}", "start": [192, 1], "end": [194, 55], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.forgetPreservesLimitsOfSize", "code": "instance forgetPreservesLimitsOfSize :\n    PreservesLimitsOfSize.{v, v} (forget (AlgebraCatMax.{v, w} R)) where\n  preservesLimitsOfShape :=\n    { preservesLimit :=\n       preservesLimitOfPreservesLimitCone (limitConeIsLimit _)\n          (Types.limitConeIsLimit (_ \u22d9 forget _)) }", "start": [197, 1], "end": [204, 52], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.forgetPreservesLimits", "code": "instance forgetPreservesLimits : PreservesLimits (forget (AlgebraCat.{w} R)) :=\n  AlgebraCat.forgetPreservesLimitsOfSize.{w, w}", "start": [207, 1], "end": [208, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/Time.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "timeCmdElab", "code": "@[command_elab timeCmd] def timeCmdElab : CommandElab\n  | `(#time%$tk $stx:command) => do\n    let start \u2190 IO.monoMsNow\n    elabCommand stx\n    logInfoAt tk m!\"time: {(\u2190 IO.monoMsNow) - start}ms\"\n  | _ => throwUnsupportedSyntax", "start": [19, 1], "end": [33, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/LDL.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/PosDef.lean", "Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LDL.lowerInv", "code": "noncomputable def LDL.lowerInv : Matrix n n \ud835\udd5c :=\n  @gramSchmidt \ud835\udd5c (n \u2192 \ud835\udd5c) _ (_ : _) (InnerProductSpace.ofMatrix hS.transpose) n _ _ _\n    (Pi.basisFun \ud835\udd5c n)", "start": [50, 1], "end": [55, 22], "kind": "commanddeclaration"}, {"full_name": "LDL.lowerInv_eq_gramSchmidtBasis", "code": "theorem LDL.lowerInv_eq_gramSchmidtBasis :\n    LDL.lowerInv hS =\n      ((Pi.basisFun \ud835\udd5c n).toMatrix\n          (@gramSchmidtBasis \ud835\udd5c (n \u2192 \ud835\udd5c) _ (_ : _) (InnerProductSpace.ofMatrix hS.transpose) n _ _ _\n            (Pi.basisFun \ud835\udd5c n)))\u1d40", "start": [58, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "LDL.invertibleLowerInv", "code": "noncomputable instance LDL.invertibleLowerInv : Invertible (LDL.lowerInv hS) := by\n  rw [LDL.lowerInv_eq_gramSchmidtBasis]\n  haveI :=\n    Basis.invertibleToMatrix (Pi.basisFun \ud835\udd5c n)\n      (@gramSchmidtBasis \ud835\udd5c (n \u2192 \ud835\udd5c) _ (_ : _) (InnerProductSpace.ofMatrix hS.transpose) n _ _ _\n        (Pi.basisFun \ud835\udd5c n))\n  infer_instance", "start": [70, 1], "end": [76, 17], "kind": "commanddeclaration"}, {"full_name": "LDL.lowerInv_orthogonal", "code": "theorem LDL.lowerInv_orthogonal {i j : n} (h\u2080 : i \u2260 j) :\n    \u27eaLDL.lowerInv hS i, S\u1d40.mulVec (LDL.lowerInv hS j)\u27eb\u2091 = 0", "start": [79, 1], "end": [81, 99], "kind": "commanddeclaration"}, {"full_name": "LDL.diagEntries", "code": "noncomputable def LDL.diagEntries : n \u2192 \ud835\udd5c := fun i =>\n  \u27eastar (LDL.lowerInv hS i), S.mulVec (star (LDL.lowerInv hS i))\u27eb\u2091", "start": [84, 1], "end": [86, 67], "kind": "commanddeclaration"}, {"full_name": "LDL.diag", "code": "noncomputable def LDL.diag : Matrix n n \ud835\udd5c :=\n  Matrix.diagonal (LDL.diagEntries hS)", "start": [89, 1], "end": [91, 39], "kind": "commanddeclaration"}, {"full_name": "LDL.lowerInv_triangular", "code": "theorem LDL.lowerInv_triangular {i j : n} (hij : i < j) : LDL.lowerInv hS i j = 0", "start": [94, 1], "end": [98, 36], "kind": "commanddeclaration"}, {"full_name": "LDL.diag_eq_lowerInv_conj", "code": "theorem LDL.diag_eq_lowerInv_conj : LDL.diag hS = LDL.lowerInv hS * S * (LDL.lowerInv hS)\u1d34", "start": [101, 1], "end": [114, 8], "kind": "commanddeclaration"}, {"full_name": "LDL.lower", "code": "noncomputable def LDL.lower :=\n  (LDL.lowerInv hS)\u207b\u00b9", "start": [117, 1], "end": [119, 22], "kind": "commanddeclaration"}, {"full_name": "LDL.lower_conj_diag", "code": "theorem LDL.lower_conj_diag : LDL.lower hS * LDL.diag hS * (LDL.lower hS)\u1d34 = S", "start": [122, 1], "end": [128, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Bertrand.lean", "imports": ["Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean", "Mathlib/Data/Nat/PrimeNormNum.lean", "Mathlib/NumberTheory/Primorial.lean", "Mathlib/Data/Nat/Choose/Factorization.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Convex/SpecificFunctions/Basic.lean"], "premises": [{"full_name": "Bertrand.real_main_inequality", "code": "theorem real_main_inequality {x : \u211d} (n_large : (512 : \u211d) \u2264 x) :\n    x * (2 * x) ^ sqrt (2 * x) * 4 ^ (2 * x / 3) \u2264 4 ^ x", "start": [51, 1], "end": [112, 35], "kind": "commanddeclaration"}, {"full_name": "bertrand_main_inequality", "code": "theorem bertrand_main_inequality {n : \u2115} (n_large : 512 \u2264 n) :\n    n * (2 * n) ^ sqrt (2 * n) * 4 ^ (2 * n / 3) \u2264 4 ^ n", "start": [123, 1], "end": [139, 84], "kind": "commanddeclaration"}, {"full_name": "centralBinom_factorization_small", "code": "theorem centralBinom_factorization_small (n : \u2115) (n_large : 2 < n)\n    (no_prime : \u00ac\u2203 p : \u2115, p.Prime \u2227 n < p \u2227 p \u2264 2 * n) :\n    centralBinom n = \u220f p in Finset.range (2 * n / 3 + 1), p ^ (centralBinom n).factorization p", "start": [142, 1], "end": [158, 93], "kind": "commanddeclaration"}, {"full_name": "centralBinom_le_of_no_bertrand_prime", "code": "theorem centralBinom_le_of_no_bertrand_prime (n : \u2115) (n_big : 2 < n)\n    (no_prime : \u00ac\u2203 p : \u2115, Nat.Prime p \u2227 n < p \u2227 p \u2264 2 * n) :\n    centralBinom n \u2264 (2 * n) ^ sqrt (2 * n) * 4 ^ (2 * n / 3)", "start": [161, 1], "end": [196, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_prime_lt_and_le_two_mul_eventually", "code": "theorem exists_prime_lt_and_le_two_mul_eventually (n : \u2115) (n_big : 512 \u2264 n) :\n    \u2203 p : \u2115, p.Prime \u2227 n < p \u2227 p \u2264 2 * n", "start": [201, 1], "end": [215, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_prime_lt_and_le_two_mul_succ", "code": "theorem exists_prime_lt_and_le_two_mul_succ {n} (q) {p : \u2115} (prime_p : Nat.Prime p)\n    (covering : p \u2264 2 * q) (H : n < q \u2192 \u2203 p : \u2115, p.Prime \u2227 n < p \u2227 p \u2264 2 * n) (hn : n < p) :\n    \u2203 p : \u2115, p.Prime \u2227 n < p \u2227 p \u2264 2 * n", "start": [218, 1], "end": [226, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_prime_lt_and_le_two_mul", "code": "theorem exists_prime_lt_and_le_two_mul (n : \u2115) (hn0 : n \u2260 0) :\n    \u2203 p, Nat.Prime p \u2227 n < p \u2227 p \u2264 2 * n", "start": [229, 1], "end": [249, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.bertrand", "code": "alias bertrand := Nat.exists_prime_lt_and_le_two_mul", "start": [252, 1], "end": [252, 53], "kind": "stdtacticaliasalias"}]}
{"path": "Mathlib/Analysis/InnerProductSpace/OfNorm.lean", "imports": ["Mathlib/Topology/Algebra/Algebra.lean", "Mathlib/Analysis/InnerProductSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "InnerProductSpaceable", "code": "class InnerProductSpaceable : Prop where\n  parallelogram_identity :\n    \u2200 x y : E, \u2016x + y\u2016 * \u2016x + y\u2016 + \u2016x - y\u2016 * \u2016x - y\u2016 = 2 * (\u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016)", "start": [62, 1], "end": [68, 83], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpace.toInnerProductSpaceable", "code": "theorem InnerProductSpace.toInnerProductSpaceable [InnerProductSpace \ud835\udd5c E] :\n    InnerProductSpaceable E", "start": [73, 1], "end": [75, 34], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpace.toInnerProductSpaceable_ofReal", "code": "instance (priority := 100) InnerProductSpace.toInnerProductSpaceable_ofReal\n    [InnerProductSpace \u211d E] : InnerProductSpaceable E :=\n  \u27e8parallelogram_law_with_norm \u211d\u27e9", "start": [79, 1], "end": [81, 34], "kind": "commanddeclaration"}, {"full_name": "inner_", "code": "private noncomputable def inner_ (x y : E) : \ud835\udd5c :=\n  4\u207b\u00b9 * (\ud835\udcda \u2016x + y\u2016 * \ud835\udcda \u2016x + y\u2016 - \ud835\udcda \u2016x - y\u2016 * \ud835\udcda \u2016x - y\u2016 +\n    (I : \ud835\udd5c) * \ud835\udcda \u2016(I : \ud835\udd5c) \u2022 x + y\u2016 * \ud835\udcda \u2016(I : \ud835\udd5c) \u2022 x + y\u2016 -\n    (I : \ud835\udd5c) * \ud835\udcda \u2016(I : \ud835\udd5c) \u2022 x - y\u2016 * \ud835\udcda \u2016(I : \ud835\udd5c) \u2022 x - y\u2016)", "start": [88, 1], "end": [92, 57], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.innerProp'", "code": "private def innerProp' (r : \ud835\udd5c) : Prop :=\n  \u2200 x y : E, inner_ \ud835\udd5c (r \u2022 x) y = conj r * inner_ \ud835\udd5c x y", "start": [99, 1], "end": [101, 56], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.innerProp_neg_one", "code": "theorem innerProp_neg_one : innerProp' E ((-1 : \u2124) : \ud835\udd5c)", "start": [105, 1], "end": [117, 7], "kind": "commanddeclaration"}, {"full_name": "Continuous.inner_", "code": "theorem _root_.Continuous.inner_ {f g : \u211d \u2192 E} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun x => inner_ \ud835\udd5c (f x) (g x)", "start": [120, 1], "end": [124, 13], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.inner_.norm_sq", "code": "theorem inner_.norm_sq (x : E) : \u2016x\u2016 ^ 2 = re (inner_ \ud835\udd5c x x)", "start": [127, 1], "end": [136, 7], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.inner_.conj_symm", "code": "theorem inner_.conj_symm (x y : E) : conj (inner_ \ud835\udd5c y x) = inner_ \ud835\udd5c x y", "start": [139, 1], "end": [161, 47], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.add_left_aux1", "code": "private theorem add_left_aux1 (x y z : E) : \u2016x + y + z\u2016 * \u2016x + y + z\u2016 =\n    (\u20162 \u2022 x + y\u2016 * \u20162 \u2022 x + y\u2016 + \u20162 \u2022 z + y\u2016 * \u20162 \u2022 z + y\u2016) / 2 - \u2016x - z\u2016 * \u2016x - z\u2016", "start": [166, 1], "end": [169, 87], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.add_left_aux2", "code": "private theorem add_left_aux2 (x y z : E) : \u2016x + y - z\u2016 * \u2016x + y - z\u2016 =\n    (\u20162 \u2022 x + y\u2016 * \u20162 \u2022 x + y\u2016 + \u2016y - 2 \u2022 z\u2016 * \u2016y - 2 \u2022 z\u2016) / 2 - \u2016x + z\u2016 * \u2016x + z\u2016", "start": [171, 1], "end": [175, 47], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.add_left_aux2'", "code": "private theorem add_left_aux2' (x y z : E) :\n    \u2016x + y + z\u2016 * \u2016x + y + z\u2016 - \u2016x + y - z\u2016 * \u2016x + y - z\u2016 =\n    \u2016x + z\u2016 * \u2016x + z\u2016 - \u2016x - z\u2016 * \u2016x - z\u2016 +\n    (\u20162 \u2022 z + y\u2016 * \u20162 \u2022 z + y\u2016 - \u2016y - 2 \u2022 z\u2016 * \u2016y - 2 \u2022 z\u2016) / 2", "start": [177, 1], "end": [181, 42], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.add_left_aux3", "code": "private theorem add_left_aux3 (y z : E) :\n    \u20162 \u2022 z + y\u2016 * \u20162 \u2022 z + y\u2016 = 2 * (\u2016y + z\u2016 * \u2016y + z\u2016 + \u2016z\u2016 * \u2016z\u2016) - \u2016y\u2016 * \u2016y\u2016", "start": [183, 1], "end": [186, 84], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.add_left_aux4", "code": "private theorem add_left_aux4 (y z : E) :\n    \u2016y - 2 \u2022 z\u2016 * \u2016y - 2 \u2022 z\u2016 = 2 * (\u2016y - z\u2016 * \u2016y - z\u2016 + \u2016z\u2016 * \u2016z\u2016) - \u2016y\u2016 * \u2016y\u2016", "start": [188, 1], "end": [192, 54], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.add_left_aux4'", "code": "private theorem add_left_aux4' (y z : E) :\n    (\u20162 \u2022 z + y\u2016 * \u20162 \u2022 z + y\u2016 - \u2016y - 2 \u2022 z\u2016 * \u2016y - 2 \u2022 z\u2016) / 2 =\n    \u2016y + z\u2016 * \u2016y + z\u2016 - \u2016y - z\u2016 * \u2016y - z\u2016", "start": [194, 1], "end": [197, 42], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.add_left_aux5", "code": "private theorem add_left_aux5 (x y z : E) :\n    \u2016(I : \ud835\udd5c) \u2022 (x + y) + z\u2016 * \u2016(I : \ud835\udd5c) \u2022 (x + y) + z\u2016 =\n    (\u2016(I : \ud835\udd5c) \u2022 (2 \u2022 x + y)\u2016 * \u2016(I : \ud835\udd5c) \u2022 (2 \u2022 x + y)\u2016 +\n    \u2016(I : \ud835\udd5c) \u2022 y + 2 \u2022 z\u2016 * \u2016(I : \ud835\udd5c) \u2022 y + 2 \u2022 z\u2016) / 2 -\n    \u2016(I : \ud835\udd5c) \u2022 x - z\u2016 * \u2016(I : \ud835\udd5c) \u2022 x - z\u2016", "start": [199, 1], "end": [206, 68], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.add_left_aux6", "code": "private theorem add_left_aux6 (x y z : E) :\n    \u2016(I : \ud835\udd5c) \u2022 (x + y) - z\u2016 * \u2016(I : \ud835\udd5c) \u2022 (x + y) - z\u2016 =\n    (\u2016(I : \ud835\udd5c) \u2022 (2 \u2022 x + y)\u2016 * \u2016(I : \ud835\udd5c) \u2022 (2 \u2022 x + y)\u2016 +\n    \u2016(I : \ud835\udd5c) \u2022 y - 2 \u2022 z\u2016 * \u2016(I : \ud835\udd5c) \u2022 y - 2 \u2022 z\u2016) / 2 -\n    \u2016(I : \ud835\udd5c) \u2022 x + z\u2016 * \u2016(I : \ud835\udd5c) \u2022 x + z\u2016", "start": [208, 1], "end": [215, 68], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.add_left_aux7", "code": "private theorem add_left_aux7 (y z : E) :\n    \u2016(I : \ud835\udd5c) \u2022 y + 2 \u2022 z\u2016 * \u2016(I : \ud835\udd5c) \u2022 y + 2 \u2022 z\u2016 =\n    2 * (\u2016(I : \ud835\udd5c) \u2022 y + z\u2016 * \u2016(I : \ud835\udd5c) \u2022 y + z\u2016 + \u2016z\u2016 * \u2016z\u2016) - \u2016(I : \ud835\udd5c) \u2022 y\u2016 * \u2016(I : \ud835\udd5c) \u2022 y\u2016", "start": [217, 1], "end": [222, 70], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.add_left_aux8", "code": "private theorem add_left_aux8 (y z : E) :\n    \u2016(I : \ud835\udd5c) \u2022 y - 2 \u2022 z\u2016 * \u2016(I : \ud835\udd5c) \u2022 y - 2 \u2022 z\u2016 =\n    2 * (\u2016(I : \ud835\udd5c) \u2022 y - z\u2016 * \u2016(I : \ud835\udd5c) \u2022 y - z\u2016 + \u2016z\u2016 * \u2016z\u2016) - \u2016(I : \ud835\udd5c) \u2022 y\u2016 * \u2016(I : \ud835\udd5c) \u2022 y\u2016", "start": [224, 1], "end": [229, 70], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.add_left", "code": "theorem add_left (x y z : E) : inner_ \ud835\udd5c (x + y) z = inner_ \ud835\udd5c x z + inner_ \ud835\udd5c y z", "start": [231, 1], "end": [241, 9], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.nat", "code": "theorem nat (n : \u2115) (x y : E) : inner_ \ud835\udd5c ((n : \ud835\udd5c) \u2022 x) y = (n : \ud835\udd5c) * inner_ \ud835\udd5c x y", "start": [244, 1], "end": [249, 40], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.nat_prop", "code": "private theorem nat_prop (r : \u2115) : innerProp' E (r : \ud835\udd5c)", "start": [252, 1], "end": [253, 43], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.int_prop", "code": "private theorem int_prop (n : \u2124) : innerProp' E (n : \ud835\udd5c)", "start": [255, 1], "end": [268, 53], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.rat_prop", "code": "private theorem rat_prop (r : \u211a) : innerProp' E (r : \ud835\udd5c)", "start": [270, 1], "end": [277, 70], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.real_prop", "code": "private theorem real_prop (r : \u211d) : innerProp' E (r : \ud835\udd5c)", "start": [279, 1], "end": [286, 73], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.I_prop", "code": "private theorem I_prop : innerProp' E (I : \ud835\udd5c)", "start": [288, 1], "end": [303, 7], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.innerProp", "code": "theorem innerProp (r : \ud835\udd5c) : innerProp' E r", "start": [305, 1], "end": [309, 7], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpace.ofNorm", "code": "noncomputable def InnerProductSpace.ofNorm\n    (h : \u2200 x y : E, \u2016x + y\u2016 * \u2016x + y\u2016 + \u2016x - y\u2016 * \u2016x - y\u2016 = 2 * (\u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016)) :\n    InnerProductSpace \ud835\udd5c E :=\n  haveI : InnerProductSpaceable E := \u27e8h\u27e9\n  { inner := inner_ \ud835\udd5c\n    norm_sq_eq_inner := inner_.norm_sq\n    conj_symm := inner_.conj_symm\n    add_left := InnerProductSpaceable.add_left\n    smul_left := fun _ _ _ => innerProp _ _ _ }", "start": [316, 1], "end": [326, 48], "kind": "commanddeclaration"}, {"full_name": "nonempty_innerProductSpace", "code": "theorem nonempty_innerProductSpace : Nonempty (InnerProductSpace \ud835\udd5c E)", "start": [333, 1], "end": [342, 51], "kind": "commanddeclaration"}, {"full_name": "InnerProductSpaceable.to_uniformConvexSpace", "code": "instance (priority := 100) InnerProductSpaceable.to_uniformConvexSpace : UniformConvexSpace E := by\n  cases nonempty_innerProductSpace \u211d E; infer_instance", "start": [351, 1], "end": [352, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Decomposition/UnsignedHahn.lean", "imports": ["Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.hahn_decomposition", "code": "theorem hahn_decomposition [IsFiniteMeasure \u03bc] [IsFiniteMeasure \u03bd] :\n    \u2203 s,\n      MeasurableSet s \u2227\n        (\u2200 t, MeasurableSet t \u2192 t \u2286 s \u2192 \u03bd t \u2264 \u03bc t) \u2227 \u2200 t, MeasurableSet t \u2192 t \u2286 s\u1d9c \u2192 \u03bc t \u2264 \u03bd t", "start": [35, 1], "end": [178, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SetFamily/LYM.lean", "imports": ["Mathlib/Algebra/Order/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Combinatorics/SetFamily/Shadow.lean", "Mathlib/Algebra/BigOperators/Ring.lean", "Mathlib/Combinatorics/DoubleCounting.lean", "Mathlib/Data/Rat/Order.lean"], "premises": [{"full_name": "Finset.card_mul_le_card_shadow_mul", "code": "theorem card_mul_le_card_shadow_mul (h\ud835\udc9c : (\ud835\udc9c : Set (Finset \u03b1)).Sized r) :\n    \ud835\udc9c.card * r \u2264 (\u2202 \ud835\udc9c).card * (Fintype.card \u03b1 - r + 1)", "start": [62, 1], "end": [86, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.card_div_choose_le_card_shadow_div_choose", "code": "theorem card_div_choose_le_card_shadow_div_choose (hr : r \u2260 0)\n    (h\ud835\udc9c : (\ud835\udc9c : Set (Finset \u03b1)).Sized r) : (\ud835\udc9c.card : \ud835\udd5c) / (Fintype.card \u03b1).choose r\n    \u2264 (\u2202 \ud835\udc9c).card / (Fintype.card \u03b1).choose (r - 1)", "start": [89, 1], "end": [110, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.falling", "code": "def falling : Finset (Finset \u03b1) :=\n  \ud835\udc9c.sup <| powersetCard k", "start": [124, 1], "end": [126, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_falling", "code": "theorem mem_falling : s \u2208 falling k \ud835\udc9c \u2194 (\u2203 t \u2208 \ud835\udc9c, s \u2286 t) \u2227 s.card = k", "start": [131, 1], "end": [133, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.sized_falling", "code": "theorem sized_falling : (falling k \ud835\udc9c : Set (Finset \u03b1)).Sized k", "start": [138, 1], "end": [138, 99], "kind": "commanddeclaration"}, {"full_name": "Finset.slice_subset_falling", "code": "theorem slice_subset_falling : \ud835\udc9c # k \u2286 falling k \ud835\udc9c", "start": [141, 1], "end": [142, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.falling_zero_subset", "code": "theorem falling_zero_subset : falling 0 \ud835\udc9c \u2286 {\u2205}", "start": [145, 1], "end": [146, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.slice_union_shadow_falling_succ", "code": "theorem slice_union_shadow_falling_succ : \ud835\udc9c # k \u222a \u2202 (falling (k + 1) \ud835\udc9c) = falling k \ud835\udc9c", "start": [149, 1], "end": [163, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.IsAntichain.disjoint_slice_shadow_falling", "code": "theorem IsAntichain.disjoint_slice_shadow_falling {m n : \u2115}\n    (h\ud835\udc9c : IsAntichain (\u00b7 \u2286 \u00b7) (\ud835\udc9c : Set (Finset \u03b1))) : Disjoint (\ud835\udc9c # m) (\u2202 (falling n \ud835\udc9c))", "start": [168, 1], "end": [177, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.le_card_falling_div_choose", "code": "theorem le_card_falling_div_choose [Fintype \u03b1] (hk : k \u2264 Fintype.card \u03b1)\n    (h\ud835\udc9c : IsAntichain (\u00b7 \u2286 \u00b7) (\ud835\udc9c : Set (Finset \u03b1))) :\n    (\u2211 r in range (k + 1),\n        ((\ud835\udc9c # (Fintype.card \u03b1 - r)).card : \ud835\udd5c) / (Fintype.card \u03b1).choose (Fintype.card \u03b1 - r)) \u2264\n      (falling (Fintype.card \u03b1 - k) \ud835\udc9c).card / (Fintype.card \u03b1).choose (Fintype.card \u03b1 - k)", "start": [180, 1], "end": [200, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_card_slice_div_choose_le_one", "code": "theorem sum_card_slice_div_choose_le_one [Fintype \u03b1]\n    (h\ud835\udc9c : IsAntichain (\u00b7 \u2286 \u00b7) (\ud835\udc9c : Set (Finset \u03b1))) :\n    (\u2211 r in range (Fintype.card \u03b1 + 1), ((\ud835\udc9c # r).card : \ud835\udd5c) / (Fintype.card \u03b1).choose r) \u2264 1", "start": [207, 1], "end": [219, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.IsAntichain.sperner", "code": "theorem IsAntichain.sperner [Fintype \u03b1] {\ud835\udc9c : Finset (Finset \u03b1)}\n    (h\ud835\udc9c : IsAntichain (\u00b7 \u2286 \u00b7) (\ud835\udc9c : Set (Finset \u03b1))) :\n    \ud835\udc9c.card \u2264 (Fintype.card \u03b1).choose (Fintype.card \u03b1 / 2)", "start": [227, 1], "end": [246, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Wilson.lean", "imports": ["Mathlib/FieldTheory/Finite/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ZMod.wilsons_lemma", "code": "@[simp]\ntheorem wilsons_lemma : ((p - 1)! : ZMod p) = -1", "start": [38, 1], "end": [69, 57], "kind": "commanddeclaration"}, {"full_name": "ZMod.prod_Ico_one_prime", "code": "@[simp]\ntheorem prod_Ico_one_prime : \u220f x in Ico 1 p, (x : ZMod p) = -1", "start": [72, 1], "end": [79, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_of_fac_equiv_neg_one", "code": "theorem prime_of_fac_equiv_neg_one (h : ((n - 1)! : ZMod n) = -1) (h1 : n \u2260 1) : Prime n", "start": [88, 1], "end": [97, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_iff_fac_equiv_neg_one", "code": "theorem prime_iff_fac_equiv_neg_one (h : n \u2260 1) : Prime n \u2194 ((n - 1)! : ZMod n) = -1", "start": [100, 1], "end": [104, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Kernel/Condexp.lean", "imports": ["Mathlib/Probability/Kernel/CondDistrib.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.AEStronglyMeasurable.comp_snd_map_prod_id", "code": "theorem _root_.MeasureTheory.AEStronglyMeasurable.comp_snd_map_prod_id [TopologicalSpace F]\n    (hm : m \u2264 m\u03a9) (hf : AEStronglyMeasurable f \u03bc) : AEStronglyMeasurable (fun x : \u03a9 \u00d7 \u03a9 => f x.2)\n      (@Measure.map \u03a9 (\u03a9 \u00d7 \u03a9) (m.prod m\u03a9) m\u03a9 (fun \u03c9 => (id \u03c9, id \u03c9)) \u03bc)", "start": [44, 1], "end": [49, 11], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.comp_snd_map_prod_id", "code": "theorem _root_.MeasureTheory.Integrable.comp_snd_map_prod_id [NormedAddCommGroup F] (hm : m \u2264 m\u03a9)\n    (hf : Integrable f \u03bc) : Integrable (fun x : \u03a9 \u00d7 \u03a9 => f x.2)\n      (@Measure.map \u03a9 (\u03a9 \u00d7 \u03a9) (m.prod m\u03a9) m\u03a9 (fun \u03c9 => (id \u03c9, id \u03c9)) \u03bc)", "start": [52, 1], "end": [57, 11], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condexpKernel", "code": "noncomputable irreducible_def condexpKernel (\u03bc : Measure \u03a9) [IsFiniteMeasure \u03bc]\n    (m : MeasurableSpace \u03a9) : @kernel \u03a9 \u03a9 m m\u03a9 :=\n  kernel.comap (@condDistrib \u03a9 \u03a9 \u03a9 _ m\u03a9 _ _ _ m\u03a9 (m \u2293 m\u03a9) id id \u03bc _) id\n    (measurable_id'' (inf_le_left : m \u2293 m\u03a9 \u2264 m))", "start": [65, 1], "end": [74, 49], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "ProbabilityTheory.condexpKernel_apply_eq_condDistrib", "code": "lemma condexpKernel_apply_eq_condDistrib :\n    condexpKernel \u03bc m \u03c9 = @condDistrib \u03a9 \u03a9 \u03a9 _ m\u03a9 _ _ _ m\u03a9 (m \u2293 m\u03a9) id id \u03bc _ (id \u03c9) := by\n  simp_rw [condexpKernel, kernel.comap_apply]", "start": [78, 1], "end": [80, 46], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.measurable_condexpKernel", "code": "theorem measurable_condexpKernel {s : Set \u03a9} (hs : MeasurableSet s) :\n    Measurable[m] fun \u03c9 => condexpKernel \u03bc m \u03c9 s", "start": [88, 1], "end": [93, 32], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.stronglyMeasurable_condexpKernel", "code": "theorem stronglyMeasurable_condexpKernel {s : Set \u03a9} (hs : MeasurableSet s) :\n    StronglyMeasurable[m] fun \u03c9 => condexpKernel \u03bc m \u03c9 s", "start": [96, 1], "end": [98, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.integral_condexpKernel", "code": "theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_condexpKernel [NormedSpace \u211d F]\n    [CompleteSpace F] (hf : AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (fun \u03c9 => \u222b y, f y \u2202condexpKernel \u03bc m \u03c9) \u03bc", "start": [100, 1], "end": [106, 43], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.aestronglyMeasurable'_integral_condexpKernel", "code": "theorem aestronglyMeasurable'_integral_condexpKernel [NormedSpace \u211d F] [CompleteSpace F]\n    (hf : AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable' m (fun \u03c9 => \u222b y, f y \u2202condexpKernel \u03bc m \u03c9) \u03bc", "start": [109, 1], "end": [117, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.condexpKernel_ae", "code": "theorem _root_.MeasureTheory.Integrable.condexpKernel_ae (hf_int : Integrable f \u03bc) :\n    \u2200\u1d50 \u03c9 \u2202\u03bc, Integrable f (condexpKernel \u03bc m \u03c9)", "start": [126, 1], "end": [131, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.integral_norm_condexpKernel", "code": "theorem _root_.MeasureTheory.Integrable.integral_norm_condexpKernel (hf_int : Integrable f \u03bc) :\n    Integrable (fun \u03c9 => \u222b y, \u2016f y\u2016 \u2202condexpKernel \u03bc m \u03c9) \u03bc", "start": [134, 1], "end": [139, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.norm_integral_condexpKernel", "code": "theorem _root_.MeasureTheory.Integrable.norm_integral_condexpKernel [NormedSpace \u211d F]\n    [CompleteSpace F] (hf_int : Integrable f \u03bc) :\n    Integrable (fun \u03c9 => \u2016\u222b y, f y \u2202condexpKernel \u03bc m \u03c9\u2016) \u03bc", "start": [142, 1], "end": [148, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.integral_condexpKernel", "code": "theorem _root_.MeasureTheory.Integrable.integral_condexpKernel [NormedSpace \u211d F] [CompleteSpace F]\n    (hf_int : Integrable f \u03bc) :\n    Integrable (fun \u03c9 => \u222b y, f y \u2202condexpKernel \u03bc m \u03c9) \u03bc", "start": [151, 1], "end": [157, 63], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.integrable_toReal_condexpKernel", "code": "theorem integrable_toReal_condexpKernel {s : Set \u03a9} (hs : MeasurableSet s) :\n    Integrable (fun \u03c9 => (condexpKernel \u03bc m \u03c9 s).toReal) \u03bc", "start": [160, 1], "end": [163, 92], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condexpKernel_ae_eq_condexp'", "code": "lemma condexpKernel_ae_eq_condexp' [IsFiniteMeasure \u03bc] {s : Set \u03a9} (hs : MeasurableSet s) :\n    (fun \u03c9 \u21a6 (condexpKernel \u03bc m \u03c9 s).toReal) =\u1d50[\u03bc] \u03bc\u27e6s | m \u2293 m\u03a9\u27e7 := by\n  have h := condDistrib_ae_eq_condexp (\u03bc := \u03bc)\n    (measurable_id'' (inf_le_right : m \u2293 m\u03a9 \u2264 m\u03a9)) measurable_id hs\n  simp only [id_eq, ge_iff_le, MeasurableSpace.comap_id, preimage_id_eq] at h\n  simp_rw [condexpKernel_apply_eq_condDistrib]\n  exact h", "start": [168, 1], "end": [174, 10], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.condexpKernel_ae_eq_condexp", "code": "lemma condexpKernel_ae_eq_condexp [IsFiniteMeasure \u03bc]\n    (hm : m \u2264 m\u03a9) {s : Set \u03a9} (hs : MeasurableSet s) :\n    (fun \u03c9 \u21a6 (condexpKernel \u03bc m \u03c9 s).toReal) =\u1d50[\u03bc] \u03bc\u27e6s | m\u27e7 :=\n  (condexpKernel_ae_eq_condexp' hs).trans (by rw [inf_of_le_left hm])", "start": [176, 1], "end": [179, 70], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.condexpKernel_ae_eq_trim_condexp", "code": "lemma condexpKernel_ae_eq_trim_condexp [IsFiniteMeasure \u03bc]\n    (hm : m \u2264 m\u03a9) {s : Set \u03a9} (hs : MeasurableSet s) :\n    (fun \u03c9 \u21a6 (condexpKernel \u03bc m \u03c9 s).toReal) =\u1d50[\u03bc.trim hm] \u03bc\u27e6s | m\u27e7 := by\n  rw [ae_eq_trim_iff hm _ stronglyMeasurable_condexp]\n  \u00b7 exact condexpKernel_ae_eq_condexp hm hs\n  \u00b7 refine Measurable.stronglyMeasurable ?_\n    exact @Measurable.ennreal_toReal _ m _ (measurable_condexpKernel hs)", "start": [181, 1], "end": [187, 73], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.condexp_ae_eq_integral_condexpKernel'", "code": "theorem condexp_ae_eq_integral_condexpKernel' [NormedAddCommGroup F] {f : \u03a9 \u2192 F}\n    [NormedSpace \u211d F] [CompleteSpace F] (hf_int : Integrable f \u03bc) :\n    \u03bc[f|m \u2293 m\u03a9] =\u1d50[\u03bc] fun \u03c9 => \u222b y, f y \u2202condexpKernel \u03bc m \u03c9", "start": [189, 1], "end": [195, 55], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condexp_ae_eq_integral_condexpKernel", "code": "theorem condexp_ae_eq_integral_condexpKernel [NormedAddCommGroup F] {f : \u03a9 \u2192 F}\n    [NormedSpace \u211d F] [CompleteSpace F] (hm : m \u2264 m\u03a9) (hf_int : Integrable f \u03bc) :\n    \u03bc[f|m] =\u1d50[\u03bc] fun \u03c9 => \u222b y, f y \u2202condexpKernel \u03bc m \u03c9", "start": [197, 1], "end": [202, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Intervals/SurjOn.lean", "imports": ["Mathlib/Data/Set/Intervals/Basic.lean", "Mathlib/Data/Set/Function.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "surjOn_Ioo_of_monotone_surjective", "code": "theorem surjOn_Ioo_of_monotone_surjective (h_mono : Monotone f) (h_surj : Function.Surjective f)\n    (a b : \u03b1) : SurjOn f (Ioo a b) (Ioo (f a) (f b))", "start": [26, 1], "end": [32, 68], "kind": "commanddeclaration"}, {"full_name": "surjOn_Ico_of_monotone_surjective", "code": "theorem surjOn_Ico_of_monotone_surjective (h_mono : Monotone f) (h_surj : Function.Surjective f)\n    (a b : \u03b1) : SurjOn f (Ico a b) (Ico (f a) (f b))", "start": [35, 1], "end": [44, 27], "kind": "commanddeclaration"}, {"full_name": "surjOn_Ioc_of_monotone_surjective", "code": "theorem surjOn_Ioc_of_monotone_surjective (h_mono : Monotone f) (h_surj : Function.Surjective f)\n    (a b : \u03b1) : SurjOn f (Ioc a b) (Ioc (f a) (f b))", "start": [47, 1], "end": [49, 89], "kind": "commanddeclaration"}, {"full_name": "surjOn_Icc_of_monotone_surjective", "code": "theorem surjOn_Icc_of_monotone_surjective (h_mono : Monotone f) (h_surj : Function.Surjective f)\n    {a b : \u03b1} (hab : a \u2264 b) : SurjOn f (Icc a b) (Icc (f a) (f b))", "start": [53, 1], "end": [60, 50], "kind": "commanddeclaration"}, {"full_name": "surjOn_Ioi_of_monotone_surjective", "code": "theorem surjOn_Ioi_of_monotone_surjective (h_mono : Monotone f) (h_surj : Function.Surjective f)\n    (a : \u03b1) : SurjOn f (Ioi a) (Ioi (f a))", "start": [63, 1], "end": [67, 39], "kind": "commanddeclaration"}, {"full_name": "surjOn_Iio_of_monotone_surjective", "code": "theorem surjOn_Iio_of_monotone_surjective (h_mono : Monotone f) (h_surj : Function.Surjective f)\n    (a : \u03b1) : SurjOn f (Iio a) (Iio (f a))", "start": [70, 1], "end": [72, 68], "kind": "commanddeclaration"}, {"full_name": "surjOn_Ici_of_monotone_surjective", "code": "theorem surjOn_Ici_of_monotone_surjective (h_mono : Monotone f) (h_surj : Function.Surjective f)\n    (a : \u03b1) : SurjOn f (Ici a) (Ici (f a))", "start": [75, 1], "end": [80, 52], "kind": "commanddeclaration"}, {"full_name": "surjOn_Iic_of_monotone_surjective", "code": "theorem surjOn_Iic_of_monotone_surjective (h_mono : Monotone f) (h_surj : Function.Surjective f)\n    (a : \u03b1) : SurjOn f (Iic a) (Iic (f a))", "start": [83, 1], "end": [85, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Group/LIntegral.lean", "imports": ["Mathlib/MeasureTheory/Group/Measure.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.lintegral_mul_left_eq_self", "code": "@[to_additive\n      \"Translating a function by left-addition does not change its Lebesgue integral with\n      respect to a left-invariant measure.\"]\ntheorem lintegral_mul_left_eq_self [IsMulLeftInvariant \u03bc] (f : G \u2192 \u211d\u22650\u221e) (g : G) :\n    (\u222b\u207b x, f (g * x) \u2202\u03bc) = \u222b\u207b x, f x \u2202\u03bc", "start": [29, 1], "end": [37, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_mul_right_eq_self", "code": "@[to_additive\n      \"Translating a function by right-addition does not change its Lebesgue integral with\n      respect to a right-invariant measure.\"]\ntheorem lintegral_mul_right_eq_self [IsMulRightInvariant \u03bc] (f : G \u2192 \u211d\u22650\u221e) (g : G) :\n    (\u222b\u207b x, f (x * g) \u2202\u03bc) = \u222b\u207b x, f x \u2202\u03bc", "start": [41, 1], "end": [49, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_div_right_eq_self", "code": "@[to_additive] theorem lintegral_div_right_eq_self [IsMulRightInvariant \u03bc] (f : G \u2192 \u211d\u22650\u221e) (g : G) :\n    (\u222b\u207b x, f (x / g) \u2202\u03bc) = \u222b\u207b x, f x \u2202\u03bc", "start": [53, 1], "end": [56, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_eq_zero_of_isMulLeftInvariant", "code": "@[to_additive\n      \"For nonzero regular left invariant measures, the integral of a continuous nonnegative\n      function `f` is 0 iff `f` is 0.\"]\ntheorem lintegral_eq_zero_of_isMulLeftInvariant [Regular \u03bc] (h\u03bc : \u03bc \u2260 0) {f : G \u2192 \u211d\u22650\u221e}\n    (hf : Continuous f) : \u222b\u207b x, f x \u2202\u03bc = 0 \u2194 f = 0", "start": [66, 1], "end": [74, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Option/Lemmas.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Data/Option/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/MeasureTheory/Integral/LebesgueNormedSpace.lean", "imports": ["Mathlib/Analysis/NormedSpace/Basic.lean", "Mathlib/MeasureTheory/Measure/WithDensity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "aemeasurable_withDensity_iff", "code": "theorem aemeasurable_withDensity_iff {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [TopologicalSpace.SecondCountableTopology E] [MeasurableSpace E] [BorelSpace E] {f : \u03b1 \u2192 \u211d\u22650}\n    (hf : Measurable f) {g : \u03b1 \u2192 E} :\n    AEMeasurable g (\u03bc.withDensity fun x => (f x : \u211d\u22650\u221e)) \u2194\n      AEMeasurable (fun x => (f x : \u211d) \u2022 g x) \u03bc", "start": [20, 1], "end": [47, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/ModuleCat/Tannaka.lean", "imports": ["Mathlib/LinearAlgebra/Span.lean", "Mathlib/Algebra/Category/ModuleCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ringEquivEndForget\u2082", "code": "def ringEquivEndForget\u2082 (R : Type u) [Ring R] :\n    R \u2243+* End (AdditiveFunctor.of (forget\u2082 (ModuleCat.{u} R) AddCommGroupCat.{u})) where\n  toFun r :=\n    { app := fun M =>\n        @AddCommGroupCat.ofHom M.carrier M.carrier _ _ (DistribMulAction.toAddMonoidHom M r)\n      naturality := fun M N f => by\n        ext\n        exact (f.map_smul _ _).symm }\n  invFun \u03c6 := \u03c6.app (ModuleCat.of R R) (1 : R)\n  left_inv := by\n    intro r\n    simp\n  right_inv := by\n    intro \u03c6\n    apply NatTrans.ext\n    ext M (x : M)\n    have w := congr_fun ((forget _).congr_map\n      (\u03c6.naturality (ModuleCat.asHomRight (LinearMap.toSpanSingleton R M x)))) (1 : R)\n    exact w.symm.trans (congr_arg (\u03c6.app M) (one_smul R x))\n  map_add' := by\n    intros\n    apply NatTrans.ext\n    ext\n    dsimp\n    simp only [AddCommGroupCat.ofHom_apply, DistribMulAction.toAddMonoidHom_apply, add_smul]\n    rfl\n  map_mul' := by\n    intros\n    apply NatTrans.ext\n    ext\n    dsimp\n    simp only [AddCommGroupCat.ofHom_apply, DistribMulAction.toAddMonoidHom_apply, mul_smul]\n    rfl", "start": [23, 1], "end": [59, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/Algebra/Field/CharP.lean", "imports": ["Mathlib/Data/Nat/Prime.lean", "Mathlib/Algebra/CharP/Basic.lean", "Mathlib/ModelTheory/Algebra/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/ModelTheory/Algebra/Ring/FreeCommRing.lean"], "premises": [{"full_name": "FirstOrder.Field.eqZero", "code": "noncomputable def eqZero (n : \u2115) : Language.ring.Sentence :=\n  Term.equal (termOfFreeCommRing n) 0", "start": [33, 1], "end": [36, 38], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Field.realize_eqZero", "code": "@[simp] theorem realize_eqZero [CommRing K] [CompatibleRing K] (n : \u2115)\n    (v : Empty \u2192 K) : (Formula.Realize (eqZero n) v) \u2194 ((n : K) = 0)", "start": [38, 1], "end": [40, 30], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.fieldOfChar", "code": "def _root_.FirstOrder.Language.Theory.fieldOfChar (p : \u2115) : Language.ring.Theory :=\n  Theory.field \u222a\n  if p = 0\n  then (fun q => \u223c(eqZero q)) '' {q : \u2115 | q.Prime}\n  else if p.Prime then {eqZero p}\n  else {\u22a5}", "start": [42, 1], "end": [48, 11], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Field.model_hasChar_of_charP", "code": "instance model_hasChar_of_charP [Field K] [CompatibleRing K] [CharP K p] :\n    (Theory.fieldOfChar p).Model K := by\n  refine Language.Theory.model_union_iff.2 \u27e8inferInstance, ?_\u27e9\n  cases CharP.char_is_prime_or_zero K p with\n  | inl hp =>\n    simp [hp.ne_zero, hp, Sentence.Realize]\n  | inr hp =>\n    subst hp\n    simp only [ite_false, ite_true, Theory.model_iff, Set.mem_image, Set.mem_setOf_eq,\n      Sentence.Realize, forall_exists_index, and_imp, forall_apply_eq_imp_iff\u2082,\n      Formula.realize_not, realize_eqZero, \u2190 CharZero.charZero_iff_forall_prime_ne_zero]\n    exact CharP.charP_to_charZero K", "start": [50, 1], "end": [61, 36], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Field.charP_iff_model_fieldOfChar", "code": "theorem charP_iff_model_fieldOfChar [Field K] [CompatibleRing K] :\n    (Theory.fieldOfChar p).Model K \u2194 CharP K p", "start": [63, 1], "end": [78, 57], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Field.model_fieldOfChar_of_charP", "code": "instance model_fieldOfChar_of_charP [Field K] [CompatibleRing K]\n    [CharP K p] : (Theory.fieldOfChar p).Model K :=\n  charP_iff_model_fieldOfChar.2 inferInstance", "start": [80, 1], "end": [82, 46], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Field.charP_of_model_fieldOfChar", "code": "theorem charP_of_model_fieldOfChar [Field K] [CompatibleRing K]\n    [h : (Theory.fieldOfChar p).Model K] : CharP K p", "start": [86, 1], "end": [88, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Sym/Card.lean", "imports": ["Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Data/Fintype/Sum.lean", "Mathlib/Data/Finset/Sym.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Sym.e1", "code": "protected def e1 {n k : \u2115} : { s : Sym (Fin (n + 1)) (k + 1) // \u21910 \u2208 s } \u2243 Sym (Fin n.succ) k where\n  toFun s := s.1.erase 0 s.2\n  invFun s := \u27e8cons 0 s, mem_cons_self 0 s\u27e9\n  left_inv s := by simp\n  right_inv s := by simp", "start": [66, 1], "end": [72, 25], "kind": "commanddeclaration"}, {"full_name": "Sym.e2", "code": "protected def e2 {n k : \u2115} : { s : Sym (Fin n.succ.succ) k // \u21910 \u2209 s } \u2243 Sym (Fin n.succ) k where\n  toFun s := map (Fin.predAbove 0) s.1\n  invFun s :=\n    \u27e8map (Fin.succAbove 0) s,\n      (mt mem_map.1) (not_exists.2 fun t => not_and.2 fun _ => Fin.succAbove_ne _ t)\u27e9\n  left_inv s := by\n    ext1\n    simp only [map_map]\n    refine (Sym.map_congr fun v hv \u21a6 ?_).trans (map_id' _)\n    exact Fin.succAbove_predAbove (ne_of_mem_of_not_mem hv s.2)\n  right_inv s := by\n    simp only [map_map, comp_apply, \u2190 Fin.castSucc_zero, Fin.predAbove_succAbove, map_id']", "start": [76, 1], "end": [91, 91], "kind": "commanddeclaration"}, {"full_name": "Sym.card_sym_fin_eq_multichoose", "code": "theorem card_sym_fin_eq_multichoose : \u2200 n k : \u2115, card (Sym (Fin n) k) = multichoose n k", "start": [96, 1], "end": [106, 58], "kind": "commanddeclaration"}, {"full_name": "Sym.card_sym_eq_multichoose", "code": "theorem card_sym_eq_multichoose (\u03b1 : Type*) (k : \u2115) [Fintype \u03b1] [Fintype (Sym \u03b1 k)] :\n    card (Sym \u03b1 k) = multichoose (card \u03b1) k", "start": [109, 1], "end": [113, 45], "kind": "commanddeclaration"}, {"full_name": "Sym.card_sym_eq_choose", "code": "theorem card_sym_eq_choose {\u03b1 : Type*} [Fintype \u03b1] (k : \u2115) [Fintype (Sym \u03b1 k)] :\n    card (Sym \u03b1 k) = (card \u03b1 + k - 1).choose k", "start": [116, 1], "end": [120, 51], "kind": "commanddeclaration"}, {"full_name": "Sym2.card_image_diag", "code": "theorem card_image_diag (s : Finset \u03b1) : (s.diag.image Quotient.mk').card = s.card", "start": [131, 1], "end": [138, 14], "kind": "commanddeclaration"}, {"full_name": "Sym2.two_mul_card_image_offDiag", "code": "theorem two_mul_card_image_offDiag (s : Finset \u03b1) :\n    2 * (s.offDiag.image Quotient.mk').card = s.offDiag.card", "start": [141, 1], "end": [160, 22], "kind": "commanddeclaration"}, {"full_name": "Sym2.card_image_offDiag", "code": "theorem card_image_offDiag (s : Finset \u03b1) :\n    (s.offDiag.image Quotient.mk').card = s.card.choose 2", "start": [163, 1], "end": [169, 80], "kind": "commanddeclaration"}, {"full_name": "Sym2.card_subtype_diag", "code": "theorem card_subtype_diag [Fintype \u03b1] : card { a : Sym2 \u03b1 // a.IsDiag } = card \u03b1", "start": [172, 1], "end": [179, 42], "kind": "commanddeclaration"}, {"full_name": "Sym2.card_subtype_not_diag", "code": "theorem card_subtype_not_diag [Fintype \u03b1] :\n    card { a : Sym2 \u03b1 // \u00aca.IsDiag } = (card \u03b1).choose 2", "start": [182, 1], "end": [190, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.card_sym2", "code": "theorem _root_.Finset.card_sym2 (s : Finset \u03b1) : s.sym2.card = s.card * (s.card + 1) / 2", "start": [193, 1], "end": [205, 34], "kind": "commanddeclaration"}, {"full_name": "Sym2.card", "code": "protected theorem card [Fintype \u03b1] : card (Sym2 \u03b1) = card \u03b1 * (card \u03b1 + 1) / 2", "start": [208, 1], "end": [210, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Adjunction/AdjointFunctorTheorems.lean", "imports": ["Mathlib/CategoryTheory/Limits/FunctorCategory.lean", "Mathlib/CategoryTheory/Limits/ConeCategory.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Subobject/Comma.lean", "Mathlib/CategoryTheory/Generator.lean", "Mathlib/CategoryTheory/Limits/Constructions/WeaklyInitial.lean"], "premises": [{"full_name": "CategoryTheory.SolutionSetCondition", "code": "def SolutionSetCondition {D : Type u} [Category.{v} D] (G : D \u2964 C) : Prop :=\n  \u2200 A : C,\n    \u2203 (\u03b9 : Type v) (B : \u03b9 \u2192 D) (f : \u2200 i : \u03b9, A \u27f6 G.obj (B i)),\n      \u2200 (X) (h : A \u27f6 G.obj X), \u2203 (i : \u03b9) (g : B i \u27f6 X), f i \u226b G.map g = h", "start": [50, 1], "end": [61, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.solutionSetCondition_of_isRightAdjoint", "code": "theorem solutionSetCondition_of_isRightAdjoint [IsRightAdjoint G] : SolutionSetCondition G", "start": [70, 1], "end": [77, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isRightAdjointOfPreservesLimitsOfSolutionSetCondition", "code": "noncomputable def isRightAdjointOfPreservesLimitsOfSolutionSetCondition [HasLimits D]\n    [PreservesLimits G] (hG : SolutionSetCondition G) : IsRightAdjoint G := by\n  refine' @isRightAdjointOfStructuredArrowInitials _ _ _ _ G ?_\n  intro A\n  specialize hG A\n  choose \u03b9 B f g using hG\n  let B' : \u03b9 \u2192 StructuredArrow A G := fun i => StructuredArrow.mk (f i)\n  have hB' : \u2200 A' : StructuredArrow A G, \u2203 i, Nonempty (B' i \u27f6 A') := by\n    intro A'\n    obtain \u27e8i, _, t\u27e9 := g _ A'.hom\n    exact \u27e8i, \u27e8StructuredArrow.homMk _ t\u27e9\u27e9\n  obtain \u27e8T, hT\u27e9 := has_weakly_initial_of_weakly_initial_set_and_hasProducts hB'\n  apply hasInitial_of_weakly_initial_and_hasWideEqualizers hT", "start": [80, 1], "end": [95, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isRightAdjointOfPreservesLimitsOfIsCoseparating", "code": "noncomputable def isRightAdjointOfPreservesLimitsOfIsCoseparating [HasLimits D] [WellPowered D]\n    {\ud835\udca2 : Set D} [Small.{v} \ud835\udca2] (h\ud835\udca2 : IsCoseparating \ud835\udca2) (G : D \u2964 C) [PreservesLimits G] :\n    IsRightAdjoint G :=\n  have : \u2200 A, HasInitial (StructuredArrow A G) := fun A =>\n    hasInitial_of_isCoseparating (StructuredArrow.isCoseparating_proj_preimage A G h\ud835\udca2)\n  isRightAdjointOfStructuredArrowInitials _", "start": [104, 1], "end": [112, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isLeftAdjointOfPreservesColimitsOfIsSeparatig", "code": "noncomputable def isLeftAdjointOfPreservesColimitsOfIsSeparatig [HasColimits C] [WellPowered C\u1d52\u1d56]\n    {\ud835\udca2 : Set C} [Small.{v} \ud835\udca2] (h\ud835\udca2 : IsSeparating \ud835\udca2) (F : C \u2964 D) [PreservesColimits F] :\n    IsLeftAdjoint F :=\n  have : \u2200 A, HasTerminal (CostructuredArrow F A) := fun A =>\n    hasTerminal_of_isSeparating (CostructuredArrow.isSeparating_proj_preimage F A h\ud835\udca2)\n  isLeftAdjointOfCostructuredArrowTerminals _", "start": [115, 1], "end": [123, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimits_of_hasLimits_of_isCoseparating", "code": "theorem hasColimits_of_hasLimits_of_isCoseparating [HasLimits C] [WellPowered C] {\ud835\udca2 : Set C}\n    [Small.{v} \ud835\udca2] (h\ud835\udca2 : IsCoseparating \ud835\udca2) : HasColimits C", "start": [130, 1], "end": [136, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimits_of_hasColimits_of_isSeparating", "code": "theorem hasLimits_of_hasColimits_of_isSeparating [HasColimits C] [WellPowered C\u1d52\u1d56] {\ud835\udca2 : Set C}\n    [Small.{v} \ud835\udca2] (h\ud835\udca2 : IsSeparating \ud835\udca2) : HasLimits C", "start": [139, 1], "end": [145, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Valuation/Quotient.lean", "imports": ["Mathlib/RingTheory/Ideal/QuotientOperations.lean", "Mathlib/RingTheory/Valuation/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Valuation.onQuotVal", "code": "def onQuotVal {J : Ideal R} (hJ : J \u2264 supp v) : R \u29f8 J \u2192 \u0393\u2080 := fun q =>\n  Quotient.liftOn' q v fun a b h =>\n    calc\n      v a = v (b + -(-a + b)) := by simp\n      _ = v b :=\n        v.map_add_supp b <| (Ideal.neg_mem_iff _).2 <| hJ <| QuotientAddGroup.leftRel_apply.mp h", "start": [27, 1], "end": [34, 97], "kind": "commanddeclaration"}, {"full_name": "Valuation.onQuot", "code": "def onQuot {J : Ideal R} (hJ : J \u2264 supp v) : Valuation (R \u29f8 J) \u0393\u2080 where\n  toFun := v.onQuotVal hJ\n  map_zero' := v.map_zero\n  map_one' := v.map_one\n  map_mul' xbar ybar := Quotient.ind\u2082' v.map_mul xbar ybar\n  map_add_le_max' xbar ybar := Quotient.ind\u2082' v.map_add xbar ybar", "start": [37, 1], "end": [43, 66], "kind": "commanddeclaration"}, {"full_name": "Valuation.onQuot_comap_eq", "code": "@[simp]\ntheorem onQuot_comap_eq {J : Ideal R} (hJ : J \u2264 supp v) :\n    (v.onQuot hJ).comap (Ideal.Quotient.mk J) = v", "start": [46, 1], "end": [49, 19], "kind": "commanddeclaration"}, {"full_name": "Valuation.self_le_supp_comap", "code": "theorem self_le_supp_comap (J : Ideal R) (v : Valuation (R \u29f8 J) \u0393\u2080) :\n    J \u2264 (v.comap (Ideal.Quotient.mk J)).supp", "start": [52, 1], "end": [55, 7], "kind": "commanddeclaration"}, {"full_name": "Valuation.comap_onQuot_eq", "code": "@[simp]\ntheorem comap_onQuot_eq (J : Ideal R) (v : Valuation (R \u29f8 J) \u0393\u2080) :\n    (v.comap (Ideal.Quotient.mk J)).onQuot (v.self_le_supp_comap J) = v", "start": [58, 1], "end": [63, 8], "kind": "commanddeclaration"}, {"full_name": "Valuation.supp_quot", "code": "theorem supp_quot {J : Ideal R} (hJ : J \u2264 supp v) :\n    supp (v.onQuot hJ) = (supp v).map (Ideal.Quotient.mk J)", "start": [66, 1], "end": [75, 13], "kind": "commanddeclaration"}, {"full_name": "Valuation.supp_quot_supp", "code": "theorem supp_quot_supp : supp (v.onQuot le_rfl) = 0", "start": [78, 1], "end": [80, 34], "kind": "commanddeclaration"}, {"full_name": "AddValuation.onQuotVal", "code": "def onQuotVal {J : Ideal R} (hJ : J \u2264 supp v) : R \u29f8 J \u2192 \u0393\u2080 :=\n  Valuation.onQuotVal v hJ", "start": [95, 1], "end": [98, 27], "kind": "commanddeclaration"}, {"full_name": "AddValuation.onQuot", "code": "def onQuot {J : Ideal R} (hJ : J \u2264 supp v) : AddValuation (R \u29f8 J) \u0393\u2080 :=\n  Valuation.onQuot v hJ", "start": [101, 1], "end": [103, 24], "kind": "commanddeclaration"}, {"full_name": "AddValuation.onQuot_comap_eq", "code": "@[simp]\ntheorem onQuot_comap_eq {J : Ideal R} (hJ : J \u2264 supp v) :\n    (v.onQuot hJ).comap (Ideal.Quotient.mk J) = v", "start": [106, 1], "end": [109, 33], "kind": "commanddeclaration"}, {"full_name": "AddValuation.comap_supp", "code": "theorem comap_supp {S : Type*} [CommRing S] (f : S \u2192+* R) :\n    supp (v.comap f) = Ideal.comap f v.supp", "start": [112, 1], "end": [114, 27], "kind": "commanddeclaration"}, {"full_name": "AddValuation.self_le_supp_comap", "code": "theorem self_le_supp_comap (J : Ideal R) (v : AddValuation (R \u29f8 J) \u0393\u2080) :\n    J \u2264 (v.comap (Ideal.Quotient.mk J)).supp", "start": [117, 1], "end": [119, 35], "kind": "commanddeclaration"}, {"full_name": "AddValuation.comap_onQuot_eq", "code": "@[simp]\ntheorem comap_onQuot_eq (J : Ideal R) (v : AddValuation (R \u29f8 J) \u0393\u2080) :\n    (v.comap (Ideal.Quotient.mk J)).onQuot (v.self_le_supp_comap J) = v", "start": [122, 1], "end": [125, 32], "kind": "commanddeclaration"}, {"full_name": "AddValuation.supp_quot", "code": "theorem supp_quot {J : Ideal R} (hJ : J \u2264 supp v) :\n    supp (v.onQuot hJ) = (supp v).map (Ideal.Quotient.mk J)", "start": [128, 1], "end": [131, 27], "kind": "commanddeclaration"}, {"full_name": "AddValuation.supp_quot_supp", "code": "theorem supp_quot_supp : supp ((Valuation.onQuot v) le_rfl) = 0", "start": [134, 1], "end": [135, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/IsSepClosed.lean", "imports": ["Mathlib/FieldTheory/IsAlgClosed/AlgebraicClosure.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsSepClosed", "code": "class IsSepClosed : Prop where\n  splits_of_separable : \u2200 p : k[X], p.Separable \u2192 (p.Splits <| RingHom.id k)", "start": [55, 1], "end": [61, 77], "kind": "commanddeclaration"}, {"full_name": "IsSepClosed.splits_codomain", "code": "theorem IsSepClosed.splits_codomain [IsSepClosed K] {f : k \u2192+* K}\n    (p : k[X]) (h : p.Separable) : p.Splits f", "start": [65, 1], "end": [72, 93], "kind": "commanddeclaration"}, {"full_name": "IsSepClosed.splits_domain", "code": "theorem IsSepClosed.splits_domain [IsSepClosed k] {f : k \u2192+* K}\n    (p : k[X]) (h : p.Separable) : p.Splits f", "start": [74, 1], "end": [81, 74], "kind": "commanddeclaration"}, {"full_name": "IsSepClosed.exists_root", "code": "theorem exists_root [IsSepClosed k] (p : k[X]) (hp : p.degree \u2260 0) (hsep : p.Separable) :\n    \u2203 x, IsRoot p x", "start": [85, 1], "end": [87, 70], "kind": "commanddeclaration"}, {"full_name": "IsSepClosed.exists_pow_nat_eq", "code": "theorem exists_pow_nat_eq [IsSepClosed k] (x : k) (n : \u2115) [hn : NeZero (n : k)] :\n    \u2203 z, z ^ n = x", "start": [89, 1], "end": [101, 81], "kind": "commanddeclaration"}, {"full_name": "IsSepClosed.exists_eq_mul_self", "code": "theorem exists_eq_mul_self [IsSepClosed k] (x : k) [h2 : NeZero (2 : k)] : \u2203 z, x = z * z", "start": [103, 1], "end": [105, 18], "kind": "commanddeclaration"}, {"full_name": "IsSepClosed.roots_eq_zero_iff", "code": "theorem roots_eq_zero_iff [IsSepClosed k] {p : k[X]} (hsep : p.Separable) :\n    p.roots = 0 \u2194 p = Polynomial.C (p.coeff 0)", "start": [107, 1], "end": [114, 15], "kind": "commanddeclaration"}, {"full_name": "IsSepClosed.exists_eval\u2082_eq_zero", "code": "theorem exists_eval\u2082_eq_zero [IsSepClosed K] (f : k \u2192+* K)\n    (p : k[X]) (hp : p.degree \u2260 0) (hsep : p.Separable) :\n    \u2203 x, p.eval\u2082 f x = 0", "start": [116, 1], "end": [121, 44], "kind": "commanddeclaration"}, {"full_name": "IsSepClosed.exists_aeval_eq_zero", "code": "theorem exists_aeval_eq_zero [IsSepClosed K] [Algebra k K] (p : k[X])\n    (hp : p.degree \u2260 0) (hsep : p.Separable) : \u2203 x : K, aeval x p = 0", "start": [125, 1], "end": [127, 50], "kind": "commanddeclaration"}, {"full_name": "IsSepClosed.of_exists_root", "code": "theorem of_exists_root (H : \u2200 p : k[X], p.Monic \u2192 Irreducible p \u2192 Separable p \u2192 \u2203 x, p.eval x = 0) :\n    IsSepClosed k", "start": [129, 1], "end": [143, 97], "kind": "commanddeclaration"}, {"full_name": "IsSepClosed.degree_eq_one_of_irreducible", "code": "theorem degree_eq_one_of_irreducible [IsSepClosed k] {p : k[X]}\n    (hp : Irreducible p) (hsep : p.Separable) : p.degree = 1", "start": [145, 1], "end": [147, 81], "kind": "commanddeclaration"}, {"full_name": "IsSepClosed.algebraMap_surjective", "code": "theorem algebraMap_surjective\n    [IsSepClosed k] [Algebra k K] [IsSeparable k K] :\n    Function.Surjective (algebraMap k K)", "start": [151, 1], "end": [162, 84], "kind": "commanddeclaration"}, {"full_name": "IsSepClosure", "code": "class IsSepClosure [Algebra k K] : Prop where\n  sep_closed : IsSepClosed K\n  separable : IsSeparable k K", "start": [168, 1], "end": [171, 30], "kind": "commanddeclaration"}, {"full_name": "isSepClosure_iff", "code": "theorem isSepClosure_iff [Algebra k K] :\n    IsSepClosure k K \u2194 IsSepClosed K \u2227 IsSeparable k K", "start": [175, 1], "end": [177, 45], "kind": "commanddeclaration"}, {"full_name": "IsSepClosure.normal", "code": "instance (priority := 100) IsSepClosure.normal [Algebra k K]\n    [IsSepClosure k K] : Normal k K :=\n  \u27e8fun x => by apply IsIntegral.isAlgebraic; exact IsSepClosure.separable.isIntegral' x,\n    fun x => @IsSepClosed.splits_codomain _ _ _ _ (IsSepClosure.sep_closed k) _ _ (by\n      have : IsSeparable k K := IsSepClosure.separable\n      exact IsSeparable.separable k x)\u27e9", "start": [179, 1], "end": [184, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/DisjointCoproduct.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.CoproductDisjoint", "code": "class CoproductDisjoint (X\u2081 X\u2082 : C) where\n  isInitialOfIsPullbackOfIsCoproduct :\n    \u2200 {X Z} {pX\u2081 : X\u2081 \u27f6 X} {pX\u2082 : X\u2082 \u27f6 X} {f : Z \u27f6 X\u2081} {g : Z \u27f6 X\u2082}\n      (_cX : IsColimit (BinaryCofan.mk pX\u2081 pX\u2082)) {comm : f \u226b pX\u2081 = g \u226b pX\u2082},\n      IsLimit (PullbackCone.mk _ _ comm) \u2192 IsInitial Z\n  mono_inl : \u2200 (X) (X\u2081 : X\u2081 \u27f6 X) (X\u2082 : X\u2082 \u27f6 X) (_cX : IsColimit (BinaryCofan.mk X\u2081 X\u2082)), Mono X\u2081\n  mono_inr : \u2200 (X) (X\u2081 : X\u2081 \u27f6 X) (X\u2082 : X\u2082 \u27f6 X) (_cX : IsColimit (BinaryCofan.mk X\u2081 X\u2082)), Mono X\u2082", "start": [38, 1], "end": [53, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isInitialOfIsPullbackOfIsCoproduct", "code": "def isInitialOfIsPullbackOfIsCoproduct {Z X\u2081 X\u2082 X : C} [CoproductDisjoint X\u2081 X\u2082] {pX\u2081 : X\u2081 \u27f6 X}\n    {pX\u2082 : X\u2082 \u27f6 X} (cX : IsColimit (BinaryCofan.mk pX\u2081 pX\u2082)) {f : Z \u27f6 X\u2081} {g : Z \u27f6 X\u2082}\n    {comm : f \u226b pX\u2081 = g \u226b pX\u2082} (cZ : IsLimit (PullbackCone.mk _ _ comm)) : IsInitial Z :=\n  CoproductDisjoint.isInitialOfIsPullbackOfIsCoproduct cX cZ", "start": [56, 1], "end": [67, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isInitialOfIsPullbackOfCoproduct", "code": "noncomputable def isInitialOfIsPullbackOfCoproduct {Z X\u2081 X\u2082 : C} [HasBinaryCoproduct X\u2081 X\u2082]\n    [CoproductDisjoint X\u2081 X\u2082] {f : Z \u27f6 X\u2081} {g : Z \u27f6 X\u2082}\n    {comm : f \u226b (coprod.inl : X\u2081 \u27f6 _ \u2a3f X\u2082) = g \u226b coprod.inr}\n    (cZ : IsLimit (PullbackCone.mk _ _ comm)) : IsInitial Z :=\n  CoproductDisjoint.isInitialOfIsPullbackOfIsCoproduct (coprodIsCoprod _ _) cZ", "start": [70, 1], "end": [82, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isInitialOfPullbackOfIsCoproduct", "code": "noncomputable def isInitialOfPullbackOfIsCoproduct {X X\u2081 X\u2082 : C} [CoproductDisjoint X\u2081 X\u2082]\n    {pX\u2081 : X\u2081 \u27f6 X} {pX\u2082 : X\u2082 \u27f6 X} [HasPullback pX\u2081 pX\u2082] (cX : IsColimit (BinaryCofan.mk pX\u2081 pX\u2082)) :\n    IsInitial (pullback pX\u2081 pX\u2082) :=\n  CoproductDisjoint.isInitialOfIsPullbackOfIsCoproduct cX (pullbackIsPullback _ _)", "start": [85, 1], "end": [95, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isInitialOfPullbackOfCoproduct", "code": "noncomputable def isInitialOfPullbackOfCoproduct {X\u2081 X\u2082 : C} [HasBinaryCoproduct X\u2081 X\u2082]\n    [CoproductDisjoint X\u2081 X\u2082] [HasPullback (coprod.inl : X\u2081 \u27f6 _ \u2a3f X\u2082) coprod.inr] :\n    IsInitial (pullback (coprod.inl : X\u2081 \u27f6 _ \u2a3f X\u2082) coprod.inr) :=\n  isInitialOfIsPullbackOfCoproduct (pullbackIsPullback _ _)", "start": [98, 1], "end": [104, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CoproductsDisjoint", "code": "class CoproductsDisjoint (C : Type u) [Category.{v} C] where\n  CoproductDisjoint : \u2200 X Y : C, CoproductDisjoint X Y", "start": [115, 1], "end": [117, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.initialMonoClass_of_disjoint_coproducts", "code": "theorem initialMonoClass_of_disjoint_coproducts [CoproductsDisjoint C] : InitialMonoClass C where", "start": [122, 1], "end": [132, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Dynamics/Ergodic/Conservative.lean", "imports": ["Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "Mathlib/Dynamics/Ergodic/MeasurePreserving.lean", "Mathlib/Combinatorics/Pigeonhole.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.Conservative", "code": "structure Conservative (f : \u03b1 \u2192 \u03b1) (\u03bc : Measure \u03b1) extends QuasiMeasurePreserving f \u03bc \u03bc : Prop where\n  exists_mem_image_mem :\n    \u2200 \u2983s\u2984, MeasurableSet s \u2192 \u03bc s \u2260 0 \u2192 \u2203 x \u2208 s, \u2203 (m : _) (_ : m \u2260 0), f^[m] x \u2208 s", "start": [53, 1], "end": [58, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.conservative", "code": "protected theorem MeasurePreserving.conservative [IsFiniteMeasure \u03bc] (h : MeasurePreserving f \u03bc \u03bc) :\n    Conservative f \u03bc", "start": [61, 1], "end": [64, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Conservative.id", "code": "protected theorem id (\u03bc : Measure \u03b1) : Conservative id \u03bc", "start": [69, 1], "end": [74, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Conservative.frequently_measure_inter_ne_zero", "code": "theorem frequently_measure_inter_ne_zero (hf : Conservative f \u03bc) (hs : MeasurableSet s)\n    (h0 : \u03bc s \u2260 0) : \u2203\u1da0 m in atTop, \u03bc (s \u2229 f^[m] \u207b\u00b9' s) \u2260 0", "start": [77, 1], "end": [103, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Conservative.exists_gt_measure_inter_ne_zero", "code": "theorem exists_gt_measure_inter_ne_zero (hf : Conservative f \u03bc) (hs : MeasurableSet s)\n    (h0 : \u03bc s \u2260 0) (N : \u2115) : \u2203 m > N, \u03bc (s \u2229 f^[m] \u207b\u00b9' s) \u2260 0", "start": [106, 1], "end": [113, 15], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Conservative.measure_mem_forall_ge_image_not_mem_eq_zero", "code": "theorem measure_mem_forall_ge_image_not_mem_eq_zero (hf : Conservative f \u03bc) (hs : MeasurableSet s)\n    (n : \u2115) : \u03bc ({ x \u2208 s | \u2200 m \u2265 n, f^[m] x \u2209 s }) = 0", "start": [116, 1], "end": [127, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Conservative.ae_mem_imp_frequently_image_mem", "code": "theorem ae_mem_imp_frequently_image_mem (hf : Conservative f \u03bc) (hs : MeasurableSet s) :\n    \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 \u2203\u1da0 n in atTop, f^[n] x \u2208 s", "start": [130, 1], "end": [137, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Conservative.inter_frequently_image_mem_ae_eq", "code": "theorem inter_frequently_image_mem_ae_eq (hf : Conservative f \u03bc) (hs : MeasurableSet s) :\n    (s \u2229 { x | \u2203\u1da0 n in atTop, f^[n] x \u2208 s } : Set \u03b1) =\u1d50[\u03bc] s", "start": [140, 1], "end": [142, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Conservative.measure_inter_frequently_image_mem_eq", "code": "theorem measure_inter_frequently_image_mem_eq (hf : Conservative f \u03bc) (hs : MeasurableSet s) :\n    \u03bc (s \u2229 { x | \u2203\u1da0 n in atTop, f^[n] x \u2208 s }) = \u03bc s", "start": [145, 1], "end": [147, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Conservative.ae_forall_image_mem_imp_frequently_image_mem", "code": "theorem ae_forall_image_mem_imp_frequently_image_mem (hf : Conservative f \u03bc)\n    (hs : MeasurableSet s) : \u2200\u1d50 x \u2202\u03bc, \u2200 k, f^[k] x \u2208 s \u2192 \u2203\u1da0 n in atTop, f^[n] x \u2208 s", "start": [150, 1], "end": [159, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Conservative.frequently_ae_mem_and_frequently_image_mem", "code": "theorem frequently_ae_mem_and_frequently_image_mem (hf : Conservative f \u03bc) (hs : MeasurableSet s)\n    (h0 : \u03bc s \u2260 0) : \u2203\u1d50 x \u2202\u03bc, x \u2208 s \u2227 \u2203\u1da0 n in atTop, f^[n] x \u2208 s", "start": [162, 1], "end": [167, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Conservative.ae_frequently_mem_of_mem_nhds", "code": "theorem ae_frequently_mem_of_mem_nhds [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1]\n    [OpensMeasurableSpace \u03b1] {f : \u03b1 \u2192 \u03b1} {\u03bc : Measure \u03b1} (h : Conservative f \u03bc) :\n    \u2200\u1d50 x \u2202\u03bc, \u2200 s \u2208 \ud835\udcdd x, \u2203\u1da0 n in atTop, f^[n] x \u2208 s", "start": [170, 1], "end": [180, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Conservative.iterate", "code": "protected theorem iterate (hf : Conservative f \u03bc) (n : \u2115) : Conservative f^[n] \u03bc", "start": [183, 1], "end": [204, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Henselian.lean", "imports": ["Mathlib/Data/Polynomial/Taylor.lean", "Mathlib/RingTheory/Ideal/LocalRing.lean", "Mathlib/LinearAlgebra/AdicCompletion.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "isLocalRingHom_of_le_jacobson_bot", "code": "theorem isLocalRingHom_of_le_jacobson_bot {R : Type*} [CommRing R] (I : Ideal R)\n    (h : I \u2264 Ideal.jacobson \u22a5) : IsLocalRingHom (Ideal.Quotient.mk I)", "start": [65, 1], "end": [82, 13], "kind": "commanddeclaration"}, {"full_name": "HenselianRing", "code": "class HenselianRing (R : Type*) [CommRing R] (I : Ideal R) : Prop where\n  jac : I \u2264 Ideal.jacobson \u22a5\n  is_henselian :\n    \u2200 (f : R[X]) (_ : f.Monic) (a\u2080 : R) (_ : f.eval a\u2080 \u2208 I)\n      (_ : IsUnit (Ideal.Quotient.mk I (f.derivative.eval a\u2080))), \u2203 a : R, f.IsRoot a \u2227 a - a\u2080 \u2208 I", "start": [85, 1], "end": [97, 98], "kind": "commanddeclaration"}, {"full_name": "HenselianLocalRing", "code": "class HenselianLocalRing (R : Type*) [CommRing R] extends LocalRing R : Prop where\n  is_henselian :\n    \u2200 (f : R[X]) (_ : f.Monic) (a\u2080 : R) (_ : f.eval a\u2080 \u2208 maximalIdeal R)\n      (_ : IsUnit (f.derivative.eval a\u2080)), \u2203 a : R, f.IsRoot a \u2227 a - a\u2080 \u2208 maximalIdeal R", "start": [100, 1], "end": [111, 89], "kind": "commanddeclaration"}, {"full_name": "Field.henselian", "code": "instance (priority := 100) Field.henselian (K : Type*) [Field K] : HenselianLocalRing K where\n  is_henselian f _ a\u2080 h\u2081 _ := by\n    simp only [(maximalIdeal K).eq_bot_of_prime, Ideal.mem_bot] at h\u2081 \u22a2\n    exact \u27e8a\u2080, h\u2081, sub_self _\u27e9", "start": [115, 1], "end": [118, 31], "kind": "commanddeclaration"}, {"full_name": "HenselianLocalRing.TFAE", "code": "theorem HenselianLocalRing.TFAE (R : Type u) [CommRing R] [LocalRing R] :\n    TFAE\n      [HenselianLocalRing R,\n        \u2200 (f : R[X]) (_ : f.Monic) (a\u2080 : ResidueField R) (_ : aeval a\u2080 f = 0)\n          (_ : aeval a\u2080 (derivative f) \u2260 0), \u2203 a : R, f.IsRoot a \u2227 residue R a = a\u2080,\n        \u2200 {K : Type u} [Field K],\n          \u2200 (\u03c6 : R \u2192+* K) (_ : Surjective \u03c6) (f : R[X]) (_ : f.Monic) (a\u2080 : K)\n            (_ : f.eval\u2082 \u03c6 a\u2080 = 0) (_ : f.derivative.eval\u2082 \u03c6 a\u2080 \u2260 0),\n            \u2203 a : R, f.IsRoot a \u2227 \u03c6 a = a\u2080]", "start": [121, 1], "end": [156, 14], "kind": "commanddeclaration"}, {"full_name": "IsAdicComplete.henselianRing", "code": "instance (priority := 100) IsAdicComplete.henselianRing (R : Type*) [CommRing R] (I : Ideal R)\n    [IsAdicComplete I R] : HenselianRing R I where\n  jac := IsAdicComplete.le_jacobson_bot _\n  is_henselian := by\n    intro f _ a\u2080 h\u2081 h\u2082\n    classical\n      let f' := derivative f\n      let c : \u2115 \u2192 R := fun n => Nat.recOn n a\u2080 fun _ b => b - f.eval b * Ring.inverse (f'.eval b)\n      have hc : \u2200 n, c (n + 1) = c n - f.eval (c n) * Ring.inverse (f'.eval (c n)) := by\n        intro n\n        simp only [Nat.rec_add_one]\n      have hc_mod : \u2200 n, c n \u2261 a\u2080 [SMOD I] := by\n        intro n\n        induction' n with n ih\n        \u00b7 rfl\n        rw [Nat.succ_eq_add_one, hc, sub_eq_add_neg, \u2190 add_zero a\u2080]\n        refine' ih.add _\n        rw [SModEq.zero, Ideal.neg_mem_iff]\n        refine' I.mul_mem_right _ _\n        rw [\u2190 SModEq.zero] at h\u2081 \u22a2\n        exact (ih.eval f).trans h\u2081\n      have hf'c : \u2200 n, IsUnit (f'.eval (c n)) := by\n        intro n\n        haveI := isLocalRingHom_of_le_jacobson_bot I (IsAdicComplete.le_jacobson_bot I)\n        apply isUnit_of_map_unit (Ideal.Quotient.mk I)\n        convert h\u2082 using 1\n        exact SModEq.def.mp ((hc_mod n).eval _)\n      have hfcI : \u2200 n, f.eval (c n) \u2208 I ^ (n + 1) := by\n        intro n\n        induction' n with n ih\n        \u00b7 simpa only [Nat.zero_eq, Nat.rec_zero, zero_add, pow_one] using h\u2081\n        rw [Nat.succ_eq_add_one, \u2190 taylor_eval_sub (c n), hc, sub_eq_add_neg, sub_eq_add_neg,\n          add_neg_cancel_comm]\n        rw [eval_eq_sum, sum_over_range' _ _ _ (lt_add_of_pos_right _ zero_lt_two), \u2190\n          Finset.sum_range_add_sum_Ico _ (Nat.le_add_left _ _)]\n        swap\n        \u00b7 intro i\n          rw [zero_mul]\n        refine' Ideal.add_mem _ _ _\n        \u00b7 erw [Finset.sum_range_succ]\n          rw [Finset.range_one, Finset.sum_singleton,\n            taylor_coeff_zero, taylor_coeff_one, pow_zero, pow_one, mul_one, mul_neg,\n            mul_left_comm, Ring.mul_inverse_cancel _ (hf'c n), mul_one, add_neg_self]\n          exact Ideal.zero_mem _\n        \u00b7 refine' Submodule.sum_mem _ _\n          simp only [Finset.mem_Ico]\n          rintro i \u27e8h2i, _\u27e9\n          have aux : n + 2 \u2264 i * (n + 1) := by trans 2 * (n + 1) <;> nlinarith only [h2i]\n          refine' Ideal.mul_mem_left _ _ (Ideal.pow_le_pow aux _)\n          rw [pow_mul']\n          refine' Ideal.pow_mem_pow ((Ideal.neg_mem_iff _).2 <| Ideal.mul_mem_right _ _ ih) _\n      have aux : \u2200 m n, m \u2264 n \u2192 c m \u2261 c n [SMOD (I ^ m \u2022 \u22a4 : Ideal R)] := by\n        intro m n hmn\n        rw [\u2190 Ideal.one_eq_top, Ideal.smul_eq_mul, mul_one]\n        obtain \u27e8k, rfl\u27e9 := Nat.exists_eq_add_of_le hmn\n        clear hmn\n        induction' k with k ih\n        \u00b7 rw [Nat.zero_eq, add_zero]\n        rw [Nat.succ_eq_add_one, \u2190 add_assoc, hc, \u2190 add_zero (c m), sub_eq_add_neg]\n        refine' ih.add _\n        symm\n        rw [SModEq.zero, Ideal.neg_mem_iff]\n        refine' Ideal.mul_mem_right _ _ (Ideal.pow_le_pow _ (hfcI _))\n        rw [add_assoc]\n        exact le_self_add\n      obtain \u27e8a, ha\u27e9 := IsPrecomplete.prec' c (aux _ _)\n      refine' \u27e8a, _, _\u27e9\n      \u00b7 show f.IsRoot a\n        suffices \u2200 n, f.eval a \u2261 0 [SMOD (I ^ n \u2022 \u22a4 : Ideal R)] by exact IsHausdorff.haus' _ this\n        intro n\n        specialize ha n\n        rw [\u2190 Ideal.one_eq_top, Ideal.smul_eq_mul, mul_one] at ha \u22a2\n        refine' (ha.symm.eval f).trans _\n        rw [SModEq.zero]\n        exact Ideal.pow_le_pow le_self_add (hfcI _)\n      \u00b7 show a - a\u2080 \u2208 I\n        specialize ha 1\n        rw [hc, pow_one, \u2190 Ideal.one_eq_top, Ideal.smul_eq_mul, mul_one, sub_eq_add_neg] at ha\n        rw [\u2190 SModEq.sub_mem, \u2190 add_zero a\u2080]\n        refine' ha.symm.trans (SModEq.rfl.add _)\n        rw [SModEq.zero, Ideal.neg_mem_iff]\n        exact Ideal.mul_mem_right _ _ h\u2081", "start": [174, 1], "end": [265, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/StronglyRegular.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Basic.lean", "Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Combinatorics/DoubleCounting.lean", "Mathlib/Data/Set/Finite.lean"], "premises": [{"full_name": "SimpleGraph.IsSRGWith", "code": "structure IsSRGWith (n k \u2113 \u03bc : \u2115) : Prop where\n  card : Fintype.card V = n\n  regular : G.IsRegularOfDegree k\n  of_adj : \u2200 v w : V, G.Adj v w \u2192 Fintype.card (G.commonNeighbors v w) = \u2113\n  of_not_adj : \u2200 v w : V, v \u2260 w \u2192 \u00acG.Adj v w \u2192 Fintype.card (G.commonNeighbors v w) = \u03bc", "start": [43, 1], "end": [53, 88], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.bot_strongly_regular", "code": "theorem bot_strongly_regular : (\u22a5 : SimpleGraph V).IsSRGWith (Fintype.card V) 0 \u2113 0 where", "start": [59, 1], "end": [68, 31], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsSRGWith.top", "code": "theorem IsSRGWith.top :\n    (\u22a4 : SimpleGraph V).IsSRGWith (Fintype.card V) (Fintype.card V - 1) (Fintype.card V - 2) \u03bc where", "start": [71, 1], "end": [80, 68], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsSRGWith.card_neighborFinset_union_eq", "code": "theorem IsSRGWith.card_neighborFinset_union_eq {v w : V} (h : G.IsSRGWith n k \u2113 \u03bc) :\n    (G.neighborFinset v \u222a G.neighborFinset w).card =\n      2 * k - Fintype.card (G.commonNeighbors v w)", "start": [84, 1], "end": [95, 40], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsSRGWith.card_neighborFinset_union_of_not_adj", "code": "theorem IsSRGWith.card_neighborFinset_union_of_not_adj {v w : V} (h : G.IsSRGWith n k \u2113 \u03bc)\n    (hne : v \u2260 w) (ha : \u00acG.Adj v w) :\n    (G.neighborFinset v \u222a G.neighborFinset w).card = 2 * k - \u03bc", "start": [99, 1], "end": [106, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsSRGWith.card_neighborFinset_union_of_adj", "code": "theorem IsSRGWith.card_neighborFinset_union_of_adj {v w : V} (h : G.IsSRGWith n k \u2113 \u03bc)\n    (ha : G.Adj v w) : (G.neighborFinset v \u222a G.neighborFinset w).card = 2 * k - \u2113", "start": [110, 1], "end": [113, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.compl_neighborFinset_sdiff_inter_eq", "code": "theorem compl_neighborFinset_sdiff_inter_eq {v w : V} :\n    (G.neighborFinset v)\u1d9c \\ {v} \u2229 ((G.neighborFinset w)\u1d9c \\ {w}) =\n      ((G.neighborFinset v)\u1d9c \u2229 (G.neighborFinset w)\u1d9c) \\ ({w} \u222a {v})", "start": [117, 1], "end": [122, 57], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.sdiff_compl_neighborFinset_inter_eq", "code": "theorem sdiff_compl_neighborFinset_inter_eq {v w : V} (h : G.Adj v w) :\n    ((G.neighborFinset v)\u1d9c \u2229 (G.neighborFinset w)\u1d9c) \\ ({w} \u222a {v}) =\n      (G.neighborFinset v)\u1d9c \u2229 (G.neighborFinset w)\u1d9c", "start": [125, 1], "end": [134, 19], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsSRGWith.compl_is_regular", "code": "theorem IsSRGWith.compl_is_regular (h : G.IsSRGWith n k \u2113 \u03bc) :\n    G\u1d9c.IsRegularOfDegree (n - k - 1)", "start": [137, 1], "end": [140, 24], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsSRGWith.card_commonNeighbors_eq_of_adj_compl", "code": "theorem IsSRGWith.card_commonNeighbors_eq_of_adj_compl (h : G.IsSRGWith n k \u2113 \u03bc) {v w : V}\n    (ha : G\u1d9c.Adj v w) : Fintype.card (G\u1d9c.commonNeighbors v w) = n - (2 * k - \u03bc) - 2", "start": [144, 1], "end": [156, 55], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsSRGWith.card_commonNeighbors_eq_of_not_adj_compl", "code": "theorem IsSRGWith.card_commonNeighbors_eq_of_not_adj_compl (h : G.IsSRGWith n k \u2113 \u03bc) {v w : V}\n    (hn : v \u2260 w) (hna : \u00acG\u1d9c.Adj v w) :\n    Fintype.card (G\u1d9c.commonNeighbors v w) = n - (2 * k - \u2113)", "start": [160, 1], "end": [168, 87], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsSRGWith.compl", "code": "theorem IsSRGWith.compl (h : G.IsSRGWith n k \u2113 \u03bc) :\n    G\u1d9c.IsSRGWith n (n - k - 1) (n - (2 * k - \u03bc) - 2) (n - (2 * k - \u2113)) where", "start": [172, 1], "end": [178, 86], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsSRGWith.param_eq", "code": "theorem IsSRGWith.param_eq (h : G.IsSRGWith n k \u2113 \u03bc) (hn : 0 < n) :\n    k * (k - \u2113 - 1) = (n - k - 1) * \u03bc", "start": [182, 1], "end": [211, 11], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsSRGWith.matrix_eq", "code": "theorem IsSRGWith.matrix_eq {\u03b1 : Type*} [Semiring \u03b1] (h : G.IsSRGWith n k \u2113 \u03bc) :\n    G.adjMatrix \u03b1 ^ 2 = k \u2022 (1 : Matrix V V \u03b1) + \u2113 \u2022 G.adjMatrix \u03b1 + \u03bc \u2022 G\u1d9c.adjMatrix \u03b1", "start": [213, 1], "end": [230, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/DoubleCoset.lean", "imports": ["Mathlib/GroupTheory/Coset.lean", "Mathlib/GroupTheory/Subgroup/Basic.lean", "Mathlib/Data/Setoid/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/Subgroup/Pointwise.lean", "Mathlib/Data/Set/Basic.lean"], "premises": [{"full_name": "Doset.doset", "code": "def doset (a : \u03b1) (s t : Set \u03b1) : Set \u03b1 :=\n  s * {a} * t", "start": [36, 1], "end": [38, 14], "kind": "commanddeclaration"}, {"full_name": "Doset.mem_doset", "code": "theorem mem_doset {s t : Set \u03b1} {a b : \u03b1} : b \u2208 doset a s t \u2194 \u2203 x \u2208 s, \u2203 y \u2208 t, b = x * a * y", "start": [41, 1], "end": [43, 50], "kind": "commanddeclaration"}, {"full_name": "Doset.mem_doset_self", "code": "theorem mem_doset_self (H K : Subgroup G) (a : G) : a \u2208 doset a H K", "start": [46, 1], "end": [47, 92], "kind": "commanddeclaration"}, {"full_name": "Doset.doset_eq_of_mem", "code": "theorem doset_eq_of_mem {H K : Subgroup G} {a b : G} (hb : b \u2208 doset a H K) :\n    doset b H K = doset a H K", "start": [50, 1], "end": [55, 40], "kind": "commanddeclaration"}, {"full_name": "Doset.mem_doset_of_not_disjoint", "code": "theorem mem_doset_of_not_disjoint {H K : Subgroup G} {a b : G}\n    (h : \u00acDisjoint (doset a H K) (doset b H K)) : b \u2208 doset a H K", "start": [58, 1], "end": [64, 101], "kind": "commanddeclaration"}, {"full_name": "Doset.eq_of_not_disjoint", "code": "theorem eq_of_not_disjoint {H K : Subgroup G} {a b : G}\n    (h : \u00acDisjoint (doset a H K) (doset b H K)) : doset a H K = doset b H K", "start": [67, 1], "end": [71, 27], "kind": "commanddeclaration"}, {"full_name": "Doset.setoid", "code": "def setoid (H K : Set G) : Setoid G :=\n  Setoid.ker fun x => doset x H K", "start": [74, 1], "end": [76, 34], "kind": "commanddeclaration"}, {"full_name": "Doset.Quotient", "code": "def Quotient (H K : Set G) : Type _ :=\n  _root_.Quotient (setoid H K)", "start": [79, 1], "end": [81, 31], "kind": "commanddeclaration"}, {"full_name": "Doset.rel_iff", "code": "theorem rel_iff {H K : Subgroup G} {x y : G} :\n    (setoid \u2191H \u2191K).Rel x y \u2194 \u2203 a \u2208 H, \u2203 b \u2208 K, y = a * x * b", "start": [84, 1], "end": [88, 14], "kind": "commanddeclaration"}, {"full_name": "Doset.bot_rel_eq_leftRel", "code": "theorem bot_rel_eq_leftRel (H : Subgroup G) :\n    (setoid \u2191(\u22a5 : Subgroup G) \u2191H).Rel = (QuotientGroup.leftRel H).Rel", "start": [91, 1], "end": [100, 69], "kind": "commanddeclaration"}, {"full_name": "Doset.rel_bot_eq_right_group_rel", "code": "theorem rel_bot_eq_right_group_rel (H : Subgroup G) :\n    (setoid \u2191H \u2191(\u22a5 : Subgroup G)).Rel = (QuotientGroup.rightRel H).Rel", "start": [103, 1], "end": [112, 70], "kind": "commanddeclaration"}, {"full_name": "Doset.quotToDoset", "code": "def quotToDoset (H K : Subgroup G) (q : Quotient (H : Set G) K) : Set G :=\n  doset q.out' H K", "start": [115, 1], "end": [117, 19], "kind": "commanddeclaration"}, {"full_name": "Doset.mk", "code": "abbrev mk (H K : Subgroup G) (a : G) : Quotient (H : Set G) K :=\n  Quotient.mk'' a", "start": [120, 1], "end": [122, 18], "kind": "commanddeclaration"}, {"full_name": "Doset.eq", "code": "theorem eq (H K : Subgroup G) (a b : G) :\n    mk H K a = mk H K b \u2194 \u2203 h \u2208 H, \u2203 k \u2208 K, b = h * a * k", "start": [128, 1], "end": [131, 16], "kind": "commanddeclaration"}, {"full_name": "Doset.out_eq'", "code": "theorem out_eq' (H K : Subgroup G) (q : Quotient \u2191H \u2191K) : mk H K q.out' = q", "start": [134, 1], "end": [135, 21], "kind": "commanddeclaration"}, {"full_name": "Doset.mk_out'_eq_mul", "code": "theorem mk_out'_eq_mul (H K : Subgroup G) (g : G) :\n    \u2203 h k : G, h \u2208 H \u2227 k \u2208 K \u2227 (mk H K g : Quotient \u2191H \u2191K).out' = h * g * k", "start": [138, 1], "end": [144, 24], "kind": "commanddeclaration"}, {"full_name": "Doset.mk_eq_of_doset_eq", "code": "theorem mk_eq_of_doset_eq {H K : Subgroup G} {a b : G} (h : doset a H K = doset b H K) :\n    mk H K a = mk H K b", "start": [147, 1], "end": [150, 53], "kind": "commanddeclaration"}, {"full_name": "Doset.disjoint_out'", "code": "theorem disjoint_out' {H K : Subgroup G} {a b : Quotient H.1 K} :\n    a \u2260 b \u2192 Disjoint (doset a.out' H K) (doset b.out' (H : Set G) K)", "start": [153, 1], "end": [157, 65], "kind": "commanddeclaration"}, {"full_name": "Doset.union_quotToDoset", "code": "theorem union_quotToDoset (H K : Subgroup G) : \u22c3 q, quotToDoset H K q = Set.univ", "start": [160, 1], "end": [167, 92], "kind": "commanddeclaration"}, {"full_name": "Doset.doset_union_rightCoset", "code": "theorem doset_union_rightCoset (H K : Subgroup G) (a : G) :\n    \u22c3 k : K, rightCoset (\u2191H) (a * k) = doset a H K", "start": [170, 1], "end": [181, 76], "kind": "commanddeclaration"}, {"full_name": "Doset.doset_union_leftCoset", "code": "theorem doset_union_leftCoset (H K : Subgroup G) (a : G) :\n    \u22c3 h : H, leftCoset (h * a : G) K = doset a H K", "start": [184, 1], "end": [194, 99], "kind": "commanddeclaration"}, {"full_name": "Doset.left_bot_eq_left_quot", "code": "theorem left_bot_eq_left_quot (H : Subgroup G) :\n    Quotient (\u22a5 : Subgroup G).1 (H : Set G) = (G \u29f8 H)", "start": [197, 1], "end": [203, 6], "kind": "commanddeclaration"}, {"full_name": "Doset.right_bot_eq_right_quot", "code": "theorem right_bot_eq_right_quot (H : Subgroup G) :\n    Quotient (H.1 : Set G) (\u22a5 : Subgroup G) = _root_.Quotient (QuotientGroup.rightRel H)", "start": [206, 1], "end": [212, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Int.lean", "imports": ["Mathlib/Analysis/Normed/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.nnnorm_coe_units", "code": "theorem nnnorm_coe_units (e : \u2124\u02e3) : \u2016(e : \u2124)\u2016\u208a = 1", "start": [26, 1], "end": [28, 73], "kind": "commanddeclaration"}, {"full_name": "Int.norm_coe_units", "code": "theorem norm_coe_units (e : \u2124\u02e3) : \u2016(e : \u2124)\u2016 = 1", "start": [31, 1], "end": [32, 54], "kind": "commanddeclaration"}, {"full_name": "Int.nnnorm_coe_nat", "code": "@[simp]\ntheorem nnnorm_coe_nat (n : \u2115) : \u2016(n : \u2124)\u2016\u208a = n", "start": [35, 1], "end": [37, 24], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_add_toNat_neg_eq_nnnorm", "code": "@[simp]\ntheorem toNat_add_toNat_neg_eq_nnnorm (n : \u2124) : \u2191n.toNat + \u2191(-n).toNat = \u2016n\u2016\u208a", "start": [40, 1], "end": [42, 72], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_add_toNat_neg_eq_norm", "code": "@[simp]\ntheorem toNat_add_toNat_neg_eq_norm (n : \u2124) : \u2191n.toNat + \u2191(-n).toNat = \u2016n\u2016", "start": [45, 1], "end": [48, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/DilationEquiv.lean", "imports": ["Mathlib/Topology/MetricSpace/Dilation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DilationEquivClass", "code": "class DilationEquivClass extends EquivLike F X Y where\n  edist_eq' : \u2200 f : F, \u2203 r : \u211d\u22650, r \u2260 0 \u2227 \u2200 x y : X, edist (f x) (f y) = r * edist x y", "start": [30, 1], "end": [33, 87], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv", "code": "structure DilationEquiv (X Y : Type*) [PseudoEMetricSpace X] [PseudoEMetricSpace Y]\n    extends X \u2243 Y, Dilation X Y", "start": [40, 1], "end": [43, 32], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.coe_toEquiv", "code": "@[simp] theorem coe_toEquiv (e : X \u2243\u1d48 Y) : \u21d1e.toEquiv = e", "start": [64, 1], "end": [64, 65], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.ext", "code": "@[ext]\nprotected theorem ext {e e' : X \u2243\u1d48 Y} (h : \u2200 x, e x = e' x) : e = e'", "start": [66, 1], "end": [68, 20], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.symm", "code": "def symm (e : X \u2243\u1d48 Y) : Y \u2243\u1d48 X where\n  toEquiv := e.1.symm\n  edist_eq' := by\n    refine \u27e8(ratio e)\u207b\u00b9, inv_ne_zero <| ratio_ne_zero e, e.surjective.forall\u2082.2 fun x y \u21a6 ?_\u27e9\n    simp_rw [Equiv.toFun_as_coe, Equiv.symm_apply_apply, coe_toEquiv, edist_eq]\n    rw [\u2190 mul_assoc, \u2190 ENNReal.coe_mul, inv_mul_cancel (ratio_ne_zero e),\n      ENNReal.coe_one, one_mul]", "start": [70, 1], "end": [77, 32], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.symm_symm", "code": "@[simp] theorem symm_symm (e : X \u2243\u1d48 Y) : e.symm.symm = e", "start": [79, 1], "end": [79, 64], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.apply_symm_apply", "code": "@[simp] theorem apply_symm_apply (e : X \u2243\u1d48 Y) (x : Y) : e (e.symm x) = x", "start": [80, 1], "end": [80, 90], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.symm_apply_apply", "code": "@[simp] theorem symm_apply_apply (e : X \u2243\u1d48 Y) (x : X) : e.symm (e x) = x", "start": [81, 1], "end": [81, 89], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.Simps.symm_apply", "code": "def Simps.symm_apply (e : X \u2243\u1d48 Y) : Y \u2192 X := e.symm", "start": [83, 1], "end": [84, 52], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.refl", "code": "@[simps! (config := .asFn) apply]\ndef refl (X : Type*) [PseudoEMetricSpace X] : X \u2243\u1d48 X where\n  toEquiv := .refl X\n  edist_eq' := \u27e81, one_ne_zero, fun _ _ \u21a6 by simp\u27e9", "start": [88, 1], "end": [92, 51], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.refl_symm", "code": "@[simp] theorem refl_symm : (refl X).symm = refl X", "start": [94, 1], "end": [94, 58], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.ratio_refl", "code": "@[simp] theorem ratio_refl : ratio (refl X) = 1", "start": [95, 1], "end": [95, 69], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.trans", "code": "@[simps! (config := .asFn) apply]\ndef trans (e\u2081 : X \u2243\u1d48 Y) (e\u2082 : Y \u2243\u1d48 Z) : X \u2243\u1d48 Z where\n  toEquiv := e\u2081.1.trans e\u2082.1\n  __ := e\u2082.toDilation.comp e\u2081.toDilation", "start": [97, 1], "end": [101, 41], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.refl_trans", "code": "@[simp] theorem refl_trans (e : X \u2243\u1d48 Y) : (refl X).trans e = e", "start": [103, 1], "end": [103, 70], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.trans_refl", "code": "@[simp] theorem trans_refl (e : X \u2243\u1d48 Y) : e.trans (refl Y) = e", "start": [104, 1], "end": [104, 70], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.symm_trans_self", "code": "@[simp] theorem symm_trans_self (e : X \u2243\u1d48 Y) : e.symm.trans e = refl Y", "start": [106, 1], "end": [107, 39], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.self_trans_symm", "code": "@[simp] theorem self_trans_symm (e : X \u2243\u1d48 Y) : e.trans e.symm = refl X", "start": [109, 1], "end": [110, 39], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.surjective", "code": "protected theorem surjective (e : X \u2243\u1d48 Y) : Surjective e", "start": [112, 1], "end": [112, 75], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.bijective", "code": "protected theorem bijective (e : X \u2243\u1d48 Y) : Bijective e", "start": [113, 1], "end": [113, 72], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.injective", "code": "protected theorem injective (e : X \u2243\u1d48 Y) : Injective e", "start": [114, 1], "end": [114, 72], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.ratio_trans", "code": "@[simp]\ntheorem ratio_trans (e : X \u2243\u1d48 Y) (e' : Y \u2243\u1d48 Z) : ratio (e.trans e') = ratio e * ratio e'", "start": [116, 1], "end": [124, 96], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.ratio_symm", "code": "@[simp]\ntheorem ratio_symm (e : X \u2243\u1d48 Y) : ratio e.symm = (ratio e)\u207b\u00b9", "start": [126, 1], "end": [128, 82], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.mul_def", "code": "theorem mul_def (e e' : X \u2243\u1d48 X) : e * e' = e'.trans e", "start": [139, 1], "end": [139, 61], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.one_def", "code": "theorem one_def : (1 : X \u2243\u1d48 X) = refl X", "start": [140, 1], "end": [140, 47], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.inv_def", "code": "theorem inv_def (e : X \u2243\u1d48 X) : e\u207b\u00b9 = e.symm", "start": [141, 1], "end": [141, 51], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.coe_mul", "code": "@[simp] theorem coe_mul (e e' : X \u2243\u1d48 X) : \u21d1(e * e') = e \u2218 e'", "start": [143, 1], "end": [143, 68], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.coe_one", "code": "@[simp] theorem coe_one : \u21d1(1 : X \u2243\u1d48 X) = id", "start": [144, 1], "end": [144, 52], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.coe_inv", "code": "theorem coe_inv (e : X \u2243\u1d48 X) : \u21d1(e\u207b\u00b9) = e.symm", "start": [145, 1], "end": [145, 54], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.ratioHom", "code": "noncomputable def ratioHom : (X \u2243\u1d48 X) \u2192* \u211d\u22650 where\n  toFun := Dilation.ratio\n  map_one' := ratio_refl\n  map_mul' _ _ := (ratio_trans _ _).trans (mul_comm _ _)", "start": [147, 1], "end": [151, 57], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.ratio_inv", "code": "@[simp]\ntheorem ratio_inv (e : X \u2243\u1d48 X) : ratio (e\u207b\u00b9) = (ratio e)\u207b\u00b9", "start": [153, 1], "end": [154, 75], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.ratio_pow", "code": "@[simp]\ntheorem ratio_pow (e : X \u2243\u1d48 X) (n : \u2115) : ratio (e ^ n) = ratio e ^ n", "start": [156, 1], "end": [158, 23], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.ratio_zpow", "code": "@[simp]\ntheorem ratio_zpow (e : X \u2243\u1d48 X) (n : \u2124) : ratio (e ^ n) = ratio e ^ n", "start": [160, 1], "end": [162, 24], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.toPerm", "code": "@[simps]\ndef toPerm : (X \u2243\u1d48 X) \u2192* Equiv.Perm X where\n  toFun e := e.1\n  map_mul' _ _ := rfl\n  map_one' := rfl", "start": [164, 1], "end": [169, 18], "kind": "commanddeclaration"}, {"full_name": "DilationEquiv.coe_pow", "code": "@[norm_cast]\ntheorem coe_pow (e : X \u2243\u1d48 X) (n : \u2115) : \u21d1(e ^ n) = e^[n]", "start": [171, 1], "end": [173, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Star/Exponential.lean", "imports": ["Mathlib/Analysis/NormedSpace/Exponential.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "selfAdjoint.expUnitary", "code": "@[simps]\nnoncomputable def selfAdjoint.expUnitary (a : selfAdjoint A) : unitary A :=\n  \u27e8exp \u2102 ((I \u2022 a.val) : A),\n      exp_mem_unitary_of_mem_skewAdjoint _ (a.prop.smul_mem_skewAdjoint conj_I)\u27e9", "start": [31, 1], "end": [36, 81], "kind": "commanddeclaration"}, {"full_name": "Commute.expUnitary_add", "code": "theorem Commute.expUnitary_add {a b : selfAdjoint A} (h : Commute (a : A) (b : A)) :\n    expUnitary (a + b) = expUnitary a * expUnitary b", "start": [41, 1], "end": [47, 92], "kind": "commanddeclaration"}, {"full_name": "Commute.expUnitary", "code": "theorem Commute.expUnitary {a b : selfAdjoint A} (h : Commute (a : A) (b : A)) :\n    Commute (expUnitary a) (expUnitary b)", "start": [50, 1], "end": [55, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SetFamily/Compression/UV.lean", "imports": ["Mathlib/Combinatorics/SetFamily/Shadow.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "sup_sdiff_injOn", "code": "theorem sup_sdiff_injOn [GeneralizedBooleanAlgebra \u03b1] (u v : \u03b1) :\n    { x | Disjoint u x \u2227 v \u2264 x }.InjOn fun x => (x \u2294 u) \\ v", "start": [56, 1], "end": [64, 89], "kind": "commanddeclaration"}, {"full_name": "UV.compress", "code": "def compress (u v a : \u03b1) : \u03b1 :=\n  if Disjoint u a \u2227 v \u2264 a then (a \u2294 u) \\ v else a", "start": [78, 1], "end": [82, 50], "kind": "commanddeclaration"}, {"full_name": "UV.compress_of_disjoint_of_le", "code": "theorem compress_of_disjoint_of_le (hua : Disjoint u a) (hva : v \u2264 a) :\n    compress u v a = (a \u2294 u) \\ v", "start": [85, 1], "end": [87, 20], "kind": "commanddeclaration"}, {"full_name": "UV.compress_of_disjoint_of_le'", "code": "theorem compress_of_disjoint_of_le' (hva : Disjoint v a) (hua : u \u2264 a) :\n    compress u v ((a \u2294 v) \\ u) = a", "start": [90, 1], "end": [94, 79], "kind": "commanddeclaration"}, {"full_name": "UV.compress_self", "code": "@[simp]\ntheorem compress_self (u a : \u03b1) : compress u u a = a", "start": [97, 1], "end": [102, 8], "kind": "commanddeclaration"}, {"full_name": "UV.compress_sdiff_sdiff", "code": "@[simp]\ntheorem compress_sdiff_sdiff (a b : \u03b1) : compress (a \\ b) (b \\ a) b = a", "start": [105, 1], "end": [110, 23], "kind": "commanddeclaration"}, {"full_name": "UV.compress_idem", "code": "@[simp]\ntheorem compress_idem (u v a : \u03b1) : compress u v (compress u v a) = compress u v a", "start": [113, 1], "end": [120, 8], "kind": "commanddeclaration"}, {"full_name": "UV.compression", "code": "def compression (u v : \u03b1) (s : Finset \u03b1) :=\n  (s.filter (compress u v \u00b7 \u2208 s)) \u222a (s.image <| compress u v).filter (\u00b7 \u2209 s)", "start": [125, 1], "end": [128, 77], "kind": "commanddeclaration"}, {"full_name": "UV.IsCompressed", "code": "def IsCompressed (u v : \u03b1) (s : Finset \u03b1) :=\n  \ud835\udcd2 u v s = s", "start": [136, 1], "end": [138, 14], "kind": "commanddeclaration"}, {"full_name": "UV.compress_injOn", "code": "theorem compress_injOn : Set.InjOn (compress u v) \u2191(s.filter (compress u v \u00b7 \u2209 s))", "start": [141, 1], "end": [151, 27], "kind": "commanddeclaration"}, {"full_name": "UV.mem_compression", "code": "theorem mem_compression :\n    a \u2208 \ud835\udcd2 u v s \u2194 a \u2208 s \u2227 compress u v a \u2208 s \u2228 a \u2209 s \u2227 \u2203 b \u2208 s, compress u v b = a", "start": [154, 1], "end": [158, 68], "kind": "commanddeclaration"}, {"full_name": "UV.IsCompressed.eq", "code": "protected theorem IsCompressed.eq (h : IsCompressed u v s) : \ud835\udcd2 u v s = s", "start": [161, 1], "end": [161, 78], "kind": "commanddeclaration"}, {"full_name": "UV.compression_self", "code": "@[simp]\ntheorem compression_self (u : \u03b1) (s : Finset \u03b1) : \ud835\udcd2 u u s = s", "start": [164, 1], "end": [173, 17], "kind": "commanddeclaration"}, {"full_name": "UV.isCompressed_self", "code": "theorem isCompressed_self (u : \u03b1) (s : Finset \u03b1) : IsCompressed u u s", "start": [176, 1], "end": [177, 94], "kind": "commanddeclaration"}, {"full_name": "UV.compress_disjoint", "code": "theorem compress_disjoint :\n    Disjoint (s.filter (compress u v \u00b7 \u2208 s)) ((s.image <| compress u v).filter (\u00b7 \u2209 s))", "start": [180, 1], "end": [182, 77], "kind": "commanddeclaration"}, {"full_name": "UV.compress_mem_compression", "code": "theorem compress_mem_compression (ha : a \u2208 s) : compress u v a \u2208 \ud835\udcd2 u v s", "start": [185, 1], "end": [190, 33], "kind": "commanddeclaration"}, {"full_name": "UV.compress_mem_compression_of_mem_compression", "code": "theorem compress_mem_compression_of_mem_compression (ha : a \u2208 \ud835\udcd2 u v s) :\n    compress u v a \u2208 \ud835\udcd2 u v s", "start": [194, 1], "end": [200, 77], "kind": "commanddeclaration"}, {"full_name": "UV.compression_idem", "code": "@[simp]\ntheorem compression_idem (u v : \u03b1) (s : Finset \u03b1) : \ud835\udcd2 u v (\ud835\udcd2 u v s) = \ud835\udcd2 u v s", "start": [203, 1], "end": [209, 57], "kind": "commanddeclaration"}, {"full_name": "UV.card_compression", "code": "@[simp]\ntheorem card_compression (u v : \u03b1) (s : Finset \u03b1) : (\ud835\udcd2 u v s).card = s.card", "start": [212, 1], "end": [217, 32], "kind": "commanddeclaration"}, {"full_name": "UV.le_of_mem_compression_of_not_mem", "code": "theorem le_of_mem_compression_of_not_mem (h : a \u2208 \ud835\udcd2 u v s) (ha : a \u2209 s) : u \u2264 a", "start": [220, 1], "end": [228, 41], "kind": "commanddeclaration"}, {"full_name": "UV.disjoint_of_mem_compression_of_not_mem", "code": "theorem disjoint_of_mem_compression_of_not_mem (h : a \u2208 \ud835\udcd2 u v s) (ha : a \u2209 s) : Disjoint v a", "start": [231, 1], "end": [239, 41], "kind": "commanddeclaration"}, {"full_name": "UV.sup_sdiff_mem_of_mem_compression_of_not_mem", "code": "theorem sup_sdiff_mem_of_mem_compression_of_not_mem (h : a \u2208 \ud835\udcd2 u v s) (ha : a \u2209 s) :\n    (a \u2294 v) \\ u \u2208 s", "start": [242, 1], "end": [251, 41], "kind": "commanddeclaration"}, {"full_name": "UV.sup_sdiff_mem_of_mem_compression", "code": "theorem sup_sdiff_mem_of_mem_compression (ha : a \u2208 \ud835\udcd2 u v s) (hva : v \u2264 a) (hua : Disjoint u a) :\n    (a \u2294 u) \\ v \u2208 s", "start": [254, 1], "end": [271, 53], "kind": "commanddeclaration"}, {"full_name": "UV.mem_of_mem_compression", "code": "theorem mem_of_mem_compression (ha : a \u2208 \ud835\udcd2 u v s) (hva : v \u2264 a) (hvu : v = \u22a5 \u2192 u = \u22a5) :\n    a \u2208 s", "start": [274, 1], "end": [285, 14], "kind": "commanddeclaration"}, {"full_name": "UV.card_compress", "code": "theorem card_compress (huv : u.card = v.card) (a : Finset \u03b1) : (compress u v a).card = a.card", "start": [296, 1], "end": [302, 8], "kind": "commanddeclaration"}, {"full_name": "Set.Sized.uvCompression", "code": "lemma _root_.Set.Sized.uvCompression (huv : u.card = v.card) (h\ud835\udc9c : (\ud835\udc9c : Set (Finset \u03b1)).Sized r) :\n    (\ud835\udcd2 u v \ud835\udc9c : Set (Finset \u03b1)).Sized r := by\n  simp_rw [Set.Sized, mem_coe, mem_compression]\n  rintro s (hs | \u27e8huvt, t, ht, rfl\u27e9)\n  \u00b7 exact h\ud835\udc9c hs.1\n  \u00b7 rw [card_compress huv, h\ud835\udc9c ht]", "start": [305, 1], "end": [310, 34], "kind": "mathlibtacticlemma"}, {"full_name": "UV.aux", "code": "private theorem aux (huv : \u2200 x \u2208 u, \u2203 y \u2208 v, IsCompressed (u.erase x) (v.erase y) \ud835\udc9c) :\n    v = \u2205 \u2192 u = \u2205", "start": [312, 1], "end": [314, 93], "kind": "commanddeclaration"}, {"full_name": "UV.shadow_compression_subset_compression_shadow", "code": "theorem shadow_compression_subset_compression_shadow (u v : Finset \u03b1)\n    (huv : \u2200 x \u2208 u, \u2203 y \u2208 v, IsCompressed (u.erase x) (v.erase y) \ud835\udc9c) :\n    \u2202 (\ud835\udcd2 u v \ud835\udc9c) \u2286 \ud835\udcd2 u v (\u2202 \ud835\udc9c)", "start": [316, 1], "end": [421, 93], "kind": "commanddeclaration"}, {"full_name": "UV.card_shadow_compression_le", "code": "theorem card_shadow_compression_le (u v : Finset \u03b1)\n    (huv : \u2200 x \u2208 u, \u2203 y \u2208 v, IsCompressed (u.erase x) (v.erase y) \ud835\udc9c) :\n    (\u2202 (\ud835\udcd2 u v \ud835\udc9c)).card \u2264 (\u2202 \ud835\udc9c).card", "start": [424, 1], "end": [431, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/CoreM.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Tactic/ToExpr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CoreM.withImportModules", "code": "def CoreM.withImportModules (modules : Array Name) (run : CoreM \u03b1)\n    (searchPath : Option SearchPath := none) (options : Options := {})\n    (trustLevel : UInt32 := 0) (fileName := \"\") :\n    IO \u03b1 := unsafe do\n  if let some sp := searchPath then searchPathRef.set sp\n  Lean.withImportModules (modules.map (Import.mk \u00b7 false)) options trustLevel fun env =>\n    let ctx := {fileName, options, fileMap := default}\n    let state := {env}\n    Prod.fst <$> (CoreM.toIO \u00b7 ctx state) do\n      run", "start": [17, 1], "end": [29, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Card.lean", "imports": ["Mathlib/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.inj_on", "code": "def inj_on (f : \u03b1 \u2192 \u03b2) (as : List \u03b1) := \u2200 {x y}, x \u2208 as \u2192 y \u2208 as \u2192 f x = f y \u2192 x = y", "start": [16, 1], "end": [16, 85], "kind": "commanddeclaration"}, {"full_name": "List.inj_on_of_subset", "code": "theorem inj_on_of_subset {f : \u03b1 \u2192 \u03b2} {as bs : List \u03b1} (h : inj_on f bs) (hsub : as \u2286 bs) :\n    inj_on f as", "start": [18, 1], "end": [19, 65], "kind": "commanddeclaration"}, {"full_name": "List.equiv", "code": "protected def equiv (as bs : List \u03b1) := \u2200 x, x \u2208 as \u2194 x \u2208 bs", "start": [21, 1], "end": [21, 61], "kind": "commanddeclaration"}, {"full_name": "List.equiv_iff_subset_and_subset", "code": "theorem equiv_iff_subset_and_subset {as bs : List \u03b1} : as.equiv bs \u2194 as \u2286 bs \u2227 bs \u2286 as", "start": [23, 1], "end": [26, 38], "kind": "commanddeclaration"}, {"full_name": "List.insert_equiv_cons", "code": "theorem insert_equiv_cons [DecidableEq \u03b1] (a : \u03b1) (as : List \u03b1) : (as.insert a).equiv (a :: as)", "start": [28, 1], "end": [29, 18], "kind": "commanddeclaration"}, {"full_name": "List.union_equiv_append", "code": "theorem union_equiv_append [DecidableEq \u03b1] (as bs : List \u03b1) : (as \u222a bs).equiv (as ++ bs)", "start": [31, 1], "end": [32, 18], "kind": "commanddeclaration"}, {"full_name": "List.remove", "code": "def remove (a : \u03b1) : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | (b :: bs) => if a = b then remove a bs else b :: remove a bs", "start": [39, 1], "end": [41, 65], "kind": "commanddeclaration"}, {"full_name": "List.mem_remove_iff", "code": "theorem mem_remove_iff {a b : \u03b1} {as : List \u03b1} : b \u2208 remove a as \u2194 b \u2208 as \u2227 b \u2260 a", "start": [43, 1], "end": [63, 42], "kind": "commanddeclaration"}, {"full_name": "List.remove_eq_of_not_mem", "code": "theorem remove_eq_of_not_mem {a : \u03b1} : \u2200 {as : List \u03b1}, (a \u2209 as) \u2192 remove a as = as", "start": [65, 1], "end": [70, 47], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_mem_remove", "code": "theorem mem_of_mem_remove {a b : \u03b1} {as : List \u03b1} (h : b \u2208 remove a as) : b \u2208 as", "start": [72, 1], "end": [73, 38], "kind": "commanddeclaration"}, {"full_name": "List.card", "code": "def card : List \u03b1 \u2192 Nat\n  | [] => 0\n  | a :: as => if a \u2208 as then card as else card as + 1", "start": [77, 1], "end": [79, 55], "kind": "commanddeclaration"}, {"full_name": "List.card_nil", "code": "@[simp] theorem card_nil : card ([] : List \u03b1) = 0", "start": [81, 1], "end": [81, 57], "kind": "commanddeclaration"}, {"full_name": "List.card_cons_of_mem", "code": "@[simp] theorem card_cons_of_mem {a : \u03b1} {as : List \u03b1} (h : a \u2208 as) :\n    card (a :: as) = card as", "start": [83, 1], "end": [84, 50], "kind": "commanddeclaration"}, {"full_name": "List.card_cons_of_not_mem", "code": "@[simp] theorem card_cons_of_not_mem {a : \u03b1} {as : List \u03b1} (h : a \u2209 as) :\n    card (a :: as) = card as + 1", "start": [86, 1], "end": [87, 54], "kind": "commanddeclaration"}, {"full_name": "List.card_le_card_cons", "code": "theorem card_le_card_cons (a : \u03b1) (as : List \u03b1) : card as \u2264 card (a :: as)", "start": [89, 1], "end": [92, 35], "kind": "commanddeclaration"}, {"full_name": "List.card_insert_of_mem", "code": "@[simp] theorem card_insert_of_mem {a : \u03b1} {as : List \u03b1} (h : a \u2208 as) :\n    card (as.insert a) = card as", "start": [94, 1], "end": [95, 48], "kind": "commanddeclaration"}, {"full_name": "List.card_insert_of_not_mem", "code": "@[simp] theorem card_insert_of_not_mem {a : \u03b1} {as : List \u03b1} (h : a \u2209 as) :\n    card (as.insert a) = card as + 1", "start": [97, 1], "end": [98, 52], "kind": "commanddeclaration"}, {"full_name": "List.card_remove_of_mem", "code": "theorem card_remove_of_mem {a : \u03b1} : \u2200 {as : List \u03b1}, a \u2208 as \u2192 card as = card (remove a as) + 1", "start": [100, 1], "end": [122, 50], "kind": "commanddeclaration"}, {"full_name": "List.card_subset_le", "code": "theorem card_subset_le : \u2200 {as bs : List \u03b1}, as \u2286 bs \u2192 card as \u2264 card bs", "start": [124, 1], "end": [138, 67], "kind": "commanddeclaration"}, {"full_name": "List.card_map_le", "code": "theorem card_map_le (f : \u03b1 \u2192 \u03b2) (as : List \u03b1) : card (as.map f) \u2264 card as", "start": [140, 1], "end": [151, 38], "kind": "commanddeclaration"}, {"full_name": "List.card_map_eq_of_inj_on", "code": "theorem card_map_eq_of_inj_on {f : \u03b1 \u2192 \u03b2} {as : List \u03b1} :\n    inj_on f as \u2192 card (as.map f) = card as", "start": [153, 1], "end": [171, 71], "kind": "commanddeclaration"}, {"full_name": "List.card_eq_of_equiv", "code": "theorem card_eq_of_equiv {as bs : List \u03b1} (h : as.equiv bs) : card as = card bs", "start": [173, 1], "end": [175, 80], "kind": "commanddeclaration"}, {"full_name": "List.card_append_disjoint", "code": "theorem card_append_disjoint : \u2200 {as bs : List \u03b1},\n    Disjoint as bs \u2192 card (as ++ bs) = card as + card bs", "start": [177, 1], "end": [189, 30], "kind": "commanddeclaration"}, {"full_name": "List.card_union_disjoint", "code": "theorem card_union_disjoint {as bs : List \u03b1} (h : Disjoint as bs) :\n    card (as \u222a bs) = card as + card bs", "start": [191, 1], "end": [193, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Sheaves/Sheafify.lean", "imports": ["Mathlib/Topology/Sheaves/Stalks.lean", "Mathlib/Topology/Sheaves/LocalPredicate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopCat.Presheaf.Sheafify.isGerm", "code": "def isGerm : PrelocalPredicate fun x => F.stalk x where\n  pred {U} f := \u2203 g : F.obj (op U), \u2200 x : U, f x = F.germ x g\n  res := fun i _ \u27e8g, p\u27e9 => \u27e8F.map i.op g, fun x => (p (i x)).trans (F.germ_res_apply i x g).symm\u27e9", "start": [46, 1], "end": [51, 98], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.Sheafify.isLocallyGerm", "code": "def isLocallyGerm : LocalPredicate fun x => F.stalk x :=\n  (isGerm F).sheafify", "start": [54, 1], "end": [58, 22], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.sheafify", "code": "def sheafify : Sheaf (Type v) X :=\n  subsheafToTypes (Sheafify.isLocallyGerm F)", "start": [63, 1], "end": [67, 45], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.toSheafify", "code": "def toSheafify : F \u27f6 F.sheafify.1 where\n  app U f := \u27e8fun x => F.germ x f, PrelocalPredicate.sheafifyOf \u27e8f, fun x => rfl\u27e9\u27e9\n  naturality U U' f := by\n    ext x\n    apply Subtype.ext ext \u27e8u, m\u27e9\n    exact germ_res_apply F f.unop \u27e8u, m\u27e9 x", "start": [70, 1], "end": [80, 43], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.stalkToFiber", "code": "def stalkToFiber (x : X) : F.sheafify.presheaf.stalk x \u27f6 F.stalk x :=\n  TopCat.stalkToFiber (Sheafify.isLocallyGerm F) x", "start": [83, 1], "end": [87, 51], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.stalkToFiber_surjective", "code": "theorem stalkToFiber_surjective (x : X) : Function.Surjective (F.stalkToFiber x)", "start": [90, 1], "end": [97, 66], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.stalkToFiber_injective", "code": "theorem stalkToFiber_injective (x : X) : Function.Injective (F.stalkToFiber x)", "start": [100, 1], "end": [121, 76], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.sheafifyStalkIso", "code": "def sheafifyStalkIso (x : X) : F.sheafify.presheaf.stalk x \u2245 F.stalk x :=\n  (Equiv.ofBijective _ \u27e8stalkToFiber_injective _ _, stalkToFiber_surjective _ _\u27e9).toIso", "start": [124, 1], "end": [127, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rbtree/Main.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Algebra/Quandle.lean", "imports": ["Mathlib/Data/ZMod/Defs.lean", "Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/Algebra/Hom/Aut.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Ring.lean"], "premises": [{"full_name": "Shelf", "code": "class Shelf (\u03b1 : Type u) where\n  \n  act : \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  \n  self_distrib : \u2200 {x y z : \u03b1}, act x (act y z) = act (act x y) (act x z)", "start": [92, 1], "end": [99, 74], "kind": "commanddeclaration"}, {"full_name": "UnitalShelf", "code": "class UnitalShelf (\u03b1 : Type u) extends Shelf \u03b1, One \u03b1 :=\n(one_act : \u2200 a : \u03b1, act 1 a = a)\n(act_one : \u2200 a : \u03b1, act a 1 = a)", "start": [102, 1], "end": [108, 33], "kind": "commanddeclaration"}, {"full_name": "ShelfHom", "code": "@[ext]\nstructure ShelfHom (S\u2081 : Type*) (S\u2082 : Type*) [Shelf S\u2081] [Shelf S\u2082] where\n  \n  toFun : S\u2081 \u2192 S\u2082\n  \n  map_act' : \u2200 {x y : S\u2081}, toFun (Shelf.act x y) = Shelf.act (toFun x) (toFun y)", "start": [111, 1], "end": [119, 81], "kind": "commanddeclaration"}, {"full_name": "Rack", "code": "class Rack (\u03b1 : Type u) extends Shelf \u03b1 where\n  \n  invAct : \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  \n  left_inv : \u2200 x, Function.LeftInverse (invAct x) (act x)\n  \n  right_inv : \u2200 x, Function.RightInverse (invAct x) (act x)", "start": [124, 1], "end": [137, 60], "kind": "commanddeclaration"}, {"full_name": "UnitalShelf.act_act_self_eq", "code": "lemma act_act_self_eq (x y : S) : (x \u25c3 y) \u25c3 x = x \u25c3 y := by\n  have h : (x \u25c3 y) \u25c3 x = (x \u25c3 y) \u25c3 (x \u25c3 1) := by rw [act_one]\n  rw [h, \u2190Shelf.self_distrib, act_one]", "start": [156, 1], "end": [163, 39], "kind": "mathlibtacticlemma"}, {"full_name": "UnitalShelf.act_idem", "code": "lemma act_idem (x : S) : (x \u25c3 x) = x := by rw [\u2190act_one x, \u2190Shelf.self_distrib, act_one, act_one]", "start": [166, 1], "end": [166, 98], "kind": "mathlibtacticlemma"}, {"full_name": "UnitalShelf.act_self_act_eq", "code": "lemma act_self_act_eq (x y : S) : x \u25c3 (x \u25c3 y) = x \u25c3 y := by\n  have h : x \u25c3 (x \u25c3 y) = (x \u25c3 1) \u25c3 (x \u25c3 y) := by rw [act_one]\n  rw [h, \u2190Shelf.self_distrib, one_act]", "start": [169, 1], "end": [171, 39], "kind": "mathlibtacticlemma"}, {"full_name": "UnitalShelf.assoc", "code": "lemma assoc (x y z : S) : (x \u25c3 y) \u25c3 z = x \u25c3 y \u25c3 z := by\n  rw [self_distrib, self_distrib, act_act_self_eq, act_self_act_eq]", "start": [174, 1], "end": [178, 68], "kind": "mathlibtacticlemma"}, {"full_name": "Rack.act'", "code": "def act' (x : R) : R \u2243 R where\n  toFun := Shelf.act x\n  invFun := invAct x\n  left_inv := left_inv x\n  right_inv := right_inv x", "start": [191, 1], "end": [197, 27], "kind": "commanddeclaration"}, {"full_name": "Rack.act'_apply", "code": "@[simp]\ntheorem act'_apply (x y : R) : act' x y = x \u25c3 y", "start": [200, 1], "end": [202, 6], "kind": "commanddeclaration"}, {"full_name": "Rack.act'_symm_apply", "code": "@[simp]\ntheorem act'_symm_apply (x y : R) : (act' x).symm y = x \u25c3\u207b\u00b9 y", "start": [205, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "Rack.invAct_apply", "code": "@[simp]\ntheorem invAct_apply (x y : R) : (act' x)\u207b\u00b9 y = x \u25c3\u207b\u00b9 y", "start": [210, 1], "end": [212, 6], "kind": "commanddeclaration"}, {"full_name": "Rack.invAct_act_eq", "code": "@[simp]\ntheorem invAct_act_eq (x y : R) : x \u25c3\u207b\u00b9 x \u25c3 y = y", "start": [215, 1], "end": [217, 15], "kind": "commanddeclaration"}, {"full_name": "Rack.act_invAct_eq", "code": "@[simp]\ntheorem act_invAct_eq (x y : R) : x \u25c3 x \u25c3\u207b\u00b9 y = y", "start": [220, 1], "end": [222, 16], "kind": "commanddeclaration"}, {"full_name": "Rack.left_cancel", "code": "theorem left_cancel (x : R) {y y' : R} : x \u25c3 y = x \u25c3 y' \u2194 y = y'", "start": [225, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "Rack.left_cancel_inv", "code": "theorem left_cancel_inv (x : R) {y y' : R} : x \u25c3\u207b\u00b9 y = x \u25c3\u207b\u00b9 y' \u2194 y = y'", "start": [232, 1], "end": [236, 6], "kind": "commanddeclaration"}, {"full_name": "Rack.self_distrib_inv", "code": "theorem self_distrib_inv {x y z : R} : x \u25c3\u207b\u00b9 y \u25c3\u207b\u00b9 z = (x \u25c3\u207b\u00b9 y) \u25c3\u207b\u00b9 x \u25c3\u207b\u00b9 z", "start": [239, 1], "end": [241, 25], "kind": "commanddeclaration"}, {"full_name": "Rack.ad_conj", "code": "theorem ad_conj {R : Type*} [Rack R] (x y : R) : act' (x \u25c3 y) = act' x * act' y * (act' x)\u207b\u00b9", "start": [244, 1], "end": [253, 26], "kind": "commanddeclaration"}, {"full_name": "Rack.oppositeRack", "code": "instance oppositeRack : Rack R\u1d50\u1d52\u1d56\n    where\n  act x y := op (invAct (unop x) (unop y))\n  self_distrib := by\n    intro x y z\n    induction x using MulOpposite.rec'\n    induction y using MulOpposite.rec'\n    induction z using MulOpposite.rec'\n    simp only [op_inj, unop_op, op_unop]\n    rw [self_distrib_inv]\n  invAct x y := op (Shelf.act (unop x) (unop y))\n  left_inv := MulOpposite.rec' fun x => MulOpposite.rec' fun y => by simp\n  right_inv := MulOpposite.rec' fun x => MulOpposite.rec' fun y => by simp", "start": [256, 1], "end": [270, 75], "kind": "commanddeclaration"}, {"full_name": "Rack.op_act_op_eq", "code": "@[simp]\ntheorem op_act_op_eq {x y : R} : op x \u25c3 op y = op (x \u25c3\u207b\u00b9 y)", "start": [273, 1], "end": [275, 6], "kind": "commanddeclaration"}, {"full_name": "Rack.op_invAct_op_eq", "code": "@[simp]\ntheorem op_invAct_op_eq {x y : R} : op x \u25c3\u207b\u00b9 op y = op (x \u25c3 y)", "start": [278, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "Rack.self_act_act_eq", "code": "@[simp]\ntheorem self_act_act_eq {x y : R} : (x \u25c3 x) \u25c3 y = x \u25c3 y", "start": [283, 1], "end": [284, 99], "kind": "commanddeclaration"}, {"full_name": "Rack.self_invAct_invAct_eq", "code": "@[simp]\ntheorem self_invAct_invAct_eq {x y : R} : (x \u25c3\u207b\u00b9 x) \u25c3\u207b\u00b9 y = x \u25c3\u207b\u00b9 y", "start": [287, 1], "end": [290, 16], "kind": "commanddeclaration"}, {"full_name": "Rack.self_act_invAct_eq", "code": "@[simp]\ntheorem self_act_invAct_eq {x y : R} : (x \u25c3 x) \u25c3\u207b\u00b9 y = x \u25c3\u207b\u00b9 y", "start": [293, 1], "end": [298, 17], "kind": "commanddeclaration"}, {"full_name": "Rack.self_invAct_act_eq", "code": "@[simp]\ntheorem self_invAct_act_eq {x y : R} : (x \u25c3\u207b\u00b9 x) \u25c3 y = x \u25c3 y", "start": [301, 1], "end": [304, 16], "kind": "commanddeclaration"}, {"full_name": "Rack.self_act_eq_iff_eq", "code": "theorem self_act_eq_iff_eq {x y : R} : x \u25c3 x = y \u25c3 y \u2194 x = y", "start": [307, 1], "end": [312, 60], "kind": "commanddeclaration"}, {"full_name": "Rack.self_invAct_eq_iff_eq", "code": "theorem self_invAct_eq_iff_eq {x y : R} : x \u25c3\u207b\u00b9 x = y \u25c3\u207b\u00b9 y \u2194 x = y", "start": [315, 1], "end": [317, 16], "kind": "commanddeclaration"}, {"full_name": "Rack.selfApplyEquiv", "code": "def selfApplyEquiv (R : Type*) [Rack R] : R \u2243 R\n    where\n  toFun x := x \u25c3 x\n  invFun x := x \u25c3\u207b\u00b9 x\n  left_inv x := by simp\n  right_inv x := by simp", "start": [320, 1], "end": [328, 25], "kind": "commanddeclaration"}, {"full_name": "Rack.IsInvolutory", "code": "def IsInvolutory (R : Type*) [Rack R] : Prop :=\n  \u2200 x : R, Function.Involutive (Shelf.act x)", "start": [331, 1], "end": [334, 45], "kind": "commanddeclaration"}, {"full_name": "Rack.involutory_invAct_eq_act", "code": "theorem involutory_invAct_eq_act {R : Type*} [Rack R] (h : IsInvolutory R) (x y : R) :\n    x \u25c3\u207b\u00b9 y = x \u25c3 y", "start": [337, 1], "end": [339, 39], "kind": "commanddeclaration"}, {"full_name": "Rack.IsAbelian", "code": "def IsAbelian (R : Type*) [Rack R] : Prop :=\n  \u2200 x y z w : R, (x \u25c3 y) \u25c3 z \u25c3 w = (x \u25c3 z) \u25c3 y \u25c3 w", "start": [342, 1], "end": [345, 51], "kind": "commanddeclaration"}, {"full_name": "Rack.assoc_iff_id", "code": "theorem assoc_iff_id {R : Type*} [Rack R] {x y z : R} : x \u25c3 y \u25c3 z = (x \u25c3 y) \u25c3 z \u2194 x \u25c3 z = z", "start": [348, 1], "end": [352, 19], "kind": "commanddeclaration"}, {"full_name": "ShelfHom.toFun_eq_coe", "code": "@[simp] theorem toFun_eq_coe (f : S\u2081 \u2192\u25c3 S\u2082) : f.toFun = f", "start": [365, 1], "end": [365, 65], "kind": "commanddeclaration"}, {"full_name": "ShelfHom.map_act", "code": "@[simp]\ntheorem map_act (f : S\u2081 \u2192\u25c3 S\u2082) {x y : S\u2081} : f (x \u25c3 y) = f x \u25c3 f y", "start": [368, 1], "end": [370, 13], "kind": "commanddeclaration"}, {"full_name": "ShelfHom.id", "code": "def id (S : Type*) [Shelf S] : S \u2192\u25c3 S where\n  toFun := fun x => x\n  map_act' := by simp", "start": [373, 1], "end": [376, 22], "kind": "commanddeclaration"}, {"full_name": "ShelfHom.inhabited", "code": "instance inhabited (S : Type*) [Shelf S] : Inhabited (S \u2192\u25c3 S) :=\n  \u27e8id S\u27e9", "start": [379, 1], "end": [380, 9], "kind": "commanddeclaration"}, {"full_name": "ShelfHom.comp", "code": "def comp (g : S\u2082 \u2192\u25c3 S\u2083) (f : S\u2081 \u2192\u25c3 S\u2082) : S\u2081 \u2192\u25c3 S\u2083\n    where\n  toFun := g.toFun \u2218 f.toFun\n  map_act' := by simp", "start": [383, 1], "end": [387, 22], "kind": "commanddeclaration"}, {"full_name": "ShelfHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (g : S\u2082 \u2192\u25c3 S\u2083) (f : S\u2081 \u2192\u25c3 S\u2082) (x : S\u2081) : (g.comp f) x = g (f x)", "start": [390, 1], "end": [392, 6], "kind": "commanddeclaration"}, {"full_name": "Quandle", "code": "class Quandle (\u03b1 : Type*) extends Rack \u03b1 where\n  \n  fix : \u2200 {x : \u03b1}, act x x = x", "start": [397, 1], "end": [401, 31], "kind": "commanddeclaration"}, {"full_name": "Quandle.fix_inv", "code": "@[simp]\ntheorem fix_inv {x : Q} : x \u25c3\u207b\u00b9 x = x", "start": [412, 1], "end": [415, 7], "kind": "commanddeclaration"}, {"full_name": "Quandle.oppositeQuandle", "code": "instance oppositeQuandle : Quandle Q\u1d50\u1d52\u1d56 where\n  fix := by\n    intro x\n    induction' x using MulOpposite.rec'\n    simp", "start": [418, 1], "end": [422, 9], "kind": "commanddeclaration"}, {"full_name": "Quandle.Conj", "code": "@[reducible]\ndef Conj (G : Type*) := G", "start": [425, 1], "end": [430, 26], "kind": "commanddeclaration"}, {"full_name": "Quandle.Conj.quandle", "code": "instance Conj.quandle (G : Type*) [Group G] : Quandle (Conj G)\n    where\n  act x := @MulAut.conj G _ x\n  self_distrib := by\n    intro x y z\n    dsimp only [MulAut.conj_apply]\n    simp [mul_assoc]\n  invAct x := (@MulAut.conj G _ x).symm\n  left_inv x y := by\n    simp [act', mul_assoc]\n  right_inv x y := by\n    simp [act', mul_assoc]\n  fix := by simp", "start": [433, 1], "end": [445, 17], "kind": "commanddeclaration"}, {"full_name": "Quandle.conj_act_eq_conj", "code": "@[simp]\ntheorem conj_act_eq_conj {G : Type*} [Group G] (x y : Conj G) :\n    x \u25c3 y = ((x : G) * (y : G) * (x : G)\u207b\u00b9 : G)", "start": [448, 1], "end": [451, 6], "kind": "commanddeclaration"}, {"full_name": "Quandle.conj_swap", "code": "theorem conj_swap {G : Type*} [Group G] (x y : Conj G) : x \u25c3 y = y \u2194 y \u25c3 x = x", "start": [454, 1], "end": [456, 88], "kind": "commanddeclaration"}, {"full_name": "Quandle.Conj.map", "code": "def Conj.map {G : Type*} {H : Type*} [Group G] [Group H] (f : G \u2192* H) : Conj G \u2192\u25c3 Conj H\n    where\n  toFun := f\n  map_act' := by simp", "start": [459, 1], "end": [464, 22], "kind": "commanddeclaration"}, {"full_name": "Quandle.Dihedral", "code": "def Dihedral (n : \u2115) :=\n  ZMod n", "start": [471, 1], "end": [477, 9], "kind": "commanddeclaration"}, {"full_name": "Quandle.dihedralAct", "code": "def dihedralAct (n : \u2115) (a : ZMod n) : ZMod n \u2192 ZMod n := fun b => 2 * a - b", "start": [480, 1], "end": [483, 77], "kind": "commanddeclaration"}, {"full_name": "Quandle.dihedralAct.inv", "code": "theorem dihedralAct.inv (n : \u2115) (a : ZMod n) : Function.Involutive (dihedralAct n a)", "start": [486, 1], "end": [489, 7], "kind": "commanddeclaration"}, {"full_name": "Rack.toConj", "code": "def toConj (R : Type*) [Rack R] : R \u2192\u25c3 Quandle.Conj (R \u2243 R)\n    where\n  toFun := act'\n  map_act' := by\n    intro x y\n    exact ad_conj x y", "start": [511, 1], "end": [519, 22], "kind": "commanddeclaration"}, {"full_name": "Rack.PreEnvelGroup", "code": "inductive PreEnvelGroup (R : Type u) : Type u\n  | unit : PreEnvelGroup R\n  | incl (x : R) : PreEnvelGroup R\n  | mul (a b : PreEnvelGroup R) : PreEnvelGroup R\n  | inv (a : PreEnvelGroup R) : PreEnvelGroup R", "start": [583, 1], "end": [589, 48], "kind": "commanddeclaration"}, {"full_name": "Rack.PreEnvelGroup.inhabited", "code": "instance PreEnvelGroup.inhabited (R : Type u) : Inhabited (PreEnvelGroup R) :=\n  \u27e8PreEnvelGroup.unit\u27e9", "start": [592, 1], "end": [593, 23], "kind": "commanddeclaration"}, {"full_name": "Rack.PreEnvelGroupRel'", "code": "inductive PreEnvelGroupRel' (R : Type u) [Rack R] : PreEnvelGroup R \u2192 PreEnvelGroup R \u2192 Type u\n  | refl {a : PreEnvelGroup R} : PreEnvelGroupRel' R a a\n  | symm {a b : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b) : PreEnvelGroupRel' R b a\n  | trans {a b c : PreEnvelGroup R} (hab : PreEnvelGroupRel' R a b)\n    (hbc : PreEnvelGroupRel' R b c) : PreEnvelGroupRel' R a c\n  | congr_mul {a b a' b' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a')\n    (hb : PreEnvelGroupRel' R b b') : PreEnvelGroupRel' R (mul a b) (mul a' b')\n  | congr_inv {a a' : PreEnvelGroup R} (ha : PreEnvelGroupRel' R a a') :\n    PreEnvelGroupRel' R (inv a) (inv a')\n  | assoc (a b c : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (mul a b) c) (mul a (mul b c))\n  | one_mul (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul unit a) a\n  | mul_one (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul a unit) a\n  | mul_left_inv (a : PreEnvelGroup R) : PreEnvelGroupRel' R (mul (inv a) a) unit\n  | act_incl (x y : R) :\n    PreEnvelGroupRel' R (mul (mul (incl x) (incl y)) (inv (incl x))) (incl (x \u25c3 y))", "start": [598, 1], "end": [617, 84], "kind": "commanddeclaration"}, {"full_name": "Rack.PreEnvelGroupRel'.inhabited", "code": "instance PreEnvelGroupRel'.inhabited (R : Type u) [Rack R] :\n    Inhabited (PreEnvelGroupRel' R unit unit) :=\n  \u27e8PreEnvelGroupRel'.refl\u27e9", "start": [620, 1], "end": [622, 27], "kind": "commanddeclaration"}, {"full_name": "Rack.PreEnvelGroupRel", "code": "inductive PreEnvelGroupRel (R : Type u) [Rack R] : PreEnvelGroup R \u2192 PreEnvelGroup R \u2192 Prop\n  | rel {a b : PreEnvelGroup R} (r : PreEnvelGroupRel' R a b) : PreEnvelGroupRel R a b", "start": [625, 1], "end": [629, 87], "kind": "commanddeclaration"}, {"full_name": "Rack.PreEnvelGroupRel'.rel", "code": "theorem PreEnvelGroupRel'.rel {R : Type u} [Rack R] {a b : PreEnvelGroup R} :\n    PreEnvelGroupRel' R a b \u2192 PreEnvelGroupRel R a b", "start": [632, 1], "end": [635, 77], "kind": "commanddeclaration"}, {"full_name": "Rack.PreEnvelGroupRel.refl", "code": "@[refl]\ntheorem PreEnvelGroupRel.refl {R : Type u} [Rack R] {a : PreEnvelGroup R} :\n    PreEnvelGroupRel R a a", "start": [638, 1], "end": [641, 46], "kind": "commanddeclaration"}, {"full_name": "Rack.PreEnvelGroupRel.symm", "code": "@[symm]\ntheorem PreEnvelGroupRel.symm {R : Type u} [Rack R] {a b : PreEnvelGroup R} :\n    PreEnvelGroupRel R a b \u2192 PreEnvelGroupRel R b a", "start": [644, 1], "end": [647, 22], "kind": "commanddeclaration"}, {"full_name": "Rack.PreEnvelGroupRel.trans", "code": "@[trans]\ntheorem PreEnvelGroupRel.trans {R : Type u} [Rack R] {a b c : PreEnvelGroup R} :\n    PreEnvelGroupRel R a b \u2192 PreEnvelGroupRel R b c \u2192 PreEnvelGroupRel R a c", "start": [650, 1], "end": [653, 40], "kind": "commanddeclaration"}, {"full_name": "Rack.PreEnvelGroup.setoid", "code": "instance PreEnvelGroup.setoid (R : Type*) [Rack R] : Setoid (PreEnvelGroup R)\n    where\n  r := PreEnvelGroupRel R\n  iseqv := by\n    constructor\n    \u00b7 apply PreEnvelGroupRel.refl\n    \u00b7 apply PreEnvelGroupRel.symm\n    \u00b7 apply PreEnvelGroupRel.trans", "start": [656, 1], "end": [663, 35], "kind": "commanddeclaration"}, {"full_name": "Rack.EnvelGroup", "code": "def EnvelGroup (R : Type*) [Rack R] :=\n  Quotient (PreEnvelGroup.setoid R)", "start": [665, 1], "end": [668, 36], "kind": "commanddeclaration"}, {"full_name": "Rack.EnvelGroup.inhabited", "code": "instance EnvelGroup.inhabited (R : Type*) [Rack R] : Inhabited (EnvelGroup R) :=\n  \u27e81\u27e9", "start": [691, 1], "end": [692, 6], "kind": "commanddeclaration"}, {"full_name": "Rack.toEnvelGroup", "code": "def toEnvelGroup (R : Type*) [Rack R] : R \u2192\u25c3 Quandle.Conj (EnvelGroup R)\n    where\n  toFun x := \u27e6incl x\u27e7\n  map_act' := @fun x y => Quotient.sound (PreEnvelGroupRel'.act_incl x y).symm.rel", "start": [695, 1], "end": [701, 83], "kind": "commanddeclaration"}, {"full_name": "Rack.toEnvelGroup.mapAux", "code": "def toEnvelGroup.mapAux {R : Type*} [Rack R] {G : Type*} [Group G] (f : R \u2192\u25c3 Quandle.Conj G) :\n    PreEnvelGroup R \u2192 G\n  | .unit => 1\n  | .incl x => f x\n  | .mul a b => toEnvelGroup.mapAux f a * toEnvelGroup.mapAux f b\n  | .inv a => (toEnvelGroup.mapAux f a)\u207b\u00b9", "start": [704, 1], "end": [712, 42], "kind": "commanddeclaration"}, {"full_name": "Rack.toEnvelGroup.mapAux.well_def", "code": "theorem well_def {R : Type*} [Rack R] {G : Type*} [Group G] (f : R \u2192\u25c3 Quandle.Conj G) :\n    \u2200 {a b : PreEnvelGroup R},\n      PreEnvelGroupRel' R a b \u2192 toEnvelGroup.mapAux f a = toEnvelGroup.mapAux f b", "start": [719, 1], "end": [734, 56], "kind": "commanddeclaration"}, {"full_name": "Rack.toEnvelGroup.map", "code": "def toEnvelGroup.map {R : Type*} [Rack R] {G : Type*} [Group G] :\n    (R \u2192\u25c3 Quandle.Conj G) \u2243 (EnvelGroup R \u2192* G)\n    where\n  toFun f :=\n    { toFun := fun x =>\n        Quotient.liftOn x (toEnvelGroup.mapAux f) fun a b \u27e8hab\u27e9 =>\n          toEnvelGroup.mapAux.well_def f hab\n      map_one' := by\n        change Quotient.liftOn \u27e6Rack.PreEnvelGroup.unit\u27e7 (toEnvelGroup.mapAux f) _ = 1\n        simp only [Quotient.lift_mk, mapAux]\n      map_mul' := fun x y =>\n        Quotient.inductionOn\u2082 x y fun x y => by\n          simp only [toEnvelGroup.mapAux]\n          change Quotient.liftOn \u27e6mul x y\u27e7 (toEnvelGroup.mapAux f) _ = _\n          simp [toEnvelGroup.mapAux] }\n  invFun F := (Quandle.Conj.map F).comp (toEnvelGroup R)\n  left_inv f := by ext; rfl\n  right_inv F :=\n    MonoidHom.ext fun x =>\n      Quotient.inductionOn x fun x => by\n        induction' x with _ x y ih_x ih_y x ih_x\n        \u00b7 exact F.map_one.symm\n        \u00b7 rfl\n        \u00b7 have hm : \u27e6x.mul y\u27e7 = @Mul.mul (EnvelGroup R) _ \u27e6x\u27e7 \u27e6y\u27e7 := rfl\n          simp only [MonoidHom.coe_mk, OneHom.coe_mk, Quotient.lift_mk]\n          suffices \u2200 x y, F (Mul.mul x y) = F (x) * F (y) by\n            simp_all only [MonoidHom.coe_mk, OneHom.coe_mk, Quotient.lift_mk, hm]\n            rw [\u2190 ih_x, \u2190 ih_y, mapAux]\n          exact F.map_mul\n        \u00b7 have hm : \u27e6x.inv\u27e7 = @Inv.inv (EnvelGroup R) _ \u27e6x\u27e7 := rfl\n          rw [hm, F.map_inv, MonoidHom.map_inv, ih_x]", "start": [739, 1], "end": [772, 54], "kind": "commanddeclaration"}, {"full_name": "Rack.toEnvelGroup.univ", "code": "theorem toEnvelGroup.univ (R : Type*) [Rack R] (G : Type*) [Group G] (f : R \u2192\u25c3 Quandle.Conj G) :\n    (Quandle.Conj.map (toEnvelGroup.map f)).comp (toEnvelGroup R) = f", "start": [775, 1], "end": [779, 38], "kind": "commanddeclaration"}, {"full_name": "Rack.toEnvelGroup.univ_uniq", "code": "theorem toEnvelGroup.univ_uniq (R : Type*) [Rack R] (G : Type*) [Group G]\n    (f : R \u2192\u25c3 Quandle.Conj G) (g : EnvelGroup R \u2192* G)\n    (h : f = (Quandle.Conj.map g).comp (toEnvelGroup R)) : g = toEnvelGroup.map f", "start": [782, 1], "end": [788, 54], "kind": "commanddeclaration"}, {"full_name": "Rack.envelAction", "code": "def envelAction {R : Type*} [Rack R] : EnvelGroup R \u2192* R \u2243 R :=\n  toEnvelGroup.map (toConj R)", "start": [791, 1], "end": [797, 30], "kind": "commanddeclaration"}, {"full_name": "Rack.envelAction_prop", "code": "@[simp]\ntheorem envelAction_prop {R : Type*} [Rack R] (x y : R) :\n    envelAction (toEnvelGroup R x) y = x \u25c3 y", "start": [800, 1], "end": [803, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Preadditive/Mat.lean", "imports": ["Mathlib/CategoryTheory/FintypeCat.lean", "Mathlib/CategoryTheory/Preadditive/AdditiveFunctor.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Data/Matrix/Basic.lean", "Mathlib/Algebra/Opposites.lean", "Mathlib/Algebra/BigOperators/Pi.lean", "Mathlib/CategoryTheory/Preadditive/Basic.lean", "Mathlib/CategoryTheory/Preadditive/SingleObj.lean", "Mathlib/Data/Matrix/DMatrix.lean", "Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean"], "premises": [{"full_name": "CategoryTheory.Mat_", "code": "structure Mat_ where\n  \u03b9 : Type\n  [F : Fintype \u03b9]\n  X : \u03b9 \u2192 C", "start": [65, 1], "end": [70, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.Hom", "code": "def Hom (M N : Mat_ C) : Type v\u2081 :=\n  DMatrix M.\u03b9 N.\u03b9 fun i j => M.X i \u27f6 N.X j", "start": [81, 1], "end": [83, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.Hom.id", "code": "def id (M : Mat_ C) : Hom M M := fun i j => if h : i = j then eqToHom (congr_arg M.X h) else 0", "start": [89, 1], "end": [90, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.Hom.comp", "code": "def comp {M N K : Mat_ C} (f : Hom M N) (g : Hom N K) : Hom M K := fun i k =>\n  \u2211 j : N.\u03b9, f i j \u226b g j k", "start": [94, 1], "end": [96, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.hom_ext", "code": "@[ext]\ntheorem hom_ext {M N : Mat_ C} (f g : M \u27f6 N) (H : \u2200 i j, f i j = g i j) : f = g", "start": [120, 1], "end": [122, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.id_def", "code": "theorem id_def (M : Mat_ C) :\n    (\ud835\udfd9 M : Hom M M) = fun i j => if h : i = j then eqToHom (congr_arg M.X h) else 0", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.id_apply", "code": "theorem id_apply (M : Mat_ C) (i j : M.\u03b9) :\n    (\ud835\udfd9 M : Hom M M) i j = if h : i = j then eqToHom (congr_arg M.X h) else 0", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.id_apply_self", "code": "@[simp]\ntheorem id_apply_self (M : Mat_ C) (i : M.\u03b9) : (\ud835\udfd9 M : Hom M M) i i = \ud835\udfd9 _", "start": [136, 1], "end": [137, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.id_apply_of_ne", "code": "@[simp]\ntheorem id_apply_of_ne (M : Mat_ C) (i j : M.\u03b9) (h : i \u2260 j) : (\ud835\udfd9 M : Hom M M) i j = 0", "start": [141, 1], "end": [143, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.comp_def", "code": "theorem comp_def {M N K : Mat_ C} (f : M \u27f6 N) (g : N \u27f6 K) :\n    f \u226b g = fun i k => \u2211 j : N.\u03b9, f i j \u226b g j k", "start": [147, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.comp_apply", "code": "@[simp]\ntheorem comp_apply {M N K : Mat_ C} (f : M \u27f6 N) (g : N \u27f6 K) (i k) :\n    (f \u226b g) i k = \u2211 j : N.\u03b9, f i j \u226b g j k", "start": [153, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.add_apply", "code": "@[simp]\ntheorem add_apply {M N : Mat_ C} (f g : M \u27f6 N) (i j) : (f + g) i j = f i j + g i j", "start": [171, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.hasFiniteBiproducts", "code": "instance hasFiniteBiproducts : HasFiniteBiproducts (Mat_ C) where\n  out n :=\n    { has_biproduct := fun f =>\n        hasBiproduct_of_total\n          { pt := \u27e8\u03a3 j, (f j).\u03b9, fun p => (f p.1).X p.2\u27e9\n            \u03c0 := fun j x y => by\n              refine' if h : x.1 = j then _ else 0\n              refine' if h' : @Eq.ndrec (Fin n) x.1 (fun j => (f j).\u03b9) x.2 _ h = y then _ else 0\n              apply eqToHom\n              substs h h'\n              rfl\n            \u03b9 := fun j x y => by\n              refine' if h : y.1 = j then _ else 0\n              refine' if h' : @Eq.ndrec _ y.1 (fun j => (f j).\u03b9) y.2 _ h = x then _ else 0\n              apply eqToHom\n              substs h h'\n              rfl\n            \u03b9_\u03c0 := fun j j' => by\n              ext x y\n              dsimp\n              simp_rw [dite_comp, comp_dite]\n              simp only [ite_self, dite_eq_ite, dif_ctx_congr, Limits.comp_zero, Limits.zero_comp,\n                eqToHom_trans, Finset.sum_congr]\n              erw [Finset.sum_sigma]\n              dsimp\n              simp only [if_congr, if_true, dif_ctx_congr, Finset.sum_dite_irrel, Finset.mem_univ,\n                Finset.sum_const_zero, Finset.sum_congr, Finset.sum_dite_eq']\n              split_ifs with h h'\n              \u00b7 substs h h'\n                simp only [CategoryTheory.eqToHom_refl, CategoryTheory.Mat_.id_apply_self]\n              \u00b7 subst h\n                rw [eqToHom_refl, id_apply_of_ne _ _ _ h']\n              \u00b7 rfl }\n          (by\n            dsimp\n            ext1 \u27e8i, j\u27e9\n            rintro \u27e8i', j'\u27e9\n            rw [Finset.sum_apply, Finset.sum_apply]\n            dsimp\n            rw [Finset.sum_eq_single i]; rotate_left\n            \u00b7 intro b _ hb\n              apply Finset.sum_eq_zero\n              intro x _\n              rw [dif_neg hb.symm, zero_comp]\n            \u00b7 intro hi\n              simp at hi\n            rw [Finset.sum_eq_single j]; rotate_left\n            \u00b7 intro b _ hb\n              rw [dif_pos rfl, dif_neg, zero_comp]\n              simp only\n              tauto\n            \u00b7 intro hj\n              simp at hj\n            simp only [eqToHom_refl, dite_eq_ite, ite_true, Category.id_comp, ne_eq,\n              Sigma.mk.inj_iff, not_and, id_def]\n            by_cases i' = i\n            \u00b7 subst h\n              rw [dif_pos rfl]\n              simp only [heq_eq_eq, true_and]\n              by_cases j' = j\n              \u00b7 subst h\n                simp\n              \u00b7 rw [dif_neg h, dif_neg (Ne.symm h)]\n            \u00b7 rw [dif_neg h, dif_neg]\n              tauto) }", "start": [183, 1], "end": [255, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapMat_", "code": "@[simps]\ndef mapMat_ (F : C \u2964 D) [Functor.Additive F] : Mat_ C \u2964 Mat_ D where\n  obj M := \u27e8M.\u03b9, fun i => F.obj (M.X i)\u27e9\n  map f i j := F.map (f i j)", "start": [267, 1], "end": [272, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapMatId", "code": "@[simps!]\ndef mapMatId : (\ud835\udfed C).mapMat_ \u2245 \ud835\udfed (Mat_ C) :=\n  NatIso.ofComponents (fun M => eqToIso (by cases M; rfl)) fun {M N} f => by\n    ext\n    cases M; cases N\n    simp [comp_dite, dite_comp]", "start": [276, 1], "end": [283, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapMatComp", "code": "@[simps!]\ndef mapMatComp {E : Type*} [Category.{v\u2081} E] [Preadditive E] (F : C \u2964 D) [Functor.Additive F]\n    (G : D \u2964 E) [Functor.Additive G] : (F \u22d9 G).mapMat_ \u2245 F.mapMat_ \u22d9 G.mapMat_ :=\n  NatIso.ofComponents (fun M => eqToIso (by cases M; rfl)) fun {M N} f => by\n    ext\n    cases M; cases N\n    simp [comp_dite, dite_comp]", "start": [287, 1], "end": [295, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.embedding", "code": "@[simps]\ndef embedding : C \u2964 Mat_ C where\n  obj X := \u27e8PUnit, fun _ => X\u27e9\n  map f _ _ := f\n  map_id _ := by ext \u27e8\u27e9; simp\n  map_comp _ _ := by ext \u27e8\u27e9; simp", "start": [303, 1], "end": [310, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.isoBiproductEmbedding", "code": "@[simps]\ndef isoBiproductEmbedding (M : Mat_ C) : M \u2245 \u2a01 fun i => (embedding C).obj (M.X i) where\n  hom := biproduct.lift fun i j k => if h : j = i then eqToHom (congr_arg M.X h) else 0\n  inv := biproduct.desc fun i j k => if h : i = k then eqToHom (congr_arg M.X h) else 0\n  hom_inv_id := by\n    simp only [biproduct.lift_desc]\n    funext i j\n    dsimp [id_def]\n    rw [Finset.sum_apply, Finset.sum_apply, Finset.sum_eq_single i]; rotate_left\n    \u00b7 intro b _ hb\n      dsimp\n      simp only [Finset.sum_const, Finset.card_singleton, one_smul]\n      rw [dif_neg hb.symm, zero_comp]\n    \u00b7 intro h\n      simp at h\n    simp\n  inv_hom_id := by\n    apply biproduct.hom_ext\n    intro i\n    apply biproduct.hom_ext'\n    intro j\n    simp only [Category.id_comp, Category.assoc, biproduct.lift_\u03c0, biproduct.\u03b9_desc_assoc,\n      biproduct.\u03b9_\u03c0]\n    ext \u27e8\u27e9 \u27e8\u27e9\n    simp only [embedding, comp_apply, comp_dite, dite_comp, comp_zero, zero_comp,\n      Finset.sum_dite_eq', Finset.mem_univ, ite_true, eqToHom_refl, Category.comp_id]\n    split_ifs with h\n    \u00b7 subst h\n      simp\n    \u00b7 rfl", "start": [332, 1], "end": [363, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.additiveObjIsoBiproduct", "code": "def additiveObjIsoBiproduct (F : Mat_ C \u2964 D) [Functor.Additive F] (M : Mat_ C) :\n    F.obj M \u2245 \u2a01 fun i => F.obj ((embedding C).obj (M.X i)) :=\n  F.mapIso (isoBiproductEmbedding M) \u226a\u226b F.mapBiproduct _", "start": [377, 1], "end": [380, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.additiveObjIsoBiproduct_hom_\u03c0", "code": "@[reassoc (attr := simp)]\nlemma additiveObjIsoBiproduct_hom_\u03c0 (F : Mat_ C \u2964 D) [Functor.Additive F] (M : Mat_ C) (i : M.\u03b9) :\n    (additiveObjIsoBiproduct F M).hom \u226b biproduct.\u03c0 _ i =\n      F.map (M.isoBiproductEmbedding.hom \u226b biproduct.\u03c0 _ i) := by\n  dsimp [additiveObjIsoBiproduct]\n  rw [biproduct.lift_\u03c0, Category.assoc]\n  erw [biproduct.lift_\u03c0, \u2190 F.map_comp]\n  simp", "start": [384, 1], "end": [391, 7], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Mat_.\u03b9_additiveObjIsoBiproduct_inv", "code": "@[reassoc (attr := simp)]\nlemma \u03b9_additiveObjIsoBiproduct_inv (F : Mat_ C \u2964 D) [Functor.Additive F] (M : Mat_ C) (i : M.\u03b9) :\n    biproduct.\u03b9 _ i \u226b (additiveObjIsoBiproduct F M).inv =\n      F.map (biproduct.\u03b9 _ i \u226b M.isoBiproductEmbedding.inv) := by\n  dsimp [additiveObjIsoBiproduct, Functor.mapBiproduct, Functor.mapBicone]\n  simp only [biproduct.\u03b9_desc, biproduct.\u03b9_desc_assoc, \u2190 F.map_comp]", "start": [393, 1], "end": [398, 69], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Mat_.additiveObjIsoBiproduct_naturality", "code": "@[reassoc]\ntheorem additiveObjIsoBiproduct_naturality (F : Mat_ C \u2964 D) [Functor.Additive F] {M N : Mat_ C}\n    (f : M \u27f6 N) :\n    F.map f \u226b (additiveObjIsoBiproduct F N).hom =\n      (additiveObjIsoBiproduct F M).hom \u226b\n        biproduct.matrix fun i j => F.map ((embedding C).map (f i j))", "start": [402, 1], "end": [417, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.additiveObjIsoBiproduct_naturality'", "code": "@[reassoc]\ntheorem additiveObjIsoBiproduct_naturality' (F : Mat_ C \u2964 D) [Functor.Additive F] {M N : Mat_ C}\n    (f : M \u27f6 N) :\n    (additiveObjIsoBiproduct F M).inv \u226b F.map f =\n      biproduct.matrix (fun i j => F.map ((embedding C).map (f i j)) : _) \u226b\n        (additiveObjIsoBiproduct F N).inv", "start": [421, 1], "end": [427, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.lift", "code": "@[simps]\ndef lift (F : C \u2964 D) [Functor.Additive F] : Mat_ C \u2964 D where\n  obj X := \u2a01 fun i => F.obj (X.X i)\n  map f := biproduct.matrix fun i j => F.map (f i j)\n  map_id X := by\n    dsimp\n    ext i j\n    by_cases h : j = i\n    \u00b7 subst h; simp\n    \u00b7 simp [h]", "start": [433, 1], "end": [444, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.lift_additive", "code": "instance lift_additive (F : C \u2964 D) [Functor.Additive F] : Functor.Additive (lift F) where", "start": [448, 1], "end": [448, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.embeddingLiftIso", "code": "@[simps!]\ndef embeddingLiftIso (F : C \u2964 D) [Functor.Additive F] : embedding C \u22d9 lift F \u2245 F :=\n  NatIso.ofComponents\n    (fun X =>\n      { hom := biproduct.desc fun _ => \ud835\udfd9 (F.obj X)\n        inv := biproduct.lift fun _ => \ud835\udfd9 (F.obj X) })", "start": [452, 1], "end": [458, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.liftUnique", "code": "def liftUnique (F : C \u2964 D) [Functor.Additive F] (L : Mat_ C \u2964 D) [Functor.Additive L]\n    (\u03b1 : embedding C \u22d9 L \u2245 F) : L \u2245 lift F :=\n  NatIso.ofComponents\n    (fun M =>\n      additiveObjIsoBiproduct L M \u226a\u226b\n        (biproduct.mapIso fun i => \u03b1.app (M.X i)) \u226a\u226b\n          (biproduct.mapIso fun i => (embeddingLiftIso F).symm.app (M.X i)) \u226a\u226b\n            (additiveObjIsoBiproduct (lift F) M).symm)\n    fun f => by\n      dsimp only [Iso.trans_hom, Iso.symm_hom, biproduct.mapIso_hom]\n      simp only [additiveObjIsoBiproduct_naturality_assoc]\n      simp only [biproduct.matrix_map_assoc, Category.assoc]\n      simp only [additiveObjIsoBiproduct_naturality']\n      simp only [biproduct.map_matrix_assoc, Category.assoc]\n      congr 3\n      ext j k\n      apply biproduct.hom_ext\n      rintro \u27e8\u27e9\n      dsimp\n      simpa using \u03b1.hom.naturality (f j k)", "start": [462, 1], "end": [483, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.ext", "code": "def ext {F G : Mat_ C \u2964 D} [Functor.Additive F] [Functor.Additive G]\n    (\u03b1 : embedding C \u22d9 F \u2245 embedding C \u22d9 G) : F \u2245 G :=\n  liftUnique (embedding C \u22d9 G) _ \u03b1 \u226a\u226b (liftUnique _ _ (Iso.refl _)).symm", "start": [489, 1], "end": [493, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.equivalenceSelfOfHasFiniteBiproductsAux", "code": "def equivalenceSelfOfHasFiniteBiproductsAux [HasFiniteBiproducts C] :\n    embedding C \u22d9 \ud835\udfed (Mat_ C) \u2245 embedding C \u22d9 lift (\ud835\udfed C) \u22d9 embedding C :=\n  Functor.rightUnitor _ \u226a\u226b\n    (Functor.leftUnitor _).symm \u226a\u226b\n      isoWhiskerRight (embeddingLiftIso _).symm _ \u226a\u226b Functor.associator _ _ _", "start": [497, 1], "end": [503, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.equivalenceSelfOfHasFiniteBiproducts", "code": "def equivalenceSelfOfHasFiniteBiproducts (C : Type (u\u2081 + 1)) [LargeCategory C] [Preadditive C]\n    [HasFiniteBiproducts C] : Mat_ C \u224c C :=\n  Equivalence.mk\n    (lift\n      (\ud835\udfed C))\n    (embedding C) (ext equivalenceSelfOfHasFiniteBiproductsAux) (embeddingLiftIso (\ud835\udfed C))", "start": [507, 1], "end": [519, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.equivalenceSelfOfHasFiniteBiproducts_functor", "code": "@[simp]\ntheorem equivalenceSelfOfHasFiniteBiproducts_functor {C : Type (u\u2081 + 1)} [LargeCategory C]\n    [Preadditive C] [HasFiniteBiproducts C] :\n    (equivalenceSelfOfHasFiniteBiproducts C).functor = lift (\ud835\udfed C)", "start": [523, 1], "end": [527, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat_.equivalenceSelfOfHasFiniteBiproducts_inverse", "code": "@[simp]\ntheorem equivalenceSelfOfHasFiniteBiproducts_inverse {C : Type (u\u2081 + 1)} [LargeCategory C]\n    [Preadditive C] [HasFiniteBiproducts C] :\n    (equivalenceSelfOfHasFiniteBiproducts C).inverse = embedding C", "start": [531, 1], "end": [535, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat", "code": "@[nolint unusedArguments]\ndef Mat (_ : Type u) :=\n  FintypeCat.{u}", "start": [543, 1], "end": [547, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat.hom_ext", "code": "@[ext]\ntheorem hom_ext {X Y : Mat R} (f g : X \u27f6 Y) (h : \u2200 i j, f i j = g i j) : f = g", "start": [574, 1], "end": [576, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat.id_def", "code": "theorem id_def (M : Mat R) : \ud835\udfd9 M = fun i j => if i = j then 1 else 0", "start": [580, 1], "end": [581, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat.id_apply", "code": "theorem id_apply (M : Mat R) (i j : M) : (\ud835\udfd9 M : Matrix M M R) i j = if i = j then 1 else 0", "start": [585, 1], "end": [586, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat.id_apply_self", "code": "@[simp]\ntheorem id_apply_self (M : Mat R) (i : M) : (\ud835\udfd9 M : Matrix M M R) i i = 1", "start": [590, 1], "end": [591, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat.id_apply_of_ne", "code": "@[simp]\ntheorem id_apply_of_ne (M : Mat R) (i j : M) (h : i \u2260 j) : (\ud835\udfd9 M : Matrix M M R) i j = 0", "start": [595, 1], "end": [597, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat.comp_def", "code": "theorem comp_def {M N K : Mat R} (f : M \u27f6 N) (g : N \u27f6 K) :\n    f \u226b g = fun i k => \u2211 j : N, f i j * g j k", "start": [601, 1], "end": [603, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat.comp_apply", "code": "@[simp]\ntheorem comp_apply {M N K : Mat R} (f : M \u27f6 N) (g : N \u27f6 K) (i k) :\n    (f \u226b g) i k = \u2211 j : N, f i j * g j k", "start": [607, 1], "end": [610, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat.equivalenceSingleObjInverse", "code": "@[simps]\ndef equivalenceSingleObjInverse : Mat_ (SingleObj R\u1d50\u1d52\u1d56) \u2964 Mat R where\n  obj X := FintypeCat.of X.\u03b9\n  map f i j := MulOpposite.unop (f i j)\n  map_id X := by\n    ext\n    simp only [Mat_.id_def, id_def]\n    split_ifs <;> rfl\n  map_comp f g := by\n    ext\n    simp only [Mat_.comp_apply, comp_apply]\n    apply Finset.unop_sum", "start": [623, 1], "end": [636, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat.equivalenceSingleObj", "code": "def equivalenceSingleObj : Mat R \u224c Mat_ (SingleObj R\u1d50\u1d52\u1d56) :=\n  haveI := Equivalence.ofFullyFaithfullyEssSurj (equivalenceSingleObjInverse R)\n  (equivalenceSingleObjInverse R).asEquivalence.symm", "start": [654, 1], "end": [658, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mat.add_apply", "code": "@[simp]\ntheorem add_apply {M N : Mat R} (f g : M \u27f6 N) (i j) : (f + g) i j = f i j + g i j", "start": [670, 1], "end": [672, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/ProjectiveSpace/Independence.lean", "imports": ["Mathlib/LinearAlgebra/ProjectiveSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Projectivization.Independent", "code": "inductive Independent : (\u03b9 \u2192 \u2119 K V) \u2192 Prop\n  | mk (f : \u03b9 \u2192 V) (hf : \u2200 i : \u03b9, f i \u2260 0) (hl : LinearIndependent K f) :\n    Independent fun i => mk K (f i) (hf i)", "start": [38, 1], "end": [42, 43], "kind": "commanddeclaration"}, {"full_name": "Projectivization.independent_iff", "code": "theorem independent_iff : Independent f \u2194 LinearIndependent K (Projectivization.rep \u2218 f)", "start": [45, 1], "end": [57, 24], "kind": "commanddeclaration"}, {"full_name": "Projectivization.independent_iff_completeLattice_independent", "code": "theorem independent_iff_completeLattice_independent :\n    Independent f \u2194 CompleteLattice.Independent fun i => (f i).submodule", "start": [60, 1], "end": [71, 30], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Dependent", "code": "inductive Dependent : (\u03b9 \u2192 \u2119 K V) \u2192 Prop\n  | mk (f : \u03b9 \u2192 V) (hf : \u2200 i : \u03b9, f i \u2260 0) (h : \u00acLinearIndependent K f) :\n    Dependent fun i => mk K (f i) (hf i)", "start": [74, 1], "end": [78, 41], "kind": "commanddeclaration"}, {"full_name": "Projectivization.dependent_iff", "code": "theorem dependent_iff : Dependent f \u2194 \u00acLinearIndependent K (Projectivization.rep \u2218 f)", "start": [81, 1], "end": [93, 39], "kind": "commanddeclaration"}, {"full_name": "Projectivization.dependent_iff_not_independent", "code": "theorem dependent_iff_not_independent : Dependent f \u2194 \u00acIndependent f", "start": [96, 1], "end": [98, 38], "kind": "commanddeclaration"}, {"full_name": "Projectivization.independent_iff_not_dependent", "code": "theorem independent_iff_not_dependent : Independent f \u2194 \u00acDependent f", "start": [101, 1], "end": [103, 56], "kind": "commanddeclaration"}, {"full_name": "Projectivization.dependent_pair_iff_eq", "code": "@[simp]\ntheorem dependent_pair_iff_eq (u v : \u2119 K V) : Dependent ![u, v] \u2194 u = v", "start": [106, 1], "end": [113, 31], "kind": "commanddeclaration"}, {"full_name": "Projectivization.independent_pair_iff_neq", "code": "@[simp]\ntheorem independent_pair_iff_neq (u v : \u2119 K V) : Independent ![u, v] \u2194 u \u2260 v", "start": [116, 1], "end": [119, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Adjunction/Over.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "Mathlib/CategoryTheory/Monad/Products.lean", "Mathlib/CategoryTheory/Over.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.star", "code": "@[simps! obj_left obj_hom map_left]\ndef star [HasBinaryProducts C] : C \u2964 Over X :=\n  cofree _ \u22d9 coalgebraToOver X", "start": [32, 1], "end": [37, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.forgetAdjStar", "code": "def forgetAdjStar [HasBinaryProducts C] : Over.forget X \u22a3 star X :=\n  (coalgebraEquivOver X).symm.toAdjunction.comp (adj _)", "start": [40, 1], "end": [46, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/HausdorffDimension.lean", "imports": ["Mathlib/Analysis/Calculus/ContDiff.lean", "Mathlib/MeasureTheory/Measure/Hausdorff.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "dimH", "code": "@[irreducible] noncomputable def dimH (s : Set X) : \u211d\u22650\u221e := by\n  borelize X; exact \u2a06 (d : \u211d\u22650) (_ : @hausdorffMeasure X _ _ \u27e8rfl\u27e9 d s = \u221e), d", "start": [93, 1], "end": [95, 79], "kind": "commanddeclaration"}, {"full_name": "dimH_def", "code": "theorem dimH_def (s : Set X) : dimH s = \u2a06 (d : \u211d\u22650) (_ : \u03bcH[d] s = \u221e), (d : \u211d\u22650\u221e)", "start": [108, 1], "end": [111, 24], "kind": "commanddeclaration"}, {"full_name": "hausdorffMeasure_of_lt_dimH", "code": "theorem hausdorffMeasure_of_lt_dimH {s : Set X} {d : \u211d\u22650} (h : \u2191d < dimH s) : \u03bcH[d] s = \u221e", "start": [115, 1], "end": [119, 60], "kind": "commanddeclaration"}, {"full_name": "dimH_le", "code": "theorem dimH_le {s : Set X} {d : \u211d\u22650\u221e} (H : \u2200 d' : \u211d\u22650, \u03bcH[d'] s = \u221e \u2192 \u2191d' \u2264 d) : dimH s \u2264 d", "start": [123, 1], "end": [124, 38], "kind": "commanddeclaration"}, {"full_name": "dimH_le_of_hausdorffMeasure_ne_top", "code": "theorem dimH_le_of_hausdorffMeasure_ne_top {s : Set X} {d : \u211d\u22650} (h : \u03bcH[d] s \u2260 \u221e) : dimH s \u2264 d", "start": [128, 1], "end": [129, 51], "kind": "commanddeclaration"}, {"full_name": "le_dimH_of_hausdorffMeasure_eq_top", "code": "theorem le_dimH_of_hausdorffMeasure_eq_top {s : Set X} {d : \u211d\u22650} (h : \u03bcH[d] s = \u221e) :\n    \u2191d \u2264 dimH s", "start": [133, 1], "end": [135, 48], "kind": "commanddeclaration"}, {"full_name": "hausdorffMeasure_of_dimH_lt", "code": "theorem hausdorffMeasure_of_dimH_lt {s : Set X} {d : \u211d\u22650} (h : dimH s < d) : \u03bcH[d] s = 0", "start": [139, 1], "end": [144, 31], "kind": "commanddeclaration"}, {"full_name": "measure_zero_of_dimH_lt", "code": "theorem measure_zero_of_dimH_lt {\u03bc : Measure X} {d : \u211d\u22650} (h : \u03bc \u226a \u03bcH[d]) {s : Set X}\n    (hd : dimH s < d) : \u03bc s = 0", "start": [148, 1], "end": [150, 38], "kind": "commanddeclaration"}, {"full_name": "le_dimH_of_hausdorffMeasure_ne_zero", "code": "theorem le_dimH_of_hausdorffMeasure_ne_zero {s : Set X} {d : \u211d\u22650} (h : \u03bcH[d] s \u2260 0) : \u2191d \u2264 dimH s", "start": [154, 1], "end": [155, 51], "kind": "commanddeclaration"}, {"full_name": "dimH_of_hausdorffMeasure_ne_zero_ne_top", "code": "theorem dimH_of_hausdorffMeasure_ne_zero_ne_top {d : \u211d\u22650} {s : Set X} (h : \u03bcH[d] s \u2260 0)\n    (h' : \u03bcH[d] s \u2260 \u221e) : dimH s = d", "start": [159, 1], "end": [161, 94], "kind": "commanddeclaration"}, {"full_name": "dimH_mono", "code": "@[mono]\ntheorem dimH_mono {s t : Set X} (h : s \u2286 t) : dimH s \u2264 dimH t", "start": [167, 1], "end": [170, 100], "kind": "commanddeclaration"}, {"full_name": "dimH_subsingleton", "code": "theorem dimH_subsingleton {s : Set X} (h : s.Subsingleton) : dimH s = 0", "start": [174, 1], "end": [178, 92], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.dimH_zero", "code": "alias Set.Subsingleton.dimH_zero := dimH_subsingleton", "start": [182, 1], "end": [182, 54], "kind": "stdtacticaliasalias"}, {"full_name": "dimH_empty", "code": "@[simp]\ntheorem dimH_empty : dimH (\u2205 : Set X) = 0", "start": [186, 1], "end": [188, 31], "kind": "commanddeclaration"}, {"full_name": "dimH_singleton", "code": "@[simp]\ntheorem dimH_singleton (x : X) : dimH ({x} : Set X) = 0", "start": [192, 1], "end": [194, 35], "kind": "commanddeclaration"}, {"full_name": "dimH_iUnion", "code": "@[simp]\ntheorem dimH_iUnion [Encodable \u03b9] (s : \u03b9 \u2192 Set X) : dimH (\u22c3 i, s i) = \u2a06 i, dimH (s i)", "start": [198, 1], "end": [206, 28], "kind": "commanddeclaration"}, {"full_name": "dimH_bUnion", "code": "@[simp]\ntheorem dimH_bUnion {s : Set \u03b9} (hs : s.Countable) (t : \u03b9 \u2192 Set X) :\n    dimH (\u22c3 i \u2208 s, t i) = \u2a06 i \u2208 s, dimH (t i)", "start": [210, 1], "end": [214, 56], "kind": "commanddeclaration"}, {"full_name": "dimH_sUnion", "code": "@[simp]\ntheorem dimH_sUnion {S : Set (Set X)} (hS : S.Countable) : dimH (\u22c3\u2080 S) = \u2a06 s \u2208 S, dimH s", "start": [218, 1], "end": [220, 41], "kind": "commanddeclaration"}, {"full_name": "dimH_union", "code": "@[simp]\ntheorem dimH_union (s t : Set X) : dimH (s \u222a t) = max (dimH s) (dimH t)", "start": [224, 1], "end": [226, 82], "kind": "commanddeclaration"}, {"full_name": "dimH_countable", "code": "theorem dimH_countable {s : Set X} (hs : s.Countable) : dimH s = 0", "start": [230, 1], "end": [231, 100], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.dimH_zero", "code": "alias Set.Countable.dimH_zero := dimH_countable", "start": [235, 1], "end": [235, 48], "kind": "stdtacticaliasalias"}, {"full_name": "dimH_finite", "code": "theorem dimH_finite {s : Set X} (hs : s.Finite) : dimH s = 0", "start": [239, 1], "end": [240, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.dimH_zero", "code": "alias Set.Finite.dimH_zero := dimH_finite", "start": [244, 1], "end": [244, 42], "kind": "stdtacticaliasalias"}, {"full_name": "dimH_coe_finset", "code": "@[simp]\ntheorem dimH_coe_finset (s : Finset X) : dimH (s : Set X) = 0", "start": [248, 1], "end": [250, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.dimH_zero", "code": "alias Finset.dimH_zero := dimH_coe_finset", "start": [254, 1], "end": [254, 42], "kind": "stdtacticaliasalias"}, {"full_name": "exists_mem_nhdsWithin_lt_dimH_of_lt_dimH", "code": "theorem exists_mem_nhdsWithin_lt_dimH_of_lt_dimH {s : Set X} {r : \u211d\u22650\u221e} (h : r < dimH s) :\n    \u2203 x \u2208 s, \u2200 t \u2208 \ud835\udcdd[s] x, r < dimH t", "start": [267, 1], "end": [277, 50], "kind": "commanddeclaration"}, {"full_name": "bsupr_limsup_dimH", "code": "theorem bsupr_limsup_dimH (s : Set X) : \u2a06 x \u2208 s, limsup dimH (\ud835\udcdd[s] x).smallSets = dimH s", "start": [281, 1], "end": [292, 49], "kind": "commanddeclaration"}, {"full_name": "iSup_limsup_dimH", "code": "theorem iSup_limsup_dimH (s : Set X) : \u2a06 x, limsup dimH (\ud835\udcdd[s] x).smallSets = dimH s", "start": [296, 1], "end": [303, 54], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.dimH_image_le", "code": "theorem HolderOnWith.dimH_image_le (h : HolderOnWith C r f s) (hr : 0 < r) :\n    dimH (f '' s) \u2264 dimH s / r", "start": [316, 1], "end": [328, 31], "kind": "commanddeclaration"}, {"full_name": "HolderWith.dimH_image_le", "code": "theorem dimH_image_le (h : HolderWith C r f) (hr : 0 < r) (s : Set X) :\n    dimH (f '' s) \u2264 dimH s / r", "start": [334, 1], "end": [338, 38], "kind": "commanddeclaration"}, {"full_name": "HolderWith.dimH_range_le", "code": "theorem dimH_range_le (h : HolderWith C r f) (hr : 0 < r) :\n    dimH (range f) \u2264 dimH (univ : Set X) / r", "start": [342, 1], "end": [346, 46], "kind": "commanddeclaration"}, {"full_name": "dimH_image_le_of_locally_holder_on", "code": "theorem dimH_image_le_of_locally_holder_on [SecondCountableTopology X] {r : \u211d\u22650} {f : X \u2192 Y}\n    (hr : 0 < r) {s : Set X} (hf : \u2200 x \u2208 s, \u2203 C : \u211d\u22650, \u2203 t \u2208 \ud835\udcdd[s] x, HolderOnWith C r f t) :\n    dimH (f '' s) \u2264 dimH s / r", "start": [352, 1], "end": [363, 96], "kind": "commanddeclaration"}, {"full_name": "dimH_range_le_of_locally_holder_on", "code": "theorem dimH_range_le_of_locally_holder_on [SecondCountableTopology X] {r : \u211d\u22650} {f : X \u2192 Y}\n    (hr : 0 < r) (hf : \u2200 x : X, \u2203 C : \u211d\u22650, \u2203 s \u2208 \ud835\udcdd x, HolderOnWith C r f s) :\n    dimH (range f) \u2264 dimH (univ : Set X) / r", "start": [367, 1], "end": [375, 55], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.dimH_image_le", "code": "theorem LipschitzOnWith.dimH_image_le (h : LipschitzOnWith K f s) : dimH (f '' s) \u2264 dimH s", "start": [384, 1], "end": [386, 55], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.dimH_image_le", "code": "theorem dimH_image_le (h : LipschitzWith K f) (s : Set X) : dimH (f '' s) \u2264 dimH s", "start": [392, 1], "end": [394, 38], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.dimH_range_le", "code": "theorem dimH_range_le (h : LipschitzWith K f) : dimH (range f) \u2264 dimH (univ : Set X)", "start": [398, 1], "end": [401, 43], "kind": "commanddeclaration"}, {"full_name": "dimH_image_le_of_locally_lipschitzOn", "code": "theorem dimH_image_le_of_locally_lipschitzOn [SecondCountableTopology X] {f : X \u2192 Y} {s : Set X}\n    (hf : \u2200 x \u2208 s, \u2203 C : \u211d\u22650, \u2203 t \u2208 \ud835\udcdd[s] x, LipschitzOnWith C f t) : dimH (f '' s) \u2264 dimH s", "start": [407, 1], "end": [414, 98], "kind": "commanddeclaration"}, {"full_name": "dimH_range_le_of_locally_lipschitzOn", "code": "theorem dimH_range_le_of_locally_lipschitzOn [SecondCountableTopology X] {f : X \u2192 Y}\n    (hf : \u2200 x : X, \u2203 C : \u211d\u22650, \u2203 s \u2208 \ud835\udcdd x, LipschitzOnWith C f s) :\n    dimH (range f) \u2264 dimH (univ : Set X)", "start": [418, 1], "end": [425, 55], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.dimH_preimage_le", "code": "theorem dimH_preimage_le (hf : AntilipschitzWith K f) (s : Set Y) : dimH (f \u207b\u00b9' s) \u2264 dimH s", "start": [431, 1], "end": [437, 42], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.le_dimH_image", "code": "theorem le_dimH_image (hf : AntilipschitzWith K f) (s : Set X) : dimH s \u2264 dimH (f '' s)", "start": [441, 1], "end": [444, 47], "kind": "commanddeclaration"}, {"full_name": "Isometry.dimH_image", "code": "theorem Isometry.dimH_image (hf : Isometry f) (s : Set X) : dimH (f '' s) = dimH s", "start": [455, 1], "end": [456, 80], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.dimH_image", "code": "@[simp]\ntheorem dimH_image (e : X \u2243\u1d62 Y) (s : Set X) : dimH (e '' s) = dimH s", "start": [462, 1], "end": [464, 26], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.dimH_preimage", "code": "@[simp]\ntheorem dimH_preimage (e : X \u2243\u1d62 Y) (s : Set Y) : dimH (e \u207b\u00b9' s) = dimH s", "start": [468, 1], "end": [470, 41], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.dimH_univ", "code": "theorem dimH_univ (e : X \u2243\u1d62 Y) : dimH (univ : Set X) = dimH (univ : Set Y)", "start": [474, 1], "end": [475, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.dimH_image", "code": "@[simp]\ntheorem dimH_image (e : E \u2243L[\ud835\udd5c] F) (s : Set E) : dimH (e '' s) = dimH s", "start": [486, 1], "end": [489, 82], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.dimH_preimage", "code": "@[simp]\ntheorem dimH_preimage (e : E \u2243L[\ud835\udd5c] F) (s : Set F) : dimH (e \u207b\u00b9' s) = dimH s", "start": [493, 1], "end": [495, 53], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.dimH_univ", "code": "theorem dimH_univ (e : E \u2243L[\ud835\udd5c] F) : dimH (univ : Set E) = dimH (univ : Set F)", "start": [499, 1], "end": [500, 40], "kind": "commanddeclaration"}, {"full_name": "Real.dimH_ball_pi", "code": "theorem dimH_ball_pi (x : \u03b9 \u2192 \u211d) {r : \u211d} (hr : 0 < r) :\n    dimH (Metric.ball x r) = Fintype.card \u03b9", "start": [515, 1], "end": [525, 34], "kind": "commanddeclaration"}, {"full_name": "Real.dimH_ball_pi_fin", "code": "theorem dimH_ball_pi_fin {n : \u2115} (x : Fin n \u2192 \u211d) {r : \u211d} (hr : 0 < r) :\n    dimH (Metric.ball x r) = n", "start": [529, 1], "end": [530, 78], "kind": "commanddeclaration"}, {"full_name": "Real.dimH_univ_pi", "code": "theorem dimH_univ_pi (\u03b9 : Type*) [Fintype \u03b9] : dimH (univ : Set (\u03b9 \u2192 \u211d)) = Fintype.card \u03b9", "start": [534, 1], "end": [536, 57], "kind": "commanddeclaration"}, {"full_name": "Real.dimH_univ_pi_fin", "code": "theorem dimH_univ_pi_fin (n : \u2115) : dimH (univ : Set (Fin n \u2192 \u211d)) = n", "start": [540, 1], "end": [541, 38], "kind": "commanddeclaration"}, {"full_name": "Real.dimH_of_mem_nhds", "code": "theorem dimH_of_mem_nhds {x : E} {s : Set E} (h : s \u2208 \ud835\udcdd x) : dimH s = finrank \u211d E", "start": [545, 1], "end": [553, 63], "kind": "commanddeclaration"}, {"full_name": "Real.dimH_of_nonempty_interior", "code": "theorem dimH_of_nonempty_interior {s : Set E} (h : (interior s).Nonempty) : dimH s = finrank \u211d E", "start": [557, 1], "end": [559, 52], "kind": "commanddeclaration"}, {"full_name": "Real.dimH_univ_eq_finrank", "code": "theorem dimH_univ_eq_finrank : dimH (univ : Set E) = finrank \u211d E", "start": [565, 1], "end": [566, 39], "kind": "commanddeclaration"}, {"full_name": "Real.dimH_univ", "code": "theorem dimH_univ : dimH (univ : Set \u211d) = 1", "start": [570, 1], "end": [571, 76], "kind": "commanddeclaration"}, {"full_name": "dense_compl_of_dimH_lt_finrank", "code": "theorem dense_compl_of_dimH_lt_finrank {s : Set E} (hs : dimH s < finrank \u211d E) : Dense s\u1d9c", "start": [580, 1], "end": [584, 21], "kind": "commanddeclaration"}, {"full_name": "ContDiffOn.dimH_image_le", "code": "theorem ContDiffOn.dimH_image_le {f : E \u2192 F} {s t : Set E} (hf : ContDiffOn \u211d 1 f s)\n    (hc : Convex \u211d s) (ht : t \u2286 s) : dimH (f '' t) \u2264 dimH t", "start": [596, 1], "end": [605, 40], "kind": "commanddeclaration"}, {"full_name": "ContDiff.dimH_range_le", "code": "theorem ContDiff.dimH_range_le {f : E \u2192 F} (h : ContDiff \u211d 1 f) : dimH (range f) \u2264 finrank \u211d E", "start": [609, 1], "end": [615, 51], "kind": "commanddeclaration"}, {"full_name": "ContDiffOn.dense_compl_image_of_dimH_lt_finrank", "code": "theorem ContDiffOn.dense_compl_image_of_dimH_lt_finrank [FiniteDimensional \u211d F] {f : E \u2192 F}\n    {s t : Set E} (h : ContDiffOn \u211d 1 f s) (hc : Convex \u211d s) (ht : t \u2286 s)\n    (htF : dimH t < finrank \u211d F) : Dense (f '' t)\u1d9c", "start": [619, 1], "end": [625, 73], "kind": "commanddeclaration"}, {"full_name": "ContDiff.dense_compl_range_of_finrank_lt_finrank", "code": "theorem ContDiff.dense_compl_range_of_finrank_lt_finrank [FiniteDimensional \u211d F] {f : E \u2192 F}\n    (h : ContDiff \u211d 1 f) (hEF : finrank \u211d E < finrank \u211d F) : Dense (range f)\u1d9c", "start": [629, 1], "end": [634, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Charpoly/Eigs.lean", "imports": ["Mathlib/FieldTheory/IsAlgClosed/Basic.lean", "Mathlib/Data/Polynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.det_eq_prod_roots_charpoly_of_splits", "code": "theorem det_eq_prod_roots_charpoly_of_splits (hAps : A.charpoly.Splits (RingHom.id R)) :\n    A.det = (Matrix.charpoly A).roots.prod", "start": [62, 1], "end": [66, 61], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_eq_sum_roots_charpoly_of_splits", "code": "theorem trace_eq_sum_roots_charpoly_of_splits (hAps : A.charpoly.Splits (RingHom.id R)) :\n    A.trace = (Matrix.charpoly A).roots.sum", "start": [69, 1], "end": [77, 85], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_eq_prod_roots_charpoly", "code": "theorem det_eq_prod_roots_charpoly [IsAlgClosed R] : A.det = (Matrix.charpoly A).roots.prod", "start": [82, 1], "end": [83, 71], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_eq_sum_roots_charpoly", "code": "theorem trace_eq_sum_roots_charpoly [IsAlgClosed R] : A.trace = (Matrix.charpoly A).roots.sum", "start": [86, 1], "end": [87, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/ProjectiveSpace/Subspace.lean", "imports": ["Mathlib/LinearAlgebra/ProjectiveSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Projectivization.Subspace", "code": "@[ext]\nstructure Subspace where\n  \n  carrier : Set (\u2119 K V)\n  \n  mem_add' (v w : V) (hv : v \u2260 0) (hw : w \u2260 0) (hvw : v + w \u2260 0) :\n    mk K v hv \u2208 carrier \u2192 mk K w hw \u2208 carrier \u2192 mk K (v + w) hvw \u2208 carrier", "start": [39, 1], "end": [48, 75], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.mem_carrier_iff", "code": "@[simp]\ntheorem mem_carrier_iff (A : Subspace K V) (x : \u2119 K V) : x \u2208 A.carrier \u2194 x \u2208 A", "start": [62, 1], "end": [64, 13], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.mem_add", "code": "theorem mem_add (T : Subspace K V) (v w : V) (hv : v \u2260 0) (hw : w \u2260 0) (hvw : v + w \u2260 0) :\n    Projectivization.mk K v hv \u2208 T \u2192\n      Projectivization.mk K w hw \u2208 T \u2192 Projectivization.mk K (v + w) hvw \u2208 T", "start": [67, 1], "end": [70, 27], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.spanCarrier", "code": "inductive spanCarrier (S : Set (\u2119 K V)) : Set (\u2119 K V)\n  | of (x : \u2119 K V) (hx : x \u2208 S) : spanCarrier S x\n  | mem_add (v w : V) (hv : v \u2260 0) (hw : w \u2260 0) (hvw : v + w \u2260 0) :\n      spanCarrier S (Projectivization.mk K v hv) \u2192\n      spanCarrier S (Projectivization.mk K w hw) \u2192 spanCarrier S (Projectivization.mk K (v + w) hvw)", "start": [73, 1], "end": [80, 101], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.span", "code": "def span (S : Set (\u2119 K V)) : Subspace K V where\n  carrier := spanCarrier S\n  mem_add' v w hv hw hvw := spanCarrier.mem_add v w hv hw hvw", "start": [83, 1], "end": [86, 62], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.subset_span", "code": "theorem subset_span (S : Set (\u2119 K V)) : S \u2286 span S", "start": [89, 1], "end": [90, 87], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.gi", "code": "def gi : GaloisInsertion (span : Set (\u2119 K V) \u2192 Subspace K V) SetLike.coe where\n  choice S _hS := span S\n  gc A B :=\n    \u27e8fun h => le_trans (subset_span _) h, by\n      intro h x hx\n      induction' hx with y hy\n      \u00b7 apply h\n        assumption\n      \u00b7 apply B.mem_add\n        assumption'\u27e9\n  le_l_u S := subset_span _\n  choice_eq _ _ := rfl", "start": [93, 1], "end": [106, 23], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.span_coe", "code": "@[simp]\ntheorem span_coe (W : Subspace K V) : span \u2191W = W", "start": [109, 1], "end": [112, 30], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.instInf", "code": "instance instInf : Inf (Subspace K V) :=\n  \u27e8fun A B =>\n    \u27e8A \u2293 B, fun _v _w hv hw _hvw h1 h2 =>\n      \u27e8A.mem_add _ _ hv hw _ h1.1 h2.1, B.mem_add _ _ hv hw _ h1.2 h2.2\u27e9\u27e9\u27e9", "start": [115, 1], "end": [119, 75], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.instInfSet", "code": "instance instInfSet : InfSet (Subspace K V) :=\n  \u27e8fun A =>\n    \u27e8sInf (SetLike.coe '' A), fun v w hv hw hvw h1 h2 t => by\n      rintro \u27e8s, hs, rfl\u27e9\n      exact s.mem_add v w hv hw _ (h1 s \u27e8s, hs, rfl\u27e9) (h2 s \u27e8s, hs, rfl\u27e9)\u27e9\u27e9", "start": [124, 1], "end": [129, 76], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.subspaceInhabited", "code": "instance subspaceInhabited : Inhabited (Subspace K V) where default := \u22a4", "start": [144, 1], "end": [144, 73], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.span_empty", "code": "@[simp]\ntheorem span_empty : span (\u2205 : Set (\u2119 K V)) = \u22a5", "start": [147, 1], "end": [149, 63], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.span_univ", "code": "@[simp]\ntheorem span_univ : span (Set.univ : Set (\u2119 K V)) = \u22a4", "start": [152, 1], "end": [157, 39], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.span_le_subspace_iff", "code": "theorem span_le_subspace_iff {S : Set (\u2119 K V)} {W : Subspace K V} : span S \u2264 W \u2194 S \u2286 W", "start": [160, 1], "end": [163, 12], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.monotone_span", "code": "@[mono]\ntheorem monotone_span : Monotone (span : Set (\u2119 K V) \u2192 Subspace K V)", "start": [166, 1], "end": [170, 19], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.subset_span_trans", "code": "theorem subset_span_trans {S T U : Set (\u2119 K V)} (hST : S \u2286 span T) (hTU : T \u2286 span U) :\n    S \u2286 span U", "start": [173, 1], "end": [175, 29], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.span_union", "code": "theorem span_union (S T : Set (\u2119 K V)) : span (S \u222a T) = span S \u2294 span T", "start": [178, 1], "end": [180, 27], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.span_iUnion", "code": "theorem span_iUnion {\u03b9} (s : \u03b9 \u2192 Set (\u2119 K V)) : span (\u22c3 i, s i) = \u2a06 i, span (s i)", "start": [183, 1], "end": [186, 28], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.sup_span", "code": "theorem sup_span {S : Set (\u2119 K V)} {W : Subspace K V} : W \u2294 span S = span (W \u222a S)", "start": [189, 1], "end": [192, 28], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.span_sup", "code": "theorem span_sup {S : Set (\u2119 K V)} {W : Subspace K V} : span S \u2294 W = span (S \u222a W)", "start": [195, 1], "end": [196, 28], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.mem_span", "code": "theorem mem_span {S : Set (\u2119 K V)} (u : \u2119 K V) :\n    u \u2208 span S \u2194 \u2200 W : Subspace K V, S \u2286 W \u2192 u \u2208 W", "start": [199, 1], "end": [204, 64], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.span_eq_sInf", "code": "theorem span_eq_sInf {S : Set (\u2119 K V)} : span S = sInf { W : Subspace K V| S \u2286 W }", "start": [207, 1], "end": [215, 63], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.span_eq_of_le", "code": "theorem span_eq_of_le {S : Set (\u2119 K V)} {W : Subspace K V} (hS : S \u2286 W) (hW : W \u2264 span S) :\n    span S = W", "start": [218, 1], "end": [223, 47], "kind": "commanddeclaration"}, {"full_name": "Projectivization.Subspace.span_eq_span_iff", "code": "theorem span_eq_span_iff {S T : Set (\u2119 K V)} : span S = span T \u2194 S \u2286 span T \u2227 T \u2286 span S", "start": [226, 1], "end": [230, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RepresentationTheory/Maschke.lean", "imports": ["Mathlib/Algebra/CharP/Invertible.lean", "Mathlib/LinearAlgebra/Basis/VectorSpace.lean", "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.conjugate", "code": "def conjugate (g : G) : W \u2192\u2097[k] V :=\n  .comp (.comp (GroupSmul.linearMap k V g\u207b\u00b9) \u03c0) (GroupSmul.linearMap k W g)", "start": [69, 1], "end": [71, 76], "kind": "commanddeclaration"}, {"full_name": "LinearMap.conjugate_apply", "code": "theorem conjugate_apply (g : G) (v : W) :\n    \u03c0.conjugate g v = MonoidAlgebra.single g\u207b\u00b9 (1 : k) \u2022 \u03c0 (MonoidAlgebra.single g (1 : k) \u2022 v)", "start": [74, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.conjugate_i", "code": "theorem conjugate_i (g : G) (v : V) : (conjugate \u03c0 g : W \u2192 V) (i v) = v", "start": [82, 1], "end": [84, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.sumOfConjugates", "code": "def sumOfConjugates : W \u2192\u2097[k] V :=\n  \u2211 g : G, \u03c0.conjugate g", "start": [91, 1], "end": [96, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.sumOfConjugates_apply", "code": "lemma sumOfConjugates_apply (v : W) : \u03c0.sumOfConjugates G v = \u2211 g : G, \u03c0.conjugate g v :=\n  LinearMap.sum_apply _ _ _", "start": [99, 1], "end": [100, 28], "kind": "mathlibtacticlemma"}, {"full_name": "LinearMap.sumOfConjugatesEquivariant", "code": "def sumOfConjugatesEquivariant : W \u2192\u2097[MonoidAlgebra k G] V :=\n  MonoidAlgebra.equivariantOfLinearOfComm (\u03c0.sumOfConjugates G) fun g v => by\n    simp only [sumOfConjugates_apply, Finset.smul_sum, conjugate_apply]\n    refine Fintype.sum_bijective (\u00b7 * g) (Group.mulRight_bijective g) _ _ fun i \u21a6 ?_\n    simp only [smul_smul, single_mul_single, mul_inv_rev, mul_inv_cancel_left, one_mul]", "start": [102, 1], "end": [108, 88], "kind": "commanddeclaration"}, {"full_name": "LinearMap.sumOfConjugatesEquivariant_apply", "code": "theorem sumOfConjugatesEquivariant_apply (v : W) :\n    \u03c0.sumOfConjugatesEquivariant G v = \u2211 g : G, \u03c0.conjugate g v", "start": [111, 1], "end": [113, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.equivariantProjection", "code": "def equivariantProjection : W \u2192\u2097[MonoidAlgebra k G] V :=\n  \u215f(Fintype.card G : k) \u2022 \u03c0.sumOfConjugatesEquivariant G", "start": [119, 1], "end": [123, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.equivariantProjection_apply", "code": "theorem equivariantProjection_apply (v : W) :\n    \u03c0.equivariantProjection G v = \u215f(Fintype.card G : k) \u2022 \u2211 g : G, \u03c0.conjugate g v", "start": [126, 1], "end": [128, 82], "kind": "commanddeclaration"}, {"full_name": "LinearMap.equivariantProjection_condition", "code": "theorem equivariantProjection_condition (v : V) : (\u03c0.equivariantProjection G) (i v) = v", "start": [130, 1], "end": [134, 41], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.exists_leftInverse_of_injective", "code": "theorem exists_leftInverse_of_injective (f : V \u2192\u2097[MonoidAlgebra k G] W)\n    (hf : LinearMap.ker f = \u22a5) :\n    \u2203 g : W \u2192\u2097[MonoidAlgebra k G] V, g.comp f = LinearMap.id", "start": [153, 1], "end": [159, 70], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.Submodule.exists_isCompl", "code": "theorem exists_isCompl (p : Submodule (MonoidAlgebra k G) V) :\n    \u2203 q : Submodule (MonoidAlgebra k G) V, IsCompl p q", "start": [164, 1], "end": [169, 29], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.Submodule.complementedLattice", "code": "instance complementedLattice : ComplementedLattice (Submodule (MonoidAlgebra k G) V) :=\n  \u27e8exists_isCompl\u27e9", "start": [172, 1], "end": [174, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Sigma/Interval.lean", "imports": ["Mathlib/Data/Sigma/Order.lean", "Mathlib/Order/LocallyFinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Sigma.card_Icc", "code": "theorem card_Icc : (Icc a b).card = if h : a.1 = b.1 then (Icc (h.rec a.2) b.2).card else 0", "start": [60, 1], "end": [61, 36], "kind": "commanddeclaration"}, {"full_name": "Sigma.card_Ico", "code": "theorem card_Ico : (Ico a b).card = if h : a.1 = b.1 then (Ico (h.rec a.2) b.2).card else 0", "start": [64, 1], "end": [65, 36], "kind": "commanddeclaration"}, {"full_name": "Sigma.card_Ioc", "code": "theorem card_Ioc : (Ioc a b).card = if h : a.1 = b.1 then (Ioc (h.rec a.2) b.2).card else 0", "start": [68, 1], "end": [69, 36], "kind": "commanddeclaration"}, {"full_name": "Sigma.card_Ioo", "code": "theorem card_Ioo : (Ioo a b).card = if h : a.1 = b.1 then (Ioo (h.rec a.2) b.2).card else 0", "start": [72, 1], "end": [73, 36], "kind": "commanddeclaration"}, {"full_name": "Sigma.Icc_mk_mk", "code": "@[simp]\ntheorem Icc_mk_mk : Icc (\u27e8i, a\u27e9 : Sigma \u03b1) \u27e8i, b\u27e9 = (Icc a b).map (Embedding.sigmaMk i)", "start": [80, 1], "end": [82, 14], "kind": "commanddeclaration"}, {"full_name": "Sigma.Ico_mk_mk", "code": "@[simp]\ntheorem Ico_mk_mk : Ico (\u27e8i, a\u27e9 : Sigma \u03b1) \u27e8i, b\u27e9 = (Ico a b).map (Embedding.sigmaMk i)", "start": [85, 1], "end": [87, 14], "kind": "commanddeclaration"}, {"full_name": "Sigma.Ioc_mk_mk", "code": "@[simp]\ntheorem Ioc_mk_mk : Ioc (\u27e8i, a\u27e9 : Sigma \u03b1) \u27e8i, b\u27e9 = (Ioc a b).map (Embedding.sigmaMk i)", "start": [90, 1], "end": [92, 14], "kind": "commanddeclaration"}, {"full_name": "Sigma.Ioo_mk_mk", "code": "@[simp]\ntheorem Ioo_mk_mk : Ioo (\u27e8i, a\u27e9 : Sigma \u03b1) \u27e8i, b\u27e9 = (Ioo a b).map (Embedding.sigmaMk i)", "start": [95, 1], "end": [97, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/Killing.lean", "imports": ["Mathlib/LinearAlgebra/PID.lean", "Mathlib/Algebra/Lie/Nilpotent.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Lie/Weights/Cartan.lean", "Mathlib/LinearAlgebra/Trace.lean", "Mathlib/Algebra/Lie/Semisimple.lean"], "premises": [{"full_name": "LieModule.traceForm", "code": "noncomputable def traceForm : L \u2192\u2097[R] L \u2192\u2097[R] R :=\n  ((LinearMap.mul _ _).compl\u2081\u2082 (\u03c6).toLinearMap (\u03c6).toLinearMap).compr\u2082 (trace R M)", "start": [54, 1], "end": [57, 83], "kind": "commanddeclaration"}, {"full_name": "LieModule.traceForm_apply_apply", "code": "lemma traceForm_apply_apply (x y : L) :\n    traceForm R L M x y = trace R _ (\u03c6 x \u2218\u2097 \u03c6 y) :=\n  rfl", "start": [59, 1], "end": [61, 6], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.traceForm_comm", "code": "lemma traceForm_comm (x y : L) : traceForm R L M x y = traceForm R L M y x :=\n  LinearMap.trace_mul_comm R (\u03c6 x) (\u03c6 y)", "start": [63, 1], "end": [64, 41], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.traceForm_flip", "code": "@[simp] lemma traceForm_flip : (traceForm R L M).flip = traceForm R L M :=\n  Eq.symm <| LinearMap.ext\u2082 <| traceForm_comm R L M", "start": [66, 1], "end": [67, 52], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.traceForm_apply_lie_apply", "code": "lemma traceForm_apply_lie_apply (x y z : L) :\n    traceForm R L M \u2045x, y\u2046 z = traceForm R L M x \u2045y, z\u2046 := by\n  calc traceForm R L M \u2045x, y\u2046 z\n      = trace R _ (\u03c6 \u2045x, y\u2046 \u2218\u2097 \u03c6 z) := by simp only [traceForm_apply_apply]\n    _ = trace R _ ((\u03c6 x * \u03c6 y - \u03c6 y * \u03c6 x) * \u03c6 z) := ?_\n    _ = trace R _ (\u03c6 x * (\u03c6 y * \u03c6 z)) - trace R _ (\u03c6 y * (\u03c6 x * \u03c6 z)) := ?_\n    _ = trace R _ (\u03c6 x * (\u03c6 y * \u03c6 z)) - trace R _ (\u03c6 x * (\u03c6 z * \u03c6 y)) := ?_\n    _ = traceForm R L M x \u2045y, z\u2046 := ?_\n  \u00b7 simp only [LieHom.map_lie, Ring.lie_def, \u2190 LinearMap.mul_eq_comp]\n  \u00b7 simp only [sub_mul, mul_sub, map_sub, mul_assoc]\n  \u00b7 simp only [LinearMap.trace_mul_cycle' R (\u03c6 x) (\u03c6 z) (\u03c6 y)]\n  \u00b7 simp only [traceForm_apply_apply, LieHom.map_lie, Ring.lie_def, mul_sub, map_sub,\n      \u2190 LinearMap.mul_eq_comp]", "start": [69, 1], "end": [84, 31], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.traceForm_apply_lie_apply'", "code": "lemma traceForm_apply_lie_apply' (x y z : L) :\n    traceForm R L M \u2045x, y\u2046 z = - traceForm R L M y \u2045x, z\u2046 :=\n  calc traceForm R L M \u2045x, y\u2046 z\n      = - traceForm R L M \u2045y, x\u2046 z := by rw [\u2190 lie_skew x y, map_neg, LinearMap.neg_apply]\n    _ = - traceForm R L M y \u2045x, z\u2046 := by rw [traceForm_apply_lie_apply]", "start": [86, 1], "end": [92, 72], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.lie_traceForm_eq_zero", "code": "@[simp] lemma lie_traceForm_eq_zero (x : L) : \u2045x, traceForm R L M\u2046 = 0 := by\n  ext y z\n  rw [LieHom.lie_apply, LinearMap.sub_apply, Module.Dual.lie_apply, LinearMap.zero_apply,\n    LinearMap.zero_apply, traceForm_apply_lie_apply', sub_self]", "start": [94, 1], "end": [98, 64], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.traceForm_eq_zero_of_isNilpotent", "code": "@[simp] lemma traceForm_eq_zero_of_isNilpotent [IsReduced R] [IsNilpotent R L M] :\n    traceForm R L M = 0 := by\n  ext x y\n  simp only [traceForm_apply_apply, LinearMap.zero_apply, \u2190 isNilpotent_iff_eq_zero]\n  apply LinearMap.isNilpotent_trace_of_isNilpotent\n  exact isNilpotent_toEndomorphism_of_isNilpotent\u2082 R L M x y", "start": [100, 1], "end": [105, 61], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.traceForm_eq_zero_if_mem_lcs_of_mem_ucs", "code": "lemma traceForm_eq_zero_if_mem_lcs_of_mem_ucs {x y : L} (k : \u2115)\n    (hx : x \u2208 (\u22a4 : LieIdeal R L).lcs L k) (hy : y \u2208 (\u22a5 : LieIdeal R L).ucs k) :\n    traceForm R L M x y = 0 := by\n  induction' k with k ih generalizing x y\n  \u00b7 replace hy : y = 0 := by simpa using hy\n    simp [hy]\n  \u00b7 rw [LieSubmodule.ucs_succ, LieSubmodule.mem_normalizer] at hy\n    simp_rw [LieIdeal.lcs_succ, \u2190 LieSubmodule.mem_coeSubmodule,\n      LieSubmodule.lieIdeal_oper_eq_linear_span', LieSubmodule.mem_top, true_and] at hx\n    refine Submodule.span_induction hx ?_ ?_ (fun z w hz hw \u21a6 ?_) (fun t z hz \u21a6 ?_)\n    \u00b7 rintro - \u27e8z, w, hw, rfl\u27e9\n      rw [\u2190 lie_skew, map_neg, LinearMap.neg_apply, neg_eq_zero, traceForm_apply_lie_apply]\n      exact ih hw (hy _)\n    \u00b7 simp\n    \u00b7 simp [hz, hw]\n    \u00b7 simp [hz]", "start": [107, 1], "end": [124, 16], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.traceForm_apply_eq_zero_of_mem_lcs_of_mem_center", "code": "lemma traceForm_apply_eq_zero_of_mem_lcs_of_mem_center {x y : L}\n    (hx : x \u2208 lowerCentralSeries R L L 1) (hy : y \u2208 LieAlgebra.center R L) :\n    traceForm R L M x y = 0 := by\n  apply traceForm_eq_zero_if_mem_lcs_of_mem_ucs R L M 1\n  \u00b7 simpa using hx\n  \u00b7 simpa using hy", "start": [126, 1], "end": [131, 19], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.traceForm_eq_zero_of_isTrivial", "code": "@[simp] lemma traceForm_eq_zero_of_isTrivial [IsTrivial L M] :\n    traceForm R L M = 0 := by\n  ext x y\n  suffices \u03c6 x \u2218\u2097 \u03c6 y = 0 by simp [traceForm_apply_apply, this]\n  ext m\n  simp", "start": [134, 1], "end": [139, 7], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.eq_zero_of_mem_weightSpace_mem_posFitting", "code": "lemma eq_zero_of_mem_weightSpace_mem_posFitting [LieAlgebra.IsNilpotent R L]\n    {B : M \u2192\u2097[R] M \u2192\u2097[R] R} (hB : \u2200 (x : L) (m n : M), B \u2045x, m\u2046 n = - B m \u2045x, n\u2046)\n    {m\u2080 m\u2081 : M} (hm\u2080 : m\u2080 \u2208 weightSpace M (0 : L \u2192 R)) (hm\u2081 : m\u2081 \u2208 posFittingComp R L M) :\n    B m\u2080 m\u2081 = 0 := by\n  replace hB : \u2200 x (k : \u2115) m n, B m ((\u03c6 x ^ k) n) = (- 1 : R) ^ k \u2022 B ((\u03c6 x ^ k) m) n := by\n    intro x k\n    induction' k with k ih; simp\n    intro m n\n    replace hB : \u2200 m, B m (\u03c6 x n) = (- 1 : R) \u2022 B (\u03c6 x m) n := by simp [hB]\n    have : (-1 : R) ^ k \u2022 (-1 : R) = (-1 : R) ^ (k + 1) := by rw [pow_succ' (-1 : R), smul_eq_mul]\n    conv_lhs => rw [pow_succ', LinearMap.mul_eq_comp, LinearMap.comp_apply, ih, hB,\n      \u2190 (\u03c6 x).comp_apply, \u2190 LinearMap.mul_eq_comp, \u2190 pow_succ, \u2190 smul_assoc, this]\n  suffices : \u2200 (x : L) m, m \u2208 posFittingCompOf R M x \u2192 B m\u2080 m = 0\n  \u00b7 apply LieSubmodule.iSup_induction _ hm\u2081 this (map_zero _)\n    aesop\n  clear hm\u2081 m\u2081; intro x m\u2081 hm\u2081\n  simp only [mem_weightSpace, Pi.zero_apply, zero_smul, sub_zero] at hm\u2080\n  obtain \u27e8k, hk\u27e9 := hm\u2080 x\n  obtain \u27e8m, rfl\u27e9 := (mem_posFittingCompOf R x m\u2081).mp hm\u2081 k\n  simp [hB, hk]", "start": [141, 1], "end": [163, 16], "kind": "mathlibtacticlemma"}, {"full_name": "LieSubmodule.trace_eq_trace_restrict_of_le_idealizer", "code": "lemma trace_eq_trace_restrict_of_le_idealizer\n    (hy' : \u2200 m \u2208 N, (\u03c6 x \u2218\u2097 \u03c6 y) m \u2208 N := fun m _ \u21a6 N.lie_mem (N.mem_idealizer.mp (h hy) m)) :\n    trace R M (\u03c6 x \u2218\u2097 \u03c6 y) = trace R N ((\u03c6 x \u2218\u2097 \u03c6 y).restrict hy') := by\n  suffices \u2200 m, \u2045x, \u2045y, m\u2046\u2046 \u2208 N by simp [(\u03c6 x \u2218\u2097 \u03c6 y).trace_restrict_eq_of_forall_mem _ this]\n  exact fun m \u21a6 N.lie_mem (h hy m)", "start": [175, 1], "end": [179, 35], "kind": "mathlibtacticlemma"}, {"full_name": "LieSubmodule.traceForm_eq_of_le_idealizer", "code": "lemma traceForm_eq_of_le_idealizer :\n    traceForm R I N = I.restrictBilinear (traceForm R L M) := by\n  ext \u27e8x, hx\u27e9 \u27e8y, hy\u27e9\n  change _ = trace R M (\u03c6 x \u2218\u2097 \u03c6 y)\n  rw [N.trace_eq_trace_restrict_of_le_idealizer I h x hy]\n  rfl", "start": [181, 1], "end": [186, 6], "kind": "mathlibtacticlemma"}, {"full_name": "LieSubmodule.traceForm_eq_zero_of_isTrivial", "code": "lemma traceForm_eq_zero_of_isTrivial [LieModule.IsTrivial I N] :\n    trace R M (\u03c6 x \u2218\u2097 \u03c6 y) = 0 := by\n  let hy' : \u2200 m \u2208 N, (\u03c6 x \u2218\u2097 \u03c6 y) m \u2208 N := fun m _ \u21a6 N.lie_mem (N.mem_idealizer.mp (h hy) m)\n  suffices : (\u03c6 x \u2218\u2097 \u03c6 y).restrict hy' = 0\n  \u00b7 simp [this, N.trace_eq_trace_restrict_of_le_idealizer I h x hy]\n  ext n\n  suffices \u2045y, (n : M)\u2046 = 0 by simp [this]\n  exact Submodule.coe_eq_zero.mpr (LieModule.IsTrivial.trivial (\u27e8y, hy\u27e9 : I) n)", "start": [188, 1], "end": [198, 80], "kind": "mathlibtacticlemma"}, {"full_name": "killingForm", "code": "noncomputable abbrev killingForm : L \u2192\u2097[R] L \u2192\u2097[R] R := LieModule.traceForm R L L", "start": [206, 1], "end": [209, 82], "kind": "commanddeclaration"}, {"full_name": "killingForm_eq_zero_of_mem_zeroRoot_mem_posFitting", "code": "lemma killingForm_eq_zero_of_mem_zeroRoot_mem_posFitting\n    (H : LieSubalgebra R L) [LieAlgebra.IsNilpotent R H]\n    {x\u2080 x\u2081 : L}\n    (hx\u2080 : x\u2080 \u2208 LieAlgebra.zeroRootSubalgebra R L H)\n    (hx\u2081 : x\u2081 \u2208 LieModule.posFittingComp R H L) :\n    killingForm R L x\u2080 x\u2081 = 0 :=\n  LieModule.eq_zero_of_mem_weightSpace_mem_posFitting R H L\n    (fun x y z \u21a6 LieModule.traceForm_apply_lie_apply' R L L x y z) hx\u2080 hx\u2081", "start": [211, 1], "end": [218, 75], "kind": "mathlibtacticlemma"}, {"full_name": "LieIdeal.killingCompl", "code": "noncomputable def killingCompl : LieIdeal R L :=\n  { LinearMap.ker ((killingForm R L).compl\u2081\u2082 LinearMap.id I.subtype) with\n    lie_mem := by\n      intro x y hy\n      ext \u27e8z, hz\u27e9\n      suffices killingForm R L \u2045x, y\u2046 z = 0 by simpa\n      rw [LieModule.traceForm_comm, \u2190 LieModule.traceForm_apply_lie_apply, LieModule.traceForm_comm]\n      simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n        Submodule.mem_toAddSubmonoid, LinearMap.mem_ker] at hy\n      replace hy := LinearMap.congr_fun hy \u27e8\u2045z, x\u2046, lie_mem_left R L I z x hz\u27e9\n      simpa using hy }", "start": [224, 1], "end": [235, 23], "kind": "commanddeclaration"}, {"full_name": "LieIdeal.mem_killingCompl", "code": "@[simp] lemma mem_killingCompl {x : L} :\n    x \u2208 I.killingCompl \u2194 \u2200 y \u2208 I, killingForm R L x y = 0 := by\n  change x \u2208 LinearMap.ker ((killingForm R L).compl\u2081\u2082 LinearMap.id I.subtype) \u2194 _\n  simp only [LinearMap.mem_ker, LieModule.traceForm_apply_apply, LinearMap.ext_iff,\n    LinearMap.compl\u2081\u2082_apply, LinearMap.id_coe, id_eq, Submodule.coeSubtype,\n    LieModule.traceForm_apply_apply, LinearMap.zero_apply, Subtype.forall]\n  rfl", "start": [237, 1], "end": [243, 6], "kind": "mathlibtacticlemma"}, {"full_name": "LieIdeal.coe_killingCompl_top", "code": "lemma coe_killingCompl_top :\n    killingCompl R L \u22a4 = LinearMap.ker (killingForm R L) := by\n  ext\n  simp [LinearMap.ext_iff]", "start": [245, 1], "end": [248, 27], "kind": "mathlibtacticlemma"}, {"full_name": "LieIdeal.killingForm_eq", "code": "lemma killingForm_eq :\n    killingForm R I = I.restrictBilinear (killingForm R L) :=\n  LieSubmodule.traceForm_eq_of_le_idealizer I I $ by simp", "start": [252, 1], "end": [254, 58], "kind": "mathlibtacticlemma"}, {"full_name": "LieIdeal.restrictBilinear_killingForm", "code": "lemma restrictBilinear_killingForm :\n    I.restrictBilinear (killingForm R L) = LieModule.traceForm R I L :=\n  rfl", "start": [256, 1], "end": [258, 6], "kind": "mathlibtacticlemma"}, {"full_name": "LieIdeal.le_killingCompl_top_of_isLieAbelian", "code": "@[simp] lemma le_killingCompl_top_of_isLieAbelian [IsLieAbelian I] :\n    I \u2264 LieIdeal.killingCompl R L \u22a4 := by\n  intro x (hx : x \u2208 I)\n  simp only [mem_killingCompl, LieSubmodule.mem_top, forall_true_left]\n  intro y\n  rw [LieModule.traceForm_comm, LieModule.traceForm_apply_apply]\n  exact LieSubmodule.traceForm_eq_zero_of_isTrivial I I (by simp) _ hx", "start": [260, 1], "end": [266, 71], "kind": "mathlibtacticlemma"}, {"full_name": "LieAlgebra.IsKilling", "code": "class IsKilling : Prop :=\n  \n  killingCompl_top_eq_bot : LieIdeal.killingCompl R L \u22a4 = \u22a5", "start": [272, 1], "end": [278, 60], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.IsKilling.ker_killingForm_eq_bot", "code": "@[simp] lemma ker_killingForm_eq_bot :\n    LinearMap.ker (killingForm R L) = \u22a5 := by\n  simp [\u2190 LieIdeal.coe_killingCompl_top, killingCompl_top_eq_bot]", "start": [286, 1], "end": [288, 66], "kind": "mathlibtacticlemma"}, {"full_name": "LieAlgebra.IsKilling.ker_restrictBilinear_of_isCartanSubalgebra_eq_bot", "code": "lemma ker_restrictBilinear_of_isCartanSubalgebra_eq_bot\n    [IsNoetherian R L] [IsArtinian R L] (H : LieSubalgebra R L) [H.IsCartanSubalgebra] :\n    LinearMap.ker (H.restrictBilinear (killingForm R L)) = \u22a5 := by\n  have h : Codisjoint (rootSpace H 0) (LieModule.posFittingComp R H L) :=\n    (LieModule.isCompl_weightSpace_zero_posFittingComp R H L).codisjoint\n  replace h : Codisjoint (H : Submodule R L) (LieModule.posFittingComp R H L : Submodule R L) := by\n    rwa [codisjoint_iff, \u2190 LieSubmodule.coe_toSubmodule_eq_iff, LieSubmodule.sup_coe_toSubmodule,\n      LieSubmodule.top_coeSubmodule, rootSpace_zero_eq R L H, LieSubalgebra.coe_toLieSubmodule,\n      \u2190 codisjoint_iff] at h\n  suffices this : \u2200 m\u2080 \u2208 H, \u2200 m\u2081 \u2208 LieModule.posFittingComp R H L, killingForm R L m\u2080 m\u2081 = 0 by\n    simp [LinearMap.ker_restrictBilinear_eq_of_codisjoint h this]\n  intro m\u2080 h\u2080 m\u2081 h\u2081\n  exact killingForm_eq_zero_of_mem_zeroRoot_mem_posFitting R L H (le_zeroRootSubalgebra R L H h\u2080) h\u2081", "start": [290, 1], "end": [304, 101], "kind": "mathlibtacticlemma"}, {"full_name": "LieAlgebra.IsKilling.restrictBilinear_killingForm", "code": "lemma restrictBilinear_killingForm (H : LieSubalgebra R L) :\n    H.restrictBilinear (killingForm R L) = LieModule.traceForm R H L :=\n  rfl", "start": [306, 1], "end": [308, 6], "kind": "mathlibtacticlemma"}, {"full_name": "LieAlgebra.IsKilling.isSemisimple", "code": "instance isSemisimple [IsDomain R] [IsPrincipalIdealRing R] : IsSemisimple R L := by\n  refine' (isSemisimple_iff_no_abelian_ideals R L).mpr fun I hI \u21a6 _\n  rw [eq_bot_iff, \u2190 killingCompl_top_eq_bot]\n  exact I.le_killingCompl_top_of_isLieAbelian", "start": [310, 1], "end": [315, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/ClassEquation.lean", "imports": ["Mathlib/Data/Set/Card.lean", "Mathlib/Algebra/Group/ConjFinite.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/GroupAction/Quotient.lean", "Mathlib/Algebra/BigOperators/Finprod.lean"], "premises": [{"full_name": "sum_conjClasses_card_eq_card", "code": "theorem sum_conjClasses_card_eq_card [Fintype <| ConjClasses G] [Fintype G]\n    [\u2200 x : ConjClasses G, Fintype x.carrier] :\n    \u2211 x : ConjClasses G, x.carrier.toFinset.card = Fintype.card G", "start": [33, 1], "end": [39, 76], "kind": "commanddeclaration"}, {"full_name": "Group.sum_card_conj_classes_eq_card", "code": "theorem Group.sum_card_conj_classes_eq_card [Finite G] :\n    \u2211\u1da0 x : ConjClasses G, x.carrier.ncard = Nat.card G", "start": [41, 1], "end": [47, 37], "kind": "commanddeclaration"}, {"full_name": "Group.nat_card_center_add_sum_card_noncenter_eq_card", "code": "theorem Group.nat_card_center_add_sum_card_noncenter_eq_card [Finite G] :\n    Nat.card (Subgroup.center G) + \u2211\u1da0 x \u2208 noncenter G, Nat.card x.carrier = Nat.card G", "start": [49, 1], "end": [74, 90], "kind": "commanddeclaration"}, {"full_name": "Group.card_center_add_sum_card_noncenter_eq_card", "code": "theorem Group.card_center_add_sum_card_noncenter_eq_card (G) [Group G]\n    [\u2200 x : ConjClasses G, Fintype x.carrier] [Fintype G] [Fintype <| Subgroup.center G]\n    [Fintype <| noncenter G] : Fintype.card (Subgroup.center G) +\n  \u2211 x in (noncenter G).toFinset, x.carrier.toFinset.card = Fintype.card G", "start": [76, 1], "end": [84, 9], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/CartanMatrix.lean", "imports": ["Mathlib/Data/Matrix/Notation.lean", "Mathlib/Algebra/Lie/Quotient.lean", "Mathlib/Algebra/Lie/Free.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CartanMatrix.Generators", "code": "inductive Generators\n  | H : B \u2192 Generators\n  | E : B \u2192 Generators\n  | F : B \u2192 Generators", "start": [97, 1], "end": [102, 23], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.Relations.HH", "code": "def HH : B \u00d7 B \u2192 FreeLieAlgebra R (Generators B) :=\n  uncurry fun i j => \u2045H i, H j\u2046", "start": [119, 1], "end": [121, 32], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.Relations.EF", "code": "def EF : B \u00d7 B \u2192 FreeLieAlgebra R (Generators B) :=\n  uncurry fun i j => if i = j then \u2045E i, F i\u2046 - H i else \u2045E i, F j\u2046", "start": [124, 1], "end": [126, 68], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.Relations.HE", "code": "def HE : B \u00d7 B \u2192 FreeLieAlgebra R (Generators B) :=\n  uncurry fun i j => \u2045H i, E j\u2046 - A i j \u2022 E j", "start": [129, 1], "end": [131, 46], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.Relations.HF", "code": "def HF : B \u00d7 B \u2192 FreeLieAlgebra R (Generators B) :=\n  uncurry fun i j => \u2045H i, F j\u2046 + A i j \u2022 F j", "start": [134, 1], "end": [136, 46], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.Relations.adE", "code": "def adE : B \u00d7 B \u2192 FreeLieAlgebra R (Generators B) :=\n  uncurry fun i j => ad (E i) ^ (-A i j).toNat <| \u2045E i, E j\u2046", "start": [139, 1], "end": [145, 61], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.Relations.adF", "code": "def adF : B \u00d7 B \u2192 FreeLieAlgebra R (Generators B) :=\n  uncurry fun i j => ad (F i) ^ (-A i j).toNat <| \u2045F i, F j\u2046", "start": [148, 1], "end": [152, 61], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.Relations.adE_of_eq_eq_zero", "code": "private theorem adE_of_eq_eq_zero (i : B) (h : A i i = 2) : adE R A \u27e8i, i\u27e9 = 0", "start": [155, 1], "end": [157, 20], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.Relations.adF_of_eq_eq_zero", "code": "private theorem adF_of_eq_eq_zero (i : B) (h : A i i = 2) : adF R A \u27e8i, i\u27e9 = 0", "start": [159, 1], "end": [161, 20], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.Relations.toSet", "code": "def toSet : Set (FreeLieAlgebra R (Generators B)) :=\n  (Set.range <| HH R) \u222a (Set.range <| EF R) \u222a (Set.range <| HE R A) \u222a (Set.range <| HF R A) \u222a\n      (Set.range <| adE R A) \u222a\n    (Set.range <| adF R A)", "start": [163, 1], "end": [167, 27], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.Relations.toIdeal", "code": "def toIdeal : LieIdeal R (FreeLieAlgebra R (Generators B)) :=\n  LieSubmodule.lieSpan R _ <| toSet R A", "start": [170, 1], "end": [172, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.ToLieAlgebra", "code": "def Matrix.ToLieAlgebra :=\n  FreeLieAlgebra R _ \u29f8 CartanMatrix.Relations.toIdeal R A", "start": [179, 1], "end": [184, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.ToLieAlgebra.instLieRing", "code": "instance Matrix.ToLieAlgebra.instLieRing : LieRing (Matrix.ToLieAlgebra R A) :=\n  inferInstanceAs (LieRing (FreeLieAlgebra R _ \u29f8 CartanMatrix.Relations.toIdeal R A))", "start": [188, 1], "end": [189, 86], "kind": "commanddeclaration"}, {"full_name": "Matrix.ToLieAlgebra.instInhabited", "code": "instance Matrix.ToLieAlgebra.instInhabited : Inhabited (Matrix.ToLieAlgebra R A) :=\n  inferInstanceAs (Inhabited (FreeLieAlgebra R _ \u29f8 CartanMatrix.Relations.toIdeal R A))", "start": [192, 1], "end": [193, 88], "kind": "commanddeclaration"}, {"full_name": "Matrix.ToLieAlgebra.instLieAlgebra", "code": "instance Matrix.ToLieAlgebra.instLieAlgebra : LieAlgebra R (Matrix.ToLieAlgebra R A) :=\n  inferInstanceAs (LieAlgebra R (FreeLieAlgebra R _ \u29f8 CartanMatrix.Relations.toIdeal R A))", "start": [196, 1], "end": [197, 91], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.E\u2086", "code": "def E\u2086 : Matrix (Fin 6) (Fin 6) \u2124 :=\n  !![2, 0, -1, 0, 0, 0;\n    0, 2, 0, -1, 0, 0;\n    -1, 0, 2, -1, 0, 0;\n    0, -1, -1, 2, -1, 0;\n    0, 0, 0, -1, 2, -1;\n    0, 0, 0, 0, -1, 2]", "start": [202, 1], "end": [217, 23], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.E\u2087", "code": "def E\u2087 : Matrix (Fin 7) (Fin 7) \u2124 :=\n  !![2, 0, -1, 0, 0, 0, 0;\n    0, 2, 0, -1, 0, 0, 0;\n    -1, 0, 2, -1, 0, 0, 0;\n    0, -1, -1, 2, -1, 0, 0;\n    0, 0, 0, -1, 2, -1, 0;\n    0, 0, 0, 0, -1, 2, -1;\n    0, 0, 0, 0, 0, -1, 2]", "start": [220, 1], "end": [236, 26], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.E\u2088", "code": "def E\u2088 : Matrix (Fin 8) (Fin 8) \u2124 :=\n  !![2, 0, -1, 0, 0, 0, 0, 0;\n    0, 2, 0, -1, 0, 0, 0, 0;\n    -1, 0, 2, -1, 0, 0, 0, 0;\n    0, -1, -1, 2, -1, 0, 0, 0;\n    0, 0, 0, -1, 2, -1, 0, 0;\n    0, 0, 0, 0, -1, 2, -1, 0;\n    0, 0, 0, 0, 0, -1, 2, -1;\n    0, 0, 0, 0, 0, 0, -1, 2]", "start": [239, 1], "end": [256, 29], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.F\u2084", "code": "def F\u2084 : Matrix (Fin 4) (Fin 4) \u2124 :=\n  !![2, -1, 0, 0; -1, 2, -2, 0; 0, -1, 2, -1; 0, 0, -1, 2]", "start": [259, 1], "end": [267, 59], "kind": "commanddeclaration"}, {"full_name": "CartanMatrix.G\u2082", "code": "def G\u2082 : Matrix (Fin 2) (Fin 2) \u2124 :=\n  !![2, -3; -1, 2]", "start": [270, 1], "end": [279, 19], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.e\u2086", "code": "abbrev e\u2086 :=\n  CartanMatrix.E\u2086.ToLieAlgebra R", "start": [286, 1], "end": [288, 33], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.e\u2087", "code": "abbrev e\u2087 :=\n  CartanMatrix.E\u2087.ToLieAlgebra R", "start": [291, 1], "end": [293, 33], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.e\u2088", "code": "abbrev e\u2088 :=\n  CartanMatrix.E\u2088.ToLieAlgebra R", "start": [296, 1], "end": [298, 33], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.f\u2084", "code": "abbrev f\u2084 :=\n  CartanMatrix.F\u2084.ToLieAlgebra R", "start": [301, 1], "end": [303, 33], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.g\u2082", "code": "abbrev g\u2082 :=\n  CartanMatrix.G\u2082.ToLieAlgebra R", "start": [306, 1], "end": [308, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Sub/Prod.lean", "imports": ["Mathlib/Algebra/Order/Sub/Basic.lean", "Mathlib/Algebra/Group/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prod.orderedSub", "code": "instance Prod.orderedSub\n    [Preorder \u03b1] [Add \u03b1] [Sub \u03b1] [OrderedSub \u03b1] [Sub \u03b2] [Preorder \u03b2] [Add \u03b2] [OrderedSub \u03b2] :\n    OrderedSub (\u03b1 \u00d7 \u03b2) where\n  tsub_le_iff_right _ _ _ :=\n  \u27e8fun w \u21a6 \u27e8tsub_le_iff_right.mp w.1, tsub_le_iff_right.mp w.2\u27e9,\n   fun w \u21a6 \u27e8tsub_le_iff_right.mpr w.1, tsub_le_iff_right.mpr w.2\u27e9\u27e9", "start": [15, 1], "end": [20, 67], "kind": "commanddeclaration"}, {"full_name": "Pi.orderedSub", "code": "instance Pi.orderedSub {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*}\n    [\u2200 i, Preorder (\u03b1 i)] [\u2200 i, Add (\u03b1 i)] [\u2200 i, Sub (\u03b1 i)] [\u2200 i, OrderedSub (\u03b1 i)] :\n    OrderedSub ((i : \u03b9) \u2192 \u03b1 i) where\n  tsub_le_iff_right _ _ _ :=\n  \u27e8fun w i \u21a6 tsub_le_iff_right.mp (w i), fun w i \u21a6 tsub_le_iff_right.mpr (w i)\u27e9", "start": [22, 1], "end": [26, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/ShortComplex/QuasiIso.lean", "imports": ["Mathlib/Algebra/Homology/ShortComplex/Homology.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.ShortComplex.QuasiIso", "code": "class QuasiIso (\u03c6 : S\u2081 \u27f6 S\u2082) : Prop where\n  \n  isIso' : IsIso (homologyMap \u03c6)", "start": [28, 1], "end": [32, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.QuasiIso.isIso", "code": "instance QuasiIso.isIso (\u03c6 : S\u2081 \u27f6 S\u2082) [QuasiIso \u03c6] : IsIso (homologyMap \u03c6) := QuasiIso.isIso'", "start": [34, 1], "end": [34, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_iff", "code": "lemma quasiIso_iff (\u03c6 : S\u2081 \u27f6 S\u2082) :\n    QuasiIso \u03c6 \u2194 IsIso (homologyMap \u03c6) := by\n  constructor\n  \u00b7 intro h\n    infer_instance\n  \u00b7 intro h\n    exact \u27e8h\u27e9", "start": [36, 1], "end": [42, 14], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_of_isIso", "code": "instance quasiIso_of_isIso (\u03c6 : S\u2081 \u27f6 S\u2082) [IsIso \u03c6] : QuasiIso \u03c6 :=\n  \u27e8IsIso.of_iso (homologyMapIso (asIso \u03c6))\u27e9", "start": [44, 1], "end": [45, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_comp", "code": "instance quasiIso_comp (\u03c6 : S\u2081 \u27f6 S\u2082) (\u03c6' : S\u2082 \u27f6 S\u2083) [h\u03c6 : QuasiIso \u03c6] [h\u03c6' : QuasiIso \u03c6'] :\n    QuasiIso (\u03c6 \u226b \u03c6') := by\n  rw [quasiIso_iff] at h\u03c6 h\u03c6' \u22a2\n  rw [homologyMap_comp]\n  infer_instance", "start": [47, 1], "end": [51, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_of_comp_left", "code": "lemma quasiIso_of_comp_left (\u03c6 : S\u2081 \u27f6 S\u2082) (\u03c6' : S\u2082 \u27f6 S\u2083)\n    [h\u03c6 : QuasiIso \u03c6] [h\u03c6\u03c6' : QuasiIso (\u03c6 \u226b \u03c6')] :\n    QuasiIso \u03c6' := by\n  rw [quasiIso_iff] at h\u03c6 h\u03c6\u03c6' \u22a2\n  rw [homologyMap_comp] at h\u03c6\u03c6'\n  exact IsIso.of_isIso_comp_left (homologyMap \u03c6) (homologyMap \u03c6')", "start": [53, 1], "end": [58, 66], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_iff_comp_left", "code": "lemma quasiIso_iff_comp_left (\u03c6 : S\u2081 \u27f6 S\u2082) (\u03c6' : S\u2082 \u27f6 S\u2083) [h\u03c6 : QuasiIso \u03c6] :\n    QuasiIso (\u03c6 \u226b \u03c6') \u2194 QuasiIso \u03c6' := by\n  constructor\n  \u00b7 intro\n    exact quasiIso_of_comp_left \u03c6 \u03c6'\n  \u00b7 intro\n    exact quasiIso_comp \u03c6 \u03c6'", "start": [60, 1], "end": [66, 29], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_of_comp_right", "code": "lemma quasiIso_of_comp_right (\u03c6 : S\u2081 \u27f6 S\u2082) (\u03c6' : S\u2082 \u27f6 S\u2083)\n    [h\u03c6' : QuasiIso \u03c6'] [h\u03c6\u03c6' : QuasiIso (\u03c6 \u226b \u03c6')] :\n    QuasiIso \u03c6 := by\n  rw [quasiIso_iff] at h\u03c6' h\u03c6\u03c6' \u22a2\n  rw [homologyMap_comp] at h\u03c6\u03c6'\n  exact IsIso.of_isIso_comp_right (homologyMap \u03c6) (homologyMap \u03c6')", "start": [68, 1], "end": [73, 67], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_iff_comp_right", "code": "lemma quasiIso_iff_comp_right (\u03c6 : S\u2081 \u27f6 S\u2082) (\u03c6' : S\u2082 \u27f6 S\u2083) [h\u03c6' : QuasiIso \u03c6'] :\n    QuasiIso (\u03c6 \u226b \u03c6') \u2194 QuasiIso \u03c6 := by\n  constructor\n  \u00b7 intro\n    exact quasiIso_of_comp_right \u03c6 \u03c6'\n  \u00b7 intro\n    exact quasiIso_comp \u03c6 \u03c6'", "start": [75, 1], "end": [81, 29], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_of_arrow_mk_iso", "code": "lemma quasiIso_of_arrow_mk_iso (\u03c6 : S\u2081 \u27f6 S\u2082) (\u03c6' : S\u2083 \u27f6 S\u2084) (e : Arrow.mk \u03c6 \u2245 Arrow.mk \u03c6')\n    [h\u03c6 : QuasiIso \u03c6] : QuasiIso \u03c6' := by\n  let \u03b1 : S\u2083 \u27f6 S\u2081 := e.inv.left\n  let \u03b2 : S\u2082 \u27f6 S\u2084 := e.hom.right\n  suffices \u03c6' = \u03b1 \u226b \u03c6 \u226b \u03b2 by\n    rw [this]\n    infer_instance\n  simp only [Arrow.w_mk_right_assoc, Arrow.mk_left, Arrow.mk_right, Arrow.mk_hom,\n    \u2190 Arrow.comp_right, e.inv_hom_id, Arrow.id_right, comp_id]", "start": [83, 1], "end": [91, 63], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_iff_of_arrow_mk_iso", "code": "lemma quasiIso_iff_of_arrow_mk_iso (\u03c6 : S\u2081 \u27f6 S\u2082) (\u03c6' : S\u2083 \u27f6 S\u2084) (e : Arrow.mk \u03c6 \u2245 Arrow.mk \u03c6') :\n    QuasiIso \u03c6 \u2194 QuasiIso \u03c6' :=\n  \u27e8fun _ => quasiIso_of_arrow_mk_iso \u03c6 \u03c6' e, fun _ => quasiIso_of_arrow_mk_iso \u03c6' \u03c6 e.symm\u27e9", "start": [93, 1], "end": [95, 92], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyMapData.quasiIso_iff", "code": "lemma LeftHomologyMapData.quasiIso_iff {\u03c6 : S\u2081 \u27f6 S\u2082} {h\u2081 : S\u2081.LeftHomologyData}\n    {h\u2082 : S\u2082.LeftHomologyData} (\u03b3 : LeftHomologyMapData \u03c6 h\u2081 h\u2082) :\n    QuasiIso \u03c6 \u2194 IsIso \u03b3.\u03c6H := by\n  rw [ShortComplex.quasiIso_iff, \u03b3.homologyMap_eq]\n  constructor\n  \u00b7 intro h\n    haveI : IsIso (\u03b3.\u03c6H \u226b (LeftHomologyData.homologyIso h\u2082).inv) :=\n      IsIso.of_isIso_comp_left (LeftHomologyData.homologyIso h\u2081).hom _\n    exact IsIso.of_isIso_comp_right _ (LeftHomologyData.homologyIso h\u2082).inv\n  \u00b7 intro h\n    infer_instance", "start": [97, 1], "end": [107, 19], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyMapData.quasiIso_iff", "code": "lemma RightHomologyMapData.quasiIso_iff {\u03c6 : S\u2081 \u27f6 S\u2082} {h\u2081 : S\u2081.RightHomologyData}\n    {h\u2082 : S\u2082.RightHomologyData} (\u03b3 : RightHomologyMapData \u03c6 h\u2081 h\u2082) :\n    QuasiIso \u03c6 \u2194 IsIso \u03b3.\u03c6H := by\n  rw [ShortComplex.quasiIso_iff, \u03b3.homologyMap_eq]\n  constructor\n  \u00b7 intro h\n    haveI : IsIso (\u03b3.\u03c6H \u226b (RightHomologyData.homologyIso h\u2082).inv) :=\n      IsIso.of_isIso_comp_left (RightHomologyData.homologyIso h\u2081).hom _\n    exact IsIso.of_isIso_comp_right _ (RightHomologyData.homologyIso h\u2082).inv\n  \u00b7 intro h\n    infer_instance", "start": [109, 1], "end": [119, 19], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_iff_isIso_leftHomologyMap'", "code": "lemma quasiIso_iff_isIso_leftHomologyMap' (\u03c6 : S\u2081 \u27f6 S\u2082)\n    (h\u2081 : S\u2081.LeftHomologyData) (h\u2082 : S\u2082.LeftHomologyData) :\n    QuasiIso \u03c6 \u2194 IsIso (leftHomologyMap' \u03c6 h\u2081 h\u2082) := by\n  have \u03b3 : LeftHomologyMapData \u03c6 h\u2081 h\u2082 := default\n  rw [\u03b3.quasiIso_iff, \u03b3.leftHomologyMap'_eq]", "start": [121, 1], "end": [125, 45], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_iff_isIso_rightHomologyMap'", "code": "lemma quasiIso_iff_isIso_rightHomologyMap' (\u03c6 : S\u2081 \u27f6 S\u2082)\n    (h\u2081 : S\u2081.RightHomologyData) (h\u2082 : S\u2082.RightHomologyData) :\n    QuasiIso \u03c6 \u2194 IsIso (rightHomologyMap' \u03c6 h\u2081 h\u2082) := by\n  have \u03b3 : RightHomologyMapData \u03c6 h\u2081 h\u2082 := default\n  rw [\u03b3.quasiIso_iff, \u03b3.rightHomologyMap'_eq]", "start": [127, 1], "end": [131, 46], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_iff_isIso_homologyMap'", "code": "lemma quasiIso_iff_isIso_homologyMap' (\u03c6 : S\u2081 \u27f6 S\u2082)\n    (h\u2081 : S\u2081.HomologyData) (h\u2082 : S\u2082.HomologyData) :\n    QuasiIso \u03c6 \u2194 IsIso (homologyMap' \u03c6 h\u2081 h\u2082) :=\n  quasiIso_iff_isIso_leftHomologyMap' _ _ _", "start": [133, 1], "end": [136, 44], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_of_epi_of_isIso_of_mono", "code": "lemma quasiIso_of_epi_of_isIso_of_mono (\u03c6 : S\u2081 \u27f6 S\u2082) [Epi \u03c6.\u03c4\u2081] [IsIso \u03c6.\u03c4\u2082] [Mono \u03c6.\u03c4\u2083] :\n    QuasiIso \u03c6 := by\n  rw [((LeftHomologyMapData.ofEpiOfIsIsoOfMono \u03c6) S\u2081.leftHomologyData).quasiIso_iff]\n  dsimp\n  infer_instance", "start": [138, 1], "end": [142, 17], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_opMap_iff", "code": "lemma quasiIso_opMap_iff (\u03c6 : S\u2081 \u27f6 S\u2082) :\n    QuasiIso (opMap \u03c6) \u2194 QuasiIso \u03c6 := by\n  have \u03b3 : HomologyMapData \u03c6 S\u2081.homologyData S\u2082.homologyData := default\n  rw [\u03b3.left.quasiIso_iff, \u03b3.op.right.quasiIso_iff]\n  dsimp\n  constructor\n  \u00b7 intro h\n    apply isIso_of_op\n  \u00b7 intro h\n    infer_instance", "start": [144, 1], "end": [153, 19], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_opMap", "code": "lemma quasiIso_opMap (\u03c6 : S\u2081 \u27f6 S\u2082) [QuasiIso \u03c6] :\n    QuasiIso (opMap \u03c6) := by\n  rw [quasiIso_opMap_iff]\n  infer_instance", "start": [155, 1], "end": [158, 17], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_unopMap", "code": "lemma quasiIso_unopMap {S\u2081 S\u2082 : ShortComplex C\u1d52\u1d56} [S\u2081.HasHomology] [S\u2082.HasHomology]\n    [S\u2081.unop.HasHomology] [S\u2082.unop.HasHomology]\n    (\u03c6 : S\u2081 \u27f6 S\u2082) [QuasiIso \u03c6] : QuasiIso (unopMap \u03c6) := by\n  rw [\u2190 quasiIso_opMap_iff]\n  change QuasiIso \u03c6\n  infer_instance", "start": [160, 1], "end": [165, 17], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_iff_isIso_liftCycles", "code": "lemma quasiIso_iff_isIso_liftCycles (\u03c6 : S\u2081 \u27f6 S\u2082)\n    (hf\u2081 : S\u2081.f = 0) (hg\u2081 : S\u2081.g = 0) (hf\u2082 : S\u2082.f = 0) [S\u2081.HasHomology] [S\u2082.HasHomology] :\n    QuasiIso \u03c6 \u2194 IsIso (S\u2082.liftCycles \u03c6.\u03c4\u2082 (by rw [\u03c6.comm\u2082\u2083, hg\u2081, zero_comp])) := by\n  let H : LeftHomologyMapData \u03c6 (LeftHomologyData.ofZeros S\u2081 hf\u2081 hg\u2081)\n      (LeftHomologyData.ofIsLimitKernelFork S\u2082 hf\u2082 _ S\u2082.cyclesIsKernel) :=\n    { \u03c6K := S\u2082.liftCycles \u03c6.\u03c4\u2082 (by rw [\u03c6.comm\u2082\u2083, hg\u2081, zero_comp])\n      \u03c6H := S\u2082.liftCycles \u03c6.\u03c4\u2082 (by rw [\u03c6.comm\u2082\u2083, hg\u2081, zero_comp]) }\n  exact H.quasiIso_iff", "start": [167, 1], "end": [174, 23], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.quasiIso_iff_isIso_descOpcycles", "code": "lemma quasiIso_iff_isIso_descOpcycles (\u03c6 : S\u2081 \u27f6 S\u2082)\n    (hg\u2081 : S\u2081.g = 0) (hf\u2082 : S\u2082.f = 0) (hg\u2082 : S\u2082.g = 0) [S\u2081.HasHomology] [S\u2082.HasHomology] :\n    QuasiIso \u03c6 \u2194 IsIso (S\u2081.descOpcycles \u03c6.\u03c4\u2082 (by rw [\u2190 \u03c6.comm\u2081\u2082, hf\u2082, comp_zero])) := by\n  let H : RightHomologyMapData \u03c6\n      (RightHomologyData.ofIsColimitCokernelCofork S\u2081 hg\u2081 _ S\u2081.opcyclesIsCokernel)\n        (RightHomologyData.ofZeros S\u2082 hf\u2082 hg\u2082) :=\n    { \u03c6Q := S\u2081.descOpcycles \u03c6.\u03c4\u2082 (by rw [\u2190 \u03c6.comm\u2081\u2082, hf\u2082, comp_zero])\n      \u03c6H := S\u2081.descOpcycles \u03c6.\u03c4\u2082 (by rw [\u2190 \u03c6.comm\u2081\u2082, hf\u2082, comp_zero]) }\n  exact H.quasiIso_iff", "start": [176, 1], "end": [184, 23], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/NumberTheory/FermatPsp.lean", "imports": ["Mathlib/FieldTheory/Finite/Basic.lean", "Mathlib/Order/Filter/Cofinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.ProbablePrime", "code": "def ProbablePrime (n b : \u2115) : Prop :=\n  n \u2223 b ^ (n - 1) - 1", "start": [45, 1], "end": [52, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.FermatPsp", "code": "def FermatPsp (n b : \u2115) : Prop :=\n  ProbablePrime n b \u2227 \u00acn.Prime \u2227 1 < n", "start": [55, 1], "end": [61, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.decidableProbablePrime", "code": "instance decidableProbablePrime (n b : \u2115) : Decidable (ProbablePrime n b) :=\n  Nat.decidable_dvd _ _", "start": [64, 1], "end": [65, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.decidablePsp", "code": "instance decidablePsp (n b : \u2115) : Decidable (FermatPsp n b) :=\n  And.decidable", "start": [68, 1], "end": [69, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_of_probablePrime", "code": "theorem coprime_of_probablePrime {n b : \u2115} (h : ProbablePrime n b) (h\u2081 : 1 \u2264 n) (h\u2082 : 1 \u2264 b) :\n    Nat.Coprime n b", "start": [72, 1], "end": [99, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.probablePrime_iff_modEq", "code": "theorem probablePrime_iff_modEq (n : \u2115) {b : \u2115} (h : 1 \u2264 b) :\n    ProbablePrime n b \u2194 b ^ (n - 1) \u2261 1 [MOD n]", "start": [102, 1], "end": [112, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_of_fermatPsp", "code": "theorem coprime_of_fermatPsp {n b : \u2115} (h : FermatPsp n b) (h\u2081 : 1 \u2264 b) : Nat.Coprime n b", "start": [115, 1], "end": [122, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.fermatPsp_base_one", "code": "theorem fermatPsp_base_one {n : \u2115} (h\u2081 : 1 < n) (h\u2082 : \u00acn.Prime) : FermatPsp n 1", "start": [125, 1], "end": [129, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_gt_exponent", "code": "private theorem pow_gt_exponent {a : \u2115} (b : \u2115) (h : 2 \u2264 a) : b < a ^ b", "start": [136, 1], "end": [137, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.a_id_helper", "code": "private theorem a_id_helper {a b : \u2115} (ha : 2 \u2264 a) (hb : 2 \u2264 b) : 2 \u2264 (a ^ b - 1) / (a - 1)", "start": [139, 1], "end": [143, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.b_id_helper", "code": "private theorem b_id_helper {a b : \u2115} (ha : 2 \u2264 a) (hb : 2 < b) : 2 \u2264 (a ^ b + 1) / (a + 1)", "start": [145, 1], "end": [151, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.AB_id_helper", "code": "private theorem AB_id_helper (b p : \u2115) (_ : 2 \u2264 b) (hp : Odd p) :\n    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1)", "start": [153, 1], "end": [159, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.bp_helper", "code": "private theorem bp_helper {b p : \u2115} (hb : 0 < b) (hp : 1 \u2264 p) :\n    b ^ (2 * p) - 1 - (b ^ 2 - 1) = b * (b ^ (p - 1) - 1) * (b ^ p + b)", "start": [161, 1], "end": [177, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.psp_from_prime", "code": "private def psp_from_prime (b : \u2115) (p : \u2115) : \u2115 :=\n  (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1))", "start": [181, 1], "end": [193, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.psp_from_prime_psp", "code": "private theorem psp_from_prime_psp {b : \u2115} (b_ge_two : 2 \u2264 b) {p : \u2115} (p_prime : p.Prime)\n    (p_gt_two : 2 < p) (not_dvd : \u00acp \u2223 b * (b ^ 2 - 1)) : FermatPsp (psp_from_prime b p) b", "start": [195, 1], "end": [297, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.psp_from_prime_gt_p", "code": "private theorem psp_from_prime_gt_p {b : \u2115} (b_ge_two : 2 \u2264 b) {p : \u2115} (p_prime : p.Prime)\n    (p_gt_two : 2 < p) : p < psp_from_prime b p", "start": [299, 1], "end": [334, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_infinite_pseudoprimes", "code": "theorem exists_infinite_pseudoprimes {b : \u2115} (h : 1 \u2264 b) (m : \u2115) :\n    \u2203 n : \u2115, FermatPsp n b \u2227 m \u2264 n", "start": [336, 1], "end": [373, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.frequently_atTop_fermatPsp", "code": "theorem frequently_atTop_fermatPsp {b : \u2115} (h : 1 \u2264 b) : \u2203\u1da0 n in Filter.atTop, FermatPsp n b", "start": [376, 1], "end": [380, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.infinite_setOf_pseudoprimes", "code": "theorem infinite_setOf_pseudoprimes {b : \u2115} (h : 1 \u2264 b) :\n    Set.Infinite { n : \u2115 | FermatPsp n b }", "start": [383, 1], "end": [387, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/WithOne/Units.lean", "imports": ["Mathlib/Algebra/Group/WithOne/Basic.lean", "Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WithZero.unitsWithZeroEquiv", "code": "def unitsWithZeroEquiv {\u03b1 : Type*} [Group \u03b1] : (WithZero \u03b1)\u02e3 \u2243* \u03b1 where\n  toFun a := unzero a.ne_zero\n  invFun a := Units.mk0 a coe_ne_zero\n  left_inv _ := Units.ext <| by simp only [coe_unzero, Units.mk0_val]\n  right_inv _ := rfl\n  map_mul' _ _ := coe_inj.mp <| by simp only [Units.val_mul, coe_unzero, coe_mul]", "start": [22, 1], "end": [28, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rbtree/Init.lean", "imports": ["lake-packages/std/Std/Data/RBMap/Basic.lean", "Mathlib/Init/Align.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Data/Multiset/Fintype.lean", "imports": ["Mathlib/Data/Fintype/Card.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Data/Prod/Lex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.ToType", "code": "def Multiset.ToType (m : Multiset \u03b1) : Type _ :=\n  \u03a3x : \u03b1, Fin (m.count x)", "start": [41, 1], "end": [46, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.mkToType", "code": "@[reducible, match_pattern]\ndef Multiset.mkToType (m : Multiset \u03b1) (x : \u03b1) (i : Fin (m.count x)) : m :=\n  \u27e8x, i\u27e9", "start": [58, 1], "end": [62, 9], "kind": "commanddeclaration"}, {"full_name": "instCoeSortMultisetType.instCoeOutToType", "code": "instance instCoeSortMultisetType.instCoeOutToType : CoeOut m \u03b1 :=\n  \u27e8fun x \u21a6 x.1\u27e9", "start": [65, 1], "end": [69, 16], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_eq", "code": "@[simp]\ntheorem Multiset.coe_eq {x y : m} : (x : \u03b1) = (y : \u03b1) \u2194 x.1 = y.1", "start": [75, 1], "end": [79, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_mk", "code": "theorem Multiset.coe_mk {x : \u03b1} {i : Fin (m.count x)} : \u2191(m.mkToType x i) = x", "start": [83, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_mem", "code": "@[simp]\ntheorem Multiset.coe_mem {x : m} : \u2191x \u2208 m", "start": [87, 1], "end": [89, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.forall_coe", "code": "@[simp]\nprotected theorem Multiset.forall_coe (p : m \u2192 Prop) :\n    (\u2200 x : m, p x) \u2194 \u2200 (x : \u03b1) (i : Fin (m.count x)), p \u27e8x, i\u27e9", "start": [92, 1], "end": [95, 15], "kind": "commanddeclaration"}, {"full_name": "Multiset.exists_coe", "code": "@[simp]\nprotected theorem Multiset.exists_coe (p : m \u2192 Prop) :\n    (\u2203 x : m, p x) \u2194 \u2203 (x : \u03b1) (i : Fin (m.count x)), p \u27e8x, i\u27e9", "start": [98, 1], "end": [101, 15], "kind": "commanddeclaration"}, {"full_name": "Multiset.toEnumFinset", "code": "def Multiset.toEnumFinset (m : Multiset \u03b1) : Finset (\u03b1 \u00d7 \u2115) :=\n  { p : \u03b1 \u00d7 \u2115 | p.2 < m.count p.1 }.toFinset", "start": [114, 1], "end": [118, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_toEnumFinset", "code": "@[simp]\ntheorem Multiset.mem_toEnumFinset (m : Multiset \u03b1) (p : \u03b1 \u00d7 \u2115) :\n    p \u2208 m.toEnumFinset \u2194 p.2 < m.count p.1", "start": [121, 1], "end": [124, 19], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_of_mem_toEnumFinset", "code": "theorem Multiset.mem_of_mem_toEnumFinset {p : \u03b1 \u00d7 \u2115} (h : p \u2208 m.toEnumFinset) : p.1 \u2208 m", "start": [127, 1], "end": [128, 68], "kind": "commanddeclaration"}, {"full_name": "Multiset.toEnumFinset_mono", "code": "@[mono]\ntheorem Multiset.toEnumFinset_mono {m\u2081 m\u2082 : Multiset \u03b1} (h : m\u2081 \u2264 m\u2082) :\n    m\u2081.toEnumFinset \u2286 m\u2082.toEnumFinset", "start": [131, 1], "end": [136, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.toEnumFinset_subset_iff", "code": "@[simp]\ntheorem Multiset.toEnumFinset_subset_iff {m\u2081 m\u2082 : Multiset \u03b1} :\n    m\u2081.toEnumFinset \u2286 m\u2082.toEnumFinset \u2194 m\u2081 \u2264 m\u2082", "start": [139, 1], "end": [151, 14], "kind": "commanddeclaration"}, {"full_name": "Multiset.coeEmbedding", "code": "@[simps]\ndef Multiset.coeEmbedding (m : Multiset \u03b1) : m \u21aa \u03b1 \u00d7 \u2115\n    where\n  toFun x := (x, x.2)\n  inj' := by\n    intro \u27e8x, i, hi\u27e9 \u27e8y, j, hj\u27e9\n    rintro \u27e8\u27e9\n    rfl", "start": [154, 1], "end": [163, 8], "kind": "commanddeclaration"}, {"full_name": "Multiset.coeEquiv", "code": "@[simps]\ndef Multiset.coeEquiv (m : Multiset \u03b1) : m \u2243 m.toEnumFinset\n    where\n  toFun x :=\n    \u27e8m.coeEmbedding x, by\n      rw [Multiset.mem_toEnumFinset]\n      exact x.2.2\u27e9\n  invFun x :=\n    \u27e8x.1.1, x.1.2, by\n      rw [\u2190 Multiset.mem_toEnumFinset]\n      exact x.2\u27e9\n  left_inv := by\n    rintro \u27e8x, i, h\u27e9\n    rfl\n  right_inv := by\n    rintro \u27e8\u27e8x, i\u27e9, h\u27e9\n    rfl", "start": [166, 1], "end": [184, 8], "kind": "commanddeclaration"}, {"full_name": "Multiset.toEmbedding_coeEquiv_trans", "code": "@[simp]\ntheorem Multiset.toEmbedding_coeEquiv_trans (m : Multiset \u03b1) :\n    m.coeEquiv.toEmbedding.trans (Function.Embedding.subtype _) = m.coeEmbedding", "start": [187, 1], "end": [189, 99], "kind": "commanddeclaration"}, {"full_name": "Multiset.fintypeCoe", "code": "@[irreducible]\ninstance Multiset.fintypeCoe : Fintype m :=\n  Fintype.ofEquiv m.toEnumFinset m.coeEquiv.symm", "start": [192, 1], "end": [194, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_univ_coeEmbedding", "code": "theorem Multiset.map_univ_coeEmbedding (m : Multiset \u03b1) :\n    (Finset.univ : Finset m).map m.coeEmbedding = m.toEnumFinset", "start": [197, 1], "end": [203, 18], "kind": "commanddeclaration"}, {"full_name": "Multiset.toEnumFinset_filter_eq", "code": "theorem Multiset.toEnumFinset_filter_eq (m : Multiset \u03b1) (x : \u03b1) :\n    (m.toEnumFinset.filter fun p \u21a6 x = p.1) =\n      (Finset.range (m.count x)).map \u27e8Prod.mk x, Prod.mk.inj_left x\u27e9", "start": [206, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_toEnumFinset_fst", "code": "@[simp]\ntheorem Multiset.map_toEnumFinset_fst (m : Multiset \u03b1) : m.toEnumFinset.val.map Prod.fst = m", "start": [217, 1], "end": [221, 78], "kind": "commanddeclaration"}, {"full_name": "Multiset.image_toEnumFinset_fst", "code": "@[simp]\ntheorem Multiset.image_toEnumFinset_fst (m : Multiset \u03b1) :\n    m.toEnumFinset.image Prod.fst = m.toFinset", "start": [224, 1], "end": [227, 51], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_univ_coe", "code": "@[simp]\ntheorem Multiset.map_univ_coe (m : Multiset \u03b1) :\n    (Finset.univ : Finset m).val.map (fun x : m \u21a6 (x : \u03b1)) = m", "start": [230, 1], "end": [236, 36], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_univ", "code": "@[simp]\ntheorem Multiset.map_univ {\u03b2 : Type*} (m : Multiset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    ((Finset.univ : Finset m).val.map fun (x : m) \u21a6 f (x : \u03b1)) = m.map f", "start": [239, 1], "end": [243, 29], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_toEnumFinset", "code": "@[simp]\ntheorem Multiset.card_toEnumFinset (m : Multiset \u03b1) : m.toEnumFinset.card = Multiset.card m", "start": [246, 1], "end": [250, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_coe", "code": "@[simp]\ntheorem Multiset.card_coe (m : Multiset \u03b1) : Fintype.card m = Multiset.card m", "start": [253, 1], "end": [256, 50], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_eq_prod_coe", "code": "@[to_additive]\ntheorem Multiset.prod_eq_prod_coe [CommMonoid \u03b1] (m : Multiset \u03b1) : m.prod = \u220f x : m, (x : \u03b1)", "start": [259, 1], "end": [263, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_eq_prod_toEnumFinset", "code": "@[to_additive]\ntheorem Multiset.prod_eq_prod_toEnumFinset [CommMonoid \u03b1] (m : Multiset \u03b1) :\n    m.prod = \u220f x in m.toEnumFinset, x.1", "start": [267, 1], "end": [271, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_toEnumFinset", "code": "@[to_additive]\ntheorem Multiset.prod_toEnumFinset {\u03b2 : Type*} [CommMonoid \u03b2] (m : Multiset \u03b1) (f : \u03b1 \u2192 \u2115 \u2192 \u03b2) :\n    \u220f x in m.toEnumFinset, f x.1 x.2 = \u220f x : m, f x x.2", "start": [275, 1], "end": [281, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Preadditive/EndoFunctor.lean", "imports": ["Mathlib/CategoryTheory/Preadditive/Basic.lean", "Mathlib/CategoryTheory/Preadditive/AdditiveFunctor.lean", "Mathlib/CategoryTheory/Endofunctor/Algebra.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Endofunctor.algebraPreadditive", "code": "@[simps]\ninstance Endofunctor.algebraPreadditive : Preadditive (Endofunctor.Algebra F) where\n  homGroup A\u2081 A\u2082 :=\n    { add := fun \u03b1 \u03b2 =>\n        { f := \u03b1.f + \u03b2.f\n          h := by simp only [Functor.map_add, add_comp, Endofunctor.Algebra.Hom.h, comp_add] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n \u03b1 =>\n        { f := n \u2022 \u03b1.f\n          h := by rw [comp_nsmul, Functor.map_nsmul, nsmul_comp, Endofunctor.Algebra.Hom.h] }\n      neg := fun \u03b1 =>\n        { f := -\u03b1.f\n          h := by simp only [Functor.map_neg, neg_comp, Endofunctor.Algebra.Hom.h, comp_neg] }\n      sub := fun \u03b1 \u03b2 =>\n        { f := \u03b1.f - \u03b2.f\n          h := by simp only [Functor.map_sub, sub_comp, Endofunctor.Algebra.Hom.h, comp_sub] }\n      zsmul := fun r \u03b1 =>\n        { f := r \u2022 \u03b1.f\n          h := by rw [comp_zsmul, Functor.map_zsmul, zsmul_comp, Endofunctor.Algebra.Hom.h] }\n      add_assoc := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_assoc\n      zero_add := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_add\n      add_zero := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        apply Algebra.Hom.ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        apply Algebra.Hom.ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        apply Algebra.Hom.ext\n        dsimp\n        simp only [coe_nat_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        apply Algebra.Hom.ext\n        simp only [negSucc_zsmul, neg_inj, nsmul_eq_smul_cast \u2124]\n      add_left_neg := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_left_neg\n      add_comm := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_comm }\n  add_comp := by\n    intros\n    apply Algebra.Hom.ext\n    apply add_comp\n  comp_add := by\n    intros\n    apply Algebra.Hom.ext\n    apply comp_add", "start": [29, 1], "end": [105, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Algebra.forget_additive", "code": "instance Algebra.forget_additive : (Endofunctor.Algebra.forget F).Additive where", "start": [108, 1], "end": [108, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.coalgebraPreadditive", "code": "@[simps]\ninstance Endofunctor.coalgebraPreadditive : Preadditive (Endofunctor.Coalgebra F) where\n  homGroup A\u2081 A\u2082 :=\n    { add := fun \u03b1 \u03b2 =>\n        { f := \u03b1.f + \u03b2.f\n          h := by simp only [Functor.map_add, comp_add, Endofunctor.Coalgebra.Hom.h, add_comp] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n \u03b1 =>\n        { f := n \u2022 \u03b1.f\n          h := by rw [Functor.map_nsmul, comp_nsmul, Endofunctor.Coalgebra.Hom.h, nsmul_comp] }\n      neg := fun \u03b1 =>\n        { f := -\u03b1.f\n          h := by simp only [Functor.map_neg, comp_neg, Endofunctor.Coalgebra.Hom.h, neg_comp] }\n      sub := fun \u03b1 \u03b2 =>\n        { f := \u03b1.f - \u03b2.f\n          h := by simp only [Functor.map_sub, comp_sub, Endofunctor.Coalgebra.Hom.h, sub_comp] }\n      zsmul := fun r \u03b1 =>\n        { f := r \u2022 \u03b1.f\n          h := by rw [Functor.map_zsmul, comp_zsmul, Endofunctor.Coalgebra.Hom.h, zsmul_comp] }\n      add_assoc := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_assoc\n      zero_add := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_add\n      add_zero := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        apply Coalgebra.Hom.ext\n        dsimp\n        simp only [coe_nat_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        apply Coalgebra.Hom.ext\n        simp only [negSucc_zsmul, neg_inj, nsmul_eq_smul_cast \u2124]\n      add_left_neg := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_left_neg\n      add_comm := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_comm }\n  add_comp := by\n    intros\n    apply Coalgebra.Hom.ext\n    apply add_comp\n  comp_add := by\n    intros\n    apply Coalgebra.Hom.ext\n    apply comp_add", "start": [111, 1], "end": [185, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Coalgebra.forget_additive", "code": "instance Coalgebra.forget_additive : (Endofunctor.Coalgebra.forget F).Additive where", "start": [188, 1], "end": [188, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/ModuleCat/ChangeOfRings.lean", "imports": ["Mathlib/RingTheory/TensorProduct.lean", "Mathlib/Algebra/Category/ModuleCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ModuleCat.RestrictScalars.obj'", "code": "def obj' : ModuleCat R where\n  carrier := M\n  isModule := Module.compHom M f", "start": [59, 1], "end": [63, 33], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.RestrictScalars.map'", "code": "def map' {M M' : ModuleCat.{v} S} (g : M \u27f6 M') : obj' f M \u27f6 obj' f M' :=\n  { g with map_smul' := fun r => g.map_smul (f r) }", "start": [66, 1], "end": [70, 52], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.restrictScalars", "code": "def restrictScalars {R : Type u\u2081} {S : Type u\u2082} [Ring R] [Ring S] (f : R \u2192+* S) :\n    ModuleCat.{v} S \u2964 ModuleCat.{v} R where\n  obj := RestrictScalars.obj' f\n  map := RestrictScalars.map' f\n  map_id _ := LinearMap.ext fun _ => rfl\n  map_comp _ _ := LinearMap.ext fun _ => rfl", "start": [75, 1], "end": [84, 45], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.restrictScalars.map_apply", "code": "@[simp]\ntheorem restrictScalars.map_apply {R : Type u\u2081} {S : Type u\u2082} [Ring R] [Ring S] (f : R \u2192+* S)\n    {M M' : ModuleCat.{v} S} (g : M \u27f6 M') (x) : (restrictScalars f).map g x = g x", "start": [102, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.restrictScalars.smul_def", "code": "@[simp]\ntheorem restrictScalars.smul_def {R : Type u\u2081} {S : Type u\u2082} [Ring R] [Ring S] (f : R \u2192+* S)\n    {M : ModuleCat.{v} S} (r : R) (m : (restrictScalars f).obj M) : r \u2022 m = (f r \u2022 m : M)", "start": [108, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.restrictScalars.smul_def'", "code": "theorem restrictScalars.smul_def' {R : Type u\u2081} {S : Type u\u2082} [Ring R] [Ring S] (f : R \u2192+* S)\n    {M : ModuleCat.{v} S} (r : R) (m : M) :\n    let m' : (restrictScalars f).obj M := m\n    (r \u2022 m' : (restrictScalars f).obj M) = (f r \u2022 m : M)", "start": [114, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.sMulCommClass_mk", "code": "instance (priority := 100) sMulCommClass_mk {R : Type u\u2081} {S : Type u\u2082} [Ring R] [CommRing S]\n    (f : R \u2192+* S) (M : Type v) [I : AddCommGroup M] [Module S M] :\n    haveI : SMul R M := (RestrictScalars.obj' f (ModuleCat.mk M)).isModule.toSMul\n    SMulCommClass R S M :=\n  have : SMul R M := (RestrictScalars.obj' f (ModuleCat.mk M)).isModule.toSMul\n  @SMulCommClass.mk R S M (_) _\n   <| fun r s m => (by simp [\u2190 mul_smul, mul_comm] : f r \u2022 s \u2022 m = s \u2022 f r \u2022 m)", "start": [123, 1], "end": [130, 80], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.semilinearMapAddEquiv", "code": "@[simps]\ndef semilinearMapAddEquiv {R : Type u\u2081} {S : Type u\u2082} [Ring R] [Ring S] (f : R \u2192+* S)\n    (M : ModuleCat.{v} R) (N : ModuleCat.{v} S) :\n    (M \u2192\u209b\u2097[f] N) \u2243+ (M \u27f6 (ModuleCat.restrictScalars f).obj N) where\n  toFun g :=\n    { toFun := g\n      map_add' := by simp\n      map_smul' := by simp }\n  invFun g :=\n    { toFun := g\n      map_add' := by simp\n      map_smul' := g.map_smul }\n  left_inv g := rfl\n  right_inv g := rfl\n  map_add' g\u2081 g\u2082 := rfl", "start": [133, 1], "end": [149, 24], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.restrictScalarsId'", "code": "def restrictScalarsId' : ModuleCat.restrictScalars.{v} f \u2245 \ud835\udfed _ := by subst hf; rfl", "start": [155, 1], "end": [157, 83], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.restrictScalarsId'_inv_apply", "code": "@[simp, nolint simpNF]\nlemma restrictScalarsId'_inv_apply (M : ModuleCat R) (x : M) :\n    (restrictScalarsId' f hf).inv.app M x = x := by subst hf; rfl", "start": [160, 1], "end": [162, 66], "kind": "mathlibtacticlemma"}, {"full_name": "ModuleCat.restrictScalarsId'_hom_apply", "code": "@[simp, nolint simpNF]\nlemma restrictScalarsId'_hom_apply (M : ModuleCat R) (x : M) :\n    (restrictScalarsId' f hf).hom.app M x = x := by subst hf; rfl", "start": [165, 1], "end": [167, 66], "kind": "mathlibtacticlemma"}, {"full_name": "ModuleCat.restrictScalarsId", "code": "abbrev restrictScalarsId := restrictScalarsId'.{v} (RingHom.id R) rfl", "start": [171, 1], "end": [173, 70], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.restrictScalarsComp'", "code": "def restrictScalarsComp' :\n    ModuleCat.restrictScalars.{v} gf \u2245\n      ModuleCat.restrictScalars g \u22d9 ModuleCat.restrictScalars f := by subst hgf; rfl", "start": [182, 1], "end": [186, 85], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.restrictScalarsComp'_hom_apply", "code": "@[simp, nolint simpNF]\nlemma restrictScalarsComp'_hom_apply (M : ModuleCat R\u2083) (x : M) :\n    (restrictScalarsComp' f g gf hgf).hom.app M x = x := by subst hgf; rfl", "start": [189, 1], "end": [191, 75], "kind": "mathlibtacticlemma"}, {"full_name": "ModuleCat.restrictScalarsComp'_inv_apply", "code": "@[simp, nolint simpNF]\nlemma restrictScalarsComp'_inv_apply (M : ModuleCat R\u2083) (x : M) :\n    (restrictScalarsComp' f g gf hgf).inv.app M x = x := by subst hgf; rfl", "start": [194, 1], "end": [196, 75], "kind": "mathlibtacticlemma"}, {"full_name": "ModuleCat.restrictScalarsComp", "code": "abbrev restrictScalarsComp := restrictScalarsComp'.{v} f g _ rfl", "start": [198, 1], "end": [200, 65], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.ExtendScalars.obj'", "code": "def obj' : ModuleCat S :=\n  \u27e8TensorProduct R ((restrictScalars f).obj \u27e8S\u27e9) M\u27e9", "start": [226, 1], "end": [229, 52], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.ExtendScalars.map'", "code": "def map' {M1 M2 : ModuleCat.{v} R} (l : M1 \u27f6 M2) : obj' f M1 \u27f6 obj' f M2 :=\n  byapply @LinearMap.baseChange R S M1 M2 _ _ ((algebraMap S _).comp f).toAlgebra _ _ _ _ l", "start": [232, 1], "end": [237, 90], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.ExtendScalars.map'_id", "code": "theorem map'_id {M : ModuleCat.{v} R} : map' f (\ud835\udfd9 M) = \ud835\udfd9 _", "start": [240, 1], "end": [249, 29], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.ExtendScalars.map'_comp", "code": "theorem map'_comp {M\u2081 M\u2082 M\u2083 : ModuleCat.{v} R} (l\u2081\u2082 : M\u2081 \u27f6 M\u2082) (l\u2082\u2083 : M\u2082 \u27f6 M\u2083) :\n    map' f (l\u2081\u2082 \u226b l\u2082\u2083) = map' f l\u2081\u2082 \u226b map' f l\u2082\u2083", "start": [252, 1], "end": [259, 38], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.extendScalars", "code": "def extendScalars {R : Type u\u2081} {S : Type u\u2082} [CommRing R] [CommRing S] (f : R \u2192+* S) :\n    ModuleCat R \u2964 ModuleCat S where\n  obj M := ExtendScalars.obj' f M\n  map l := ExtendScalars.map' f l\n  map_id _ := ExtendScalars.map'_id f\n  map_comp := ExtendScalars.map'_comp f", "start": [264, 1], "end": [272, 40], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.ExtendScalars.smul_tmul", "code": "@[simp]\nprotected theorem smul_tmul {M : ModuleCat.{v} R} (s s' : S) (m : M) :\n    s \u2022 (s'\u2297\u209c[R,f]m : (extendScalars f).obj M) = (s * s')\u2297\u209c[R,f]m", "start": [281, 1], "end": [284, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.ExtendScalars.map_tmul", "code": "@[simp]\ntheorem map_tmul {M M' : ModuleCat.{v} R} (g : M \u27f6 M') (s : S) (m : M) :\n    (extendScalars f).map g (s\u2297\u209c[R,f]m) = s\u2297\u209c[R,f]g m", "start": [287, 1], "end": [290, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.CoextendScalars.hasSMul", "code": "instance hasSMul : SMul S <| (restrictScalars f).obj \u27e8S\u27e9 \u2192\u2097[R] M where\n  smul s g :=\n    { toFun := fun s' : S => g (s' * s : S)\n      map_add' := fun x y : S => by dsimp; rw [add_mul, map_add]\n      map_smul' := fun r (t : S) => by\n        dsimp\n        rw [\u2190 LinearMap.map_smul]\n        erw [smul_eq_mul, smul_eq_mul, mul_assoc] }", "start": [308, 1], "end": [319, 52], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.CoextendScalars.smul_apply'", "code": "@[simp]\ntheorem smul_apply' (s : S) (g : (restrictScalars f).obj \u27e8S\u27e9 \u2192\u2097[R] M) (s' : S) :\n    (s \u2022 g) s' = g (s' * s : S)", "start": [322, 1], "end": [325, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.CoextendScalars.mulAction", "code": "instance mulAction : MulAction S <| (restrictScalars f).obj \u27e8S\u27e9 \u2192\u2097[R] M :=\n  { CoextendScalars.hasSMul f _ with\n    one_smul := fun g => LinearMap.ext fun s : S => by simp\n    mul_smul := fun (s t : S) g => LinearMap.ext fun x : S => by simp [mul_assoc] }", "start": [328, 1], "end": [331, 84], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.CoextendScalars.distribMulAction", "code": "instance distribMulAction : DistribMulAction S <| (restrictScalars f).obj \u27e8S\u27e9 \u2192\u2097[R] M :=\n  { CoextendScalars.mulAction f _ with\n    smul_add := fun s g h => LinearMap.ext fun t : S => by simp\n    smul_zero := fun s => LinearMap.ext fun t : S => by simp }", "start": [334, 1], "end": [337, 63], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.CoextendScalars.isModule", "code": "instance isModule : Module S <| (restrictScalars f).obj \u27e8S\u27e9 \u2192\u2097[R] M :=\n  { CoextendScalars.distribMulAction f _ with\n    add_smul := fun s1 s2 g => LinearMap.ext fun x : S => by simp [mul_add, LinearMap.map_add]\n    zero_smul := fun g => LinearMap.ext fun x : S => by simp [LinearMap.map_zero] }", "start": [340, 1], "end": [346, 84], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.CoextendScalars.obj'", "code": "def obj' : ModuleCat S :=\n  \u27e8(restrictScalars f).obj \u27e8S\u27e9 \u2192\u2097[R] M\u27e9", "start": [353, 1], "end": [356, 40], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.CoextendScalars.map'", "code": "@[simps]\ndef map' {M M' : ModuleCat R} (g : M \u27f6 M') : obj' f M \u27f6 obj' f M' where\n  toFun h := g.comp h\n  map_add' _ _ := LinearMap.comp_add _ _ _\n  map_smul' s h := LinearMap.ext fun t : S => by dsimp; rw [smul_apply',smul_apply']; simp", "start": [361, 1], "end": [367, 91], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.coextendScalars", "code": "def coextendScalars {R : Type u\u2081} {S : Type u\u2082} [Ring R] [Ring S] (f : R \u2192+* S) :\n    ModuleCat R \u2964 ModuleCat S where\n  obj := CoextendScalars.obj' f\n  map := CoextendScalars.map' f\n  map_id _ := LinearMap.ext fun _ => LinearMap.ext fun _ => rfl\n  map_comp _ _ := LinearMap.ext fun _ => LinearMap.ext fun _ => rfl", "start": [373, 1], "end": [383, 68], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.CoextendScalars.smul_apply", "code": "theorem smul_apply (M : ModuleCat R) (g : (coextendScalars f).obj M) (s s' : S) :\n    (s \u2022 g) s' = g (s' * s)", "start": [394, 1], "end": [396, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.CoextendScalars.map_apply", "code": "@[simp]\ntheorem map_apply {M M' : ModuleCat R} (g : M \u27f6 M') (x) (s : S) :\n    (coextendScalars f).map g x s = g (x s)", "start": [399, 1], "end": [402, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.RestrictionCoextensionAdj.HomEquiv.fromRestriction", "code": "@[simps apply_apply]\ndef HomEquiv.fromRestriction {X : ModuleCat R} {Y : ModuleCat S}\n    (g : (restrictScalars f).obj Y \u27f6 X) : Y \u27f6 (coextendScalars f).obj X where\n  toFun := fun y : Y =>\n    { toFun := fun s : S => g <| (s \u2022 y : Y)\n      map_add' := fun s1 s2 : S => by simp only [add_smul]; rw [LinearMap.map_add]\n      map_smul' := fun r (s : S) => by\n        dsimp\n        rw [\u2190 g.map_smul]\n        erw [smul_eq_mul, mul_smul]\n        rfl}\n  map_add' := fun y1 y2 : Y =>\n    LinearMap.ext fun s : S => by\n      dsimp\n      rw [LinearMap.add_apply, LinearMap.coe_mk, LinearMap.coe_mk]\n      dsimp\n      rw [smul_add, map_add]\n  map_smul' := fun (s : S) (y : Y) => LinearMap.ext fun t : S => by\n      rw [RingHom.id_apply, LinearMap.coe_mk, ModuleCat.CoextendScalars.smul_apply',\n        LinearMap.coe_mk]\n      dsimp\n      rw [mul_smul]", "start": [413, 1], "end": [440, 20], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.RestrictionCoextensionAdj.HomEquiv.toRestriction", "code": "@[simps apply]\ndef HomEquiv.toRestriction {X Y} (g : Y \u27f6 (coextendScalars f).obj X) : (restrictScalars f).obj Y \u27f6 X\n    where\n  toFun := fun y : Y => (g y) (1 : S)\n  map_add' x y := by dsimp; rw [g.map_add, LinearMap.add_apply]\n  map_smul' r (y : Y) := by\n    dsimp\n    rw [\u2190 LinearMap.map_smul]\n    erw [smul_eq_mul, mul_one, LinearMap.map_smul]\n    rw [\u2190 LinearMap.coe_toAddHom, \u2190AddHom.toFun_eq_coe]\n    rw [CoextendScalars.smul_apply (s := f r) (g := g y) (s' := 1), one_mul]\n    simp", "start": [443, 1], "end": [458, 9], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.RestrictionCoextensionAdj.app'", "code": "def app' (Y : ModuleCat S) : Y \u2192\u2097[S] (restrictScalars f \u22d9 coextendScalars f).obj Y :=\n  { toFun := fun y : Y =>\n      { toFun := fun s : S => (s \u2022 y : Y)\n        map_add' := fun s s' => add_smul _ _ _\n        map_smul' := fun r (s : S) => by\n          dsimp\n          erw [smul_eq_mul, mul_smul]\n          simp }\n    map_add' := fun y1 y2 =>\n      LinearMap.ext fun s : S => by\n        dsimp\n        rw [LinearMap.add_apply, LinearMap.coe_mk, LinearMap.coe_mk, LinearMap.coe_mk]\n        dsimp\n        rw [smul_add]\n    map_smul' := fun s (y : Y) => LinearMap.ext fun t : S => by\n      rw [RingHom.id_apply, LinearMap.coe_mk, CoextendScalars.smul_apply', LinearMap.coe_mk]\n      dsimp\n      rw [mul_smul] }", "start": [462, 1], "end": [482, 22], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.RestrictionCoextensionAdj.unit'", "code": "protected def unit' : \ud835\udfed (ModuleCat S) \u27f6 restrictScalars f \u22d9 coextendScalars f where\n  app Y := app' f Y\n  naturality Y Y' g :=\n    LinearMap.ext fun y : Y => LinearMap.ext fun s : S => by\n      simp only [ModuleCat.coe_comp, Functor.id_map, Functor.id_obj, Functor.comp_obj,\n        Functor.comp_map]\n      rw [coe_comp, coe_comp, Function.comp, Function.comp]\n      conv_rhs => rw [\u2190 LinearMap.coe_toAddHom, \u2190AddHom.toFun_eq_coe]\n      erw [CoextendScalars.map_apply, AddHom.toFun_eq_coe, LinearMap.coe_toAddHom,\n        restrictScalars.map_apply f]\n      change s \u2022 (g y) = g (s \u2022 y)\n      rw [map_smul]", "start": [484, 1], "end": [501, 20], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.RestrictionCoextensionAdj.counit'", "code": "protected def counit' : coextendScalars f \u22d9 restrictScalars f \u27f6 \ud835\udfed (ModuleCat R) where\n  app X :=\n    { toFun := fun g => g.toFun (1 : S)\n      map_add' := fun x1 x2 => by\n        dsimp\n        rw [LinearMap.add_apply]\n      map_smul' := fun r (g : (restrictScalars f).obj ((coextendScalars f).obj X)) => by\n        dsimp\n        rw [\u2190 LinearMap.coe_toAddHom, \u2190AddHom.toFun_eq_coe]\n        rw [CoextendScalars.smul_apply (s := f r) (g := g) (s' := 1), one_mul, \u2190 LinearMap.map_smul]\n        rw [\u2190 LinearMap.coe_toAddHom, \u2190AddHom.toFun_eq_coe]\n        congr\n        change f r = (f r) \u2022 (1 : S)\n        rw [smul_eq_mul (a := f r) (a' := 1), mul_one] }\n  naturality X X' g := LinearMap.ext fun h => by\n    rw [ModuleCat.coe_comp]\n    rfl", "start": [504, 1], "end": [524, 8], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.restrictCoextendScalarsAdj", "code": "def restrictCoextendScalarsAdj {R : Type u\u2081} {S : Type u\u2082} [Ring R] [Ring S] (f : R \u2192+* S) :\n    restrictScalars.{max v u\u2082,u\u2081,u\u2082} f \u22a3 coextendScalars f where\n  homEquiv X Y :=\n    { toFun := RestrictionCoextensionAdj.HomEquiv.fromRestriction.{u\u2081,u\u2082,v} f\n      invFun := RestrictionCoextensionAdj.HomEquiv.toRestriction.{u\u2081,u\u2082,v} f\n      left_inv := fun g => LinearMap.ext fun x : X => by\n        rw [RestrictionCoextensionAdj.HomEquiv.toRestriction_apply, AddHom.toFun_eq_coe,\n          LinearMap.coe_toAddHom, RestrictionCoextensionAdj.HomEquiv.fromRestriction_apply_apply,\n          one_smul]\n      right_inv := fun g => LinearMap.ext fun x => LinearMap.ext fun s : S => by\n        rw [RestrictionCoextensionAdj.HomEquiv.fromRestriction_apply_apply,\n          RestrictionCoextensionAdj.HomEquiv.toRestriction_apply, AddHom.toFun_eq_coe,\n          LinearMap.coe_toAddHom, LinearMap.map_smul\u209b\u2097, RingHom.id_apply,\n          CoextendScalars.smul_apply', one_mul] }\n  unit := RestrictionCoextensionAdj.unit'.{u\u2081,u\u2082,v} f\n  counit := RestrictionCoextensionAdj.counit'.{u\u2081,u\u2082,v} f\n  homEquiv_unit := LinearMap.ext fun y => rfl\n  homEquiv_counit := fun {X Y g} => LinearMap.ext <| by\n    intro x; dsimp\n    rw [coe_comp, Function.comp]\n    change _ = (((restrictScalars f).map g) x).toFun (1 : S)\n    rw [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom, restrictScalars.map_apply]", "start": [530, 1], "end": [556, 80], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.ExtendRestrictScalarsAdj.HomEquiv.toRestrictScalars", "code": "@[simps apply]\ndef HomEquiv.toRestrictScalars {X Y} (g : (extendScalars f).obj X \u27f6 Y) :\n    X \u27f6 (restrictScalars f).obj Y where\n  toFun x := g <| (1 : S)\u2297\u209c[R,f]x\n  map_add' _ _ := by dsimp; rw [tmul_add, map_add]\n  map_smul' r x := by\n    letI : Module R S := Module.compHom S f\n    letI : Module R Y := Module.compHom Y f\n    dsimp\n    rw [RestrictScalars.smul_def, \u2190 LinearMap.map_smul]\n    erw [tmul_smul]\n    congr", "start": [575, 1], "end": [591, 10], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.ExtendRestrictScalarsAdj.HomEquiv.evalAt", "code": "@[simps]\ndef HomEquiv.evalAt {X : ModuleCat R} {Y : ModuleCat S} (s : S)\n    (g : X \u27f6 (restrictScalars f).obj Y) : have : Module R Y := Module.compHom Y f\n    X \u2192\u2097[R] Y :=\n  @LinearMap.mk _ _ _ _ (RingHom.id R) X Y _ _ _ (_)\n    { toFun := fun x => s \u2022 (g x : Y)\n      map_add' := by intros; dsimp; rw [map_add,smul_add] }\n    (by\n      intros r x\n      rw [AddHom.toFun_eq_coe, AddHom.coe_mk, RingHom.id_apply,\n        LinearMap.map_smul, smul_comm r s (g x : Y)] )", "start": [595, 1], "end": [608, 55], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.ExtendRestrictScalarsAdj.HomEquiv.fromExtendScalars", "code": "@[simps apply]\ndef HomEquiv.fromExtendScalars {X Y} (g : X \u27f6 (restrictScalars f).obj Y) :\n    (extendScalars f).obj X \u27f6 Y := by\n  letI m1 : Module R S := Module.compHom S f; letI m2 : Module R Y := Module.compHom Y f\n  refine {toFun := fun z => TensorProduct.lift ?_ z, map_add' := ?_, map_smul' := ?_}\n  \u00b7 refine\n    {toFun := fun s => HomEquiv.evalAt f s g, map_add' := fun (s\u2081 s\u2082 : S) => ?_,\n      map_smul' := fun (r : R) (s : S) => ?_}\n    \u00b7 ext\n      dsimp\n      rw [\u2190 add_smul]\n    \u00b7 ext x\n      apply mul_smul (f r) s (g x)\n  \u00b7 intros z\u2081 z\u2082\n    change lift _ (z\u2081 + z\u2082) = lift _ z\u2081 + lift _ z\u2082\n    rw [map_add]\n  \u00b7 intro s z\n    change lift _ (s \u2022 z) = s \u2022 lift _ z\n    induction' z using TensorProduct.induction_on with s' x x y ih1 ih2\n    \u00b7 rw [smul_zero, map_zero, smul_zero]\n    \u00b7 rw [LinearMap.coe_mk, ExtendScalars.smul_tmul]\n      erw [lift.tmul, lift.tmul]\n      set s' : S := s'\n      change (s * s') \u2022 (g x) = s \u2022 s' \u2022 (g x)\n      rw [mul_smul]\n    \u00b7 rw [smul_add, map_add, ih1, ih2, map_add, smul_add]", "start": [610, 1], "end": [640, 58], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.ExtendRestrictScalarsAdj.homEquiv", "code": "@[simps symm_apply]\ndef homEquiv {X Y} :\n    ((extendScalars f).obj X \u27f6 Y) \u2243 (X \u27f6 (restrictScalars.{max v u\u2082,u\u2081,u\u2082} f).obj Y) where\n  toFun := HomEquiv.toRestrictScalars.{u\u2081,u\u2082,v} f\n  invFun := HomEquiv.fromExtendScalars.{u\u2081,u\u2082,v} f\n  left_inv g := by\n    letI m1 : Module R S := Module.compHom S f; letI m2 : Module R Y := Module.compHom Y f\n    apply LinearMap.ext; intro z\n    induction' z using TensorProduct.induction_on with x s z1 z2 ih1 ih2\n    \u00b7 rw [map_zero, map_zero]\n    \u00b7 erw [TensorProduct.lift.tmul]\n      simp only [LinearMap.coe_mk]\n      change S at x\n      dsimp\n      erw [\u2190 LinearMap.map_smul, ExtendScalars.smul_tmul, mul_one x]\n    \u00b7 rw [map_add, map_add, ih1, ih2]\n  right_inv g := by\n    letI m1 : Module R S := Module.compHom S f; letI m2 : Module R Y := Module.compHom Y f\n    apply LinearMap.ext; intro x\n    rw [HomEquiv.toRestrictScalars_apply, HomEquiv.fromExtendScalars_apply, lift.tmul,\n      LinearMap.coe_mk, LinearMap.coe_mk]\n    dsimp\n    rw [one_smul]", "start": [643, 1], "end": [668, 18], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.ExtendRestrictScalarsAdj.Unit.map", "code": "def Unit.map {X} : X \u27f6 (extendScalars f \u22d9 restrictScalars f).obj X where\n  toFun x := (1 : S)\u2297\u209c[R,f]x\n  map_add' x x' := by dsimp; rw [TensorProduct.tmul_add]\n  map_smul' r x := by\n    letI m1 : Module R S := Module.compHom S f\n    dsimp; rw [\u2190TensorProduct.smul_tmul,TensorProduct.smul_tmul']", "start": [671, 1], "end": [681, 66], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.ExtendRestrictScalarsAdj.unit", "code": "@[simps]\ndef unit : \ud835\udfed (ModuleCat R) \u27f6 extendScalars f \u22d9 restrictScalars.{max v u\u2082,u\u2081,u\u2082} f where\n  app _ := Unit.map.{u\u2081,u\u2082,v} f", "start": [684, 1], "end": [690, 32], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.ExtendRestrictScalarsAdj.Counit.map", "code": "@[simps apply]\ndef Counit.map {Y} : (restrictScalars f \u22d9 extendScalars f).obj Y \u27f6 Y := by\n  letI m1 : Module R S := Module.compHom S f\n  letI m2 : Module R Y := Module.compHom Y f\n  refine'\n    {toFun := TensorProduct.lift\n      {toFun := fun s : S => {toFun := fun y : Y => s \u2022 y, map_add' := smul_add _, map_smul' := _},\n        map_add' := _, map_smul' := _}, map_add' := _, map_smul' := _}\n  \u00b7 intros r y\n    dsimp\n    change s \u2022 f r \u2022 y = f r \u2022 s \u2022 y\n    rw [\u2190mul_smul, mul_comm, mul_smul]\n  \u00b7 intros s\u2081 s\u2082\n    ext y\n    change (s\u2081 + s\u2082) \u2022 y = s\u2081 \u2022 y + s\u2082 \u2022 y\n    rw [add_smul]\n  \u00b7 intros r s\n    ext y\n    change (f r \u2022 s) \u2022 y = (f r) \u2022 s \u2022 y\n    rw [smul_eq_mul,mul_smul]\n  \u00b7 intros\n    rw [map_add]\n  \u00b7 intro s z\n    dsimp\n    induction' z using TensorProduct.induction_on with s' y z1 z2 ih1 ih2\n    \u00b7 rw [smul_zero, map_zero, smul_zero]\n    \u00b7 rw [ExtendScalars.smul_tmul, LinearMap.coe_mk]\n      erw [TensorProduct.lift.tmul, TensorProduct.lift.tmul]\n      set s' : S := s'\n      change (s * s') \u2022 y = s \u2022 s' \u2022 y\n      rw [mul_smul]\n    \u00b7 rw [smul_add, map_add, map_add, ih1, ih2, smul_add]", "start": [693, 1], "end": [727, 58], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.ExtendRestrictScalarsAdj.counit", "code": "@[simps app]\ndef counit : restrictScalars.{max v u\u2082,u\u2081,u\u2082} f \u22d9 extendScalars f \u27f6 \ud835\udfed (ModuleCat S) where\n  app _ := Counit.map.{u\u2081,u\u2082,v} f\n  naturality Y Y' g := by\n    letI m1 : Module R S := Module.compHom S f\n    letI m2 : Module R Y := Module.compHom Y f\n    letI m2 : Module R Y' := Module.compHom Y' f\n    apply LinearMap.ext; intro z\n    induction' z using TensorProduct.induction_on with s' y z\u2081 z\u2082 ih\u2081 ih\u2082\n    \u00b7 rw [map_zero, map_zero]\n    \u00b7 dsimp\n      rw [ModuleCat.coe_comp, ModuleCat.coe_comp,Function.comp,Function.comp,\n        ExtendScalars.map_tmul, restrictScalars.map_apply]\n      erw [Counit.map_apply]\n      rw [lift.tmul, LinearMap.coe_mk, LinearMap.coe_mk]\n      set s' : S := s'\n      change s' \u2022 g y = g (s' \u2022 y)\n      rw [map_smul]\n    \u00b7 rw [map_add,map_add]\n      congr 1", "start": [735, 1], "end": [759, 14], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.extendRestrictScalarsAdj", "code": "def extendRestrictScalarsAdj {R : Type u\u2081} {S : Type u\u2082} [CommRing R] [CommRing S] (f : R \u2192+* S) :\n    extendScalars.{u\u2081,u\u2082,max v u\u2082} f \u22a3 restrictScalars.{max v u\u2082,u\u2081,u\u2082} f where\n  homEquiv _ _ := ExtendRestrictScalarsAdj.homEquiv.{v,u\u2081,u\u2082} f\n  unit := ExtendRestrictScalarsAdj.unit.{v,u\u2081,u\u2082} f\n  counit := ExtendRestrictScalarsAdj.counit.{v,u\u2081,u\u2082} f\n  homEquiv_unit {X Y g} := LinearMap.ext fun x => by\n    dsimp\n    rw [ModuleCat.coe_comp, Function.comp, restrictScalars.map_apply]\n    rfl\n  homEquiv_counit {X Y g} := LinearMap.ext fun x => by\n      letI m1 : Module R S := Module.compHom S f\n      letI m2 : Module R Y := Module.compHom Y f\n      induction' x using TensorProduct.induction_on with s x _ _ _ _\n      \u00b7 rw [map_zero, map_zero]\n      \u00b7 rw [ExtendRestrictScalarsAdj.homEquiv_symm_apply]\n        erw [ModuleCat.coe_comp]\n        rw [Function.comp_apply, ExtendRestrictScalarsAdj.counit_app]\n        erw [ExtendRestrictScalarsAdj.Counit.map_apply]\n        dsimp\n        rw [TensorProduct.lift.tmul]\n        rfl\n      \u00b7 rw [map_add,map_add]\n        congr 1", "start": [763, 1], "end": [792, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/Pointwise.lean", "imports": ["Mathlib/Data/Finsupp/Defs.lean", "Mathlib/Algebra/Ring/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp.coe_mul", "code": "theorem coe_mul (g\u2081 g\u2082 : \u03b1 \u2192\u2080 \u03b2) : \u21d1(g\u2081 * g\u2082) = g\u2081 * g\u2082", "start": [43, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mul_apply", "code": "@[simp]\ntheorem mul_apply {g\u2081 g\u2082 : \u03b1 \u2192\u2080 \u03b2} {a : \u03b1} : (g\u2081 * g\u2082) a = g\u2081 a * g\u2082 a", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_mul", "code": "theorem support_mul [DecidableEq \u03b1] {g\u2081 g\u2082 : \u03b1 \u2192\u2080 \u03b2} :\n    (g\u2081 * g\u2082).support \u2286 g\u2081.support \u2229 g\u2082.support", "start": [52, 1], "end": [60, 39], "kind": "commanddeclaration"}, {"full_name": "Finsupp.pointwiseScalar", "code": "instance pointwiseScalar [Semiring \u03b2] : SMul (\u03b1 \u2192 \u03b2) (\u03b1 \u2192\u2080 \u03b2) where\n  smul f g :=\n    Finsupp.ofSupportFinite (fun a \u21a6 f a \u2022 g a) (by\n      apply Set.Finite.subset g.finite_support\n      simp only [Function.support_subset_iff, Finsupp.mem_support_iff, Ne.def,\n        Finsupp.fun_support_eq, Finset.mem_coe]\n      intro x hx h\n      apply hx\n      rw [h, smul_zero])", "start": [95, 1], "end": [103, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_pointwise_smul", "code": "@[simp]\ntheorem coe_pointwise_smul [Semiring \u03b2] (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192\u2080 \u03b2) : FunLike.coe (f \u2022 g) = f \u2022 g", "start": [106, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.pointwiseModule", "code": "instance pointwiseModule [Semiring \u03b2] : Module (\u03b1 \u2192 \u03b2) (\u03b1 \u2192\u2080 \u03b2) :=\n  Function.Injective.module _ coeFnAddHom FunLike.coe_injective coe_pointwise_smul", "start": [111, 1], "end": [113, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rbtree/Basic.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Topology/MetricSpace/Infsep.lean", "imports": ["Mathlib/Topology/MetricSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.einfsep", "code": "noncomputable def einfsep [EDist \u03b1] (s : Set \u03b1) : \u211d\u22650\u221e :=\n  \u2a05 (x \u2208 s) (y \u2208 s) (_ : x \u2260 y), edist x y", "start": [41, 1], "end": [43, 43], "kind": "commanddeclaration"}, {"full_name": "Set.le_einfsep_iff", "code": "theorem le_einfsep_iff {d} :\n    d \u2264 s.einfsep \u2194 \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s) (_hxy : x \u2260 y), d \u2264 edist x y", "start": [50, 1], "end": [52, 33], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_zero", "code": "theorem einfsep_zero : s.einfsep = 0 \u2194\n    \u2200 (C) (_hC : 0 < C), \u2203 (x : _) (_ : x \u2208 s) (y : _) (_ : y \u2208 s) (_hxy : x \u2260 y), edist x y < C", "start": [55, 1], "end": [57, 71], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_pos", "code": "theorem einfsep_pos :\n    0 < s.einfsep \u2194\n      \u2203 (C : _) (_hC : 0 < C), \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s) (_hxy : x \u2260 y), C \u2264 edist x y", "start": [60, 1], "end": [64, 45], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_top", "code": "theorem einfsep_top :\n    s.einfsep = \u221e \u2194 \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s) (_hxy : x \u2260 y), edist x y = \u221e", "start": [67, 1], "end": [69, 33], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_lt_top", "code": "theorem einfsep_lt_top :\n    s.einfsep < \u221e \u2194 \u2203 (x : _) (_ : x \u2208 s) (y : _) (_ : y \u2208 s) (_hxy : x \u2260 y), edist x y < \u221e", "start": [72, 1], "end": [74, 33], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_ne_top", "code": "theorem einfsep_ne_top :\n    s.einfsep \u2260 \u221e \u2194 \u2203 (x : _) (_ : x \u2208 s) (y : _) (_ : y \u2208 s) (_hxy : x \u2260 y), edist x y \u2260 \u221e", "start": [77, 1], "end": [79, 48], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_lt_iff", "code": "theorem einfsep_lt_iff {d} :\n    s.einfsep < d \u2194 \u2203 (x : _) (_ : x \u2208 s) (y : _) (_ : y \u2208 s) (_h : x \u2260 y), edist x y < d", "start": [82, 1], "end": [84, 33], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_of_einfsep_lt_top", "code": "theorem nontrivial_of_einfsep_lt_top (hs : s.einfsep < \u221e) : s.Nontrivial", "start": [87, 1], "end": [89, 28], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_of_einfsep_ne_top", "code": "theorem nontrivial_of_einfsep_ne_top (hs : s.einfsep \u2260 \u221e) : s.Nontrivial", "start": [92, 1], "end": [93, 58], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.einfsep", "code": "theorem Subsingleton.einfsep (hs : s.Subsingleton) : s.einfsep = \u221e", "start": [96, 1], "end": [98, 52], "kind": "commanddeclaration"}, {"full_name": "Set.le_einfsep_image_iff", "code": "theorem le_einfsep_image_iff {d} {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} :\n    d \u2264 einfsep (f '' s) \u2194 \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s), f x \u2260 f y \u2192 d \u2264 edist (f x) (f y)", "start": [101, 1], "end": [103, 46], "kind": "commanddeclaration"}, {"full_name": "Set.le_edist_of_le_einfsep", "code": "theorem le_edist_of_le_einfsep {d x} (hx : x \u2208 s) {y} (hy : y \u2208 s) (hxy : x \u2260 y)\n    (hd : d \u2264 s.einfsep) : d \u2264 edist x y", "start": [106, 1], "end": [108, 36], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_le_edist_of_mem", "code": "theorem einfsep_le_edist_of_mem {x} (hx : x \u2208 s) {y} (hy : y \u2208 s) (hxy : x \u2260 y) :\n    s.einfsep \u2264 edist x y", "start": [111, 1], "end": [113, 42], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_le_of_mem_of_edist_le", "code": "theorem einfsep_le_of_mem_of_edist_le {d x} (hx : x \u2208 s) {y} (hy : y \u2208 s) (hxy : x \u2260 y)\n    (hxy' : edist x y \u2264 d) : s.einfsep \u2264 d", "start": [116, 1], "end": [118, 52], "kind": "commanddeclaration"}, {"full_name": "Set.le_einfsep", "code": "theorem le_einfsep {d} (h : \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s) (_hxy : x \u2260 y), d \u2264 edist x y) :\n    d \u2264 s.einfsep", "start": [121, 1], "end": [123, 21], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_empty", "code": "@[simp]\ntheorem einfsep_empty : (\u2205 : Set \u03b1).einfsep = \u221e", "start": [126, 1], "end": [128, 29], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_singleton", "code": "@[simp]\ntheorem einfsep_singleton : ({x} : Set \u03b1).einfsep = \u221e", "start": [131, 1], "end": [133, 33], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_iUnion_mem_option", "code": "theorem einfsep_iUnion_mem_option {\u03b9 : Type*} (o : Option \u03b9) (s : \u03b9 \u2192 Set \u03b1) :\n    (\u22c3 i \u2208 o, s i).einfsep = \u2a05 i \u2208 o, (s i).einfsep", "start": [136, 1], "end": [137, 75], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_anti", "code": "theorem einfsep_anti (hst : s \u2286 t) : t.einfsep \u2264 s.einfsep", "start": [140, 1], "end": [141, 74], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_insert_le", "code": "theorem einfsep_insert_le : (insert x s).einfsep \u2264 \u2a05 (y \u2208 s) (_ : x \u2260 y), edist x y", "start": [144, 1], "end": [146, 96], "kind": "commanddeclaration"}, {"full_name": "Set.le_einfsep_pair", "code": "theorem le_einfsep_pair : edist x y \u2293 edist y x \u2264 ({x, y} : Set \u03b1).einfsep", "start": [149, 1], "end": [152, 18], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_pair_le_left", "code": "theorem einfsep_pair_le_left (hxy : x \u2260 y) : ({x, y} : Set \u03b1).einfsep \u2264 edist x y", "start": [155, 1], "end": [156, 87], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_pair_le_right", "code": "theorem einfsep_pair_le_right (hxy : x \u2260 y) : ({x, y} : Set \u03b1).einfsep \u2264 edist y x", "start": [159, 1], "end": [160, 54], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_pair_eq_inf", "code": "theorem einfsep_pair_eq_inf (hxy : x \u2260 y) : ({x, y} : Set \u03b1).einfsep = edist x y \u2293 edist y x", "start": [163, 1], "end": [164, 94], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_eq_iInf", "code": "theorem einfsep_eq_iInf : s.einfsep = \u2a05 d : s.offDiag, (uncurry edist) (d : \u03b1 \u00d7 \u03b1)", "start": [167, 1], "end": [170, 46], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_of_fintype", "code": "theorem einfsep_of_fintype [DecidableEq \u03b1] [Fintype s] :\n    s.einfsep = s.offDiag.toFinset.inf (uncurry edist)", "start": [173, 1], "end": [177, 46], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.einfsep", "code": "theorem Finite.einfsep (hs : s.Finite) : s.einfsep = hs.offDiag.toFinset.inf (uncurry edist)", "start": [180, 1], "end": [183, 46], "kind": "commanddeclaration"}, {"full_name": "Set.Finset.coe_einfsep", "code": "theorem Finset.coe_einfsep [DecidableEq \u03b1] {s : Finset \u03b1} :\n    (s : Set \u03b1).einfsep = s.offDiag.inf (uncurry edist)", "start": [186, 1], "end": [188, 74], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.einfsep_exists_of_finite", "code": "theorem Nontrivial.einfsep_exists_of_finite [Finite s] (hs : s.Nontrivial) :\n    \u2203 (x : _) (_ : x \u2208 s) (y : _) (_ : y \u2208 s) (_hxy : x \u2260 y), s.einfsep = edist x y", "start": [191, 1], "end": [199, 57], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.einfsep_exists_of_nontrivial", "code": "theorem Finite.einfsep_exists_of_nontrivial (hsf : s.Finite) (hs : s.Nontrivial) :\n    \u2203 (x : _) (_ : x \u2208 s) (y : _) (_ : y \u2208 s) (_hxy : x \u2260 y), s.einfsep = edist x y", "start": [202, 1], "end": [205, 30], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_pair", "code": "theorem einfsep_pair (hxy : x \u2260 y) : ({x, y} : Set \u03b1).einfsep = edist x y", "start": [214, 1], "end": [217, 18], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_insert", "code": "theorem einfsep_insert : einfsep (insert x s) =\n    (\u2a05 (y \u2208 s) (_ : x \u2260 y), edist x y) \u2293 s.einfsep", "start": [220, 1], "end": [229, 53], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_triple", "code": "theorem einfsep_triple (hxy : x \u2260 y) (hyz : y \u2260 z) (hxz : x \u2260 z) :\n    einfsep ({x, y, z} : Set \u03b1) = edist x y \u2293 edist x z \u2293 edist y z", "start": [232, 1], "end": [235, 49], "kind": "commanddeclaration"}, {"full_name": "Set.le_einfsep_pi_of_le", "code": "theorem le_einfsep_pi_of_le {\u03c0 : \u03b2 \u2192 Type*} [Fintype \u03b2] [\u2200 b, PseudoEMetricSpace (\u03c0 b)]\n    {s : \u2200 b : \u03b2, Set (\u03c0 b)} {c : \u211d\u22650\u221e} (h : \u2200 b, c \u2264 einfsep (s b)) :\n    c \u2264 einfsep (Set.pi univ s)", "start": [238, 1], "end": [244, 89], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_of_einfsep_eq_top", "code": "theorem subsingleton_of_einfsep_eq_top (hs : s.einfsep = \u221e) : s.Subsingleton", "start": [253, 1], "end": [255, 83], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_eq_top_iff", "code": "theorem einfsep_eq_top_iff : s.einfsep = \u221e \u2194 s.Subsingleton", "start": [258, 1], "end": [259, 57], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.einfsep_ne_top", "code": "theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep \u2260 \u221e", "start": [262, 1], "end": [265, 42], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.einfsep_lt_top", "code": "theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < \u221e", "start": [268, 1], "end": [270, 26], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_lt_top_iff", "code": "theorem einfsep_lt_top_iff : s.einfsep < \u221e \u2194 s.Nontrivial", "start": [273, 1], "end": [274, 60], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_ne_top_iff", "code": "theorem einfsep_ne_top_iff : s.einfsep \u2260 \u221e \u2194 s.Nontrivial", "start": [277, 1], "end": [278, 60], "kind": "commanddeclaration"}, {"full_name": "Set.le_einfsep_of_forall_dist_le", "code": "theorem le_einfsep_of_forall_dist_le {d}\n    (h : \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s) (_hxy : x \u2260 y), d \u2264 dist x y) :\n    ENNReal.ofReal d \u2264 s.einfsep", "start": [281, 1], "end": [284, 101], "kind": "commanddeclaration"}, {"full_name": "Set.einfsep_pos_of_finite", "code": "theorem einfsep_pos_of_finite [Finite s] : 0 < s.einfsep", "start": [293, 1], "end": [299, 48], "kind": "commanddeclaration"}, {"full_name": "Set.relatively_discrete_of_finite", "code": "theorem relatively_discrete_of_finite [Finite s] :\n    \u2203 (C : _) (_hC : 0 < C), \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s) (_hxy : x \u2260 y), C \u2264 edist x y", "start": [302, 1], "end": [305, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.einfsep_pos", "code": "theorem Finite.einfsep_pos (hs : s.Finite) : 0 < s.einfsep", "start": [308, 1], "end": [310, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.relatively_discrete", "code": "theorem Finite.relatively_discrete (hs : s.Finite) :\n    \u2203 (C : _) (_hC : 0 < C), \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s) (_hxy : x \u2260 y), C \u2264 edist x y", "start": [313, 1], "end": [316, 32], "kind": "commanddeclaration"}, {"full_name": "Set.infsep", "code": "noncomputable def infsep [EDist \u03b1] (s : Set \u03b1) : \u211d :=\n  ENNReal.toReal s.einfsep", "start": [329, 1], "end": [331, 27], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_zero", "code": "theorem infsep_zero : s.infsep = 0 \u2194 s.einfsep = 0 \u2228 s.einfsep = \u221e", "start": [338, 1], "end": [339, 42], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_nonneg", "code": "theorem infsep_nonneg : 0 \u2264 s.infsep", "start": [342, 1], "end": [343, 24], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_pos", "code": "theorem infsep_pos : 0 < s.infsep \u2194 0 < s.einfsep \u2227 s.einfsep < \u221e", "start": [346, 1], "end": [347, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.infsep_zero", "code": "theorem Subsingleton.infsep_zero (hs : s.Subsingleton) : s.infsep = 0", "start": [350, 1], "end": [353, 19], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_of_infsep_pos", "code": "theorem nontrivial_of_infsep_pos (hs : 0 < s.infsep) : s.Nontrivial", "start": [356, 1], "end": [359, 37], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_empty", "code": "theorem infsep_empty : (\u2205 : Set \u03b1).infsep = 0", "start": [362, 1], "end": [363, 33], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_singleton", "code": "theorem infsep_singleton : ({x} : Set \u03b1).infsep = 0", "start": [366, 1], "end": [367, 37], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_pair_le_toReal_inf", "code": "theorem infsep_pair_le_toReal_inf (hxy : x \u2260 y) :\n    ({x, y} : Set \u03b1).infsep \u2264 (edist x y \u2293 edist y x).toReal", "start": [370, 1], "end": [373, 7], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_pair_eq_toReal", "code": "theorem infsep_pair_eq_toReal : ({x, y} : Set \u03b1).infsep = (edist x y).toReal", "start": [382, 1], "end": [386, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.le_infsep_iff", "code": "theorem Nontrivial.le_infsep_iff {d} (hs : s.Nontrivial) :\n    d \u2264 s.infsep \u2194 \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s) (_hxy : x \u2260 y), d \u2264 dist x y", "start": [395, 1], "end": [398, 46], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.infsep_lt_iff", "code": "theorem Nontrivial.infsep_lt_iff {d} (hs : s.Nontrivial) :\n    s.infsep < d \u2194 \u2203 (x : _) (_ : x \u2208 s) (y : _) (_ : y \u2208 s) (_hxy : x \u2260 y), dist x y < d", "start": [401, 1], "end": [405, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.le_infsep", "code": "theorem Nontrivial.le_infsep {d} (hs : s.Nontrivial)\n    (h : \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s) (_hxy : x \u2260 y), d \u2264 dist x y) : d \u2264 s.infsep", "start": [408, 1], "end": [410, 23], "kind": "commanddeclaration"}, {"full_name": "Set.le_edist_of_le_infsep", "code": "theorem le_edist_of_le_infsep {d x} (hx : x \u2208 s) {y} (hy : y \u2208 s) (hxy : x \u2260 y)\n    (hd : d \u2264 s.infsep) : d \u2264 dist x y", "start": [413, 1], "end": [419, 34], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_le_dist_of_mem", "code": "theorem infsep_le_dist_of_mem (hx : x \u2208 s) (hy : y \u2208 s) (hxy : x \u2260 y) : s.infsep \u2264 dist x y", "start": [422, 1], "end": [423, 41], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_le_of_mem_of_edist_le", "code": "theorem infsep_le_of_mem_of_edist_le {d x} (hx : x \u2208 s) {y} (hy : y \u2208 s) (hxy : x \u2260 y)\n    (hxy' : dist x y \u2264 d) : s.infsep \u2264 d", "start": [426, 1], "end": [428, 50], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_pair", "code": "theorem infsep_pair : ({x, y} : Set \u03b1).infsep = dist x y", "start": [431, 1], "end": [433, 42], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_triple", "code": "theorem infsep_triple (hxy : x \u2260 y) (hyz : y \u2260 z) (hxz : x \u2260 z) :\n    ({x, y, z} : Set \u03b1).infsep = dist x y \u2293 dist x z \u2293 dist y z", "start": [436, 1], "end": [440, 19], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.infsep_anti", "code": "theorem Nontrivial.infsep_anti (hs : s.Nontrivial) (hst : s \u2286 t) : t.infsep \u2264 s.infsep", "start": [443, 1], "end": [444, 59], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_eq_iInf", "code": "theorem infsep_eq_iInf [Decidable s.Nontrivial] :\n    s.infsep = if s.Nontrivial then \u2a05 d : s.offDiag, (uncurry dist) (d : \u03b1 \u00d7 \u03b1) else 0", "start": [447, 1], "end": [458, 49], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.infsep_eq_iInf", "code": "theorem Nontrivial.infsep_eq_iInf (hs : s.Nontrivial) :\n    s.infsep = \u2a05 d : s.offDiag, (uncurry dist) (d : \u03b1 \u00d7 \u03b1)", "start": [461, 1], "end": [463, 47], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_of_fintype", "code": "theorem infsep_of_fintype [Decidable s.Nontrivial] [DecidableEq \u03b1] [Fintype s] : s.infsep =\n    if hs : s.Nontrivial then s.offDiag.toFinset.inf' (by simpa) (uncurry dist) else 0", "start": [466, 1], "end": [473, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.infsep_of_fintype", "code": "theorem Nontrivial.infsep_of_fintype [DecidableEq \u03b1] [Fintype s] (hs : s.Nontrivial) :\n    s.infsep = s.offDiag.toFinset.inf' (by simpa) (uncurry dist)", "start": [476, 1], "end": [478, 51], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.infsep", "code": "theorem Finite.infsep [Decidable s.Nontrivial] (hsf : s.Finite) :\n    s.infsep =\n      if hs : s.Nontrivial then hsf.offDiag.toFinset.inf' (by simpa) (uncurry dist) else 0", "start": [481, 1], "end": [489, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.infsep_of_nontrivial", "code": "theorem Finite.infsep_of_nontrivial (hsf : s.Finite) (hs : s.Nontrivial) :\n    s.infsep = hsf.offDiag.toFinset.inf' (by simpa) (uncurry dist)", "start": [492, 1], "end": [494, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_infsep", "code": "theorem _root_.Finset.coe_infsep [DecidableEq \u03b1] (s : Finset \u03b1) : (s : Set \u03b1).infsep =\n    if hs : s.offDiag.Nonempty then s.offDiag.inf' hs (uncurry dist) else 0", "start": [497, 1], "end": [503, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_infsep_of_offDiag_nonempty", "code": "theorem _root_.Finset.coe_infsep_of_offDiag_nonempty [DecidableEq \u03b1] {s : Finset \u03b1}\n    (hs : s.offDiag.Nonempty) : (s : Set \u03b1).infsep = s.offDiag.inf' hs (uncurry dist)", "start": [506, 1], "end": [508, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_infsep_of_offDiag_empty", "code": "theorem _root_.Finset.coe_infsep_of_offDiag_empty\n    [DecidableEq \u03b1] {s : Finset \u03b1} (hs : s.offDiag = \u2205) : (s : Set \u03b1).infsep = 0", "start": [511, 1], "end": [514, 37], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.infsep_exists_of_finite", "code": "theorem Nontrivial.infsep_exists_of_finite [Finite s] (hs : s.Nontrivial) :\n    \u2203 (x : _) (_ : x \u2208 s) (y : _) (_ : y \u2208 s) (_hxy : x \u2260 y), s.infsep = dist x y", "start": [517, 1], "end": [525, 55], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.infsep_exists_of_nontrivial", "code": "theorem Finite.infsep_exists_of_nontrivial (hsf : s.Finite) (hs : s.Nontrivial) :\n    \u2203 (x : _) (_ : x \u2208 s) (y : _) (_ : y \u2208 s) (_hxy : x \u2260 y), s.infsep = dist x y", "start": [528, 1], "end": [531, 29], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_zero_iff_subsingleton_of_finite", "code": "theorem infsep_zero_iff_subsingleton_of_finite [Finite s] : s.infsep = 0 \u2194 s.Subsingleton", "start": [540, 1], "end": [542, 52], "kind": "commanddeclaration"}, {"full_name": "Set.infsep_pos_iff_nontrivial_of_finite", "code": "theorem infsep_pos_iff_nontrivial_of_finite [Finite s] : 0 < s.infsep \u2194 s.Nontrivial", "start": [545, 1], "end": [547, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.infsep_zero_iff_subsingleton", "code": "theorem Finite.infsep_zero_iff_subsingleton (hs : s.Finite) : s.infsep = 0 \u2194 s.Subsingleton", "start": [550, 1], "end": [552, 41], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.infsep_pos_iff_nontrivial", "code": "theorem Finite.infsep_pos_iff_nontrivial (hs : s.Finite) : 0 < s.infsep \u2194 s.Nontrivial", "start": [555, 1], "end": [557, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.infsep_zero_iff_subsingleton", "code": "theorem _root_.Finset.infsep_zero_iff_subsingleton (s : Finset \u03b1) :\n    (s : Set \u03b1).infsep = 0 \u2194 (s : Set \u03b1).Subsingleton", "start": [560, 1], "end": [562, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.infsep_pos_iff_nontrivial", "code": "theorem _root_.Finset.infsep_pos_iff_nontrivial (s : Finset \u03b1) :\n    0 < (s : Set \u03b1).infsep \u2194 (s : Set \u03b1).Nontrivial", "start": [565, 1], "end": [567, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monad/Monadicity.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Equalizers.lean", "Mathlib/CategoryTheory/Monad/Coequalizer.lean", "Mathlib/CategoryTheory/Monad/Limits.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Monad.MonadicityInternal.main_pair_reflexive", "code": "instance main_pair_reflexive (A : (adj).toMonad.Algebra) :\n    IsReflexivePair ((F).map A.a) ((adj).counit.app ((F).obj A.A)) := by\n  apply IsReflexivePair.mk' ((F).map ((adj).unit.app _)) _ _\n  \u00b7 rw [\u2190 (F).map_comp, \u2190 (F).map_id]\n    exact congr_arg (F).map A.unit\n  \u00b7 rw [(adj).left_triangle_components]\n    rfl", "start": [66, 1], "end": [76, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.MonadicityInternal.main_pair_G_split", "code": "instance main_pair_G_split (A : (adj).toMonad.Algebra) :\n    G.IsSplitPair ((F).map A.a)\n      ((adj).counit.app ((F).obj A.A)) where\n  splittable := \u27e8_, _, \u27e8beckSplitCoequalizer A\u27e9\u27e9", "start": [79, 1], "end": [86, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.MonadicityInternal.comparisonLeftAdjointObj", "code": "def comparisonLeftAdjointObj (A : (adj).toMonad.Algebra)\n    [HasCoequalizer ((F).map A.a) ((adj).counit.app _)] : D :=\n  coequalizer ((F).map A.a) ((adj).counit.app _)", "start": [90, 1], "end": [93, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.MonadicityInternal.comparisonLeftAdjointHomEquiv", "code": "@[simps!]\ndef comparisonLeftAdjointHomEquiv (A : (adj).toMonad.Algebra) (B : D)\n    [HasCoequalizer ((F).map A.a) ((adj).counit.app ((F).obj A.A))] :\n    (comparisonLeftAdjointObj A \u27f6 B) \u2243 (A \u27f6 (comparison adj).obj B) :=\n  calc\n    (comparisonLeftAdjointObj A \u27f6 B) \u2243 { f : (F).obj A.A \u27f6 B // _ } :=\n      Cofork.IsColimit.homIso (colimit.isColimit _) B\n    _ \u2243 { g : A.A \u27f6 G.obj B // G.map ((F).map g) \u226b G.map ((adj).counit.app B) = A.a \u226b g } := by\n      refine' ((adj).homEquiv _ _).subtypeEquiv _\n      intro f\n      rw [\u2190 ((adj).homEquiv _ _).injective.eq_iff, Adjunction.homEquiv_naturality_left,\n        (adj).homEquiv_unit, (adj).homEquiv_unit, G.map_comp]\n      dsimp\n      rw [(adj).right_triangle_components_assoc, \u2190 G.map_comp, (F).map_comp, Category.assoc,\n        (adj).counit_naturality, (adj).left_triangle_components_assoc]\n      apply eq_comm\n    _ \u2243 (A \u27f6 (comparison adj).obj B) :=\n      { toFun := fun g =>\n          { f := _\n            h := g.prop }\n        invFun := fun f => \u27e8f.f, f.h\u27e9\n        left_inv := fun g => by ext; rfl\n        right_inv := fun f => by ext; rfl }", "start": [96, 1], "end": [122, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.MonadicityInternal.leftAdjointComparison", "code": "def leftAdjointComparison\n    [\u2200 A : (adj).toMonad.Algebra, HasCoequalizer ((F).map A.a)\n      ((adj).counit.app ((F).obj A.A))] :\n    (adj).toMonad.Algebra \u2964 D := by\n  refine'\n    Adjunction.leftAdjointOfEquiv (G := comparison adj)\n      (F_obj := fun A => comparisonLeftAdjointObj A) (fun A B => _) _\n  \u00b7 apply comparisonLeftAdjointHomEquiv\n  \u00b7 intro A B B' g h\n    ext1\n    simp [Cofork.IsColimit.homIso]", "start": [125, 1], "end": [141, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction", "code": "@[simps! counit]\ndef comparisonAdjunction\n    [\u2200 A : (adj).toMonad.Algebra, HasCoequalizer ((F).map A.a)\n      ((adj).counit.app ((F).obj A.A))] :\n    leftAdjointComparison \u22a3 comparison (adj) :=\n  Adjunction.adjunctionOfEquivLeft _ _", "start": [144, 1], "end": [151, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction_unit_f_aux", "code": "theorem comparisonAdjunction_unit_f_aux\n    [\u2200 A : (adj).toMonad.Algebra, HasCoequalizer ((F).map A.a)\n      ((adj).counit.app ((F).obj A.A))]\n    (A : (adj).toMonad.Algebra) :\n    (comparisonAdjunction.unit.app A).f =\n      (adj).homEquiv A.A _\n        (coequalizer.\u03c0 ((F).map A.a) ((adj).counit.app ((F).obj A.A)))", "start": [154, 1], "end": [161, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.MonadicityInternal.unitCofork", "code": "@[simps! pt]\ndef unitCofork (A : (adj).toMonad.Algebra)\n    [HasCoequalizer ((F).map A.a) ((adj).counit.app ((F).obj A.A))] :\n    Cofork (G.map ((F).map A.a)) (G.map ((adj).counit.app ((F).obj A.A))) :=\n  Cofork.of\u03c0 (G.map (coequalizer.\u03c0 ((F).map A.a) ((adj).counit.app ((F).obj A.A))))\n    (by\n      change _ = G.map _ \u226b _\n      rw [\u2190 G.map_comp, coequalizer.condition, G.map_comp])", "start": [164, 1], "end": [174, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.MonadicityInternal.unitCofork_\u03c0", "code": "@[simp]\ntheorem unitCofork_\u03c0 (A : (adj).toMonad.Algebra)\n    [HasCoequalizer ((F).map A.a) ((adj).counit.app ((F).obj A.A))] :\n    (unitCofork A).\u03c0 = G.map (coequalizer.\u03c0 ((F).map A.a) ((adj).counit.app ((F).obj A.A)))", "start": [177, 1], "end": [181, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction_unit_f", "code": "theorem comparisonAdjunction_unit_f\n    [\u2200 A : (adj).toMonad.Algebra, HasCoequalizer ((F).map A.a)\n      ((adj).counit.app ((F).obj A.A))]\n    (A : (adj).toMonad.Algebra) :\n    (comparisonAdjunction.unit.app A).f = (beckCoequalizer A).desc (unitCofork A)", "start": [184, 1], "end": [194, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.MonadicityInternal.counitCofork", "code": "@[simps!]\ndef counitCofork (B : D) :\n    Cofork ((F).map (G.map ((adj).counit.app B)))\n      ((adj).counit.app ((F).obj (G.obj B))) :=\n  Cofork.of\u03c0 ((adj).counit.app B) ((adj).counit_naturality _)", "start": [197, 1], "end": [204, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.MonadicityInternal.unitColimitOfPreservesCoequalizer", "code": "def unitColimitOfPreservesCoequalizer (A : (adj).toMonad.Algebra)\n    [HasCoequalizer ((F).map A.a) ((adj).counit.app ((F).obj A.A))]\n    [PreservesColimit (parallelPair ((F).map A.a) ((adj).counit.app ((F).obj A.A))) G] :\n    IsColimit (unitCofork (G := G) A) :=\n  isColimitOfHasCoequalizerOfPreservesColimit G _ _", "start": [207, 1], "end": [212, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.MonadicityInternal.counitCoequalizerOfReflectsCoequalizer", "code": "def counitCoequalizerOfReflectsCoequalizer (B : D)\n    [ReflectsColimit (parallelPair ((F).map (G.map ((adj).counit.app B)))\n      ((adj).counit.app ((F).obj (G.obj B)))) G] :\n    IsColimit (counitCofork (G := G) B) :=\n  isColimitOfIsColimitCoforkMap G _ (beckCoequalizer ((comparison adj).obj B))", "start": [215, 1], "end": [220, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction_counit_app", "code": "theorem comparisonAdjunction_counit_app\n    [\u2200 A : (adj).toMonad.Algebra, HasCoequalizer ((F).map A.a) ((adj).counit.app ((F).obj A.A))]\n    (B : D) : (comparisonAdjunction (G := G)).counit.app B = colimit.desc _ (counitCofork B)", "start": [233, 1], "end": [240, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.createsGSplitCoequalizersOfMonadic", "code": "def createsGSplitCoequalizersOfMonadic [MonadicRightAdjoint G] \u2983A B\u2984 (f g : A \u27f6 B)\n    [G.IsSplitPair f g] : CreatesColimit (parallelPair f g) G := by\n  apply (config := {allowSynthFailures := true}) monadicCreatesColimitOfPreservesColimit\n    \u00b7 apply @preservesColimitOfIsoDiagram _ _ _ _ _ _ _ _ _ (diagramIsoParallelPair.{v\u2081} _).symm ?_\n    dsimp\n    infer_instance\n  \u00b7 apply @preservesColimitOfIsoDiagram _ _ _ _ _ _ _ _ _ (diagramIsoParallelPair.{v\u2081} _).symm ?_\n    dsimp\n    infer_instance", "start": [251, 1], "end": [264, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.HasCoequalizerOfIsSplitPair", "code": "class HasCoequalizerOfIsSplitPair (G : D \u2964 C) : Prop where\n  out : \u2200 {A B} (f g : A \u27f6 B) [G.IsSplitPair f g], HasCoequalizer f g", "start": [279, 1], "end": [280, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.PreservesColimitOfIsSplitPair", "code": "class PreservesColimitOfIsSplitPair (G : D \u2964 C) where\n  out : \u2200 {A B} (f g : A \u27f6 B) [G.IsSplitPair f g], PreservesColimit (parallelPair f g) G", "start": [293, 1], "end": [294, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.ReflectsColimitOfIsSplitPair", "code": "class ReflectsColimitOfIsSplitPair (G : D \u2964 C) where\n  out : \u2200 {A B} (f g : A \u27f6 B) [G.IsSplitPair f g], ReflectsColimit (parallelPair f g) G", "start": [306, 1], "end": [307, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.monadicOfHasPreservesReflectsGSplitCoequalizers", "code": "def monadicOfHasPreservesReflectsGSplitCoequalizers [HasCoequalizerOfIsSplitPair G]\n    [PreservesColimitOfIsSplitPair G] [ReflectsColimitOfIsSplitPair G] : MonadicRightAdjoint G := by\n  let i : IsRightAdjoint (comparison (ofRightAdjoint G)) := \u27e8_, comparisonAdjunction\u27e9\n  constructor\n  let _ : \u2200 X : (ofRightAdjoint G).toMonad.Algebra,\n      IsIso ((ofRightAdjoint (comparison (ofRightAdjoint G))).unit.app X) := by\n    intro X\n    apply @isIso_of_reflects_iso _ _ _ _ _ _ _ (Monad.forget (ofRightAdjoint G).toMonad) ?_ _\n    \u00b7 change IsIso (comparisonAdjunction.unit.app X).f\n      rw [comparisonAdjunction_unit_f]\n      change\n        IsIso\n          (IsColimit.coconePointUniqueUpToIso (beckCoequalizer X)\n              (unitColimitOfPreservesCoequalizer X)).hom\n      refine' IsIso.of_iso (IsColimit.coconePointUniqueUpToIso _ _)\n  let _ : \u2200 Y : D, IsIso ((ofRightAdjoint (comparison (ofRightAdjoint G))).counit.app Y) := by\n    intro Y\n    change IsIso (comparisonAdjunction.counit.app Y)\n    rw [comparisonAdjunction_counit_app]\n    change IsIso (IsColimit.coconePointUniqueUpToIso _ ?_).hom\n    infer_instance\n    apply @counitCoequalizerOfReflectsCoequalizer _ _ _ _ _ _ _ ?_\n    letI _ :\n      G.IsSplitPair ((leftAdjoint G).map (G.map ((Adjunction.ofRightAdjoint G).counit.app Y)))\n        ((Adjunction.ofRightAdjoint G).counit.app ((leftAdjoint G).obj (G.obj Y))) :=\n      MonadicityInternal.main_pair_G_split ((comparison (Adjunction.ofRightAdjoint G)).obj Y)\n    infer_instance\n  exact Adjunction.isRightAdjointToIsEquivalence", "start": [317, 1], "end": [350, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.CreatesColimitOfIsSplitPair", "code": "class CreatesColimitOfIsSplitPair (G : D \u2964 C) where\n  out : \u2200 {A B} (f g : A \u27f6 B) [G.IsSplitPair f g], CreatesColimit (parallelPair f g) G", "start": [356, 1], "end": [357, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.monadicOfCreatesGSplitCoequalizers", "code": "def monadicOfCreatesGSplitCoequalizers [CreatesColimitOfIsSplitPair G] :\n    MonadicRightAdjoint G := by\n  let I {A B} (f g : A \u27f6 B) [G.IsSplitPair f g] : HasColimit (parallelPair f g \u22d9 G) := by\n    apply @hasColimitOfIso _ _ _ _ _ _ ?_ (diagramIsoParallelPair.{v\u2081} _)\n    exact inferInstanceAs <| HasCoequalizer (G.map f) (G.map g)\n  apply @monadicOfHasPreservesReflectsGSplitCoequalizers _ _ _ _ _ _ ?_ ?_ ?_\n  \u00b7 constructor\n    intros\n    apply hasColimit_of_created (parallelPair _ _) G\n  \u00b7 constructor\n    intros\n    infer_instance\n  \u00b7 constructor\n    intros\n    infer_instance", "start": [367, 1], "end": [386, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.monadicOfHasPreservesGSplitCoequalizersOfReflectsIsomorphisms", "code": "def monadicOfHasPreservesGSplitCoequalizersOfReflectsIsomorphisms [ReflectsIsomorphisms G]\n    [HasCoequalizerOfIsSplitPair G] [PreservesColimitOfIsSplitPair G] :\n    MonadicRightAdjoint G := by\n  apply (config := {allowSynthFailures := true}) @monadicOfHasPreservesReflectsGSplitCoequalizers\n  constructor\n  intro _ _ f g _\n  have := HasCoequalizerOfIsSplitPair.out G f g\n  apply reflectsColimitOfReflectsIsomorphisms", "start": [390, 1], "end": [400, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.PreservesColimitOfIsReflexivePair", "code": "class PreservesColimitOfIsReflexivePair (G : C \u2964 D) where\n  out : \u2200 \u2983A B\u2984 (f g : A \u27f6 B) [IsReflexivePair f g], PreservesColimit (parallelPair f g) G", "start": [416, 1], "end": [417, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.monadicOfHasPreservesReflexiveCoequalizersOfReflectsIsomorphisms", "code": "def monadicOfHasPreservesReflexiveCoequalizersOfReflectsIsomorphisms : MonadicRightAdjoint G := by\n  letI i : IsRightAdjoint (comparison (Adjunction.ofRightAdjoint G)) :=\n    \u27e8_, comparisonAdjunction\u27e9\n  constructor\n  let _ : \u2200 X : (Adjunction.ofRightAdjoint G).toMonad.Algebra,\n      IsIso ((Adjunction.ofRightAdjoint\n                (comparison (Adjunction.ofRightAdjoint G))).unit.app X) := by\n    intro X\n    apply\n      @isIso_of_reflects_iso _ _ _ _ _ _ _ (Monad.forget (Adjunction.ofRightAdjoint G).toMonad) ?_ _\n    \u00b7 change IsIso (comparisonAdjunction.unit.app X).f\n      rw [comparisonAdjunction_unit_f]\n      change\n        IsIso\n          (IsColimit.coconePointUniqueUpToIso (beckCoequalizer X)\n              (unitColimitOfPreservesCoequalizer X)).hom\n      apply IsIso.of_iso (IsColimit.coconePointUniqueUpToIso _ _)\n  let _ : \u2200 Y : D,\n      IsIso ((ofRightAdjoint (comparison (Adjunction.ofRightAdjoint G))).counit.app Y) := by\n    intro Y\n    change IsIso (comparisonAdjunction.counit.app Y)\n    rw [comparisonAdjunction_counit_app]\n    change IsIso (IsColimit.coconePointUniqueUpToIso _ ?_).hom\n    infer_instance\n    apply @counitCoequalizerOfReflectsCoequalizer _ _ _ _ _ _ _ ?_\n    apply reflectsColimitOfReflectsIsomorphisms\n  exact Adjunction.isRightAdjointToIsEquivalence", "start": [429, 1], "end": [460, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/Floor.lean", "imports": ["Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.measurable_floor", "code": "theorem Int.measurable_floor [OpensMeasurableSpace R] : Measurable (Int.floor : R \u2192 \u2124)", "start": [25, 1], "end": [27, 70], "kind": "commanddeclaration"}, {"full_name": "Measurable.floor", "code": "@[measurability]\ntheorem Measurable.floor [OpensMeasurableSpace R] {f : \u03b1 \u2192 R} (hf : Measurable f) :\n    Measurable fun x => \u230af x\u230b", "start": [30, 1], "end": [33, 31], "kind": "commanddeclaration"}, {"full_name": "Int.measurable_ceil", "code": "theorem Int.measurable_ceil [OpensMeasurableSpace R] : Measurable (Int.ceil : R \u2192 \u2124)", "start": [36, 1], "end": [38, 69], "kind": "commanddeclaration"}, {"full_name": "Measurable.ceil", "code": "@[measurability]\ntheorem Measurable.ceil [OpensMeasurableSpace R] {f : \u03b1 \u2192 R} (hf : Measurable f) :\n    Measurable fun x => \u2308f x\u2309", "start": [41, 1], "end": [44, 30], "kind": "commanddeclaration"}, {"full_name": "measurable_fract", "code": "theorem measurable_fract [BorelSpace R] : Measurable (Int.fract : R \u2192 R)", "start": [47, 1], "end": [50, 93], "kind": "commanddeclaration"}, {"full_name": "Measurable.fract", "code": "@[measurability]\ntheorem Measurable.fract [BorelSpace R] {f : \u03b1 \u2192 R} (hf : Measurable f) :\n    Measurable fun x => Int.fract (f x)", "start": [53, 1], "end": [56, 27], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.image_fract", "code": "theorem MeasurableSet.image_fract [BorelSpace R] {s : Set R} (hs : MeasurableSet s) :\n    MeasurableSet (Int.fract '' s)", "start": [59, 1], "end": [62, 90], "kind": "commanddeclaration"}, {"full_name": "Nat.measurable_floor", "code": "theorem Nat.measurable_floor : Measurable (Nat.floor : R \u2192 \u2115)", "start": [72, 1], "end": [74, 100], "kind": "commanddeclaration"}, {"full_name": "Measurable.nat_floor", "code": "@[measurability]\ntheorem Measurable.nat_floor (hf : Measurable f) : Measurable fun x => \u230af x\u230b\u208a", "start": [77, 1], "end": [79, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.measurable_ceil", "code": "theorem Nat.measurable_ceil : Measurable (Nat.ceil : R \u2192 \u2115)", "start": [82, 1], "end": [84, 98], "kind": "commanddeclaration"}, {"full_name": "Measurable.nat_ceil", "code": "@[measurability]\ntheorem Measurable.nat_ceil (hf : Measurable f) : Measurable fun x => \u2308f x\u2309\u208a", "start": [87, 1], "end": [89, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/SpecialFunctions/Inner.lean", "imports": ["Mathlib/Analysis/InnerProductSpace/Basic.lean", "Mathlib/MeasureTheory/Constructions/BorelSpace/Complex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Measurable.inner", "code": "@[aesop safe 20 apply (rule_sets [Measurable])]\ntheorem Measurable.inner {_ : MeasurableSpace \u03b1} [MeasurableSpace E] [OpensMeasurableSpace E]\n    [TopologicalSpace.SecondCountableTopology E] {f g : \u03b1 \u2192 E} (hf : Measurable f)\n    (hg : Measurable g) : Measurable fun t => \u27eaf t, g t\u27eb", "start": [22, 1], "end": [26, 48], "kind": "commanddeclaration"}, {"full_name": "Measurable.const_inner", "code": "@[measurability]\ntheorem Measurable.const_inner {_ : MeasurableSpace \u03b1} [MeasurableSpace E] [OpensMeasurableSpace E]\n    [TopologicalSpace.SecondCountableTopology E] {c : E} {f : \u03b1 \u2192 E} (hf : Measurable f) :\n    Measurable fun t => \u27eac, f t\u27eb", "start": [29, 1], "end": [33, 39], "kind": "commanddeclaration"}, {"full_name": "Measurable.inner_const", "code": "@[measurability]\ntheorem Measurable.inner_const {_ : MeasurableSpace \u03b1} [MeasurableSpace E] [OpensMeasurableSpace E]\n    [TopologicalSpace.SecondCountableTopology E] {c : E} {f : \u03b1 \u2192 E} (hf : Measurable f) :\n    Measurable fun t => \u27eaf t, c\u27eb", "start": [35, 1], "end": [39, 39], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.inner", "code": "@[aesop safe 20 apply (rule_sets [Measurable])]\ntheorem AEMeasurable.inner {m : MeasurableSpace \u03b1} [MeasurableSpace E] [OpensMeasurableSpace E]\n    [TopologicalSpace.SecondCountableTopology E] {\u03bc : MeasureTheory.Measure \u03b1} {f g : \u03b1 \u2192 E}\n    (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) : AEMeasurable (fun x => \u27eaf x, g x\u27eb) \u03bc", "start": [41, 1], "end": [48, 8], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.const_inner", "code": "@[measurability]\ntheorem AEMeasurable.const_inner {m : MeasurableSpace \u03b1} [MeasurableSpace E]\n    [OpensMeasurableSpace E] [TopologicalSpace.SecondCountableTopology E]\n    {\u03bc : MeasureTheory.Measure \u03b1} {f : \u03b1 \u2192 E} {c : E} (hf : AEMeasurable f \u03bc) :\n    AEMeasurable (fun x => \u27eac, f x\u27eb) \u03bc", "start": [52, 1], "end": [57, 43], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.inner_const", "code": "@[measurability]\ntheorem AEMeasurable.inner_const {m : MeasurableSpace \u03b1} [MeasurableSpace E]\n    [OpensMeasurableSpace E] [TopologicalSpace.SecondCountableTopology E]\n    {\u03bc : MeasureTheory.Measure \u03b1} {f : \u03b1 \u2192 E} {c : E} (hf : AEMeasurable f \u03bc) :\n    AEMeasurable (fun x => \u27eaf x, c\u27eb) \u03bc", "start": [60, 1], "end": [65, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Chebyshev.lean", "imports": ["Mathlib/Data/Polynomial/AlgebraMap.lean", "Mathlib/Data/Complex/Exponential.lean", "Mathlib/RingTheory/Polynomial/Chebyshev.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Complex/Module.lean"], "premises": [{"full_name": "Polynomial.Chebyshev.aeval_T", "code": "@[simp]\ntheorem aeval_T (x : A) (n : \u2115) : aeval x (T R n) = (T A n).eval x", "start": [28, 1], "end": [30, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.aeval_U", "code": "@[simp]\ntheorem aeval_U (x : A) (n : \u2115) : aeval x (U R n) = (U A n).eval x", "start": [33, 1], "end": [35, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.algebraMap_eval_T", "code": "@[simp]\ntheorem algebraMap_eval_T (x : R) (n : \u2115) :\n    algebraMap R A ((T R n).eval x) = (T A n).eval (algebraMap R A x)", "start": [38, 1], "end": [41, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.algebraMap_eval_U", "code": "@[simp]\ntheorem algebraMap_eval_U (x : R) (n : \u2115) :\n    algebraMap R A ((U R n).eval x) = (U A n).eval (algebraMap R A x)", "start": [44, 1], "end": [47, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.complex_ofReal_eval_T", "code": "@[simp, norm_cast]\ntheorem complex_ofReal_eval_T : \u2200 (x : \u211d) n, (((T \u211d n).eval x : \u211d) : \u2102) = (T \u2102 n).eval (x : \u2102)", "start": [51, 1], "end": [53, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.complex_ofReal_eval_U", "code": "@[simp, norm_cast]\ntheorem complex_ofReal_eval_U : \u2200 (x : \u211d) n, (((U \u211d n).eval x : \u211d) : \u2102) = (U \u2102 n).eval (x : \u2102)", "start": [57, 1], "end": [59, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.T_complex_cos", "code": "@[simp]\ntheorem T_complex_cos : \u2200 n, (T \u2102 n).eval (cos \u03b8) = cos (n * \u03b8)", "start": [71, 1], "end": [85, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.U_complex_cos", "code": "@[simp]\ntheorem U_complex_cos (n : \u2115) : (U \u2102 n).eval (cos \u03b8) * sin \u03b8 = sin ((n + 1) * \u03b8)", "start": [88, 1], "end": [101, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.T_real_cos", "code": "@[simp]\ntheorem T_real_cos : (T \u211d n).eval (cos \u03b8) = cos (n * \u03b8)", "start": [113, 1], "end": [116, 95], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.U_real_cos", "code": "@[simp]\ntheorem U_real_cos : (U \u211d n).eval (cos \u03b8) * sin \u03b8 = sin ((n + 1) * \u03b8)", "start": [119, 1], "end": [123, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/MonoCoprod.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "Mathlib/CategoryTheory/Limits/Shapes/RegularMono.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.MonoCoprod", "code": "class MonoCoprod : Prop where\n  \n  binaryCofan_inl : \u2200 \u2983A B : C\u2984 (c : BinaryCofan A B) (_ : IsColimit c), Mono c.inl", "start": [41, 1], "end": [44, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.monoCoprodOfHasZeroMorphisms", "code": "instance (priority := 100) monoCoprodOfHasZeroMorphisms [HasZeroMorphisms C] : MonoCoprod C :=\n  \u27e8fun A B c hc => by\n    haveI : IsSplitMono c.inl :=\n      IsSplitMono.mk' (SplitMono.mk (hc.desc (BinaryCofan.mk (\ud835\udfd9 A) 0)) (IsColimit.fac _ _ _))\n    infer_instance\u27e9", "start": [49, 1], "end": [53, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MonoCoprod.binaryCofan_inr", "code": "theorem binaryCofan_inr {A B : C} [MonoCoprod C] (c : BinaryCofan A B) (hc : IsColimit c) :\n    Mono c.inr", "start": [58, 1], "end": [64, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MonoCoprod.mono_inl_iff", "code": "theorem mono_inl_iff {A B : C} {c\u2081 c\u2082 : BinaryCofan A B} (hc\u2081 : IsColimit c\u2081) (hc\u2082 : IsColimit c\u2082) :\n    Mono c\u2081.inl \u2194 Mono c\u2082.inl", "start": [73, 1], "end": [82, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MonoCoprod.mk'", "code": "theorem mk' (h : \u2200 A B : C, \u2203 (c : BinaryCofan A B) (_ : IsColimit c), Mono c.inl) : MonoCoprod C", "start": [85, 1], "end": [88, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.MonoCoprod.monoCoprodType", "code": "instance monoCoprodType : MonoCoprod (Type u) :=\n  MonoCoprod.mk' fun A B => by\n    refine' \u27e8BinaryCofan.mk (Sum.inl : A \u27f6 Sum A B) Sum.inr, _, _\u27e9\n    \u00b7 exact BinaryCofan.IsColimit.mk _\n        (fun f\u2081 f\u2082 x => by\n          rcases x with x | x\n          exacts [f\u2081 x, f\u2082 x])\n        (fun f\u2081 f\u2082 => by rfl)\n        (fun f\u2081 f\u2082 => by rfl)\n        (fun f\u2081 f\u2082 m h\u2081 h\u2082 => by\n          funext x\n          rcases x with x | x\n          \u00b7 exact congr_fun h\u2081 x\n          \u00b7 exact congr_fun h\u2082 x)\n    \u00b7 rw [mono_iff_injective]\n      intro a\u2081 a\u2082 h\n      simpa using h", "start": [91, 1], "end": [107, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rbmap/Default.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Analysis/Calculus/Conformal/InnerProduct.lean", "imports": ["Mathlib/Analysis/InnerProductSpace/ConformalLinearMap.lean", "Mathlib/Analysis/Calculus/Conformal/NormedSpace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "conformalAt_iff'", "code": "theorem conformalAt_iff' {f : E \u2192 F} {x : E} :\n    ConformalAt f x \u2194 \u2203 c : \u211d, 0 < c \u2227 \u2200 u v : E, \u27eafderiv \u211d f x u, fderiv \u211d f x v\u27eb = c * \u27eau, v\u27eb", "start": [29, 1], "end": [33, 68], "kind": "commanddeclaration"}, {"full_name": "conformalAt_iff", "code": "theorem conformalAt_iff {f : E \u2192 F} {x : E} {f' : E \u2192L[\u211d] F} (h : HasFDerivAt f f' x) :\n    ConformalAt f x \u2194 \u2203 c : \u211d, 0 < c \u2227 \u2200 u v : E, \u27eaf' u, f' v\u27eb = c * \u27eau, v\u27eb", "start": [36, 1], "end": [40, 41], "kind": "commanddeclaration"}, {"full_name": "conformalFactorAt", "code": "def conformalFactorAt {f : E \u2192 F} {x : E} (h : ConformalAt f x) : \u211d :=\n  Classical.choose (conformalAt_iff'.mp h)", "start": [43, 1], "end": [46, 43], "kind": "commanddeclaration"}, {"full_name": "conformalFactorAt_pos", "code": "theorem conformalFactorAt_pos {f : E \u2192 F} {x : E} (h : ConformalAt f x) : 0 < conformalFactorAt h", "start": [49, 1], "end": [50, 53], "kind": "commanddeclaration"}, {"full_name": "conformalFactorAt_inner_eq_mul_inner'", "code": "theorem conformalFactorAt_inner_eq_mul_inner' {f : E \u2192 F} {x : E} (h : ConformalAt f x) (u v : E) :\n    \u27ea(fderiv \u211d f x) u, (fderiv \u211d f x) v\u27eb = (conformalFactorAt h : \u211d) * \u27eau, v\u27eb", "start": [53, 1], "end": [55, 57], "kind": "commanddeclaration"}, {"full_name": "conformalFactorAt_inner_eq_mul_inner", "code": "theorem conformalFactorAt_inner_eq_mul_inner {f : E \u2192 F} {x : E} {f' : E \u2192L[\u211d] F}\n    (h : HasFDerivAt f f' x) (H : ConformalAt f x) (u v : E) :\n    \u27eaf' u, f' v\u27eb = (conformalFactorAt H : \u211d) * \u27eau, v\u27eb", "start": [58, 1], "end": [61, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Computability/ContextFreeGrammar.lean", "imports": ["Mathlib/Computability/Language.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContextFreeRule", "code": "structure ContextFreeRule (T : Type uT) (N : Type uN) where\n  \n  input : N\n  \n  output : List (Symbol T N)", "start": [20, 1], "end": [25, 29], "kind": "commanddeclaration"}, {"full_name": "ContextFreeGrammar", "code": "structure ContextFreeGrammar.{uN,uT} (T : Type uT) where\n  \n  NT : Type uN\n  \n  initial : NT\n  \n  rules : List (ContextFreeRule T NT)", "start": [27, 1], "end": [34, 38], "kind": "commanddeclaration"}, {"full_name": "ContextFreeRule.Rewrites", "code": "inductive Rewrites (r : ContextFreeRule T N) : List (Symbol T N) \u2192 List (Symbol T N) \u2192 Prop\n  \n  | head (s : List (Symbol T N)) :\n      r.Rewrites (Symbol.nonterminal r.input :: s) (r.output ++ s)\n  \n  | cons (x : Symbol T N) {s\u2081 s\u2082 : List (Symbol T N)} (hrs : Rewrites r s\u2081 s\u2082) :\n      r.Rewrites (x :: s\u2081) (x :: s\u2082)", "start": [42, 1], "end": [50, 37], "kind": "commanddeclaration"}, {"full_name": "ContextFreeRule.Rewrites.exists_parts", "code": "lemma Rewrites.exists_parts {r : ContextFreeRule T N} {u v : List (Symbol T N)}\n    (hyp : r.Rewrites u v) :\n    \u2203 p : List (Symbol T N), \u2203 q : List (Symbol T N),\n      u = p ++ [Symbol.nonterminal r.input] ++ q \u2227 v = p ++ r.output ++ q := by\n  induction hyp with\n  | head xs =>\n    use [], xs\n    simp\n  | cons x _ ih =>\n    rcases ih with \u27e8p', q', rfl, rfl\u27e9\n    use x :: p', q'\n    simp", "start": [52, 1], "end": [63, 9], "kind": "mathlibtacticlemma"}, {"full_name": "ContextFreeRule.rewrites_of_exists_parts", "code": "lemma rewrites_of_exists_parts (r : ContextFreeRule T N) (p q : List (Symbol T N)) :\n    r.Rewrites (p ++ [Symbol.nonterminal r.input] ++ q) (p ++ r.output ++ q) := by\n  induction p with\n  | nil         => exact Rewrites.head q\n  | cons d l ih => exact Rewrites.cons d ih", "start": [65, 1], "end": [69, 44], "kind": "mathlibtacticlemma"}, {"full_name": "ContextFreeRule.rewrites_iff", "code": "theorem rewrites_iff {r : ContextFreeRule T N} (u v : List (Symbol T N)) :\n    r.Rewrites u v \u2194 \u2203 p q : List (Symbol T N),\n      u = p ++ [Symbol.nonterminal r.input] ++ q \u2227 v = p ++ r.output ++ q", "start": [71, 1], "end": [77, 86], "kind": "commanddeclaration"}, {"full_name": "ContextFreeGrammar.Produces", "code": "def Produces (g : ContextFreeGrammar.{uN} T) (u v : List (Symbol T g.NT)) : Prop :=\n  \u2203 r \u2208 g.rules, r.Rewrites u v", "start": [83, 1], "end": [87, 32], "kind": "commanddeclaration"}, {"full_name": "ContextFreeGrammar.Derives", "code": "abbrev Derives (g : ContextFreeGrammar.{uN} T) :\n    List (Symbol T g.NT) \u2192 List (Symbol T g.NT) \u2192 Prop :=\n  Relation.ReflTransGen g.Produces", "start": [89, 1], "end": [93, 35], "kind": "commanddeclaration"}, {"full_name": "ContextFreeGrammar.Generates", "code": "def Generates (g : ContextFreeGrammar.{uN} T) (s : List (Symbol T g.NT)) : Prop :=\n  g.Derives [Symbol.nonterminal g.initial] s", "start": [95, 1], "end": [99, 45], "kind": "commanddeclaration"}, {"full_name": "ContextFreeGrammar.language", "code": "def language (g : ContextFreeGrammar.{uN} T) : Language T :=\n  { w | g.Generates (List.map Symbol.terminal w) }", "start": [101, 1], "end": [103, 51], "kind": "commanddeclaration"}, {"full_name": "ContextFreeGrammar.mem_language_iff", "code": "@[simp]\nlemma mem_language_iff (g : ContextFreeGrammar.{uN} T) (w : List T) :\n    w \u2208 g.language \u2194 g.Derives [Symbol.nonterminal g.initial] (List.map Symbol.terminal w) := by\n  rfl", "start": [105, 1], "end": [111, 6], "kind": "mathlibtacticlemma"}, {"full_name": "ContextFreeGrammar.Derives.refl", "code": "@[refl]\nlemma Derives.refl (w : List (Symbol T g.NT)) : g.Derives w w :=\n  Relation.ReflTransGen.refl", "start": [115, 1], "end": [117, 29], "kind": "mathlibtacticlemma"}, {"full_name": "ContextFreeGrammar.Produces.single", "code": "lemma Produces.single {v w : List (Symbol T g.NT)} (hvw : g.Produces v w) : g.Derives v w :=\n  Relation.ReflTransGen.single hvw", "start": [119, 1], "end": [120, 35], "kind": "mathlibtacticlemma"}, {"full_name": "ContextFreeGrammar.Derives.trans", "code": "@[trans]\nlemma Derives.trans {u v w : List (Symbol T g.NT)} (huv : g.Derives u v) (hvw : g.Derives v w) :\n    g.Derives u w :=\n  Relation.ReflTransGen.trans huv hvw", "start": [122, 1], "end": [125, 38], "kind": "mathlibtacticlemma"}, {"full_name": "ContextFreeGrammar.Derives.trans_produces", "code": "lemma Derives.trans_produces {u v w : List (Symbol T g.NT)}\n    (huv : g.Derives u v) (hvw : g.Produces v w) :\n    g.Derives u w :=\n  huv.trans hvw.single", "start": [127, 1], "end": [130, 23], "kind": "mathlibtacticlemma"}, {"full_name": "ContextFreeGrammar.Produces.trans_derives", "code": "lemma Produces.trans_derives {u v w : List (Symbol T g.NT)}\n    (huv : g.Produces u v) (hvw : g.Derives v w) :\n    g.Derives u w :=\n  huv.single.trans hvw", "start": [132, 1], "end": [135, 23], "kind": "mathlibtacticlemma"}, {"full_name": "ContextFreeGrammar.Derives.eq_or_head", "code": "lemma Derives.eq_or_head {u w : List (Symbol T g.NT)} (huw : g.Derives u w) :\n    u = w \u2228 \u2203 v : List (Symbol T g.NT), g.Produces u v \u2227 g.Derives v w :=\n  Relation.ReflTransGen.cases_head huw", "start": [137, 1], "end": [139, 39], "kind": "mathlibtacticlemma"}, {"full_name": "ContextFreeGrammar.Derives.eq_or_tail", "code": "lemma Derives.eq_or_tail {u w : List (Symbol T g.NT)} (huw : g.Derives u w) :\n    u = w \u2228 \u2203 v : List (Symbol T g.NT), g.Derives u v \u2227 g.Produces v w :=\n  (Relation.ReflTransGen.cases_tail huw).casesOn (Or.inl \u2218 Eq.symm) Or.inr", "start": [141, 1], "end": [143, 75], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Geometry/Euclidean/Sphere/SecondInter.lean", "imports": ["Mathlib/Geometry/Euclidean/Sphere/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EuclideanGeometry.Sphere.secondInter", "code": "def Sphere.secondInter (s : Sphere P) (p : P) (v : V) : P :=\n  (-2 * \u27eav, p -\u1d65 s.center\u27eb / \u27eav, v\u27eb) \u2022 v +\u1d65 p", "start": [33, 1], "end": [38, 46], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.secondInter_dist", "code": "@[simp]\ntheorem Sphere.secondInter_dist (s : Sphere P) (p : P) (v : V) :\n    dist (s.secondInter p v) s.center = dist p s.center", "start": [41, 1], "end": [49, 19], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.secondInter_mem", "code": "@[simp]\ntheorem Sphere.secondInter_mem {s : Sphere P} {p : P} (v : V) : s.secondInter p v \u2208 s \u2194 p \u2208 s", "start": [52, 1], "end": [55, 48], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.secondInter_zero", "code": "@[simp]\ntheorem Sphere.secondInter_zero (s : Sphere P) (p : P) : s.secondInter p (0 : V) = p", "start": [60, 1], "end": [63, 28], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.secondInter_eq_self_iff", "code": "theorem Sphere.secondInter_eq_self_iff {s : Sphere P} {p : P} {v : V} :\n    s.secondInter p v = p \u2194 \u27eav, p -\u1d65 s.center\u27eb = 0", "start": [68, 1], "end": [78, 74], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.eq_or_eq_secondInter_of_mem_mk'_span_singleton_iff_mem", "code": "theorem Sphere.eq_or_eq_secondInter_of_mem_mk'_span_singleton_iff_mem {s : Sphere P} {p : P}\n    (hp : p \u2208 s) {v : V} {p' : P} (hp' : p' \u2208 AffineSubspace.mk' p (\u211d \u2219 v)) :\n    p' = p \u2228 p' = s.secondInter p v \u2194 p' \u2208 s", "start": [81, 1], "end": [98, 39], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.secondInter_smul", "code": "@[simp]\ntheorem Sphere.secondInter_smul (s : Sphere P) (p : P) (v : V) {r : \u211d} (hr : r \u2260 0) :\n    s.secondInter p (r \u2022 v) = s.secondInter p v", "start": [101, 1], "end": [108, 40], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.secondInter_neg", "code": "@[simp]\ntheorem Sphere.secondInter_neg (s : Sphere P) (p : P) (v : V) :\n    s.secondInter p (-v) = s.secondInter p v", "start": [111, 1], "end": [115, 79], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.secondInter_secondInter", "code": "@[simp]\ntheorem Sphere.secondInter_secondInter (s : Sphere P) (p : P) (v : V) :\n    s.secondInter (s.secondInter p v) v = p", "start": [118, 1], "end": [129, 7], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.secondInter_eq_lineMap", "code": "theorem Sphere.secondInter_eq_lineMap (s : Sphere P) (p p' : P) :\n    s.secondInter p (p' -\u1d65 p) =\n      AffineMap.lineMap p p' (-2 * \u27eap' -\u1d65 p, p -\u1d65 s.center\u27eb / \u27eap' -\u1d65 p, p' -\u1d65 p\u27eb)", "start": [132, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.secondInter_vsub_mem_affineSpan", "code": "theorem Sphere.secondInter_vsub_mem_affineSpan (s : Sphere P) (p\u2081 p\u2082 : P) :\n    s.secondInter p\u2081 (p\u2082 -\u1d65 p\u2081) \u2208 line[\u211d, p\u2081, p\u2082]", "start": [140, 1], "end": [144, 43], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.secondInter_collinear", "code": "theorem Sphere.secondInter_collinear (s : Sphere P) (p p' : P) :\n    Collinear \u211d ({p, p', s.secondInter p (p' -\u1d65 p)} : Set P)", "start": [147, 1], "end": [154, 29], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.wbtw_secondInter", "code": "theorem Sphere.wbtw_secondInter {s : Sphere P} {p p' : P} (hp : p \u2208 s)\n    (hp' : dist p' s.center \u2264 s.radius) : Wbtw \u211d p p' (s.secondInter p (p' -\u1d65 p))", "start": [157, 1], "end": [169, 85], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.sbtw_secondInter", "code": "theorem Sphere.sbtw_secondInter {s : Sphere P} {p p' : P} (hp : p \u2208 s)\n    (hp' : dist p' s.center < s.radius) : Sbtw \u211d p p' (s.secondInter p (p' -\u1d65 p))", "start": [172, 1], "end": [183, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Homotopy/HomotopyGroup.lean", "imports": ["Mathlib/Algebra/Group/Ext.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/EckmannHilton.lean", "Mathlib/Logic/Equiv/TransferInstance.lean", "Mathlib/AlgebraicTopology/FundamentalGroupoid/FundamentalGroup.lean"], "premises": [{"full_name": "Cube.boundary", "code": "def boundary (N : Type*) : Set (I^N) :=\n  {y | \u2203 i, y i = 0 \u2228 y i = 1}", "start": [55, 1], "end": [57, 31], "kind": "commanddeclaration"}, {"full_name": "Cube.splitAt", "code": "@[reducible]\ndef splitAt (i : N) : (I^N) \u2243\u209c I \u00d7 I^{ j // j \u2260 i } :=\n  funSplitAt I i", "start": [62, 1], "end": [66, 17], "kind": "commanddeclaration"}, {"full_name": "Cube.insertAt", "code": "@[reducible]\ndef insertAt (i : N) : (I \u00d7 I^{ j // j \u2260 i }) \u2243\u209c I^N :=\n  (funSplitAt I i).symm", "start": [69, 1], "end": [73, 24], "kind": "commanddeclaration"}, {"full_name": "Cube.insertAt_boundary", "code": "theorem insertAt_boundary (i : N) {t\u2080 : I} {t}\n    (H : (t\u2080 = 0 \u2228 t\u2080 = 1) \u2228 t \u2208 boundary { j // j \u2260 i }) : insertAt i \u27e8t\u2080, t\u27e9 \u2208 boundary N", "start": [76, 1], "end": [80, 72], "kind": "commanddeclaration"}, {"full_name": "LoopSpace", "code": "@[reducible]\ndef LoopSpace :=\n  Path x x", "start": [87, 1], "end": [90, 11], "kind": "commanddeclaration"}, {"full_name": "LoopSpace.inhabited", "code": "instance LoopSpace.inhabited : Inhabited (Path x x) :=\n  \u27e8Path.refl x\u27e9", "start": [96, 1], "end": [97, 16], "kind": "commanddeclaration"}, {"full_name": "GenLoop", "code": "def GenLoop : Set C(I^N, X) :=\n  {p | \u2200 y \u2208 Cube.boundary N, p y = x}", "start": [100, 1], "end": [104, 39], "kind": "commanddeclaration"}, {"full_name": "GenLoop.funLike", "code": "instance funLike : FunLike (\u03a9^ N X x) (I^N) fun _ => X where\n  coe f := f.1\n  coe_injective' := fun \u27e8\u27e8f, _\u27e9, _\u27e9 \u27e8\u27e8g, _\u27e9, _\u27e9 _ => by congr", "start": [115, 1], "end": [117, 62], "kind": "commanddeclaration"}, {"full_name": "GenLoop.ext", "code": "@[ext]\ntheorem ext (f g : \u03a9^ N X x) (H : \u2200 y, f y = g y) : f = g", "start": [120, 1], "end": [122, 36], "kind": "commanddeclaration"}, {"full_name": "GenLoop.mk_apply", "code": "@[simp]\ntheorem mk_apply (f : C(I^N, X)) (H y) : (\u27e8f, H\u27e9 : \u03a9^ N X x) y = f y", "start": [125, 1], "end": [127, 6], "kind": "commanddeclaration"}, {"full_name": "GenLoop.copy", "code": "def copy (f : \u03a9^ N X x) (g : (I^N) \u2192 X) (h : g = f) : \u03a9^ N X x :=\n  \u27e8\u27e8g, h.symm \u25b8 f.1.2\u27e9, by convert f.2\u27e9", "start": [130, 1], "end": [133, 40], "kind": "commanddeclaration"}, {"full_name": "GenLoop.coe_copy", "code": "theorem coe_copy (f : \u03a9^ N X x) {g : (I^N) \u2192 X} (h : g = f) : \u21d1(copy f g h) = g", "start": [138, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "GenLoop.copy_eq", "code": "theorem copy_eq (f : \u03a9^ N X x) {g : (I^N) \u2192 X} (h : g = f) : copy f g h = f", "start": [142, 1], "end": [144, 22], "kind": "commanddeclaration"}, {"full_name": "GenLoop.boundary", "code": "theorem boundary (f : \u03a9^ N X x) : \u2200 y \u2208 Cube.boundary N, f y = x", "start": [147, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "GenLoop.const", "code": "def const : \u03a9^ N X x :=\n  \u27e8ContinuousMap.const _ x, fun _ _ => rfl\u27e9", "start": [151, 1], "end": [153, 44], "kind": "commanddeclaration"}, {"full_name": "GenLoop.const_apply", "code": "@[simp]\ntheorem const_apply {t} : (@const N X _ x) t = x", "start": [156, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "GenLoop.inhabited", "code": "instance inhabited : Inhabited (\u03a9^ N X x) :=\n  \u27e8const\u27e9", "start": [161, 1], "end": [162, 10], "kind": "commanddeclaration"}, {"full_name": "GenLoop.Homotopic", "code": "def Homotopic (f g : \u03a9^ N X x) : Prop :=\n  f.1.HomotopicRel g.1 (Cube.boundary N)", "start": [164, 1], "end": [166, 41], "kind": "commanddeclaration"}, {"full_name": "GenLoop.Homotopic.refl", "code": "@[refl]\ntheorem refl (f : \u03a9^ N X x) : Homotopic f f", "start": [173, 1], "end": [175, 36], "kind": "commanddeclaration"}, {"full_name": "GenLoop.Homotopic.symm", "code": "@[symm]\nnonrec theorem symm (H : Homotopic f g) : Homotopic g f", "start": [178, 1], "end": [180, 9], "kind": "commanddeclaration"}, {"full_name": "GenLoop.Homotopic.trans", "code": "@[trans]\nnonrec theorem trans (H0 : Homotopic f g) (H1 : Homotopic g h) : Homotopic f h", "start": [183, 1], "end": [185, 14], "kind": "commanddeclaration"}, {"full_name": "GenLoop.Homotopic.equiv", "code": "theorem equiv : Equivalence (@Homotopic N X _ x)", "start": [188, 1], "end": [189, 52], "kind": "commanddeclaration"}, {"full_name": "GenLoop.Homotopic.setoid", "code": "instance setoid (N) (x : X) : Setoid (\u03a9^ N X x) :=\n  \u27e8Homotopic, equiv\u27e9", "start": [192, 1], "end": [193, 21], "kind": "commanddeclaration"}, {"full_name": "GenLoop.toLoop", "code": "@[simps]\ndef toLoop (i : N) (p : \u03a9^ N X x) : \u03a9 (\u03a9^ { j // j \u2260 i } X x) const\n    where\n  toFun t :=\n    \u27e8(p.val.comp (Cube.insertAt i).toContinuousMap).curry t, fun y yH =>\n      p.property (Cube.insertAt i (t, y)) (Cube.insertAt_boundary i <| Or.inr yH)\u27e9\n  source' := by ext t; refine' p.property (Cube.insertAt i (0, t)) \u27e8i, Or.inl _\u27e9; simp\n  target' := by ext t; refine' p.property (Cube.insertAt i (1, t)) \u27e8i, Or.inr _\u27e9; simp", "start": [202, 1], "end": [210, 87], "kind": "commanddeclaration"}, {"full_name": "GenLoop.continuous_toLoop", "code": "theorem continuous_toLoop (i : N) : Continuous (@toLoop N X _ x _ i)", "start": [214, 1], "end": [222, 8], "kind": "commanddeclaration"}, {"full_name": "GenLoop.fromLoop", "code": "@[simps]\ndef fromLoop (i : N) (p : \u03a9 (\u03a9^ { j // j \u2260 i } X x) const) : \u03a9^ N X x :=\n  \u27e8(ContinuousMap.comp \u27e8Subtype.val, by continuity\u27e9 p.toContinuousMap).uncurry.comp\n    (Cube.splitAt i).toContinuousMap,\n    by\n    rintro y \u27e8j, Hj\u27e9\n    simp only [ContinuousMap.comp_apply, toContinuousMap_apply,\n      funSplitAt_apply, ContinuousMap.uncurry_apply, ContinuousMap.coe_mk,\n      Function.uncurry_apply_pair]\n    obtain rfl | Hne := eq_or_ne j i\n    \u00b7 cases' Hj with Hj Hj <;> simp only [Hj, p.coe_toContinuousMap, p.source, p.target] <;> rfl\n    \u00b7 exact GenLoop.boundary _ _ \u27e8\u27e8j, Hne\u27e9, Hj\u27e9\u27e9", "start": [225, 1], "end": [237, 49], "kind": "commanddeclaration"}, {"full_name": "GenLoop.continuous_fromLoop", "code": "theorem continuous_fromLoop (i : N) : Continuous (@fromLoop N X _ x _ i)", "start": [240, 1], "end": [244, 6], "kind": "commanddeclaration"}, {"full_name": "GenLoop.to_from", "code": "theorem to_from (i : N) (p : \u03a9 (\u03a9^ { j // j \u2260 i } X x) const) : toLoop i (fromLoop i p) = p", "start": [247, 1], "end": [250, 11], "kind": "commanddeclaration"}, {"full_name": "GenLoop.loopHomeo", "code": "@[simps]\ndef loopHomeo (i : N) : \u03a9^ N X x \u2243\u209c \u03a9 (\u03a9^ { j // j \u2260 i } X x) const\n    where\n  toFun := toLoop i\n  invFun := fromLoop i\n  left_inv p := by ext; exact congr_arg p (Equiv.apply_symm_apply _ _)\n  right_inv := to_from i\n  continuous_toFun := continuous_toLoop i\n  continuous_invFun := continuous_fromLoop i", "start": [253, 1], "end": [264, 45], "kind": "commanddeclaration"}, {"full_name": "GenLoop.toLoop_apply", "code": "theorem toLoop_apply (i : N) {p : \u03a9^ N X x} {t} {tn} :\n    toLoop i p t tn = p (Cube.insertAt i \u27e8t, tn\u27e9)", "start": [267, 1], "end": [269, 6], "kind": "commanddeclaration"}, {"full_name": "GenLoop.fromLoop_apply", "code": "theorem fromLoop_apply (i : N) {p : \u03a9 (\u03a9^ { j // j \u2260 i } X x) const} {t : I^N} :\n    fromLoop i p t = p (t i) (Cube.splitAt i t).snd", "start": [272, 1], "end": [274, 6], "kind": "commanddeclaration"}, {"full_name": "GenLoop.cCompInsert", "code": "@[reducible]\ndef cCompInsert (i : N) : C(C(I^N, X), C(I \u00d7 I^{ j // j \u2260 i }, X)) :=\n  \u27e8fun f => f.comp (Cube.insertAt i).toContinuousMap,\n    (Cube.insertAt i).toContinuousMap.continuous_comp_left\u27e9", "start": [277, 1], "end": [281, 60], "kind": "commanddeclaration"}, {"full_name": "GenLoop.homotopyTo", "code": "def homotopyTo (i : N) {p q : \u03a9^ N X x} (H : p.1.HomotopyRel q.1 (Cube.boundary N)) :\n    C(I \u00d7 I, C(I^{ j // j \u2260 i }, X)) :=\n  ((\u27e8_, ContinuousMap.continuous_curry\u27e9 : C(_, _)).comp <|\n      (cCompInsert i).comp H.toContinuousMap.curry).uncurry", "start": [284, 1], "end": [289, 60], "kind": "commanddeclaration"}, {"full_name": "GenLoop.homotopyTo_apply", "code": "theorem homotopyTo_apply (i : N) {p q : \u03a9^ N X x} (H : p.1.HomotopyRel q.1 <| Cube.boundary N)\n    (t : I \u00d7 I) (t\u2099 : I^{ j // j \u2260 i }) :\n    homotopyTo i H t t\u2099 = H (t.fst, Cube.insertAt i (t.snd, t\u2099))", "start": [293, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "GenLoop.homotopicTo", "code": "theorem homotopicTo (i : N) {p q : \u03a9^ N X x} :\n    Homotopic p q \u2192 (toLoop i p).Homotopic (toLoop i q)", "start": [299, 1], "end": [312, 69], "kind": "commanddeclaration"}, {"full_name": "GenLoop.homotopyFrom", "code": "@[simps!] def homotopyFrom (i : N) {p q : \u03a9^ N X x} (H : (toLoop i p).Homotopy (toLoop i q)) :\n    C(I \u00d7 I^N, X) :=\n  (ContinuousMap.comp \u27e8_, ContinuousMap.continuous_uncurry\u27e9\n          (ContinuousMap.comp \u27e8Subtype.val, by continuity\u27e9 H.toContinuousMap).curry).uncurry.comp <|\n    (ContinuousMap.id I).prodMap (Cube.splitAt i).toContinuousMap", "start": [315, 1], "end": [321, 66], "kind": "commanddeclaration"}, {"full_name": "GenLoop.homotopicFrom", "code": "theorem homotopicFrom (i : N) {p q : \u03a9^ N X x} :\n    (toLoop i p).Homotopic (toLoop i q) \u2192 Homotopic p q", "start": [326, 1], "end": [348, 38], "kind": "commanddeclaration"}, {"full_name": "GenLoop.transAt", "code": "def transAt (i : N) (f g : \u03a9^ N X x) : \u03a9^ N X x :=\n  copy (fromLoop i <| (toLoop i f).trans <| toLoop i g)\n    (fun t => if (t i : \u211d) \u2264 1 / 2\n      then f (Function.update t i <| Set.projIcc 0 1 zero_le_one (2 * t i))\n      else g (Function.update t i <| Set.projIcc 0 1 zero_le_one (2 * t i - 1)))\n    (by\n      ext1; symm\n      dsimp only [Path.trans, fromLoop, Path.coe_mk_mk, Function.comp_apply, mk_apply,\n        ContinuousMap.comp_apply, toContinuousMap_apply, funSplitAt_apply,\n        ContinuousMap.uncurry_apply, ContinuousMap.coe_mk, Function.uncurry_apply_pair]\n      split_ifs; change f _ = _; swap; change g _ = _\n      all_goals congr 1)", "start": [351, 1], "end": [363, 25], "kind": "commanddeclaration"}, {"full_name": "GenLoop.symmAt", "code": "def symmAt (i : N) (f : \u03a9^ N X x) : \u03a9^ N X x :=\n  (copy (fromLoop i (toLoop i f).symm) fun t => f fun j => if j = i then \u03c3 (t i) else t j) <| by\n    ext1; change _ = f _; congr; ext1; simp", "start": [366, 1], "end": [369, 44], "kind": "commanddeclaration"}, {"full_name": "GenLoop.transAt_distrib", "code": "theorem transAt_distrib {i j : N} (h : i \u2260 j) (a b c d : \u03a9^ N X x) :\n    transAt i (transAt j a b) (transAt j c d) = transAt j (transAt i a c) (transAt i b d)", "start": [372, 1], "end": [377, 51], "kind": "commanddeclaration"}, {"full_name": "GenLoop.fromLoop_trans_toLoop", "code": "theorem fromLoop_trans_toLoop {i : N} {p q : \u03a9^ N X x} :\n    fromLoop i ((toLoop i p).trans <| toLoop i q) = transAt i p q", "start": [380, 1], "end": [382, 21], "kind": "commanddeclaration"}, {"full_name": "GenLoop.fromLoop_symm_toLoop", "code": "theorem fromLoop_symm_toLoop {i : N} {p : \u03a9^ N X x} : fromLoop i (toLoop i p).symm = symmAt i p", "start": [385, 1], "end": [386, 21], "kind": "commanddeclaration"}, {"full_name": "HomotopyGroup", "code": "def HomotopyGroup (N X : Type*) [TopologicalSpace X] (x : X) : Type _ :=\n  Quotient (GenLoop.Homotopic.setoid N x)", "start": [393, 1], "end": [396, 42], "kind": "commanddeclaration"}, {"full_name": "homotopyGroupEquivFundamentalGroup", "code": "def homotopyGroupEquivFundamentalGroup (i : N) :\n    HomotopyGroup N X x \u2243 FundamentalGroup (\u03a9^ { j // j \u2260 i } X x) const := by\n  refine' Equiv.trans _ (CategoryTheory.Groupoid.isoEquivHom _ _).symm\n  apply Quotient.congr (loopHomeo i).toEquiv\n  exact fun p q => \u27e8homotopicTo i, homotopicFrom i\u27e9", "start": [407, 1], "end": [413, 52], "kind": "commanddeclaration"}, {"full_name": "HomotopyGroup.Pi", "code": "@[reducible]\ndef HomotopyGroup.Pi (n) (X : Type*) [TopologicalSpace X] (x : X) :=\n  HomotopyGroup (Fin n) _ x", "start": [416, 1], "end": [419, 28], "kind": "commanddeclaration"}, {"full_name": "genLoopHomeoOfIsEmpty", "code": "def genLoopHomeoOfIsEmpty (N x) [IsEmpty N] : \u03a9^ N X x \u2243\u209c X where\n  toFun f := f 0\n  invFun y := \u27e8ContinuousMap.const _ y, fun _ \u27e8i, _\u27e9 => isEmptyElim i\u27e9\n  left_inv f := by ext; exact congr_arg f (Subsingleton.elim _ _)\n  right_inv _ := rfl\n  continuous_toFun := (ContinuousMap.continuous_eval_const (0 : N \u2192 I)).comp continuous_induced_dom\n  continuous_invFun := ContinuousMap.const'.2.subtype_mk _", "start": [425, 1], "end": [432, 59], "kind": "commanddeclaration"}, {"full_name": "homotopyGroupEquivZerothHomotopyOfIsEmpty", "code": "def homotopyGroupEquivZerothHomotopyOfIsEmpty (N x) [IsEmpty N] :\n    HomotopyGroup N X x \u2243 ZerothHomotopy X :=\n  Quotient.congr (genLoopHomeoOfIsEmpty N x).toEquiv\n    (by\n      intros a\u2081 a\u2082;\n      constructor <;> rintro \u27e8H\u27e9\n      exacts\n        [\u27e8{ toFun := fun t => H \u27e8t, isEmptyElim\u27e9\n            source' := (H.apply_zero _).trans (congr_arg a\u2081 <| Subsingleton.elim _ _)\n            target' := (H.apply_one _).trans (congr_arg a\u2082 <| Subsingleton.elim _ _) }\u27e9,\n        \u27e8{  toFun := fun t0 => H t0.fst\n            map_zero_left := fun _ => H.source.trans (congr_arg a\u2081 <| Subsingleton.elim _ _)\n            map_one_left := fun _ => H.target.trans (congr_arg a\u2082 <| Subsingleton.elim _ _)\n            prop' := fun _ _ \u27e8i, _\u27e9 => isEmptyElim i }\u27e9])", "start": [435, 1], "end": [451, 58], "kind": "commanddeclaration"}, {"full_name": "HomotopyGroup.pi0EquivZerothHomotopy", "code": "def HomotopyGroup.pi0EquivZerothHomotopy : \u03c0_ 0 X x \u2243 ZerothHomotopy X :=\n  homotopyGroupEquivZerothHomotopyOfIsEmpty (Fin 0) x", "start": [454, 1], "end": [456, 54], "kind": "commanddeclaration"}, {"full_name": "genLoopEquivOfUnique", "code": "def genLoopEquivOfUnique (N) [Unique N] : \u03a9^ N X x \u2243 \u03a9 X x where\n  toFun p :=\n    Path.mk \u27e8fun t => p fun _ => t, by continuity\u27e9\n      (GenLoop.boundary _ (fun _ => 0) \u27e8default, Or.inl rfl\u27e9)\n      (GenLoop.boundary _ (fun _ => 1) \u27e8default, Or.inr rfl\u27e9)\n  invFun p :=\n    \u27e8\u27e8fun c => p (c default), by continuity\u27e9,\n      by\n      rintro y \u27e8i, iH | iH\u27e9 <;> cases Unique.eq_default i <;> apply (congr_arg p iH).trans\n      exacts [p.source, p.target]\u27e9\n  left_inv p := by ext y; exact congr_arg p (eq_const_of_unique y).symm\n  right_inv p := by ext; rfl", "start": [459, 1], "end": [471, 29], "kind": "commanddeclaration"}, {"full_name": "homotopyGroupEquivFundamentalGroupOfUnique", "code": "def homotopyGroupEquivFundamentalGroupOfUnique (N) [Unique N] :\n    HomotopyGroup N X x \u2243 FundamentalGroup X x := by\n  refine' Equiv.trans _ (CategoryTheory.Groupoid.isoEquivHom _ _).symm\n  refine' Quotient.congr (genLoopEquivOfUnique N) _\n  intros a\u2081 a\u2082; constructor <;> rintro \u27e8H\u27e9\n  \u00b7 exact\n      \u27e8{  toFun := fun tx => H (tx.fst, fun _ => tx.snd)\n          map_zero_left := fun _ => H.apply_zero _\n          map_one_left := fun _ => H.apply_one _\n          prop' := fun t y iH => H.prop' _ _ \u27e8default, iH\u27e9 }\u27e9\n  refine'\n    \u27e8\u27e8\u27e8\u27e8fun tx => H (tx.fst, tx.snd default), H.continuous.comp _\u27e9, fun y => _, fun y => _\u27e9, _\u27e9\u27e9\n  \u00b7 exact continuous_fst.prod_mk ((continuous_apply _).comp continuous_snd)\n  \u00b7 exact (H.apply_zero _).trans (congr_arg a\u2081 (eq_const_of_unique y).symm)\n  \u00b7 exact (H.apply_one _).trans (congr_arg a\u2082 (eq_const_of_unique y).symm)\n  \u00b7 rintro t y \u27e8i, iH\u27e9\n    cases Unique.eq_default i; constructor\n    \u00b7 exact (H.eq_fst _ iH).trans (congr_arg a\u2081 (eq_const_of_unique y).symm)\n    \u00b7 exact (H.eq_snd _ iH).trans (congr_arg a\u2082 (eq_const_of_unique y).symm)", "start": [479, 1], "end": [499, 77], "kind": "commanddeclaration"}, {"full_name": "HomotopyGroup.pi1EquivFundamentalGroup", "code": "def HomotopyGroup.pi1EquivFundamentalGroup : \u03c0_ 1 X x \u2243 FundamentalGroup X x :=\n  homotopyGroupEquivFundamentalGroupOfUnique (Fin 1)", "start": [502, 1], "end": [504, 53], "kind": "commanddeclaration"}, {"full_name": "HomotopyGroup.group", "code": "instance group (N) [DecidableEq N] [Nonempty N] : Group (HomotopyGroup N X x) :=\n  (homotopyGroupEquivFundamentalGroup <| Classical.arbitrary N).group", "start": [509, 1], "end": [511, 70], "kind": "commanddeclaration"}, {"full_name": "HomotopyGroup.auxGroup", "code": "@[reducible]\ndef auxGroup (i : N) : Group (HomotopyGroup N X x) :=\n  (homotopyGroupEquivFundamentalGroup i).group", "start": [514, 1], "end": [519, 47], "kind": "commanddeclaration"}, {"full_name": "HomotopyGroup.isUnital_auxGroup", "code": "theorem isUnital_auxGroup (i : N) :\n    EckmannHilton.IsUnital (auxGroup i).mul (\u27e6const\u27e7 : HomotopyGroup N X x)", "start": [522, 1], "end": [524, 51], "kind": "commanddeclaration"}, {"full_name": "HomotopyGroup.auxGroup_indep", "code": "theorem auxGroup_indep (i j : N) : (auxGroup i : Group (HomotopyGroup N X x)) = auxGroup j", "start": [527, 1], "end": [534, 44], "kind": "commanddeclaration"}, {"full_name": "HomotopyGroup.transAt_indep", "code": "theorem transAt_indep {i} (j) (f g : \u03a9^ N X x) :\n    (\u27e6transAt i f g\u27e7 : HomotopyGroup N X x) = \u27e6transAt j f g\u27e7", "start": [537, 1], "end": [541, 88], "kind": "commanddeclaration"}, {"full_name": "HomotopyGroup.symmAt_indep", "code": "theorem symmAt_indep {i} (j) (f : \u03a9^ N X x) :\n    (\u27e6symmAt i f\u27e7 : HomotopyGroup N X x) = \u27e6symmAt j f\u27e7", "start": [544, 1], "end": [548, 85], "kind": "commanddeclaration"}, {"full_name": "HomotopyGroup.one_def", "code": "theorem one_def [Nonempty N] : (1 : HomotopyGroup N X x) = \u27e6const\u27e7", "start": [551, 1], "end": [553, 6], "kind": "commanddeclaration"}, {"full_name": "HomotopyGroup.mul_spec", "code": "theorem mul_spec [Nonempty N] {i} {p q : \u03a9^ N X x} :\n    ((\u00b7 * \u00b7) : _ \u2192 _ \u2192 HomotopyGroup N X x) \u27e6p\u27e7 \u27e6q\u27e7 = \u27e6transAt i q p\u27e7", "start": [556, 1], "end": [560, 77], "kind": "commanddeclaration"}, {"full_name": "HomotopyGroup.inv_spec", "code": "theorem inv_spec [Nonempty N] {i} {p : \u03a9^ N X x} : ((\u27e6p\u27e7)\u207b\u00b9 : HomotopyGroup N X x) = \u27e6symmAt i p\u27e7", "start": [563, 1], "end": [565, 78], "kind": "commanddeclaration"}, {"full_name": "HomotopyGroup.commGroup", "code": "instance commGroup [Nontrivial N] : CommGroup (HomotopyGroup N X x) :=\n  let h := exists_ne (Classical.arbitrary N)\n  @EckmannHilton.commGroup (HomotopyGroup N X x) _ 1 (isUnital_auxGroup <| Classical.choose h) _\n    (by\n      rintro \u27e8a\u27e9 \u27e8b\u27e9 \u27e8c\u27e9 \u27e8d\u27e9\n      apply congr_arg Quotient.mk'\n      simp only [fromLoop_trans_toLoop, transAt_distrib <| Classical.choose_spec h, coe_toEquiv,\n        loopHomeo_apply, coe_symm_toEquiv, loopHomeo_symm_apply])", "start": [568, 1], "end": [577, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Category/CompleteLat.lean", "imports": ["Mathlib/Order/Category/BddLat.lean", "Mathlib/Order/Hom/CompleteLattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CompleteLat", "code": "def CompleteLat :=\n  Bundled CompleteLattice", "start": [23, 1], "end": [25, 26], "kind": "commanddeclaration"}, {"full_name": "CompleteLat.of", "code": "def of (\u03b1 : Type*) [CompleteLattice \u03b1] : CompleteLat :=\n  Bundled.of \u03b1", "start": [36, 1], "end": [38, 15], "kind": "commanddeclaration"}, {"full_name": "CompleteLat.coe_of", "code": "@[simp]\ntheorem coe_of (\u03b1 : Type*) [CompleteLattice \u03b1] : \u21a5(of \u03b1) = \u03b1", "start": [41, 1], "end": [43, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLat.hasForgetToBddLat", "code": "instance hasForgetToBddLat : HasForget\u2082 CompleteLat BddLat where\n  forget\u2082 :=\n    { obj := fun X => BddLat.of X\n      map := fun {X Y} => CompleteLatticeHom.toBoundedLatticeHom }\n  forget_comp := rfl", "start": [60, 1], "end": [64, 21], "kind": "commanddeclaration"}, {"full_name": "CompleteLat.Iso.mk", "code": "@[simps]\ndef Iso.mk {\u03b1 \u03b2 : CompleteLat.{u}} (e : \u03b1 \u2243o \u03b2) : \u03b1 \u2245 \u03b2 where\n  hom := (e : CompleteLatticeHom _ _) inv := (e.symm : CompleteLatticeHom _ _)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _", "start": [67, 1], "end": [73, 51], "kind": "commanddeclaration"}, {"full_name": "CompleteLat.dual", "code": "@[simps]\ndef dual : CompleteLat \u2964 CompleteLat where\n  obj X := of X\u1d52\u1d48\n  map {X Y} := CompleteLatticeHom.dual", "start": [76, 1], "end": [80, 39], "kind": "commanddeclaration"}, {"full_name": "CompleteLat.dualEquiv", "code": "@[simps functor inverse]\ndef dualEquiv : CompleteLat \u224c CompleteLat where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X", "start": [83, 1], "end": [89, 74], "kind": "commanddeclaration"}, {"full_name": "completeLat_dual_comp_forget_to_bddLat", "code": "theorem completeLat_dual_comp_forget_to_bddLat :\n    CompleteLat.dual \u22d9 forget\u2082 CompleteLat BddLat =\n    forget\u2082 CompleteLat BddLat \u22d9 BddLat.dual", "start": [94, 1], "end": [97, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Closed/Types.lean", "imports": ["Mathlib/CategoryTheory/Limits/Presheaf.lean", "Mathlib/CategoryTheory/Limits/Preserves/FunctorCategory.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Closed/Cartesian.lean", "Mathlib/CategoryTheory/Limits/Shapes/Types.lean"], "premises": []}
{"path": "Mathlib/SetTheory/Ordinal/Topology.lean", "imports": ["Mathlib/SetTheory/Ordinal/Arithmetic.lean", "Mathlib/Tactic/TFAE.lean", "Mathlib/Topology/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ordinal.isOpen_singleton_iff", "code": "theorem isOpen_singleton_iff : IsOpen ({a} : Set Ordinal) \u2194 \u00acIsLimit a", "start": [41, 1], "end": [53, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nhds_right'", "code": "theorem nhds_right' (a : Ordinal) : \ud835\udcdd[>] a = \u22a5", "start": [57, 1], "end": [57, 80], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nhds_left'_eq_nhds_ne", "code": "theorem nhds_left'_eq_nhds_ne (a : Ordinal) : \ud835\udcdd[<] a = \ud835\udcdd[\u2260] a", "start": [60, 1], "end": [61, 61], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nhds_left_eq_nhds", "code": "theorem nhds_left_eq_nhds (a : Ordinal) : \ud835\udcdd[\u2264] a = \ud835\udcdd a", "start": [64, 1], "end": [65, 60], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nhdsBasis_Ioc", "code": "theorem nhdsBasis_Ioc (h : a \u2260 0) : (\ud835\udcdd a).HasBasis (\u00b7 < a) (Set.Ioc \u00b7 a)", "start": [68, 1], "end": [69, 60], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nhds_eq_pure", "code": "theorem nhds_eq_pure : \ud835\udcdd a = pure a \u2194 \u00acIsLimit a", "start": [72, 1], "end": [73, 72], "kind": "commanddeclaration"}, {"full_name": "Ordinal.isOpen_iff", "code": "theorem isOpen_iff : IsOpen s \u2194 \u2200 o \u2208 s, IsLimit o \u2192 \u2203 a < o, Set.Ioo a o \u2286 s", "start": [76, 1], "end": [82, 39], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mem_closure_tfae", "code": "theorem mem_closure_tfae (a : Ordinal.{u}) (s : Set Ordinal) :\n    TFAE [a \u2208 closure s,\n      a \u2208 closure (s \u2229 Iic a),\n      (s \u2229 Iic a).Nonempty \u2227 sSup (s \u2229 Iic a) = a,\n      \u2203 t, t \u2286 s \u2227 t.Nonempty \u2227 BddAbove t \u2227 sSup t = a,\n      \u2203 (o : Ordinal.{u}), o \u2260 0 \u2227 \u2203 (f : \u2200 x < o, Ordinal),\n        (\u2200 x hx, f x hx \u2208 s) \u2227 bsup.{u, u} o f = a,\n      \u2203 (\u03b9 : Type u), Nonempty \u03b9 \u2227 \u2203 f : \u03b9 \u2192 Ordinal, (\u2200 i, f i \u2208 s) \u2227 sup.{u, u} f = a]", "start": [86, 1], "end": [124, 14], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mem_closure_iff_sup", "code": "theorem mem_closure_iff_sup :\n    a \u2208 closure s \u2194\n      \u2203 (\u03b9 : Type u) (_ : Nonempty \u03b9) (f : \u03b9 \u2192 Ordinal), (\u2200 i, f i \u2208 s) \u2227 sup.{u, u} f = a", "start": [126, 1], "end": [129, 71], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mem_closed_iff_sup", "code": "theorem mem_closed_iff_sup (hs : IsClosed s) :\n    a \u2208 s \u2194 \u2203 (\u03b9 : Type u) (_h\u03b9 : Nonempty \u03b9) (f : \u03b9 \u2192 Ordinal),\n      (\u2200 i, f i \u2208 s) \u2227 sup.{u, u} f = a", "start": [132, 1], "end": [135, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mem_closure_iff_bsup", "code": "theorem mem_closure_iff_bsup :\n    a \u2208 closure s \u2194\n      \u2203 (o : Ordinal) (_ho : o \u2260 0) (f : \u2200 a < o, Ordinal),\n        (\u2200 i hi, f i hi \u2208 s) \u2227 bsup.{u, u} o f = a", "start": [138, 1], "end": [142, 71], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mem_closed_iff_bsup", "code": "theorem mem_closed_iff_bsup (hs : IsClosed s) :\n    a \u2208 s \u2194\n      \u2203 (o : Ordinal) (_ho : o \u2260 0) (f : \u2200 a < o, Ordinal),\n        (\u2200 i hi, f i hi \u2208 s) \u2227 bsup.{u, u} o f = a", "start": [145, 1], "end": [149, 48], "kind": "commanddeclaration"}, {"full_name": "Ordinal.isClosed_iff_sup", "code": "theorem isClosed_iff_sup :\n    IsClosed s \u2194\n      \u2200 {\u03b9 : Type u}, Nonempty \u03b9 \u2192 \u2200 f : \u03b9 \u2192 Ordinal, (\u2200 i, f i \u2208 s) \u2192 sup.{u, u} f \u2208 s", "start": [152, 1], "end": [159, 18], "kind": "commanddeclaration"}, {"full_name": "Ordinal.isClosed_iff_bsup", "code": "theorem isClosed_iff_bsup :\n    IsClosed s \u2194\n      \u2200 {o : Ordinal}, o \u2260 0 \u2192 \u2200 f : \u2200 a < o, Ordinal,\n        (\u2200 i hi, f i hi \u2208 s) \u2192 bsup.{u, u} o f \u2208 s", "start": [162, 1], "end": [171, 27], "kind": "commanddeclaration"}, {"full_name": "Ordinal.isLimit_of_mem_frontier", "code": "theorem isLimit_of_mem_frontier (ha : a \u2208 frontier s) : IsLimit a", "start": [174, 1], "end": [182, 16], "kind": "commanddeclaration"}, {"full_name": "Ordinal.isNormal_iff_strictMono_and_continuous", "code": "theorem isNormal_iff_strictMono_and_continuous (f : Ordinal.{u} \u2192 Ordinal.{u}) :\n    IsNormal f \u2194 StrictMono f \u2227 Continuous f", "start": [185, 1], "end": [206, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd_isNormal_iff_isClosed", "code": "theorem enumOrd_isNormal_iff_isClosed (hs : s.Unbounded (\u00b7 < \u00b7)) :\n    IsNormal (enumOrd s) \u2194 IsClosed s", "start": [209, 1], "end": [235, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/ShortComplex/Preadditive.lean", "imports": ["Mathlib/Algebra/Homology/ShortComplex/Homology.lean", "Mathlib/CategoryTheory/Preadditive/AdditiveFunctor.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.ShortComplex.add_\u03c4\u2081", "code": "@[simp] lemma add_\u03c4\u2081 (\u03c6 \u03c6' : S\u2081 \u27f6 S\u2082) : (\u03c6 + \u03c6').\u03c4\u2081 = \u03c6.\u03c4\u2081 + \u03c6'.\u03c4\u2081 := rfl", "start": [57, 1], "end": [57, 74], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.add_\u03c4\u2082", "code": "@[simp] lemma add_\u03c4\u2082 (\u03c6 \u03c6' : S\u2081 \u27f6 S\u2082) : (\u03c6 + \u03c6').\u03c4\u2082 = \u03c6.\u03c4\u2082 + \u03c6'.\u03c4\u2082 := rfl", "start": [58, 1], "end": [58, 74], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.add_\u03c4\u2083", "code": "@[simp] lemma add_\u03c4\u2083 (\u03c6 \u03c6' : S\u2081 \u27f6 S\u2082) : (\u03c6 + \u03c6').\u03c4\u2083 = \u03c6.\u03c4\u2083 + \u03c6'.\u03c4\u2083 := rfl", "start": [59, 1], "end": [59, 74], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.sub_\u03c4\u2081", "code": "@[simp] lemma sub_\u03c4\u2081 (\u03c6 \u03c6' : S\u2081 \u27f6 S\u2082) : (\u03c6 - \u03c6').\u03c4\u2081 = \u03c6.\u03c4\u2081 - \u03c6'.\u03c4\u2081 := rfl", "start": [60, 1], "end": [60, 74], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.sub_\u03c4\u2082", "code": "@[simp] lemma sub_\u03c4\u2082 (\u03c6 \u03c6' : S\u2081 \u27f6 S\u2082) : (\u03c6 - \u03c6').\u03c4\u2082 = \u03c6.\u03c4\u2082 - \u03c6'.\u03c4\u2082 := rfl", "start": [61, 1], "end": [61, 74], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.sub_\u03c4\u2083", "code": "@[simp] lemma sub_\u03c4\u2083 (\u03c6 \u03c6' : S\u2081 \u27f6 S\u2082) : (\u03c6 - \u03c6').\u03c4\u2083 = \u03c6.\u03c4\u2083 - \u03c6'.\u03c4\u2083 := rfl", "start": [62, 1], "end": [62, 74], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.neg_\u03c4\u2081", "code": "@[simp] lemma neg_\u03c4\u2081 (\u03c6 : S\u2081 \u27f6 S\u2082) : (-\u03c6).\u03c4\u2081 = -\u03c6.\u03c4\u2081 := rfl", "start": [63, 1], "end": [63, 60], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.neg_\u03c4\u2082", "code": "@[simp] lemma neg_\u03c4\u2082 (\u03c6 : S\u2081 \u27f6 S\u2082) : (-\u03c6).\u03c4\u2082 = -\u03c6.\u03c4\u2082 := rfl", "start": [64, 1], "end": [64, 60], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.neg_\u03c4\u2083", "code": "@[simp] lemma neg_\u03c4\u2083 (\u03c6 : S\u2081 \u27f6 S\u2082) : (-\u03c6).\u03c4\u2083 = -\u03c6.\u03c4\u2083 := rfl", "start": [65, 1], "end": [65, 60], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyMapData.neg", "code": "@[simps]\ndef neg : LeftHomologyMapData (-\u03c6) h\u2081 h\u2082 where\n  \u03c6K := -\u03b3.\u03c6K\n  \u03c6H := -\u03b3.\u03c6H", "start": [77, 1], "end": [82, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyMapData.add", "code": "@[simps]\ndef add : LeftHomologyMapData (\u03c6 + \u03c6') h\u2081 h\u2082 where\n  \u03c6K := \u03b3.\u03c6K + \u03b3'.\u03c6K\n  \u03c6H := \u03b3.\u03c6H + \u03b3'.\u03c6H", "start": [84, 1], "end": [89, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.leftHomologyMap'_neg", "code": "@[simp]\nlemma leftHomologyMap'_neg :\n    leftHomologyMap' (-\u03c6) h\u2081 h\u2082 = -leftHomologyMap' \u03c6 h\u2081 h\u2082 := by\n  have \u03b3 : LeftHomologyMapData \u03c6 h\u2081 h\u2082 := default\n  simp only [\u03b3.leftHomologyMap'_eq, \u03b3.neg.leftHomologyMap'_eq, LeftHomologyMapData.neg_\u03c6H]", "start": [95, 1], "end": [99, 91], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.cyclesMap'_neg", "code": "@[simp]\nlemma cyclesMap'_neg :\n    cyclesMap' (-\u03c6) h\u2081 h\u2082 = -cyclesMap' \u03c6 h\u2081 h\u2082 := by\n  have \u03b3 : LeftHomologyMapData \u03c6 h\u2081 h\u2082 := default\n  simp only [\u03b3.cyclesMap'_eq, \u03b3.neg.cyclesMap'_eq, LeftHomologyMapData.neg_\u03c6K]", "start": [101, 1], "end": [105, 79], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftHomologyMap'_add", "code": "@[simp]\nlemma leftHomologyMap'_add :\n    leftHomologyMap' (\u03c6 + \u03c6') h\u2081 h\u2082 = leftHomologyMap' \u03c6 h\u2081 h\u2082 +\n      leftHomologyMap' \u03c6' h\u2081 h\u2082 := by\n  have \u03b3 : LeftHomologyMapData \u03c6 h\u2081 h\u2082 := default\n  have \u03b3' : LeftHomologyMapData \u03c6' h\u2081 h\u2082 := default\n  simp only [\u03b3.leftHomologyMap'_eq, \u03b3'.leftHomologyMap'_eq,\n    (\u03b3.add \u03b3').leftHomologyMap'_eq, LeftHomologyMapData.add_\u03c6H]", "start": [107, 1], "end": [114, 64], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.cyclesMap'_add", "code": "@[simp]\nlemma cyclesMap'_add :\n    cyclesMap' (\u03c6 + \u03c6') h\u2081 h\u2082 = cyclesMap' \u03c6 h\u2081 h\u2082 +\n      cyclesMap' \u03c6' h\u2081 h\u2082 := by\n  have \u03b3 : LeftHomologyMapData \u03c6 h\u2081 h\u2082 := default\n  have \u03b3' : LeftHomologyMapData \u03c6' h\u2081 h\u2082 := default\n  simp only [\u03b3.cyclesMap'_eq, \u03b3'.cyclesMap'_eq,\n    (\u03b3.add \u03b3').cyclesMap'_eq, LeftHomologyMapData.add_\u03c6K]", "start": [116, 1], "end": [123, 58], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftHomologyMap'_sub", "code": "@[simp]\nlemma leftHomologyMap'_sub :\n    leftHomologyMap' (\u03c6 - \u03c6') h\u2081 h\u2082 = leftHomologyMap' \u03c6 h\u2081 h\u2082 -\n      leftHomologyMap' \u03c6' h\u2081 h\u2082 := by\n  simp only [sub_eq_add_neg, leftHomologyMap'_add, leftHomologyMap'_neg]", "start": [125, 1], "end": [129, 73], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.cyclesMap'_sub", "code": "@[simp]\nlemma cyclesMap'_sub :\n    cyclesMap' (\u03c6 - \u03c6') h\u2081 h\u2082 = cyclesMap' \u03c6 h\u2081 h\u2082 -\n      cyclesMap' \u03c6' h\u2081 h\u2082 := by\n  simp only [sub_eq_add_neg, cyclesMap'_add, cyclesMap'_neg]", "start": [131, 1], "end": [135, 61], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftHomologyMap_neg", "code": "@[simp]\nlemma leftHomologyMap_neg : leftHomologyMap (-\u03c6)  = -leftHomologyMap \u03c6 :=\n  leftHomologyMap'_neg _ _", "start": [143, 1], "end": [145, 27], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.cyclesMap_neg", "code": "@[simp]\nlemma cyclesMap_neg : cyclesMap (-\u03c6) = -cyclesMap \u03c6 :=\n  cyclesMap'_neg _ _", "start": [147, 1], "end": [149, 21], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftHomologyMap_add", "code": "@[simp]\nlemma leftHomologyMap_add : leftHomologyMap (\u03c6 + \u03c6')  = leftHomologyMap \u03c6 + leftHomologyMap \u03c6' :=\n  leftHomologyMap'_add _ _", "start": [151, 1], "end": [153, 27], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.cyclesMap_add", "code": "@[simp]\nlemma cyclesMap_add : cyclesMap (\u03c6 + \u03c6') = cyclesMap \u03c6 + cyclesMap \u03c6' :=\n  cyclesMap'_add _ _", "start": [155, 1], "end": [157, 21], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftHomologyMap_sub", "code": "@[simp]\nlemma leftHomologyMap_sub : leftHomologyMap (\u03c6 - \u03c6') = leftHomologyMap \u03c6 - leftHomologyMap \u03c6' :=\n  leftHomologyMap'_sub  _ _", "start": [159, 1], "end": [161, 28], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.cyclesMap_sub", "code": "@[simp]\nlemma cyclesMap_sub : cyclesMap (\u03c6 - \u03c6') = cyclesMap \u03c6 - cyclesMap \u03c6' :=\n  cyclesMap'_sub _ _", "start": [163, 1], "end": [165, 21], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftHomologyFunctor_additive", "code": "instance leftHomologyFunctor_additive [HasKernels C] [HasCokernels C] :\n  (leftHomologyFunctor C).Additive where", "start": [169, 1], "end": [170, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.cyclesFunctor_additive", "code": "instance cyclesFunctor_additive [HasKernels C] [HasCokernels C] :\n  (cyclesFunctor C).Additive where", "start": [172, 1], "end": [173, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Polynomial/Dickson.lean", "imports": ["Mathlib/RingTheory/Localization/FractionRing.lean", "Mathlib/Data/ZMod/Basic.lean", "Mathlib/RingTheory/Polynomial/Chebyshev.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Ideal/LocalRing.lean", "Mathlib/Algebra/CharP/Invertible.lean"], "premises": [{"full_name": "Polynomial.dickson", "code": "noncomputable def dickson : \u2115 \u2192 R[X]\n  | 0 => 3 - k\n  | 1 => X\n  | n + 2 => X * dickson (n + 1) - C a * dickson n", "start": [59, 1], "end": [64, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dickson_zero", "code": "@[simp]\ntheorem dickson_zero : dickson k a 0 = 3 - k", "start": [67, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dickson_one", "code": "@[simp]\ntheorem dickson_one : dickson k a 1 = X", "start": [72, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dickson_two", "code": "theorem dickson_two : dickson k a 2 = X ^ 2 - C a * (3 - k : R[X])", "start": [77, 1], "end": [78, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dickson_add_two", "code": "@[simp]\ntheorem dickson_add_two (n : \u2115) :\n    dickson k a (n + 2) = X * dickson k a (n + 1) - C a * dickson k a n", "start": [81, 1], "end": [83, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dickson_of_two_le", "code": "theorem dickson_of_two_le {n : \u2115} (h : 2 \u2264 n) :\n    dickson k a n = X * dickson k a (n - 1) - C a * dickson k a (n - 2)", "start": [86, 1], "end": [90, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_dickson", "code": "theorem map_dickson (f : R \u2192+* S) : \u2200 n : \u2115, map f (dickson k a n) = dickson k (f a) n", "start": [95, 1], "end": [101, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dickson_two_zero", "code": "@[simp]\ntheorem dickson_two_zero : \u2200 n : \u2115, dickson 2 (0 : R) n = X ^ n", "start": [104, 1], "end": [112, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dickson_one_one_eval_add_inv", "code": "theorem dickson_one_one_eval_add_inv (x y : R) (h : x * y = 1) :\n    \u2200 n, (dickson 1 (1 : R) n).eval (x + y) = x ^ n + y ^ n", "start": [129, 1], "end": [141, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.two_mul_C_half_eq_one", "code": "private theorem two_mul_C_half_eq_one [Invertible (2 : R)] : 2 * C (\u215f 2 : R) = 1", "start": [147, 1], "end": [148, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_half_mul_two_eq_one", "code": "private theorem C_half_mul_two_eq_one [Invertible (2 : R)] : C (\u215f 2 : R) * 2 = 1", "start": [150, 1], "end": [151, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dickson_one_one_eq_chebyshev_T", "code": "theorem dickson_one_one_eq_chebyshev_T [Invertible (2 : R)] :\n    \u2200 n, dickson 1 (1 : R) n = 2 * (Chebyshev.T R n).comp (C (\u215f 2) * X)", "start": [153, 1], "end": [164, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.chebyshev_T_eq_dickson_one_one", "code": "theorem chebyshev_T_eq_dickson_one_one [Invertible (2 : R)] (n : \u2115) :\n    Chebyshev.T R n = C (\u215f 2) * (dickson 1 1 n).comp (2 * X)", "start": [168, 1], "end": [171, 80], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dickson_one_one_mul", "code": "theorem dickson_one_one_mul (m n : \u2115) :\n    dickson 1 (1 : R) (m * n) = (dickson 1 1 m).comp (dickson 1 1 n)", "start": [175, 1], "end": [191, 77], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dickson_one_one_comp_comm", "code": "theorem dickson_one_one_comp_comm (m n : \u2115) :\n    (dickson 1 (1 : R) m).comp (dickson 1 1 n) = (dickson 1 1 n).comp (dickson 1 1 m)", "start": [194, 1], "end": [196, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dickson_one_one_zmod_p", "code": "theorem dickson_one_one_zmod_p (p : \u2115) [Fact p.Prime] : dickson 1 (1 : ZMod p) p = X ^ p", "start": [199, 1], "end": [265, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dickson_one_one_charP", "code": "theorem dickson_one_one_charP (p : \u2115) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p", "start": [268, 1], "end": [272, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/Morphisms/QuasiSeparated.lean", "imports": ["Mathlib/Topology/QuasiSeparated.lean", "Mathlib/AlgebraicGeometry/Morphisms/QuasiCompact.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicGeometry.QuasiSeparated", "code": "@[mk_iff]\nclass QuasiSeparated (f : X \u27f6 Y) : Prop where\n  \n  diagonalQuasiCompact : QuasiCompact (pullback.diagonal f)", "start": [44, 1], "end": [48, 60], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiSeparated.affineProperty", "code": "def QuasiSeparated.affineProperty : AffineTargetMorphismProperty := fun X _ _ _ =>\n  QuasiSeparatedSpace X.carrier", "start": [51, 1], "end": [54, 32], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiSeparatedSpace_iff_affine", "code": "theorem quasiSeparatedSpace_iff_affine (X : Scheme) :\n    QuasiSeparatedSpace X.carrier \u2194 \u2200 U V : X.affineOpens, IsCompact (U \u2229 V : Set X.carrier)", "start": [57, 1], "end": [83, 16], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasi_compact_affineProperty_iff_quasiSeparatedSpace", "code": "theorem quasi_compact_affineProperty_iff_quasiSeparatedSpace {X Y : Scheme} [IsAffine Y]\n    (f : X \u27f6 Y) : QuasiCompact.affineProperty.diagonal f \u2194 QuasiSeparatedSpace X.carrier", "start": [86, 1], "end": [114, 15], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiSeparated_eq_diagonal_is_quasiCompact", "code": "theorem quasiSeparated_eq_diagonal_is_quasiCompact :\n    @QuasiSeparated = MorphismProperty.diagonal @QuasiCompact", "start": [117, 1], "end": [118, 100], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasi_compact_affineProperty_diagonal_eq", "code": "theorem quasi_compact_affineProperty_diagonal_eq :\n    QuasiCompact.affineProperty.diagonal = QuasiSeparated.affineProperty", "start": [121, 1], "end": [123, 73], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiSeparated_eq_affineProperty_diagonal", "code": "theorem quasiSeparated_eq_affineProperty_diagonal :\n    @QuasiSeparated = targetAffineLocally QuasiCompact.affineProperty.diagonal", "start": [126, 1], "end": [130, 94], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiSeparated_eq_affineProperty", "code": "theorem quasiSeparated_eq_affineProperty :\n    @QuasiSeparated = targetAffineLocally QuasiSeparated.affineProperty", "start": [133, 1], "end": [135, 91], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiSeparated.affineProperty_isLocal", "code": "theorem QuasiSeparated.affineProperty_isLocal : QuasiSeparated.affineProperty.IsLocal", "start": [138, 1], "end": [139, 90], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiSeparatedOfMono", "code": "instance (priority := 900) quasiSeparatedOfMono {X Y : Scheme} (f : X \u27f6 Y) [Mono f] :\n    QuasiSeparated f :=\n  \u27e8inferInstance\u27e9", "start": [142, 1], "end": [144, 18], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiSeparated_stableUnderComposition", "code": "theorem quasiSeparated_stableUnderComposition :\n    MorphismProperty.StableUnderComposition @QuasiSeparated", "start": [147, 1], "end": [151, 41], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiSeparated_stableUnderBaseChange", "code": "theorem quasiSeparated_stableUnderBaseChange :\n    MorphismProperty.StableUnderBaseChange @QuasiSeparated", "start": [154, 1], "end": [157, 73], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiSeparatedComp", "code": "instance quasiSeparatedComp {X Y Z : Scheme} (f : X \u27f6 Y) (g : Y \u27f6 Z) [QuasiSeparated f]\n    [QuasiSeparated g] : QuasiSeparated (f \u226b g) :=\n  quasiSeparated_stableUnderComposition f g inferInstance inferInstance", "start": [160, 1], "end": [162, 72], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiSeparated_respectsIso", "code": "theorem quasiSeparated_respectsIso : MorphismProperty.RespectsIso @QuasiSeparated", "start": [165, 1], "end": [166, 86], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiSeparated.affine_openCover_TFAE", "code": "theorem QuasiSeparated.affine_openCover_TFAE {X Y : Scheme.{u}} (f : X \u27f6 Y) :\n    TFAE\n      [QuasiSeparated f,\n        \u2203 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (_ : \u2200 i, IsAffine (\ud835\udcb0.obj i)),\n          \u2200 i : \ud835\udcb0.J, QuasiSeparatedSpace (pullback f (\ud835\udcb0.map i)).carrier,\n        \u2200 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) [\u2200 i, IsAffine (\ud835\udcb0.obj i)] (i : \ud835\udcb0.J),\n          QuasiSeparatedSpace (pullback f (\ud835\udcb0.map i)).carrier,\n        \u2200 {U : Scheme} (g : U \u27f6 Y) [IsAffine U] [IsOpenImmersion g],\n          QuasiSeparatedSpace (pullback f g).carrier,\n        \u2203 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (_ : \u2200 i, IsAffine (\ud835\udcb0.obj i)) (\ud835\udcb0' :\n          \u2200 i : \ud835\udcb0.J, Scheme.OpenCover.{u} (pullback f (\ud835\udcb0.map i))) (_ :\n          \u2200 i j, IsAffine ((\ud835\udcb0' i).obj j)),\n          \u2200 (i : \ud835\udcb0.J) (j k : (\ud835\udcb0' i).J),\n            CompactSpace (pullback ((\ud835\udcb0' i).map j) ((\ud835\udcb0' i).map k)).carrier]", "start": [170, 1], "end": [187, 13], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiSeparated.is_local_at_target", "code": "theorem QuasiSeparated.is_local_at_target : PropertyIsLocalAtTarget @QuasiSeparated", "start": [190, 1], "end": [192, 76], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiSeparated.openCover_TFAE", "code": "theorem QuasiSeparated.openCover_TFAE {X Y : Scheme.{u}} (f : X \u27f6 Y) :\n    TFAE\n      [QuasiSeparated f,\n        \u2203 \ud835\udcb0 : Scheme.OpenCover.{u} Y,\n          \u2200 i : \ud835\udcb0.J, QuasiSeparated (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i),\n        \u2200 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (i : \ud835\udcb0.J),\n          QuasiSeparated (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i),\n        \u2200 U : Opens Y.carrier, QuasiSeparated (f \u2223_ U),\n        \u2200 {U : Scheme} (g : U \u27f6 Y) [IsOpenImmersion g],\n          QuasiSeparated (pullback.snd : pullback f g \u27f6 _),\n        \u2203 (\u03b9 : Type u) (U : \u03b9 \u2192 Opens Y.carrier) (_ : iSup U = \u22a4),\n          \u2200 i, QuasiSeparated (f \u2223_ U i)]", "start": [196, 1], "end": [208, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiSeparated_over_affine_iff", "code": "theorem quasiSeparated_over_affine_iff {X Y : Scheme} (f : X \u27f6 Y) [IsAffine Y] :\n    QuasiSeparated f \u2194 QuasiSeparatedSpace X.carrier", "start": [211, 1], "end": [214, 94], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiSeparatedSpace_iff_quasiSeparated", "code": "theorem quasiSeparatedSpace_iff_quasiSeparated (X : Scheme) :\n    QuasiSeparatedSpace X.carrier \u2194 QuasiSeparated (terminal.from X)", "start": [217, 1], "end": [219, 42], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiSeparated.affine_openCover_iff", "code": "theorem QuasiSeparated.affine_openCover_iff {X Y : Scheme.{u}} (\ud835\udcb0 : Scheme.OpenCover.{u} Y)\n    [\u2200 i, IsAffine (\ud835\udcb0.obj i)] (f : X \u27f6 Y) :\n    QuasiSeparated f \u2194 \u2200 i, QuasiSeparatedSpace (pullback f (\ud835\udcb0.map i)).carrier", "start": [222, 1], "end": [227, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiSeparated.openCover_iff", "code": "theorem QuasiSeparated.openCover_iff {X Y : Scheme.{u}} (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (f : X \u27f6 Y) :\n    QuasiSeparated f \u2194 \u2200 i, QuasiSeparated (pullback.snd : pullback f (\ud835\udcb0.map i) \u27f6 _)", "start": [230, 1], "end": [232, 54], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiSeparatedSpace_of_quasiSeparated", "code": "theorem quasiSeparatedSpace_of_quasiSeparated {X Y : Scheme} (f : X \u27f6 Y)\n    [hY : QuasiSeparatedSpace Y.carrier] [QuasiSeparated f] : QuasiSeparatedSpace X.carrier", "start": [247, 1], "end": [252, 17], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiSeparatedSpace_of_isAffine", "code": "instance quasiSeparatedSpace_of_isAffine (X : Scheme) [IsAffine X] :\n    QuasiSeparatedSpace X.carrier := by\n  constructor\n  intro U V hU hU' hV hV'\n  obtain \u27e8s, hs, e\u27e9 := (isCompact_open_iff_eq_basicOpen_union _).mp \u27e8hU', hU\u27e9\n  obtain \u27e8s', hs', e'\u27e9 := (isCompact_open_iff_eq_basicOpen_union _).mp \u27e8hV', hV\u27e9\n  rw [e, e', Set.iUnion\u2082_inter]\n  simp_rw [Set.inter_iUnion\u2082]\n  apply hs.isCompact_biUnion\n  \u00b7 intro i _\n    apply hs'.isCompact_biUnion\n    intro i' _\n    change IsCompact (X.basicOpen i \u2293 X.basicOpen i').1\n    rw [\u2190 Scheme.basicOpen_mul]\n    exact ((topIsAffineOpen _).basicOpenIsAffine _).isCompact", "start": [255, 1], "end": [269, 62], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.IsAffineOpen.isQuasiSeparated", "code": "theorem IsAffineOpen.isQuasiSeparated {X : Scheme} {U : Opens X.carrier} (hU : IsAffineOpen U) :\n    IsQuasiSeparated (U : Set X.carrier)", "start": [272, 1], "end": [275, 77], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiSeparatedOfComp", "code": "theorem quasiSeparatedOfComp {X Y Z : Scheme} (f : X \u27f6 Y) (g : Y \u27f6 Z) [H : QuasiSeparated (f \u226b g)] :\n    QuasiSeparated f", "start": [278, 1], "end": [298, 24], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.exists_eq_pow_mul_of_isAffineOpen", "code": "theorem exists_eq_pow_mul_of_isAffineOpen (X : Scheme) (U : Opens X.carrier) (hU : IsAffineOpen U)\n    (f : X.presheaf.obj (op U)) (x : X.presheaf.obj (op <| X.basicOpen f)) :\n    \u2203 (n : \u2115) (y : X.presheaf.obj (op U)), y |_ X.basicOpen f = (f |_ X.basicOpen f) ^ n * x", "start": [301, 1], "end": [308, 34], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux", "code": "theorem exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux (X : Scheme)\n    (S : X.affineOpens) (U\u2081 U\u2082 : Opens X.carrier) {n\u2081 n\u2082 : \u2115} {y\u2081 : X.presheaf.obj (op U\u2081)}\n    {y\u2082 : X.presheaf.obj (op U\u2082)} {f : X.presheaf.obj (op <| U\u2081 \u2294 U\u2082)}\n    {x : X.presheaf.obj (op <| X.basicOpen f)} (h\u2081 : S.1 \u2264 U\u2081) (h\u2082 : S.1 \u2264 U\u2082)\n    (e\u2081 :\n      X.presheaf.map\n          (homOfLE <| X.basicOpen_le (X.presheaf.map (homOfLE le_sup_left).op f) : _ \u27f6 U\u2081).op y\u2081 =\n        X.presheaf.map (homOfLE (by erw [X.basicOpen_res]; exact inf_le_left)).op\n              (X.presheaf.map (homOfLE le_sup_left).op f) ^\n            n\u2081 *\n          (X.presheaf.map (homOfLE (by erw [X.basicOpen_res]; exact inf_le_right)).op) x)\n    (e\u2082 :\n      X.presheaf.map\n          (homOfLE <| X.basicOpen_le (X.presheaf.map (homOfLE le_sup_right).op f) : _ \u27f6 U\u2082).op y\u2082 =\n        X.presheaf.map (homOfLE (by rw [X.basicOpen_res]; exact inf_le_left)).op\n              (X.presheaf.map (homOfLE le_sup_right).op f) ^\n            n\u2082 *\n          (X.presheaf.map (homOfLE (by rw [X.basicOpen_res]; exact inf_le_right)).op) x) :\n    \u2203 n : \u2115,\n      X.presheaf.map (homOfLE <| h\u2081).op\n          (X.presheaf.map (homOfLE le_sup_left).op f ^ (n + n\u2082) * y\u2081) =\n        X.presheaf.map (homOfLE <| h\u2082).op\n          (X.presheaf.map (homOfLE le_sup_right).op f ^ (n + n\u2081) * y\u2082)", "start": [312, 1], "end": [370, 10], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.exists_eq_pow_mul_of_isCompact_of_isQuasiSeparated", "code": "theorem exists_eq_pow_mul_of_isCompact_of_isQuasiSeparated (X : Scheme.{u}) (U : Opens X.carrier)\n    (hU : IsCompact U.1) (hU' : IsQuasiSeparated U.1) (f : X.presheaf.obj (op U))\n    (x : X.presheaf.obj (op <| X.basicOpen f)) :\n    \u2203 (n : \u2115) (y : X.presheaf.obj (op U)), y |_ X.basicOpen f = (f |_ X.basicOpen f) ^ n * x", "start": [374, 1], "end": [511, 66], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.is_localization_basicOpen_of_qcqs", "code": "theorem is_localization_basicOpen_of_qcqs {X : Scheme} {U : Opens X.carrier} (hU : IsCompact U.1)\n    (hU' : IsQuasiSeparated U.1) (f : X.presheaf.obj (op U)) :\n    IsLocalization.Away f (X.presheaf.obj (op <| X.basicOpen f))", "start": [514, 1], "end": [541, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/ProbabilityMassFunction/Integrals.lean", "imports": ["Mathlib/MeasureTheory/Integral/Bochner.lean", "Mathlib/Probability/ProbabilityMassFunction/Constructions.lean", "Mathlib/Probability/ProbabilityMassFunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PMF.integral_eq_tsum", "code": "theorem integral_eq_tsum (p : PMF \u03b1) (f : \u03b1 \u2192 E) (hf : Integrable f p.toMeasure) :\n    \u222b a, f a \u2202(p.toMeasure) = \u2211' a, (p a).toReal \u2022 f a", "start": [28, 1], "end": [41, 56], "kind": "commanddeclaration"}, {"full_name": "PMF.integral_eq_sum", "code": "theorem integral_eq_sum [Fintype \u03b1] (p : PMF \u03b1) (f : \u03b1 \u2192 E) :\n    \u222b a, f a \u2202(p.toMeasure) = \u2211 a, (p a).toReal \u2022 f a", "start": [43, 1], "end": [47, 70], "kind": "commanddeclaration"}, {"full_name": "PMF.bernoulli_expectation", "code": "theorem bernoulli_expectation {p : \u211d\u22650\u221e} (h : p \u2264 1) :\n    \u222b b, cond b 1 0 \u2202((bernoulli p h).toMeasure) = p.toReal", "start": [51, 1], "end": [52, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Preadditive/OfBiproducts.lean", "imports": ["Mathlib/GroupTheory/EckmannHilton.lean", "Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean", "Mathlib/Tactic/CategoryTheory/Reassoc.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.SemiadditiveOfBinaryBiproducts.leftAdd", "code": "@[simp]\ndef leftAdd (f g : X \u27f6 Y) : X \u27f6 Y :=\n  biprod.lift f g \u226b biprod.desc (\ud835\udfd9 Y) (\ud835\udfd9 Y)", "start": [36, 1], "end": [40, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SemiadditiveOfBinaryBiproducts.rightAdd", "code": "@[simp]\ndef rightAdd (f g : X \u27f6 Y) : X \u27f6 Y :=\n  biprod.lift (\ud835\udfd9 X) (\ud835\udfd9 X) \u226b biprod.desc f g", "start": [43, 1], "end": [47, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SemiadditiveOfBinaryBiproducts.isUnital_leftAdd", "code": "theorem isUnital_leftAdd : EckmannHilton.IsUnital (\u00b7 +\u2097 \u00b7) 0", "start": [56, 1], "end": [68, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SemiadditiveOfBinaryBiproducts.isUnital_rightAdd", "code": "theorem isUnital_rightAdd : EckmannHilton.IsUnital (\u00b7 +\u1d63 \u00b7) 0", "start": [71, 1], "end": [83, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SemiadditiveOfBinaryBiproducts.distrib", "code": "theorem distrib (f g h k : X \u27f6 Y) : (f +\u1d63 g) +\u2097 h +\u1d63 k = (f +\u2097 h) +\u1d63 g +\u2097 k", "start": [86, 1], "end": [94, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SemiadditiveOfBinaryBiproducts.addCommMonoidHomOfHasBinaryBiproducts", "code": "def addCommMonoidHomOfHasBinaryBiproducts : AddCommMonoid (X \u27f6 Y)\n    where\n  add := (\u00b7 +\u1d63 \u00b7)\n  add_assoc :=\n    (EckmannHilton.mul_assoc (isUnital_leftAdd X Y) (isUnital_rightAdd X Y) (distrib X Y)).assoc\n  zero := 0\n  zero_add := (isUnital_rightAdd X Y).left_id\n  add_zero := (isUnital_rightAdd X Y).right_id\n  add_comm :=\n    (EckmannHilton.mul_comm (isUnital_leftAdd X Y) (isUnital_rightAdd X Y) (distrib X Y)).comm", "start": [97, 1], "end": [107, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SemiadditiveOfBinaryBiproducts.add_eq_right_addition", "code": "theorem add_eq_right_addition (f g : X \u27f6 Y) : f + g = biprod.lift (\ud835\udfd9 X) (\ud835\udfd9 X) \u226b biprod.desc f g", "start": [118, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SemiadditiveOfBinaryBiproducts.add_eq_left_addition", "code": "theorem add_eq_left_addition (f g : X \u27f6 Y) : f + g = biprod.lift f g \u226b biprod.desc (\ud835\udfd9 Y) (\ud835\udfd9 Y)", "start": [122, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SemiadditiveOfBinaryBiproducts.add_comp", "code": "theorem add_comp (f g : X \u27f6 Y) (h : Y \u27f6 Z) : (f + g) \u226b h = f \u226b h + g \u226b h", "start": [127, 1], "end": [130, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SemiadditiveOfBinaryBiproducts.comp_add", "code": "theorem comp_add (f : X \u27f6 Y) (g h : Y \u27f6 Z) : f \u226b (g + h) = f \u226b g + f \u226b h", "start": [133, 1], "end": [136, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Cast/Synonym.lean", "imports": ["Mathlib/Data/Nat/Cast/Basic.lean", "Mathlib/Order/Synonym.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "toDual_natCast", "code": "@[simp]\ntheorem toDual_natCast [NatCast \u03b1] (n : \u2115) : toDual (n : \u03b1) = n", "start": [43, 1], "end": [45, 6], "kind": "commanddeclaration"}, {"full_name": "ofDual_natCast", "code": "@[simp]\ntheorem ofDual_natCast [NatCast \u03b1] (n : \u2115) : (ofDual n : \u03b1) = n", "start": [48, 1], "end": [50, 6], "kind": "commanddeclaration"}, {"full_name": "toLex_natCast", "code": "@[simp]\ntheorem toLex_natCast [NatCast \u03b1] (n : \u2115) : toLex (n : \u03b1) = n", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "ofLex_natCast", "code": "@[simp]\ntheorem ofLex_natCast [NatCast \u03b1] (n : \u2115) : (ofLex n : \u03b1) = n", "start": [70, 1], "end": [72, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/ULift.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PLift.map", "code": "protected def map (f : \u03b1 \u2192 \u03b2) (a : PLift \u03b1) : PLift \u03b2 :=\n  PLift.up (f a.down)", "start": [23, 1], "end": [25, 22], "kind": "commanddeclaration"}, {"full_name": "PLift.map_up", "code": "@[simp]\ntheorem map_up (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : (PLift.up a).map f = PLift.up (f a)", "start": [28, 1], "end": [30, 6], "kind": "commanddeclaration"}, {"full_name": "PLift.pure", "code": "@[simp]\nprotected def pure : \u03b1 \u2192 PLift \u03b1 :=\n  up", "start": [33, 1], "end": [36, 5], "kind": "commanddeclaration"}, {"full_name": "PLift.seq", "code": "protected def seq (f : PLift (\u03b1 \u2192 \u03b2)) (x : Unit \u2192 PLift \u03b1) : PLift \u03b2 :=\n  PLift.up (f.down (x ()).down)", "start": [39, 1], "end": [41, 32], "kind": "commanddeclaration"}, {"full_name": "PLift.seq_up", "code": "@[simp]\ntheorem seq_up (f : \u03b1 \u2192 \u03b2) (x : \u03b1) : (PLift.up f).seq (fun _ => PLift.up x) = PLift.up (f x)", "start": [44, 1], "end": [46, 6], "kind": "commanddeclaration"}, {"full_name": "PLift.bind", "code": "protected def bind (a : PLift \u03b1) (f : \u03b1 \u2192 PLift \u03b2) : PLift \u03b2 :=\n  f a.down", "start": [49, 1], "end": [51, 11], "kind": "commanddeclaration"}, {"full_name": "PLift.bind_up", "code": "@[simp]\ntheorem bind_up (a : \u03b1) (f : \u03b1 \u2192 PLift \u03b2) : (PLift.up a).bind f = f a", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "PLift.rec.constant", "code": "@[simp]\ntheorem rec.constant {\u03b1 : Sort u} {\u03b2 : Type v} (b : \u03b2) :\n    (@PLift.rec \u03b1 (fun _ => \u03b2) fun _ => b) = fun _ => b", "start": [84, 1], "end": [86, 63], "kind": "commanddeclaration"}, {"full_name": "ULift.map", "code": "protected def map (f : \u03b1 \u2192 \u03b2) (a : ULift \u03b1) : ULift \u03b2 :=\n  ULift.up.{u} (f a.down)", "start": [95, 1], "end": [97, 26], "kind": "commanddeclaration"}, {"full_name": "ULift.map_up", "code": "@[simp]\ntheorem map_up (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : (ULift.up.{u} a).map f = ULift.up.{u} (f a)", "start": [100, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.pure", "code": "@[simp]\nprotected def pure : \u03b1 \u2192 ULift \u03b1 :=\n  up", "start": [105, 1], "end": [108, 5], "kind": "commanddeclaration"}, {"full_name": "ULift.seq", "code": "protected def seq {\u03b1 \u03b2} (f : ULift (\u03b1 \u2192 \u03b2)) (x : Unit \u2192 ULift \u03b1) : ULift \u03b2 :=\n  ULift.up.{u} (f.down (x ()).down)", "start": [111, 1], "end": [113, 36], "kind": "commanddeclaration"}, {"full_name": "ULift.seq_up", "code": "@[simp]\ntheorem seq_up (f : \u03b1 \u2192 \u03b2) (x : \u03b1) : (ULift.up f).seq (fun _ => ULift.up x) = ULift.up (f x)", "start": [116, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.bind", "code": "protected def bind (a : ULift \u03b1) (f : \u03b1 \u2192 ULift \u03b2) : ULift \u03b2 :=\n  f a.down", "start": [121, 1], "end": [123, 11], "kind": "commanddeclaration"}, {"full_name": "ULift.bind_up", "code": "@[simp]\ntheorem bind_up (a : \u03b1) (f : \u03b1 \u2192 ULift \u03b2) : (ULift.up a).bind f = f a", "start": [126, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.rec.constant", "code": "@[simp]\ntheorem rec.constant {\u03b1 : Type u} {\u03b2 : Sort v} (b : \u03b2) :\n    (@ULift.rec \u03b1 (fun _ => \u03b2) fun _ => b) = fun _ => b", "start": [156, 1], "end": [158, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Constructions/Over/Basic.lean", "imports": ["Mathlib/CategoryTheory/Limits/Constructions/Equalizers.lean", "Mathlib/CategoryTheory/Limits/Constructions/LimitsOfProductsAndEqualizers.lean", "Mathlib/CategoryTheory/Limits/Constructions/Over/Products.lean", "Mathlib/CategoryTheory/Limits/Constructions/Over/Connected.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Connected.lean"], "premises": [{"full_name": "CategoryTheory.Over.hasFiniteLimits", "code": "instance hasFiniteLimits {B : C} [HasFiniteWidePullbacks C] : HasFiniteLimits (Over B) := by\n  apply @hasFiniteLimits_of_hasEqualizers_and_finite_products _ _ ?_ ?_\n  \u00b7 exact ConstructProducts.over_finiteProducts_of_finiteWidePullbacks\n  \u00b7 apply @hasEqualizers_of_hasPullbacks_and_binary_products _ _ ?_ _\n    \u00b7 haveI : HasPullbacks C := \u27e8inferInstance\u27e9\n      exact ConstructProducts.over_binaryProduct_of_pullback", "start": [47, 1], "end": [52, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.hasLimits", "code": "instance hasLimits {B : C} [HasWidePullbacks.{w} C] : HasLimitsOfSize.{w} (Over B) := by\n  apply @has_limits_of_hasEqualizers_and_products _ _ ?_ ?_\n  \u00b7 exact ConstructProducts.over_products_of_widePullbacks\n  \u00b7 apply @hasEqualizers_of_hasPullbacks_and_binary_products _ _ ?_ _\n    \u00b7 haveI : HasPullbacks C := \u27e8inferInstance\u27e9\n      exact ConstructProducts.over_binaryProduct_of_pullback", "start": [55, 1], "end": [60, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/Deriv/Star.lean", "imports": ["Mathlib/Analysis/Calculus/FDeriv/Star.lean", "Mathlib/Analysis/Calculus/Deriv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HasDerivAtFilter.star", "code": "protected nonrec theorem HasDerivAtFilter.star (h : HasDerivAtFilter f f' x L) :\n    HasDerivAtFilter (fun x => star (f x)) (star f') x L", "start": [37, 1], "end": [39, 38], "kind": "commanddeclaration"}, {"full_name": "HasDerivWithinAt.star", "code": "protected nonrec theorem HasDerivWithinAt.star (h : HasDerivWithinAt f f' s x) :\n    HasDerivWithinAt (fun x => star (f x)) (star f') s x", "start": [42, 1], "end": [44, 9], "kind": "commanddeclaration"}, {"full_name": "HasDerivAt.star", "code": "protected nonrec theorem HasDerivAt.star (h : HasDerivAt f f' x) :\n    HasDerivAt (fun x => star (f x)) (star f') x", "start": [47, 1], "end": [49, 9], "kind": "commanddeclaration"}, {"full_name": "HasStrictDerivAt.star", "code": "protected nonrec theorem HasStrictDerivAt.star (h : HasStrictDerivAt f f' x) :\n    HasStrictDerivAt (fun x => star (f x)) (star f') x", "start": [52, 1], "end": [53, 97], "kind": "commanddeclaration"}, {"full_name": "derivWithin.star", "code": "protected theorem derivWithin.star (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    derivWithin (fun y => star (f y)) s x = star (derivWithin f s x)", "start": [56, 1], "end": [58, 46], "kind": "commanddeclaration"}, {"full_name": "deriv.star", "code": "protected theorem deriv.star : deriv (fun y => star (f y)) x = star (deriv f x)", "start": [61, 1], "end": [62, 34], "kind": "commanddeclaration"}, {"full_name": "deriv.star'", "code": "@[simp]\nprotected theorem deriv.star' : (deriv fun y => star (f y)) = fun x => star (deriv f x)", "start": [65, 1], "end": [67, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/AffineSpace/Pointwise.lean", "imports": ["Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AffineSubspace.pointwiseAddAction", "code": "protected def pointwiseAddAction : AddAction V (AffineSubspace k P) where\n  vadd x S := S.map (AffineEquiv.constVAdd k P x)\n  zero_vadd p := ((congr_arg fun f => p.map f) <| AffineMap.ext <| zero_vadd _).trans p.map_id\n  add_vadd _ _ p :=\n    ((congr_arg fun f => p.map f) <| AffineMap.ext <| add_vadd _ _).trans (p.map_map _ _).symm", "start": [34, 1], "end": [41, 95], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.pointwise_vadd_eq_map", "code": "theorem pointwise_vadd_eq_map (v : V) (s : AffineSubspace k P) :\n    v +\u1d65 s = s.map (AffineEquiv.constVAdd k P v)", "start": [49, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.coe_pointwise_vadd", "code": "@[simp]\ntheorem coe_pointwise_vadd (v : V) (s : AffineSubspace k P) :\n    ((v +\u1d65 s : AffineSubspace k P) : Set P) = v +\u1d65 (s : Set P)", "start": [53, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.vadd_mem_pointwise_vadd_iff", "code": "theorem vadd_mem_pointwise_vadd_iff {v : V} {s : AffineSubspace k P} {p : P} :\n    v +\u1d65 p \u2208 v +\u1d65 s \u2194 p \u2208 s", "start": [59, 1], "end": [61, 24], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.pointwise_vadd_bot", "code": "theorem pointwise_vadd_bot (v : V) : v +\u1d65 (\u22a5 : AffineSubspace k P) = \u22a5", "start": [64, 1], "end": [65, 45], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.pointwise_vadd_direction", "code": "theorem pointwise_vadd_direction (v : V) (s : AffineSubspace k P) :\n    (v +\u1d65 s).direction = s.direction", "start": [68, 1], "end": [71, 27], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.pointwise_vadd_span", "code": "theorem pointwise_vadd_span (v : V) (s : Set P) : v +\u1d65 affineSpan k s = affineSpan k (v +\u1d65 s)", "start": [74, 1], "end": [75, 15], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.map_pointwise_vadd", "code": "theorem map_pointwise_vadd (f : P\u2081 \u2192\u1d43[k] P\u2082) (v : V\u2081) (s : AffineSubspace k P\u2081) :\n    (v +\u1d65 s).map f = f.linear v +\u1d65 s.map f", "start": [78, 1], "end": [83, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/ConstantSpeed.lean", "imports": ["Mathlib/Analysis/BoundedVariation.lean", "Mathlib/Data/Set/Function.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HasConstantSpeedOnWith", "code": "def HasConstantSpeedOnWith :=\n  \u2200 \u2983x\u2984 (_ : x \u2208 s) \u2983y\u2984 (_ : y \u2208 s), eVariationOn f (s \u2229 Icc x y) = ENNReal.ofReal (l * (y - x))", "start": [51, 1], "end": [55, 97], "kind": "commanddeclaration"}, {"full_name": "HasConstantSpeedOnWith.hasLocallyBoundedVariationOn", "code": "theorem HasConstantSpeedOnWith.hasLocallyBoundedVariationOn (h : HasConstantSpeedOnWith f s l) :\n    LocallyBoundedVariationOn f s", "start": [60, 1], "end": [62, 88], "kind": "commanddeclaration"}, {"full_name": "hasConstantSpeedOnWith_of_subsingleton", "code": "theorem hasConstantSpeedOnWith_of_subsingleton (f : \u211d \u2192 E) {s : Set \u211d} (hs : s.Subsingleton)\n    (l : \u211d\u22650) : HasConstantSpeedOnWith f s l", "start": [65, 1], "end": [69, 54], "kind": "commanddeclaration"}, {"full_name": "hasConstantSpeedOnWith_iff_ordered", "code": "theorem hasConstantSpeedOnWith_iff_ordered :\n    HasConstantSpeedOnWith f s l \u2194 \u2200 \u2983x\u2984 (_ : x \u2208 s) \u2983y\u2984 (_ : y \u2208 s),\n      x \u2264 y \u2192 eVariationOn f (s \u2229 Icc x y) = ENNReal.ofReal (l * (y - x))", "start": [72, 1], "end": [83, 10], "kind": "commanddeclaration"}, {"full_name": "hasConstantSpeedOnWith_iff_variationOnFromTo_eq", "code": "theorem hasConstantSpeedOnWith_iff_variationOnFromTo_eq :\n    HasConstantSpeedOnWith f s l \u2194 LocallyBoundedVariationOn f s \u2227\n      \u2200 \u2983x\u2984 (_ : x \u2208 s) \u2983y\u2984 (_ : y \u2208 s), variationOnFromTo f s x y = l * (y - x)", "start": [86, 1], "end": [100, 95], "kind": "commanddeclaration"}, {"full_name": "HasConstantSpeedOnWith.union", "code": "theorem HasConstantSpeedOnWith.union {t : Set \u211d} (hfs : HasConstantSpeedOnWith f s l)\n    (hft : HasConstantSpeedOnWith f t l) {x : \u211d} (hs : IsGreatest s x) (ht : IsLeast t x) :\n    HasConstantSpeedOnWith f (s \u222a t) l", "start": [103, 1], "end": [138, 28], "kind": "commanddeclaration"}, {"full_name": "HasConstantSpeedOnWith.Icc_Icc", "code": "theorem HasConstantSpeedOnWith.Icc_Icc {x y z : \u211d} (hfs : HasConstantSpeedOnWith f (Icc x y) l)\n    (hft : HasConstantSpeedOnWith f (Icc y z) l) : HasConstantSpeedOnWith f (Icc x z) l", "start": [141, 1], "end": [154, 26], "kind": "commanddeclaration"}, {"full_name": "hasConstantSpeedOnWith_zero_iff", "code": "theorem hasConstantSpeedOnWith_zero_iff :\n    HasConstantSpeedOnWith f s 0 \u2194 \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s), edist (f x) (f y) = 0", "start": [157, 1], "end": [174, 62], "kind": "commanddeclaration"}, {"full_name": "HasConstantSpeedOnWith.ratio", "code": "theorem HasConstantSpeedOnWith.ratio {l' : \u211d\u22650} (hl' : l' \u2260 0) {\u03c6 : \u211d \u2192 \u211d} (\u03c6m : MonotoneOn \u03c6 s)\n    (hf\u03c6 : HasConstantSpeedOnWith (f \u2218 \u03c6) s l) (hf : HasConstantSpeedOnWith f (\u03c6 '' s) l') \u2983x : \u211d\u2984\n    (xs : x \u2208 s) : EqOn \u03c6 (fun y => l / l' * (y - x) + \u03c6 x) s", "start": [177, 1], "end": [191, 45], "kind": "commanddeclaration"}, {"full_name": "HasUnitSpeedOn", "code": "def HasUnitSpeedOn (f : \u211d \u2192 E) (s : Set \u211d) :=\n  HasConstantSpeedOnWith f s 1", "start": [194, 1], "end": [196, 31], "kind": "commanddeclaration"}, {"full_name": "HasUnitSpeedOn.union", "code": "theorem HasUnitSpeedOn.union {t : Set \u211d} {x : \u211d} (hfs : HasUnitSpeedOn f s)\n    (hft : HasUnitSpeedOn f t) (hs : IsGreatest s x) (ht : IsLeast t x) :\n    HasUnitSpeedOn f (s \u222a t)", "start": [199, 1], "end": [202, 45], "kind": "commanddeclaration"}, {"full_name": "HasUnitSpeedOn.Icc_Icc", "code": "theorem HasUnitSpeedOn.Icc_Icc {x y z : \u211d} (hfs : HasUnitSpeedOn f (Icc x y))\n    (hft : HasUnitSpeedOn f (Icc y z)) : HasUnitSpeedOn f (Icc x z)", "start": [205, 1], "end": [207, 41], "kind": "commanddeclaration"}, {"full_name": "unique_unit_speed", "code": "theorem unique_unit_speed {\u03c6 : \u211d \u2192 \u211d} (\u03c6m : MonotoneOn \u03c6 s) (hf\u03c6 : HasUnitSpeedOn (f \u2218 \u03c6) s)\n    (hf : HasUnitSpeedOn f (\u03c6 '' s)) \u2983x : \u211d\u2984 (xs : x \u2208 s) : EqOn \u03c6 (fun y => y - x + \u03c6 x) s", "start": [210, 1], "end": [217, 11], "kind": "commanddeclaration"}, {"full_name": "unique_unit_speed_on_Icc_zero", "code": "theorem unique_unit_speed_on_Icc_zero {s t : \u211d} (hs : 0 \u2264 s) (ht : 0 \u2264 t) {\u03c6 : \u211d \u2192 \u211d}\n    (\u03c6m : MonotoneOn \u03c6 <| Icc 0 s) (\u03c6st : \u03c6 '' Icc 0 s = Icc 0 t)\n    (hf\u03c6 : HasUnitSpeedOn (f \u2218 \u03c6) (Icc 0 s)) (hf : HasUnitSpeedOn f (Icc 0 t)) :\n    EqOn \u03c6 id (Icc 0 s)", "start": [220, 1], "end": [236, 6], "kind": "commanddeclaration"}, {"full_name": "naturalParameterization", "code": "noncomputable def naturalParameterization (f : \u03b1 \u2192 E) (s : Set \u03b1) (a : \u03b1) : \u211d \u2192 E :=\n  f \u2218 @Function.invFunOn _ _ \u27e8a\u27e9 (variationOnFromTo f s a) s", "start": [239, 1], "end": [245, 61], "kind": "commanddeclaration"}, {"full_name": "edist_naturalParameterization_eq_zero", "code": "theorem edist_naturalParameterization_eq_zero {f : \u03b1 \u2192 E} {s : Set \u03b1}\n    (hf : LocallyBoundedVariationOn f s) {a : \u03b1} (as : a \u2208 s) {b : \u03b1} (bs : b \u2208 s) :\n    edist (naturalParameterization f s a (variationOnFromTo f s a b)) (f b) = 0", "start": [248, 1], "end": [257, 60], "kind": "commanddeclaration"}, {"full_name": "has_unit_speed_naturalParameterization", "code": "theorem has_unit_speed_naturalParameterization (f : \u03b1 \u2192 E) {s : Set \u03b1}\n    (hf : LocallyBoundedVariationOn f s) {a : \u03b1} (as : a \u2208 s) :\n    HasUnitSpeedOn (naturalParameterization f s a) (variationOnFromTo f s a '' s)", "start": [260, 1], "end": [278, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/CompletePartialOrder.lean", "imports": ["Mathlib/Order/OmegaCompletePartialOrder.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CompletePartialOrder", "code": "class CompletePartialOrder (\u03b1 : Type*) extends PartialOrder \u03b1, SupSet \u03b1 where\n  \n  lubOfDirected : \u2200 d, DirectedOn (. \u2264 .) d \u2192 IsLUB d (sSup d)", "start": [37, 1], "end": [42, 63], "kind": "commanddeclaration"}, {"full_name": "DirectedOn.isLUB_sSup", "code": "protected lemma DirectedOn.isLUB_sSup : DirectedOn (. \u2264 .) d \u2192 IsLUB d (sSup d) :=\nCompletePartialOrder.lubOfDirected _", "start": [46, 1], "end": [47, 37], "kind": "mathlibtacticlemma"}, {"full_name": "DirectedOn.le_sSup", "code": "protected lemma DirectedOn.le_sSup (hd : DirectedOn (. \u2264 .) d) (ha : a \u2208 d) : a \u2264 sSup d :=\nhd.isLUB_sSup.1 ha", "start": [49, 1], "end": [50, 19], "kind": "mathlibtacticlemma"}, {"full_name": "DirectedOn.sSup_le", "code": "protected lemma DirectedOn.sSup_le (hd : DirectedOn (. \u2264 .) d) (ha : \u2200 b \u2208 d, b \u2264 a) : sSup d \u2264 a :=\nhd.isLUB_sSup.2 ha", "start": [52, 1], "end": [53, 19], "kind": "mathlibtacticlemma"}, {"full_name": "Directed.le_iSup", "code": "protected lemma Directed.le_iSup (hf : Directed (. \u2264 .) f) (i : \u03b9) : f i \u2264 \u2a06 j, f j :=\nhf.directedOn_range.le_sSup $ Set.mem_range_self _", "start": [55, 1], "end": [56, 51], "kind": "mathlibtacticlemma"}, {"full_name": "Directed.iSup_le", "code": "protected lemma Directed.iSup_le (hf : Directed (. \u2264 .) f) (ha : \u2200 i, f i \u2264 a) :  \u2a06 i, f i \u2264 a :=\nhf.directedOn_range.sSup_le $ Set.forall_range_iff.2 ha", "start": [58, 1], "end": [59, 56], "kind": "mathlibtacticlemma"}, {"full_name": "CompletePartialOrder.scottContinuous", "code": "lemma CompletePartialOrder.scottContinuous {f : \u03b1 \u2192 \u03b2} :\n    ScottContinuous f \u2194\n    \u2200 \u2983d : Set \u03b1\u2984, d.Nonempty \u2192 DirectedOn (. \u2264 .) d \u2192 IsLUB (f '' d) (f (sSup d)) := by\n  refine' \u27e8\u03bb h d hd\u2081 hd\u2082 \u21a6 h hd\u2081 hd\u2082 hd\u2082.isLUB_sSup, \u03bb h d hne hd a hda \u21a6 _\u27e9\n  rw [hda.unique hd.isLUB_sSup]\n  exact h hne hd", "start": [63, 1], "end": [69, 17], "kind": "mathlibtacticlemma"}, {"full_name": "CompletePartialOrder.toOmegaCompletePartialOrder", "code": "instance CompletePartialOrder.toOmegaCompletePartialOrder : OmegaCompletePartialOrder \u03b1 where\n  \u03c9Sup c := \u2a06 n, c n\n  le_\u03c9Sup c := c.directed.le_iSup\n  \u03c9Sup_le c _ := c.directed.iSup_le", "start": [73, 1], "end": [77, 36], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.toCompletePartialOrder", "code": "instance CompleteLattice.toCompletePartialOrder [CompleteLattice \u03b1] : CompletePartialOrder \u03b1 where\n  sSup := sSup\n  lubOfDirected _ _ := isLUB_sSup _", "start": [81, 1], "end": [84, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Separation/NotNormal.lean", "imports": ["Mathlib/Topology/Separation.lean", "Mathlib/Data/Real/Cardinality.lean", "Mathlib/Topology/TietzeExtension.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsClosed.mk_lt_continuum", "code": "theorem IsClosed.mk_lt_continuum [NormalSpace X] {s : Set X} (hs : IsClosed s)\n    [DiscreteTopology s] : #s < \ud835\udd20", "start": [21, 1], "end": [53, 57], "kind": "commanddeclaration"}, {"full_name": "IsClosed.not_normal_of_continuum_le_mk", "code": "theorem IsClosed.not_normal_of_continuum_le_mk {s : Set X} (hs : IsClosed s) [DiscreteTopology s]\n    (hmk : \ud835\udd20 \u2264 #s) : \u00acNormalSpace X", "start": [55, 1], "end": [58, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Partition.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Coloring.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.Partition", "code": "structure Partition where\n  \n  parts : Set (Set V)\n  \n  isPartition : Setoid.IsPartition parts\n  \n  independent : \u2200 s \u2208 parts, IsAntichain G.Adj s", "start": [54, 1], "end": [66, 49], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Partition.PartsCardLe", "code": "def Partition.PartsCardLe {G : SimpleGraph V} (P : G.Partition) (n : \u2115) : Prop :=\n  \u2203 h : P.parts.Finite, h.toFinset.card \u2264 n", "start": [69, 1], "end": [72, 44], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Partitionable", "code": "def Partitionable (n : \u2115) : Prop := \u2203 P : G.Partition, P.PartsCardLe n", "start": [75, 1], "end": [77, 71], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Partition.partOfVertex", "code": "def partOfVertex (v : V) : Set V := Classical.choose (P.isPartition.2 v)", "start": [84, 1], "end": [85, 73], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Partition.partOfVertex_mem", "code": "theorem partOfVertex_mem (v : V) : P.partOfVertex v \u2208 P.parts", "start": [88, 1], "end": [90, 10], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Partition.mem_partOfVertex", "code": "theorem mem_partOfVertex (v : V) : v \u2208 P.partOfVertex v", "start": [93, 1], "end": [95, 13], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Partition.partOfVertex_ne_of_adj", "code": "theorem partOfVertex_ne_of_adj {v w : V} (h : G.Adj v w) : P.partOfVertex v \u2260 P.partOfVertex w", "start": [98, 1], "end": [102, 91], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Partition.toColoring", "code": "def toColoring : G.Coloring P.parts :=\n  Coloring.mk (fun v \u21a6 \u27e8P.partOfVertex v, P.partOfVertex_mem v\u27e9) fun hvw \u21a6 by\n    rw [Ne.def, Subtype.mk_eq_mk]\n    exact P.partOfVertex_ne_of_adj hvw", "start": [105, 1], "end": [110, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Partition.toColoring'", "code": "def toColoring' : G.Coloring (Set V) :=\n  Coloring.mk P.partOfVertex fun hvw \u21a6 P.partOfVertex_ne_of_adj hvw", "start": [113, 1], "end": [115, 68], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Partition.to_colorable", "code": "theorem to_colorable [Fintype P.parts] : G.Colorable (Fintype.card P.parts)", "start": [118, 1], "end": [119, 28], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Coloring.toPartition", "code": "@[simps]\ndef Coloring.toPartition {\u03b1 : Type v} (C : G.Coloring \u03b1) : G.Partition\n    where\n  parts := C.colorClasses\n  isPartition := C.colorClasses_isPartition\n  independent := by\n    rintro s \u27e8c, rfl\u27e9\n    apply C.color_classes_independent", "start": [126, 1], "end": [134, 38], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.partitionable_iff_colorable", "code": "theorem partitionable_iff_colorable {n : \u2115} : G.Partitionable n \u2194 G.Colorable n", "start": [141, 1], "end": [152, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/ModuleCat/Presheaf.lean", "imports": ["Mathlib/Algebra/Category/Ring/Basic.lean", "Mathlib/Algebra/Category/ModuleCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PresheafOfModules", "code": "structure PresheafOfModules (R : C\u1d52\u1d56 \u2964 RingCat.{u}) where\n  presheaf : C\u1d52\u1d56 \u2964 AddCommGroupCat.{v}\n  module : \u2200 X : C\u1d52\u1d56, Module (R.obj X) (presheaf.obj X)\n  map_smul : \u2200 {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) (r : R.obj X) (x : presheaf.obj X),\n    presheaf.map f (r \u2022 x) = R.map f r \u2022 presheaf.map f x", "start": [32, 1], "end": [39, 58], "kind": "commanddeclaration"}, {"full_name": "PresheafOfModules.obj", "code": "def obj (P : PresheafOfModules R) (X : C\u1d52\u1d56) : ModuleCat (R.obj X) :=\n  ModuleCat.of _ (P.presheaf.obj X)", "start": [47, 1], "end": [49, 36], "kind": "commanddeclaration"}, {"full_name": "PresheafOfModules.map", "code": "def map (P : PresheafOfModules R) {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) :\n    P.obj X \u2192\u209b\u2097[R.map f] P.obj Y :=\n  { toAddHom := (P.presheaf.map f).toAddHom,\n    map_smul' := P.map_smul f, }", "start": [51, 1], "end": [59, 33], "kind": "commanddeclaration"}, {"full_name": "PresheafOfModules.map_apply", "code": "@[simp]\ntheorem map_apply (P : PresheafOfModules R) {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) (x) :\n    P.map f x = (P.presheaf.map f) x", "start": [61, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "PresheafOfModules.map_id", "code": "@[simp]\ntheorem map_id (P : PresheafOfModules R) (X : C\u1d52\u1d56) :\n    P.map (\ud835\udfd9 X) = LinearMap.id'", "start": [73, 1], "end": [77, 7], "kind": "commanddeclaration"}, {"full_name": "PresheafOfModules.map_comp", "code": "@[simp]\ntheorem map_comp (P : PresheafOfModules R) {X Y Z : C\u1d52\u1d56} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    P.map (f \u226b g) = (P.map g).comp (P.map f)", "start": [79, 1], "end": [83, 7], "kind": "commanddeclaration"}, {"full_name": "PresheafOfModules.Hom", "code": "structure Hom (P Q : PresheafOfModules R) where\n  hom : P.presheaf \u27f6 Q.presheaf\n  map_smul : \u2200 (X : C\u1d52\u1d56) (r : R.obj X) (x : P.presheaf.obj X), hom.app X (r \u2022 x) = r \u2022 hom.app X x", "start": [85, 1], "end": [88, 99], "kind": "commanddeclaration"}, {"full_name": "PresheafOfModules.Hom.id", "code": "def id (P : PresheafOfModules R) : Hom P P where\n  hom := \ud835\udfd9 _\n  map_smul _ _ _ := rfl", "start": [92, 1], "end": [95, 24], "kind": "commanddeclaration"}, {"full_name": "PresheafOfModules.Hom.comp", "code": "def comp {P Q R : PresheafOfModules R} (f : Hom P Q) (g : Hom Q R) : Hom P R where\n  hom := f.hom \u226b g.hom\n  map_smul _ _ _ := by simp [Hom.map_smul]", "start": [97, 1], "end": [100, 43], "kind": "commanddeclaration"}, {"full_name": "PresheafOfModules.Hom.app", "code": "def app (f : Hom P Q) (X : C\u1d52\u1d56) : P.obj X \u2192\u2097[R.obj X] Q.obj X :=\n  { toAddHom := (f.hom.app X).toAddHom\n    map_smul' := f.map_smul X }", "start": [113, 1], "end": [118, 32], "kind": "commanddeclaration"}, {"full_name": "PresheafOfModules.Hom.comp_app", "code": "@[simp]\nlemma comp_app (f : P \u27f6 Q) (g : Q \u27f6 T) (X : C\u1d52\u1d56) :\n    (f \u226b g).app X = (g.app X).comp (f.app X) := rfl", "start": [120, 1], "end": [122, 52], "kind": "mathlibtacticlemma"}, {"full_name": "PresheafOfModules.Hom.ext", "code": "@[ext]\ntheorem ext {f g : P \u27f6 Q} (w : \u2200 X, f.app X = g.app X) : f = g", "start": [124, 1], "end": [129, 36], "kind": "commanddeclaration"}, {"full_name": "PresheafOfModules.Hom.zero_app", "code": "@[simp]\nlemma zero_app (X : C\u1d52\u1d56) : (0 : P \u27f6 Q).app X = 0 := rfl", "start": [137, 1], "end": [138, 56], "kind": "mathlibtacticlemma"}, {"full_name": "PresheafOfModules.Hom.add_app", "code": "@[simp]\nlemma add_app (f g : P \u27f6 Q) (X : C\u1d52\u1d56) : (f + g).app X = f.app X + g.app X := rfl", "start": [146, 1], "end": [147, 81], "kind": "mathlibtacticlemma"}, {"full_name": "PresheafOfModules.Hom.sub_app", "code": "@[simp]\nlemma sub_app (f g : P \u27f6 Q) (X : C\u1d52\u1d56) : (f - g).app X = f.app X - g.app X := rfl", "start": [154, 1], "end": [155, 81], "kind": "mathlibtacticlemma"}, {"full_name": "PresheafOfModules.Hom.neg_app", "code": "@[simp]\nlemma neg_app (f : P \u27f6 Q) (X : C\u1d52\u1d56): (-f).app X = -f.app X := rfl", "start": [162, 1], "end": [163, 66], "kind": "mathlibtacticlemma"}, {"full_name": "PresheafOfModules.toPresheaf", "code": "@[simps obj]\ndef toPresheaf : PresheafOfModules R \u2964 (C\u1d52\u1d56 \u2964 AddCommGroupCat) where\n  obj P := P.presheaf\n  map f := f.hom", "start": [181, 1], "end": [187, 17], "kind": "commanddeclaration"}, {"full_name": "PresheafOfModules.toPresheaf_map_app", "code": "@[simp]\nlemma toPresheaf_map_app {P Q : PresheafOfModules R}\n    (f : P \u27f6 Q) (X : C\u1d52\u1d56) :\n    ((toPresheaf R).map f).app X = (f.app X).toAddMonoidHom := rfl", "start": [191, 1], "end": [194, 67], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/NumberTheory/ModularForms/CongruenceSubgroups.lean", "imports": ["Mathlib/Data/ZMod/Basic.lean", "Mathlib/GroupTheory/GroupAction/ConjAct.lean", "Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/Subgroup/Pointwise.lean"], "premises": [{"full_name": "SL_reduction_mod_hom_val", "code": "@[simp]\ntheorem SL_reduction_mod_hom_val (N : \u2115) (\u03b3 : SL(2, \u2124)) :\n    \u2200 i j : Fin 2, (SLMOD(N) \u03b3 : Matrix (Fin 2) (Fin 2) (ZMod N)) i j = ((\u2191\u2098\u03b3 i j : \u2124) : ZMod N)", "start": [39, 1], "end": [42, 17], "kind": "commanddeclaration"}, {"full_name": "Gamma", "code": "def Gamma (N : \u2115) : Subgroup SL(2, \u2124) :=\n  SLMOD(N).ker", "start": [45, 1], "end": [48, 15], "kind": "commanddeclaration"}, {"full_name": "Gamma_mem'", "code": "theorem Gamma_mem' (N : \u2115) (\u03b3 : SL(2, \u2124)) : \u03b3 \u2208 Gamma N \u2194 SLMOD(N) \u03b3 = 1", "start": [51, 1], "end": [52, 10], "kind": "commanddeclaration"}, {"full_name": "Gamma_mem", "code": "@[simp]\ntheorem Gamma_mem (N : \u2115) (\u03b3 : SL(2, \u2124)) : \u03b3 \u2208 Gamma N \u2194 ((\u2191\u2098\u03b3 0 0 : \u2124) : ZMod N) = 1 \u2227\n    ((\u2191\u2098\u03b3 0 1 : \u2124) : ZMod N) = 0 \u2227 ((\u2191\u2098\u03b3 1 0 : \u2124) : ZMod N) = 0 \u2227 ((\u2191\u2098\u03b3 1 1 : \u2124) : ZMod N) = 1", "start": [55, 1], "end": [66, 42], "kind": "commanddeclaration"}, {"full_name": "Gamma_normal", "code": "theorem Gamma_normal (N : \u2115) : Subgroup.Normal (Gamma N)", "start": [69, 1], "end": [70, 22], "kind": "commanddeclaration"}, {"full_name": "Gamma_one_top", "code": "theorem Gamma_one_top : Gamma 1 = \u22a4", "start": [73, 1], "end": [75, 7], "kind": "commanddeclaration"}, {"full_name": "Gamma_zero_bot", "code": "theorem Gamma_zero_bot : Gamma 0 = \u22a5", "start": [78, 1], "end": [88, 13], "kind": "commanddeclaration"}, {"full_name": "Gamma0", "code": "def Gamma0 (N : \u2115) : Subgroup SL(2, \u2124) where\n  carrier := { g : SL(2, \u2124) | ((\u2191\u2098g 1 0 : \u2124) : ZMod N) = 0 }\n  one_mem' := by simp\n  mul_mem' := by\n    intro a b ha hb\n    simp only [Set.mem_setOf_eq]\n    have h := (Matrix.two_mul_expl a.1 b.1).2.2.1\n    simp only [coe_matrix_coe, coe_mul, Int.coe_castRingHom, map_apply, Set.mem_setOf_eq] at *\n    rw [h]\n    simp [ha, hb]\n  inv_mem' := by\n    intro a ha\n    simp only [Set.mem_setOf_eq]\n    rw [SL2_inv_expl a]\n    simp only [cons_val_zero, cons_val_one, head_cons, coe_matrix_coe,\n      coe_mk, Int.coe_castRingHom, map_apply, Int.cast_neg, neg_eq_zero, Set.mem_setOf_eq] at *\n    exact ha", "start": [91, 1], "end": [109, 13], "kind": "commanddeclaration"}, {"full_name": "Gamma0_mem", "code": "@[simp]\ntheorem Gamma0_mem (N : \u2115) (A : SL(2, \u2124)) : A \u2208 Gamma0 N \u2194 ((\u2191\u2098A 1 0 : \u2124) : ZMod N) = 0", "start": [112, 1], "end": [114, 10], "kind": "commanddeclaration"}, {"full_name": "Gamma0_det", "code": "theorem Gamma0_det (N : \u2115) (A : Gamma0 N) : (A.1.1.det : ZMod N) = 1", "start": [117, 1], "end": [117, 95], "kind": "commanddeclaration"}, {"full_name": "Gamma0Map", "code": "def Gamma0Map (N : \u2115) : Gamma0 N \u2192* ZMod N where\n  toFun g := ((\u2191\u2098g 1 1 : \u2124) : ZMod N)\n  map_one' := by simp\n  map_mul' := by\n    intro A B\n    have := (two_mul_expl A.1.1 B.1.1).2.2.2\n    simp only [Subgroup.coe_mul, coe_matrix_coe, coe_mul, Int.coe_castRingHom, map_apply] at *\n    rw [this]\n    have ha := A.property\n    simp only [Int.cast_add, Int.cast_mul, add_left_eq_self, Gamma0_mem,\n      coe_matrix_coe, Int.coe_castRingHom, map_apply] at *\n    rw [ha]\n    simp", "start": [120, 1], "end": [134, 9], "kind": "commanddeclaration"}, {"full_name": "Gamma1'", "code": "def Gamma1' (N : \u2115) : Subgroup (Gamma0 N) :=\n  (Gamma0Map N).ker", "start": [137, 1], "end": [140, 20], "kind": "commanddeclaration"}, {"full_name": "Gamma1_mem'", "code": "@[simp, nolint simpNF] theorem Gamma1_mem' (N : \u2115) (\u03b3 : Gamma0 N) : \u03b3 \u2208 Gamma1' N \u2194 (Gamma0Map N) \u03b3 = 1", "start": [143, 1], "end": [145, 10], "kind": "commanddeclaration"}, {"full_name": "Gamma1_to_Gamma0_mem", "code": "theorem Gamma1_to_Gamma0_mem (N : \u2115) (A : Gamma0 N) : A \u2208 Gamma1' N \u2194\n    ((\u2191\u2098A 0 0 : \u2124) : ZMod N) = 1 \u2227 ((\u2191\u2098A 1 1 : \u2124) : ZMod N) = 1 \u2227 ((\u2191\u2098A 1 0 : \u2124) : ZMod N) = 0", "start": [148, 1], "end": [164, 17], "kind": "commanddeclaration"}, {"full_name": "Gamma1", "code": "def Gamma1 (N : \u2115) : Subgroup SL(2, \u2124) :=\n  Subgroup.map ((Gamma0 N).subtype.comp (Gamma1' N).subtype) \u22a4", "start": [167, 1], "end": [170, 63], "kind": "commanddeclaration"}, {"full_name": "Gamma1_mem", "code": "@[simp]\ntheorem Gamma1_mem (N : \u2115) (A : SL(2, \u2124)) : A \u2208 Gamma1 N \u2194\n    ((\u2191\u2098A 0 0 : \u2124) : ZMod N) = 1 \u2227 ((\u2191\u2098A 1 1 : \u2124) : ZMod N) = 1 \u2227 ((\u2191\u2098A 1 0 : \u2124) : ZMod N) = 0", "start": [173, 1], "end": [192, 9], "kind": "commanddeclaration"}, {"full_name": "Gamma1_in_Gamma0", "code": "theorem Gamma1_in_Gamma0 (N : \u2115) : Gamma1 N \u2264 Gamma0 N", "start": [195, 1], "end": [198, 15], "kind": "commanddeclaration"}, {"full_name": "IsCongruenceSubgroup", "code": "def IsCongruenceSubgroup (\u0393 : Subgroup SL(2, \u2124)) : Prop :=\n  \u2203 N : \u2115+, Gamma N \u2264 \u0393", "start": [203, 1], "end": [206, 24], "kind": "commanddeclaration"}, {"full_name": "isCongruenceSubgroup_trans", "code": "theorem isCongruenceSubgroup_trans (H K : Subgroup SL(2, \u2124)) (h : H \u2264 K)\n    (h2 : IsCongruenceSubgroup H) : IsCongruenceSubgroup K", "start": [209, 1], "end": [212, 29], "kind": "commanddeclaration"}, {"full_name": "Gamma_is_cong_sub", "code": "theorem Gamma_is_cong_sub (N : \u2115+) : IsCongruenceSubgroup (Gamma N)", "start": [215, 1], "end": [216, 30], "kind": "commanddeclaration"}, {"full_name": "Gamma1_is_congruence", "code": "theorem Gamma1_is_congruence (N : \u2115+) : IsCongruenceSubgroup (Gamma1 N)", "start": [219, 1], "end": [223, 49], "kind": "commanddeclaration"}, {"full_name": "Gamma0_is_congruence", "code": "theorem Gamma0_is_congruence (N : \u2115+) : IsCongruenceSubgroup (Gamma0 N)", "start": [226, 1], "end": [227, 79], "kind": "commanddeclaration"}, {"full_name": "Gamma_cong_eq_self", "code": "theorem Gamma_cong_eq_self (N : \u2115) (g : ConjAct SL(2, \u2124)) : g \u2022 Gamma N = Gamma N", "start": [236, 1], "end": [237, 49], "kind": "commanddeclaration"}, {"full_name": "conj_cong_is_cong", "code": "theorem conj_cong_is_cong (g : ConjAct SL(2, \u2124)) (\u0393 : Subgroup SL(2, \u2124))\n    (h : IsCongruenceSubgroup \u0393) : IsCongruenceSubgroup (g \u2022 \u0393)", "start": [240, 1], "end": [245, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/ClassNumber/FunctionField.lean", "imports": ["Mathlib/NumberTheory/FunctionField.lean", "Mathlib/NumberTheory/ClassNumber/Finite.lean", "Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FunctionField.classNumber", "code": "noncomputable def classNumber : \u2115 :=\n  Fintype.card (ClassGroup (ringOfIntegers Fq F))", "start": [50, 1], "end": [52, 50], "kind": "commanddeclaration"}, {"full_name": "FunctionField.classNumber_eq_one_iff", "code": "theorem classNumber_eq_one_iff :\n    classNumber Fq F = 1 \u2194 IsPrincipalIdealRing (ringOfIntegers Fq F)", "start": [55, 1], "end": [58, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Integral/IntervalAverage.lean", "imports": ["Mathlib/MeasureTheory/Integral/IntervalIntegral.lean", "Mathlib/MeasureTheory/Integral/Average.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "interval_average_symm", "code": "theorem interval_average_symm (f : \u211d \u2192 E) (a b : \u211d) : (\u2a0d x in a..b, f x) = \u2a0d x in b..a, f x", "start": [39, 1], "end": [40, 47], "kind": "commanddeclaration"}, {"full_name": "interval_average_eq", "code": "theorem interval_average_eq (f : \u211d \u2192 E) (a b : \u211d) :\n    (\u2a0d x in a..b, f x) = (b - a)\u207b\u00b9 \u2022 \u222b x in a..b, f x", "start": [43, 1], "end": [49, 91], "kind": "commanddeclaration"}, {"full_name": "interval_average_eq_div", "code": "theorem interval_average_eq_div (f : \u211d \u2192 \u211d) (a b : \u211d) :\n    (\u2a0d x in a..b, f x) = (\u222b x in a..b, f x) / (b - a)", "start": [52, 1], "end": [54, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/IncMatrix.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Basic.lean", "Mathlib/Data/Matrix/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.incMatrix", "code": "noncomputable def incMatrix [Zero R] [One R] : Matrix \u03b1 (Sym2 \u03b1) R := fun a =>\n  (G.incidenceSet a).indicator 1", "start": [54, 1], "end": [57, 33], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.incMatrix_apply", "code": "theorem incMatrix_apply [Zero R] [One R] {a : \u03b1} {e : Sym2 \u03b1} :\n    G.incMatrix R a e = (G.incidenceSet a).indicator 1 e", "start": [62, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.incMatrix_apply'", "code": "theorem incMatrix_apply' [Zero R] [One R] [DecidableEq \u03b1] [DecidableRel G.Adj] {a : \u03b1}\n    {e : Sym2 \u03b1} : G.incMatrix R a e = if e \u2208 G.incidenceSet a then 1 else 0", "start": [67, 1], "end": [71, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.incMatrix_apply_mul_incMatrix_apply", "code": "theorem incMatrix_apply_mul_incMatrix_apply : G.incMatrix R a e * G.incMatrix R b e =\n    (G.incidenceSet a \u2229 G.incidenceSet b).indicator 1 e", "start": [78, 1], "end": [81, 23], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.incMatrix_apply_mul_incMatrix_apply_of_not_adj", "code": "theorem incMatrix_apply_mul_incMatrix_apply_of_not_adj (hab : a \u2260 b) (h : \u00acG.Adj a b) :\n    G.incMatrix R a e * G.incMatrix R b e = 0", "start": [84, 1], "end": [88, 28], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.incMatrix_of_not_mem_incidenceSet", "code": "theorem incMatrix_of_not_mem_incidenceSet (h : e \u2209 G.incidenceSet a) : G.incMatrix R a e = 0", "start": [91, 1], "end": [92, 51], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.incMatrix_of_mem_incidenceSet", "code": "theorem incMatrix_of_mem_incidenceSet (h : e \u2208 G.incidenceSet a) : G.incMatrix R a e = 1", "start": [95, 1], "end": [96, 61], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.incMatrix_apply_eq_zero_iff", "code": "theorem incMatrix_apply_eq_zero_iff : G.incMatrix R a e = 0 \u2194 e \u2209 G.incidenceSet a", "start": [101, 1], "end": [102, 86], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.incMatrix_apply_eq_one_iff", "code": "theorem incMatrix_apply_eq_one_iff : G.incMatrix R a e = 1 \u2194 e \u2208 G.incidenceSet a", "start": [105, 1], "end": [111, 29], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.sum_incMatrix_apply", "code": "theorem sum_incMatrix_apply [DecidableEq \u03b1] [DecidableRel G.Adj] :\n    \u2211 e, G.incMatrix R a e = G.degree a", "start": [120, 1], "end": [122, 70], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.incMatrix_mul_transpose_diag", "code": "theorem incMatrix_mul_transpose_diag [DecidableEq \u03b1] [DecidableRel G.Adj] :\n    (G.incMatrix R * (G.incMatrix R)\u1d40) a a = G.degree a", "start": [125, 1], "end": [129, 38], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.sum_incMatrix_apply_of_mem_edgeSet", "code": "theorem sum_incMatrix_apply_of_mem_edgeSet :\n    e \u2208 G.edgeSet \u2192 \u2211 a, G.incMatrix R a e = 2", "start": [132, 1], "end": [142, 78], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.sum_incMatrix_apply_of_not_mem_edgeSet", "code": "theorem sum_incMatrix_apply_of_not_mem_edgeSet (h : e \u2209 G.edgeSet) :\n    \u2211 a, G.incMatrix R a e = 0", "start": [145, 1], "end": [147, 78], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.incMatrix_transpose_mul_diag", "code": "theorem incMatrix_transpose_mul_diag [DecidableRel G.Adj] :\n    ((G.incMatrix R)\u1d40 * G.incMatrix R) e e = if e \u2208 G.edgeSet then 2 else 0", "start": [150, 1], "end": [168, 62], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.incMatrix_mul_transpose_apply_of_adj", "code": "theorem incMatrix_mul_transpose_apply_of_adj (h : G.Adj a b) :\n    (G.incMatrix R * (G.incMatrix R)\u1d40) a b = (1 : R)", "start": [177, 1], "end": [185, 53], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.incMatrix_mul_transpose", "code": "theorem incMatrix_mul_transpose [Fintype \u03b1] [DecidableEq \u03b1] [DecidableRel G.Adj] :\n    G.incMatrix R * (G.incMatrix R)\u1d40 = fun a b =>\n      if a = b then (G.degree a : R) else if G.Adj a b then 1 else 0", "start": [188, 1], "end": [198, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Buffer/Parser/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/GroupTheory/GroupAction/Sum.lean", "imports": ["Mathlib/GroupTheory/GroupAction/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Sum.smul_def", "code": "@[to_additive]\ntheorem smul_def : a \u2022 x = x.map ((\u00b7 \u2022 \u00b7) a) ((\u00b7 \u2022 \u00b7) a)", "start": [37, 1], "end": [39, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.smul_inl", "code": "@[to_additive (attr := simp)]\ntheorem smul_inl : a \u2022 (inl b : Sum \u03b1 \u03b2) = inl (a \u2022 b)", "start": [43, 1], "end": [45, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.smul_inr", "code": "@[to_additive (attr := simp)]\ntheorem smul_inr : a \u2022 (inr c : Sum \u03b1 \u03b2) = inr (a \u2022 c)", "start": [49, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.smul_swap", "code": "@[to_additive (attr := simp)]\ntheorem smul_swap : (a \u2022 x).swap = a \u2022 x.swap", "start": [55, 1], "end": [56, 68], "kind": "commanddeclaration"}, {"full_name": "Sum.FaithfulSMulLeft", "code": "@[to_additive]\ninstance FaithfulSMulLeft [FaithfulSMul M \u03b1] : FaithfulSMul M (Sum \u03b1 \u03b2) :=\n  \u27e8fun h => eq_of_smul_eq_smul fun a : \u03b1 => by injection h (inl a)\u27e9", "start": [78, 1], "end": [80, 68], "kind": "commanddeclaration"}, {"full_name": "Sum.FaithfulSMulRight", "code": "@[to_additive]\ninstance FaithfulSMulRight [FaithfulSMul M \u03b2] : FaithfulSMul M (Sum \u03b1 \u03b2) :=\n  \u27e8fun h => eq_of_smul_eq_smul fun b : \u03b2 => by injection h (inr b)\u27e9", "start": [84, 1], "end": [86, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/PNat/Factors.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/PNat/Prime.lean", "Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "Mathlib/Data/Nat/Factors.lean", "Mathlib/Data/Multiset/Sort.lean"], "premises": [{"full_name": "PrimeMultiset", "code": "def PrimeMultiset :=\n  Multiset Nat.Primes deriving Inhabited, CanonicallyOrderedAddCommMonoid, DistribLattice,\n  SemilatticeSup, Sub", "start": [27, 1], "end": [32, 22], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.ofPrime", "code": "def ofPrime (p : Nat.Primes) : PrimeMultiset :=\n  ({p} : Multiset Nat.Primes)", "start": [46, 1], "end": [48, 30], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.card_ofPrime", "code": "theorem card_ofPrime (p : Nat.Primes) : Multiset.card (ofPrime p) = 1", "start": [51, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.toNatMultiset", "code": "def toNatMultiset : PrimeMultiset \u2192 Multiset \u2115 := fun v => v.map Coe.coe", "start": [55, 1], "end": [63, 73], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coeNat", "code": "instance coeNat : Coe PrimeMultiset (Multiset \u2115) :=\n  \u27e8toNatMultiset\u27e9", "start": [66, 1], "end": [67, 18], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coeNatMonoidHom", "code": "def coeNatMonoidHom : PrimeMultiset \u2192+ Multiset \u2115 :=\n  { Multiset.mapAddMonoidHom Coe.coe with toFun := Coe.coe }", "start": [70, 1], "end": [73, 61], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coe_coeNatMonoidHom", "code": "@[simp]\ntheorem coe_coeNatMonoidHom : (coeNatMonoidHom : PrimeMultiset \u2192 Multiset \u2115) = Coe.coe", "start": [76, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coeNat_injective", "code": "theorem coeNat_injective : Function.Injective (Coe.coe : PrimeMultiset \u2192 Multiset \u2115)", "start": [81, 1], "end": [82, 54], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coeNat_ofPrime", "code": "theorem coeNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset \u2115) = {(p : \u2115)}", "start": [85, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coeNat_prime", "code": "theorem coeNat_prime (v : PrimeMultiset) (p : \u2115) (h : p \u2208 (v : Multiset \u2115)) : p.Prime", "start": [89, 1], "end": [91, 19], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.toPNatMultiset", "code": "def toPNatMultiset : PrimeMultiset \u2192 Multiset \u2115+ := fun v => v.map Coe.coe", "start": [94, 1], "end": [95, 75], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coePNat", "code": "instance coePNat : Coe PrimeMultiset (Multiset \u2115+) :=\n  \u27e8toPNatMultiset\u27e9", "start": [98, 1], "end": [99, 19], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coePNatMonoidHom", "code": "def coePNatMonoidHom : PrimeMultiset \u2192+ Multiset \u2115+ :=\n  { Multiset.mapAddMonoidHom Coe.coe with toFun := Coe.coe }", "start": [102, 1], "end": [105, 61], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coe_coePNatMonoidHom", "code": "@[simp]\ntheorem coe_coePNatMonoidHom : (coePNatMonoidHom : PrimeMultiset \u2192 Multiset \u2115+) = Coe.coe", "start": [108, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coePNat_injective", "code": "theorem coePNat_injective : Function.Injective (Coe.coe : PrimeMultiset \u2192 Multiset \u2115+)", "start": [113, 1], "end": [114, 55], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coePNat_ofPrime", "code": "theorem coePNat_ofPrime (p : Nat.Primes) : (ofPrime p : Multiset \u2115+) = {(p : \u2115+)}", "start": [117, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coePNat_prime", "code": "theorem coePNat_prime (v : PrimeMultiset) (p : \u2115+) (h : p \u2208 (v : Multiset \u2115+)) : p.Prime", "start": [121, 1], "end": [123, 19], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coeMultisetPNatNat", "code": "instance coeMultisetPNatNat : Coe (Multiset \u2115+) (Multiset \u2115) :=\n  \u27e8fun v => v.map Coe.coe\u27e9", "start": [126, 1], "end": [127, 27], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coePNat_nat", "code": "theorem coePNat_nat (v : PrimeMultiset) : ((v : Multiset \u2115+) : Multiset \u2115) = (v : Multiset \u2115)", "start": [130, 1], "end": [133, 8], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.prod", "code": "def prod (v : PrimeMultiset) : \u2115+ :=\n  (v : Multiset PNat).prod", "start": [136, 1], "end": [138, 27], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.coe_prod", "code": "theorem coe_prod (v : PrimeMultiset) : (v.prod : \u2115) = (v : Multiset \u2115).prod", "start": [141, 1], "end": [146, 26], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.prod_ofPrime", "code": "theorem prod_ofPrime (p : Nat.Primes) : (ofPrime p).prod = (p : \u2115+)", "start": [149, 1], "end": [150, 28], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.ofNatMultiset", "code": "def ofNatMultiset (v : Multiset \u2115) (h : \u2200 p : \u2115, p \u2208 v \u2192 p.Prime) : PrimeMultiset :=\n  @Multiset.pmap \u2115 Nat.Primes Nat.Prime (fun p hp => \u27e8p, hp\u27e9) v h", "start": [153, 1], "end": [155, 66], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.to_ofNatMultiset", "code": "theorem to_ofNatMultiset (v : Multiset \u2115) (h) : (ofNatMultiset v h : Multiset \u2115) = v", "start": [158, 1], "end": [163, 70], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.prod_ofNatMultiset", "code": "theorem prod_ofNatMultiset (v : Multiset \u2115) (h) : ((ofNatMultiset v h).prod : \u2115) = (v.prod : \u2115)", "start": [166, 1], "end": [167, 37], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.ofPNatMultiset", "code": "def ofPNatMultiset (v : Multiset \u2115+) (h : \u2200 p : \u2115+, p \u2208 v \u2192 p.Prime) : PrimeMultiset :=\n  @Multiset.pmap \u2115+ Nat.Primes PNat.Prime (fun p hp => \u27e8(p : \u2115), hp\u27e9) v h", "start": [170, 1], "end": [172, 74], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.to_ofPNatMultiset", "code": "theorem to_ofPNatMultiset (v : Multiset \u2115+) (h) : (ofPNatMultiset v h : Multiset \u2115+) = v", "start": [175, 1], "end": [181, 70], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.prod_ofPNatMultiset", "code": "theorem prod_ofPNatMultiset (v : Multiset \u2115+) (h) : ((ofPNatMultiset v h).prod : \u2115+) = v.prod", "start": [184, 1], "end": [186, 25], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.ofNatList", "code": "def ofNatList (l : List \u2115) (h : \u2200 p : \u2115, p \u2208 l \u2192 p.Prime) : PrimeMultiset :=\n  ofNatMultiset (l : Multiset \u2115) h", "start": [189, 1], "end": [192, 35], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.prod_ofNatList", "code": "theorem prod_ofNatList (l : List \u2115) (h) : ((ofNatList l h).prod : \u2115) = l.prod", "start": [195, 1], "end": [198, 13], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.ofPNatList", "code": "def ofPNatList (l : List \u2115+) (h : \u2200 p : \u2115+, p \u2208 l \u2192 p.Prime) : PrimeMultiset :=\n  ofPNatMultiset (l : Multiset \u2115+) h", "start": [201, 1], "end": [204, 37], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.prod_ofPNatList", "code": "theorem prod_ofPNatList (l : List \u2115+) (h) : (ofPNatList l h).prod = l.prod", "start": [207, 1], "end": [210, 13], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.prod_zero", "code": "theorem prod_zero : (0 : PrimeMultiset).prod = 1", "start": [213, 1], "end": [216, 27], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.prod_add", "code": "theorem prod_add (u v : PrimeMultiset) : (u + v).prod = u.prod * v.prod", "start": [219, 1], "end": [222, 30], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.prod_smul", "code": "theorem prod_smul (d : \u2115) (u : PrimeMultiset) : (d \u2022 u).prod = Pow.pow u.prod d", "start": [226, 1], "end": [230, 74], "kind": "commanddeclaration"}, {"full_name": "PNat.factorMultiset", "code": "def factorMultiset (n : \u2115+) : PrimeMultiset :=\n  PrimeMultiset.ofNatList (Nat.factors n) (@Nat.prime_of_mem_factors n)", "start": [237, 1], "end": [239, 72], "kind": "commanddeclaration"}, {"full_name": "PNat.prod_factorMultiset", "code": "theorem prod_factorMultiset (n : \u2115+) : (factorMultiset n).prod = n", "start": [242, 1], "end": [247, 37], "kind": "commanddeclaration"}, {"full_name": "PNat.coeNat_factorMultiset", "code": "theorem coeNat_factorMultiset (n : \u2115+) :\n    (factorMultiset n : Multiset \u2115) = (Nat.factors n : Multiset \u2115)", "start": [250, 1], "end": [252, 79], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.factorMultiset_prod", "code": "theorem factorMultiset_prod (v : PrimeMultiset) : v.prod.factorMultiset = v", "start": [259, 1], "end": [273, 73], "kind": "commanddeclaration"}, {"full_name": "PNat.factorMultisetEquiv", "code": "def factorMultisetEquiv : \u2115+ \u2243 PrimeMultiset\n    where\n  toFun := factorMultiset\n  invFun := PrimeMultiset.prod\n  left_inv := prod_factorMultiset\n  right_inv := PrimeMultiset.factorMultiset_prod", "start": [280, 1], "end": [286, 49], "kind": "commanddeclaration"}, {"full_name": "PNat.factorMultiset_one", "code": "theorem factorMultiset_one : factorMultiset 1 = 0", "start": [289, 1], "end": [292, 78], "kind": "commanddeclaration"}, {"full_name": "PNat.factorMultiset_mul", "code": "theorem factorMultiset_mul (n m : \u2115+) :\n    factorMultiset (n * m) = factorMultiset n + factorMultiset m", "start": [295, 1], "end": [302, 49], "kind": "commanddeclaration"}, {"full_name": "PNat.factorMultiset_pow", "code": "theorem factorMultiset_pow (n : \u2115+) (m : \u2115) :\n    factorMultiset (Pow.pow n m) = m \u2022 factorMultiset n", "start": [305, 1], "end": [310, 49], "kind": "commanddeclaration"}, {"full_name": "PNat.factorMultiset_ofPrime", "code": "theorem factorMultiset_ofPrime (p : Nat.Primes) :\n    (p : \u2115+).factorMultiset = PrimeMultiset.ofPrime p", "start": [313, 1], "end": [318, 64], "kind": "commanddeclaration"}, {"full_name": "PNat.factorMultiset_le_iff", "code": "theorem factorMultiset_le_iff {m n : \u2115+} : factorMultiset m \u2264 factorMultiset n \u2194 m \u2223 n", "start": [321, 1], "end": [333, 22], "kind": "commanddeclaration"}, {"full_name": "PNat.factorMultiset_le_iff'", "code": "theorem factorMultiset_le_iff' {m : \u2115+} {v : PrimeMultiset} :\n    factorMultiset m \u2264 v \u2194 m \u2223 v.prod", "start": [336, 1], "end": [340, 10], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.prod_dvd_iff", "code": "theorem prod_dvd_iff {u v : PrimeMultiset} : u.prod \u2223 v.prod \u2194 u \u2264 v", "start": [347, 1], "end": [350, 15], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.prod_dvd_iff'", "code": "theorem prod_dvd_iff' {u : PrimeMultiset} {n : \u2115+} : u.prod \u2223 n \u2194 u \u2264 n.factorMultiset", "start": [353, 1], "end": [356, 10], "kind": "commanddeclaration"}, {"full_name": "PNat.factorMultiset_gcd", "code": "theorem factorMultiset_gcd (m n : \u2115+) :\n    factorMultiset (gcd m n) = factorMultiset m \u2293 factorMultiset n", "start": [363, 1], "end": [374, 23], "kind": "commanddeclaration"}, {"full_name": "PNat.factorMultiset_lcm", "code": "theorem factorMultiset_lcm (m n : \u2115+) :\n    factorMultiset (lcm m n) = factorMultiset m \u2294 factorMultiset n", "start": [377, 1], "end": [386, 28], "kind": "commanddeclaration"}, {"full_name": "PNat.count_factorMultiset", "code": "theorem count_factorMultiset (m : \u2115+) (p : Nat.Primes) (k : \u2115) :\n    Pow.pow (p : \u2115+) k \u2223 m \u2194 k \u2264 m.factorMultiset.count p", "start": [389, 1], "end": [402, 41], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.prod_inf", "code": "theorem prod_inf (u v : PrimeMultiset) : (u \u2293 v).prod = PNat.gcd u.prod v.prod", "start": [409, 1], "end": [415, 63], "kind": "commanddeclaration"}, {"full_name": "PrimeMultiset.prod_sup", "code": "theorem prod_sup (u v : PrimeMultiset) : (u \u2294 v).prod = PNat.lcm u.prod v.prod", "start": [418, 1], "end": [424, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Num/Prime.lean", "imports": ["Mathlib/Tactic/Ring.lean", "Mathlib/Data/Num/Lemmas.lean", "Mathlib/Data/Nat/Prime.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PosNum.minFacAux", "code": "def minFacAux (n : PosNum) : \u2115 \u2192 PosNum \u2192 PosNum\n  | 0, _ => n\n  | fuel + 1, k =>\n    if n < k.bit1 * k.bit1 then n else if k.bit1 \u2223 n then k.bit1 else minFacAux n fuel k.succ", "start": [31, 1], "end": [40, 94], "kind": "commanddeclaration"}, {"full_name": "PosNum.minFacAux_to_nat", "code": "theorem minFacAux_to_nat {fuel : \u2115} {n k : PosNum} (h : Nat.sqrt n < fuel + k.bit1) :\n    (minFacAux n fuel k : \u2115) = Nat.minFacAux n k.bit1", "start": [44, 1], "end": [54, 43], "kind": "commanddeclaration"}, {"full_name": "PosNum.minFac", "code": "def minFac : PosNum \u2192 PosNum\n  | 1 => 1\n  | bit0 _ => 2\n  | bit1 n => minFacAux (bit1 n) n 1", "start": [57, 1], "end": [61, 37], "kind": "commanddeclaration"}, {"full_name": "PosNum.minFac_to_nat", "code": "@[simp]\ntheorem minFac_to_nat (n : PosNum) : (minFac n : \u2115) = Nat.minFac n", "start": [64, 1], "end": [82, 9], "kind": "commanddeclaration"}, {"full_name": "PosNum.Prime", "code": "@[simp]\ndef Prime (n : PosNum) : Prop :=\n  Nat.Prime n", "start": [85, 1], "end": [88, 14], "kind": "commanddeclaration"}, {"full_name": "PosNum.decidablePrime", "code": "instance decidablePrime : DecidablePred PosNum.Prime\n  | 1 => Decidable.isFalse Nat.not_prime_one\n  | bit0 n =>\n    decidable_of_iff' (n = 1)\n      (by\n        refine' Nat.prime_def_minFac.trans ((and_iff_right _).trans <| eq_comm.trans _)\n        \u00b7 exact bit0_le_bit0.2 (Nat.succ_le_of_lt (to_nat_pos _))\n        rw [\u2190 minFac_to_nat, to_nat_inj]\n        exact \u27e8bit0.inj, congr_arg _\u27e9)\n  | bit1 n =>\n    decidable_of_iff' (minFacAux (bit1 n) n 1 = bit1 n)\n      (by\n        refine' Nat.prime_def_minFac.trans ((and_iff_right _).trans _)\n        \u00b7 exact Nat.bit0_le_bit1_iff.2 (to_nat_pos _)\n        rw [\u2190 minFac_to_nat, to_nat_inj]; rfl)", "start": [91, 1], "end": [105, 47], "kind": "commanddeclaration"}, {"full_name": "Num.minFac", "code": "def minFac : Num \u2192 PosNum\n  | 0 => 2\n  | pos n => n.minFac", "start": [112, 1], "end": [115, 22], "kind": "commanddeclaration"}, {"full_name": "Num.minFac_to_nat", "code": "@[simp]\ntheorem minFac_to_nat : \u2200 n : Num, (minFac n : \u2115) = Nat.minFac n", "start": [118, 1], "end": [121, 36], "kind": "commanddeclaration"}, {"full_name": "Num.Prime", "code": "@[simp]\ndef Prime (n : Num) : Prop :=\n  Nat.Prime n", "start": [124, 1], "end": [127, 14], "kind": "commanddeclaration"}, {"full_name": "Num.decidablePrime", "code": "instance decidablePrime : DecidablePred Num.Prime\n  | 0 => Decidable.isFalse Nat.not_prime_zero\n  | pos n => PosNum.decidablePrime n", "start": [130, 1], "end": [132, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Bitvec/Lemmas.lean", "imports": ["Mathlib/Tactic/NormNum.lean", "Mathlib/Data/Bitvec/Defs.lean", "Mathlib/Data/Fin/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Bitvec.bitsToNat_toList", "code": "theorem bitsToNat_toList {n : \u2115} (x : Bitvec n) : Bitvec.toNat x = bitsToNat (Vector.toList x)", "start": [22, 1], "end": [23, 6], "kind": "commanddeclaration"}, {"full_name": "Bitvec.toNat_append", "code": "theorem toNat_append {m : \u2115} (xs : Bitvec m) (b : Bool) :\n    Bitvec.toNat (xs++\u209cb ::\u1d65 Vector.nil) =\n      Bitvec.toNat xs * 2 + Bitvec.toNat (b ::\u1d65 Vector.nil)", "start": [33, 1], "end": [52, 16], "kind": "commanddeclaration"}, {"full_name": "Bitvec.bits_toNat_decide", "code": "theorem bits_toNat_decide (n : \u2115) : Bitvec.toNat (decide (n % 2 = 1) ::\u1d65 Vector.nil) = n % 2", "start": [59, 1], "end": [62, 52], "kind": "commanddeclaration"}, {"full_name": "Bitvec.ofNat_succ", "code": "theorem ofNat_succ {k n : \u2115} :\n    Bitvec.ofNat k.succ n = Bitvec.ofNat k (n / 2)++\u209cdecide (n % 2 = 1) ::\u1d65 Vector.nil", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "Bitvec.toNat_ofNat", "code": "theorem toNat_ofNat {k n : \u2115} : Bitvec.toNat (Bitvec.ofNat k n) = n % 2 ^ k", "start": [70, 1], "end": [74, 85], "kind": "commanddeclaration"}, {"full_name": "Bitvec.ofFin_val", "code": "theorem ofFin_val {n : \u2115} (i : Fin <| 2 ^ n) : (ofFin i).toNat = i.val", "start": [77, 1], "end": [79, 16], "kind": "commanddeclaration"}, {"full_name": "Bitvec.addLsb_eq_twice_add_one", "code": "theorem addLsb_eq_twice_add_one {x b} : addLsb x b = 2 * x + cond b 1 0", "start": [82, 1], "end": [83, 25], "kind": "commanddeclaration"}, {"full_name": "Bitvec.toNat_eq_foldr_reverse", "code": "theorem toNat_eq_foldr_reverse {n : \u2115} (v : Bitvec n) :\n    v.toNat = v.toList.reverse.foldr (flip addLsb) 0", "start": [86, 1], "end": [87, 88], "kind": "commanddeclaration"}, {"full_name": "Bitvec.toNat_lt", "code": "theorem toNat_lt {n : \u2115} (v : Bitvec n) : v.toNat < 2 ^ n", "start": [90, 1], "end": [109, 19], "kind": "commanddeclaration"}, {"full_name": "Bitvec.addLsb_div_two", "code": "theorem addLsb_div_two {x b} : addLsb x b / 2 = x", "start": [112, 1], "end": [116, 11], "kind": "commanddeclaration"}, {"full_name": "Bitvec.decide_addLsb_mod_two", "code": "theorem decide_addLsb_mod_two {x b} : decide (addLsb x b % 2 = 1) = b", "start": [119, 1], "end": [122, 75], "kind": "commanddeclaration"}, {"full_name": "Bitvec.ofNat_toNat", "code": "theorem ofNat_toNat {n : \u2115} (v : Bitvec n) : Bitvec.ofNat n v.toNat = v", "start": [125, 1], "end": [144, 8], "kind": "commanddeclaration"}, {"full_name": "Bitvec.toFin_val", "code": "theorem toFin_val {n : \u2115} (v : Bitvec n) : (toFin v : \u2115) = v.toNat", "start": [147, 1], "end": [149, 17], "kind": "commanddeclaration"}, {"full_name": "Bitvec.toFin_le_toFin_of_le", "code": "theorem toFin_le_toFin_of_le {n} {v\u2080 v\u2081 : Bitvec n} (h : v\u2080 \u2264 v\u2081) : v\u2080.toFin \u2264 v\u2081.toFin", "start": [152, 1], "end": [155, 12], "kind": "commanddeclaration"}, {"full_name": "Bitvec.ofFin_le_ofFin_of_le", "code": "theorem ofFin_le_ofFin_of_le {n : \u2115} {i j : Fin (2 ^ n)} (h : i \u2264 j) : ofFin i \u2264 ofFin j", "start": [158, 1], "end": [161, 12], "kind": "commanddeclaration"}, {"full_name": "Bitvec.toFin_ofFin", "code": "theorem toFin_ofFin {n} (i : Fin <| 2 ^ n) : (ofFin i).toFin = i", "start": [164, 1], "end": [165, 85], "kind": "commanddeclaration"}, {"full_name": "Bitvec.ofFin_toFin", "code": "theorem ofFin_toFin {n} (v : Bitvec n) : ofFin (toFin v) = v", "start": [168, 1], "end": [170, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/InnerProductSpace/Positive.lean", "imports": ["Mathlib/Analysis/InnerProductSpace/Adjoint.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousLinearMap.IsPositive", "code": "def IsPositive (T : E \u2192L[\ud835\udd5c] E) : Prop :=\n  IsSelfAdjoint T \u2227 \u2200 x, 0 \u2264 T.reApplyInnerSelf x", "start": [55, 1], "end": [58, 50], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.IsPositive.isSelfAdjoint", "code": "theorem IsPositive.isSelfAdjoint {T : E \u2192L[\ud835\udd5c] E} (hT : IsPositive T) : IsSelfAdjoint T", "start": [61, 1], "end": [62, 7], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.IsPositive.inner_nonneg_left", "code": "theorem IsPositive.inner_nonneg_left {T : E \u2192L[\ud835\udd5c] E} (hT : IsPositive T) (x : E) :\n    0 \u2264 re \u27eaT x, x\u27eb", "start": [65, 1], "end": [67, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.IsPositive.inner_nonneg_right", "code": "theorem IsPositive.inner_nonneg_right {T : E \u2192L[\ud835\udd5c] E} (hT : IsPositive T) (x : E) :\n    0 \u2264 re \u27eax, T x\u27eb", "start": [70, 1], "end": [71, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isPositive_zero", "code": "theorem isPositive_zero : IsPositive (0 : E \u2192L[\ud835\udd5c] E)", "start": [74, 1], "end": [77, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isPositive_one", "code": "theorem isPositive_one : IsPositive (1 : E \u2192L[\ud835\udd5c] E)", "start": [80, 1], "end": [81, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.IsPositive.add", "code": "theorem IsPositive.add {T S : E \u2192L[\ud835\udd5c] E} (hT : T.IsPositive) (hS : S.IsPositive) :\n    (T + S).IsPositive", "start": [84, 1], "end": [88, 69], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.IsPositive.conj_adjoint", "code": "theorem IsPositive.conj_adjoint {T : E \u2192L[\ud835\udd5c] E} (hT : T.IsPositive) (S : E \u2192L[\ud835\udd5c] F) :\n    (S \u2218L T \u2218L S\u2020).IsPositive", "start": [91, 1], "end": [95, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.IsPositive.adjoint_conj", "code": "theorem IsPositive.adjoint_conj {T : E \u2192L[\ud835\udd5c] E} (hT : T.IsPositive) (S : F \u2192L[\ud835\udd5c] E) :\n    (S\u2020 \u2218L T \u2218L S).IsPositive", "start": [98, 1], "end": [101, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.IsPositive.conj_orthogonalProjection", "code": "theorem IsPositive.conj_orthogonalProjection (U : Submodule \ud835\udd5c E) {T : E \u2192L[\ud835\udd5c] E} (hT : T.IsPositive)\n    [CompleteSpace U] :\n    (U.subtypeL \u2218L\n        orthogonalProjection U \u2218L T \u2218L U.subtypeL \u2218L orthogonalProjection U).IsPositive", "start": [104, 1], "end": [109, 66], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.IsPositive.orthogonalProjection_comp", "code": "theorem IsPositive.orthogonalProjection_comp {T : E \u2192L[\ud835\udd5c] E} (hT : T.IsPositive) (U : Submodule \ud835\udd5c E)\n    [CompleteSpace U] : (orthogonalProjection U \u2218L T \u2218L U.subtypeL).IsPositive", "start": [112, 1], "end": [115, 47], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isPositive_iff_complex", "code": "theorem isPositive_iff_complex (T : E' \u2192L[\u2102] E') :\n    IsPositive T \u2194 \u2200 x, (re \u27eaT x, x\u27eb_\u2102 : \u2102) = \u27eaT x, x\u27eb_\u2102 \u2227 0 \u2264 re \u27eaT x, x\u27eb_\u2102", "start": [122, 1], "end": [126, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/QuadraticForm/Complex.lean", "imports": ["Mathlib/LinearAlgebra/QuadraticForm/IsometryEquiv.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "QuadraticForm.isometryEquivSumSquares", "code": "noncomputable def isometryEquivSumSquares [DecidableEq \u03b9] (w' : \u03b9 \u2192 \u2102) :\n    IsometryEquiv (weightedSumSquares \u2102 w')\n      (weightedSumSquares \u2102 (fun i => if w' i = 0 then 0 else 1 : \u03b9 \u2192 \u2102)) := by\n  let w i := if h : w' i = 0 then (1 : Units \u2102) else Units.mk0 (w' i) h\n  have hw' : \u2200 i : \u03b9, (w i : \u2102) ^ (-(1 / 2 : \u2102)) \u2260 0 := by\n    intro i hi\n    exact (w i).ne_zero ((Complex.cpow_eq_zero_iff _ _).1 hi).1\n  convert (weightedSumSquares \u2102 w').isometryEquivBasisRepr\n    ((Pi.basisFun \u2102 \u03b9).unitsSMul fun i => (isUnit_iff_ne_zero.2 <| hw' i).unit)\n  ext1 v\n  erw [basisRepr_apply, weightedSumSquares_apply, weightedSumSquares_apply]\n  refine' sum_congr rfl fun j hj => _\n  have hsum : (\u2211 i : \u03b9, v i \u2022 ((isUnit_iff_ne_zero.2 <| hw' i).unit : \u2102) \u2022 (Pi.basisFun \u2102 \u03b9) i) j =\n      v j \u2022 w j ^ (-(1 / 2 : \u2102)) := by\n    rw [Finset.sum_apply, sum_eq_single j, Pi.basisFun_apply, IsUnit.unit_spec,\n      LinearMap.stdBasis_apply, Pi.smul_apply, Pi.smul_apply, Function.update_same, smul_eq_mul,\n      smul_eq_mul, smul_eq_mul, mul_one]\n    intro i _ hij\n    rw [Pi.basisFun_apply, LinearMap.stdBasis_apply, Pi.smul_apply, Pi.smul_apply,\n      Function.update_noteq hij.symm, Pi.zero_apply, smul_eq_mul, smul_eq_mul,\n      mul_zero, mul_zero]\n    intro hj'; exact False.elim (hj' hj)\n  simp_rw [Basis.unitsSMul_apply]\n  erw [hsum, smul_eq_mul]\n  split_ifs with h\n  \u00b7 simp only [h, zero_smul, zero_mul]\n  have hww' : w' j = w j := by simp only [dif_neg h, Units.val_mk0]\n  simp only [one_mul, Units.val_mk0, smul_eq_mul]\n  rw [hww']\n  suffices v j * v j = w j ^ (-(1 / 2 : \u2102)) * w j ^ (-(1 / 2 : \u2102)) * w j * v j * v j by\n    rw [this]; ring\n  rw [\u2190 Complex.cpow_add _ _ (w j).ne_zero, show -(1 / 2 : \u2102) + -(1 / 2) = -1 by simp [\u2190 two_mul],\n    Complex.cpow_neg_one, inv_mul_cancel (w j).ne_zero, one_mul]", "start": [28, 1], "end": [62, 65], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.isometryEquivSumSquaresUnits", "code": "noncomputable def isometryEquivSumSquaresUnits [DecidableEq \u03b9] (w : \u03b9 \u2192 Units \u2102) :\n    IsometryEquiv (weightedSumSquares \u2102 w) (weightedSumSquares \u2102 (1 : \u03b9 \u2192 \u2102)) := by\n  simpa using isometryEquivSumSquares ((\u2191) \u2218 w)", "start": [65, 1], "end": [69, 48], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.equivalent_sum_squares", "code": "theorem equivalent_sum_squares {M : Type*} [AddCommGroup M] [Module \u2102 M] [FiniteDimensional \u2102 M]\n    (Q : QuadraticForm \u2102 M) (hQ : (associated (R := \u2102) Q).Nondegenerate) :\n    Equivalent Q (weightedSumSquares \u2102 (1 : Fin (FiniteDimensional.finrank \u2102 M) \u2192 \u2102))", "start": [72, 1], "end": [78, 47], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.complex_equivalent", "code": "theorem complex_equivalent {M : Type*} [AddCommGroup M] [Module \u2102 M] [FiniteDimensional \u2102 M]\n    (Q\u2081 Q\u2082 : QuadraticForm \u2102 M) (hQ\u2081 : (associated (R := \u2102) Q\u2081).Nondegenerate)\n    (hQ\u2082 : (associated (R := \u2102) Q\u2082).Nondegenerate) : Equivalent Q\u2081 Q\u2082", "start": [81, 1], "end": [85, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/ParametricIntervalIntegral.lean", "imports": ["Mathlib/MeasureTheory/Integral/IntervalIntegral.lean", "Mathlib/Analysis/Calculus/ParametricIntegral.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "intervalIntegral.hasFDerivAt_integral_of_dominated_loc_of_lip", "code": "nonrec theorem hasFDerivAt_integral_of_dominated_loc_of_lip\n    {F : H \u2192 \u211d \u2192 E} {F' : \u211d \u2192 H \u2192L[\ud835\udd5c] E} {x\u2080 : H}\n    (\u03b5_pos : 0 < \u03b5) (hF_meas : \u2200\u1da0 x in \ud835\udcdd x\u2080, AEStronglyMeasurable (F x) (\u03bc.restrict (\u0399 a b)))\n    (hF_int : IntervalIntegrable (F x\u2080) \u03bc a b)\n    (hF'_meas : AEStronglyMeasurable F' (\u03bc.restrict (\u0399 a b)))\n    (h_lip : \u2200\u1d50 t \u2202\u03bc, t \u2208 \u0399 a b \u2192\n      LipschitzOnWith (Real.nnabs <| bound t) (fun x => F x t) (ball x\u2080 \u03b5))\n    (bound_integrable : IntervalIntegrable bound \u03bc a b)\n    (h_diff : \u2200\u1d50 t \u2202\u03bc, t \u2208 \u0399 a b \u2192 HasFDerivAt (fun x => F x t) (F' t) x\u2080) :\n    IntervalIntegrable F' \u03bc a b \u2227\n      HasFDerivAt (fun x => \u222b t in a..b, F x t \u2202\u03bc) (\u222b t in a..b, F' t \u2202\u03bc) x\u2080", "start": [28, 1], "end": [48, 38], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.hasFDerivAt_integral_of_dominated_of_fderiv_le", "code": "nonrec theorem hasFDerivAt_integral_of_dominated_of_fderiv_le\n    {F : H \u2192 \u211d \u2192 E} {F' : H \u2192 \u211d \u2192 H \u2192L[\ud835\udd5c] E} {x\u2080 : H} (\u03b5_pos : 0 < \u03b5)\n    (hF_meas : \u2200\u1da0 x in \ud835\udcdd x\u2080, AEStronglyMeasurable (F x) (\u03bc.restrict (\u0399 a b)))\n    (hF_int : IntervalIntegrable (F x\u2080) \u03bc a b)\n    (hF'_meas : AEStronglyMeasurable (F' x\u2080) (\u03bc.restrict (\u0399 a b)))\n    (h_bound : \u2200\u1d50 t \u2202\u03bc, t \u2208 \u0399 a b \u2192 \u2200 x \u2208 ball x\u2080 \u03b5, \u2016F' x t\u2016 \u2264 bound t)\n    (bound_integrable : IntervalIntegrable bound \u03bc a b)\n    (h_diff : \u2200\u1d50 t \u2202\u03bc, t \u2208 \u0399 a b \u2192 \u2200 x \u2208 ball x\u2080 \u03b5, HasFDerivAt (fun x => F x t) (F' x t) x) :\n    HasFDerivAt (fun x => \u222b t in a..b, F x t \u2202\u03bc) (\u222b t in a..b, F' x\u2080 t \u2202\u03bc) x\u2080", "start": [51, 1], "end": [68, 42], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.hasDerivAt_integral_of_dominated_loc_of_lip", "code": "nonrec theorem hasDerivAt_integral_of_dominated_loc_of_lip {F : \ud835\udd5c \u2192 \u211d \u2192 E} {F' : \u211d \u2192 E} {x\u2080 : \ud835\udd5c}\n    (\u03b5_pos : 0 < \u03b5) (hF_meas : \u2200\u1da0 x in \ud835\udcdd x\u2080, AEStronglyMeasurable (F x) (\u03bc.restrict (\u0399 a b)))\n    (hF_int : IntervalIntegrable (F x\u2080) \u03bc a b)\n    (hF'_meas : AEStronglyMeasurable F' (\u03bc.restrict (\u0399 a b)))\n    (h_lipsch : \u2200\u1d50 t \u2202\u03bc, t \u2208 \u0399 a b \u2192\n      LipschitzOnWith (Real.nnabs <| bound t) (fun x => F x t) (ball x\u2080 \u03b5))\n    (bound_integrable : IntervalIntegrable (bound : \u211d \u2192 \u211d) \u03bc a b)\n    (h_diff : \u2200\u1d50 t \u2202\u03bc, t \u2208 \u0399 a b \u2192 HasDerivAt (fun x => F x t) (F' t) x\u2080) :\n    IntervalIntegrable F' \u03bc a b \u2227\n      HasDerivAt (fun x => \u222b t in a..b, F x t \u2202\u03bc) (\u222b t in a..b, F' t \u2202\u03bc) x\u2080", "start": [71, 1], "end": [90, 38], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.hasDerivAt_integral_of_dominated_loc_of_deriv_le", "code": "nonrec theorem hasDerivAt_integral_of_dominated_loc_of_deriv_le\n    {F : \ud835\udd5c \u2192 \u211d \u2192 E} {F' : \ud835\udd5c \u2192 \u211d \u2192 E} {x\u2080 : \ud835\udd5c}\n    (\u03b5_pos : 0 < \u03b5) (hF_meas : \u2200\u1da0 x in \ud835\udcdd x\u2080, AEStronglyMeasurable (F x) (\u03bc.restrict (\u0399 a b)))\n    (hF_int : IntervalIntegrable (F x\u2080) \u03bc a b)\n    (hF'_meas : AEStronglyMeasurable (F' x\u2080) (\u03bc.restrict (\u0399 a b)))\n    (h_bound : \u2200\u1d50 t \u2202\u03bc, t \u2208 \u0399 a b \u2192 \u2200 x \u2208 ball x\u2080 \u03b5, \u2016F' x t\u2016 \u2264 bound t)\n    (bound_integrable : IntervalIntegrable bound \u03bc a b)\n    (h_diff : \u2200\u1d50 t \u2202\u03bc, t \u2208 \u0399 a b \u2192 \u2200 x \u2208 ball x\u2080 \u03b5, HasDerivAt (fun x => F x t) (F' x t) x) :\n    IntervalIntegrable (F' x\u2080) \u03bc a b \u2227\n      HasDerivAt (fun x => \u222b t in a..b, F x t \u2202\u03bc) (\u222b t in a..b, F' x\u2080 t \u2202\u03bc) x\u2080", "start": [93, 1], "end": [112, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Subadditive.lean", "imports": ["Mathlib/Topology/Instances/Real.lean", "Mathlib/Order/Filter/Archimedean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subadditive", "code": "def Subadditive (u : \u2115 \u2192 \u211d) : Prop :=\n  \u2200 m n, u (m + n) \u2264 u m + u n", "start": [28, 1], "end": [31, 31], "kind": "commanddeclaration"}, {"full_name": "Subadditive.lim", "code": "@[nolint unusedArguments] protected def lim (_h : Subadditive u) :=\n  sInf ((fun n : \u2115 => u n / n) '' Ici 1)", "start": [38, 1], "end": [42, 41], "kind": "commanddeclaration"}, {"full_name": "Subadditive.lim_le_div", "code": "theorem lim_le_div (hbdd : BddBelow (range fun n => u n / n)) {n : \u2115} (hn : n \u2260 0) :\n    h.lim \u2264 u n / n", "start": [45, 1], "end": [48, 75], "kind": "commanddeclaration"}, {"full_name": "Subadditive.apply_mul_add_le", "code": "theorem apply_mul_add_le (k n r) : u (k * n + r) \u2264 k * u n + u r", "start": [51, 1], "end": [59, 51], "kind": "commanddeclaration"}, {"full_name": "Subadditive.eventually_div_lt_of_div_lt", "code": "theorem eventually_div_lt_of_div_lt {L : \u211d} {n : \u2115} (hn : n \u2260 0) (hL : u n / n < L) :\n    \u2200\u1da0 p in atTop, u p / p < L", "start": [62, 1], "end": [81, 72], "kind": "commanddeclaration"}, {"full_name": "Subadditive.tendsto_lim", "code": "theorem tendsto_lim (hbdd : BddBelow (range fun n => u n / n)) :\n    Tendsto (fun n => u n / n) atTop (\ud835\udcdd h.lim)", "start": [84, 1], "end": [95, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Order/Priestley.lean", "imports": ["Mathlib/Order/UpperLower/Basic.lean", "Mathlib/Topology/Separation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PriestleySpace", "code": "class PriestleySpace (\u03b1 : Type*) [Preorder \u03b1] [TopologicalSpace \u03b1] : Prop where\n  priestley {x y : \u03b1} : \u00acx \u2264 y \u2192 \u2203 U : Set \u03b1, IsClopen U \u2227 IsUpperSet U \u2227 x \u2208 U \u2227 y \u2209 U", "start": [38, 1], "end": [41, 88], "kind": "commanddeclaration"}, {"full_name": "exists_clopen_upper_of_not_le", "code": "theorem exists_clopen_upper_of_not_le :\n    \u00acx \u2264 y \u2192 \u2203 U : Set \u03b1, IsClopen U \u2227 IsUpperSet U \u2227 x \u2208 U \u2227 y \u2209 U", "start": [50, 1], "end": [52, 27], "kind": "commanddeclaration"}, {"full_name": "exists_clopen_lower_of_not_le", "code": "theorem exists_clopen_lower_of_not_le (h : \u00acx \u2264 y) :\n    \u2203 U : Set \u03b1, IsClopen U \u2227 IsLowerSet U \u2227 x \u2209 U \u2227 y \u2208 U", "start": [55, 1], "end": [58, 56], "kind": "commanddeclaration"}, {"full_name": "exists_clopen_upper_or_lower_of_ne", "code": "theorem exists_clopen_upper_or_lower_of_ne (h : x \u2260 y) :\n    \u2203 U : Set \u03b1, IsClopen U \u2227 (IsUpperSet U \u2228 IsLowerSet U) \u2227 x \u2208 U \u2227 y \u2209 U", "start": [67, 1], "end": [72, 38], "kind": "commanddeclaration"}, {"full_name": "PriestleySpace.toT2Space", "code": "instance (priority := 100) PriestleySpace.toT2Space : T2Space \u03b1 :=\n  \u27e8fun _ _ h \u21a6\n    let \u27e8U, hU, _, hx, hy\u27e9 := exists_clopen_upper_or_lower_of_ne h\n    \u27e8U, U\u1d9c, hU.isOpen, hU.compl.isOpen, hx, hy, disjoint_compl_right\u27e9\u27e9", "start": [76, 1], "end": [79, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/FP/Basic.lean", "imports": ["Mathlib/Data/Semiquot.lean", "Mathlib/Data/Rat/Floor.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.shift2", "code": "@[nolint docBlame]\ndef Int.shift2 (a b : \u2115) : \u2124 \u2192 \u2115 \u00d7 \u2115\n  | Int.ofNat e => (a <<< e, b)\n  | Int.negSucc e => (a, b <<< e.succ)", "start": [17, 1], "end": [20, 39], "kind": "commanddeclaration"}, {"full_name": "FP.RMode", "code": "@[nolint docBlame]\ninductive RMode\n  | NE deriving Inhabited", "start": [25, 1], "end": [28, 21], "kind": "commanddeclaration"}, {"full_name": "FP.FloatCfg", "code": "@[nolint docBlame]\nclass FloatCfg where\n  (prec emax : \u2115)\n  precPos : 0 < prec\n  precMax : prec \u2264 emax", "start": [31, 1], "end": [35, 24], "kind": "commanddeclaration"}, {"full_name": "FP.prec", "code": "@[nolint docBlame]\ndef prec :=\n  C.prec", "start": [41, 1], "end": [43, 9], "kind": "commanddeclaration"}, {"full_name": "FP.emax", "code": "@[nolint docBlame]\ndef emax :=\n  C.emax", "start": [46, 1], "end": [48, 9], "kind": "commanddeclaration"}, {"full_name": "FP.emin", "code": "@[nolint docBlame]\ndef emin : \u2124 :=\n  1 - C.emax", "start": [51, 1], "end": [53, 13], "kind": "commanddeclaration"}, {"full_name": "FP.ValidFinite", "code": "@[nolint docBlame]\ndef ValidFinite (e : \u2124) (m : \u2115) : Prop :=\n  emin \u2264 e + prec - 1 \u2227 e + prec - 1 \u2264 emax \u2227 e = max (e + m.size - prec) emin", "start": [56, 1], "end": [58, 79], "kind": "commanddeclaration"}, {"full_name": "FP.decValidFinite", "code": "instance decValidFinite (e m) : Decidable (ValidFinite e m) := by\n  (unfold ValidFinite; infer_instance)", "start": [61, 1], "end": [62, 39], "kind": "commanddeclaration"}, {"full_name": "FP.Float", "code": "@[nolint docBlame]\ninductive Float\n  | inf : Bool \u2192 Float\n  | nan : Float\n  | finite : Bool \u2192 \u2200 e m, ValidFinite e m \u2192 Float", "start": [65, 1], "end": [69, 51], "kind": "commanddeclaration"}, {"full_name": "FP.Float.isFinite", "code": "@[nolint docBlame]\ndef Float.isFinite : Float \u2192 Bool\n  | Float.finite _ _ _ _ => true\n  | _ => false", "start": [72, 1], "end": [75, 15], "kind": "commanddeclaration"}, {"full_name": "FP.toRat", "code": "@[nolint docBlame]\ndef toRat : \u2200 f : Float, f.isFinite \u2192 \u211a\n  | Float.finite s e m _, _ =>\n    let (n, d) := Int.shift2 m 1 e\n    let r := mkRat n d\n    if s then -r else r", "start": [78, 1], "end": [83, 24], "kind": "commanddeclaration"}, {"full_name": "FP.Float.Zero.valid", "code": "theorem Float.Zero.valid : ValidFinite emin 0", "start": [86, 1], "end": [101, 51], "kind": "commanddeclaration"}, {"full_name": "FP.Float.zero", "code": "@[nolint docBlame]\ndef Float.zero (s : Bool) : Float :=\n  Float.finite s emin 0 Float.Zero.valid", "start": [104, 1], "end": [106, 41], "kind": "commanddeclaration"}, {"full_name": "FP.Float.sign'", "code": "@[nolint docBlame]\nprotected def Float.sign' : Float \u2192 Semiquot Bool\n  | Float.inf s => pure s\n  | Float.nan => \u22a4\n  | Float.finite s _ _ _ => pure s", "start": [112, 1], "end": [116, 35], "kind": "commanddeclaration"}, {"full_name": "FP.Float.sign", "code": "@[nolint docBlame]\nprotected def Float.sign : Float \u2192 Bool\n  | Float.inf s => s\n  | Float.nan => false\n  | Float.finite s _ _ _ => s", "start": [119, 1], "end": [123, 30], "kind": "commanddeclaration"}, {"full_name": "FP.Float.isZero", "code": "@[nolint docBlame]\nprotected def Float.isZero : Float \u2192 Bool\n  | Float.finite _ _ 0 _ => true\n  | _ => false", "start": [126, 1], "end": [129, 15], "kind": "commanddeclaration"}, {"full_name": "FP.Float.neg", "code": "@[nolint docBlame]\nprotected def Float.neg : Float \u2192 Float\n  | Float.inf s => Float.inf (not s)\n  | Float.nan => Float.nan\n  | Float.finite s e m f => Float.finite (not s) e m f", "start": [132, 1], "end": [136, 55], "kind": "commanddeclaration"}, {"full_name": "FP.divNatLtTwoPow", "code": "@[nolint docBlame]\ndef divNatLtTwoPow (n d : \u2115) : \u2124 \u2192 Bool\n  | Int.ofNat e => n < d <<< e\n  | Int.negSucc e => n <<< e.succ < d", "start": [139, 1], "end": [142, 38], "kind": "commanddeclaration"}, {"full_name": "FP.ofPosRatDn", "code": "@[nolint docBlame]\nunsafe def ofPosRatDn (n : \u2115+) (d : \u2115+) : Float \u00d7 Bool := by\n  let e\u2081 : \u2124 := n.1.size - d.1.size - prec\n  cases' h\u2081 : Int.shift2 d.1 n.1 (e\u2081 + prec) with d\u2081 n\u2081\n  let e\u2082 := if n\u2081 < d\u2081 then e\u2081 - 1 else e\u2081\n  let e\u2083 := max e\u2082 emin\n  cases' h\u2082 : Int.shift2 d.1 n.1 (e\u2083 + prec) with d\u2082 n\u2082\n  let r := mkRat n\u2082 d\u2082\n  let m := r.floor\n  refine' (Float.finite Bool.false e\u2083 (Int.toNat m) _, r.den = 1)\n  \u00b7 exact lcProof", "start": [147, 1], "end": [157, 18], "kind": "commanddeclaration"}, {"full_name": "FP.nextUpPos", "code": "@[nolint docBlame]\nunsafe def nextUpPos (e m) (v : ValidFinite e m) : Float :=\n  let m' := m.succ\n  if ss : m'.size = m.size then\n    Float.finite false e m' (by unfold ValidFinite at *; rw [ss]; exact v)\n  else if h : e = emax then Float.inf false else Float.finite false e.succ (Nat.div2 m') lcProof", "start": [162, 1], "end": [167, 97], "kind": "commanddeclaration"}, {"full_name": "FP.nextDnPos", "code": "@[nolint docBlame]\nunsafe def nextDnPos (e m) (v : ValidFinite e m) : Float :=\n  match m with\n  | 0 => nextUpPos _ _ Float.Zero.valid\n  | Nat.succ m' =>\n    if ss : m'.size = m'.succ.size then\n      Float.finite false e m' (by unfold ValidFinite at *; rw [ss]; exact v)\n    else\n      if h : e = emin then Float.finite false emin m' lcProof\n      else Float.finite false e.pred (bit1 m') lcProof", "start": [173, 1], "end": [183, 55], "kind": "commanddeclaration"}, {"full_name": "FP.nextUp", "code": "@[nolint docBlame]\nunsafe def nextUp : Float \u2192 Float\n  | Float.finite Bool.false e m f => nextUpPos e m f\n  | Float.finite Bool.true e m f => Float.neg <| nextDnPos e m f\n  | f => f", "start": [186, 1], "end": [190, 11], "kind": "commanddeclaration"}, {"full_name": "FP.nextDn", "code": "@[nolint docBlame]\nunsafe def nextDn : Float \u2192 Float\n  | Float.finite Bool.false e m f => nextDnPos e m f\n  | Float.finite Bool.true e m f => Float.neg <| nextUpPos e m f\n  | f => f", "start": [193, 1], "end": [197, 11], "kind": "commanddeclaration"}, {"full_name": "FP.ofRatUp", "code": "@[nolint docBlame]\nunsafe def ofRatUp : \u211a \u2192 Float\n  | \u27e80, _, _, _\u27e9 => Float.zero false\n  | \u27e8Nat.succ n, d, h, _\u27e9 =>\n    let (f, exact) := ofPosRatDn n.succPNat \u27e8d, Nat.pos_of_ne_zero h\u27e9\n    if exact then f else nextUp f\n  | \u27e8Int.negSucc n, d, h, _\u27e9 => Float.neg (ofPosRatDn n.succPNat \u27e8d, Nat.pos_of_ne_zero h\u27e9).1", "start": [200, 1], "end": [206, 94], "kind": "commanddeclaration"}, {"full_name": "FP.ofRatDn", "code": "@[nolint docBlame]\nunsafe def ofRatDn (r : \u211a) : Float :=\n  Float.neg <| ofRatUp (-r)", "start": [209, 1], "end": [211, 28], "kind": "commanddeclaration"}, {"full_name": "FP.ofRat", "code": "@[nolint docBlame]\nunsafe def ofRat : RMode \u2192 \u211a \u2192 Float\n  | RMode.NE, r =>\n    let low := ofRatDn r\n    let high := ofRatUp r\n    if hf : high.isFinite then\n      if r = toRat _ hf then high\n      else\n        if lf : low.isFinite then\n          if r - toRat _ lf > toRat _ hf - r then high\n          else\n            if r - toRat _ lf < toRat _ hf - r then low\n            else\n              match low, lf with\n              | Float.finite _ _ m _, _ => if 2 \u2223 m then low else high\n        else Float.inf true\n    else Float.inf false", "start": [214, 1], "end": [230, 25], "kind": "commanddeclaration"}, {"full_name": "FP.Float.add", "code": "@[nolint docBlame]\nunsafe def add (mode : RMode) : Float \u2192 Float \u2192 Float\n  | nan, _ => nan\n  | _, nan => nan\n  | inf Bool.true, inf Bool.false=> nan\n  | inf Bool.false, inf Bool.true => nan\n  | inf s\u2081, _ => inf s\u2081\n  | _, inf s\u2082 => inf s\u2082\n  | finite s\u2081 e\u2081 m\u2081 v\u2081, finite s\u2082 e\u2082 m\u2082 v\u2082 =>\n    let f\u2081 := finite s\u2081 e\u2081 m\u2081 v\u2081\n    let f\u2082 := finite s\u2082 e\u2082 m\u2082 v\u2082\n    ofRat mode (toRat f\u2081 rfl + toRat f\u2082 rfl)", "start": [238, 1], "end": [249, 45], "kind": "commanddeclaration"}, {"full_name": "FP.Float.sub", "code": "@[nolint docBlame]\nunsafe def sub (mode : RMode) (f1 f2 : Float) : Float :=\n  add mode f1 (-f2)", "start": [255, 1], "end": [257, 20], "kind": "commanddeclaration"}, {"full_name": "FP.Float.mul", "code": "@[nolint docBlame]\nunsafe def mul (mode : RMode) : Float \u2192 Float \u2192 Float\n  | nan, _ => nan\n  | _, nan => nan\n  | inf s\u2081, f\u2082 => if f\u2082.isZero then nan else inf (xor s\u2081 f\u2082.sign)\n  | f\u2081, inf s\u2082 => if f\u2081.isZero then nan else inf (xor f\u2081.sign s\u2082)\n  | finite s\u2081 e\u2081 m\u2081 v\u2081, finite s\u2082 e\u2082 m\u2082 v\u2082 =>\n    let f\u2081 := finite s\u2081 e\u2081 m\u2081 v\u2081\n    let f\u2082 := finite s\u2082 e\u2082 m\u2082 v\u2082\n    ofRat mode (toRat f\u2081 rfl * toRat f\u2082 rfl)", "start": [263, 1], "end": [272, 45], "kind": "commanddeclaration"}, {"full_name": "FP.Float.div", "code": "@[nolint docBlame]\nunsafe def div (mode : RMode) : Float \u2192 Float \u2192 Float\n  | nan, _ => nan\n  | _, nan => nan\n  | inf _, inf _ => nan\n  | inf s\u2081, f\u2082 => inf (xor s\u2081 f\u2082.sign)\n  | f\u2081, inf s\u2082 => zero (xor f\u2081.sign s\u2082)\n  | finite s\u2081 e\u2081 m\u2081 v\u2081, finite s\u2082 e\u2082 m\u2082 v\u2082 =>\n    let f\u2081 := finite s\u2081 e\u2081 m\u2081 v\u2081\n    let f\u2082 := finite s\u2082 e\u2082 m\u2082 v\u2082\n    if f\u2082.isZero then inf (xor s\u2081 s\u2082) else ofRat mode (toRat f\u2081 rfl / toRat f\u2082 rfl)", "start": [275, 1], "end": [285, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/Free.lean", "imports": ["Mathlib/Algebra/FreeAlgebra.lean", "Mathlib/Algebra/Star/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FreeMonoid.star_of", "code": "@[simp]\ntheorem star_of (x : \u03b1) : star (of x) = of x", "start": [31, 1], "end": [33, 6], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.star_one", "code": "@[simp, nolint simpNF] theorem star_one : star (1 : FreeMonoid \u03b1) = 1", "start": [36, 1], "end": [39, 6], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.star_\u03b9", "code": "@[simp]\ntheorem star_\u03b9 (x : X) : star (\u03b9 R x) = \u03b9 R x", "start": [66, 1], "end": [67, 75], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.star_algebraMap", "code": "@[simp]\ntheorem star_algebraMap (r : R) : star (algebraMap R (FreeAlgebra R X) r) = algebraMap R _ r", "start": [70, 1], "end": [72, 25], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.starHom", "code": "def starHom : FreeAlgebra R X \u2243\u2090[R] (FreeAlgebra R X)\u1d50\u1d52\u1d56 :=\n  { starRingEquiv with commutes' := fun r => by simp [star_algebraMap] }", "start": [75, 1], "end": [77, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Lists.lean", "imports": ["Mathlib/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lists'", "code": "inductive Lists'.{u} (\u03b1 : Type u) : Bool \u2192 Type u\n  | atom : \u03b1 \u2192 Lists' \u03b1 false\n  | nil : Lists' \u03b1 true\n  | cons' {b} : Lists' \u03b1 b \u2192 Lists' \u03b1 true \u2192 Lists' \u03b1 true\n  deriving DecidableEq", "start": [46, 1], "end": [55, 23], "kind": "commanddeclaration"}, {"full_name": "Lists", "code": "def Lists (\u03b1 : Type*) :=\n  \u03a3b, Lists' \u03b1 b", "start": [59, 1], "end": [63, 17], "kind": "commanddeclaration"}, {"full_name": "Lists'.cons", "code": "def cons : Lists \u03b1 \u2192 Lists' \u03b1 true \u2192 Lists' \u03b1 true\n  | \u27e8_, a\u27e9, l => cons' a l", "start": [72, 1], "end": [74, 27], "kind": "commanddeclaration"}, {"full_name": "Lists'.toList", "code": "@[simp]\ndef toList : \u2200 {b}, Lists' \u03b1 b \u2192 List (Lists \u03b1)\n  | _, atom _ => []\n  | _, nil => []\n  | _, cons' a l => \u27e8_, a\u27e9 :: l.toList", "start": [77, 1], "end": [82, 39], "kind": "commanddeclaration"}, {"full_name": "Lists'.toList_cons", "code": "theorem toList_cons (a : Lists \u03b1) (l) : toList (cons a l) = a :: l.toList", "start": [87, 1], "end": [87, 85], "kind": "commanddeclaration"}, {"full_name": "Lists'.ofList", "code": "@[simp]\ndef ofList : List (Lists \u03b1) \u2192 Lists' \u03b1 true\n  | [] => nil\n  | a :: l => cons a (ofList l)", "start": [90, 1], "end": [94, 32], "kind": "commanddeclaration"}, {"full_name": "Lists'.to_ofList", "code": "@[simp]\ntheorem to_ofList (l : List (Lists \u03b1)) : toList (ofList l) = l", "start": [97, 1], "end": [98, 94], "kind": "commanddeclaration"}, {"full_name": "Lists'.of_toList", "code": "@[simp]\ntheorem of_toList : \u2200 l : Lists' \u03b1 true, ofList (toList l) = l", "start": [101, 1], "end": [119, 32], "kind": "commanddeclaration"}, {"full_name": "Lists.Equiv", "code": "inductive Lists.Equiv : Lists \u03b1 \u2192 Lists \u03b1 \u2192 Prop\n    | refl (l) : Lists.Equiv l l\n    | antisymm {l\u2081 l\u2082 : Lists' \u03b1 true} :\n      Lists'.Subset l\u2081 l\u2082 \u2192 Lists'.Subset l\u2082 l\u2081 \u2192 Lists.Equiv \u27e8_, l\u2081\u27e9 \u27e8_, l\u2082\u27e9", "start": [125, 3], "end": [128, 78], "kind": "commanddeclaration"}, {"full_name": "Lists'.Subset", "code": "inductive Lists'.Subset : Lists' \u03b1 true \u2192 Lists' \u03b1 true \u2192 Prop\n    | nil {l} : Lists'.Subset Lists'.nil l\n    | cons {a a' l l'} :\n      Lists.Equiv a a' \u2192\n        a' \u2208 Lists'.toList l' \u2192 Lists'.Subset l l' \u2192 Lists'.Subset (Lists'.cons a l) l'", "start": [129, 3], "end": [133, 88], "kind": "commanddeclaration"}, {"full_name": "Lists'.mem_def", "code": "theorem mem_def {b a} {l : Lists' \u03b1 b} : a \u2208 l \u2194 \u2203 a' \u2208 l.toList, a ~ a'", "start": [156, 1], "end": [157, 10], "kind": "commanddeclaration"}, {"full_name": "Lists'.mem_cons", "code": "@[simp]\ntheorem mem_cons {a y l} : a \u2208 @cons \u03b1 y l \u2194 a ~ y \u2228 a \u2208 l", "start": [160, 1], "end": [162, 42], "kind": "commanddeclaration"}, {"full_name": "Lists'.cons_subset", "code": "theorem cons_subset {a} {l\u2081 l\u2082 : Lists' \u03b1 true} : Lists'.cons a l\u2081 \u2286 l\u2082 \u2194 a \u2208 l\u2082 \u2227 l\u2081 \u2286 l\u2082", "start": [165, 1], "end": [171, 52], "kind": "commanddeclaration"}, {"full_name": "Lists'.ofList_subset", "code": "theorem ofList_subset {l\u2081 l\u2082 : List (Lists \u03b1)} (h : l\u2081 \u2286 l\u2082) :\n    Lists'.ofList l\u2081 \u2286 Lists'.ofList l\u2082", "start": [174, 1], "end": [178, 22], "kind": "commanddeclaration"}, {"full_name": "Lists'.Subset.refl", "code": "@[refl]\ntheorem Subset.refl {l : Lists' \u03b1 true} : l \u2286 l", "start": [181, 1], "end": [183, 70], "kind": "commanddeclaration"}, {"full_name": "Lists'.subset_nil", "code": "theorem subset_nil {l : Lists' \u03b1 true} : l \u2286 Lists'.nil \u2192 l = Lists'.nil", "start": [186, 1], "end": [190, 48], "kind": "commanddeclaration"}, {"full_name": "Lists'.mem_of_subset'", "code": "theorem mem_of_subset' {a} : \u2200 {l\u2081 l\u2082 : Lists' \u03b1 true} (_ : l\u2081 \u2286 l\u2082) (_ : a \u2208 l\u2081.toList), a \u2208 l\u2082", "start": [193, 1], "end": [200, 31], "kind": "commanddeclaration"}, {"full_name": "Lists'.subset_def", "code": "theorem subset_def {l\u2081 l\u2082 : Lists' \u03b1 true} : l\u2081 \u2286 l\u2082 \u2194 \u2200 a \u2208 l\u2081.toList, a \u2208 l\u2082", "start": [203, 1], "end": [209, 43], "kind": "commanddeclaration"}, {"full_name": "Lists.atom", "code": "@[match_pattern]\ndef atom (a : \u03b1) : Lists \u03b1 :=\n  \u27e8_, Lists'.atom a\u27e9", "start": [216, 1], "end": [219, 21], "kind": "commanddeclaration"}, {"full_name": "Lists.of'", "code": "@[match_pattern]\ndef of' (l : Lists' \u03b1 true) : Lists \u03b1 :=\n  \u27e8_, l\u27e9", "start": [222, 1], "end": [225, 9], "kind": "commanddeclaration"}, {"full_name": "Lists.toList", "code": "@[simp]\ndef toList : Lists \u03b1 \u2192 List (Lists \u03b1)\n  | \u27e8_, l\u27e9 => l.toList", "start": [228, 1], "end": [231, 23], "kind": "commanddeclaration"}, {"full_name": "Lists.IsList", "code": "def IsList (l : Lists \u03b1) : Prop :=\n  l.1", "start": [234, 1], "end": [236, 6], "kind": "commanddeclaration"}, {"full_name": "Lists.ofList", "code": "def ofList (l : List (Lists \u03b1)) : Lists \u03b1 :=\n  of' (Lists'.ofList l)", "start": [239, 1], "end": [241, 24], "kind": "commanddeclaration"}, {"full_name": "Lists.isList_toList", "code": "theorem isList_toList (l : List (Lists \u03b1)) : IsList (ofList l)", "start": [244, 1], "end": [245, 12], "kind": "commanddeclaration"}, {"full_name": "Lists.to_ofList", "code": "theorem to_ofList (l : List (Lists \u03b1)) : toList (ofList l) = l", "start": [248, 1], "end": [248, 88], "kind": "commanddeclaration"}, {"full_name": "Lists.of_toList", "code": "theorem of_toList : \u2200 {l : Lists \u03b1}, IsList l \u2192 ofList (toList l) = l", "start": [251, 1], "end": [252, 46], "kind": "commanddeclaration"}, {"full_name": "Lists.inductionMut", "code": "def inductionMut (C : Lists \u03b1 \u2192 Sort*) (D : Lists' \u03b1 true \u2192 Sort*)\n    (C0 : \u2200 a, C (atom a)) (C1 : \u2200 l, D l \u2192 C (of' l))\n    (D0 : D Lists'.nil) (D1 : \u2200 a l, C a \u2192 D l \u2192 D (Lists'.cons a l)) :\n    PProd (\u2200 l, C l) (\u2200 l, D l) := by\n  suffices\n    \u2200 {b} (l : Lists' \u03b1 b),\n      PProd (C \u27e8_, l\u27e9)\n        (match b, l with\n        | true, l => D l\n        | false, _ => PUnit)\n    by exact \u27e8fun \u27e8b, l\u27e9 => (this _).1, fun l => (this l).2\u27e9\n  intros b l\n  induction' l with a b a l IH\u2081 IH\n  \u00b7 exact \u27e8C0 _, \u27e8\u27e9\u27e9\n  \u00b7 exact \u27e8C1 _ D0, D0\u27e9\n  \u00b7 have : D (Lists'.cons' a l) := D1 \u27e8_, _\u27e9 _ IH\u2081.1 IH.2\n    exact \u27e8C1 _ this, this\u27e9", "start": [262, 1], "end": [279, 28], "kind": "commanddeclaration"}, {"full_name": "Lists.mem", "code": "def mem (a : Lists \u03b1) : Lists \u03b1 \u2192 Prop\n  | \u27e8false, _\u27e9 => False\n  | \u27e8_, l\u27e9 => a \u2208 l", "start": [282, 1], "end": [286, 20], "kind": "commanddeclaration"}, {"full_name": "Lists.isList_of_mem", "code": "theorem isList_of_mem {a : Lists \u03b1} : \u2200 {l : Lists \u03b1}, a \u2208 l \u2192 IsList l", "start": [292, 1], "end": [294, 36], "kind": "commanddeclaration"}, {"full_name": "Lists.Equiv.antisymm_iff", "code": "theorem Equiv.antisymm_iff {l\u2081 l\u2082 : Lists' \u03b1 true} : of' l\u2081 ~ of' l\u2082 \u2194 l\u2081 \u2286 l\u2082 \u2227 l\u2082 \u2286 l\u2081", "start": [297, 1], "end": [301, 19], "kind": "commanddeclaration"}, {"full_name": "Lists.equiv_atom", "code": "theorem equiv_atom {a} {l : Lists \u03b1} : atom a ~ l \u2194 atom a = l", "start": [306, 1], "end": [307, 56], "kind": "commanddeclaration"}, {"full_name": "Lists.Equiv.symm", "code": "@[symm]\ntheorem Equiv.symm {l\u2081 l\u2082 : Lists \u03b1} (h : l\u2081 ~ l\u2082) : l\u2082 ~ l\u2081", "start": [310, 1], "end": [312, 66], "kind": "commanddeclaration"}, {"full_name": "Lists.Equiv.trans", "code": "theorem Equiv.trans : \u2200 {l\u2081 l\u2082 l\u2083 : Lists \u03b1}, l\u2081 ~ l\u2082 \u2192 l\u2082 ~ l\u2083 \u2192 l\u2081 ~ l\u2083", "start": [315, 1], "end": [351, 26], "kind": "commanddeclaration"}, {"full_name": "Lists.instSetoidLists", "code": "instance instSetoidLists : Setoid (Lists \u03b1) :=\n  \u27e8(\u00b7 ~ \u00b7), Equiv.refl, @Equiv.symm _, @Equiv.trans _\u27e9", "start": [354, 1], "end": [355, 55], "kind": "commanddeclaration"}, {"full_name": "Lists.Equiv.decidableMeas", "code": "@[simp, deprecated] def Equiv.decidableMeas :\n    (PSum (\u03a3' _l\u2081 : Lists \u03b1, Lists \u03b1) <|\n        PSum (\u03a3' _l\u2081 : Lists' \u03b1 true, Lists' \u03b1 true) (\u03a3' _a : Lists \u03b1, Lists' \u03b1 true)) \u2192\n      \u2115\n  | PSum.inl \u27e8l\u2081, l\u2082\u27e9 => SizeOf.sizeOf l\u2081 + SizeOf.sizeOf l\u2082\n  | PSum.inr <| PSum.inl \u27e8l\u2081, l\u2082\u27e9 => SizeOf.sizeOf l\u2081 + SizeOf.sizeOf l\u2082\n  | PSum.inr <| PSum.inr \u27e8l\u2081, l\u2082\u27e9 => SizeOf.sizeOf l\u2081 + SizeOf.sizeOf l\u2082", "start": [359, 1], "end": [367, 73], "kind": "commanddeclaration"}, {"full_name": "Lists.sizeof_pos", "code": "theorem sizeof_pos {b} (l : Lists' \u03b1 b) : 0 < SizeOf.sizeOf l", "start": [370, 1], "end": [372, 26], "kind": "commanddeclaration"}, {"full_name": "Lists.lt_sizeof_cons'", "code": "theorem lt_sizeof_cons' {b} (a : Lists' \u03b1 b) (l) :\n    SizeOf.sizeOf (\u27e8b, a\u27e9 : Lists \u03b1) < SizeOf.sizeOf (Lists'.cons' a l)", "start": [375, 1], "end": [378, 19], "kind": "commanddeclaration"}, {"full_name": "Lists.Equiv.decidable", "code": "instance Equiv.decidable : \u2200 l\u2081 l\u2082 : Lists \u03b1, Decidable (l\u2081 ~ l\u2082)\n    | \u27e8false, l\u2081\u27e9, \u27e8false, l\u2082\u27e9 =>\n      decidable_of_iff' (l\u2081 = l\u2082) <| by\n        cases l\u2081\n        apply equiv_atom.trans\n        simp [atom]\n        constructor <;> (rintro \u27e8rfl\u27e9; rfl)\n    | \u27e8false, l\u2081\u27e9, \u27e8true, l\u2082\u27e9 => isFalse <| by rintro \u27e8\u27e9\n    | \u27e8true, l\u2081\u27e9, \u27e8false, l\u2082\u27e9 => isFalse <| by rintro \u27e8\u27e9\n    | \u27e8true, l\u2081\u27e9, \u27e8true, l\u2082\u27e9 => by\n      haveI : Decidable (l\u2081 \u2286 l\u2082) :=\n        have : SizeOf.sizeOf l\u2081 + SizeOf.sizeOf l\u2082 <\n            SizeOf.sizeOf (\u27e8true, l\u2081\u27e9 : Lists \u03b1) + SizeOf.sizeOf (\u27e8true, l\u2082\u27e9 : Lists \u03b1) :=\n          by decreasing_tactic\n        Subset.decidable l\u2081 l\u2082\n      haveI : Decidable (l\u2082 \u2286 l\u2081) :=\n        have : SizeOf.sizeOf l\u2082 + SizeOf.sizeOf l\u2081 <\n            SizeOf.sizeOf (\u27e8true, l\u2081\u27e9 : Lists \u03b1) + SizeOf.sizeOf (\u27e8true, l\u2082\u27e9 : Lists \u03b1) :=\n          by decreasing_tactic\n        Subset.decidable l\u2082 l\u2081\n      exact decidable_of_iff' _ Equiv.antisymm_iff", "start": [384, 3], "end": [404, 51], "kind": "commanddeclaration"}, {"full_name": "Lists.Subset.decidable", "code": "instance Subset.decidable : \u2200 l\u2081 l\u2082 : Lists' \u03b1 true, Decidable (l\u2081 \u2286 l\u2082)\n    | Lists'.nil, l\u2082 => isTrue Lists'.Subset.nil\n    | @Lists'.cons' _ b a l\u2081, l\u2082 => by\n      haveI :=\n        have : sizeOf (\u27e8b, a\u27e9 : Lists \u03b1) < 1 + 1 + sizeOf a + sizeOf l\u2081 := by simp [sizeof_pos]\n        mem.decidable \u27e8b, a\u27e9 l\u2082\n      haveI :=\n        have : SizeOf.sizeOf l\u2081 + SizeOf.sizeOf l\u2082 <\n            SizeOf.sizeOf (Lists'.cons' a l\u2081) + SizeOf.sizeOf l\u2082 :=\n          by decreasing_tactic\n        Subset.decidable l\u2081 l\u2082\n      exact decidable_of_iff' _ (@Lists'.cons_subset _ \u27e8_, _\u27e9 _ _)", "start": [405, 3], "end": [416, 67], "kind": "commanddeclaration"}, {"full_name": "Lists.mem.decidable", "code": "instance mem.decidable : \u2200 (a : Lists \u03b1) (l : Lists' \u03b1 true), Decidable (a \u2208 l)\n    | a, Lists'.nil => isFalse <| by rintro \u27e8_, \u27e8\u27e9, _\u27e9\n    | a, Lists'.cons' b l\u2082 => by\n      haveI :=\n        have : sizeOf (\u27e8_, b\u27e9 : Lists \u03b1) < 1 + 1 + sizeOf b + sizeOf l\u2082 := by simp [sizeof_pos]\n        Equiv.decidable a \u27e8_, b\u27e9\n      haveI :=\n        have :\n          SizeOf.sizeOf a + SizeOf.sizeOf l\u2082 <\n            SizeOf.sizeOf a + SizeOf.sizeOf (Lists'.cons' b l\u2082) :=\n          by decreasing_tactic\n        mem.decidable a l\u2082\n      refine' decidable_of_iff' (a ~ \u27e8_, b\u27e9 \u2228 a \u2208 l\u2082) _\n      rw [\u2190 Lists'.mem_cons]; rfl", "start": [417, 3], "end": [430, 34], "kind": "commanddeclaration"}, {"full_name": "Lists'.mem_equiv_left", "code": "theorem mem_equiv_left {l : Lists' \u03b1 true} : \u2200 {a a'}, a ~ a' \u2192 (a \u2208 l \u2194 a' \u2208 l)", "start": [449, 1], "end": [451, 50], "kind": "commanddeclaration"}, {"full_name": "Lists'.mem_of_subset", "code": "theorem mem_of_subset {a} {l\u2081 l\u2082 : Lists' \u03b1 true} (s : l\u2081 \u2286 l\u2082) : a \u2208 l\u2081 \u2192 a \u2208 l\u2082", "start": [454, 1], "end": [455, 59], "kind": "commanddeclaration"}, {"full_name": "Lists'.Subset.trans", "code": "theorem Subset.trans {l\u2081 l\u2082 l\u2083 : Lists' \u03b1 true} (h\u2081 : l\u2081 \u2286 l\u2082) (h\u2082 : l\u2082 \u2286 l\u2083) : l\u2081 \u2286 l\u2083", "start": [458, 1], "end": [459, 68], "kind": "commanddeclaration"}, {"full_name": "Finsets", "code": "def Finsets (\u03b1 : Type*) :=\n  Quotient (@Lists.instSetoidLists \u03b1)", "start": [464, 1], "end": [466, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Radon.lean", "imports": ["Mathlib/Tactic/Linarith.lean", "Mathlib/Analysis/Convex/Combination.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "radon_partition", "code": "theorem radon_partition (h : \u00ac AffineIndependent \ud835\udd5c f) :\n    \u2203 I, (convexHull \ud835\udd5c (f '' I) \u2229 convexHull \ud835\udd5c (f '' I\u1d9c)).Nonempty", "start": [25, 1], "end": [51, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/LpEquiv.lean", "imports": ["Mathlib/Analysis/NormedSpace/PiLp.lean", "Mathlib/Topology/ContinuousFunction/Bounded.lean", "Mathlib/Analysis/NormedSpace/lpSpace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mem\u2113p.all", "code": "theorem Mem\u2113p.all [Finite \u03b1] (f : \u2200 i, E i) : Mem\u2113p f p", "start": [49, 1], "end": [54, 84], "kind": "commanddeclaration"}, {"full_name": "Equiv.lpPiLp", "code": "def Equiv.lpPiLp : lp E p \u2243 PiLp p E where\n  toFun f := \u21d1f\n  invFun f := \u27e8f, Mem\u2113p.all f\u27e9\n  left_inv _f := lp.ext <| funext fun _x => rfl\n  right_inv _f := funext fun _x => rfl", "start": [59, 1], "end": [64, 39], "kind": "commanddeclaration"}, {"full_name": "coe_equiv_lpPiLp", "code": "theorem coe_equiv_lpPiLp (f : lp E p) : Equiv.lpPiLp f = \u21d1f", "start": [67, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "coe_equiv_lpPiLp_symm", "code": "theorem coe_equiv_lpPiLp_symm (f : PiLp p E) : (Equiv.lpPiLp.symm f : \u2200 i, E i) = f", "start": [71, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "equiv_lpPiLp_norm", "code": "theorem equiv_lpPiLp_norm (f : lp E p) : \u2016Equiv.lpPiLp f\u2016 = \u2016f\u2016", "start": [75, 1], "end": [79, 71], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.lpPiLp", "code": "def AddEquiv.lpPiLp [Fact (1 \u2264 p)] : lp E p \u2243+ PiLp p E :=\n  { Equiv.lpPiLp with map_add' := fun _f _g => rfl }", "start": [82, 1], "end": [85, 53], "kind": "commanddeclaration"}, {"full_name": "coe_addEquiv_lpPiLp", "code": "theorem coe_addEquiv_lpPiLp [Fact (1 \u2264 p)] (f : lp E p) : AddEquiv.lpPiLp f = \u21d1f", "start": [88, 1], "end": [89, 6], "kind": "commanddeclaration"}, {"full_name": "coe_addEquiv_lpPiLp_symm", "code": "theorem coe_addEquiv_lpPiLp_symm [Fact (1 \u2264 p)] (f : PiLp p E) :\n    (AddEquiv.lpPiLp.symm f : \u2200 i, E i) = f", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "lpPiLp\u2097\u1d62", "code": "noncomputable def lpPiLp\u2097\u1d62 [Fact (1 \u2264 p)] : lp E p \u2243\u2097\u1d62[\ud835\udd5c] PiLp p E :=\n  { AddEquiv.lpPiLp with\n    map_smul' := fun _k _f => rfl\n    norm_map' := equiv_lpPiLp_norm }", "start": [105, 1], "end": [110, 37], "kind": "commanddeclaration"}, {"full_name": "coe_lpPiLp\u2097\u1d62", "code": "theorem coe_lpPiLp\u2097\u1d62 [Fact (1 \u2264 p)] (f : lp E p) : (lpPiLp\u2097\u1d62 E \ud835\udd5c f : \u2200 i, E i) = \u21d1f", "start": [116, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "coe_lpPiLp\u2097\u1d62_symm", "code": "theorem coe_lpPiLp\u2097\u1d62_symm [Fact (1 \u2264 p)] (f : PiLp p E) :\n    ((lpPiLp\u2097\u1d62 E \ud835\udd5c).symm f : \u2200 i, E i) = f", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.lpBcf", "code": "noncomputable def AddEquiv.lpBcf : lp (fun _ : \u03b1 => E) \u221e \u2243+ (\u03b1 \u2192\u1d47 E) where\n  toFun f := ofNormedAddCommGroupDiscrete f \u2016f\u2016 <| le_ciSup (mem\u2113p_infty_iff.mp f.prop)\n  invFun f := \u27e8\u21d1f, f.bddAbove_range_norm_comp\u27e9\n  left_inv _f := lp.ext rfl\n  right_inv _f := BoundedContinuousFunction.ext fun _x => rfl\n  map_add' _f _g := BoundedContinuousFunction.ext fun _x => rfl", "start": [144, 1], "end": [150, 64], "kind": "commanddeclaration"}, {"full_name": "coe_addEquiv_lpBcf", "code": "theorem coe_addEquiv_lpBcf (f : lp (fun _ : \u03b1 => E) \u221e) : (AddEquiv.lpBcf f : \u03b1 \u2192 E) = f", "start": [154, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "coe_addEquiv_lpBcf_symm", "code": "theorem coe_addEquiv_lpBcf_symm (f : \u03b1 \u2192\u1d47 E) : (AddEquiv.lpBcf.symm f : \u03b1 \u2192 E) = f", "start": [158, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "lpBcf\u2097\u1d62", "code": "noncomputable def lpBcf\u2097\u1d62 : lp (fun _ : \u03b1 => E) \u221e \u2243\u2097\u1d62[\ud835\udd5c] \u03b1 \u2192\u1d47 E :=\n  { AddEquiv.lpBcf with\n    map_smul' := fun k f => rfl\n    norm_map' := fun f => by simp only [norm_eq_iSup_norm, lp.norm_eq_ciSup]; rfl }", "start": [167, 1], "end": [171, 84], "kind": "commanddeclaration"}, {"full_name": "coe_lpBcf\u2097\u1d62", "code": "theorem coe_lpBcf\u2097\u1d62 (f : lp (fun _ : \u03b1 => E) \u221e) : (lpBcf\u2097\u1d62 E \ud835\udd5c f : \u03b1 \u2192 E) = f", "start": [177, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "coe_lpBcf\u2097\u1d62_symm", "code": "theorem coe_lpBcf\u2097\u1d62_symm (f : \u03b1 \u2192\u1d47 E) : ((lpBcf\u2097\u1d62 E \ud835\udd5c).symm f : \u03b1 \u2192 E) = f", "start": [181, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.lpBcf", "code": "noncomputable def RingEquiv.lpBcf : lp (fun _ : \u03b1 => R) \u221e \u2243+* (\u03b1 \u2192\u1d47 R) :=\n  { @AddEquiv.lpBcf _ R _ _ _ with\n    map_mul' := fun _f _g => BoundedContinuousFunction.ext fun _x => rfl }", "start": [189, 1], "end": [192, 75], "kind": "commanddeclaration"}, {"full_name": "coe_ringEquiv_lpBcf", "code": "theorem coe_ringEquiv_lpBcf (f : lp (fun _ : \u03b1 => R) \u221e) : (RingEquiv.lpBcf R f : \u03b1 \u2192 R) = f", "start": [197, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "coe_ringEquiv_lpBcf_symm", "code": "theorem coe_ringEquiv_lpBcf_symm (f : \u03b1 \u2192\u1d47 R) : ((RingEquiv.lpBcf R).symm f : \u03b1 \u2192 R) = f", "start": [201, 1], "end": [202, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.lpBcf", "code": "noncomputable def AlgEquiv.lpBcf : lp (fun _ : \u03b1 => A) \u221e \u2243\u2090[\ud835\udd5c] \u03b1 \u2192\u1d47 A :=\n  { RingEquiv.lpBcf A with commutes' := fun _k => rfl }", "start": [210, 1], "end": [212, 56], "kind": "commanddeclaration"}, {"full_name": "coe_algEquiv_lpBcf", "code": "theorem coe_algEquiv_lpBcf (f : lp (fun _ : \u03b1 => A) \u221e) : (AlgEquiv.lpBcf \u03b1 A \ud835\udd5c f : \u03b1 \u2192 A) = f", "start": [217, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "coe_algEquiv_lpBcf_symm", "code": "theorem coe_algEquiv_lpBcf_symm (f : \u03b1 \u2192\u1d47 A) : ((AlgEquiv.lpBcf \u03b1 A \ud835\udd5c).symm f : \u03b1 \u2192 A) = f", "start": [221, 1], "end": [222, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Order/Category/FrameAdjunction.lean", "imports": ["Mathlib/Topology/Category/Locale.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Locale.PT", "code": "@[reducible]\ndef PT := FrameHom L Prop", "start": [50, 1], "end": [53, 26], "kind": "commanddeclaration"}, {"full_name": "Locale.openOfElementHom", "code": "@[simps]\ndef openOfElementHom : FrameHom L (Set (PT L)) where\n  toFun u := {x | x u}\n  map_inf' a b := by simp [Set.setOf_and]\n  map_top' := by simp\n  map_sSup' S := by ext; simp [Prop.exists_iff]", "start": [55, 1], "end": [62, 48], "kind": "commanddeclaration"}, {"full_name": "Locale.PT.instTopologicalSpace", "code": "instance instTopologicalSpace : TopologicalSpace (PT L) where\n  IsOpen s := \u2203 u, {x | x u} = s\n  isOpen_univ := \u27e8\u22a4, by simp\u27e9\n  isOpen_inter := by rintro s t \u27e8u, rfl\u27e9 \u27e8v, rfl\u27e9; use u \u2293 v; simp_rw [map_inf]; rfl\n  isOpen_sUnion S hS := by\n    choose f hf using hS\n    use \u2a06 t, \u2a06 ht, f t ht\n    simp_rw [map_iSup, iSup_Prop_eq, setOf_exists, hf, sUnion_eq_biUnion]", "start": [66, 1], "end": [74, 74], "kind": "commanddeclaration"}, {"full_name": "Locale.PT.isOpen_iff", "code": "lemma isOpen_iff (U : Set (PT L)) : IsOpen U \u2194 \u2203 u : L, {x | x u} = U := Iff.rfl", "start": [76, 1], "end": [77, 81], "kind": "mathlibtacticlemma"}, {"full_name": "Locale.pt", "code": "def pt : Locale \u2964 TopCat where\n  obj L := \u27e8PT L.unop, inferInstance\u27e9\n  map f := \u27e8fun p \u21a6 p.comp f.unop, continuous_def.2 <| by rintro s \u27e8u, rfl\u27e9; use f.unop u; rfl\u27e9", "start": [81, 1], "end": [87, 96], "kind": "commanddeclaration"}, {"full_name": "Locale.localePointOfSpacePoint", "code": "@[simps]\ndef localePointOfSpacePoint (x : X) : PT (Opens X) where\n  toFun := (x \u2208 \u00b7)\n  map_inf' a b := rfl\n  map_top' := rfl\n  map_sSup' S := by simp [Prop.exists_iff]", "start": [94, 1], "end": [101, 43], "kind": "commanddeclaration"}, {"full_name": "Locale.counitAppCont", "code": "def counitAppCont : FrameHom L (Opens <| PT L) where\n  toFun u := \u27e8openOfElementHom L u, u, rfl\u27e9\n  map_inf' a b := by simp\n  map_top' := by simp\n  map_sSup' S := by ext; simp", "start": [103, 1], "end": [108, 30], "kind": "commanddeclaration"}, {"full_name": "Locale.adjunctionTopToLocalePT", "code": "def adjunctionTopToLocalePT : topToLocale \u22a3 pt :=\n  Adjunction.mkOfUnitCounit\n    { unit := { app := fun X \u21a6 \u27e8localePointOfSpacePoint X, continuous_def.2 <|\n        by rintro _ \u27e8u, rfl\u27e9; simpa using u.2\u27e9 }\n      counit := { app := fun L \u21a6 \u27e8counitAppCont L\u27e9 } }", "start": [110, 1], "end": [115, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/EllipticCurve/Point.lean", "imports": ["Mathlib/AlgebraicGeometry/EllipticCurve/Weierstrass.lean", "Mathlib/LinearAlgebra/FreeModule/Norm.lean", "Mathlib/RingTheory/ClassGroup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WeierstrassCurve.negPolynomial", "code": "noncomputable def negPolynomial : R[X][Y] :=\n  -Y - C (C W.a\u2081 * X + C W.a\u2083)", "start": [104, 1], "end": [106, 31], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.negY", "code": "@[simp]\ndef negY : R :=\n  -y\u2081 - W.a\u2081 * x\u2081 - W.a\u2083", "start": [109, 1], "end": [114, 25], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.negY_negY", "code": "lemma negY_negY : W.negY x\u2081 (W.negY x\u2081 y\u2081) = y\u2081 := by\n  simp only [negY]\n  ring1", "start": [118, 1], "end": [120, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_negY", "code": "lemma baseChange_negY :\n    (W.baseChange A).negY (algebraMap R A x\u2081) (algebraMap R A y\u2081) =\n      algebraMap R A (W.negY x\u2081 y\u2081) := by\n  simp only [negY]\n  map_simp\n  rfl", "start": [124, 1], "end": [129, 6], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_negY_of_baseChange", "code": "lemma baseChange_negY_of_baseChange (x\u2081 y\u2081 : A) :\n    (W.baseChange B).negY (algebraMap A B x\u2081) (algebraMap A B y\u2081) =\n      algebraMap A B ((W.baseChange A).negY x\u2081 y\u2081) := by\n  rw [\u2190 baseChange_negY, baseChange_baseChange]", "start": [133, 1], "end": [136, 48], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.eval_negPolynomial", "code": "lemma eval_negPolynomial : (W.negPolynomial.eval <| C y\u2081).eval x\u2081 = W.negY x\u2081 y\u2081 := by\n  rw [negY, sub_sub, negPolynomial]\n  eval_simp", "start": [141, 1], "end": [143, 12], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.linePolynomial", "code": "noncomputable def linePolynomial : R[X] :=\n  C L * (X - C x\u2081) + C y\u2081", "start": [146, 1], "end": [151, 26], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.XYIdeal_eq\u2081", "code": "lemma XYIdeal_eq\u2081 : XYIdeal W x\u2081 (C y\u2081) = XYIdeal W x\u2081 (linePolynomial x\u2081 y\u2081 L) := by\n  simp only [XYIdeal, XClass, YClass, linePolynomial]\n  rw [\u2190 span_pair_add_mul_right <| CoordinateRing.mk W <| C <| C <| -L, \u2190 _root_.map_mul, \u2190 map_add]\n  apply congr_arg (_ \u2218 _ \u2218 _ \u2218 _)\n  C_simp\n  ring1", "start": [154, 1], "end": [159, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.addPolynomial", "code": "noncomputable def addPolynomial : R[X] :=\n  W.polynomial.eval <| linePolynomial x\u2081 y\u2081 L", "start": [163, 1], "end": [170, 46], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.C_addPolynomial", "code": "lemma C_addPolynomial :\n    C (W.addPolynomial x\u2081 y\u2081 L) =\n      (Y - C (linePolynomial x\u2081 y\u2081 L)) * (W.negPolynomial - C (linePolynomial x\u2081 y\u2081 L)) +\n        W.polynomial := by\n  rw [addPolynomial, linePolynomial, WeierstrassCurve.polynomial, negPolynomial]\n  eval_simp\n  C_simp\n  ring1", "start": [173, 1], "end": [180, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.C_addPolynomial", "code": "lemma CoordinateRing.C_addPolynomial :\n    CoordinateRing.mk W (C (W.addPolynomial x\u2081 y\u2081 L)) =\n      CoordinateRing.mk W\n        ((Y - C (linePolynomial x\u2081 y\u2081 L)) * (W.negPolynomial - C (linePolynomial x\u2081 y\u2081 L))) :=\n  AdjoinRoot.mk_eq_mk.mpr \u27e81, by rw [W.C_addPolynomial, add_sub_cancel', mul_one]\u27e9", "start": [184, 1], "end": [188, 83], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.addPolynomial_eq", "code": "lemma addPolynomial_eq :\n    W.addPolynomial x\u2081 y\u2081 L =\n      -Cubic.toPoly\n        \u27e81, -L ^ 2 - W.a\u2081 * L + W.a\u2082,\n          2 * x\u2081 * L ^ 2 + (W.a\u2081 * x\u2081 - 2 * y\u2081 - W.a\u2083) * L + (-W.a\u2081 * y\u2081 + W.a\u2084),\n          -x\u2081 ^ 2 * L ^ 2 + (2 * x\u2081 * y\u2081 + W.a\u2083 * x\u2081) * L - (y\u2081 ^ 2 + W.a\u2083 * y\u2081 - W.a\u2086)\u27e9 := by\n  rw [addPolynomial, linePolynomial, WeierstrassCurve.polynomial, Cubic.toPoly]\n  eval_simp\n  C_simp\n  ring1", "start": [192, 1], "end": [201, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.addX", "code": "@[simp]\ndef addX : R :=\n  L ^ 2 + W.a\u2081 * L - W.a\u2082 - x\u2081 - x\u2082", "start": [204, 1], "end": [210, 36], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.baseChange_addX", "code": "lemma baseChange_addX :\n    (W.baseChange A).addX (algebraMap R A x\u2081) (algebraMap R A x\u2082) (algebraMap R A L) =\n      algebraMap R A (W.addX x\u2081 x\u2082 L) := by\n  simp only [addX]\n  map_simp\n  rfl", "start": [214, 1], "end": [219, 6], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_addX_of_baseChange", "code": "lemma baseChange_addX_of_baseChange (x\u2081 x\u2082 L : A) :\n    (W.baseChange B).addX (algebraMap A B x\u2081) (algebraMap A B x\u2082) (algebraMap A B L) =\n      algebraMap A B ((W.baseChange A).addX x\u2081 x\u2082 L) := by\n  rw [\u2190 baseChange_addX, baseChange_baseChange]", "start": [223, 1], "end": [226, 48], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.addY'", "code": "@[simp]\ndef addY' : R :=\n  L * (W.addX x\u2081 x\u2082 L - x\u2081) + y\u2081", "start": [230, 1], "end": [236, 33], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.baseChange_addY'", "code": "lemma baseChange_addY' :\n    (W.baseChange A).addY' (algebraMap R A x\u2081) (algebraMap R A x\u2082) (algebraMap R A y\u2081)\n        (algebraMap R A L) =\n      algebraMap R A (W.addY' x\u2081 x\u2082 y\u2081 L) := by\n  simp only [addY', baseChange_addX]\n  map_simp", "start": [240, 1], "end": [245, 11], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_addY'_of_baseChange", "code": "lemma baseChange_addY'_of_baseChange (x\u2081 x\u2082 y\u2081 L : A) :\n    (W.baseChange B).addY' (algebraMap A B x\u2081) (algebraMap A B x\u2082) (algebraMap A B y\u2081)\n        (algebraMap A B L) =\n      algebraMap A B ((W.baseChange A).addY' x\u2081 x\u2082 y\u2081 L) := by\n  rw [\u2190 baseChange_addY', baseChange_baseChange]", "start": [249, 1], "end": [253, 49], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.addY", "code": "@[simp]\ndef addY : R :=\n  W.negY (W.addX x\u2081 x\u2082 L) (W.addY' x\u2081 x\u2082 y\u2081 L)", "start": [257, 1], "end": [263, 47], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.baseChange_addY", "code": "lemma baseChange_addY :\n    (W.baseChange A).addY (algebraMap R A x\u2081) (algebraMap R A x\u2082) (algebraMap R A y\u2081)\n        (algebraMap R A L) =\n      algebraMap R A (W.addY x\u2081 x\u2082 y\u2081 L) := by\n  simp only [addY, baseChange_addY', baseChange_addX, baseChange_negY]", "start": [267, 1], "end": [271, 71], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_addY_of_baseChange", "code": "lemma baseChange_addY_of_baseChange (x\u2081 x\u2082 y\u2081 L : A) :\n    (W.baseChange B).addY (algebraMap A B x\u2081) (algebraMap A B x\u2082) (algebraMap A B y\u2081)\n        (algebraMap A B L) =\n      algebraMap A B ((W.baseChange A).addY x\u2081 x\u2082 y\u2081 L) := by\n  rw [\u2190 baseChange_addY, baseChange_baseChange]", "start": [275, 1], "end": [279, 48], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.XYIdeal_add_eq", "code": "lemma XYIdeal_add_eq :\n    XYIdeal W (W.addX x\u2081 x\u2082 L) (C (W.addY x\u2081 x\u2082 y\u2081 L)) =\n      span {CoordinateRing.mk W <| W.negPolynomial - C (linePolynomial x\u2081 y\u2081 L)} \u2294\n        XIdeal W (W.addX x\u2081 x\u2082 L) := by\n  simp only [XYIdeal, XIdeal, XClass, YClass, addY, addY', negY, negPolynomial, linePolynomial]\n  rw [sub_sub <| -Y, neg_sub_left Y, map_neg, span_singleton_neg, sup_comm, \u2190 span_insert,\n    \u2190 span_pair_add_mul_right <| CoordinateRing.mk W <| C <| C <| W.a\u2081 + L, \u2190 _root_.map_mul,\n    \u2190 map_add]\n  apply congr_arg (_ \u2218 _ \u2218 _ \u2218 _)\n  C_simp\n  ring1", "start": [283, 1], "end": [293, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.equation_add_iff", "code": "lemma equation_add_iff :\n    W.equation (W.addX x\u2081 x\u2082 L) (W.addY' x\u2081 x\u2082 y\u2081 L) \u2194\n      (W.addPolynomial x\u2081 y\u2081 L).eval (W.addX x\u2081 x\u2082 L) = 0 := by\n  rw [WeierstrassCurve.equation, addY', addPolynomial, linePolynomial, WeierstrassCurve.polynomial]\n  eval_simp", "start": [297, 1], "end": [301, 12], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.nonsingular_add_of_eval_derivative_ne_zero", "code": "lemma nonsingular_add_of_eval_derivative_ne_zero\n    (hx' : W.equation (W.addX x\u2081 x\u2082 L) (W.addY' x\u2081 x\u2082 y\u2081 L))\n    (hx : (derivative <| W.addPolynomial x\u2081 y\u2081 L).eval (W.addX x\u2081 x\u2082 L) \u2260 0) :\n    W.nonsingular (W.addX x\u2081 x\u2082 L) (W.addY' x\u2081 x\u2082 y\u2081 L) := by\n  rw [WeierstrassCurve.nonsingular, and_iff_right hx', addY', WeierstrassCurve.polynomialX,\n    WeierstrassCurve.polynomialY]\n  eval_simp\n  contrapose! hx\n  rw [addPolynomial, linePolynomial, WeierstrassCurve.polynomial]\n  eval_simp\n  derivative_simp\n  simp only [zero_add, add_zero, sub_zero, zero_mul, mul_one]\n  eval_simp\n  linear_combination (norm := (norm_num1; ring1)) hx.left + L * hx.right", "start": [304, 1], "end": [317, 73], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point", "code": "inductive Point\n  | zero\n  | some {x y : R} (h : W.nonsingular x y)", "start": [322, 1], "end": [327, 43], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.Point.zero_def", "code": "lemma zero_def : (zero : W.Point) = 0 :=\n  rfl", "start": [342, 1], "end": [343, 6], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.equation_neg_iff", "code": "lemma equation_neg_iff : W.equation x\u2081 (W.negY x\u2081 y\u2081) \u2194 W.equation x\u2081 y\u2081 := by\n  rw [equation_iff, equation_iff, negY]\n  congr! 1\n  ring1", "start": [350, 1], "end": [353, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.equation_neg_of", "code": "lemma equation_neg_of (h : W.equation x\u2081 <| W.negY x\u2081 y\u2081) : W.equation x\u2081 y\u2081 :=\n  equation_neg_iff.mp h", "start": [356, 1], "end": [357, 24], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.equation_neg", "code": "lemma equation_neg (h : W.equation x\u2081 y\u2081) : W.equation x\u2081 <| W.negY x\u2081 y\u2081 :=\n  equation_neg_iff.mpr h", "start": [360, 1], "end": [362, 25], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.nonsingular_neg_iff", "code": "lemma nonsingular_neg_iff : W.nonsingular x\u2081 (W.negY x\u2081 y\u2081) \u2194 W.nonsingular x\u2081 y\u2081 := by\n  rw [nonsingular_iff, equation_neg_iff, \u2190 negY, negY_negY, \u2190 @ne_comm _ y\u2081, nonsingular_iff]\n  exact and_congr_right' <| (iff_congr not_and_or.symm not_and_or.symm).mpr <|\n    not_congr <| and_congr_left fun h => by rw [\u2190 h]", "start": [365, 1], "end": [368, 53], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.nonsingular_neg_of", "code": "lemma nonsingular_neg_of (h : W.nonsingular x\u2081 <| W.negY x\u2081 y\u2081) : W.nonsingular x\u2081 y\u2081 :=\n  nonsingular_neg_iff.mp h", "start": [371, 1], "end": [372, 27], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.nonsingular_neg", "code": "lemma nonsingular_neg (h : W.nonsingular x\u2081 y\u2081) : W.nonsingular x\u2081 <| W.negY x\u2081 y\u2081 :=\n  nonsingular_neg_iff.mpr h", "start": [375, 1], "end": [377, 28], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.neg", "code": "def neg : W.Point \u2192 W.Point\n  | 0 => 0\n  | some h => some <| nonsingular_neg h", "start": [382, 1], "end": [387, 40], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.Point.neg_def", "code": "lemma neg_def (P : W.Point) : P.neg = -P :=\n  rfl", "start": [394, 1], "end": [395, 6], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.neg_zero", "code": "@[simp]\nlemma neg_zero : (-0 : W.Point) = 0 :=\n  rfl", "start": [398, 1], "end": [400, 6], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.neg_some", "code": "@[simp]\nlemma neg_some (h : W.nonsingular x\u2081 y\u2081) : -some h = some (nonsingular_neg h) :=\n  rfl", "start": [403, 1], "end": [405, 6], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.slope", "code": "noncomputable def slope : F :=\n  if x\u2081 = x\u2082 then\n    if y\u2081 = W.negY x\u2082 y\u2082 then 0\n    else (3 * x\u2081 ^ 2 + 2 * W.a\u2082 * x\u2081 + W.a\u2084 - W.a\u2081 * y\u2081) / (y\u2081 - W.negY x\u2081 y\u2081)\n  else (y\u2081 - y\u2082) / (x\u2081 - x\u2082)", "start": [424, 1], "end": [436, 29], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.slope_of_Y_eq", "code": "@[simp]\nlemma slope_of_Y_eq (hx : x\u2081 = x\u2082) (hy : y\u2081 = W.negY x\u2082 y\u2082) : W.slope x\u2081 x\u2082 y\u2081 y\u2082 = 0 := by\n  rw [slope, if_pos hx, if_pos hy]", "start": [442, 1], "end": [444, 35], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.slope_of_Y_ne", "code": "@[simp]\nlemma slope_of_Y_ne (hx : x\u2081 = x\u2082) (hy : y\u2081 \u2260 W.negY x\u2082 y\u2082) :\n    W.slope x\u2081 x\u2082 y\u2081 y\u2082 =\n      (3 * x\u2081 ^ 2 + 2 * W.a\u2082 * x\u2081 + W.a\u2084 - W.a\u2081 * y\u2081) / (y\u2081 - W.negY x\u2081 y\u2081) := by\n  rw [slope, if_pos hx, if_neg hy]", "start": [448, 1], "end": [452, 35], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.slope_of_X_ne", "code": "@[simp]\nlemma slope_of_X_ne (hx : x\u2081 \u2260 x\u2082) : W.slope x\u2081 x\u2082 y\u2081 y\u2082 = (y\u2081 - y\u2082) / (x\u2081 - x\u2082) := by\n  rw [slope, if_neg hx]", "start": [456, 1], "end": [458, 24], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.slope_of_Y_ne_eq_eval", "code": "lemma slope_of_Y_ne_eq_eval (hx : x\u2081 = x\u2082) (hy : y\u2081 \u2260 W.negY x\u2082 y\u2082) :\n    W.slope x\u2081 x\u2082 y\u2081 y\u2082 =\n      -(W.polynomialX.eval <| C y\u2081).eval x\u2081 / (W.polynomialY.eval <| C y\u2081).eval x\u2081 := by\n  rw [slope_of_Y_ne hx hy, eval_polynomialX, neg_sub]\n  congr 1\n  rw [negY, eval_polynomialY]\n  ring1", "start": [462, 1], "end": [468, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_slope", "code": "lemma baseChange_slope :\n    (W.baseChange K).slope (algebraMap F K x\u2081) (algebraMap F K x\u2082) (algebraMap F K y\u2081)\n        (algebraMap F K y\u2082) =\n      algebraMap F K (W.slope x\u2081 x\u2082 y\u2081 y\u2082) := by\n  by_cases hx : x\u2081 = x\u2082\n  \u00b7 by_cases hy : y\u2081 = W.negY x\u2082 y\u2082\n    \u00b7 rw [slope_of_Y_eq hx hy, slope_of_Y_eq <| congr_arg _ hx, map_zero]\n      \u00b7 rw [hy, baseChange_negY]\n    \u00b7 rw [slope_of_Y_ne hx hy, slope_of_Y_ne <| congr_arg _ hx]\n      \u00b7 map_simp\n        simp only [baseChange_negY]\n        rfl\n      \u00b7 rw [baseChange_negY]\n        contrapose! hy\n        exact NoZeroSMulDivisors.algebraMap_injective F K hy\n  \u00b7 rw [slope_of_X_ne hx, slope_of_X_ne]\n    \u00b7 map_simp\n    \u00b7 contrapose! hx\n      exact NoZeroSMulDivisors.algebraMap_injective F K hx", "start": [472, 1], "end": [490, 59], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_slope_of_baseChange", "code": "lemma baseChange_slope_of_baseChange {R : Type u} [CommRing R] (W : WeierstrassCurve R)\n    (F : Type v) [Field F] [Algebra R F] (K : Type w) [Field K] [Algebra R K] [Algebra F K]\n    [IsScalarTower R F K] (x\u2081 x\u2082 y\u2081 y\u2082 : F) :\n    (W.baseChange K).slope (algebraMap F K x\u2081) (algebraMap F K x\u2082) (algebraMap F K y\u2081)\n        (algebraMap F K y\u2082) =\n      algebraMap F K ((W.baseChange F).slope x\u2081 x\u2082 y\u2081 y\u2082) := by\n  rw [\u2190 baseChange_slope, baseChange_baseChange]", "start": [493, 1], "end": [499, 49], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Y_eq_of_X_eq", "code": "lemma Y_eq_of_X_eq (hx : x\u2081 = x\u2082) : y\u2081 = y\u2082 \u2228 y\u2081 = W.negY x\u2082 y\u2082 := by\n  rw [equation_iff] at h\u2081' h\u2082'\n  rw [\u2190 sub_eq_zero, \u2190 @sub_eq_zero _ _ y\u2081, \u2190 mul_eq_zero, negY]\n  linear_combination (norm := (rw [hx]; ring1)) h\u2081' - h\u2082'", "start": [502, 1], "end": [505, 58], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Y_eq_of_Y_ne", "code": "lemma Y_eq_of_Y_ne (hx : x\u2081 = x\u2082) (hy : y\u2081 \u2260 W.negY x\u2082 y\u2082) : y\u2081 = y\u2082 :=\n  Or.resolve_right (Y_eq_of_X_eq h\u2081' h\u2082' hx) hy", "start": [509, 1], "end": [510, 48], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.XYIdeal_eq\u2082", "code": "lemma XYIdeal_eq\u2082 (hxy : x\u2081 = x\u2082 \u2192 y\u2081 \u2260 W.negY x\u2082 y\u2082) :\n    XYIdeal W x\u2082 (C y\u2082) = XYIdeal W x\u2082 (linePolynomial x\u2081 y\u2081 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082) := by\n  clear h\u2082\n  have hy\u2082 : y\u2082 = (linePolynomial x\u2081 y\u2081 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082).eval x\u2082 := by\n    by_cases hx : x\u2081 = x\u2082\n    \u00b7 rcases hx, Y_eq_of_Y_ne h\u2081' h\u2082' hx <| hxy hx with \u27e8rfl, rfl\u27e9\n      field_simp [linePolynomial, sub_ne_zero_of_ne (hxy rfl)]\n    \u00b7 field_simp [linePolynomial, slope_of_X_ne hx, sub_ne_zero_of_ne hx]\n      ring1\n  nth_rw 1 [hy\u2082]\n  simp only [XYIdeal, XClass, YClass, linePolynomial]\n  rw [\u2190 span_pair_add_mul_right <| CoordinateRing.mk W <| C <| C <| -W.slope x\u2081 x\u2082 y\u2081 y\u2082,\n    \u2190 _root_.map_mul, \u2190 map_add]\n  apply congr_arg (_ \u2218 _ \u2218 _ \u2218 _)\n  eval_simp\n  C_simp\n  ring1", "start": [514, 1], "end": [531, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.addPolynomial_slope", "code": "lemma addPolynomial_slope (hxy : x\u2081 = x\u2082 \u2192 y\u2081 \u2260 W.negY x\u2082 y\u2082) :\n    W.addPolynomial x\u2081 y\u2081 (W.slope x\u2081 x\u2082 y\u2081 y\u2082) =\n      -((X - C x\u2081) * (X - C x\u2082) * (X - C (W.addX x\u2081 x\u2082 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082))) := by\n  clear h\u2082\n  rw [addPolynomial_eq, neg_inj, Cubic.prod_X_sub_C_eq, Cubic.toPoly_injective]\n  by_cases hx : x\u2081 = x\u2082\n  \u00b7 rcases hx, Y_eq_of_Y_ne h\u2081' h\u2082' hx (hxy hx) with \u27e8rfl, rfl\u27e9\n    rw [equation_iff] at h\u2081' h\u2082'\n    rw [slope_of_Y_ne rfl <| hxy rfl]\n    rw [negY, \u2190 sub_ne_zero] at hxy\n    ext\n    \u00b7 rfl\n    \u00b7 simp only [addX]\n      ring1\n    \u00b7 field_simp [hxy rfl]\n      ring1\n    \u00b7 linear_combination (norm := (field_simp [hxy rfl]; ring1)) -h\u2081'\n  \u00b7 rw [equation_iff] at h\u2081' h\u2082'\n    rw [slope_of_X_ne hx]\n    rw [\u2190 sub_eq_zero] at hx\n    ext\n    \u00b7 rfl\n    \u00b7 simp only [addX]\n      ring1\n    \u00b7 apply mul_right_injective\u2080 hx\n      linear_combination (norm := (field_simp [hx]; ring1)) h\u2082' - h\u2081'\n    \u00b7 apply mul_right_injective\u2080 hx\n      linear_combination (norm := (field_simp [hx]; ring1)) x\u2082 * h\u2081' - x\u2081 * h\u2082'", "start": [535, 1], "end": [563, 80], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.C_addPolynomial_slope", "code": "lemma CoordinateRing.C_addPolynomial_slope (hxy : x\u2081 = x\u2082 \u2192 y\u2081 \u2260 W.negY x\u2082 y\u2082) :\n    CoordinateRing.mk W (C <| W.addPolynomial x\u2081 y\u2081 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082) =\n      -(XClass W x\u2081 * XClass W x\u2082 * XClass W (W.addX x\u2081 x\u2082 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082)) := by\n  simp only [addPolynomial_slope h\u2081' h\u2082' hxy, C_neg, mk, map_neg, neg_inj, _root_.map_mul]\n  rfl", "start": [566, 1], "end": [570, 6], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.derivative_addPolynomial_slope", "code": "lemma derivative_addPolynomial_slope (hxy : x\u2081 = x\u2082 \u2192 y\u2081 \u2260 W.negY x\u2082 y\u2082) :\n    derivative (W.addPolynomial x\u2081 y\u2081 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082) =\n      -((X - C x\u2081) * (X - C x\u2082) + (X - C x\u2081) * (X - C (W.addX x\u2081 x\u2082 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082)) +\n          (X - C x\u2082) * (X - C (W.addX x\u2081 x\u2082 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082))) := by\n  rw [addPolynomial_slope h\u2081' h\u2082' hxy]\n  derivative_simp\n  ring1", "start": [574, 1], "end": [580, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.equation_add'", "code": "lemma equation_add' (hxy : x\u2081 = x\u2082 \u2192 y\u2081 \u2260 W.negY x\u2082 y\u2082) :\n    W.equation (W.addX x\u2081 x\u2082 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082) (W.addY' x\u2081 x\u2082 y\u2081 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082) := by\n  rw [equation_add_iff, addPolynomial_slope h\u2081' h\u2082' hxy]\n  eval_simp\n  rw [neg_eq_zero, sub_self, mul_zero]", "start": [585, 1], "end": [591, 39], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.equation_add", "code": "lemma equation_add (hxy : x\u2081 = x\u2082 \u2192 y\u2081 \u2260 W.negY x\u2082 y\u2082) :\n    W.equation (W.addX x\u2081 x\u2082 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082) (W.addY x\u2081 x\u2082 y\u2081 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082) :=\n  equation_neg <| equation_add' h\u2081' h\u2082' hxy", "start": [594, 1], "end": [597, 44], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.nonsingular_add'", "code": "lemma nonsingular_add' (hxy : x\u2081 = x\u2082 \u2192 y\u2081 \u2260 W.negY x\u2082 y\u2082) :\n    W.nonsingular (W.addX x\u2081 x\u2082 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082)\n      (W.addY' x\u2081 x\u2082 y\u2081 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082) := by\n  clear h\u2082'\n  by_cases hx\u2081 : W.addX x\u2081 x\u2082 (W.slope x\u2081 x\u2082 y\u2081 y\u2082) = x\u2081\n  \u00b7 rwa [addY', hx\u2081, sub_self, mul_zero, zero_add]\n  \u00b7 by_cases hx\u2082 : W.addX x\u2081 x\u2082 (W.slope x\u2081 x\u2082 y\u2081 y\u2082) = x\u2082\n    \u00b7 by_cases hx : x\u2081 = x\u2082\n      \u00b7 subst hx\n        contradiction\n      \u00b7 rwa [addY', \u2190 neg_sub, mul_neg, hx\u2082, slope_of_X_ne hx,\n          div_mul_cancel _ <| sub_ne_zero_of_ne hx, neg_sub, sub_add_cancel]\n    \u00b7 apply W.nonsingular_add_of_eval_derivative_ne_zero _ _ _ _ (equation_add' h\u2081.1 h\u2082.1 hxy)\n      rw [derivative_addPolynomial_slope h\u2081.left h\u2082.left hxy]\n      eval_simp\n      simpa only [neg_ne_zero, sub_self, mul_zero, add_zero] using\n        mul_ne_zero (sub_ne_zero_of_ne hx\u2081) (sub_ne_zero_of_ne hx\u2082)", "start": [600, 1], "end": [619, 68], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.nonsingular_add", "code": "lemma nonsingular_add (hxy : x\u2081 = x\u2082 \u2192 y\u2081 \u2260 W.negY x\u2082 y\u2082) :\n    W.nonsingular (W.addX x\u2081 x\u2082 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082) (W.addY x\u2081 x\u2082 y\u2081 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082) :=\n  nonsingular_neg <| nonsingular_add' h\u2081 h\u2082 hxy", "start": [622, 1], "end": [625, 48], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.add", "code": "noncomputable def add : W.Point \u2192 W.Point \u2192 W.Point\n  | 0, P => P\n  | P, 0 => P\n  | @some _ _ _ x\u2081 y\u2081 h\u2081, @some _ _ _ x\u2082 y\u2082 h\u2082 =>\n    if hx : x\u2081 = x\u2082 then\n      if hy : y\u2081 = W.negY x\u2082 y\u2082 then 0 else some <| nonsingular_add h\u2081 h\u2082 fun _ => hy\n    else some <| nonsingular_add h\u2081 h\u2082 fun h => (hx h).elim", "start": [632, 1], "end": [641, 60], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.Point.instAddPoint", "code": "noncomputable instance instAddPoint : Add W.Point :=\n  \u27e8add\u27e9", "start": [644, 1], "end": [645, 8], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.Point.add_def", "code": "lemma add_def (P Q : W.Point) : P.add Q = P + Q :=\n  rfl", "start": [648, 1], "end": [649, 6], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.instAddZeroClassPoint", "code": "noncomputable instance instAddZeroClassPoint : AddZeroClass W.Point :=\n  \u27e8by rintro (_ | _) <;> rfl, by rintro (_ | _) <;> rfl\u27e9", "start": [652, 1], "end": [653, 57], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.Point.some_add_some_of_Y_eq", "code": "@[simp]\nlemma some_add_some_of_Y_eq (hx : x\u2081 = x\u2082) (hy : y\u2081 = W.negY x\u2082 y\u2082) : some h\u2081 + some h\u2082 = 0 := by\n  simp only [\u2190 add_def, add, dif_pos hx, dif_pos hy]", "start": [655, 1], "end": [657, 53], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.some_add_self_of_Y_eq", "code": "@[simp]\nlemma some_add_self_of_Y_eq (hy : y\u2081 = W.negY x\u2081 y\u2081) : some h\u2081 + some h\u2081 = 0 :=\n  some_add_some_of_Y_eq rfl hy", "start": [661, 1], "end": [663, 31], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.some_add_some_of_Y_ne", "code": "@[simp]\nlemma some_add_some_of_Y_ne (hx : x\u2081 = x\u2082) (hy : y\u2081 \u2260 W.negY x\u2082 y\u2082) :\n    some h\u2081 + some h\u2082 = some (nonsingular_add h\u2081 h\u2082 fun _ => hy) := by\n  simp only [\u2190 add_def, add, dif_pos hx, dif_neg hy]", "start": [667, 1], "end": [670, 53], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.some_add_some_of_Y_ne'", "code": "lemma some_add_some_of_Y_ne' (hx : x\u2081 = x\u2082) (hy : y\u2081 \u2260 W.negY x\u2082 y\u2082) :\n    some h\u2081 + some h\u2082 = -some (nonsingular_add' h\u2081 h\u2082 fun _ => hy) :=\n  some_add_some_of_Y_ne hx hy", "start": [674, 1], "end": [676, 30], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.some_add_self_of_Y_ne", "code": "@[simp]\nlemma some_add_self_of_Y_ne (hy : y\u2081 \u2260 W.negY x\u2081 y\u2081) :\n    some h\u2081 + some h\u2081 = some (nonsingular_add h\u2081 h\u2081 fun _ => hy) :=\n  some_add_some_of_Y_ne rfl hy", "start": [680, 1], "end": [683, 31], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.some_add_self_of_Y_ne'", "code": "lemma some_add_self_of_Y_ne' (hy : y\u2081 \u2260 W.negY x\u2081 y\u2081) :\n    some h\u2081 + some h\u2081 = -some (nonsingular_add' h\u2081 h\u2081 fun _ => hy) :=\n  some_add_some_of_Y_ne rfl hy", "start": [687, 1], "end": [689, 31], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.some_add_some_of_X_ne", "code": "@[simp]\nlemma some_add_some_of_X_ne (hx : x\u2081 \u2260 x\u2082) :\n    some h\u2081 + some h\u2082 = some (nonsingular_add h\u2081 h\u2082 fun h => (hx h).elim) := by\n  simp only [\u2190 add_def, add, dif_neg hx]", "start": [693, 1], "end": [696, 41], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.some_add_some_of_X_ne'", "code": "lemma some_add_some_of_X_ne' (hx : x\u2081 \u2260 x\u2082) :\n    some h\u2081 + some h\u2082 = -some (nonsingular_add' h\u2081 h\u2082 fun h => (hx h).elim) :=\n  some_add_some_of_X_ne hx", "start": [700, 1], "end": [702, 27], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.XYIdeal_neg_mul", "code": "lemma XYIdeal_neg_mul : XYIdeal W x\u2081 (C <| W.negY x\u2081 y\u2081) * XYIdeal W x\u2081 (C y\u2081) = XIdeal W x\u2081 := by\n  have Y_rw :\n    (Y - C (C y\u2081)) * (Y - C (C (W.negY x\u2081 y\u2081))) -\n        C (X - C x\u2081) *\n          (C (X ^ 2 + C (x\u2081 + W.a\u2082) * X + C (x\u2081 ^ 2 + W.a\u2082 * x\u2081 + W.a\u2084)) - C (C W.a\u2081) * Y) =\n      W.polynomial * 1 := by\n    linear_combination (norm := (rw [negY, WeierstrassCurve.polynomial]; C_simp; ring1))\n      congr_arg C (congr_arg C ((W.equation_iff _ _).mp h\u2081.left).symm)\n  simp_rw [XYIdeal, XClass, YClass, span_pair_mul_span_pair, mul_comm, \u2190 _root_.map_mul,\n    AdjoinRoot.mk_eq_mk.mpr \u27e81, Y_rw\u27e9, _root_.map_mul, span_insert,\n    \u2190 span_singleton_mul_span_singleton, \u2190 mul_sup, \u2190 span_insert]\n  convert mul_top (_ : Ideal W.CoordinateRing) using 2\n  simp_rw [\u2190 @Set.image_singleton _ _ <| CoordinateRing.mk W, \u2190 Set.image_insert_eq, \u2190 map_span]\n  convert map_top (R := F[X][Y]) (CoordinateRing.mk W) using 1\n  apply congr_arg\n  simp_rw [eq_top_iff_one, mem_span_insert', mem_span_singleton']\n  rcases ((W.nonsingular_iff' _ _).mp h\u2081).right with hx | hy\n  \u00b7 let W_X := W.a\u2081 * y\u2081 - (3 * x\u2081 ^ 2 + 2 * W.a\u2082 * x\u2081 + W.a\u2084)\n    refine\n      \u27e8C (C W_X\u207b\u00b9 * -(X + C (2 * x\u2081 + W.a\u2082))), C (C <| W_X\u207b\u00b9 * W.a\u2081), 0, C (C <| W_X\u207b\u00b9 * -1), ?_\u27e9\n    rw [\u2190 mul_right_inj' <| C_ne_zero.mpr <| C_ne_zero.mpr hx]\n    simp only [mul_add, \u2190 mul_assoc, \u2190 C_mul, mul_inv_cancel hx]\n    C_simp\n    ring1\n  \u00b7 let W_Y := 2 * y\u2081 + W.a\u2081 * x\u2081 + W.a\u2083\n    refine \u27e80, C (C W_Y\u207b\u00b9), C (C <| W_Y\u207b\u00b9 * -1), 0, ?_\u27e9\n    rw [negY, \u2190 mul_right_inj' <| C_ne_zero.mpr <| C_ne_zero.mpr hy]\n    simp only [mul_add, \u2190 mul_assoc, \u2190 C_mul, mul_inv_cancel hy]\n    C_simp\n    ring1", "start": [718, 1], "end": [747, 10], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.XYIdeal'_mul_inv", "code": "private lemma XYIdeal'_mul_inv :\n    XYIdeal W x\u2081 (C y\u2081) *\n        (XYIdeal W x\u2081 (C <| W.negY x\u2081 y\u2081) *\n          (XIdeal W x\u2081 : FractionalIdeal W.CoordinateRing\u2070 W.FunctionField)\u207b\u00b9) =\n      1 := by\n  rw [\u2190 mul_assoc, \u2190 FractionalIdeal.coeIdeal_mul, mul_comm <| XYIdeal W _ _, XYIdeal_neg_mul h\u2081,\n    XIdeal, FractionalIdeal.coe_ideal_span_singleton_mul_inv W.FunctionField <| XClass_ne_zero W x\u2081]", "start": [751, 1], "end": [757, 101], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.XYIdeal_mul_XYIdeal", "code": "lemma XYIdeal_mul_XYIdeal (hxy : x\u2081 = x\u2082 \u2192 y\u2081 \u2260 W.negY x\u2082 y\u2082) :\n    XIdeal W (W.addX x\u2081 x\u2082 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082) * (XYIdeal W x\u2081 (C y\u2081) * XYIdeal W x\u2082 (C y\u2082)) =\n      YIdeal W (linePolynomial x\u2081 y\u2081 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082) *\n        XYIdeal W (W.addX x\u2081 x\u2082 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082)\n          (C <| W.addY x\u2081 x\u2082 y\u2081 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082) := by\n  clear h\u2082\n  have sup_rw : \u2200 a b c d : Ideal W.CoordinateRing, a \u2294 (b \u2294 (c \u2294 d)) = a \u2294 d \u2294 b \u2294 c :=\n    fun _ _ c _ => by rw [\u2190 sup_assoc, @sup_comm _ _ c, sup_sup_sup_comm, \u2190 sup_assoc]\n  rw [XYIdeal_add_eq, XIdeal, mul_comm, W.XYIdeal_eq\u2081 x\u2081 y\u2081 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082, XYIdeal,\n    XYIdeal_eq\u2082 h\u2081' h\u2082' hxy, XYIdeal, span_pair_mul_span_pair]\n  simp_rw [span_insert, sup_rw, sup_mul, span_singleton_mul_span_singleton]\n  rw [\u2190 neg_eq_iff_eq_neg.mpr <| CoordinateRing.C_addPolynomial_slope h\u2081' h\u2082' hxy,\n    span_singleton_neg, CoordinateRing.C_addPolynomial, _root_.map_mul, YClass]\n  simp_rw [mul_comm <| XClass W x\u2081, mul_assoc, \u2190 span_singleton_mul_span_singleton, \u2190 mul_sup]\n  rw [span_singleton_mul_span_singleton, \u2190 span_insert,\n    \u2190 span_pair_add_mul_right <| -(XClass W <| W.addX x\u2081 x\u2082 <| W.slope x\u2081 x\u2082 y\u2081 y\u2082), mul_neg,\n    \u2190 sub_eq_add_neg, \u2190 sub_mul, \u2190 map_sub <| CoordinateRing.mk W, sub_sub_sub_cancel_right,\n    span_insert, \u2190 span_singleton_mul_span_singleton, \u2190 sup_rw, \u2190 sup_mul, \u2190 sup_mul]\n  apply congr_arg (_ \u2218 _)\n  convert top_mul (_ : Ideal W.CoordinateRing)\n  simp_rw [XClass, \u2190 @Set.image_singleton _ _ <| CoordinateRing.mk W, \u2190 map_span, \u2190 Ideal.map_sup,\n    eq_top_iff_one, mem_map_iff_of_surjective _ AdjoinRoot.mk_surjective, \u2190 span_insert,\n    mem_span_insert', mem_span_singleton']\n  by_cases hx : x\u2081 = x\u2082\n  \u00b7 rcases hx, Y_eq_of_Y_ne h\u2081' h\u2082' hx (hxy hx) with \u27e8rfl, rfl\u27e9\n    let y := (y\u2081 - W.negY x\u2081 y\u2081) ^ 2\n    replace hxy := pow_ne_zero 2 (sub_ne_zero_of_ne <| hxy rfl)\n    refine\n      \u27e81 + C (C <| y\u207b\u00b9 * 4) * W.polynomial,\n        \u27e8C <| C y\u207b\u00b9 * (C 4 * X ^ 2 + C (4 * x\u2081 + W.b\u2082) * X + C (4 * x\u2081 ^ 2 + W.b\u2082 * x\u2081 + 2 * W.b\u2084)),\n          0, C (C y\u207b\u00b9) * (Y - W.negPolynomial), ?_\u27e9, by\n        rw [map_add, map_one, _root_.map_mul <| CoordinateRing.mk W, AdjoinRoot.mk_self, mul_zero,\n          add_zero]\u27e9\n    rw [WeierstrassCurve.polynomial, negPolynomial,\n      \u2190 mul_right_inj' <| C_ne_zero.mpr <| C_ne_zero.mpr hxy]\n    simp only [mul_add, \u2190 mul_assoc, \u2190 C_mul, mul_inv_cancel hxy]\n    linear_combination (norm := (rw [b\u2082, b\u2084, negY]; C_simp; ring1))\n      -4 * congr_arg C (congr_arg C <| (W.equation_iff _ _).mp h\u2081')\n  \u00b7 replace hx := sub_ne_zero_of_ne hx\n    refine \u27e8_, \u27e8\u27e8C <| C (x\u2081 - x\u2082)\u207b\u00b9, C <| C <| (x\u2081 - x\u2082)\u207b\u00b9 * -1, 0, ?_\u27e9, map_one _\u27e9\u27e9\n    rw [\u2190 mul_right_inj' <| C_ne_zero.mpr <| C_ne_zero.mpr hx]\n    simp only [\u2190 mul_assoc, mul_add, \u2190 C_mul, mul_inv_cancel hx]\n    C_simp\n    ring1", "start": [759, 1], "end": [803, 10], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.XYIdeal'", "code": "noncomputable def XYIdeal' : (FractionalIdeal W.CoordinateRing\u2070 W.FunctionField)\u02e3 :=\n  Units.mkOfMulEqOne _ _ <| XYIdeal'_mul_inv h\u2081", "start": [808, 1], "end": [810, 48], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.XYIdeal'_eq", "code": "lemma XYIdeal'_eq :\n    (XYIdeal' h\u2081 : FractionalIdeal W.CoordinateRing\u2070 W.FunctionField) = XYIdeal W x\u2081 (C y\u2081) :=\n  rfl", "start": [814, 1], "end": [816, 6], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.mk_XYIdeal'_mul_mk_XYIdeal'_of_Y_eq", "code": "lemma mk_XYIdeal'_mul_mk_XYIdeal'_of_Y_eq :\n    ClassGroup.mk (XYIdeal' <| nonsingular_neg h\u2081) * ClassGroup.mk (XYIdeal' h\u2081) = 1 := by\n  rw [\u2190 _root_.map_mul]\n  exact\n    (ClassGroup.mk_eq_one_of_coe_ideal <| by exact (FractionalIdeal.coeIdeal_mul _ _).symm.trans <|\n      FractionalIdeal.coeIdeal_inj.mpr <| XYIdeal_neg_mul h\u2081).mpr \u27e8_, XClass_ne_zero W _, rfl\u27e9", "start": [820, 1], "end": [825, 95], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.mk_XYIdeal'_mul_mk_XYIdeal'", "code": "lemma mk_XYIdeal'_mul_mk_XYIdeal' (hxy : x\u2081 = x\u2082 \u2192 y\u2081 \u2260 W.negY x\u2082 y\u2082) :\n    ClassGroup.mk (XYIdeal' h\u2081) * ClassGroup.mk (XYIdeal' h\u2082) =\n      ClassGroup.mk (XYIdeal' <| nonsingular_add h\u2081 h\u2082 hxy) := by\n  rw [\u2190 _root_.map_mul]\n  exact\n    (ClassGroup.mk_eq_mk_of_coe_ideal (by exact (FractionalIdeal.coeIdeal_mul _ _).symm) <|\n        XYIdeal'_eq _).mpr\n      \u27e8_, _, XClass_ne_zero W _, YClass_ne_zero W _, XYIdeal_mul_XYIdeal h\u2081.left h\u2082.left hxy\u27e9", "start": [829, 1], "end": [836, 94], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.toClassFun", "code": "@[simp]\nnoncomputable def toClassFun : W.Point \u2192 Additive (ClassGroup W.CoordinateRing)\n  | 0 => 0\n  | some h => Additive.ofMul <| ClassGroup.mk <| XYIdeal' h", "start": [842, 1], "end": [847, 60], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.Point.toClass", "code": "@[simps]\nnoncomputable def toClass : W.Point \u2192+ Additive (ClassGroup W.CoordinateRing) where\n  toFun := toClassFun\n  map_zero' := rfl\n  map_add' := by\n    rintro (_ | @\u27e8x\u2081, y\u2081, h\u2081\u27e9) (_ | @\u27e8x\u2082, y\u2082, h\u2082\u27e9)\n    any_goals simp only [zero_def, toClassFun, _root_.zero_add, _root_.add_zero]\n    by_cases hx : x\u2081 = x\u2082\n    \u00b7 by_cases hy : y\u2081 = W.negY x\u2082 y\u2082\n      \u00b7 substs hx hy\n        simpa only [some_add_some_of_Y_eq rfl rfl] using\n          (mk_XYIdeal'_mul_mk_XYIdeal'_of_Y_eq h\u2082).symm\n      \u00b7 simpa only [some_add_some_of_Y_ne hx hy] using\n          (mk_XYIdeal'_mul_mk_XYIdeal' h\u2081 h\u2082 fun _ => hy).symm\n    \u00b7 simpa only [some_add_some_of_X_ne hx] using\n        (mk_XYIdeal'_mul_mk_XYIdeal' h\u2081 h\u2082 fun h => (hx h).elim).symm", "start": [850, 1], "end": [867, 70], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.Point.toClass_zero", "code": "lemma toClass_zero : toClass (0 : W.Point) = 0 :=\n  rfl", "start": [871, 1], "end": [872, 6], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.toClass_some", "code": "lemma toClass_some : toClass (some h\u2081) = ClassGroup.mk (XYIdeal' h\u2081) :=\n  rfl", "start": [875, 1], "end": [876, 6], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.add_eq_zero", "code": "lemma add_eq_zero (P Q : W.Point) : P + Q = 0 \u2194 P = -Q := by\n  rcases P, Q with \u27e8_ | @\u27e8x\u2081, y\u2081, _\u27e9, _ | @\u27e8x\u2082, y\u2082, _\u27e9\u27e9\n  any_goals rfl\n  \u00b7 rw [zero_def, zero_add, \u2190 neg_eq_iff_eq_neg, neg_zero, eq_comm]\n  \u00b7 rw [neg_some, some.injEq]\n    constructor\n    \u00b7 intro h\n      by_cases hx : x\u2081 = x\u2082\n      \u00b7 by_cases hy : y\u2081 = W.negY x\u2082 y\u2082\n        \u00b7 exact \u27e8hx, hy\u27e9\n        \u00b7 rw [some_add_some_of_Y_ne hx hy] at h\n          contradiction\n      \u00b7 rw [some_add_some_of_X_ne hx] at h\n        contradiction\n    \u00b7 exact fun \u27e8hx, hy\u27e9 => some_add_some_of_Y_eq hx hy", "start": [880, 1], "end": [894, 56], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.add_left_neg", "code": "lemma add_left_neg (P : W.Point) : -P + P = 0 := by\n  rw [add_eq_zero]", "start": [898, 1], "end": [899, 19], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.neg_add_eq_zero", "code": "lemma neg_add_eq_zero (P Q : W.Point) : -P + Q = 0 \u2194 P = Q := by\n  rw [add_eq_zero, neg_inj]", "start": [903, 1], "end": [904, 28], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.toClass_eq_zero", "code": "lemma toClass_eq_zero (P : W.Point) : toClass P = 0 \u2194 P = 0 := by\n  constructor\n  \u00b7 intro hP\n    rcases P with (_ | @\u27e8_, _, \u27e8h, _\u27e9\u27e9)\n    \u00b7 rfl\n    \u00b7 rcases (ClassGroup.mk_eq_one_of_coe_ideal <| by rfl).mp hP with \u27e8p, h0, hp\u27e9\n      apply (p.natDegree_norm_ne_one _).elim\n      rw [\u2190 finrank_quotient_span_eq_natDegree_norm (CoordinateRing.basis W) h0,\n        \u2190 (quotientEquivAlgOfEq F hp).toLinearEquiv.finrank_eq,\n        (quotientXYIdealEquiv W h).toLinearEquiv.finrank_eq, FiniteDimensional.finrank_self]\n  \u00b7 exact congr_arg toClass", "start": [907, 1], "end": [917, 28], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.toClass_injective", "code": "lemma toClass_injective : Function.Injective <| @toClass _ _ W := by\n  rintro (_ | h) _ hP\n  all_goals rw [\u2190 neg_add_eq_zero, \u2190 toClass_eq_zero, map_add, \u2190 hP]\n  \u00b7 exact zero_add 0\n  \u00b7 exact mk_XYIdeal'_mul_mk_XYIdeal'_of_Y_eq h", "start": [920, 1], "end": [924, 48], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.add_comm", "code": "lemma add_comm (P Q : W.Point) : P + Q = Q + P :=\n  toClass_injective <| by simp only [map_add, _root_.add_comm]", "start": [927, 1], "end": [928, 63], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.add_assoc", "code": "lemma add_assoc (P Q R : W.Point) : P + Q + R = P + (Q + R) :=\n  toClass_injective <| by simp only [map_add, _root_.add_assoc]", "start": [931, 1], "end": [932, 64], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.Point.instAddCommGroupPoint", "code": "noncomputable instance instAddCommGroupPoint : AddCommGroup W.Point where\n  zero := zero\n  neg := neg\n  add := add\n  zero_add := zero_add\n  add_zero := add_zero\n  add_left_neg := add_left_neg\n  add_comm := add_comm\n  add_assoc := add_assoc", "start": [935, 1], "end": [943, 25], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.Point.ofBaseChangeFun", "code": "def ofBaseChangeFun : W\u27eeF\u27ef \u2192 W\u27eeK\u27ef\n  | 0 => 0\n  | some h => some <| (nonsingular_iff_baseChange_of_baseChange W F K _ _).mp h", "start": [960, 1], "end": [963, 80], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.Point.ofBaseChange", "code": "@[simps]\ndef ofBaseChange : W\u27eeF\u27ef \u2192+ W\u27eeK\u27ef where\n  toFun := ofBaseChangeFun W F K\n  map_zero' := rfl\n  map_add' := by\n    rintro (_ | @\u27e8x\u2081, y\u2081, _\u27e9) (_ | @\u27e8x\u2082, y\u2082, _\u27e9)\n    any_goals rfl\n    by_cases hx : x\u2081 = x\u2082\n    \u00b7 by_cases hy : y\u2081 = (W.baseChange F).negY x\u2082 y\u2082\n      \u00b7 simp only [some_add_some_of_Y_eq hx hy, ofBaseChangeFun]\n        rw [some_add_some_of_Y_eq <| congr_arg _ hx]\n        \u00b7 rw [hy, baseChange_negY_of_baseChange]\n      \u00b7 simp only [some_add_some_of_Y_ne hx hy, ofBaseChangeFun]\n        rw [some_add_some_of_Y_ne <| congr_arg _ hx]\n        \u00b7 simp only [baseChange_addX_of_baseChange, baseChange_addY_of_baseChange,\n            baseChange_slope_of_baseChange]\n        \u00b7 rw [baseChange_negY_of_baseChange]\n          contrapose! hy\n          exact NoZeroSMulDivisors.algebraMap_injective F K hy\n    \u00b7 simp only [some_add_some_of_X_ne hx, ofBaseChangeFun]\n      rw [some_add_some_of_X_ne]\n      \u00b7 simp only [baseChange_addX_of_baseChange, baseChange_addY_of_baseChange,\n          baseChange_slope_of_baseChange]\n      \u00b7 contrapose! hx\n        exact NoZeroSMulDivisors.algebraMap_injective F K hx", "start": [966, 1], "end": [991, 61], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.Point.ofBaseChange_injective", "code": "lemma ofBaseChange_injective : Function.Injective <| ofBaseChange W F K := by\n  rintro (_ | _) (_ | _) h\n  any_goals contradiction\n  \u00b7 rfl\n  \u00b7 rw [some.injEq]\n    exact\n      \u27e8NoZeroSMulDivisors.algebraMap_injective F K (some.inj h).left,\n        NoZeroSMulDivisors.algebraMap_injective F K (some.inj h).right\u27e9", "start": [994, 1], "end": [1001, 72], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.Point.mk", "code": "def mk {x y : R} (h : E.equation x y) : E.Point :=\n  WeierstrassCurve.Point.some <| E.nonsingular h", "start": [1018, 1], "end": [1020, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/Fraisse.lean", "imports": ["Mathlib/ModelTheory/Bundled.lean", "Mathlib/ModelTheory/FinitelyGenerated.lean", "Mathlib/ModelTheory/DirectLimit.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FirstOrder.Language.age", "code": "def age (M : Type w) [L.Structure M] : Set (Bundled.{w} L.Structure) :=\n  {N | Structure.FG L N \u2227 Nonempty (N \u21aa[L] M)}", "start": [77, 1], "end": [79, 47], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Hereditary", "code": "def Hereditary : Prop :=\n  \u2200 M : Bundled.{w} L.Structure, M \u2208 K \u2192 L.age M \u2286 K", "start": [84, 1], "end": [87, 53], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.JointEmbedding", "code": "def JointEmbedding : Prop :=\n  DirectedOn (fun M N : Bundled.{w} L.Structure => Nonempty (M \u21aa[L] N)) K", "start": [90, 1], "end": [93, 74], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Amalgamation", "code": "def Amalgamation : Prop :=\n  \u2200 (M N P : Bundled.{w} L.Structure) (MN : M \u21aa[L] N) (MP : M \u21aa[L] P),\n    M \u2208 K \u2192 N \u2208 K \u2192 P \u2208 K \u2192 \u2203 (Q : Bundled.{w} L.Structure) (NQ : N \u21aa[L] Q) (PQ : P \u21aa[L] Q),\n      Q \u2208 K \u2227 NQ.comp MN = PQ.comp MP", "start": [96, 1], "end": [102, 38], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.IsFraisse", "code": "class IsFraisse : Prop where\n  is_nonempty : K.Nonempty\n  FG : \u2200 M : Bundled.{w} L.Structure, M \u2208 K \u2192 Structure.FG L M\n  is_equiv_invariant : \u2200 M N : Bundled.{w} L.Structure, Nonempty (M \u2243[L] N) \u2192 (M \u2208 K \u2194 N \u2208 K)\n  is_essentially_countable : (Quotient.mk' '' K).Countable\n  hereditary : Hereditary K\n  jointEmbedding : JointEmbedding K\n  amalgamation : Amalgamation K", "start": [105, 1], "end": [114, 32], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.age.is_equiv_invariant", "code": "theorem age.is_equiv_invariant (N P : Bundled.{w} L.Structure) (h : Nonempty (N \u2243[L] P)) :\n    N \u2208 L.age M \u2194 P \u2208 L.age M", "start": [119, 1], "end": [123, 65], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Embedding.age_subset_age", "code": "theorem Embedding.age_subset_age (MN : M \u21aa[L] N) : L.age M \u2286 L.age N", "start": [128, 1], "end": [129, 39], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Equiv.age_eq_age", "code": "theorem Equiv.age_eq_age (MN : M \u2243[L] N) : L.age M = L.age N", "start": [132, 1], "end": [133, 79], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.FG.mem_age_of_equiv", "code": "theorem Structure.FG.mem_age_of_equiv {M N : Bundled L.Structure} (h : Structure.FG L M)\n    (MN : Nonempty (M \u2243[L] N)) : N \u2208 L.age M", "start": [136, 1], "end": [138, 51], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Hereditary.is_equiv_invariant_of_fg", "code": "theorem Hereditary.is_equiv_invariant_of_fg (h : Hereditary K)\n    (fg : \u2200 M : Bundled.{w} L.Structure, M \u2208 K \u2192 Structure.FG L M) (M N : Bundled.{w} L.Structure)\n    (hn : Nonempty (M \u2243[L] N)) : M \u2208 K \u2194 N \u2208 K", "start": [142, 1], "end": [146, 65], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.age.nonempty", "code": "theorem age.nonempty : (L.age M).Nonempty", "start": [151, 1], "end": [153, 87], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.age.hereditary", "code": "theorem age.hereditary : Hereditary (L.age M)", "start": [156, 1], "end": [156, 94], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.age.jointEmbedding", "code": "theorem age.jointEmbedding : JointEmbedding (L.age M)", "start": [159, 1], "end": [164, 80], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.age.countable_quotient", "code": "theorem age.countable_quotient [h : Countable M] : (Quotient.mk' '' L.age M).Countable", "start": [167, 1], "end": [182, 31], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.age_directLimit", "code": "theorem age_directLimit {\u03b9 : Type w} [Preorder \u03b9] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] [Nonempty \u03b9]\n    (G : \u03b9 \u2192 Type max w w') [\u2200 i, L.Structure (G i)] (f : \u2200 i j, i \u2264 j \u2192 G i \u21aa[L] G j)\n    [DirectedSystem G fun i j h => f i j h] : L.age (DirectLimit G f) = \u22c3 i : \u03b9, L.age (G i)", "start": [185, 1], "end": [208, 63], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.exists_cg_is_age_of", "code": "theorem exists_cg_is_age_of (hn : K.Nonempty)\n    (h : \u2200 M N : Bundled.{w} L.Structure, Nonempty (M \u2243[L] N) \u2192 (M \u2208 K \u2194 N \u2208 K))\n    (hc : (Quotient.mk' '' K).Countable)\n    (fg : \u2200 M : Bundled.{w} L.Structure, M \u2208 K \u2192 Structure.FG L M) (hp : Hereditary K)\n    (jep : JointEmbedding K) : \u2203 M : Bundled.{w} L.Structure, Structure.CG L M \u2227 L.age M = K", "start": [211, 1], "end": [246, 34], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.exists_countable_is_age_of_iff", "code": "theorem exists_countable_is_age_of_iff [Countable (\u03a3 l, L.Functions l)] :\n    (\u2203 M : Bundled.{w} L.Structure, Countable M \u2227 L.age M = K) \u2194\n      K.Nonempty \u2227 (\u2200 M N : Bundled.{w} L.Structure, Nonempty (M \u2243[L] N) \u2192 (M \u2208 K \u2194 N \u2208 K)) \u2227\n      (Quotient.mk' '' K).Countable \u2227 (\u2200 M : Bundled.{w} L.Structure, M \u2208 K \u2192 Structure.FG L M) \u2227\n      Hereditary K \u2227 JointEmbedding K", "start": [249, 1], "end": [260, 52], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.IsUltrahomogeneous", "code": "def IsUltrahomogeneous : Prop :=\n  \u2200 (S : L.Substructure M) (_ : S.FG) (f : S \u21aa[L] M),\n    \u2203 g : M \u2243[L] M, f = g.toEmbedding.comp S.subtype", "start": [265, 1], "end": [269, 53], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.IsFraisseLimit", "code": "structure IsFraisseLimit [Countable (\u03a3 l, L.Functions l)] [Countable M] : Prop where\n  protected ultrahomogeneous : IsUltrahomogeneous L M\n  protected age : L.age M = K", "start": [274, 1], "end": [278, 30], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.IsUltrahomogeneous.amalgamation_age", "code": "theorem IsUltrahomogeneous.amalgamation_age (h : L.IsUltrahomogeneous M) :\n    Amalgamation (L.age M)", "start": [283, 1], "end": [306, 7], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.IsUltrahomogeneous.age_isFraisse", "code": "theorem IsUltrahomogeneous.age_isFraisse [Countable M] (h : L.IsUltrahomogeneous M) :\n    IsFraisse (L.age M)", "start": [309, 1], "end": [312, 64], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.IsFraisseLimit.isFraisse", "code": "theorem isFraisse [Countable (\u03a3 l, L.Functions l)] [Countable M] (h : IsFraisseLimit K M) :\n    IsFraisse K", "start": [317, 1], "end": [320, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Category/FinBoolAlg.lean", "imports": ["Mathlib/Order/Category/FinBddDistLat.lean", "Mathlib/Order/Category/BoolAlg.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/Powerset.lean", "Mathlib/Tactic/ApplyFun.lean", "Mathlib/Order/Hom/CompleteLattice.lean"], "premises": [{"full_name": "FinBoolAlg", "code": "structure FinBoolAlg where\n  toBoolAlg : BoolAlg\n  [isFintype : Fintype toBoolAlg]", "start": [37, 1], "end": [40, 34], "kind": "commanddeclaration"}, {"full_name": "FinBoolAlg.of", "code": "def of (\u03b1 : Type*) [BooleanAlgebra \u03b1] [Fintype \u03b1] : FinBoolAlg :=\n  \u27e8{\u03b1 := \u03b1}\u27e9", "start": [60, 1], "end": [62, 13], "kind": "commanddeclaration"}, {"full_name": "FinBoolAlg.coe_of", "code": "@[simp]\ntheorem coe_of (\u03b1 : Type*) [BooleanAlgebra \u03b1] [Fintype \u03b1] : \u21a5(of \u03b1) = \u03b1", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "FinBoolAlg.largeCategory", "code": "instance largeCategory : LargeCategory FinBoolAlg :=\n  InducedCategory.category FinBoolAlg.toBoolAlg", "start": [73, 1], "end": [74, 48], "kind": "commanddeclaration"}, {"full_name": "FinBoolAlg.concreteCategory", "code": "instance concreteCategory : ConcreteCategory FinBoolAlg :=\n  InducedCategory.concreteCategory FinBoolAlg.toBoolAlg", "start": [77, 1], "end": [78, 56], "kind": "commanddeclaration"}, {"full_name": "FinBoolAlg.instBoundedLatticeHomClass", "code": "instance instBoundedLatticeHomClass {X Y : FinBoolAlg} : BoundedLatticeHomClass (X \u27f6 Y) X Y :=\n  BoundedLatticeHom.instBoundedLatticeHomClass", "start": [85, 1], "end": [86, 47], "kind": "commanddeclaration"}, {"full_name": "FinBoolAlg.hasForgetToBoolAlg", "code": "instance hasForgetToBoolAlg : HasForget\u2082 FinBoolAlg BoolAlg :=\n  InducedCategory.hasForget\u2082 FinBoolAlg.toBoolAlg", "start": [88, 1], "end": [89, 50], "kind": "commanddeclaration"}, {"full_name": "FinBoolAlg.hasForgetToFinBddDistLat", "code": "instance hasForgetToFinBddDistLat : HasForget\u2082 FinBoolAlg FinBddDistLat where\n  forget\u2082.obj X := FinBddDistLat.of X\n  forget\u2082.map f := f\n  forget_comp := rfl", "start": [92, 1], "end": [95, 21], "kind": "commanddeclaration"}, {"full_name": "FinBoolAlg.forgetToBoolAlgFull", "code": "instance forgetToBoolAlgFull : Full (forget\u2082 FinBoolAlg BoolAlg) :=\n  InducedCategory.full _", "start": [98, 1], "end": [99, 25], "kind": "commanddeclaration"}, {"full_name": "FinBoolAlg.forgetToBoolAlgFaithful", "code": "instance forgetToBoolAlgFaithful : Faithful (forget\u2082 FinBoolAlg BoolAlg) :=\n  InducedCategory.faithful _", "start": [102, 1], "end": [103, 29], "kind": "commanddeclaration"}, {"full_name": "FinBoolAlg.hasForgetToFinPartOrd", "code": "@[simps]\ninstance hasForgetToFinPartOrd : HasForget\u2082 FinBoolAlg FinPartOrd where\n  forget\u2082.obj X := FinPartOrd.of X\n  forget\u2082.map {X Y} f := show OrderHom X Y from \u2191(show BoundedLatticeHom X Y from f)", "start": [106, 1], "end": [109, 85], "kind": "commanddeclaration"}, {"full_name": "FinBoolAlg.forgetToFinPartOrdFaithful", "code": "instance forgetToFinPartOrdFaithful : Faithful (forget\u2082 FinBoolAlg FinPartOrd) :=\n  \u27e8fun {X Y} f g h => by\n    dsimp at *\n    apply FunLike.coe_injective\n    dsimp\n    ext x\n    apply_fun (fun f => f x) at h\n    exact h \u27e9", "start": [112, 1], "end": [125, 14], "kind": "commanddeclaration"}, {"full_name": "FinBoolAlg.Iso.mk", "code": "@[simps]\ndef Iso.mk {\u03b1 \u03b2 : FinBoolAlg.{u}} (e : \u03b1 \u2243o \u03b2) : \u03b1 \u2245 \u03b2 where\n  hom := (e : BoundedLatticeHom \u03b1 \u03b2)\n  inv := (e.symm : BoundedLatticeHom \u03b2 \u03b1)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _", "start": [128, 1], "end": [135, 51], "kind": "commanddeclaration"}, {"full_name": "FinBoolAlg.dual", "code": "@[simps]\ndef dual : FinBoolAlg \u2964 FinBoolAlg where\n  obj X := of X\u1d52\u1d48\n  map {X Y} := BoundedLatticeHom.dual", "start": [138, 1], "end": [142, 38], "kind": "commanddeclaration"}, {"full_name": "FinBoolAlg.dualEquiv", "code": "@[simps functor inverse]\ndef dualEquiv : FinBoolAlg \u224c FinBoolAlg where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X", "start": [145, 1], "end": [151, 74], "kind": "commanddeclaration"}, {"full_name": "finBoolAlg_dual_comp_forget_to_finBddDistLat", "code": "theorem finBoolAlg_dual_comp_forget_to_finBddDistLat :\n    FinBoolAlg.dual \u22d9 forget\u2082 FinBoolAlg FinBddDistLat =\n      forget\u2082 FinBoolAlg FinBddDistLat \u22d9 FinBddDistLat.dual", "start": [156, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "fintypeToFinBoolAlgOp", "code": "@[simps]\ndef fintypeToFinBoolAlgOp : FintypeCat \u2964 FinBoolAlg\u1d52\u1d56 where\n  obj X := op <| FinBoolAlg.of (Set X)\n  map {X Y} f :=\n    Quiver.Hom.op <| (CompleteLatticeHom.setPreimage f : BoundedLatticeHom (Set Y) (Set X))", "start": [162, 1], "end": [167, 92], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/Sheaf/Smooth.lean", "imports": ["Mathlib/Algebra/Category/Ring/FilteredColimits.lean", "Mathlib/Algebra/Category/Ring/Colimits.lean", "Mathlib/Geometry/Manifold/Sheaf/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Geometry/Manifold/Algebra/SmoothFunctions.lean", "Mathlib/CategoryTheory/Sites/Whiskering.lean"], "premises": [{"full_name": "smoothSheaf", "code": "def smoothSheaf : TopCat.Sheaf (Type u) (TopCat.of M) :=\n  (contDiffWithinAt_localInvariantProp IM I \u22a4).sheaf M N", "start": [83, 1], "end": [85, 57], "kind": "commanddeclaration"}, {"full_name": "smoothSheaf.coeFun", "code": "instance smoothSheaf.coeFun (U : (Opens (TopCat.of M))\u1d52\u1d56) :\n    CoeFun ((smoothSheaf IM I M N).presheaf.obj U) (fun _ \u21a6 \u2191(unop U) \u2192 N) :=\n  (contDiffWithinAt_localInvariantProp IM I \u22a4).sheafHasCoeToFun _ _ _", "start": [89, 1], "end": [91, 70], "kind": "commanddeclaration"}, {"full_name": "smoothSheaf.obj_eq", "code": "lemma smoothSheaf.obj_eq (U : (Opens (TopCat.of M))\u1d52\u1d56) :\n    (smoothSheaf IM I M N).presheaf.obj U = C^\u221e\u27eeIM, (unop U : Opens M); I, N\u27ef := rfl", "start": [94, 1], "end": [98, 85], "kind": "mathlibtacticlemma"}, {"full_name": "smoothSheaf.eval", "code": "def smoothSheaf.eval (x : M) : (smoothSheaf IM I M N).presheaf.stalk x \u2192 N :=\n  TopCat.stalkToFiber (StructureGroupoid.LocalInvariantProp.localPredicate M N _) x", "start": [100, 1], "end": [103, 84], "kind": "commanddeclaration"}, {"full_name": "smoothSheaf.evalHom", "code": "def smoothSheaf.evalHom (x : TopCat.of M) : (smoothSheaf IM I M N).presheaf.stalk x \u27f6 N :=\n  TopCat.stalkToFiber (StructureGroupoid.LocalInvariantProp.localPredicate M N _) x", "start": [105, 1], "end": [108, 84], "kind": "commanddeclaration"}, {"full_name": "smoothSheaf.evalAt", "code": "def smoothSheaf.evalAt (x : TopCat.of M) (U : OpenNhds x)\n    (i : (smoothSheaf IM I M N).presheaf.obj (Opposite.op U.obj)) : N :=\n  i.1 \u27e8x, U.2\u27e9", "start": [112, 1], "end": [116, 15], "kind": "commanddeclaration"}, {"full_name": "smoothSheaf.\u03b9_evalHom", "code": "@[simp, reassoc, elementwise] lemma smoothSheaf.\u03b9_evalHom (x : TopCat.of M) (U) :\n    colimit.\u03b9 ((OpenNhds.inclusion x).op \u22d9 (smoothSheaf IM I M N).val) U \u226b\n    smoothSheaf.evalHom IM I N x =\n    smoothSheaf.evalAt _ _ _ _ _ :=\n  colimit.\u03b9_desc _ _", "start": [118, 1], "end": [122, 21], "kind": "mathlibtacticlemma"}, {"full_name": "smoothSheaf.eval_surjective", "code": "lemma smoothSheaf.eval_surjective (x : M) : Function.Surjective (smoothSheaf.eval IM I N x) := by\n  apply TopCat.stalkToFiber_surjective\n  intro n\n  exact \u27e8\u22a4, fun _ \u21a6 n, smooth_const, rfl\u27e9", "start": [124, 1], "end": [128, 42], "kind": "mathlibtacticlemma"}, {"full_name": "smoothSheaf.eval_germ", "code": "@[simp] lemma smoothSheaf.eval_germ (U : Opens (TopCat.of M)) (x : U)\n    (f : (smoothSheaf IM I M N).presheaf.obj (op U)) :\n    smoothSheaf.eval IM I N (x : TopCat.of M) ((smoothSheaf IM I M N).presheaf.germ x f) = f x :=\n  TopCat.stalkToFiber_germ _ U x f", "start": [132, 1], "end": [135, 35], "kind": "mathlibtacticlemma"}, {"full_name": "smoothSheaf.smooth_section", "code": "lemma smoothSheaf.smooth_section {U : (Opens (TopCat.of M))\u1d52\u1d56}\n    (f : (smoothSheaf IM I M N).presheaf.obj U) :\n    Smooth IM I f :=\n  (contDiffWithinAt_localInvariantProp IM I \u22a4).section_spec _ _ _ _", "start": [137, 1], "end": [140, 68], "kind": "mathlibtacticlemma"}, {"full_name": "smoothPresheafGroup", "code": "@[to_additive \"The presheaf of smooth functions from `M` to `G`, for `G` an additive Lie group, as a\npresheaf of additive groups.\"]\nnoncomputable def smoothPresheafGroup : TopCat.Presheaf GroupCat.{u} (TopCat.of M) :=\n  { obj := fun U \u21a6 GroupCat.of ((smoothSheaf IM I M G).presheaf.obj U)\n    map := fun h \u21a6 GroupCat.ofHom <|\n      SmoothMap.restrictMonoidHom IM I G <| CategoryTheory.leOfHom h.unop\n    map_id := fun _ \u21a6 rfl\n    map_comp := fun _ _ \u21a6 rfl }", "start": [153, 1], "end": [162, 32], "kind": "commanddeclaration"}, {"full_name": "smoothSheafGroup", "code": "@[to_additive \"The sheaf of smooth functions from `M` to `G`, for `G` an additive Lie group, as a\nsheaf of additive groups.\"]\nnoncomputable def smoothSheafGroup : TopCat.Sheaf GroupCat.{u} (TopCat.of M) :=\n  { val := smoothPresheafGroup IM I M G\n    cond := by\n      rw [CategoryTheory.Presheaf.isSheaf_iff_isSheaf_forget _ _ (CategoryTheory.forget GroupCat)]\n      exact CategoryTheory.Sheaf.cond (smoothSheaf IM I M G) }", "start": [164, 1], "end": [172, 63], "kind": "commanddeclaration"}, {"full_name": "smoothPresheafCommGroup", "code": "@[to_additive \"The presheaf of smooth functions from `M` to `A`, for `A` an additive abelian Lie\ngroup, as a presheaf of additive abelian groups.\"]\nnoncomputable def smoothPresheafCommGroup : TopCat.Presheaf CommGroupCat.{u} (TopCat.of M) :=\n  { obj := fun U \u21a6 CommGroupCat.of ((smoothSheaf IM I M A).presheaf.obj U)\n    map := fun h \u21a6 CommGroupCat.ofHom <|\n      SmoothMap.restrictMonoidHom IM I A <| CategoryTheory.leOfHom h.unop\n    map_id := fun _ \u21a6 rfl\n    map_comp := fun _ _ \u21a6 rfl }", "start": [184, 1], "end": [193, 32], "kind": "commanddeclaration"}, {"full_name": "smoothSheafCommGroup", "code": "@[to_additive \"The sheaf of smooth functions from `M` to\n`A`, for `A` an abelian additive Lie group, as a sheaf of abelian additive groups.\"]\nnoncomputable def smoothSheafCommGroup : TopCat.Sheaf CommGroupCat.{u} (TopCat.of M) :=\n  { val := smoothPresheafCommGroup IM I M A\n    cond := by\n      rw [CategoryTheory.Presheaf.isSheaf_iff_isSheaf_forget _ _\n        (CategoryTheory.forget CommGroupCat)]\n      exact CategoryTheory.Sheaf.cond (smoothSheaf IM I M A) }", "start": [195, 1], "end": [204, 63], "kind": "commanddeclaration"}, {"full_name": "smoothSheafCommGroup.compLeft", "code": "@[to_additive \"For a manifold `M` and a smooth homomorphism `\u03c6` between abelian additive Lie groups\n`A`, `A'`, the 'left-composition-by-`\u03c6`' morphism of sheaves from `smoothSheafAddCommGroup IM I M A`\nto `smoothSheafAddCommGroup IM I' M A'`.\"]\ndef smoothSheafCommGroup.compLeft (\u03c6 : A \u2192* A') (h\u03c6 : Smooth I I' \u03c6) :\n    smoothSheafCommGroup IM I M A \u27f6 smoothSheafCommGroup IM I' M A' :=\n  CategoryTheory.Sheaf.Hom.mk <|\n  { app := fun _ \u21a6 CommGroupCat.ofHom <| SmoothMap.compLeftMonoidHom _ _ \u03c6 h\u03c6\n    naturality := fun _ _ _ \u21a6 rfl }", "start": [206, 1], "end": [216, 36], "kind": "commanddeclaration"}, {"full_name": "smoothPresheafRing", "code": "def smoothPresheafRing : TopCat.Presheaf RingCat.{u} (TopCat.of M) :=\n  { obj := fun U \u21a6 RingCat.of ((smoothSheaf IM I M R).presheaf.obj U)\n    map := fun h \u21a6 RingCat.ofHom <|\n      SmoothMap.restrictRingHom IM I R <| CategoryTheory.leOfHom h.unop\n    map_id := fun _ \u21a6 rfl\n    map_comp := fun _ _ \u21a6 rfl }", "start": [227, 1], "end": [234, 32], "kind": "commanddeclaration"}, {"full_name": "smoothSheafRing", "code": "def smoothSheafRing : TopCat.Sheaf RingCat.{u} (TopCat.of M) :=\n  { val := smoothPresheafRing IM I M R\n    cond := by\n      rw [CategoryTheory.Presheaf.isSheaf_iff_isSheaf_forget _ _ (CategoryTheory.forget RingCat)]\n      exact CategoryTheory.Sheaf.cond (smoothSheaf IM I M R) }", "start": [236, 1], "end": [242, 63], "kind": "commanddeclaration"}, {"full_name": "smoothPresheafCommRing", "code": "def smoothPresheafCommRing : TopCat.Presheaf CommRingCat.{u} (TopCat.of M) :=\n  { obj := fun U \u21a6 CommRingCat.of ((smoothSheaf IM I M R).presheaf.obj U)\n    map := fun h \u21a6 CommRingCat.ofHom <|\n      SmoothMap.restrictRingHom IM I R <| CategoryTheory.leOfHom h.unop\n    map_id := fun _ \u21a6 rfl\n    map_comp := fun _ _ \u21a6 rfl }", "start": [253, 1], "end": [260, 32], "kind": "commanddeclaration"}, {"full_name": "smoothSheafCommRing", "code": "def smoothSheafCommRing : TopCat.Sheaf CommRingCat.{u} (TopCat.of M) :=\n  { val := smoothPresheafCommRing IM I M R\n    cond := by\n      rw [CategoryTheory.Presheaf.isSheaf_iff_isSheaf_forget _ _\n        (CategoryTheory.forget CommRingCat)]\n      exact CategoryTheory.Sheaf.cond (smoothSheaf IM I M R) }", "start": [262, 1], "end": [269, 63], "kind": "commanddeclaration"}, {"full_name": "smoothSheafCommRing.coeFun", "code": "instance smoothSheafCommRing.coeFun (U : (Opens (TopCat.of M))\u1d52\u1d56) :\n    CoeFun ((smoothSheafCommRing IM I M R).presheaf.obj U) (fun _ \u21a6 \u2191(unop U) \u2192 R) :=\n  (contDiffWithinAt_localInvariantProp IM I \u22a4).sheafHasCoeToFun _ _ _", "start": [276, 1], "end": [278, 70], "kind": "commanddeclaration"}, {"full_name": "smoothSheafCommRing.forgetStalk", "code": "def smoothSheafCommRing.forgetStalk (x : TopCat.of M) :\n    (forget _).obj ((smoothSheafCommRing IM I M R).presheaf.stalk x) \u2245\n    (smoothSheaf IM I M R).presheaf.stalk x :=\n  preservesColimitIso _ _", "start": [282, 1], "end": [287, 26], "kind": "commanddeclaration"}, {"full_name": "smoothSheafCommRing.\u03b9_forgetStalk_hom", "code": "@[simp, reassoc, elementwise] lemma smoothSheafCommRing.\u03b9_forgetStalk_hom (x : TopCat.of M) (U) :\n    CategoryStruct.comp\n      (Z := (smoothSheaf IM I M R).presheaf.stalk x)\n      (FunLike.coe\n        (\u03b1 := ((forget CommRingCat).obj ((smoothSheafCommRing IM I M R).presheaf.obj\n          (op ((OpenNhds.inclusion x).obj U.unop)))))\n        (colimit.\u03b9 ((OpenNhds.inclusion x).op \u22d9 (smoothSheafCommRing IM I M R).presheaf) U))\n      (forgetStalk IM I M R x).hom =\n    colimit.\u03b9 ((OpenNhds.inclusion x).op \u22d9 (smoothSheaf IM I M R).presheaf) U :=\n  \u03b9_preservesColimitsIso_hom _ _ _", "start": [289, 1], "end": [298, 35], "kind": "mathlibtacticlemma"}, {"full_name": "smoothSheafCommRing.\u03b9_forgetStalk_inv", "code": "@[simp, reassoc, elementwise] lemma smoothSheafCommRing.\u03b9_forgetStalk_inv (x : TopCat.of M) (U) :\n    colimit.\u03b9 ((OpenNhds.inclusion x).op \u22d9 (smoothSheaf IM I M R).val) U \u226b\n    (smoothSheafCommRing.forgetStalk IM I M R x).inv =\n    (forget CommRingCat).map\n      (colimit.\u03b9 ((OpenNhds.inclusion x).op \u22d9 (smoothSheafCommRing IM I M R).val) U) := by\n  rw [Iso.comp_inv_eq, \u2190 smoothSheafCommRing.\u03b9_forgetStalk_hom, CommRingCat.forget_map]\n  simp_rw [Functor.comp_obj, Functor.op_obj]", "start": [300, 1], "end": [306, 45], "kind": "mathlibtacticlemma"}, {"full_name": "smoothSheafCommRing.evalAt", "code": "def smoothSheafCommRing.evalAt (x : TopCat.of M) (U : OpenNhds x) :\n    (smoothSheafCommRing IM I M R).presheaf.obj (Opposite.op U.1) \u27f6 CommRingCat.of R :=\n  SmoothMap.evalRingHom \u27e8x, U.2\u27e9", "start": [308, 1], "end": [312, 33], "kind": "commanddeclaration"}, {"full_name": "smoothSheafCommRing.evalHom", "code": "def smoothSheafCommRing.evalHom (x : TopCat.of M) :\n    (smoothSheafCommRing IM I M R).presheaf.stalk x \u27f6 CommRingCat.of R := by\n  refine CategoryTheory.Limits.colimit.desc _ \u27e8_, \u27e8fun U \u21a6 ?_, ?_\u27e9\u27e9\n  \u00b7 apply smoothSheafCommRing.evalAt\n  \u00b7 aesop_cat", "start": [314, 1], "end": [321, 14], "kind": "commanddeclaration"}, {"full_name": "smoothSheafCommRing.eval", "code": "def smoothSheafCommRing.eval (x : M) : (smoothSheafCommRing IM I M R).presheaf.stalk x \u2192+* R :=\n  smoothSheafCommRing.evalHom IM I M R x", "start": [323, 1], "end": [326, 41], "kind": "commanddeclaration"}, {"full_name": "smoothSheafCommRing.\u03b9_evalHom", "code": "@[simp, reassoc, elementwise] lemma smoothSheafCommRing.\u03b9_evalHom (x : TopCat.of M) (U) :\n    colimit.\u03b9 ((OpenNhds.inclusion x).op \u22d9 _) U \u226b smoothSheafCommRing.evalHom IM I M R x =\n    smoothSheafCommRing.evalAt _ _ _ _ _ _ :=\n  colimit.\u03b9_desc _ _", "start": [328, 1], "end": [331, 21], "kind": "mathlibtacticlemma"}, {"full_name": "smoothSheafCommRing.forgetStalk_inv_comp_eval", "code": "@[simp, reassoc, elementwise] lemma smoothSheafCommRing.forgetStalk_inv_comp_eval\n    (x : TopCat.of M) :\n    (smoothSheafCommRing.forgetStalk IM I M R x).inv \u226b\n     (FunLike.coe (smoothSheafCommRing.evalHom IM I M R x)) =\n    smoothSheaf.evalHom _ _ _ _ := by\n  apply Limits.colimit.hom_ext\n  intro U\n  show (colimit.\u03b9 _ U) \u226b _ = colimit.\u03b9 ((OpenNhds.inclusion x).op \u22d9 _) U \u226b _\n  rw [smoothSheafCommRing.\u03b9_forgetStalk_inv_assoc]\n  convert congr_arg (fun i \u21a6 (forget CommRingCat).map i) (smoothSheafCommRing.\u03b9_evalHom ..)\n  exact smoothSheaf.\u03b9_evalHom IM I R x U", "start": [333, 1], "end": [343, 41], "kind": "mathlibtacticlemma"}, {"full_name": "smoothSheafCommRing.forgetStalk_hom_comp_evalHom", "code": "@[simp, reassoc, elementwise] lemma smoothSheafCommRing.forgetStalk_hom_comp_evalHom\n    (x : TopCat.of M) :\n    (smoothSheafCommRing.forgetStalk IM I M R x).hom \u226b (smoothSheaf.evalHom IM I R x) =\n    (forget _).map (smoothSheafCommRing.evalHom _ _ _ _ _) := by\n  simp_rw [\u2190 CategoryTheory.Iso.eq_inv_comp]\n  rw [\u2190 smoothSheafCommRing.forgetStalk_inv_comp_eval]\n  rfl", "start": [345, 1], "end": [351, 6], "kind": "mathlibtacticlemma"}, {"full_name": "smoothSheafCommRing.eval_surjective", "code": "lemma smoothSheafCommRing.eval_surjective (x) :\n    Function.Surjective (smoothSheafCommRing.eval IM I M R x) := by\n  intro r\n  obtain \u27e8y, rfl\u27e9 := smoothSheaf.eval_surjective IM I R x r\n  use (smoothSheafCommRing.forgetStalk IM I M R x).inv y\n  apply smoothSheafCommRing.forgetStalk_inv_comp_eval_apply", "start": [353, 1], "end": [358, 60], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/NumberTheory/ModularForms/JacobiTheta/Manifold.lean", "imports": ["Mathlib/NumberTheory/ModularForms/JacobiTheta/Basic.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/Manifold.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "mdifferentiable_jacobiTheta", "code": "theorem mdifferentiable_jacobiTheta : MDifferentiable \ud835\udcd8(\u2102) \ud835\udcd8(\u2102) (jacobiTheta \u2218 (\u2191) : \u210d \u2192 \u2102)", "start": [25, 1], "end": [26, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/TensorProduct/Matrix.lean", "imports": ["Mathlib/LinearAlgebra/TensorProductBasis.lean", "Mathlib/Data/Matrix/Kronecker.lean", "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TensorProduct.toMatrix_map", "code": "theorem TensorProduct.toMatrix_map (f : M \u2192\u2097[R] M') (g : N \u2192\u2097[R] N') :\n    toMatrix (bM.tensorProduct bN) (bM'.tensorProduct bN') (TensorProduct.map f g) =\n      toMatrix bM bM' f \u2297\u2096 toMatrix bN bN' g", "start": [45, 1], "end": [52, 65], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin_kronecker", "code": "theorem Matrix.toLin_kronecker (A : Matrix \u03b9' \u03b9 R) (B : Matrix \u03ba' \u03ba R) :\n    toLin (bM.tensorProduct bN) (bM'.tensorProduct bN') (A \u2297\u2096 B) =\n      TensorProduct.map (toLin bM bM' A) (toLin bN bN' B)", "start": [55, 1], "end": [61, 20], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.toMatrix_comm", "code": "theorem TensorProduct.toMatrix_comm :\n    toMatrix (bM.tensorProduct bN) (bN.tensorProduct bM) (TensorProduct.comm R M N) =\n      (1 : Matrix (\u03b9 \u00d7 \u03ba) (\u03b9 \u00d7 \u03ba) R).submatrix Prod.swap _root_.id", "start": [64, 1], "end": [72, 21], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.toMatrix_assoc", "code": "theorem TensorProduct.toMatrix_assoc :\n    toMatrix ((bM.tensorProduct bN).tensorProduct bP) (bM.tensorProduct (bN.tensorProduct bP))\n        (TensorProduct.assoc R M N P) =\n      (1 : Matrix (\u03b9 \u00d7 \u03ba \u00d7 \u03c4) (\u03b9 \u00d7 \u03ba \u00d7 \u03c4) R).submatrix _root_.id (Equiv.prodAssoc _ _ _)", "start": [75, 1], "end": [85, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/SchurComplement.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "Mathlib/LinearAlgebra/Matrix/PosDef.lean", "Mathlib/Data/Matrix/Invertible.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.fromBlocks_eq_of_invertible\u2081\u2081", "code": "theorem fromBlocks_eq_of_invertible\u2081\u2081 (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (C : Matrix l m \u03b1)\n    (D : Matrix l n \u03b1) [Invertible A] :\n    fromBlocks A B C D =\n      fromBlocks 1 0 (C * \u215f A) 1 * fromBlocks A 0 0 (D - C * \u215f A * B) *\n        fromBlocks 1 (\u215f A * B) 0 1", "start": [52, 1], "end": [61, 79], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_eq_of_invertible\u2082\u2082", "code": "theorem fromBlocks_eq_of_invertible\u2082\u2082 (A : Matrix l m \u03b1) (B : Matrix l n \u03b1) (C : Matrix n m \u03b1)\n    (D : Matrix n n \u03b1) [Invertible D] :\n    fromBlocks A B C D =\n      fromBlocks 1 (B * \u215f D) 0 1 * fromBlocks (A - B * \u215f D * C) 0 0 D *\n        fromBlocks 1 0 (\u215f D * C) 1", "start": [64, 1], "end": [74, 90], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocksZero\u2082\u2081Invertible", "code": "def fromBlocksZero\u2082\u2081Invertible (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (D : Matrix n n \u03b1)\n    [Invertible A] [Invertible D] : Invertible (fromBlocks A B 0 D) :=\n  invertibleOfLeftInverse _ (fromBlocks (\u215f A) (-(\u215f A * B * \u215f D)) 0 (\u215f D)) <| by\n    simp_rw [fromBlocks_multiply, Matrix.mul_zero, Matrix.zero_mul, zero_add, add_zero,\n      Matrix.neg_mul, invOf_mul_self, Matrix.mul_invOf_mul_self_cancel, add_right_neg,\n      fromBlocks_one]", "start": [82, 1], "end": [88, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocksZero\u2081\u2082Invertible", "code": "def fromBlocksZero\u2081\u2082Invertible (A : Matrix m m \u03b1) (C : Matrix n m \u03b1) (D : Matrix n n \u03b1)\n    [Invertible A] [Invertible D] : Invertible (fromBlocks A 0 C D) :=\n  invertibleOfLeftInverse _\n      (fromBlocks (\u215f A) 0 (-(\u215f D * C * \u215f A))\n        (\u215f D)) <| by simp_rw [fromBlocks_multiply, Matrix.mul_zero, Matrix.zero_mul, zero_add, add_zero,\n      Matrix.neg_mul, invOf_mul_self, Matrix.mul_invOf_mul_self_cancel, add_left_neg,\n      fromBlocks_one]", "start": [91, 1], "end": [99, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.invOf_fromBlocks_zero\u2082\u2081_eq", "code": "theorem invOf_fromBlocks_zero\u2082\u2081_eq (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (D : Matrix n n \u03b1)\n    [Invertible A] [Invertible D] [Invertible (fromBlocks A B 0 D)] :\n    \u215f (fromBlocks A B 0 D) = fromBlocks (\u215f A) (-(\u215f A * B * \u215f D)) 0 (\u215f D)", "start": [102, 1], "end": [106, 45], "kind": "commanddeclaration"}, {"full_name": "Matrix.invOf_fromBlocks_zero\u2081\u2082_eq", "code": "theorem invOf_fromBlocks_zero\u2081\u2082_eq (A : Matrix m m \u03b1) (C : Matrix n m \u03b1) (D : Matrix n n \u03b1)\n    [Invertible A] [Invertible D] [Invertible (fromBlocks A 0 C D)] :\n    \u215f (fromBlocks A 0 C D) = fromBlocks (\u215f A) 0 (-(\u215f D * C * \u215f A)) (\u215f D)", "start": [109, 1], "end": [113, 45], "kind": "commanddeclaration"}, {"full_name": "Matrix.invertibleOfFromBlocksZero\u2082\u2081Invertible", "code": "def invertibleOfFromBlocksZero\u2082\u2081Invertible (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (D : Matrix n n \u03b1)\n    [Invertible (fromBlocks A B 0 D)] : Invertible A \u00d7 Invertible D where\n  fst :=\n    invertibleOfLeftInverse _ (\u215f (fromBlocks A B 0 D)).toBlocks\u2081\u2081 <| by\n      have := invOf_mul_self (fromBlocks A B 0 D)\n      rw [\u2190 fromBlocks_toBlocks (\u215f (fromBlocks A B 0 D)), fromBlocks_multiply] at this\n      replace := congr_arg Matrix.toBlocks\u2081\u2081 this\n      simpa only [Matrix.toBlocks_fromBlocks\u2081\u2081, Matrix.mul_zero, add_zero, \u2190 fromBlocks_one] using\n        this\n  snd :=\n    invertibleOfRightInverse _ (\u215f (fromBlocks A B 0 D)).toBlocks\u2082\u2082 <| by\n      have := mul_invOf_self (fromBlocks A B 0 D)\n      rw [\u2190 fromBlocks_toBlocks (\u215f (fromBlocks A B 0 D)), fromBlocks_multiply] at this\n      replace := congr_arg Matrix.toBlocks\u2082\u2082 this\n      simpa only [Matrix.toBlocks_fromBlocks\u2082\u2082, Matrix.zero_mul, zero_add, \u2190 fromBlocks_one] using\n        this", "start": [116, 1], "end": [133, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.invertibleOfFromBlocksZero\u2081\u2082Invertible", "code": "def invertibleOfFromBlocksZero\u2081\u2082Invertible (A : Matrix m m \u03b1) (C : Matrix n m \u03b1) (D : Matrix n n \u03b1)\n    [Invertible (fromBlocks A 0 C D)] : Invertible A \u00d7 Invertible D where\n  fst :=\n    invertibleOfRightInverse _ (\u215f (fromBlocks A 0 C D)).toBlocks\u2081\u2081 <| by\n      have := mul_invOf_self (fromBlocks A 0 C D)\n      rw [\u2190 fromBlocks_toBlocks (\u215f (fromBlocks A 0 C D)), fromBlocks_multiply] at this\n      replace := congr_arg Matrix.toBlocks\u2081\u2081 this\n      simpa only [Matrix.toBlocks_fromBlocks\u2081\u2081, Matrix.zero_mul, add_zero, \u2190 fromBlocks_one] using\n        this\n  snd :=\n    invertibleOfLeftInverse _ (\u215f (fromBlocks A 0 C D)).toBlocks\u2082\u2082 <| by\n      have := invOf_mul_self (fromBlocks A 0 C D)\n      rw [\u2190 fromBlocks_toBlocks (\u215f (fromBlocks A 0 C D)), fromBlocks_multiply] at this\n      replace := congr_arg Matrix.toBlocks\u2082\u2082 this\n      simpa only [Matrix.toBlocks_fromBlocks\u2082\u2082, Matrix.mul_zero, zero_add, \u2190 fromBlocks_one] using\n        this", "start": [136, 1], "end": [153, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocksZero\u2082\u2081InvertibleEquiv", "code": "def fromBlocksZero\u2082\u2081InvertibleEquiv (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (D : Matrix n n \u03b1) :\n    Invertible (fromBlocks A B 0 D) \u2243 Invertible A \u00d7 Invertible D where\n  toFun _ := invertibleOfFromBlocksZero\u2082\u2081Invertible A B D\n  invFun i := by\n    letI := i.1\n    letI := i.2\n    exact fromBlocksZero\u2082\u2081Invertible A B D\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _", "start": [156, 1], "end": [166, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocksZero\u2081\u2082InvertibleEquiv", "code": "def fromBlocksZero\u2081\u2082InvertibleEquiv (A : Matrix m m \u03b1) (C : Matrix n m \u03b1) (D : Matrix n n \u03b1) :\n    Invertible (fromBlocks A 0 C D) \u2243 Invertible A \u00d7 Invertible D where\n  toFun _ := invertibleOfFromBlocksZero\u2081\u2082Invertible A C D\n  invFun i := by\n    letI := i.1\n    letI := i.2\n    exact fromBlocksZero\u2081\u2082Invertible A C D\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _", "start": [169, 1], "end": [179, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_fromBlocks_zero\u2082\u2081", "code": "@[simp]\ntheorem isUnit_fromBlocks_zero\u2082\u2081 {A : Matrix m m \u03b1} {B : Matrix m n \u03b1} {D : Matrix n n \u03b1} :\n    IsUnit (fromBlocks A B 0 D) \u2194 IsUnit A \u2227 IsUnit D", "start": [182, 1], "end": [189, 60], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_fromBlocks_zero\u2081\u2082", "code": "@[simp]\ntheorem isUnit_fromBlocks_zero\u2081\u2082 {A : Matrix m m \u03b1} {C : Matrix n m \u03b1} {D : Matrix n n \u03b1} :\n    IsUnit (fromBlocks A 0 C D) \u2194 IsUnit A \u2227 IsUnit D", "start": [192, 1], "end": [199, 60], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_fromBlocks_zero\u2082\u2081_of_isUnit_iff", "code": "theorem inv_fromBlocks_zero\u2082\u2081_of_isUnit_iff (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (D : Matrix n n \u03b1)\n    (hAD : IsUnit A \u2194 IsUnit D) :\n    (fromBlocks A B 0 D)\u207b\u00b9 = fromBlocks A\u207b\u00b9 (-(A\u207b\u00b9 * B * D\u207b\u00b9)) 0 D\u207b\u00b9", "start": [202, 1], "end": [217, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_fromBlocks_zero\u2081\u2082_of_isUnit_iff", "code": "theorem inv_fromBlocks_zero\u2081\u2082_of_isUnit_iff (A : Matrix m m \u03b1) (C : Matrix n m \u03b1) (D : Matrix n n \u03b1)\n    (hAD : IsUnit A \u2194 IsUnit D) :\n    (fromBlocks A 0 C D)\u207b\u00b9 = fromBlocks A\u207b\u00b9 0 (-(D\u207b\u00b9 * C * A\u207b\u00b9)) D\u207b\u00b9", "start": [220, 1], "end": [235, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks\u2082\u2082Invertible", "code": "def fromBlocks\u2082\u2082Invertible (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (C : Matrix n m \u03b1)\n    (D : Matrix n n \u03b1) [Invertible D] [Invertible (A - B * \u215f D * C)] :\n    Invertible (fromBlocks A B C D) := by\n  refine'\n    Invertible.copy' _ _\n      (fromBlocks (\u215f (A - B * \u215f D * C)) (-(\u215f (A - B * \u215f D * C) * B * \u215f D))\n        (-(\u215f D * C * \u215f (A - B * \u215f D * C))) (\u215f D + \u215f D * C * \u215f (A - B * \u215f D * C) * B * \u215f D))\n      (fromBlocks_eq_of_invertible\u2082\u2082 _ _ _ _) _\n  \u00b7 letI : Invertible (1 : Matrix n n \u03b1) := invertibleOne\n    letI : Invertible (1 : Matrix m m \u03b1) := invertibleOne\n    refine' Invertible.mul _ (fromBlocksZero\u2081\u2082Invertible _ _ _)\n    exact\n      Invertible.mul (fromBlocksZero\u2082\u2081Invertible _ _ _)\n        (fromBlocksZero\u2082\u2081Invertible _ _ _)\n  \u00b7 show\n      _ =\n        fromBlocks 1 0 (-(1 * (\u215f D * C) * 1)) 1 *\n          (fromBlocks (\u215f (A - B * \u215f D * C)) (-(\u215f (A - B * \u215f D * C) * 0 * \u215f D)) 0 (\u215f D) *\n            fromBlocks 1 (-(1 * (B * \u215f D) * 1)) 0 1)\n    simp only [fromBlocks_multiply, invOf_one, Matrix.one_mul, Matrix.mul_one, Matrix.zero_mul,\n      Matrix.mul_zero, add_zero, zero_add, neg_zero, Matrix.mul_neg, Matrix.neg_mul, neg_neg, \u2190\n      Matrix.mul_assoc, add_comm (\u215fD)]", "start": [248, 1], "end": [275, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks\u2081\u2081Invertible", "code": "def fromBlocks\u2081\u2081Invertible (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (C : Matrix n m \u03b1)\n    (D : Matrix n n \u03b1) [Invertible A] [Invertible (D - C * \u215f A * B)] :\n    Invertible (fromBlocks A B C D) := by\n  letI := fromBlocks\u2082\u2082Invertible D C B A\n  letI iDCBA :=\n    submatrixEquivInvertible (fromBlocks D C B A) (Equiv.sumComm _ _) (Equiv.sumComm _ _)\n  exact\n    iDCBA.copy' _\n      (fromBlocks (\u215f A + \u215f A * B * \u215f (D - C * \u215f A * B) * C * \u215f A) (-(\u215f A * B * \u215f (D - C * \u215f A * B)))\n        (-(\u215f (D - C * \u215f A * B) * C * \u215f A)) (\u215f (D - C * \u215f A * B)))\n      (fromBlocks_submatrix_sum_swap_sum_swap _ _ _ _).symm\n      (fromBlocks_submatrix_sum_swap_sum_swap _ _ _ _).symm", "start": [278, 1], "end": [292, 60], "kind": "commanddeclaration"}, {"full_name": "Matrix.invOf_fromBlocks\u2082\u2082_eq", "code": "theorem invOf_fromBlocks\u2082\u2082_eq (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (C : Matrix n m \u03b1)\n    (D : Matrix n n \u03b1) [Invertible D] [Invertible (A - B * \u215f D * C)]\n    [Invertible (fromBlocks A B C D)] :\n    \u215f (fromBlocks A B C D) =\n      fromBlocks (\u215f (A - B * \u215f D * C)) (-(\u215f (A - B * \u215f D * C) * B * \u215f D))\n        (-(\u215f D * C * \u215f (A - B * \u215f D * C))) (\u215f D + \u215f D * C * \u215f (A - B * \u215f D * C) * B * \u215f D)", "start": [295, 1], "end": [302, 45], "kind": "commanddeclaration"}, {"full_name": "Matrix.invOf_fromBlocks\u2081\u2081_eq", "code": "theorem invOf_fromBlocks\u2081\u2081_eq (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (C : Matrix n m \u03b1)\n    (D : Matrix n n \u03b1) [Invertible A] [Invertible (D - C * \u215f A * B)]\n    [Invertible (fromBlocks A B C D)] :\n    \u215f (fromBlocks A B C D) =\n      fromBlocks (\u215f A + \u215f A * B * \u215f (D - C * \u215f A * B) * C * \u215f A) (-(\u215f A * B * \u215f (D - C * \u215f A * B)))\n        (-(\u215f (D - C * \u215f A * B) * C * \u215f A)) (\u215f (D - C * \u215f A * B))", "start": [305, 1], "end": [312, 45], "kind": "commanddeclaration"}, {"full_name": "Matrix.invertibleOfFromBlocks\u2082\u2082Invertible", "code": "def invertibleOfFromBlocks\u2082\u2082Invertible (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (C : Matrix n m \u03b1)\n    (D : Matrix n n \u03b1) [Invertible D] [Invertible (fromBlocks A B C D)] :\n    Invertible (A - B * \u215f D * C) := by\n  suffices Invertible (fromBlocks (A - B * \u215f D * C) 0 0 D) by\n    exact (invertibleOfFromBlocksZero\u2081\u2082Invertible (A - B * \u215f D * C) 0 D).1\n  letI : Invertible (1 : Matrix n n \u03b1) := invertibleOne\n  letI : Invertible (1 : Matrix m m \u03b1) := invertibleOne\n  letI iDC : Invertible (fromBlocks 1 0 (\u215f D * C) 1 : Matrix (Sum m n) (Sum m n) \u03b1) :=\n    fromBlocksZero\u2081\u2082Invertible _ _ _\n  letI iBD : Invertible (fromBlocks 1 (B * \u215f D) 0 1 : Matrix (Sum m n) (Sum m n) \u03b1) :=\n    fromBlocksZero\u2082\u2081Invertible _ _ _\n  letI iBDC := Invertible.copy \u2039_\u203a _ (fromBlocks_eq_of_invertible\u2082\u2082 A B C D).symm\n  refine' (iBD.mulLeft _).symm _\n  refine' (iDC.mulRight _).symm iBDC", "start": [315, 1], "end": [330, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.invertibleOfFromBlocks\u2081\u2081Invertible", "code": "def invertibleOfFromBlocks\u2081\u2081Invertible (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (C : Matrix n m \u03b1)\n    (D : Matrix n n \u03b1) [Invertible A] [Invertible (fromBlocks A B C D)] :\n    Invertible (D - C * \u215f A * B) := by\n  letI iABCD' :=\n    submatrixEquivInvertible (fromBlocks A B C D) (Equiv.sumComm _ _) (Equiv.sumComm _ _)\n  letI iDCBA := iABCD'.copy _ (fromBlocks_submatrix_sum_swap_sum_swap _ _ _ _).symm\n  refine' invertibleOfFromBlocks\u2082\u2082Invertible D C B A", "start": [333, 1], "end": [342, 53], "kind": "commanddeclaration"}, {"full_name": "Matrix.invertibleEquivFromBlocks\u2082\u2082Invertible", "code": "def invertibleEquivFromBlocks\u2082\u2082Invertible (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (C : Matrix n m \u03b1)\n    (D : Matrix n n \u03b1) [Invertible D] :\n    Invertible (fromBlocks A B C D) \u2243 Invertible (A - B * \u215f D * C) where\n  toFun _iABCD := invertibleOfFromBlocks\u2082\u2082Invertible _ _ _ _\n  invFun _i_schur := fromBlocks\u2082\u2082Invertible _ _ _ _\n  left_inv _iABCD := Subsingleton.elim _ _\n  right_inv _i_schur := Subsingleton.elim _ _", "start": [345, 1], "end": [353, 46], "kind": "commanddeclaration"}, {"full_name": "Matrix.invertibleEquivFromBlocks\u2081\u2081Invertible", "code": "def invertibleEquivFromBlocks\u2081\u2081Invertible (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (C : Matrix n m \u03b1)\n    (D : Matrix n n \u03b1) [Invertible A] :\n    Invertible (fromBlocks A B C D) \u2243 Invertible (D - C * \u215f A * B) where\n  toFun _iABCD := invertibleOfFromBlocks\u2081\u2081Invertible _ _ _ _\n  invFun _i_schur := fromBlocks\u2081\u2081Invertible _ _ _ _\n  left_inv _iABCD := Subsingleton.elim _ _\n  right_inv _i_schur := Subsingleton.elim _ _", "start": [356, 1], "end": [364, 46], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_fromBlocks_iff_of_invertible\u2082\u2082", "code": "theorem isUnit_fromBlocks_iff_of_invertible\u2082\u2082 {A : Matrix m m \u03b1} {B : Matrix m n \u03b1}\n    {C : Matrix n m \u03b1} {D : Matrix n n \u03b1} [Invertible D] :\n    IsUnit (fromBlocks A B C D) \u2194 IsUnit (A - B * \u215f D * C)", "start": [367, 1], "end": [373, 68], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_fromBlocks_iff_of_invertible\u2081\u2081", "code": "theorem isUnit_fromBlocks_iff_of_invertible\u2081\u2081 {A : Matrix m m \u03b1} {B : Matrix m n \u03b1}\n    {C : Matrix n m \u03b1} {D : Matrix n n \u03b1} [Invertible A] :\n    IsUnit (fromBlocks A B C D) \u2194 IsUnit (D - C * \u215f A * B)", "start": [376, 1], "end": [382, 68], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_fromBlocks\u2081\u2081", "code": "theorem det_fromBlocks\u2081\u2081 (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (C : Matrix n m \u03b1)\n    (D : Matrix n n \u03b1) [Invertible A] :\n    (Matrix.fromBlocks A B C D).det = det A * det (D - C * \u215f A * B)", "start": [392, 1], "end": [398, 95], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_fromBlocks_one\u2081\u2081", "code": "@[simp]\ntheorem det_fromBlocks_one\u2081\u2081 (B : Matrix m n \u03b1) (C : Matrix n m \u03b1) (D : Matrix n n \u03b1) :\n    (Matrix.fromBlocks 1 B C D).det = det (D - C * B)", "start": [401, 1], "end": [405, 69], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_fromBlocks\u2082\u2082", "code": "theorem det_fromBlocks\u2082\u2082 (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (C : Matrix n m \u03b1)\n    (D : Matrix n n \u03b1) [Invertible D] :\n    (Matrix.fromBlocks A B C D).det = det D * det (A - B * \u215f D * C)", "start": [408, 1], "end": [417, 56], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_fromBlocks_one\u2082\u2082", "code": "@[simp]\ntheorem det_fromBlocks_one\u2082\u2082 (A : Matrix m m \u03b1) (B : Matrix m n \u03b1) (C : Matrix n m \u03b1) :\n    (Matrix.fromBlocks A B C 1).det = det (A - B * C)", "start": [420, 1], "end": [424, 69], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_one_add_mul_comm", "code": "theorem det_one_add_mul_comm (A : Matrix m n \u03b1) (B : Matrix n m \u03b1) :\n    det (1 + A * B) = det (1 + B * A)", "start": [427, 1], "end": [434, 88], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_mul_add_one_comm", "code": "theorem det_mul_add_one_comm (A : Matrix m n \u03b1) (B : Matrix n m \u03b1) :\n    det (A * B + 1) = det (B * A + 1)", "start": [437, 1], "end": [439, 90], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_one_sub_mul_comm", "code": "theorem det_one_sub_mul_comm (A : Matrix m n \u03b1) (B : Matrix n m \u03b1) :\n    det (1 - A * B) = det (1 - B * A)", "start": [442, 1], "end": [444, 96], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_one_add_col_mul_row", "code": "theorem det_one_add_col_mul_row (u v : m \u2192 \u03b1) : det (1 + col u * row v) = 1 + v \u2b1d\u1d65 u", "start": [447, 1], "end": [450, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_add_col_mul_row", "code": "theorem det_add_col_mul_row {A : Matrix m m \u03b1} (hA : IsUnit A.det) (u v : m \u2192 \u03b1) :\n    (A + col u * row v).det = A.det * (1 + row v * A\u207b\u00b9 * col u).det", "start": [453, 1], "end": [463, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_add_mul", "code": "theorem det_add_mul {A : Matrix m m \u03b1} (U : Matrix m n \u03b1)\n    (V : Matrix n m \u03b1) (hA : IsUnit A.det) :\n    (A + U * V).det = A.det * (1 + V * A\u207b\u00b9 * U).det", "start": [465, 1], "end": [471, 73], "kind": "commanddeclaration"}, {"full_name": "Matrix.schur_complement_eq\u2081\u2081", "code": "theorem schur_complement_eq\u2081\u2081 [Fintype m] [DecidableEq m] [Fintype n] {A : Matrix m m \ud835\udd5c}\n    (B : Matrix m n \ud835\udd5c) (D : Matrix n n \ud835\udd5c) (x : m \u2192 \ud835\udd5c) (y : n \u2192 \ud835\udd5c) [Invertible A]\n    (hA : A.IsHermitian) :\n    vecMul (star (x \u2295\u1d65 y)) (fromBlocks A B B\u1d34 D) \u2b1d\u1d65 (x \u2295\u1d65 y) =\n      vecMul (star (x + (A\u207b\u00b9 * B).mulVec y)) A \u2b1d\u1d65 (x + (A\u207b\u00b9 * B).mulVec y) +\n        vecMul (star y) (D - B\u1d34 * A\u207b\u00b9 * B) \u2b1d\u1d65 y", "start": [486, 1], "end": [495, 7], "kind": "commanddeclaration"}, {"full_name": "Matrix.schur_complement_eq\u2082\u2082", "code": "theorem schur_complement_eq\u2082\u2082 [Fintype m] [Fintype n] [DecidableEq n] (A : Matrix m m \ud835\udd5c)\n    (B : Matrix m n \ud835\udd5c) {D : Matrix n n \ud835\udd5c} (x : m \u2192 \ud835\udd5c) (y : n \u2192 \ud835\udd5c) [Invertible D]\n    (hD : D.IsHermitian) :\n    vecMul (star (x \u2295\u1d65 y)) (fromBlocks A B B\u1d34 D) \u2b1d\u1d65 (x \u2295\u1d65 y) =\n      vecMul (star ((D\u207b\u00b9 * B\u1d34).mulVec x + y)) D \u2b1d\u1d65 ((D\u207b\u00b9 * B\u1d34).mulVec x + y) +\n        vecMul (star x) (A - B * D\u207b\u00b9 * B\u1d34) \u2b1d\u1d65 x", "start": [498, 1], "end": [507, 7], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.fromBlocks\u2081\u2081", "code": "theorem IsHermitian.fromBlocks\u2081\u2081 [Fintype m] [DecidableEq m] {A : Matrix m m \ud835\udd5c} (B : Matrix m n \ud835\udd5c)\n    (D : Matrix n n \ud835\udd5c) (hA : A.IsHermitian) :\n    (Matrix.fromBlocks A B B\u1d34 D).IsHermitian \u2194 (D - B\u1d34 * A\u207b\u00b9 * B).IsHermitian", "start": [510, 1], "end": [523, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.fromBlocks\u2082\u2082", "code": "theorem IsHermitian.fromBlocks\u2082\u2082 [Fintype n] [DecidableEq n] (A : Matrix m m \ud835\udd5c) (B : Matrix m n \ud835\udd5c)\n    {D : Matrix n n \ud835\udd5c} (hD : D.IsHermitian) :\n    (Matrix.fromBlocks A B B\u1d34 D).IsHermitian \u2194 (A - B * D\u207b\u00b9 * B\u1d34).IsHermitian", "start": [526, 1], "end": [531, 51], "kind": "commanddeclaration"}, {"full_name": "Matrix.PosSemidef.fromBlocks\u2081\u2081", "code": "theorem PosSemidef.fromBlocks\u2081\u2081 [Fintype m] [DecidableEq m] [Fintype n] {A : Matrix m m \ud835\udd5c}\n    (B : Matrix m n \ud835\udd5c) (D : Matrix n n \ud835\udd5c) (hA : A.PosDef) [Invertible A] :\n    (fromBlocks A B B\u1d34 D).PosSemidef \u2194 (D - B\u1d34 * A\u207b\u00b9 * B).PosSemidef", "start": [534, 1], "end": [550, 16], "kind": "commanddeclaration"}, {"full_name": "Matrix.PosSemidef.fromBlocks\u2082\u2082", "code": "theorem PosSemidef.fromBlocks\u2082\u2082 [Fintype m] [Fintype n] [DecidableEq n] (A : Matrix m m \ud835\udd5c)\n    (B : Matrix m n \ud835\udd5c) {D : Matrix n n \ud835\udd5c} (hD : D.PosDef) [Invertible D] :\n    (fromBlocks A B B\u1d34 D).PosSemidef \u2194 (A - B * D\u207b\u00b9 * B\u1d34).PosSemidef", "start": [553, 1], "end": [561, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/UnionFind.lean", "imports": ["Mathlib/Data/Array/Basic.lean", "lake-packages/std/Std/Tactic/Simpa.lean", "Mathlib/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UFModel", "code": "structure UFModel (n) where\n  parent : Fin n \u2192 Fin n\n  rank : Nat \u2192 Nat\n  rank_lt : \u2200 i, (parent i).1 \u2260 i \u2192 rank i < rank (parent i)", "start": [12, 1], "end": [15, 61], "kind": "commanddeclaration"}, {"full_name": "UFModel.empty", "code": "def empty : UFModel 0 where\n  parent i := i.elim0\n  rank _ := 0\n  rank_lt i := i.elim0", "start": [19, 1], "end": [22, 23], "kind": "commanddeclaration"}, {"full_name": "UFModel.push", "code": "def push {n} (m : UFModel n) (k) (le : n \u2264 k) : UFModel k where\n  parent i :=\n    if h : i < n then\n      let \u27e8a, h'\u27e9 := m.parent \u27e8i, h\u27e9\n      \u27e8a, lt_of_lt_of_le h' le\u27e9\n    else i\n  rank i := if i < n then m.rank i else 0\n  rank_lt i := by\n    simp; split <;> rename_i h\n    \u00b7 simp [(m.parent \u27e8i, h\u27e9).2, h]; exact m.rank_lt _\n    \u00b7 intro.", "start": [24, 1], "end": [34, 13], "kind": "commanddeclaration"}, {"full_name": "UFModel.setParent", "code": "def setParent {n} (m : UFModel n) (x y : Fin n) (h : m.rank x < m.rank y) : UFModel n where\n  parent i := if x.1 = i then y else m.parent i\n  rank := m.rank\n  rank_lt i := by\n    simp; split <;> rename_i h'\n    \u00b7 rw [\u2190 h']; exact fun _ \u21a6 h\n    \u00b7 exact m.rank_lt i", "start": [36, 1], "end": [42, 24], "kind": "commanddeclaration"}, {"full_name": "UFModel.setParentBump", "code": "def setParentBump {n} (m : UFModel n) (x y : Fin n)\n    (H : m.rank x \u2264 m.rank y) (hroot : (m.parent y).1 = y) : UFModel n where\n  parent i := if x.1 = i then y else m.parent i\n  rank i := if y.1 = i \u2227 m.rank x = m.rank y then m.rank y + 1 else m.rank i\n  rank_lt i := by\n    simp; split <;>\n      (rename_i h\u2081; (try simp [h\u2081]); split <;> rename_i h\u2082 <;>\n        (intro h; try simp [h] at h\u2082 <;> simp [h\u2081, h\u2082, h]))\n    \u00b7 simp [\u2190 h\u2081]; split <;> rename_i h\u2083\n      \u00b7 rw [h\u2083]; apply Nat.lt_succ_self\n      \u00b7 exact lt_of_le_of_ne H h\u2083\n    \u00b7 have := Fin.eq_of_val_eq h\u2082.1; subst this\n      simp [hroot] at h\n    \u00b7 have := m.rank_lt i h\n      split <;> rename_i h\u2083\n      \u00b7 rw [h\u2083.1]; exact Nat.lt_succ_of_lt this\n      \u00b7 exact this", "start": [44, 1], "end": [60, 19], "kind": "commanddeclaration"}, {"full_name": "UFNode", "code": "structure UFNode (\u03b1 : Type*) where\n  parent : Nat\n  value : \u03b1\n  rank : Nat", "start": [64, 1], "end": [67, 13], "kind": "commanddeclaration"}, {"full_name": "UFModel.Agrees", "code": "inductive UFModel.Agrees (arr : Array \u03b1) (f : \u03b1 \u2192 \u03b2) : \u2200 {n}, (Fin n \u2192 \u03b2) \u2192 Prop\n  | mk : Agrees arr f fun i \u21a6 f (arr.get i)", "start": [69, 1], "end": [70, 44], "kind": "commanddeclaration"}, {"full_name": "UFModel.Agrees.mk'", "code": "theorem mk' {arr : Array \u03b1} {f : \u03b1 \u2192 \u03b2} {n} {g : Fin n \u2192 \u03b2} (e : n = arr.size)\n    (H : \u2200 i h\u2081 h\u2082, f (arr.get \u27e8i, h\u2081\u27e9) = g \u27e8i, h\u2082\u27e9) : Agrees arr f g", "start": [74, 1], "end": [78, 26], "kind": "commanddeclaration"}, {"full_name": "UFModel.Agrees.size_eq", "code": "theorem size_eq {arr : Array \u03b1} {m : Fin n \u2192 \u03b2} (H : Agrees arr f m) : n = arr.size", "start": [80, 1], "end": [81, 15], "kind": "commanddeclaration"}, {"full_name": "UFModel.Agrees.get_eq", "code": "theorem get_eq {arr : Array \u03b1} {n} {m : Fin n \u2192 \u03b2} (H : Agrees arr f m) :\n    \u2200 i h\u2081 h\u2082, f (arr.get \u27e8i, h\u2081\u27e9) = m \u27e8i, h\u2082\u27e9", "start": [83, 1], "end": [85, 33], "kind": "commanddeclaration"}, {"full_name": "UFModel.Agrees.get_eq'", "code": "theorem get_eq' {arr : Array \u03b1} {m : Fin arr.size \u2192 \u03b2} (H : Agrees arr f m)\n    (i) : f (arr.get i) = m i", "start": [87, 1], "end": [88, 45], "kind": "commanddeclaration"}, {"full_name": "UFModel.Agrees.empty", "code": "theorem empty {f : \u03b1 \u2192 \u03b2} {g : Fin 0 \u2192 \u03b2} : Agrees #[] f g", "start": [90, 1], "end": [90, 73], "kind": "commanddeclaration"}, {"full_name": "UFModel.Agrees.push", "code": "theorem push {arr : Array \u03b1} {n} {m : Fin n \u2192 \u03b2} (H : Agrees arr f m)\n    (k) (hk : k = n + 1) (x) (m' : Fin k \u2192 \u03b2)\n    (hm\u2081 : \u2200 (i : Fin k) (h : i < n), m' i = m \u27e8i, h\u27e9)\n    (hm\u2082 : \u2200 (h : n < k), f x = m' \u27e8n, h\u27e9) : Agrees (arr.push x) f m'", "start": [92, 1], "end": [102, 13], "kind": "commanddeclaration"}, {"full_name": "UFModel.Agrees.set", "code": "theorem set {arr : Array \u03b1} {n} {m : Fin n \u2192 \u03b2} (H : Agrees arr f m)\n    {i : Fin arr.size} {x} {m' : Fin n \u2192 \u03b2}\n  (hm\u2081 : \u2200 (j : Fin n), j.1 \u2260 i \u2192 m' j = m j)\n  (hm\u2082 : \u2200 (h : i < n), f x = m' \u27e8i, h\u27e9) : Agrees (arr.set i x) f m'", "start": [104, 1], "end": [113, 61], "kind": "commanddeclaration"}, {"full_name": "UFModel.Models", "code": "def UFModel.Models (arr : Array (UFNode \u03b1)) {n} (m : UFModel n) :=\n  UFModel.Agrees arr (\u00b7.parent) (fun i \u21a6 m.parent i) \u2227\n  UFModel.Agrees arr (\u00b7.rank) (fun i : Fin n \u21a6 m.rank i)", "start": [117, 1], "end": [119, 57], "kind": "commanddeclaration"}, {"full_name": "UFModel.Models.size_eq", "code": "theorem size_eq {arr : Array (UFNode \u03b1)} {n} {m : UFModel n} (H : m.Models arr) :\n    n = arr.size", "start": [123, 1], "end": [124, 32], "kind": "commanddeclaration"}, {"full_name": "UFModel.Models.parent_eq", "code": "theorem parent_eq {arr : Array (UFNode \u03b1)} {n} {m : UFModel n} (H : m.Models arr)\n    (i : Nat) (h\u2081 : i < arr.size) (h\u2082) : arr[i].parent = m.parent \u27e8i, h\u2082\u27e9", "start": [126, 1], "end": [127, 91], "kind": "commanddeclaration"}, {"full_name": "UFModel.Models.parent_eq'", "code": "theorem parent_eq' {arr : Array (UFNode \u03b1)} {m : UFModel arr.size} (H : m.Models arr)\n    (i : Fin arr.size) : (arr[i.1]).parent = m.parent i", "start": [129, 1], "end": [130, 74], "kind": "commanddeclaration"}, {"full_name": "UFModel.Models.rank_eq", "code": "theorem rank_eq {arr : Array (UFNode \u03b1)} {n} {m : UFModel n} (H : m.Models arr) (i : Nat)\n    (h : i < arr.size) : arr[i].rank = m.rank i", "start": [132, 1], "end": [134, 46], "kind": "commanddeclaration"}, {"full_name": "UFModel.Models.empty", "code": "theorem empty : UFModel.empty.Models (\u03b1 := \u03b1) #[]", "start": [136, 1], "end": [136, 82], "kind": "commanddeclaration"}, {"full_name": "UFModel.Models.push", "code": "theorem push {arr : Array (UFNode \u03b1)} {n} {m : UFModel n} (H : m.Models arr)\n    (k) (hk : k = n + 1) (x) :\n    (m.push k (hk \u25b8 Nat.le_add_right ..)).Models (arr.push \u27e8n, x, 0\u27e9)", "start": [138, 1], "end": [144, 38], "kind": "commanddeclaration"}, {"full_name": "UFModel.Models.setParent", "code": "theorem setParent {arr : Array (UFNode \u03b1)} {n} {m : UFModel n} (hm : m.Models arr)\n    (i j H hi x) (hp : x.parent = j.1) (hrk : x.rank = arr[i].rank) :\n    (m.setParent i j H).Models (arr.set \u27e8i.1, hi\u27e9 x)", "start": [146, 1], "end": [152, 67], "kind": "commanddeclaration"}, {"full_name": "UnionFind", "code": "structure UnionFind (\u03b1) where\n  arr : Array (UFNode \u03b1)\n  model : \u2203 (n : _) (m : UFModel n), m.Models arr", "start": [156, 1], "end": [158, 50], "kind": "commanddeclaration"}, {"full_name": "UnionFind.size", "code": "def size (self : UnionFind \u03b1) := self.arr.size", "start": [162, 1], "end": [162, 47], "kind": "commanddeclaration"}, {"full_name": "UnionFind.model'", "code": "theorem model' (self : UnionFind \u03b1) : \u2203 (m : UFModel self.arr.size), m.Models self.arr", "start": [164, 1], "end": [165, 64], "kind": "commanddeclaration"}, {"full_name": "UnionFind.empty", "code": "def empty : UnionFind \u03b1 where\n  arr := #[]\n  model := \u27e8_, _, UFModel.Models.empty\u27e9", "start": [167, 1], "end": [169, 40], "kind": "commanddeclaration"}, {"full_name": "UnionFind.mkEmpty", "code": "def mkEmpty (c : Nat) : UnionFind \u03b1 where\n  arr := Array.mkEmpty c\n  model := \u27e8_, _, UFModel.Models.empty\u27e9", "start": [171, 1], "end": [173, 40], "kind": "commanddeclaration"}, {"full_name": "UnionFind.rank", "code": "def rank (self : UnionFind \u03b1) (i : Nat) : Nat :=\n  if h : i < self.size then (self.arr.get \u27e8i, h\u27e9).rank else 0", "start": [175, 1], "end": [176, 62], "kind": "commanddeclaration"}, {"full_name": "UnionFind.rankMaxAux", "code": "def rankMaxAux (self : UnionFind \u03b1) : \u2200 (i : Nat),\n    {k : Nat // \u2200 j < i, \u2200 h, (self.arr.get \u27e8j, h\u27e9).rank \u2264 k}\n  | 0 => \u27e80, \u03bb.\u27e9\n  | i+1 => by\n    let \u27e8k, H\u27e9 := rankMaxAux self i\n    refine \u27e8max k (if h : _ then (self.arr.get \u27e8i, h\u27e9).rank else 0), fun j hj h \u21a6 ?_\u27e9\n    match j, lt_or_eq_of_le (Nat.le_of_lt_succ hj) with\n    | j, Or.inl hj => exact le_trans (H _ hj h) (le_max_left _ _)\n    | _, Or.inr rfl => simp [h, le_max_right]", "start": [178, 1], "end": [186, 46], "kind": "commanddeclaration"}, {"full_name": "UnionFind.rankMax", "code": "def rankMax (self : UnionFind \u03b1) := (rankMaxAux self self.size).1 + 1", "start": [188, 1], "end": [188, 70], "kind": "commanddeclaration"}, {"full_name": "UnionFind.lt_rankMax'", "code": "theorem lt_rankMax' (self : UnionFind \u03b1) (i : Fin self.size) :\n    (self.arr.get i).rank < self.rankMax", "start": [190, 1], "end": [192, 56], "kind": "commanddeclaration"}, {"full_name": "UnionFind.lt_rankMax", "code": "theorem lt_rankMax (self : UnionFind \u03b1) (i : Nat) : self.rank i < self.rankMax", "start": [194, 1], "end": [195, 62], "kind": "commanddeclaration"}, {"full_name": "UnionFind.rank_eq", "code": "theorem rank_eq (self : UnionFind \u03b1) {n} {m : UFModel n} (H : m.Models self.arr)\n    {i} (h : i < self.size) : self.rank i = m.rank i", "start": [197, 1], "end": [199, 28], "kind": "commanddeclaration"}, {"full_name": "UnionFind.rank_lt", "code": "theorem rank_lt (self : UnionFind \u03b1) {i : Nat} (h) : self.arr[i].parent \u2260 i \u2192\n    self.rank i < self.rank self.arr[i].parent", "start": [201, 1], "end": [204, 94], "kind": "commanddeclaration"}, {"full_name": "UnionFind.parent_lt", "code": "theorem parent_lt (self : UnionFind \u03b1) (i : Nat) (h) : self.arr[i].parent < self.size", "start": [206, 1], "end": [208, 52], "kind": "commanddeclaration"}, {"full_name": "UnionFind.push", "code": "def push (self : UnionFind \u03b1) (x : \u03b1) : UnionFind \u03b1 where\n  arr := self.arr.push \u27e8self.arr.size, x, 0\u27e9\n  model := let \u27e8_, hm\u27e9 := self.model'; \u27e8_, _, hm.push _ rfl _\u27e9", "start": [210, 1], "end": [212, 63], "kind": "commanddeclaration"}, {"full_name": "UnionFind.findAux", "code": "def findAux (self : UnionFind \u03b1) (x : Fin self.size) :\n    (s : Array (UFNode \u03b1)) \u00d7' (root : Fin s.size) \u00d7'\n    \u2203 n, \u2203 (m : UFModel n) (m' : UFModel n),\n      m.Models self.arr \u2227 m'.Models s \u2227 m'.rank = m.rank \u2227\n      (\u2203 hr, (m'.parent \u27e8root, hr\u27e9).1 = root) \u2227\n      m.rank x \u2264 m.rank root := by\n  let y := self.arr[x].parent\n  refine if h : y = x then \u27e8self.arr, x, ?a'\u27e9 else\n    have := Nat.sub_lt_sub_left (self.lt_rankMax x) (self.rank_lt _ h)\n    let \u27e8arr\u2081, root, H\u27e9 := self.findAux \u27e8y, self.parent_lt _ x.2\u27e9\n    have hx := ?hx\n    let arr\u2082 := arr\u2081.set \u27e8x, hx\u27e9 {arr\u2081.get \u27e8x, hx\u27e9 with parent := root}\n    \u27e8arr\u2082, \u27e8root, by simp [root.2]\u27e9, ?b'\u27e9\n  case a' => let \u27e8m, hm\u27e9 := self.model'\n    exact \u27e8_, m, m, hm, hm, rfl, \u27e8x.2, by rwa [\u2190 hm.parent_eq]\u27e9, le_refl _\u27e9\n  all_goals let \u27e8n, m, m', hm, hm', e, \u27e8_, hr\u27e9, le\u27e9 := H\n  case hx => exact hm'.size_eq \u25b8 hm.size_eq.symm \u25b8 x.2\n  case b' =>\n    let x' : Fin n := \u27e8x, hm.size_eq \u25b8 x.2\u27e9\n    let root : Fin n := \u27e8root, hm'.size_eq.symm \u25b8 root.2\u27e9\n    have hy : (UFModel.parent m x').1 = y := by rw [\u2190 hm.parent_eq x x.2 x'.2]; rfl\n    have := m.rank_lt x'; rw [hy] at this\n    have := lt_of_lt_of_le (this h) le\n    refine \u27e8n, m, _, hm,\n      hm'.setParent x' root (by rw [e]; exact this) hx _ rfl rfl, e,\n      \u27e8root.2, ?_\u27e9, le_of_lt this\u27e9\n    have : x.1 \u2260 root := mt (congrArg _) (ne_of_lt this); dsimp only at this\n    simp [UFModel.setParent, this, hr]\ntermination_by _ \u03b1 self x => self.rankMax - self.rank x", "start": [214, 1], "end": [244, 56], "kind": "commanddeclaration"}, {"full_name": "UnionFind.find", "code": "def find (self : UnionFind \u03b1) (x : Fin self.size) :\n    (s : UnionFind \u03b1) \u00d7 (root : Fin s.size) \u00d7'\n    s.size = self.size \u2227 (s.arr.get root).parent = root :=\n  let \u27e8s, root, H\u27e9 := self.findAux x\n  have : _ \u2227 s.size = self.size \u2227 s[root.1].parent = root :=\n    let \u27e8n, _, m', hm, hm', _, \u27e8_, hr\u27e9, _\u27e9 := H\n    \u27e8\u27e8n, m', hm'\u27e9, hm'.size_eq.symm.trans hm.size_eq, by rwa [hm'.parent_eq]\u27e9\n  \u27e8\u27e8s, this.1\u27e9, root, this.2\u27e9", "start": [246, 1], "end": [253, 30], "kind": "commanddeclaration"}, {"full_name": "UnionFind.link", "code": "def link (self : UnionFind \u03b1) (x y : Fin self.size)\n    (yroot : (self.arr.get y).parent = y) : UnionFind \u03b1 := by\n  refine if ne : x.1 = y then self else\n    let nx := self.arr[x]\n    let ny := self.arr[y]\n    if h : ny.rank < nx.rank then\n      \u27e8self.arr.set y {ny with parent := x}, ?a\u27e9\n    else\n      let arr\u2081 := self.arr.set x {nx with parent := y}\n      let arr\u2082 := if nx.rank = ny.rank then\n        arr\u2081.set \u27e8y, by simp; exact y.2\u27e9 {ny with rank := ny.rank + 1}\n      else arr\u2081\n      \u27e8arr\u2082, ?b\u27e9\n  case a =>\n    let \u27e8m, hm\u27e9 := self.model'\n    exact \u27e8_, _, hm.setParent y x (by simpa [hm.rank_eq] using h) _ _ rfl rfl\u27e9\n  case b =>\n    let \u27e8m, hm\u27e9 := self.model'; let n := self.size\n    refine \u27e8_, m.setParentBump x y (by simpa [hm.rank_eq] using h)\n      (by simpa [\u2190 hm.parent_eq'] using yroot), ?_\u27e9\n    let parent (i : Fin n) := (if x.1 = i then y else m.parent i).1\n    have : UFModel.Agrees arr\u2081 (\u00b7.parent) parent :=\n      hm.1.set (fun i h \u21a6 by simp; rw [if_neg h.symm]) (fun _ \u21a6 by simp)\n    have H1 : UFModel.Agrees arr\u2082 (\u00b7.parent) parent := by\n      simp; split\n      \u00b7 exact this.set (fun i h \u21a6 by simp [h.symm]) (fun h \u21a6 by simp [ne, hm.parent_eq'])\n      \u00b7 exact this\n    have : UFModel.Agrees arr\u2081 (\u00b7.rank) (fun i : Fin n \u21a6 m.rank i) :=\n      hm.2.set (fun i _ \u21a6 by simp) (fun _ \u21a6 by simp [hm.rank_eq])\n    let rank (i : Fin n) := if y.1 = i \u2227 m.rank x = m.rank y then m.rank y + 1 else m.rank i\n    have H2 : UFModel.Agrees arr\u2082 (\u00b7.rank) rank := by\n      simp; split <;> (rename_i xy; simp [hm.rank_eq] at xy; simp [xy])\n      \u00b7 exact this.set (fun i h \u21a6 by rw [if_neg h.symm]) (fun h \u21a6 by simp [hm.rank_eq])\n      \u00b7 exact this\n    exact \u27e8H1, H2\u27e9", "start": [255, 1], "end": [290, 19], "kind": "commanddeclaration"}, {"full_name": "UnionFind.union", "code": "def union (self : UnionFind \u03b1) (x y : Fin self.size) : UnionFind \u03b1 :=\n  let \u27e8self\u2081, rx, e, _\u27e9 := self.find x\n  let \u27e8self\u2082, ry, e, hry\u27e9 := self\u2081.find \u27e8y, by rw [e]; exact y.2\u27e9\n  self\u2082.link \u27e8rx, by rw [e]; exact rx.2\u27e9 ry hry", "start": [292, 1], "end": [295, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/ProjectiveSpectrum/Scheme.lean", "imports": ["Mathlib/AlgebraicGeometry/ProjectiveSpectrum/StructureSheaf.lean", "Mathlib/RingTheory/GradedAlgebra/Radical.lean", "Mathlib/AlgebraicGeometry/Spec.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.carrier", "code": "def carrier : Ideal (A\u2070_ f) :=\n  Ideal.comap (algebraMap (A\u2070_ f) (Away f))\n    (Ideal.span <| algebraMap A (Away f) '' x.val.asHomogeneousIdeal)", "start": [150, 1], "end": [155, 70], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.mem_carrier_iff", "code": "theorem mem_carrier_iff (z : A\u2070_ f) :\n    z \u2208 carrier x \u2194 z.val \u2208 Ideal.span (algebraMap A (Away f) '' x.1.asHomogeneousIdeal)", "start": [158, 1], "end": [160, 10], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.MemCarrier.clear_denominator'", "code": "theorem MemCarrier.clear_denominator' [DecidableEq (Away f)] {z : Localization.Away f}\n    (hz : z \u2208 span (algebraMap A (Away f) '' x.val.asHomogeneousIdeal)) :\n    \u2203 (c : algebraMap A (Away f) '' x.1.asHomogeneousIdeal \u2192\u2080 Away f) (N : \u2115) (acd :\n      \u2200 y \u2208 c.support.image c, A),\n      f ^ N \u2022 z =\n        algebraMap A (Away f)\n          (\u2211 i in c.support.attach,\n            acd (c i) (Finset.mem_image.mpr \u27e8i, \u27e8i.2, rfl\u27e9\u27e9) * i.1.2.choose)", "start": [163, 1], "end": [181, 90], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.MemCarrier.clear_denominator", "code": "theorem MemCarrier.clear_denominator [DecidableEq (Away f)] {z : A\u2070_ f} (hz : z \u2208 carrier x) :\n    \u2203 (c : algebraMap A (Away f) '' x.1.asHomogeneousIdeal \u2192\u2080 Away f) (N : \u2115) (acd :\n      \u2200 y \u2208 c.support.image c, A),\n      f ^ N \u2022 z.val =\n        algebraMap A (Away f)\n          (\u2211 i in c.support.attach,\n            acd (c i) (Finset.mem_image.mpr \u27e8i, \u27e8i.2, rfl\u27e9\u27e9) * i.1.2.choose)", "start": [184, 1], "end": [191, 66], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.disjoint", "code": "theorem disjoint :\n    Disjoint (x.1.asHomogeneousIdeal.toIdeal : Set A) (Submonoid.powers f : Set A)", "start": [194, 1], "end": [206, 14], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.carrier_ne_top", "code": "theorem carrier_ne_top : carrier x \u2260 \u22a4", "start": [209, 1], "end": [226, 37], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.toFun", "code": "def toFun (x : Proj.T| pbo f) : Spec.T A\u2070_ f :=\n  \u27e8carrier x, carrier_ne_top x, fun {x1 x2} hx12 => by\n    classical\n    rw [mem_carrier_iff] at hx12\n    let J := span ((algebraMap A (Away f) : A \u2192 (Away f)) '' x.val.asHomogeneousIdeal)\n    suffices h : \u2200 x y : Localization.Away f, x * y \u2208 J \u2192 x \u2208 J \u2228 y \u2208 J\n    \u00b7 rw [HomogeneousLocalization.mul_val] at hx12; exact h x1.val x2.val hx12\n    clear x1 x2 hx12\n    intro x1 x2 hx12\n    induction' x1 using Localization.induction_on with data_x1\n    induction' x2 using Localization.induction_on with data_x2\n    rcases data_x1, data_x2 with \u27e8\u27e8a1, _, \u27e8n1, rfl\u27e9\u27e9, \u27e8a2, _, \u27e8n2, rfl\u27e9\u27e9\u27e9\n    rcases MemCarrier.clear_denominator' x hx12 with \u27e8c, N, acd, eq1\u27e9\n    simp only [Algebra.smul_def] at eq1\n    change Localization.mk (f ^ N) 1 * (Localization.mk _ _ * Localization.mk _ _)\n      = Localization.mk _ _ at eq1\n    simp only [Localization.mk_mul, one_mul] at eq1\n    simp only [mk_eq_mk', IsLocalization.eq] at eq1\n    rcases eq1 with \u27e8\u27e8_, \u27e8M, rfl\u27e9\u27e9, eq1\u27e9\n    rw [Submonoid.coe_one, one_mul] at eq1\n    change f ^ _ * (_ * _) = f ^ _ * (f ^ _ * f ^ _ * _) at eq1\n    have that : a1 * a2 * f ^ N * f ^ M \u2208 x.val.asHomogeneousIdeal.toIdeal := ?_\n    rcases x.1.isPrime.mem_or_mem (show a1 * a2 * f ^ N * f ^ M \u2208 _ from that) with (h1 | rid2)\n    rcases x.1.isPrime.mem_or_mem h1 with (h1 | rid1)\n    rcases x.1.isPrime.mem_or_mem h1 with (h1 | h2)\n    \u00b7 left;\n      simp only [show (Localization.mk a1 \u27e8f ^ n1, _\u27e9 : Away f) =\n        Localization.mk a1 1 * Localization.mk 1 (\u27e8f ^ n1, \u27e8n1, rfl\u27e9\u27e9 : Submonoid.powers f) by\n          rw [Localization.mk_mul, mul_one, one_mul]]\n      exact Ideal.mul_mem_right _ _ (Ideal.subset_span \u27e8_, h1, rfl\u27e9)\n    \u00b7 right;\n      simp only [show (mk a2 \u27e8f ^ n2, _\u27e9 : Away f) =\n        mk a2 1 * Localization.mk 1 (\u27e8f ^ n2, \u27e8n2, rfl\u27e9\u27e9 : Submonoid.powers f) by\n          rw [Localization.mk_mul, mul_one, one_mul]]\n      exact Ideal.mul_mem_right _ _ (Ideal.subset_span \u27e8_, h2, rfl\u27e9)\n    \u00b7 exact False.elim (x.2 (x.1.isPrime.mem_of_pow_mem N rid1))\n    \u00b7 exact False.elim (x.2 (x.1.isPrime.mem_of_pow_mem M rid2))\n    \u00b7 rw [\u2190 mul_comm (f ^ M), \u2190 mul_comm (f ^ N), eq1]\n      refine' mul_mem_left _ _ (mul_mem_left _ _ (sum_mem _ fun i _ => mul_mem_left _ _ _))\n      generalize_proofs h\u2081 h\u2082; exact (Classical.choose_spec h\u2082).1\u27e9", "start": [231, 1], "end": [273, 67], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.preimage_eq", "code": "theorem preimage_eq (a b : A) (k : \u2115) (a_mem : a \u2208 \ud835\udc9c k) (b_mem1 : b \u2208 \ud835\udc9c k)\n    (b_mem2 : b \u2208 Submonoid.powers f) :\n    toFun f \u207b\u00b9'\n        (@PrimeSpectrum.basicOpen (A\u2070_ f) _ (Quotient.mk'' \u27e8k, \u27e8a, a_mem\u27e9, \u27e8b, b_mem1\u27e9, b_mem2\u27e9) :\n          Set (PrimeSpectrum (HomogeneousLocalization.Away \ud835\udc9c f))) =\n      {x | x.1 \u2208 (pbo f) \u2293 pbo a}", "start": [281, 1], "end": [322, 50], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.toSpec", "code": "def toSpec {f : A} : (Proj.T| pbo f) \u27f6 Spec.T A\u2070_ f where\n  toFun := ToSpec.toFun f\n  continuous_toFun := by\n    apply IsTopologicalBasis.continuous PrimeSpectrum.isTopologicalBasis_basic_opens\n    rintro _ \u27e8\u27e8k, \u27e8a, ha\u27e9, \u27e8b, hb1\u27e9, \u27e8k', hb2\u27e9\u27e9, rfl\u27e9; dsimp\n    erw [ToSpec.preimage_eq f a b k ha hb1 \u27e8k', hb2\u27e9]\n    refine' isOpen_induced_iff.mpr \u27e8(pbo f).1 \u2293 (pbo a).1, IsOpen.inter (pbo f).2 (pbo a).2, _\u27e9\n    ext z; constructor\n    \u00b7 intro hz; simpa [Set.mem_preimage]\n    \u00b7 intro hz; simpa only [Set.inf_eq_inter,Set.mem_inter_iff,Set.mem_preimage]", "start": [331, 1], "end": [343, 81], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier", "code": "def carrier (q : Spec.T A\u2070_ f) : Set A :=\n  {a | \u2200 i, (Quotient.mk'' \u27e8m * i, \u27e8proj \ud835\udc9c i a ^ m, by mem_tac\u27e9,\n              \u27e8f ^ i, by rw [mul_comm]; mem_tac\u27e9, \u27e8_, rfl\u27e9\u27e9 : A\u2070_ f) \u2208 q.1}", "start": [369, 1], "end": [383, 76], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.mem_carrier_iff", "code": "theorem mem_carrier_iff (q : Spec.T A\u2070_ f) (a : A) :\n    a \u2208 carrier f_deg q \u2194 \u2200 i, (Quotient.mk'' \u27e8m * i, \u27e8proj \ud835\udc9c i a ^ m, by mem_tac\u27e9,\n      \u27e8f ^ i, by rw [mul_comm]; mem_tac\u27e9, \u27e8_, rfl\u27e9\u27e9 : A\u2070_ f) \u2208 q.1", "start": [386, 1], "end": [389, 10], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.mem_carrier_iff'", "code": "theorem mem_carrier_iff' (q : Spec.T A\u2070_ f) (a : A) :\n    a \u2208 carrier f_deg q \u2194\n      \u2200 i, (Localization.mk (proj \ud835\udc9c i a ^ m) \u27e8f ^ i, \u27e8i, rfl\u27e9\u27e9 : Localization.Away f) \u2208\n          algebraMap (HomogeneousLocalization.Away \ud835\udc9c f) (Localization.Away f) '' { s | s \u2208 q.1 }", "start": [392, 1], "end": [404, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.add_mem", "code": "theorem carrier.add_mem (q : Spec.T A\u2070_ f) {a b : A} (ha : a \u2208 carrier f_deg q)\n    (hb : b \u2208 carrier f_deg q) : a + b \u2208 carrier f_deg q", "start": [407, 1], "end": [457, 27], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.zero_mem", "code": "theorem carrier.zero_mem : (0 : A) \u2208 carrier f_deg q", "start": [462, 1], "end": [466, 67], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.smul_mem", "code": "theorem carrier.smul_mem (c x : A) (hx : x \u2208 carrier f_deg q) : c \u2022 x \u2208 carrier f_deg q", "start": [469, 1], "end": [491, 65], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.asIdeal", "code": "def carrier.asIdeal : Ideal A where\n  carrier := carrier f_deg q\n  zero_mem' := carrier.zero_mem f_deg hm q\n  add_mem' := carrier.add_mem f_deg q\n  smul_mem' := carrier.smul_mem f_deg hm q", "start": [494, 1], "end": [500, 43], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.asIdeal.homogeneous", "code": "theorem carrier.asIdeal.homogeneous : (carrier.asIdeal f_deg hm q).IsHomogeneous \ud835\udc9c", "start": [504, 1], "end": [510, 70], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.asHomogeneousIdeal", "code": "def carrier.asHomogeneousIdeal : HomogeneousIdeal \ud835\udc9c :=\n  \u27e8carrier.asIdeal f_deg hm q, carrier.asIdeal.homogeneous f_deg hm q\u27e9", "start": [513, 1], "end": [516, 71], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.denom_not_mem", "code": "theorem carrier.denom_not_mem : f \u2209 carrier.asIdeal f_deg hm q", "start": [519, 1], "end": [528, 76], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.relevant", "code": "theorem carrier.relevant : \u00acHomogeneousIdeal.irrelevant \ud835\udc9c \u2264 carrier.asHomogeneousIdeal f_deg hm q", "start": [531, 1], "end": [532, 101], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.asIdeal.ne_top", "code": "theorem carrier.asIdeal.ne_top : carrier.asIdeal f_deg hm q \u2260 \u22a4", "start": [535, 1], "end": [536, 66], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.carrier.asIdeal.prime", "code": "theorem carrier.asIdeal.prime : (carrier.asIdeal f_deg hm q).IsPrime", "start": [539, 1], "end": [558, 40], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.toFun", "code": "def toFun : (Spec.T A\u2070_ f) \u2192 Proj.T| pbo f := fun q =>\n  \u27e8\u27e8carrier.asHomogeneousIdeal f_deg hm q, carrier.asIdeal.prime f_deg hm q,\n      carrier.relevant f_deg hm q\u27e9,\n    (ProjectiveSpectrum.mem_basicOpen _ f _).mp <| carrier.denom_not_mem f_deg hm q\u27e9", "start": [561, 1], "end": [566, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/Ring/Adjunctions.lean", "imports": ["Mathlib/Data/MvPolynomial/CommRing.lean", "Mathlib/Algebra/Category/Ring/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CommRingCat.free", "code": "def free : Type u \u2964 CommRingCat.{u} where\n  obj \u03b1 := of (MvPolynomial \u03b1 \u2124)\n  map {X Y} f := (\u2191(rename f : _ \u2192\u2090[\u2124] _) : MvPolynomial X \u2124 \u2192+* MvPolynomial Y \u2124)\n  map_id _ := RingHom.ext <| rename_id\n  map_comp f g := RingHom.ext fun p => (rename_rename f g p).symm", "start": [30, 1], "end": [39, 66], "kind": "commanddeclaration"}, {"full_name": "CommRingCat.free_obj_coe", "code": "@[simp]\ntheorem free_obj_coe {\u03b1 : Type u} : (free.obj \u03b1 : Type u) = MvPolynomial \u03b1 \u2124", "start": [42, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "CommRingCat.free_map_coe", "code": "@[simp, nolint simpNF]\ntheorem free_map_coe {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} : \u21d1(free.map f) = \u21d1(rename f)", "start": [49, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "CommRingCat.adj", "code": "def adj : free \u22a3 forget CommRingCat.{u} :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X R => homEquiv\n      homEquiv_naturality_left_symm := fun {_ _ Y} f g =>\n        RingHom.ext fun x => eval\u2082_cast_comp f (Int.castRingHom Y) g x }", "start": [54, 1], "end": [60, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/ContinuousFunction/T0Sierpinski.lean", "imports": ["Mathlib/Topology/Order.lean", "Mathlib/Topology/ContinuousFunction/Basic.lean", "Mathlib/Topology/Sets/Opens.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopologicalSpace.eq_induced_by_maps_to_sierpinski", "code": "theorem eq_induced_by_maps_to_sierpinski (X : Type*) [t : TopologicalSpace X] :\n    t = \u2a05 u : Opens X, sierpinskiSpace.induced (\u00b7 \u2208 u)", "start": [28, 1], "end": [37, 74], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.productOfMemOpens", "code": "def productOfMemOpens : C(X, Opens X \u2192 Prop) where\n  toFun x u := x \u2208 u\n  continuous_toFun := continuous_pi_iff.2 fun u => continuous_Prop.2 u.isOpen", "start": [42, 1], "end": [47, 78], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.productOfMemOpens_inducing", "code": "theorem productOfMemOpens_inducing : Inducing (productOfMemOpens X)", "start": [50, 1], "end": [52, 41], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.productOfMemOpens_injective", "code": "theorem productOfMemOpens_injective [T0Space X] : Function.Injective (productOfMemOpens X)", "start": [55, 1], "end": [58, 68], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.productOfMemOpens_embedding", "code": "theorem productOfMemOpens_embedding [T0Space X] : Embedding (productOfMemOpens X)", "start": [61, 1], "end": [62, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/MvPolynomial/Ideal.lean", "imports": ["Mathlib/Data/MvPolynomial/Division.lean", "Mathlib/Algebra/MonoidAlgebra/Ideal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvPolynomial.mem_ideal_span_monomial_image", "code": "theorem mem_ideal_span_monomial_image {x : MvPolynomial \u03c3 R} {s : Set (\u03c3 \u2192\u2080 \u2115)} :\n    x \u2208 Ideal.span ((fun s => monomial s (1 : R)) '' s) \u2194 \u2200 xi \u2208 x.support, \u2203 si \u2208 s, si \u2264 xi", "start": [29, 1], "end": [36, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mem_ideal_span_monomial_image_iff_dvd", "code": "theorem mem_ideal_span_monomial_image_iff_dvd {x : MvPolynomial \u03c3 R} {s : Set (\u03c3 \u2192\u2080 \u2115)} :\n    x \u2208 Ideal.span ((fun s => monomial s (1 : R)) '' s) \u2194\n      \u2200 xi \u2208 x.support, \u2203 si \u2208 s, monomial si 1 \u2223 monomial xi (x.coeff xi)", "start": [39, 1], "end": [43, 95], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mem_ideal_span_X_image", "code": "theorem mem_ideal_span_X_image {x : MvPolynomial \u03c3 R} {s : Set \u03c3} :\n    x \u2208 Ideal.span (MvPolynomial.X '' s : Set (MvPolynomial \u03c3 R)) \u2194\n      \u2200 m \u2208 x.support, \u2203 i \u2208 s, (m : \u03c3 \u2192\u2080 \u2115) i \u2260 0", "start": [46, 1], "end": [54, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean", "imports": ["Mathlib/Data/MvPolynomial/Variables.lean", "Mathlib/Algebra/GradedMonoid.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvPolynomial.weightedDegree'", "code": "def weightedDegree' (w : \u03c3 \u2192 M) : (\u03c3 \u2192\u2080 \u2115) \u2192+ M :=\n  (Finsupp.total \u03c3 M \u2115 w).toAddMonoidHom", "start": [63, 1], "end": [66, 41], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedTotalDegree'", "code": "def weightedTotalDegree' (w : \u03c3 \u2192 M) (p : MvPolynomial \u03c3 R) : WithBot M :=\n  p.support.sup fun s => weightedDegree' w s", "start": [73, 1], "end": [75, 45], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedTotalDegree'_eq_bot_iff", "code": "theorem weightedTotalDegree'_eq_bot_iff (w : \u03c3 \u2192 M) (p : MvPolynomial \u03c3 R) :\n    weightedTotalDegree' w p = \u22a5 \u2194 p = 0", "start": [78, 1], "end": [83, 49], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedTotalDegree'_zero", "code": "theorem weightedTotalDegree'_zero (w : \u03c3 \u2192 M) : weightedTotalDegree' w (0 : MvPolynomial \u03c3 R) = \u22a5", "start": [86, 1], "end": [88, 70], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedTotalDegree", "code": "def weightedTotalDegree (w : \u03c3 \u2192 M) (p : MvPolynomial \u03c3 R) : M :=\n  p.support.sup fun s => weightedDegree' w s", "start": [95, 1], "end": [98, 45], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedTotalDegree_coe", "code": "theorem weightedTotalDegree_coe (w : \u03c3 \u2192 M) (p : MvPolynomial \u03c3 R) (hp : p \u2260 0) :\n    weightedTotalDegree' w p = \u2191(weightedTotalDegree w p)", "start": [101, 1], "end": [113, 43], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedTotalDegree_zero", "code": "theorem weightedTotalDegree_zero (w : \u03c3 \u2192 M) : weightedTotalDegree w (0 : MvPolynomial \u03c3 R) = \u22a5", "start": [116, 1], "end": [118, 69], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.le_weightedTotalDegree", "code": "theorem le_weightedTotalDegree (w : \u03c3 \u2192 M) {\u03c6 : MvPolynomial \u03c3 R} {d : \u03c3 \u2192\u2080 \u2115}\n    (hd : d \u2208 \u03c6.support) : weightedDegree' w d \u2264 \u03c6.weightedTotalDegree w", "start": [121, 1], "end": [123, 12], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsWeightedHomogeneous", "code": "def IsWeightedHomogeneous (w : \u03c3 \u2192 M) (\u03c6 : MvPolynomial \u03c3 R) (m : M) : Prop :=\n  \u2200 \u2983d\u2984, coeff d \u03c6 \u2260 0 \u2192 weightedDegree' w d = m", "start": [130, 1], "end": [133, 49], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedHomogeneousSubmodule", "code": "def weightedHomogeneousSubmodule (w : \u03c3 \u2192 M) (m : M) : Submodule R (MvPolynomial \u03c3 R) where\n  carrier := { x | x.IsWeightedHomogeneous w m }\n  smul_mem' r a ha c hc := by\n    rw [coeff_smul] at hc\n    exact ha (right_ne_zero_of_mul hc)\n  zero_mem' d hd := False.elim (hd <| coeff_zero _)\n  add_mem' {a} {b} ha hb c hc := by\n    rw [coeff_add] at hc\n    obtain h | h : coeff c a \u2260 0 \u2228 coeff c b \u2260 0 := by\n      contrapose! hc\n      simp only [hc, add_zero]\n    \u00b7 exact ha h\n    \u00b7 exact hb h", "start": [138, 1], "end": [151, 17], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mem_weightedHomogeneousSubmodule", "code": "@[simp]\ntheorem mem_weightedHomogeneousSubmodule (w : \u03c3 \u2192 M) (m : M) (p : MvPolynomial \u03c3 R) :\n    p \u2208 weightedHomogeneousSubmodule R w m \u2194 p.IsWeightedHomogeneous w m", "start": [154, 1], "end": [157, 10], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedHomogeneousSubmodule_eq_finsupp_supported", "code": "theorem weightedHomogeneousSubmodule_eq_finsupp_supported (w : \u03c3 \u2192 M) (m : M) :\n    weightedHomogeneousSubmodule R w m = Finsupp.supported R R { d | weightedDegree' w d = m }", "start": [160, 1], "end": [169, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedHomogeneousSubmodule_mul", "code": "theorem weightedHomogeneousSubmodule_mul (w : \u03c3 \u2192 M) (m n : M) :\n    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n \u2264\n      weightedHomogeneousSubmodule R w (m + n)", "start": [174, 1], "end": [188, 74], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isWeightedHomogeneous_monomial", "code": "theorem isWeightedHomogeneous_monomial (w : \u03c3 \u2192 M) (d : \u03c3 \u2192\u2080 \u2115) (r : R) {m : M}\n    (hm : weightedDegree' w d = m) : IsWeightedHomogeneous w (monomial d r) m", "start": [191, 1], "end": [200, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isWeightedHomogeneous_of_total_degree_zero", "code": "theorem isWeightedHomogeneous_of_total_degree_zero [SemilatticeSup M] [OrderBot M] (w : \u03c3 \u2192 M)\n    {p : MvPolynomial \u03c3 R} (hp : weightedTotalDegree w p = (\u22a5 : M)) :\n    IsWeightedHomogeneous w p (\u22a5 : M)", "start": [203, 1], "end": [211, 47], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isWeightedHomogeneous_C", "code": "theorem isWeightedHomogeneous_C (w : \u03c3 \u2192 M) (r : R) :\n    IsWeightedHomogeneous w (C r : MvPolynomial \u03c3 R) 0", "start": [214, 1], "end": [217, 52], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isWeightedHomogeneous_zero", "code": "theorem isWeightedHomogeneous_zero (w : \u03c3 \u2192 M) (m : M) :\n    IsWeightedHomogeneous w (0 : MvPolynomial \u03c3 R) m", "start": [223, 1], "end": [226, 48], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isWeightedHomogeneous_one", "code": "theorem isWeightedHomogeneous_one (w : \u03c3 \u2192 M) : IsWeightedHomogeneous w (1 : MvPolynomial \u03c3 R) 0", "start": [229, 1], "end": [231, 30], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isWeightedHomogeneous_X", "code": "theorem isWeightedHomogeneous_X (w : \u03c3 \u2192 M) (i : \u03c3) :\n    IsWeightedHomogeneous w (X i : MvPolynomial \u03c3 R) (w i)", "start": [234, 1], "end": [238, 85], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsWeightedHomogeneous.coeff_eq_zero", "code": "theorem coeff_eq_zero {w : \u03c3 \u2192 M} (h\u03c6 : IsWeightedHomogeneous w \u03c6 n) (d : \u03c3 \u2192\u2080 \u2115)\n    (hd : weightedDegree' w d \u2260 n) : coeff d \u03c6 = 0", "start": [248, 1], "end": [252, 33], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsWeightedHomogeneous.inj_right", "code": "theorem inj_right {w : \u03c3 \u2192 M} (h\u03c6 : \u03c6 \u2260 0) (hm : IsWeightedHomogeneous w \u03c6 m)\n    (hn : IsWeightedHomogeneous w \u03c6 n) : m = n", "start": [255, 1], "end": [259, 24], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsWeightedHomogeneous.add", "code": "theorem add {w : \u03c3 \u2192 M} (h\u03c6 : IsWeightedHomogeneous w \u03c6 n) (h\u03c8 : IsWeightedHomogeneous w \u03c8 n) :\n    IsWeightedHomogeneous w (\u03c6 + \u03c8) n", "start": [262, 1], "end": [266, 53], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsWeightedHomogeneous.sum", "code": "theorem sum {\u03b9 : Type*} (s : Finset \u03b9) (\u03c6 : \u03b9 \u2192 MvPolynomial \u03c3 R) (n : M) {w : \u03c3 \u2192 M}\n    (h : \u2200 i \u2208 s, IsWeightedHomogeneous w (\u03c6 i) n) : IsWeightedHomogeneous w (\u2211 i in s, \u03c6 i) n", "start": [269, 1], "end": [273, 49], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsWeightedHomogeneous.mul", "code": "theorem mul {w : \u03c3 \u2192 M} (h\u03c6 : IsWeightedHomogeneous w \u03c6 m) (h\u03c8 : IsWeightedHomogeneous w \u03c8 n) :\n    IsWeightedHomogeneous w (\u03c6 * \u03c8) (m + n)", "start": [276, 1], "end": [280, 72], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsWeightedHomogeneous.prod", "code": "theorem prod {\u03b9 : Type*} (s : Finset \u03b9) (\u03c6 : \u03b9 \u2192 MvPolynomial \u03c3 R) (n : \u03b9 \u2192 M) {w : \u03c3 \u2192 M} :\n    (\u2200 i \u2208 s, IsWeightedHomogeneous w (\u03c6 i) (n i)) \u2192\n      IsWeightedHomogeneous w (\u220f i in s, \u03c6 i) (\u2211 i in s, n i)", "start": [283, 1], "end": [296, 45], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsWeightedHomogeneous.weighted_total_degree", "code": "theorem weighted_total_degree [SemilatticeSup M] {w : \u03c3 \u2192 M} (h\u03c6 : IsWeightedHomogeneous w \u03c6 n)\n    (h : \u03c6 \u2260 0) : weightedTotalDegree' w \u03c6 = n", "start": [299, 1], "end": [310, 27], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsWeightedHomogeneous.WeightedHomogeneousSubmodule.gcomm_monoid", "code": "instance WeightedHomogeneousSubmodule.gcomm_monoid {w : \u03c3 \u2192 M} :\n    SetLike.GradedMonoid (weightedHomogeneousSubmodule R w) where\n  one_mem := isWeightedHomogeneous_one R w\n  mul_mem _ _ _ _ := IsWeightedHomogeneous.mul", "start": [313, 1], "end": [317, 47], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedHomogeneousComponent", "code": "def weightedHomogeneousComponent (w : \u03c3 \u2192 M) (n : M) : MvPolynomial \u03c3 R \u2192\u2097[R] MvPolynomial \u03c3 R :=\n  (Submodule.subtype _).comp <| Finsupp.restrictDom _ _ { d | weightedDegree' w d = n }", "start": [324, 1], "end": [329, 88], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_weightedHomogeneousComponent", "code": "theorem coeff_weightedHomogeneousComponent [DecidableEq M] (d : \u03c3 \u2192\u2080 \u2115) :\n    coeff d (weightedHomogeneousComponent w n \u03c6) =\n      if weightedDegree' w d = n then coeff d \u03c6 else 0", "start": [336, 1], "end": [339, 71], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedHomogeneousComponent_apply", "code": "theorem weightedHomogeneousComponent_apply [DecidableEq M] :\n    weightedHomogeneousComponent w n \u03c6 =\n      \u2211 d in \u03c6.support.filter fun d => weightedDegree' w d = n, monomial d (coeff d \u03c6)", "start": [342, 1], "end": [345, 70], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedHomogeneousComponent_isWeightedHomogeneous", "code": "theorem weightedHomogeneousComponent_isWeightedHomogeneous :\n    (weightedHomogeneousComponent w n \u03c6).IsWeightedHomogeneous w n", "start": [348, 1], "end": [355, 53], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedHomogeneousComponent_C_mul", "code": "@[simp]\ntheorem weightedHomogeneousComponent_C_mul (n : M) (r : R) :\n    weightedHomogeneousComponent w n (C r * \u03c6) = C r * weightedHomogeneousComponent w n \u03c6", "start": [358, 1], "end": [361, 41], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedHomogeneousComponent_eq_zero'", "code": "theorem weightedHomogeneousComponent_eq_zero'\n    (h : \u2200 d : \u03c3 \u2192\u2080 \u2115, d \u2208 \u03c6.support \u2192 weightedDegree' w d \u2260 n) :\n    weightedHomogeneousComponent w n \u03c6 = 0", "start": [365, 1], "end": [371, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedHomogeneousComponent_eq_zero", "code": "theorem weightedHomogeneousComponent_eq_zero [SemilatticeSup M] [OrderBot M]\n    (h : weightedTotalDegree w \u03c6 < n) : weightedHomogeneousComponent w n \u03c6 = 0", "start": [374, 1], "end": [383, 57], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedHomogeneousComponent_finsupp", "code": "theorem weightedHomogeneousComponent_finsupp :\n    (Function.support fun m => weightedHomogeneousComponent w m \u03c6).Finite", "start": [386, 1], "end": [397, 54], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.sum_weightedHomogeneousComponent", "code": "theorem sum_weightedHomogeneousComponent :\n    (finsum fun m => weightedHomogeneousComponent w m \u03c6) = \u03c6", "start": [402, 1], "end": [418, 20], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedHomogeneousComponent_weighted_homogeneous_polynomial", "code": "theorem weightedHomogeneousComponent_weighted_homogeneous_polynomial [DecidableEq M] (m n : M)\n    (p : MvPolynomial \u03c3 R) (h : p \u2208 weightedHomogeneousSubmodule R w n) :\n    weightedHomogeneousComponent w m p = if m = n then p else 0", "start": [423, 1], "end": [437, 29], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.weightedHomogeneousComponent_zero", "code": "@[simp]\ntheorem weightedHomogeneousComponent_zero [NoZeroSMulDivisors \u2115 M] (hw : \u2200 i : \u03c3, w i \u2260 0) :\n    weightedHomogeneousComponent w 0 \u03c6 = C (coeff 0 \u03c6)", "start": [448, 1], "end": [463, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/LocallyConvex/ContinuousOfBounded.lean", "imports": ["Mathlib/Analysis/LocallyConvex/Bounded.lean", "Mathlib/Data/IsROrC/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.clmOfExistsBoundedImage", "code": "def LinearMap.clmOfExistsBoundedImage (f : E \u2192\u2097[\ud835\udd5c] F)\n    (h : \u2203 (V : Set E) (_ : V \u2208 \ud835\udcdd (0 : E)), Bornology.IsVonNBounded \ud835\udd5c (f '' V)) : E \u2192L[\ud835\udd5c] F :=\n  \u27e8f, by\n    refine' continuous_of_continuousAt_zero f _\n    rw [continuousAt_def, f.map_zero]\n    intro U hU\n    rcases h with \u27e8V, hV, h\u27e9\n    rcases h hU with \u27e8r, hr, h\u27e9\n    rcases NormedField.exists_lt_norm \ud835\udd5c r with \u27e8x, hx\u27e9\n    specialize h x hx.le\n    have x_ne := norm_pos_iff.mp (hr.trans hx)\n    have : x\u207b\u00b9 \u2022 V \u2286 f \u207b\u00b9' U :=\n      calc\n        x\u207b\u00b9 \u2022 V \u2286 x\u207b\u00b9 \u2022 f \u207b\u00b9' (f '' V) := Set.smul_set_mono (Set.subset_preimage_image (\u21d1f) V)\n        _ \u2286 x\u207b\u00b9 \u2022 f \u207b\u00b9' (x \u2022 U) := (Set.smul_set_mono (Set.preimage_mono h))\n        _ = f \u207b\u00b9' (x\u207b\u00b9 \u2022 x \u2022 U) := by\n          ext\n          simp only [Set.mem_inv_smul_set_iff\u2080 x_ne, Set.mem_preimage, LinearMap.map_smul]\n        _ \u2286 f \u207b\u00b9' U := by rw [inv_smul_smul\u2080 x_ne _]\n    refine' mem_of_superset _ this\n    convert set_smul_mem_nhds_smul hV (inv_ne_zero x_ne)\n    exact (smul_zero _).symm\u27e9", "start": [44, 1], "end": [72, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.clmOfExistsBoundedImage_coe", "code": "theorem LinearMap.clmOfExistsBoundedImage_coe {f : E \u2192\u2097[\ud835\udd5c] F}\n    {h : \u2203 (V : Set E) (_ : V \u2208 \ud835\udcdd (0 : E)), Bornology.IsVonNBounded \ud835\udd5c (f '' V)} :\n    (f.clmOfExistsBoundedImage h : E \u2192\u2097[\ud835\udd5c] F) = f", "start": [75, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.clmOfExistsBoundedImage_apply", "code": "@[simp]\ntheorem LinearMap.clmOfExistsBoundedImage_apply {f : E \u2192\u2097[\ud835\udd5c] F}\n    {h : \u2203 (V : Set E) (_ : V \u2208 \ud835\udcdd (0 : E)), Bornology.IsVonNBounded \ud835\udd5c (f '' V)} {x : E} :\n    f.clmOfExistsBoundedImage h x = f x", "start": [81, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.continuousAt_zero_of_locally_bounded", "code": "theorem LinearMap.continuousAt_zero_of_locally_bounded (f : E \u2192\u209b\u2097[\u03c3] F)\n    (hf : \u2200 (s : Set E) (_ : IsVonNBounded \ud835\udd5c s), IsVonNBounded \ud835\udd5c' (f '' s)) : ContinuousAt f 0", "start": [102, 1], "end": [172, 22], "kind": "commanddeclaration"}, {"full_name": "LinearMap.continuous_of_locally_bounded", "code": "theorem LinearMap.continuous_of_locally_bounded [UniformAddGroup F] (f : E \u2192\u209b\u2097[\u03c3] F)\n    (hf : \u2200 (s : Set E) (_ : IsVonNBounded \ud835\udd5c s), IsVonNBounded \ud835\udd5c' (f '' s)) : Continuous f", "start": [175, 1], "end": [178, 101], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Computability/Reduce.lean", "imports": ["Mathlib/Computability/Halting.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ManyOneReducible", "code": "def ManyOneReducible {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] (p : \u03b1 \u2192 Prop) (q : \u03b2 \u2192 Prop) :=\n  \u2203 f, Computable f \u2227 \u2200 a, p a \u2194 q (f a)", "start": [35, 1], "end": [40, 41], "kind": "commanddeclaration"}, {"full_name": "ManyOneReducible.mk", "code": "theorem ManyOneReducible.mk {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {f : \u03b1 \u2192 \u03b2} (q : \u03b2 \u2192 Prop)\n    (h : Computable f) : (fun a => q (f a)) \u2264\u2080 q", "start": [47, 1], "end": [49, 27], "kind": "commanddeclaration"}, {"full_name": "manyOneReducible_refl", "code": "@[refl]\ntheorem manyOneReducible_refl {\u03b1} [Primcodable \u03b1] (p : \u03b1 \u2192 Prop) : p \u2264\u2080 p", "start": [52, 1], "end": [54, 31], "kind": "commanddeclaration"}, {"full_name": "ManyOneReducible.trans", "code": "@[trans]\ntheorem ManyOneReducible.trans {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3]\n    {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} : p \u2264\u2080 q \u2192 q \u2264\u2080 r \u2192 p \u2264\u2080 r", "start": [57, 1], "end": [62, 85], "kind": "commanddeclaration"}, {"full_name": "reflexive_manyOneReducible", "code": "theorem reflexive_manyOneReducible {\u03b1} [Primcodable \u03b1] : Reflexive (@ManyOneReducible \u03b1 \u03b1 _ _)", "start": [65, 1], "end": [66, 24], "kind": "commanddeclaration"}, {"full_name": "transitive_manyOneReducible", "code": "theorem transitive_manyOneReducible {\u03b1} [Primcodable \u03b1] : Transitive (@ManyOneReducible \u03b1 \u03b1 _ _)", "start": [69, 1], "end": [70, 38], "kind": "commanddeclaration"}, {"full_name": "OneOneReducible", "code": "def OneOneReducible {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] (p : \u03b1 \u2192 Prop) (q : \u03b2 \u2192 Prop) :=\n  \u2203 f, Computable f \u2227 Injective f \u2227 \u2200 a, p a \u2194 q (f a)", "start": [73, 1], "end": [78, 55], "kind": "commanddeclaration"}, {"full_name": "OneOneReducible.mk", "code": "theorem OneOneReducible.mk {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {f : \u03b1 \u2192 \u03b2} (q : \u03b2 \u2192 Prop)\n    (h : Computable f) (i : Injective f) : (fun a => q (f a)) \u2264\u2081 q", "start": [85, 1], "end": [87, 30], "kind": "commanddeclaration"}, {"full_name": "oneOneReducible_refl", "code": "@[refl]\ntheorem oneOneReducible_refl {\u03b1} [Primcodable \u03b1] (p : \u03b1 \u2192 Prop) : p \u2264\u2081 p", "start": [90, 1], "end": [92, 45], "kind": "commanddeclaration"}, {"full_name": "OneOneReducible.trans", "code": "@[trans]\ntheorem OneOneReducible.trans {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] {p : \u03b1 \u2192 Prop}\n    {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} : p \u2264\u2081 q \u2192 q \u2264\u2081 r \u2192 p \u2264\u2081 r", "start": [95, 1], "end": [100, 76], "kind": "commanddeclaration"}, {"full_name": "OneOneReducible.to_many_one", "code": "theorem OneOneReducible.to_many_one {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {p : \u03b1 \u2192 Prop}\n    {q : \u03b2 \u2192 Prop} : p \u2264\u2081 q \u2192 p \u2264\u2080 q", "start": [103, 1], "end": [105, 30], "kind": "commanddeclaration"}, {"full_name": "OneOneReducible.of_equiv", "code": "theorem OneOneReducible.of_equiv {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {e : \u03b1 \u2243 \u03b2} (q : \u03b2 \u2192 Prop)\n    (h : Computable e) : (q \u2218 e) \u2264\u2081 q", "start": [108, 1], "end": [110, 37], "kind": "commanddeclaration"}, {"full_name": "OneOneReducible.of_equiv_symm", "code": "theorem OneOneReducible.of_equiv_symm {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {e : \u03b1 \u2243 \u03b2}\n    (q : \u03b2 \u2192 Prop) (h : Computable e.symm) : q \u2264\u2081 (q \u2218 e)", "start": [113, 1], "end": [115, 53], "kind": "commanddeclaration"}, {"full_name": "reflexive_oneOneReducible", "code": "theorem reflexive_oneOneReducible {\u03b1} [Primcodable \u03b1] : Reflexive (@OneOneReducible \u03b1 \u03b1 _ _)", "start": [118, 1], "end": [119, 23], "kind": "commanddeclaration"}, {"full_name": "transitive_oneOneReducible", "code": "theorem transitive_oneOneReducible {\u03b1} [Primcodable \u03b1] : Transitive (@OneOneReducible \u03b1 \u03b1 _ _)", "start": [122, 1], "end": [123, 37], "kind": "commanddeclaration"}, {"full_name": "ComputablePred.computable_of_manyOneReducible", "code": "theorem computable_of_manyOneReducible {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (h\u2081 : p \u2264\u2080 q)\n    (h\u2082 : ComputablePred q) : ComputablePred p", "start": [134, 1], "end": [139, 54], "kind": "commanddeclaration"}, {"full_name": "ComputablePred.computable_of_oneOneReducible", "code": "theorem computable_of_oneOneReducible {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (h : p \u2264\u2081 q) :\n    ComputablePred q \u2192 ComputablePred p", "start": [142, 1], "end": [144, 47], "kind": "commanddeclaration"}, {"full_name": "ManyOneEquiv", "code": "def ManyOneEquiv {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] (p : \u03b1 \u2192 Prop) (q : \u03b2 \u2192 Prop) :=\n  p \u2264\u2080 q \u2227 q \u2264\u2080 p", "start": [149, 1], "end": [151, 18], "kind": "commanddeclaration"}, {"full_name": "OneOneEquiv", "code": "def OneOneEquiv {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] (p : \u03b1 \u2192 Prop) (q : \u03b2 \u2192 Prop) :=\n  p \u2264\u2081 q \u2227 q \u2264\u2081 p", "start": [154, 1], "end": [156, 18], "kind": "commanddeclaration"}, {"full_name": "manyOneEquiv_refl", "code": "@[refl]\ntheorem manyOneEquiv_refl {\u03b1} [Primcodable \u03b1] (p : \u03b1 \u2192 Prop) : ManyOneEquiv p p", "start": [159, 1], "end": [161, 53], "kind": "commanddeclaration"}, {"full_name": "ManyOneEquiv.symm", "code": "@[symm]\ntheorem ManyOneEquiv.symm {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} :\n    ManyOneEquiv p q \u2192 ManyOneEquiv q p", "start": [164, 1], "end": [167, 11], "kind": "commanddeclaration"}, {"full_name": "ManyOneEquiv.trans", "code": "@[trans]\ntheorem ManyOneEquiv.trans {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] {p : \u03b1 \u2192 Prop}\n    {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} : ManyOneEquiv p q \u2192 ManyOneEquiv q r \u2192 ManyOneEquiv p r", "start": [170, 1], "end": [173, 53], "kind": "commanddeclaration"}, {"full_name": "equivalence_of_manyOneEquiv", "code": "theorem equivalence_of_manyOneEquiv {\u03b1} [Primcodable \u03b1] : Equivalence (@ManyOneEquiv \u03b1 \u03b1 _ _)", "start": [176, 1], "end": [177, 89], "kind": "commanddeclaration"}, {"full_name": "oneOneEquiv_refl", "code": "@[refl]\ntheorem oneOneEquiv_refl {\u03b1} [Primcodable \u03b1] (p : \u03b1 \u2192 Prop) : OneOneEquiv p p", "start": [180, 1], "end": [182, 51], "kind": "commanddeclaration"}, {"full_name": "OneOneEquiv.symm", "code": "@[symm]\ntheorem OneOneEquiv.symm {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} :\n    OneOneEquiv p q \u2192 OneOneEquiv q p", "start": [185, 1], "end": [188, 11], "kind": "commanddeclaration"}, {"full_name": "OneOneEquiv.trans", "code": "@[trans]\ntheorem OneOneEquiv.trans {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] {p : \u03b1 \u2192 Prop}\n    {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} : OneOneEquiv p q \u2192 OneOneEquiv q r \u2192 OneOneEquiv p r", "start": [191, 1], "end": [194, 53], "kind": "commanddeclaration"}, {"full_name": "equivalence_of_oneOneEquiv", "code": "theorem equivalence_of_oneOneEquiv {\u03b1} [Primcodable \u03b1] : Equivalence (@OneOneEquiv \u03b1 \u03b1 _ _)", "start": [197, 1], "end": [198, 86], "kind": "commanddeclaration"}, {"full_name": "OneOneEquiv.to_many_one", "code": "theorem OneOneEquiv.to_many_one {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {p : \u03b1 \u2192 Prop}\n    {q : \u03b2 \u2192 Prop} : OneOneEquiv p q \u2192 ManyOneEquiv p q", "start": [201, 1], "end": [203, 49], "kind": "commanddeclaration"}, {"full_name": "Equiv.Computable", "code": "nonrec def Equiv.Computable {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] (e : \u03b1 \u2243 \u03b2) :=\n  Computable e \u2227 Computable e.symm", "start": [206, 1], "end": [208, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Computable.symm", "code": "theorem Equiv.Computable.symm {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {e : \u03b1 \u2243 \u03b2} :\n    e.Computable \u2192 e.symm.Computable", "start": [211, 1], "end": [213, 11], "kind": "commanddeclaration"}, {"full_name": "Equiv.Computable.trans", "code": "theorem Equiv.Computable.trans {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] {e\u2081 : \u03b1 \u2243 \u03b2}\n    {e\u2082 : \u03b2 \u2243 \u03b3} : e\u2081.Computable \u2192 e\u2082.Computable \u2192 (e\u2081.trans e\u2082).Computable", "start": [216, 1], "end": [218, 51], "kind": "commanddeclaration"}, {"full_name": "Computable.eqv", "code": "theorem Computable.eqv (\u03b1) [Denumerable \u03b1] : (Denumerable.eqv \u03b1).Computable", "start": [221, 1], "end": [222, 42], "kind": "commanddeclaration"}, {"full_name": "Computable.equiv\u2082", "code": "theorem Computable.equiv\u2082 (\u03b1 \u03b2) [Denumerable \u03b1] [Denumerable \u03b2] :\n    (Denumerable.equiv\u2082 \u03b1 \u03b2).Computable", "start": [225, 1], "end": [227, 51], "kind": "commanddeclaration"}, {"full_name": "OneOneEquiv.of_equiv", "code": "theorem OneOneEquiv.of_equiv {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {e : \u03b1 \u2243 \u03b2} (h : e.Computable)\n    {p} : OneOneEquiv (p \u2218 e) p", "start": [230, 1], "end": [232, 72], "kind": "commanddeclaration"}, {"full_name": "ManyOneEquiv.of_equiv", "code": "theorem ManyOneEquiv.of_equiv {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {e : \u03b1 \u2243 \u03b2} (h : e.Computable)\n    {p} : ManyOneEquiv (p \u2218 e) p", "start": [235, 1], "end": [237, 39], "kind": "commanddeclaration"}, {"full_name": "ManyOneEquiv.le_congr_left", "code": "theorem ManyOneEquiv.le_congr_left {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3]\n    {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (h : ManyOneEquiv p q) : p \u2264\u2080 r \u2194 q \u2264\u2080 r", "start": [240, 1], "end": [242, 25], "kind": "commanddeclaration"}, {"full_name": "ManyOneEquiv.le_congr_right", "code": "theorem ManyOneEquiv.le_congr_right {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3]\n    {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (h : ManyOneEquiv q r) : p \u2264\u2080 q \u2194 p \u2264\u2080 r", "start": [245, 1], "end": [247, 51], "kind": "commanddeclaration"}, {"full_name": "OneOneEquiv.le_congr_left", "code": "theorem OneOneEquiv.le_congr_left {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3]\n    {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (h : OneOneEquiv p q) : p \u2264\u2081 r \u2194 q \u2264\u2081 r", "start": [250, 1], "end": [252, 25], "kind": "commanddeclaration"}, {"full_name": "OneOneEquiv.le_congr_right", "code": "theorem OneOneEquiv.le_congr_right {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3]\n    {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (h : OneOneEquiv q r) : p \u2264\u2081 q \u2194 p \u2264\u2081 r", "start": [255, 1], "end": [257, 51], "kind": "commanddeclaration"}, {"full_name": "ManyOneEquiv.congr_left", "code": "theorem ManyOneEquiv.congr_left {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3]\n    {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (h : ManyOneEquiv p q) :\n    ManyOneEquiv p r \u2194 ManyOneEquiv q r", "start": [260, 1], "end": [263, 45], "kind": "commanddeclaration"}, {"full_name": "ManyOneEquiv.congr_right", "code": "theorem ManyOneEquiv.congr_right {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3]\n    {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (h : ManyOneEquiv q r) :\n    ManyOneEquiv p q \u2194 ManyOneEquiv p r", "start": [266, 1], "end": [269, 45], "kind": "commanddeclaration"}, {"full_name": "OneOneEquiv.congr_left", "code": "theorem OneOneEquiv.congr_left {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3]\n    {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (h : OneOneEquiv p q) :\n    OneOneEquiv p r \u2194 OneOneEquiv q r", "start": [272, 1], "end": [275, 45], "kind": "commanddeclaration"}, {"full_name": "OneOneEquiv.congr_right", "code": "theorem OneOneEquiv.congr_right {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3]\n    {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (h : OneOneEquiv q r) :\n    OneOneEquiv p q \u2194 OneOneEquiv p r", "start": [278, 1], "end": [281, 45], "kind": "commanddeclaration"}, {"full_name": "ULower.down_computable", "code": "@[simp]\ntheorem ULower.down_computable {\u03b1} [Primcodable \u03b1] : (ULower.equiv \u03b1).Computable", "start": [284, 1], "end": [286, 59], "kind": "commanddeclaration"}, {"full_name": "manyOneEquiv_up", "code": "theorem manyOneEquiv_up {\u03b1} [Primcodable \u03b1] {p : \u03b1 \u2192 Prop} : ManyOneEquiv (p \u2218 ULower.up) p", "start": [289, 1], "end": [290, 52], "kind": "commanddeclaration"}, {"full_name": "OneOneReducible.disjoin_left", "code": "theorem OneOneReducible.disjoin_left {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {p : \u03b1 \u2192 Prop}\n    {q : \u03b2 \u2192 Prop} : p \u2264\u2081 p \u2295' q", "start": [298, 1], "end": [300, 80], "kind": "commanddeclaration"}, {"full_name": "OneOneReducible.disjoin_right", "code": "theorem OneOneReducible.disjoin_right {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {p : \u03b1 \u2192 Prop}\n    {q : \u03b2 \u2192 Prop} : q \u2264\u2081 p \u2295' q", "start": [303, 1], "end": [305, 80], "kind": "commanddeclaration"}, {"full_name": "disjoin_manyOneReducible", "code": "theorem disjoin_manyOneReducible {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3]\n    {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} : p \u2264\u2080 r \u2192 q \u2264\u2080 r \u2192 (p \u2295' q) \u2264\u2080 r", "start": [308, 1], "end": [313, 52], "kind": "commanddeclaration"}, {"full_name": "disjoin_le", "code": "theorem disjoin_le {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] {p : \u03b1 \u2192 Prop}\n    {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} : (p \u2295' q) \u2264\u2080 r \u2194 p \u2264\u2080 r \u2227 q \u2264\u2080 r", "start": [316, 1], "end": [321, 52], "kind": "commanddeclaration"}, {"full_name": "toNat", "code": "def toNat (p : Set \u03b1) : Set \u2115 :=\n  { n | p ((Encodable.decode (\u03b1 := \u03b1) n).getD default) }", "start": [330, 1], "end": [333, 57], "kind": "commanddeclaration"}, {"full_name": "toNat_manyOneReducible", "code": "@[simp]\ntheorem toNat_manyOneReducible {p : Set \u03b1} : toNat p \u2264\u2080 p", "start": [336, 1], "end": [339, 85], "kind": "commanddeclaration"}, {"full_name": "manyOneReducible_toNat", "code": "@[simp]\ntheorem manyOneReducible_toNat {p : Set \u03b1} : p \u2264\u2080 toNat p", "start": [342, 1], "end": [344, 64], "kind": "commanddeclaration"}, {"full_name": "manyOneReducible_toNat_toNat", "code": "@[simp]\ntheorem manyOneReducible_toNat_toNat {p : Set \u03b1} {q : Set \u03b2} : toNat p \u2264\u2080 toNat q \u2194 p \u2264\u2080 q", "start": [347, 1], "end": [350, 67], "kind": "commanddeclaration"}, {"full_name": "toNat_manyOneEquiv", "code": "@[simp]\ntheorem toNat_manyOneEquiv {p : Set \u03b1} : ManyOneEquiv (toNat p) p", "start": [353, 1], "end": [354, 92], "kind": "commanddeclaration"}, {"full_name": "manyOneEquiv_toNat", "code": "@[simp]\ntheorem manyOneEquiv_toNat (p : Set \u03b1) (q : Set \u03b2) :\n    ManyOneEquiv (toNat p) (toNat q) \u2194 ManyOneEquiv p q", "start": [357, 1], "end": [359, 82], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree", "code": "def ManyOneDegree : Type :=\n  Quotient (\u27e8ManyOneEquiv, equivalence_of_manyOneEquiv\u27e9 : Setoid (Set \u2115))", "start": [362, 1], "end": [364, 74], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.of", "code": "def of (p : \u03b1 \u2192 Prop) : ManyOneDegree :=\n  Quotient.mk'' (toNat p)", "start": [369, 1], "end": [371, 26], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.ind_on", "code": "@[elab_as_elim]\nprotected theorem ind_on {C : ManyOneDegree \u2192 Prop} (d : ManyOneDegree)\n    (h : \u2200 p : Set \u2115, C (of p)) : C d", "start": [374, 1], "end": [377, 28], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.liftOn", "code": "@[reducible] protected def liftOn {\u03c6} (d : ManyOneDegree) (f : Set \u2115 \u2192 \u03c6)\n    (h : \u2200 p q, ManyOneEquiv p q \u2192 f p = f q) : \u03c6 :=\n  Quotient.liftOn' d f h", "start": [380, 1], "end": [385, 25], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.liftOn_eq", "code": "@[simp]\nprotected theorem liftOn_eq {\u03c6} (p : Set \u2115) (f : Set \u2115 \u2192 \u03c6)\n    (h : \u2200 p q, ManyOneEquiv p q \u2192 f p = f q) : (of p).liftOn f h = f p", "start": [388, 1], "end": [391, 6], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.liftOn\u2082", "code": "@[reducible, simp] protected def liftOn\u2082 {\u03c6} (d\u2081 d\u2082 : ManyOneDegree) (f : Set \u2115 \u2192 Set \u2115 \u2192 \u03c6)\n    (h : \u2200 p\u2081 p\u2082 q\u2081 q\u2082, ManyOneEquiv p\u2081 p\u2082 \u2192 ManyOneEquiv q\u2081 q\u2082 \u2192 f p\u2081 q\u2081 = f p\u2082 q\u2082) : \u03c6 :=\n  d\u2081.liftOn (fun p => d\u2082.liftOn (f p) fun q\u2081 q\u2082 hq => h _ _ _ _ (by rfl) hq)\n    (by\n      intro p\u2081 p\u2082 hp\n      induction d\u2082 using ManyOneDegree.ind_on\n      apply h\n      assumption\n      rfl)", "start": [394, 1], "end": [405, 11], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.liftOn\u2082_eq", "code": "@[simp]\nprotected theorem liftOn\u2082_eq {\u03c6} (p q : Set \u2115) (f : Set \u2115 \u2192 Set \u2115 \u2192 \u03c6)\n    (h : \u2200 p\u2081 p\u2082 q\u2081 q\u2082, ManyOneEquiv p\u2081 p\u2082 \u2192 ManyOneEquiv q\u2081 q\u2082 \u2192 f p\u2081 q\u2081 = f p\u2082 q\u2082) :\n    (of p).liftOn\u2082 (of q) f h = f p q", "start": [408, 1], "end": [412, 6], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.of_eq_of", "code": "@[simp]\ntheorem of_eq_of {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} : of p = of q \u2194 ManyOneEquiv p q", "start": [415, 1], "end": [419, 7], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.instInhabited", "code": "instance instInhabited : Inhabited ManyOneDegree :=\n  \u27e8of (\u2205 : Set \u2115)\u27e9", "start": [422, 1], "end": [423, 19], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.instLE", "code": "instance instLE : LE ManyOneDegree :=\n  \u27e8fun d\u2081 d\u2082 =>\n    ManyOneDegree.liftOn\u2082 d\u2081 d\u2082 (\u00b7 \u2264\u2080 \u00b7) fun _p\u2081 _p\u2082 _q\u2081 _q\u2082 hp hq =>\n      propext (hp.le_congr_left.trans hq.le_congr_right)\u27e9", "start": [426, 1], "end": [432, 58], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.of_le_of", "code": "@[simp]\ntheorem of_le_of {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} : of p \u2264 of q \u2194 p \u2264\u2080 q", "start": [435, 1], "end": [437, 31], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.le_refl", "code": "private theorem le_refl (d : ManyOneDegree) : d \u2264 d", "start": [440, 1], "end": [441, 52], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.le_antisymm", "code": "private theorem le_antisymm {d\u2081 d\u2082 : ManyOneDegree} : d\u2081 \u2264 d\u2082 \u2192 d\u2082 \u2264 d\u2081 \u2192 d\u2081 = d\u2082", "start": [443, 1], "end": [447, 65], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.le_trans", "code": "private theorem le_trans {d\u2081 d\u2082 d\u2083 : ManyOneDegree} : d\u2081 \u2264 d\u2082 \u2192 d\u2082 \u2264 d\u2083 \u2192 d\u2081 \u2264 d\u2083", "start": [449, 1], "end": [453, 31], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.instPartialOrder", "code": "instance instPartialOrder : PartialOrder ManyOneDegree where\n  le := (\u00b7 \u2264 \u00b7)\n  le_refl := le_refl\n  le_trans _ _ _ := le_trans\n  le_antisymm _ _ := le_antisymm", "start": [455, 1], "end": [459, 33], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.instAdd", "code": "instance instAdd : Add ManyOneDegree :=\n  \u27e8fun d\u2081 d\u2082 =>\n    d\u2081.liftOn\u2082 d\u2082 (fun a b => of (a \u2295' b))\n      (by\n        rintro a b c d \u27e8hl\u2081, hr\u2081\u27e9 \u27e8hl\u2082, hr\u2082\u27e9\n        rw [of_eq_of]\n        exact\n          \u27e8disjoin_manyOneReducible (hl\u2081.trans OneOneReducible.disjoin_left.to_many_one)\n              (hl\u2082.trans OneOneReducible.disjoin_right.to_many_one),\n            disjoin_manyOneReducible (hr\u2081.trans OneOneReducible.disjoin_left.to_many_one)\n              (hr\u2082.trans OneOneReducible.disjoin_right.to_many_one)\u27e9)\u27e9", "start": [462, 1], "end": [473, 71], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.add_of", "code": "@[simp]\ntheorem add_of (p : Set \u03b1) (q : Set \u03b2) : of (p \u2295' q) = of p + of q", "start": [476, 1], "end": [484, 82], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.add_le", "code": "@[simp]\nprotected theorem add_le {d\u2081 d\u2082 d\u2083 : ManyOneDegree} : d\u2081 + d\u2082 \u2264 d\u2083 \u2194 d\u2081 \u2264 d\u2083 \u2227 d\u2082 \u2264 d\u2083", "start": [487, 1], "end": [492, 51], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.le_add_left", "code": "@[simp]\nprotected theorem le_add_left (d\u2081 d\u2082 : ManyOneDegree) : d\u2081 \u2264 d\u2081 + d\u2082", "start": [495, 1], "end": [497, 38], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.le_add_right", "code": "@[simp]\nprotected theorem le_add_right (d\u2081 d\u2082 : ManyOneDegree) : d\u2082 \u2264 d\u2081 + d\u2082", "start": [500, 1], "end": [502, 38], "kind": "commanddeclaration"}, {"full_name": "ManyOneDegree.instSemilatticeSup", "code": "instance instSemilatticeSup : SemilatticeSup ManyOneDegree :=\n  { ManyOneDegree.instPartialOrder with\n    sup := (\u00b7 + \u00b7)\n    le_sup_left := ManyOneDegree.le_add_left\n    le_sup_right := ManyOneDegree.le_add_right\n    sup_le := fun _ _ _ h\u2081 h\u2082 => ManyOneDegree.add_le.2 \u27e8h\u2081, h\u2082\u27e9 }", "start": [505, 1], "end": [510, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Buffer/Parser/Numeral.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/NumberTheory/SumFourSquares.lean", "imports": ["Mathlib/Data/Int/Parity.lean", "Mathlib/Algebra/GroupPower/Identities.lean", "Mathlib/Data/ZMod/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/FieldTheory/Finite/Basic.lean"], "premises": [{"full_name": "euler_four_squares", "code": "theorem euler_four_squares {R : Type*} [CommRing R] (a b c d x y z w : R) :\n    (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 +\n      (a * z - b * w + c * x + d * y) ^ 2 + (a * w + b * z - c * y + d * x) ^ 2 =\n      (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)", "start": [32, 1], "end": [36, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.euler_four_squares", "code": "theorem Nat.euler_four_squares (a b c d x y z w : \u2115) :\n    ((a : \u2124) * x - b * y - c * z - d * w).natAbs ^ 2 +\n      ((a : \u2124) * y + b * x + c * w - d * z).natAbs ^ 2 +\n      ((a : \u2124) * z - b * w + c * x + d * y).natAbs ^ 2 +\n      ((a : \u2124) * w + b * z - c * y + d * x).natAbs ^ 2 =\n      (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)", "start": [38, 1], "end": [47, 48], "kind": "commanddeclaration"}, {"full_name": "Int.sq_add_sq_of_two_mul_sq_add_sq", "code": "theorem sq_add_sq_of_two_mul_sq_add_sq {m x y : \u2124} (h : 2 * m = x ^ 2 + y ^ 2) :\n    m = ((x - y) / 2) ^ 2 + ((x + y) / 2) ^ 2", "start": [51, 1], "end": [63, 69], "kind": "commanddeclaration"}, {"full_name": "Int.lt_of_sum_four_squares_eq_mul", "code": "theorem lt_of_sum_four_squares_eq_mul {a b c d k m : \u2115}\n    (h : a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = k * m)\n    (ha : 2 * a < m) (hb : 2 * b < m) (hc : 2 * c < m) (hd : 2 * d < m) :\n    k < m", "start": [67, 1], "end": [78, 41], "kind": "commanddeclaration"}, {"full_name": "Int.exists_sq_add_sq_add_one_eq_mul", "code": "theorem exists_sq_add_sq_add_one_eq_mul (p : \u2115) [hp : Fact p.Prime] :\n    \u2203 (a b k : \u2115), 0 < k \u2227 k < p \u2227 a ^ 2 + b ^ 2 + 1 = k * p", "start": [81, 1], "end": [100, 19], "kind": "commanddeclaration"}, {"full_name": "Int.exists_sq_add_sq_add_one_eq_k", "code": "@[deprecated exists_sq_add_sq_add_one_eq_mul]\ntheorem exists_sq_add_sq_add_one_eq_k (p : \u2115) [Fact p.Prime] :\n    \u2203 (a b : \u2124) (k : \u2115), a ^ 2 + b ^ 2 + 1 = k * p \u2227 k < p", "start": [102, 1], "end": [106, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_four_squares_of_two_mul_sum_four_squares", "code": "private theorem sum_four_squares_of_two_mul_sum_four_squares {m a b c d : \u2124}\n    (h : a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = 2 * m) :\n    \u2203 w x y z : \u2124, w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 = m", "start": [117, 1], "end": [140, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.sum_four_squares", "code": "protected theorem Prime.sum_four_squares {p : \u2115} (hp : p.Prime) :\n    \u2203 a b c d : \u2115, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p", "start": [142, 1], "end": [223, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_four_squares", "code": "theorem sum_four_squares (n : \u2115) : \u2203 a b c d : \u2115, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n", "start": [225, 1], "end": [236, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Euclidean/MongePoint.lean", "imports": ["Mathlib/Geometry/Euclidean/Circumcenter.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Affine.Simplex.mongePoint", "code": "def mongePoint {n : \u2115} (s : Simplex \u211d P n) : P :=\n  (((n + 1 : \u2115) : \u211d) / ((n - 1 : \u2115) : \u211d)) \u2022\n      ((univ : Finset (Fin (n + 1))).centroid \u211d s.points -\u1d65 s.circumcenter) +\u1d65\n    s.circumcenter", "start": [69, 1], "end": [84, 19], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mongePoint_eq_smul_vsub_vadd_circumcenter", "code": "theorem mongePoint_eq_smul_vsub_vadd_circumcenter {n : \u2115} (s : Simplex \u211d P n) :\n    s.mongePoint =\n      (((n + 1 : \u2115) : \u211d) / ((n - 1 : \u2115) : \u211d)) \u2022\n          ((univ : Finset (Fin (n + 1))).centroid \u211d s.points -\u1d65 s.circumcenter) +\u1d65\n        s.circumcenter", "start": [87, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mongePoint_mem_affineSpan", "code": "theorem mongePoint_mem_affineSpan {n : \u2115} (s : Simplex \u211d P n) :\n    s.mongePoint \u2208 affineSpan \u211d (Set.range s.points)", "start": [97, 1], "end": [101, 64], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mongePoint_eq_of_range_eq", "code": "theorem mongePoint_eq_of_range_eq {n : \u2115} {s\u2081 s\u2082 : Simplex \u211d P n}\n    (h : Set.range s\u2081.points = Set.range s\u2082.points) : s\u2081.mongePoint = s\u2082.mongePoint", "start": [104, 1], "end": [108, 35], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mongePointWeightsWithCircumcenter", "code": "def mongePointWeightsWithCircumcenter (n : \u2115) : PointsWithCircumcenterIndex (n + 2) \u2192 \u211d\n  | point_index _ => ((n + 1 : \u2115) : \u211d)\u207b\u00b9\n  | circumcenter_index => -2 / ((n + 1 : \u2115) : \u211d)", "start": [111, 1], "end": [115, 49], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.sum_mongePointWeightsWithCircumcenter", "code": "@[simp]\ntheorem sum_mongePointWeightsWithCircumcenter (n : \u2115) :\n    \u2211 i, mongePointWeightsWithCircumcenter n i = 1", "start": [118, 1], "end": [127, 7], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mongePoint_eq_affineCombination_of_pointsWithCircumcenter", "code": "theorem mongePoint_eq_affineCombination_of_pointsWithCircumcenter {n : \u2115}\n    (s : Simplex \u211d P (n + 2)) :\n    s.mongePoint =\n      (univ : Finset (PointsWithCircumcenterIndex (n + 2))).affineCombination \u211d\n        s.pointsWithCircumcenter (mongePointWeightsWithCircumcenter n)", "start": [130, 1], "end": [156, 9], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mongePointVSubFaceCentroidWeightsWithCircumcenter", "code": "def mongePointVSubFaceCentroidWeightsWithCircumcenter {n : \u2115} (i\u2081 i\u2082 : Fin (n + 3)) :\n    PointsWithCircumcenterIndex (n + 2) \u2192 \u211d\n  | point_index i => if i = i\u2081 \u2228 i = i\u2082 then ((n + 1 : \u2115) : \u211d)\u207b\u00b9 else 0\n  | circumcenter_index => -2 / ((n + 1 : \u2115) : \u211d)", "start": [159, 1], "end": [165, 49], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mongePointVSubFaceCentroidWeightsWithCircumcenter_eq_sub", "code": "theorem mongePointVSubFaceCentroidWeightsWithCircumcenter_eq_sub {n : \u2115} {i\u2081 i\u2082 : Fin (n + 3)}\n    (h : i\u2081 \u2260 i\u2082) :\n    mongePointVSubFaceCentroidWeightsWithCircumcenter i\u2081 i\u2082 =\n      mongePointWeightsWithCircumcenter n - centroidWeightsWithCircumcenter {i\u2081, i\u2082}\u1d9c", "start": [168, 1], "end": [184, 57], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.sum_mongePointVSubFaceCentroidWeightsWithCircumcenter", "code": "@[simp]\ntheorem sum_mongePointVSubFaceCentroidWeightsWithCircumcenter {n : \u2115} {i\u2081 i\u2082 : Fin (n + 3)}\n    (h : i\u2081 \u2260 i\u2082) : \u2211 i, mongePointVSubFaceCentroidWeightsWithCircumcenter i\u2081 i\u2082 i = 0", "start": [187, 1], "end": [194, 35], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mongePoint_vsub_face_centroid_eq_weightedVSub_of_pointsWithCircumcenter", "code": "theorem mongePoint_vsub_face_centroid_eq_weightedVSub_of_pointsWithCircumcenter {n : \u2115}\n    (s : Simplex \u211d P (n + 2)) {i\u2081 i\u2082 : Fin (n + 3)} (h : i\u2081 \u2260 i\u2082) :\n    s.mongePoint -\u1d65 ({i\u2081, i\u2082}\u1d9c : Finset (Fin (n + 3))).centroid \u211d s.points =\n      (univ : Finset (PointsWithCircumcenterIndex (n + 2))).weightedVSub s.pointsWithCircumcenter\n        (mongePointVSubFaceCentroidWeightsWithCircumcenter i\u2081 i\u2082)", "start": [197, 1], "end": [206, 64], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.inner_mongePoint_vsub_face_centroid_vsub", "code": "theorem inner_mongePoint_vsub_face_centroid_vsub {n : \u2115} (s : Simplex \u211d P (n + 2))\n    {i\u2081 i\u2082 : Fin (n + 3)} :\n    \u27eas.mongePoint -\u1d65 ({i\u2081, i\u2082}\u1d9c : Finset (Fin (n + 3))).centroid \u211d s.points,\n        s.points i\u2081 -\u1d65 s.points i\u2082\u27eb =\n      0", "start": [209, 1], "end": [242, 20], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mongePlane", "code": "def mongePlane {n : \u2115} (s : Simplex \u211d P (n + 2)) (i\u2081 i\u2082 : Fin (n + 3)) : AffineSubspace \u211d P :=\n  mk' (({i\u2081, i\u2082}\u1d9c : Finset (Fin (n + 3))).centroid \u211d s.points) (\u211d \u2219 s.points i\u2081 -\u1d65 s.points i\u2082)\u15ee \u2293\n    affineSpan \u211d (Set.range s.points)", "start": [245, 1], "end": [252, 38], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mongePlane_def", "code": "theorem mongePlane_def {n : \u2115} (s : Simplex \u211d P (n + 2)) (i\u2081 i\u2082 : Fin (n + 3)) :\n    s.mongePlane i\u2081 i\u2082 =\n      mk' (({i\u2081, i\u2082}\u1d9c : Finset (Fin (n + 3))).centroid \u211d s.points)\n          (\u211d \u2219 s.points i\u2081 -\u1d65 s.points i\u2082)\u15ee \u2293\n        affineSpan \u211d (Set.range s.points)", "start": [255, 1], "end": [261, 6], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mongePlane_comm", "code": "theorem mongePlane_comm {n : \u2115} (s : Simplex \u211d P (n + 2)) (i\u2081 i\u2082 : Fin (n + 3)) :\n    s.mongePlane i\u2081 i\u2082 = s.mongePlane i\u2082 i\u2081", "start": [264, 1], "end": [275, 87], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mongePoint_mem_mongePlane", "code": "theorem mongePoint_mem_mongePlane {n : \u2115} (s : Simplex \u211d P (n + 2)) {i\u2081 i\u2082 : Fin (n + 3)} :\n    s.mongePoint \u2208 s.mongePlane i\u2081 i\u2082", "start": [278, 1], "end": [286, 78], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.direction_mongePlane", "code": "theorem direction_mongePlane {n : \u2115} (s : Simplex \u211d P (n + 2)) {i\u2081 i\u2082 : Fin (n + 3)} :\n    (s.mongePlane i\u2081 i\u2082).direction =\n      (\u211d \u2219 s.points i\u2081 -\u1d65 s.points i\u2082)\u15ee \u2293 vectorSpan \u211d (Set.range s.points)", "start": [289, 1], "end": [294, 26], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.eq_mongePoint_of_forall_mem_mongePlane", "code": "theorem eq_mongePoint_of_forall_mem_mongePlane {n : \u2115} {s : Simplex \u211d P (n + 2)} {i\u2081 : Fin (n + 3)}\n    {p : P} (h : \u2200 i\u2082, i\u2081 \u2260 i\u2082 \u2192 p \u2208 s.mongePlane i\u2081 i\u2082) : p = s.mongePoint", "start": [297, 1], "end": [329, 97], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.altitude", "code": "def altitude {n : \u2115} (s : Simplex \u211d P (n + 1)) (i : Fin (n + 2)) : AffineSubspace \u211d P :=\n  mk' (s.points i) (affineSpan \u211d (s.points '' \u2191(univ.erase i))).direction\u15ee \u2293\n    affineSpan \u211d (Set.range s.points)", "start": [332, 1], "end": [336, 38], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.altitude_def", "code": "theorem altitude_def {n : \u2115} (s : Simplex \u211d P (n + 1)) (i : Fin (n + 2)) :\n    s.altitude i =\n      mk' (s.points i) (affineSpan \u211d (s.points '' \u2191(univ.erase i))).direction\u15ee \u2293\n        affineSpan \u211d (Set.range s.points)", "start": [339, 1], "end": [344, 6], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mem_altitude", "code": "theorem mem_altitude {n : \u2115} (s : Simplex \u211d P (n + 1)) (i : Fin (n + 2)) :\n    s.points i \u2208 s.altitude i", "start": [347, 1], "end": [350, 84], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.direction_altitude", "code": "theorem direction_altitude {n : \u2115} (s : Simplex \u211d P (n + 1)) (i : Fin (n + 2)) :\n    (s.altitude i).direction =\n      (vectorSpan \u211d (s.points '' \u2191(Finset.univ.erase i)))\u15ee \u2293 vectorSpan \u211d (Set.range s.points)", "start": [353, 1], "end": [359, 63], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.vectorSpan_isOrtho_altitude_direction", "code": "theorem vectorSpan_isOrtho_altitude_direction {n : \u2115} (s : Simplex \u211d P (n + 1)) (i : Fin (n + 2)) :\n    vectorSpan \u211d (s.points '' \u2191(Finset.univ.erase i)) \u27c2 (s.altitude i).direction", "start": [362, 1], "end": [367, 70], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.finiteDimensional_direction_altitude", "code": "instance finiteDimensional_direction_altitude {n : \u2115} (s : Simplex \u211d P (n + 1)) (i : Fin (n + 2)) :\n    FiniteDimensional \u211d (s.altitude i).direction := by\n  rw [direction_altitude]\n  infer_instance", "start": [372, 1], "end": [376, 17], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.finrank_direction_altitude", "code": "@[simp]\ntheorem finrank_direction_altitude {n : \u2115} (s : Simplex \u211d P (n + 1)) (i : Fin (n + 2)) :\n    finrank \u211d (s.altitude i).direction = 1", "start": [379, 1], "end": [389, 54], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.affineSpan_pair_eq_altitude_iff", "code": "theorem affineSpan_pair_eq_altitude_iff {n : \u2115} (s : Simplex \u211d P (n + 1)) (i : Fin (n + 2))\n    (p : P) :\n    line[\u211d, p, s.points i] = s.altitude i \u2194\n      p \u2260 s.points i \u2227\n        p \u2208 affineSpan \u211d (Set.range s.points) \u2227\n          p -\u1d65 s.points i \u2208 (affineSpan \u211d (s.points '' \u2191(Finset.univ.erase i))).direction\u15ee", "start": [392, 1], "end": [425, 24], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.orthocenter", "code": "def orthocenter (t : Triangle \u211d P) : P :=\n  t.mongePoint", "start": [437, 1], "end": [441, 15], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.orthocenter_eq_mongePoint", "code": "theorem orthocenter_eq_mongePoint (t : Triangle \u211d P) : t.orthocenter = t.mongePoint", "start": [444, 1], "end": [446, 6], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.orthocenter_eq_smul_vsub_vadd_circumcenter", "code": "theorem orthocenter_eq_smul_vsub_vadd_circumcenter (t : Triangle \u211d P) :\n    t.orthocenter =\n      (3 : \u211d) \u2022 ((univ : Finset (Fin 3)).centroid \u211d t.points -\u1d65 t.circumcenter : V) +\u1d65\n        t.circumcenter", "start": [449, 1], "end": [456, 11], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.orthocenter_mem_affineSpan", "code": "theorem orthocenter_mem_affineSpan (t : Triangle \u211d P) :\n    t.orthocenter \u2208 affineSpan \u211d (Set.range t.points)", "start": [459, 1], "end": [462, 30], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.orthocenter_eq_of_range_eq", "code": "theorem orthocenter_eq_of_range_eq {t\u2081 t\u2082 : Triangle \u211d P}\n    (h : Set.range t\u2081.points = Set.range t\u2082.points) : t\u2081.orthocenter = t\u2082.orthocenter", "start": [465, 1], "end": [468, 30], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.altitude_eq_mongePlane", "code": "theorem altitude_eq_mongePlane (t : Triangle \u211d P) {i\u2081 i\u2082 i\u2083 : Fin 3} (h\u2081\u2082 : i\u2081 \u2260 i\u2082) (h\u2081\u2083 : i\u2081 \u2260 i\u2083)\n    (h\u2082\u2083 : i\u2082 \u2260 i\u2083) : t.altitude i\u2081 = t.mongePlane i\u2082 i\u2083", "start": [471, 1], "end": [486, 50], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.orthocenter_mem_altitude", "code": "theorem orthocenter_mem_altitude (t : Triangle \u211d P) {i\u2081 : Fin 3} :\n    t.orthocenter \u2208 t.altitude i\u2081", "start": [489, 1], "end": [496, 36], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.eq_orthocenter_of_forall_mem_altitude", "code": "theorem eq_orthocenter_of_forall_mem_altitude {t : Triangle \u211d P} {i\u2081 i\u2082 : Fin 3} {p : P}\n    (h\u2081\u2082 : i\u2081 \u2260 i\u2082) (h\u2081 : p \u2208 t.altitude i\u2081) (h\u2082 : p \u2208 t.altitude i\u2082) : p = t.orthocenter", "start": [499, 1], "end": [519, 50], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.dist_orthocenter_reflection_circumcenter", "code": "theorem dist_orthocenter_reflection_circumcenter (t : Triangle \u211d P) {i\u2081 i\u2082 : Fin 3} (h : i\u2081 \u2260 i\u2082) :\n    dist t.orthocenter (reflection (affineSpan \u211d (t.points '' {i\u2081, i\u2082})) t.circumcenter) =\n      t.circumradius", "start": [522, 1], "end": [548, 11], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.dist_orthocenter_reflection_circumcenter_finset", "code": "theorem dist_orthocenter_reflection_circumcenter_finset (t : Triangle \u211d P) {i\u2081 i\u2082 : Fin 3}\n    (h : i\u2081 \u2260 i\u2082) :\n    dist t.orthocenter\n        (reflection (affineSpan \u211d (t.points '' \u2191({i\u2081, i\u2082} : Finset (Fin 3)))) t.circumcenter) =\n      t.circumradius", "start": [551, 1], "end": [560, 53], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.affineSpan_orthocenter_point_le_altitude", "code": "theorem affineSpan_orthocenter_point_le_altitude (t : Triangle \u211d P) (i : Fin 3) :\n    line[\u211d, t.orthocenter, t.points i] \u2264 t.altitude i", "start": [563, 1], "end": [569, 55], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.altitude_replace_orthocenter_eq_affineSpan", "code": "theorem altitude_replace_orthocenter_eq_affineSpan {t\u2081 t\u2082 : Triangle \u211d P}\n    {i\u2081 i\u2082 i\u2083 j\u2081 j\u2082 j\u2083 : Fin 3} (hi\u2081\u2082 : i\u2081 \u2260 i\u2082) (hi\u2081\u2083 : i\u2081 \u2260 i\u2083) (hi\u2082\u2083 : i\u2082 \u2260 i\u2083) (hj\u2081\u2082 : j\u2081 \u2260 j\u2082)\n    (hj\u2081\u2083 : j\u2081 \u2260 j\u2083) (hj\u2082\u2083 : j\u2082 \u2260 j\u2083) (h\u2081 : t\u2082.points j\u2081 = t\u2081.orthocenter)\n    (h\u2082 : t\u2082.points j\u2082 = t\u2081.points i\u2082) (h\u2083 : t\u2082.points j\u2083 = t\u2081.points i\u2083) :\n    t\u2082.altitude j\u2082 = line[\u211d, t\u2081.points i\u2081, t\u2081.points i\u2082]", "start": [572, 1], "end": [617, 101], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.orthocenter_replace_orthocenter_eq_point", "code": "theorem orthocenter_replace_orthocenter_eq_point {t\u2081 t\u2082 : Triangle \u211d P} {i\u2081 i\u2082 i\u2083 j\u2081 j\u2082 j\u2083 : Fin 3}\n    (hi\u2081\u2082 : i\u2081 \u2260 i\u2082) (hi\u2081\u2083 : i\u2081 \u2260 i\u2083) (hi\u2082\u2083 : i\u2082 \u2260 i\u2083) (hj\u2081\u2082 : j\u2081 \u2260 j\u2082) (hj\u2081\u2083 : j\u2081 \u2260 j\u2083)\n    (hj\u2082\u2083 : j\u2082 \u2260 j\u2083) (h\u2081 : t\u2082.points j\u2081 = t\u2081.orthocenter) (h\u2082 : t\u2082.points j\u2082 = t\u2081.points i\u2082)\n    (h\u2083 : t\u2082.points j\u2083 = t\u2081.points i\u2083) : t\u2082.orthocenter = t\u2081.points i\u2081", "start": [620, 1], "end": [632, 48], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.OrthocentricSystem", "code": "def OrthocentricSystem (s : Set P) : Prop :=\n  \u2203 t : Triangle \u211d P,\n    t.orthocenter \u2209 Set.range t.points \u2227 s = insert t.orthocenter (Set.range t.points)", "start": [646, 1], "end": [650, 87], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.exists_of_range_subset_orthocentricSystem", "code": "theorem exists_of_range_subset_orthocentricSystem {t : Triangle \u211d P}\n    (ho : t.orthocenter \u2209 Set.range t.points) {p : Fin 3 \u2192 P}\n    (hps : Set.range p \u2286 insert t.orthocenter (Set.range t.points)) (hpi : Function.Injective p) :\n    (\u2203 i\u2081 i\u2082 i\u2083 j\u2082 j\u2083 : Fin 3,\n      i\u2081 \u2260 i\u2082 \u2227 i\u2081 \u2260 i\u2083 \u2227 i\u2082 \u2260 i\u2083 \u2227 (\u2200 i : Fin 3, i = i\u2081 \u2228 i = i\u2082 \u2228 i = i\u2083) \u2227\n        p i\u2081 = t.orthocenter \u2227 j\u2082 \u2260 j\u2083 \u2227 t.points j\u2082 = p i\u2082 \u2227 t.points j\u2083 = p i\u2083) \u2228\n      Set.range p = Set.range t.points", "start": [653, 1], "end": [691, 94], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.exists_dist_eq_circumradius_of_subset_insert_orthocenter", "code": "theorem exists_dist_eq_circumradius_of_subset_insert_orthocenter {t : Triangle \u211d P}\n    (ho : t.orthocenter \u2209 Set.range t.points) {p : Fin 3 \u2192 P}\n    (hps : Set.range p \u2286 insert t.orthocenter (Set.range t.points)) (hpi : Function.Injective p) :\n    \u2203 c \u2208 affineSpan \u211d (Set.range t.points), \u2200 p\u2081 \u2208 Set.range p, dist p\u2081 c = t.circumradius", "start": [694, 1], "end": [723, 48], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.OrthocentricSystem.affineIndependent", "code": "theorem OrthocentricSystem.affineIndependent {s : Set P} (ho : OrthocentricSystem s) {p : Fin 3 \u2192 P}\n    (hps : Set.range p \u2286 s) (hpi : Function.Injective p) : AffineIndependent \u211d p", "start": [726, 1], "end": [732, 81], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.affineSpan_of_orthocentricSystem", "code": "theorem affineSpan_of_orthocentricSystem {s : Set P} (ho : OrthocentricSystem s) {p : Fin 3 \u2192 P}\n    (hps : Set.range p \u2286 s) (hpi : Function.Injective p) :\n    affineSpan \u211d (Set.range p) = affineSpan \u211d s", "start": [735, 1], "end": [750, 59], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.OrthocentricSystem.exists_circumradius_eq", "code": "theorem OrthocentricSystem.exists_circumradius_eq {s : Set P} (ho : OrthocentricSystem s) :\n    \u2203 r : \u211d, \u2200 t : Triangle \u211d P, Set.range t.points \u2286 s \u2192 t.circumradius = r", "start": [753, 1], "end": [770, 50], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.OrthocentricSystem.eq_insert_orthocenter", "code": "theorem OrthocentricSystem.eq_insert_orthocenter {s : Set P} (ho : OrthocentricSystem s)\n    {t : Triangle \u211d P} (ht : Set.range t.points \u2286 s) :\n    s = insert t.orthocenter (Set.range t.points)", "start": [773, 1], "end": [798, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/QPF/Multivariate/Constructions/Cofix.lean", "imports": ["Mathlib/Data/PFunctor/Multivariate/Basic.lean", "Mathlib/Data/PFunctor/Multivariate/M.lean", "Mathlib/Data/QPF/Multivariate/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Control/Functor/Multivariate.lean"], "premises": [{"full_name": "MvQPF.corecF", "code": "def corecF {\u03b1 : TypeVec n} {\u03b2 : Type u} (g : \u03b2 \u2192 F (\u03b1.append1 \u03b2)) : \u03b2 \u2192 q.P.M \u03b1 :=\n  M.corec _ fun x => repr (g x)", "start": [56, 1], "end": [60, 32], "kind": "commanddeclaration"}, {"full_name": "MvQPF.corecF_eq", "code": "theorem corecF_eq {\u03b1 : TypeVec n} {\u03b2 : Type u} (g : \u03b2 \u2192 F (\u03b1.append1 \u03b2)) (x : \u03b2) :\n    M.dest q.P (corecF g x) = appendFun id (corecF g) <$$> repr (g x)", "start": [64, 1], "end": [66, 28], "kind": "commanddeclaration"}, {"full_name": "MvQPF.IsPrecongr", "code": "def IsPrecongr {\u03b1 : TypeVec n} (r : q.P.M \u03b1 \u2192 q.P.M \u03b1 \u2192 Prop) : Prop :=\n  \u2200 \u2983x y\u2984,\n    r x y \u2192\n      abs (appendFun id (Quot.mk r) <$$> M.dest q.P x) =\n        abs (appendFun id (Quot.mk r) <$$> M.dest q.P y)", "start": [70, 1], "end": [75, 57], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Mcongr", "code": "def Mcongr {\u03b1 : TypeVec n} (x y : q.P.M \u03b1) : Prop :=\n  \u2203 r, IsPrecongr r \u2227 r x y", "start": [78, 1], "end": [80, 28], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix", "code": "def Cofix (F : TypeVec (n + 1) \u2192 Type u) [MvFunctor F] [q : MvQPF F] (\u03b1 : TypeVec n) :=\n  Quot (@Mcongr _ F _ q \u03b1)", "start": [84, 1], "end": [92, 27], "kind": "commanddeclaration"}, {"full_name": "MvQPF.mRepr", "code": "def mRepr {\u03b1 : TypeVec n} : q.P.M \u03b1 \u2192 q.P.M \u03b1 :=\n  corecF (abs \u2218 M.dest q.P)", "start": [99, 1], "end": [101, 28], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.map", "code": "def Cofix.map {\u03b1 \u03b2 : TypeVec n} (g : \u03b1 \u27f9 \u03b2) : Cofix F \u03b1 \u2192 Cofix F \u03b2 :=\n  Quot.lift (fun x : q.P.M \u03b1 => Quot.mk Mcongr (g <$$> x))\n    (by\n      rintro aa\u2081 aa\u2082 \u27e8r, pr, ra\u2081a\u2082\u27e9; apply Quot.sound\n      let r' b\u2081 b\u2082 := \u2203 a\u2081 a\u2082 : q.P.M \u03b1, r a\u2081 a\u2082 \u2227 b\u2081 = g <$$> a\u2081 \u2227 b\u2082 = g <$$> a\u2082\n      use r'; constructor\n      \u00b7 show IsPrecongr r'\n        rintro b\u2081 b\u2082 \u27e8a\u2081, a\u2082, ra\u2081a\u2082, b\u2081eq, b\u2082eq\u27e9\n        let u : Quot r \u2192 Quot r' :=\n          Quot.lift (fun x : q.P.M \u03b1 => Quot.mk r' (g <$$> x))\n            (by\n              intro a\u2081 a\u2082 ra\u2081a\u2082\n              apply Quot.sound\n              exact \u27e8a\u2081, a\u2082, ra\u2081a\u2082, rfl, rfl\u27e9)\n        have hu : (Quot.mk r' \u2218 fun x : q.P.M \u03b1 => g <$$> x) = u \u2218 Quot.mk r := by\n          ext x\n          rfl\n        rw [b\u2081eq, b\u2082eq, M.dest_map, M.dest_map, \u2190 q.P.comp_map, \u2190 q.P.comp_map]\n        rw [\u2190 appendFun_comp, id_comp, hu, \u2190 comp_id g, appendFun_comp]\n        rw [q.P.comp_map, q.P.comp_map, abs_map, pr ra\u2081a\u2082, \u2190 abs_map]\n      show r' (g <$$> aa\u2081) (g <$$> aa\u2082); exact \u27e8aa\u2081, aa\u2082, ra\u2081a\u2082, rfl, rfl\u27e9)", "start": [105, 1], "end": [126, 76], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.mvfunctor", "code": "instance Cofix.mvfunctor : MvFunctor (Cofix F) where map := @Cofix.map _ _ _ _", "start": [129, 1], "end": [129, 79], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.corec", "code": "def Cofix.corec {\u03b1 : TypeVec n} {\u03b2 : Type u} (g : \u03b2 \u2192 F (\u03b1.append1 \u03b2)) : \u03b2 \u2192 Cofix F \u03b1 := fun x =>\n  Quot.mk _ (corecF g x)", "start": [132, 1], "end": [134, 25], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.dest", "code": "def Cofix.dest {\u03b1 : TypeVec n} : Cofix F \u03b1 \u2192 F (\u03b1.append1 (Cofix F \u03b1)) :=\n  Quot.lift (fun x => appendFun id (Quot.mk Mcongr) <$$> abs (M.dest q.P x))\n    (by\n      rintro x y \u27e8r, pr, rxy\u27e9\n      dsimp\n      have : \u2200 x y, r x y \u2192 Mcongr x y := by\n        intro x y h\n        exact \u27e8r, pr, h\u27e9\n      rw [\u2190 Quot.factor_mk_eq _ _ this]\n      conv =>\n        lhs\n        rw [appendFun_comp_id, comp_map, \u2190 abs_map, pr rxy, abs_map, \u2190 comp_map,\n          \u2190 appendFun_comp_id])", "start": [137, 1], "end": [150, 32], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.abs", "code": "def Cofix.abs {\u03b1} : q.P.M \u03b1 \u2192 Cofix F \u03b1 :=\n  Quot.mk _", "start": [153, 1], "end": [155, 12], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.repr", "code": "def Cofix.repr {\u03b1} : Cofix F \u03b1 \u2192 q.P.M \u03b1 :=\n  M.corec _ <| q.repr \u2218 Cofix.dest", "start": [158, 1], "end": [160, 35], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.corec'\u2081", "code": "def Cofix.corec'\u2081 {\u03b1 : TypeVec n} {\u03b2 : Type u} (g : \u2200 {X}, (\u03b2 \u2192 X) \u2192 F (\u03b1.append1 X)) (x : \u03b2) :\n    Cofix F \u03b1 :=\n  Cofix.corec (fun _ => g id) x", "start": [163, 1], "end": [166, 32], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.corec'", "code": "def Cofix.corec' {\u03b1 : TypeVec n} {\u03b2 : Type u} (g : \u03b2 \u2192 F (\u03b1.append1 (Cofix F \u03b1 \u2295 \u03b2))) (x : \u03b2) :\n    Cofix F \u03b1 :=\n  let f : (\u03b1 ::: Cofix F \u03b1) \u27f9 (\u03b1 ::: (Cofix F \u03b1 \u2295 \u03b2)) := id ::: Sum.inl\n  Cofix.corec (Sum.elim (MvFunctor.map f \u2218 Cofix.dest) g) (Sum.inr x : Cofix F \u03b1 \u2295 \u03b2)", "start": [169, 1], "end": [174, 86], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.corec\u2081", "code": "def Cofix.corec\u2081 {\u03b1 : TypeVec n} {\u03b2 : Type u}\n    (g : \u2200 {X}, (Cofix F \u03b1 \u2192 X) \u2192 (\u03b2 \u2192 X) \u2192 \u03b2 \u2192 F (\u03b1 ::: X)) (x : \u03b2) : Cofix F \u03b1 :=\n  Cofix.corec' (fun x => g Sum.inl Sum.inr x) x", "start": [177, 1], "end": [181, 48], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.dest_corec", "code": "theorem Cofix.dest_corec {\u03b1 : TypeVec n} {\u03b2 : Type u} (g : \u03b2 \u2192 F (\u03b1.append1 \u03b2)) (x : \u03b2) :\n    Cofix.dest (Cofix.corec g x) = appendFun id (Cofix.corec g) <$$> g x", "start": [184, 1], "end": [190, 71], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.mk", "code": "def Cofix.mk {\u03b1 : TypeVec n} : F (\u03b1.append1 <| Cofix F \u03b1) \u2192 Cofix F \u03b1 :=\n  Cofix.corec fun x => (appendFun id fun i : Cofix F \u03b1 => Cofix.dest.{u} i) <$$> x", "start": [193, 1], "end": [195, 83], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.bisim_aux", "code": "private theorem Cofix.bisim_aux {\u03b1 : TypeVec n} (r : Cofix F \u03b1 \u2192 Cofix F \u03b1 \u2192 Prop) (h' : \u2200 x, r x x)\n    (h : \u2200 x y, r x y \u2192\n      appendFun id (Quot.mk r) <$$> Cofix.dest x = appendFun id (Quot.mk r) <$$> Cofix.dest y) :\n    \u2200 x y, r x y \u2192 x = y", "start": [214, 1], "end": [255, 26], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.bisim_rel", "code": "theorem Cofix.bisim_rel {\u03b1 : TypeVec n} (r : Cofix F \u03b1 \u2192 Cofix F \u03b1 \u2192 Prop)\n    (h : \u2200 x y, r x y \u2192\n      appendFun id (Quot.mk r) <$$> Cofix.dest x = appendFun id (Quot.mk r) <$$> Cofix.dest y) :\n    \u2200 x y, r x y \u2192 x = y", "start": [257, 1], "end": [280, 19], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.bisim", "code": "theorem Cofix.bisim {\u03b1 : TypeVec n} (r : Cofix F \u03b1 \u2192 Cofix F \u03b1 \u2192 Prop)\n    (h : \u2200 x y, r x y \u2192 LiftR (RelLast \u03b1 r (i := _)) (Cofix.dest x) (Cofix.dest y)) :\n    \u2200 x y, r x y \u2192 x = y", "start": [283, 1], "end": [299, 17], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.bisim\u2082", "code": "theorem Cofix.bisim\u2082 {\u03b1 : TypeVec n} (r : Cofix F \u03b1 \u2192 Cofix F \u03b1 \u2192 Prop)\n    (h : \u2200 x y, r x y \u2192 LiftR' (RelLast' \u03b1 r) (Cofix.dest x) (Cofix.dest y)) :\n    \u2200 x y, r x y \u2192 x = y", "start": [304, 1], "end": [308, 76], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.bisim'", "code": "theorem Cofix.bisim' {\u03b1 : TypeVec n} {\u03b2 : Type*} (Q : \u03b2 \u2192 Prop) (u v : \u03b2 \u2192 Cofix F \u03b1)\n    (h : \u2200 x, Q x \u2192 \u2203 a f' f\u2080 f\u2081,\n      Cofix.dest (u x) = q.abs \u27e8a, q.P.appendContents f' f\u2080\u27e9 \u2227\n        Cofix.dest (v x) = q.abs \u27e8a, q.P.appendContents f' f\u2081\u27e9 \u2227\n          \u2200 i, \u2203 x', Q x' \u2227 f\u2080 i = u x' \u2227 f\u2081 i = v x') :\n    \u2200 x, Q x \u2192 u x = v x", "start": [311, 1], "end": [332, 26], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.mk_dest", "code": "theorem Cofix.mk_dest {\u03b1 : TypeVec n} (x : Cofix F \u03b1) : Cofix.mk (Cofix.dest x) = x", "start": [335, 1], "end": [352, 6], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.dest_mk", "code": "theorem Cofix.dest_mk {\u03b1 : TypeVec n} (x : F (\u03b1.append1 <| Cofix F \u03b1)) :\n    Cofix.dest (Cofix.mk x) = x", "start": [355, 1], "end": [359, 39], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.ext", "code": "theorem Cofix.ext {\u03b1 : TypeVec n} (x y : Cofix F \u03b1) (h : x.dest = y.dest) : x = y", "start": [362, 1], "end": [363, 43], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.ext_mk", "code": "theorem Cofix.ext_mk {\u03b1 : TypeVec n} (x y : F (\u03b1 ::: Cofix F \u03b1)) (h : Cofix.mk x = Cofix.mk y) :\n    x = y", "start": [366, 1], "end": [367, 57], "kind": "commanddeclaration"}, {"full_name": "MvQPF.liftR_map", "code": "theorem liftR_map {\u03b1 \u03b2 : TypeVec n} {F' : TypeVec n \u2192 Type u} [MvFunctor F'] [LawfulMvFunctor F']\n    (R : \u03b2 \u2297 \u03b2 \u27f9 \u00abrepeat\u00bb n Prop) (x : F' \u03b1) (f g : \u03b1 \u27f9 \u03b2) (h : \u03b1 \u27f9 Subtype_ R)\n    (hh : subtypeVal _ \u229a h = (f \u2297' g) \u229a prod.diag) : LiftR' R (f <$$> x) (g <$$> x)", "start": [378, 1], "end": [385, 38], "kind": "commanddeclaration"}, {"full_name": "MvQPF.liftR_map_last", "code": "theorem liftR_map_last [lawful: LawfulMvFunctor F]\n    {\u03b1 : TypeVec n} {\u03b9 \u03b9'} (R : \u03b9' \u2192 \u03b9' \u2192 Prop)\n    (x : F (\u03b1 ::: \u03b9)) (f g : \u03b9 \u2192 \u03b9') (hh : \u2200 x : \u03b9, R (f x) (g x)) :\n    LiftR' (RelLast' _ R) ((id ::: f) <$$> x) ((id ::: g) <$$> x)", "start": [390, 1], "end": [419, 67], "kind": "commanddeclaration"}, {"full_name": "MvQPF.liftR_map_last'", "code": "theorem liftR_map_last' [LawfulMvFunctor F] {\u03b1 : TypeVec n} {\u03b9} (R : \u03b9 \u2192 \u03b9 \u2192 Prop) (x : F (\u03b1 ::: \u03b9))\n    (f : \u03b9 \u2192 \u03b9) (hh : \u2200 x : \u03b9, R (f x) x) : LiftR' (RelLast' _ R) ((id ::: f) <$$> x) x", "start": [422, 1], "end": [425, 50], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.abs_repr", "code": "theorem Cofix.abs_repr {\u03b1} (x : Cofix F \u03b1) : Quot.mk _ (Cofix.repr x) = x", "start": [432, 1], "end": [448, 6], "kind": "commanddeclaration"}, {"full_name": "MvQPF.corec_roll", "code": "theorem corec_roll {\u03b1 : TypeVec n} {X Y} {x\u2080 : X} (f : X \u2192 Y) (g : Y \u2192 F (\u03b1 ::: X)) :\n    Cofix.corec (g \u2218 f) x\u2080 = Cofix.corec (MvFunctor.map (id ::: f) \u2218 g) (f x\u2080)", "start": [520, 1], "end": [526, 33], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.dest_corec'", "code": "theorem Cofix.dest_corec' {\u03b1 : TypeVec.{u} n} {\u03b2 : Type u}\n    (g : \u03b2 \u2192 F (\u03b1.append1 (Cofix F \u03b1 \u2295 \u03b2))) (x : \u03b2) :\n    Cofix.dest (Cofix.corec' g x) =\n      appendFun id (Sum.elim _root_.id (Cofix.corec' g)) <$$> g x", "start": [529, 1], "end": [545, 38], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Cofix.dest_corec\u2081", "code": "theorem Cofix.dest_corec\u2081 {\u03b1 : TypeVec n} {\u03b2 : Type u}\n    (g : \u2200 {X}, (Cofix F \u03b1 \u2192 X) \u2192 (\u03b2 \u2192 X) \u2192 \u03b2 \u2192 F (\u03b1.append1 X)) (x : \u03b2)\n    (h : \u2200 (X Y) (f : Cofix F \u03b1 \u2192 X) (f' : \u03b2 \u2192 X) (k : X \u2192 Y),\n      g (k \u2218 f) (k \u2218 f') x = (id ::: k) <$$> g f f' x) :\n    Cofix.dest (Cofix.corec\u2081 (@g) x) = g id (Cofix.corec\u2081 @g) x", "start": [548, 1], "end": [553, 49], "kind": "commanddeclaration"}, {"full_name": "MvQPF.mvqpfCofix", "code": "instance mvqpfCofix : MvQPF (Cofix F) where\n  P         := q.P.mp\n  abs       := Quot.mk Mcongr\n  repr      := Cofix.repr\n  abs_repr  := Cofix.abs_repr\n  abs_map   := by intros; rfl", "start": [556, 1], "end": [561, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/DoldKan/HomotopyEquivalence.lean", "imports": ["Mathlib/AlgebraicTopology/DoldKan/Normalized.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicTopology.DoldKan.homotopyPToId", "code": "noncomputable def homotopyPToId : \u2200 q : \u2115, Homotopy (P q : K[X] \u27f6 _) (\ud835\udfd9 _)\n  | 0 => Homotopy.refl _\n  | q + 1 => by\n    refine'\n      Homotopy.trans (Homotopy.ofEq _)\n        (Homotopy.trans\n          (Homotopy.add (homotopyPToId q) (Homotopy.compLeft (homotopyH\u03c3ToZero q) (P q)))\n          (Homotopy.ofEq _))\n    \u00b7 simp only [P_succ, comp_add, comp_id]\n    \u00b7 simp only [add_zero, comp_zero]", "start": [32, 1], "end": [42, 38], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.homotopyQToZero", "code": "def homotopyQToZero (q : \u2115) : Homotopy (Q q : K[X] \u27f6 _) 0 :=\n  Homotopy.equivSubZero.toFun (homotopyPToId X q).symm", "start": [46, 1], "end": [48, 55], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.homotopyPToId_eventually_constant", "code": "theorem homotopyPToId_eventually_constant {q n : \u2115} (hqn : n < q) :\n    ((homotopyPToId X (q + 1)).hom n (n + 1) : X _[n] \u27f6 X _[n + 1]) =\n      (homotopyPToId X q).hom n (n + 1)", "start": [52, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.homotopyPInftyToId", "code": "@[simps]\ndef homotopyPInftyToId : Homotopy (PInfty : K[X] \u27f6 _) (\ud835\udfd9 _) where\n  hom i j := (homotopyPToId X (j + 1)).hom i j\n  zero i j hij := Homotopy.zero _ i j hij\n  comm n := by\n    rcases n with _|n\n    \u00b7 simpa only [Homotopy.dNext_zero_chainComplex, Homotopy.prevD_chainComplex,\n        PInfty_f, Nat.zero_eq, P_f_0_eq, zero_add] using (homotopyPToId X 2).comm 0\n    \u00b7 rw [Homotopy.dNext_succ_chainComplex, Homotopy.prevD_chainComplex, PInfty_f,\n        \u2190 P_is_eventually_constant (rfl.le : n + 1 \u2264 n + 1)]\n      erw [homotopyPToId_eventually_constant X (lt_add_one (Nat.succ n))]\n      have := (homotopyPToId X (n + 2)).comm (n + 1)\n      rw [Homotopy.dNext_succ_chainComplex, Homotopy.prevD_chainComplex] at this\n      exact this", "start": [63, 1], "end": [86, 17], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.homotopyEquivNormalizedMooreComplexAlternatingFaceMapComplex", "code": "@[simps]\ndef homotopyEquivNormalizedMooreComplexAlternatingFaceMapComplex {A : Type*} [Category A]\n    [Abelian A] {Y : SimplicialObject A} :\n    HomotopyEquiv ((normalizedMooreComplex A).obj Y) ((alternatingFaceMapComplex A).obj Y) where\n  hom := inclusionOfMooreComplexMap Y\n  inv := PInftyToNormalizedMooreComplex Y\n  homotopyHomInvId := Homotopy.ofEq (splitMonoInclusionOfMooreComplexMap Y).id\n  homotopyInvHomId := Homotopy.trans\n      (Homotopy.ofEq (PInftyToNormalizedMooreComplex_comp_inclusionOfMooreComplexMap Y))\n      (homotopyPInftyToId Y)", "start": [90, 1], "end": [101, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/MLList/IO.lean", "imports": ["lake-packages/std/Std/Data/MLList/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MLList.linesFromHandle", "code": "def linesFromHandle (h : Handle) : MLList IO String :=\n  MLList.iterate (do\n    let line \u2190 h.getLine\n    if line.length == 0 then\n      return none\n    else if line.back == '\\n' then\n      let line := line.dropRight 1\n      let line :=\n        if System.Platform.isWindows && line.back == '\\x0d' then line.dropRight 1 else line\n      return some line\n    else\n      return some line)\n  |>.takeWhile (\u00b7.isSome) |>.map (fun o => o.getD \"\")", "start": [20, 1], "end": [34, 54], "kind": "commanddeclaration"}, {"full_name": "MLList.lines", "code": "def lines (f : FilePath) : MLList IO String := .squash fun _ => do\n  return linesFromHandle (\u2190 Handle.mk f Mode.read)", "start": [36, 1], "end": [38, 51], "kind": "commanddeclaration"}, {"full_name": "MLList.runCmd", "code": "def runCmd (cmd : String) (args : Array String) (input : String := \"\") : MLList IO String := do\n  let child \u2190 spawn\n    { cmd := cmd, args := args, stdin := .piped, stdout := .piped, stderr := .piped }\n  linesFromHandle (\u2190 put child input).stdout\nwhere put\n    (child : Child { stdin := .piped, stdout := .piped, stderr := .piped }) (input : String) :\n    IO (Child { stdin := .null, stdout := .piped, stderr := .piped }) := do\n  let (stdin, child) \u2190 child.takeStdin\n  stdin.putStr input\n  stdin.flush\n  return child", "start": [41, 1], "end": [55, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Factorial/SuperFactorial.lean", "imports": ["Mathlib/Data/Nat/Factorial/Basic.lean", "Mathlib/LinearAlgebra/Vandermonde.lean", "Mathlib/Algebra/BigOperators/Intervals.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.superFactorial", "code": "def superFactorial : \u2115 \u2192 \u2115\n  | 0 => 1\n  | succ n => factorial n.succ * superFactorial n", "start": [24, 1], "end": [27, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.superFactorial_zero", "code": "@[simp]\ntheorem superFactorial_zero : sf 0 = 1", "start": [36, 1], "end": [38, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.superFactorial_succ", "code": "theorem superFactorial_succ (n : \u2115) : (sf n.succ) = (n + 1)! * sf n", "start": [40, 1], "end": [41, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.superFactorial_one", "code": "@[simp]\ntheorem superFactorial_one : sf 1 = 1", "start": [43, 1], "end": [45, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.superFactorial_two", "code": "@[simp]\ntheorem superFactorial_two : sf 2 = 2", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_Icc_factorial", "code": "@[simp]\ntheorem prod_Icc_factorial : \u2200 n : \u2115, \u220f x in Icc 1 n, x ! = sf n", "start": [53, 1], "end": [59, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_range_factorial_succ", "code": "@[simp]\ntheorem prod_range_factorial_succ : \u2200 n : \u2115, \u220f x in range n, (x + 1)! = sf n", "start": [61, 1], "end": [65, 98], "kind": "commanddeclaration"}, {"full_name": "Nat.det_vandermonde_id_eq_superFactorial", "code": "theorem det_vandermonde_id_eq_superFactorial (n : \u2115) :\n    (Matrix.vandermonde (fun (i : Fin (n + 1)) \u21a6 (i : R))).det = Nat.superFactorial n", "start": [69, 1], "end": [80, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/BigOperators.lean", "imports": ["Mathlib/Data/Finsupp/Defs.lean", "Mathlib/Data/Finset/Pairwise.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.support_sum_subset", "code": "theorem List.support_sum_subset [AddMonoid M] (l : List (\u03b9 \u2192\u2080 M)) :\n    l.sum.support \u2286 l.foldr ((\u00b7 \u2294 \u00b7) \u2218 Finsupp.support) \u2205", "start": [38, 1], "end": [44, 8], "kind": "commanddeclaration"}, {"full_name": "Multiset.support_sum_subset", "code": "theorem Multiset.support_sum_subset [AddCommMonoid M] (s : Multiset (\u03b9 \u2192\u2080 M)) :\n    s.sum.support \u2286 (s.map Finsupp.support).sup", "start": [47, 1], "end": [51, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.support_sum_subset", "code": "theorem Finset.support_sum_subset [AddCommMonoid M] (s : Finset (\u03b9 \u2192\u2080 M)) :\n    (s.sum id).support \u2286 Finset.sup s Finsupp.support", "start": [54, 1], "end": [56, 58], "kind": "commanddeclaration"}, {"full_name": "List.mem_foldr_sup_support_iff", "code": "theorem List.mem_foldr_sup_support_iff [Zero M] {l : List (\u03b9 \u2192\u2080 M)} {x : \u03b9} :\n    x \u2208 l.foldr ((\u00b7 \u2294 \u00b7) \u2218 Finsupp.support) \u2205 \u2194 \u2203 (f : \u03b9 \u2192\u2080 M) (_ : f \u2208 l), x \u2208 f.support", "start": [59, 1], "end": [65, 41], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_sup_map_support_iff", "code": "theorem Multiset.mem_sup_map_support_iff [Zero M] {s : Multiset (\u03b9 \u2192\u2080 M)} {x : \u03b9} :\n    x \u2208 (s.map Finsupp.support).sup \u2194 \u2203 (f : \u03b9 \u2192\u2080 M) (_ : f \u2208 s), x \u2208 f.support", "start": [68, 1], "end": [72, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_sup_support_iff", "code": "theorem Finset.mem_sup_support_iff [Zero M] {s : Finset (\u03b9 \u2192\u2080 M)} {x : \u03b9} :\n    x \u2208 s.sup Finsupp.support \u2194 \u2203 (f : \u03b9 \u2192\u2080 M) (_ : f \u2208 s), x \u2208 f.support", "start": [75, 1], "end": [77, 35], "kind": "commanddeclaration"}, {"full_name": "List.support_sum_eq", "code": "theorem List.support_sum_eq [AddMonoid M] (l : List (\u03b9 \u2192\u2080 M))\n    (hl : l.Pairwise (_root_.Disjoint on Finsupp.support)) :\n    l.sum.support = l.foldr ((\u00b7 \u2294 \u00b7) \u2218 Finsupp.support) \u2205", "start": [80, 1], "end": [95, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.support_sum_eq", "code": "theorem Multiset.support_sum_eq [AddCommMonoid M] (s : Multiset (\u03b9 \u2192\u2080 M))\n    (hs : s.Pairwise (_root_.Disjoint on Finsupp.support)) :\n    s.sum.support = (s.map Finsupp.support).sup", "start": [98, 1], "end": [110, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.support_sum_eq", "code": "theorem Finset.support_sum_eq [AddCommMonoid M] (s : Finset (\u03b9 \u2192\u2080 M))\n    (hs : (s : Set (\u03b9 \u2192\u2080 M)).PairwiseDisjoint Finsupp.support) :\n    (s.sum id).support = Finset.sup s Finsupp.support", "start": [113, 1], "end": [127, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Conformal.lean", "imports": ["Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean", "Mathlib/Analysis/Calculus/Conformal/NormedSpace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "InnerProductGeometry.IsConformalMap.preserves_angle", "code": "theorem IsConformalMap.preserves_angle {f' : E \u2192L[\u211d] F} (h : IsConformalMap f') (u v : E) :\n    angle (f' u) (f' v) = angle u v", "start": [27, 1], "end": [30, 58], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.ConformalAt.preserves_angle", "code": "theorem ConformalAt.preserves_angle {f : E \u2192 F} {x : E} {f' : E \u2192L[\u211d] F} (h : HasFDerivAt f f' x)\n    (H : ConformalAt f x) (u v : E) : angle (f' u) (f' v) = angle u v", "start": [33, 1], "end": [38, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/Profinite/AsLimit.lean", "imports": ["Mathlib/Topology/DiscreteQuotient.lean", "Mathlib/Topology/Category/Profinite/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Profinite.fintypeDiagram", "code": "def fintypeDiagram : DiscreteQuotient X \u2964 FintypeCat where\n  obj S := @FintypeCat.of S (Fintype.ofFinite S)\n  map f := DiscreteQuotient.ofLE f.le\n  map_comp _ _ := by ext; aesop_cat", "start": [44, 1], "end": [50, 36], "kind": "commanddeclaration"}, {"full_name": "Profinite.diagram", "code": "abbrev diagram : DiscreteQuotient X \u2964 Profinite :=\n  X.fintypeDiagram \u22d9 FintypeCat.toProfinite", "start": [54, 1], "end": [56, 44], "kind": "commanddeclaration"}, {"full_name": "Profinite.asLimitCone", "code": "def asLimitCone : CategoryTheory.Limits.Cone X.diagram :=\n  { pt := X\n    \u03c0 := { app := fun S => \u27e8S.proj, IsLocallyConstant.continuous (S.proj_isLocallyConstant)\u27e9 } }", "start": [60, 1], "end": [63, 97], "kind": "commanddeclaration"}, {"full_name": "Profinite.isIso_asLimitCone_lift", "code": "instance isIso_asLimitCone_lift : IsIso ((limitConeIsLimit X.diagram).lift X.asLimitCone) :=\n  isIso_of_bijective _\n    (by\n      refine' \u27e8fun a b h => _, fun a => _\u27e9\n      \u00b7 refine' DiscreteQuotient.eq_of_forall_proj_eq fun S => _\n        apply_fun fun f : (limitCone X.diagram).pt => f.val S at h\n        exact h\n      \u00b7 obtain \u27e8b, hb\u27e9 :=\n          DiscreteQuotient.exists_of_compat (fun S => a.val S) fun _ _ h => a.prop (homOfLE h)\n        use b\n        apply Subtype.ext\n        apply funext\n        rintro S\n        apply hb\n    )", "start": [67, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "Profinite.isoAsLimitConeLift", "code": "def isoAsLimitConeLift : X \u2245 (limitCone X.diagram).pt :=\n  asIso <| (limitConeIsLimit _).lift X.asLimitCone", "start": [87, 1], "end": [91, 51], "kind": "commanddeclaration"}, {"full_name": "Profinite.asLimitConeIso", "code": "def asLimitConeIso : X.asLimitCone \u2245 limitCone _ :=\n  Limits.Cones.ext (isoAsLimitConeLift _) fun _ => rfl", "start": [95, 1], "end": [99, 55], "kind": "commanddeclaration"}, {"full_name": "Profinite.asLimit", "code": "def asLimit : CategoryTheory.Limits.IsLimit X.asLimitCone :=\n  Limits.IsLimit.ofIsoLimit (limitConeIsLimit _) X.asLimitConeIso.symm", "start": [103, 1], "end": [105, 71], "kind": "commanddeclaration"}, {"full_name": "Profinite.lim", "code": "def lim : Limits.LimitCone X.diagram :=\n  \u27e8X.asLimitCone, X.asLimit\u27e9", "start": [109, 1], "end": [111, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/AnnihilatingPolynomial.lean", "imports": ["Mathlib/RingTheory/PrincipalIdealDomain.lean", "Mathlib/FieldTheory/Minpoly/Field.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.annIdeal", "code": "noncomputable def annIdeal (a : A) : Ideal R[X] :=\n  RingHom.ker ((aeval a).toRingHom : R[X] \u2192+* A)", "start": [47, 1], "end": [54, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_annIdeal_iff_aeval_eq_zero", "code": "theorem mem_annIdeal_iff_aeval_eq_zero {a : A} {p : R[X]} : p \u2208 annIdeal R a \u2194 aeval a p = 0", "start": [59, 1], "end": [62, 10], "kind": "commanddeclaration"}, {"full_name": "Polynomial.annIdealGenerator", "code": "noncomputable def annIdealGenerator (a : A) : \ud835\udd5c[X] :=\n  let g := IsPrincipal.generator <| annIdeal \ud835\udd5c a\n  g * C g.leadingCoeff\u207b\u00b9", "start": [75, 1], "end": [83, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.annIdealGenerator_eq_zero_iff", "code": "@[simp]\ntheorem annIdealGenerator_eq_zero_iff {a : A} : annIdealGenerator \ud835\udd5c a = 0 \u2194 annIdeal \ud835\udd5c a = \u22a5", "start": [90, 1], "end": [93, 85], "kind": "commanddeclaration"}, {"full_name": "Polynomial.span_singleton_annIdealGenerator", "code": "@[simp]\ntheorem span_singleton_annIdealGenerator (a : A) :\n    Ideal.span {annIdealGenerator \ud835\udd5c a} = annIdeal \ud835\udd5c a", "start": [98, 1], "end": [109, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.annIdealGenerator_mem", "code": "theorem annIdealGenerator_mem (a : A) : annIdealGenerator \ud835\udd5c a \u2208 annIdeal \ud835\udd5c a", "start": [112, 1], "end": [114, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_iff_eq_smul_annIdealGenerator", "code": "theorem mem_iff_eq_smul_annIdealGenerator {p : \ud835\udd5c[X]} (a : A) :\n    p \u2208 annIdeal \ud835\udd5c a \u2194 \u2203 s : \ud835\udd5c[X], p = s \u2022 annIdealGenerator \ud835\udd5c a", "start": [117, 1], "end": [119, 99], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_annIdealGenerator", "code": "theorem monic_annIdealGenerator (a : A) (hg : annIdealGenerator \ud835\udd5c a \u2260 0) :\n    Monic (annIdealGenerator \ud835\udd5c a)", "start": [122, 1], "end": [125, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.annIdealGenerator_aeval_eq_zero", "code": "theorem annIdealGenerator_aeval_eq_zero (a : A) : aeval a (annIdealGenerator \ud835\udd5c a) = 0", "start": [135, 1], "end": [136, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_iff_annIdealGenerator_dvd", "code": "theorem mem_iff_annIdealGenerator_dvd {p : \ud835\udd5c[X]} {a : A} :\n    p \u2208 annIdeal \ud835\udd5c a \u2194 annIdealGenerator \ud835\udd5c a \u2223 p", "start": [141, 1], "end": [143, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_annIdealGenerator_le_of_mem", "code": "theorem degree_annIdealGenerator_le_of_mem (a : A) (p : \ud835\udd5c[X]) (hp : p \u2208 annIdeal \ud835\udd5c a)\n    (hpn0 : p \u2260 0) : degree (annIdealGenerator \ud835\udd5c a) \u2264 degree p", "start": [146, 1], "end": [150, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.annIdealGenerator_eq_minpoly", "code": "theorem annIdealGenerator_eq_minpoly (a : A) : annIdealGenerator \ud835\udd5c a = minpoly \ud835\udd5c a", "start": [155, 1], "end": [165, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_generator_eq_minpoly", "code": "theorem monic_generator_eq_minpoly (a : A) (p : \ud835\udd5c[X]) (p_monic : p.Monic)\n    (p_gen : Ideal.span {p} = annIdeal \ud835\udd5c a) : annIdealGenerator \ud835\udd5c a = p", "start": [168, 1], "end": [177, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Sites/RegularExtensive.lean", "imports": ["Mathlib/CategoryTheory/Preadditive/Projective.lean", "Mathlib/Tactic/ApplyFun.lean", "Mathlib/CategoryTheory/Sites/Coherent.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Preregular", "code": "class Preregular : Prop where\n  \n  exists_fac : \u2200 {X Y Z : C} (f : X \u27f6 Y) (g : Z \u27f6 Y) [EffectiveEpi g],\n    (\u2203 (W : C) (h : W \u27f6 X) (_ : EffectiveEpi h) (i : W \u27f6 Z), i \u226b g = h \u226b f)", "start": [47, 1], "end": [67, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasPullbacksOfInclusions", "code": "class HasPullbacksOfInclusions : Prop where\n    \n    has_pullback : \u2200 {X Z : C} {\u03b1 : Type w} (f : X \u27f6 Z) {Y : (a : \u03b1) \u2192 C}\n    (i : (a : \u03b1) \u2192 Y a \u27f6 Z) [Fintype \u03b1] [HasCoproduct Y] [IsIso (Sigma.desc i)] (a : \u03b1),\n    HasPullback f (i a)", "start": [69, 1], "end": [78, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Extensive", "code": "class Extensive extends HasFiniteCoproducts C, HasPullbacksOfInclusions C : Prop where\n  \n  sigma_desc_iso : \u2200 {\u03b1 : Type} [Fintype \u03b1] {X : C} {Z : \u03b1 \u2192 C} (\u03c0 : (a : \u03b1) \u2192 Z a \u27f6 X)\n    {Y : C} (f : Y \u27f6 X) (_ : IsIso (Sigma.desc \u03c0)),\n    IsIso (Sigma.desc ((fun _ \u21a6 pullback.fst) : (a : \u03b1) \u2192 pullback f (\u03c0 a) \u27f6 _))", "start": [90, 1], "end": [100, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.regularCoverage", "code": "def regularCoverage [Preregular C] : Coverage C where\n  covering B := { S | \u2203 (X : C) (f : X \u27f6 B), S = Presieve.ofArrows (fun (_ : Unit) \u21a6 X)\n    (fun (_ : Unit) \u21a6 f) \u2227 EffectiveEpi f }\n  pullback := by\n    intro X Y f S \u27e8Z, \u03c0, h\u03c0, h_epi\u27e9\n    have := Preregular.exists_fac f \u03c0\n    obtain \u27e8W, h, _, i, this\u27e9 := this\n    refine \u27e8Presieve.singleton h, \u27e8?_, ?_\u27e9\u27e9\n    \u00b7 exact \u27e8W, h, by {rw [Presieve.ofArrows_pUnit h]}, inferInstance\u27e9\n    \u00b7 intro W g hg\n      cases hg\n      refine \u27e8Z, i, \u03c0, \u27e8?_, this\u27e9\u27e9\n      cases h\u03c0\n      rw [Presieve.ofArrows_pUnit]\n      exact Presieve.singleton.mk", "start": [102, 1], "end": [119, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.extensiveCoverage", "code": "def extensiveCoverage [Extensive C] : Coverage C where\n  covering B := { S | \u2203 (\u03b1 : Type) (_ : Fintype \u03b1) (X : \u03b1 \u2192 C) (\u03c0 : (a : \u03b1) \u2192 (X a \u27f6 B)),\n    S = Presieve.ofArrows X \u03c0 \u2227 IsIso (Sigma.desc \u03c0) }\n  pullback := by\n    intro X Y f S \u27e8\u03b1, h\u03b1, Z, \u03c0, hS, h_iso\u27e9\n    let Z' : \u03b1 \u2192 C := fun a \u21a6 pullback f (\u03c0 a)\n    let \u03c0' : (a : \u03b1) \u2192 Z' a \u27f6 Y := fun a \u21a6 pullback.fst\n    refine \u27e8@Presieve.ofArrows C _ _ \u03b1 Z' \u03c0', \u27e8?_, ?_\u27e9\u27e9\n    \u00b7 constructor\n      exact \u27e8h\u03b1, Z', \u03c0', \u27e8by simp only, Extensive.sigma_desc_iso (fun x => \u03c0 x) f h_iso\u27e9\u27e9\n    \u00b7 intro W g hg\n      rcases hg with \u27e8a\u27e9\n      refine \u27e8Z a, pullback.snd, \u03c0 a, ?_, by rw [CategoryTheory.Limits.pullback.condition]\u27e9\n      rw [hS]\n      refine Presieve.ofArrows.mk a", "start": [121, 1], "end": [138, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.extensive_regular_generate_coherent", "code": "lemma extensive_regular_generate_coherent [Preregular C] [Extensive C] [Precoherent C] :\n    ((extensiveCoverage C) \u2294 (regularCoverage C)).toGrothendieck =\n    (coherentTopology C) := by\n  ext B S\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 induction h with\n    | of Y T hT =>\n      apply Coverage.saturate.of\n      simp only [Coverage.sup_covering, Set.mem_union] at hT\n      exact Or.elim hT\n        (fun \u27e8\u03b1, x, X, \u03c0, \u27e8h, _\u27e9\u27e9 \u21a6 \u27e8\u03b1, x, X, \u03c0, \u27e8h, inferInstance\u27e9\u27e9)\n        (fun \u27e8Z, f, \u27e8h, _\u27e9\u27e9 \u21a6 \u27e8Unit, inferInstance, fun _ \u21a6 Z, fun _ \u21a6 f, \u27e8h, inferInstance\u27e9\u27e9)\n    | top => apply Coverage.saturate.top\n    | transitive Y T => apply Coverage.saturate.transitive Y T<;> [assumption; assumption]\n  \u00b7 induction h with\n    | of Y T hT =>\n      obtain \u27e8I, hI, X, f, \u27e8h, hT\u27e9\u27e9 := hT\n      let \u03c6 := fun (i : I) \u21a6 Sigma.\u03b9 X i\n      let F := Sigma.desc f\n      let Z := Sieve.generate T\n      let Xs := (\u2210 fun (i : I) => X i)\n      let Zf := Sieve.generate (Presieve.ofArrows (fun (_ : Unit) \u21a6 Xs) (fun (_ : Unit) \u21a6 F))\n      apply Coverage.saturate.transitive Y Zf\n      \u00b7 apply Coverage.saturate.of\n        simp only [Coverage.sup_covering, extensiveCoverage, regularCoverage, Set.mem_union,\n          Set.mem_setOf_eq]\n        exact Or.inr \u27e8Xs, F, \u27e8rfl, inferInstance\u27e9\u27e9\n      \u00b7 intro R g hZfg\n        dsimp at hZfg\n        rw [Presieve.ofArrows_pUnit] at hZfg\n        obtain \u27e8W, \u03c8, \u03c3, \u27e8hW, hW'\u27e9\u27e9 := hZfg\n        induction hW\n        rw [\u2190 hW', Sieve.pullback_comp Z]\n        suffices Sieve.pullback \u03c8 ((Sieve.pullback F) Z) \u2208 GrothendieckTopology.sieves\n          ((extensiveCoverage C) \u2294 (regularCoverage C)).toGrothendieck R by assumption\n        apply GrothendieckTopology.pullback_stable'\n        suffices Coverage.saturate ((extensiveCoverage C) \u2294 (regularCoverage C)) Xs\n          (Z.pullback F) by assumption\n        suffices : Sieve.generate (Presieve.ofArrows X \u03c6) \u2264 Z.pullback F\n        \u00b7 apply Coverage.saturate_of_superset _ this\n          apply Coverage.saturate.of\n          simp only [Coverage.sup_covering, extensiveCoverage, regularCoverage, Set.mem_union,\n            Set.mem_setOf_eq]\n          refine Or.inl \u27e8I, hI, X, \u03c6, \u27e8rfl, ?_\u27e9\u27e9\n          suffices Sigma.desc \u03c6 = \ud835\udfd9 _ by rw [this]; infer_instance\n          ext\n          simp only [colimit.\u03b9_desc, Cofan.mk_pt, Cofan.mk_\u03b9_app, Category.comp_id]\n        intro Q q hq\n        simp only [Sieve.pullback_apply, Sieve.generate_apply]\n        simp only [Sieve.generate_apply] at hq\n        obtain \u27e8E, e, r, hq\u27e9 := hq\n        refine' \u27e8E, e, r \u226b F, \u27e8_, _\u27e9\u27e9\n        \u00b7 rw [h]\n          induction hq.1\n          simp only [colimit.\u03b9_desc, Cofan.mk_pt, Cofan.mk_\u03b9_app]\n          exact Presieve.ofArrows.mk _\n        \u00b7 rw [\u2190 hq.2]\n          simp only [Category.assoc]\n    | top => apply Coverage.saturate.top\n    | transitive Y T => apply Coverage.saturate.transitive Y T<;> [assumption; assumption]", "start": [141, 1], "end": [201, 91], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Presieve.regular", "code": "class Presieve.regular {X : C} (R : Presieve X) : Prop where\n  \n  single_epi : \u2203 (Y : C) (f : Y \u27f6 X), R = Presieve.ofArrows (fun (_ : Unit) \u21a6 Y)\n    (fun (_ : Unit) \u21a6 f) \u2227 EffectiveEpi f", "start": [209, 1], "end": [213, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MapToEqualizer", "code": "def MapToEqualizer (P : C\u1d52\u1d56 \u2964 Type (max u v)) {W X B : C} (f : X \u27f6 B)\n    (g\u2081 g\u2082 : W \u27f6 X) (w : g\u2081 \u226b f = g\u2082 \u226b f) :\n    P.obj (op B) \u2192 { x : P.obj (op X) | P.map g\u2081.op x = P.map g\u2082.op x } :=\n  fun t \u21a6 \u27e8P.map f.op t, by\n    change (P.map _ \u226b P.map _) _ = (P.map _ \u226b P.map _) _;\n    simp_rw [\u2190 P.map_comp, \u2190 op_comp, w] \u27e9", "start": [215, 1], "end": [223, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.EqualizerCondition", "code": "def EqualizerCondition (P : C\u1d52\u1d56 \u2964 Type (max u v)) : Prop :=\n  \u2200 (X B : C) (\u03c0 : X \u27f6 B) [EffectiveEpi \u03c0] [HasPullback \u03c0 \u03c0], Function.Bijective\n    (MapToEqualizer P \u03c0 (pullback.fst (f := \u03c0) (g := \u03c0)) (pullback.snd (f := \u03c0) (g := \u03c0))\n    pullback.condition)", "start": [225, 1], "end": [231, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.EqualizerFirstObjIso", "code": "noncomputable\ndef EqualizerFirstObjIso (F : C\u1d52\u1d56 \u2964 Type (max u v)) {B X : C} (\u03c0 : X \u27f6 B) :\n    Equalizer.FirstObj F (Presieve.singleton \u03c0) \u2245 F.obj (op X) :=\n  CategoryTheory.Equalizer.firstObjEqFamily F (Presieve.singleton \u03c0) \u226a\u226b\n  { hom := fun e \u21a6 e \u03c0 (Presieve.singleton_self \u03c0)\n    inv := fun e _ _ h \u21a6 by\n      induction h with\n      | mk => exact e\n    hom_inv_id := by\n      funext _ _ _ h\n      induction h with\n      | mk => rfl\n    inv_hom_id := by aesop }", "start": [233, 1], "end": [248, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.EqualizerSecondObjIso", "code": "noncomputable\ndef EqualizerSecondObjIso (F : C\u1d52\u1d56 \u2964 Type (max u v)) {B X : C} (\u03c0 : X \u27f6 B) [EffectiveEpi \u03c0]\n    [HasPullback \u03c0 \u03c0] :\n    Equalizer.Presieve.SecondObj F (Presieve.singleton \u03c0) \u2245 F.obj (op (Limits.pullback \u03c0 \u03c0)) :=\n  Types.productIso.{max u v, max u v} _ \u226a\u226b\n  { hom := fun e \u21a6 e (\u27e8X, \u27e8\u03c0, Presieve.singleton_self \u03c0\u27e9\u27e9, \u27e8X, \u27e8\u03c0, Presieve.singleton_self \u03c0\u27e9\u27e9)\n    inv := fun x \u27e8\u27e8_, \u27e8_, h\u2081\u27e9\u27e9 , \u27e8_, \u27e8_, h\u2082\u27e9\u27e9\u27e9 \u21a6 by\n      induction h\u2081\n      induction h\u2082\n      exact x\n    hom_inv_id := by\n      funext _ \u27e8\u27e8_, \u27e8_, h\u2081\u27e9\u27e9 , \u27e8_, \u27e8_, h\u2082\u27e9\u27e9\u27e9\n      induction h\u2081\n      induction h\u2082\n      rfl\n    inv_hom_id := by aesop }", "start": [257, 1], "end": [276, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.EqualizerCondition.isSheafFor", "code": "lemma EqualizerCondition.isSheafFor {B : C} {S : Presieve B} [S.regular] [S.hasPullbacks]\n    {F : C\u1d52\u1d56 \u2964 Type (max u v)}\n    (hFecs : EqualizerCondition F) : S.IsSheafFor F := by\n  obtain \u27e8X, \u03c0, \u27e8hS, \u03c0surj\u27e9\u27e9 := Presieve.regular.single_epi (R := S)\n  rw [Presieve.ofArrows_pUnit] at hS\n  haveI : (Presieve.singleton \u03c0).hasPullbacks := by rw [\u2190 hS]; infer_instance\n  haveI : HasPullback \u03c0 \u03c0 :=\n    Presieve.hasPullbacks.has_pullbacks (Presieve.singleton.mk) (Presieve.singleton.mk)\n  subst hS\n  rw [Equalizer.Presieve.sheaf_condition, Limits.Types.type_equalizer_iff_unique]\n  intro y h\n  specialize hFecs X B \u03c0\n  have hy : F.map (pullback.fst (f := \u03c0) (g := \u03c0)).op ((EqualizerFirstObjIso F \u03c0).hom y) =\n      F.map (pullback.snd (f := \u03c0) (g := \u03c0)).op ((EqualizerFirstObjIso F \u03c0).hom y) :=\n    calc\n      _ = (Equalizer.Presieve.firstMap F (Presieve.singleton \u03c0) \u226b\n          (EqualizerSecondObjIso F \u03c0).hom) y := by\n          simp [EqualizerSecondObjIso, EqualizerFirstObjIso, Equalizer.Presieve.firstMap]\n      _ = (Equalizer.Presieve.secondMap F (Presieve.singleton \u03c0) \u226b (EqualizerSecondObjIso F \u03c0).hom)\n          y := by simp only [Equalizer.Presieve.SecondObj, types_comp_apply]; rw [h]\n      _ = _ := by\n          simp [EqualizerSecondObjIso, EqualizerFirstObjIso, Equalizer.Presieve.secondMap]\n  obtain \u27e8x, \u27e8hx\u2081, hx\u2082\u27e9\u27e9 : \u2203! x, F.map \u03c0.op x = (EqualizerFirstObjIso F \u03c0).hom y\n  \u00b7 rw [Function.bijective_iff_existsUnique] at hFecs\n    specialize hFecs \u27e8(EqualizerFirstObjIso F \u03c0).hom y, hy\u27e9\n    obtain \u27e8x, \u27e8hx\u2081, hx\u2082\u27e9\u27e9 := hFecs\n    refine \u27e8x, \u27e8Subtype.ext_iff.mp hx\u2081, ?_\u27e9\u27e9\n    intros\n    apply hx\u2082\n    rwa [Subtype.ext_iff]\n  have fork_comp : Equalizer.forkMap F (Presieve.singleton \u03c0) \u226b (EqualizerFirstObjIso F \u03c0).hom =\n      F.map \u03c0.op := by ext; simp [EqualizerFirstObjIso, Equalizer.forkMap]\n  rw [\u2190 fork_comp] at hx\u2081 hx\u2082\n  refine \u27e8x, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 apply_fun (EqualizerFirstObjIso F \u03c0).hom using injective_of_mono (EqualizerFirstObjIso F \u03c0).hom\n    exact hx\u2081\n  \u00b7 intro z hz\n    apply_fun (EqualizerFirstObjIso F \u03c0).hom at hz\n    exact hx\u2082 z hz", "start": [278, 1], "end": [316, 19], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.IsSheafForRegular.equalizerCondition", "code": "lemma IsSheafForRegular.equalizerCondition {F : C\u1d52\u1d56 \u2964 Type (max u v)}\n    (hSF : \u2200 {B : C} (S : Presieve B) [S.regular] [S.hasPullbacks], S.IsSheafFor F) :\n    EqualizerCondition F := by\n  intro X B \u03c0 _ _\n  haveI : (Presieve.singleton \u03c0).regular :=\n    \u27e8X, \u03c0, \u27e8(Presieve.ofArrows_pUnit \u03c0).symm, inferInstance\u27e9\u27e9\n  specialize hSF (Presieve.singleton \u03c0)\n  rw [Equalizer.Presieve.sheaf_condition, Limits.Types.type_equalizer_iff_unique] at hSF\n  rw [Function.bijective_iff_existsUnique]\n  intro \u27e8b, hb\u27e9\n  specialize hSF ((EqualizerFirstObjIso F \u03c0).inv b) ?_\n  \u00b7 apply_fun (EqualizerSecondObjIso F \u03c0).hom using injective_of_mono _\n    calc\n      _ = F.map (pullback.fst (f := \u03c0) (g := \u03c0)).op b := by\n        simp only [Equalizer.Presieve.SecondObj, EqualizerSecondObjIso, Equalizer.Presieve.firstMap,\n          EqualizerFirstObjIso, Iso.trans_inv, types_comp_apply, Equalizer.firstObjEqFamily_inv,\n          Iso.trans_hom, Types.productIso_hom_comp_eval_apply, Types.Limit.lift_\u03c0_apply', Fan.mk_pt,\n          Fan.mk_\u03c0_app]; rfl\n      _ = F.map (pullback.snd (f := \u03c0) (g := \u03c0)).op b := hb\n      _ = ((EqualizerFirstObjIso F \u03c0).inv \u226b Equalizer.Presieve.secondMap F (Presieve.singleton \u03c0) \u226b\n        (EqualizerSecondObjIso F \u03c0).hom) b := by\n          simp only [EqualizerFirstObjIso, Iso.trans_inv, Equalizer.Presieve.SecondObj,\n            Equalizer.Presieve.secondMap, EqualizerSecondObjIso, Iso.trans_hom,\n            Types.productIso_hom_comp_eval, limit.lift_\u03c0, Fan.mk_pt, Fan.mk_\u03c0_app, types_comp_apply,\n            Equalizer.firstObjEqFamily_inv, Types.Limit.lift_\u03c0_apply']; rfl\n  \u00b7 obtain \u27e8a, \u27e8ha\u2081, ha\u2082\u27e9\u27e9 := hSF\n    refine \u27e8a, \u27e8?_, ?_\u27e9\u27e9\n    \u00b7 ext\n      dsimp [MapToEqualizer]\n      apply_fun (EqualizerFirstObjIso F \u03c0).hom at ha\u2081\n      simp only [inv_hom_id_apply] at ha\u2081\n      rw [\u2190 ha\u2081]\n      simp only [EqualizerFirstObjIso, Equalizer.forkMap, Iso.trans_hom, types_comp_apply,\n        Equalizer.firstObjEqFamily_hom, Types.pi_lift_\u03c0_apply]\n    \u00b7 intro y hy\n      apply ha\u2082\n      apply_fun (EqualizerFirstObjIso F \u03c0).hom using injective_of_mono _\n      simp only [inv_hom_id_apply]\n      simp only [MapToEqualizer, Set.mem_setOf_eq, Subtype.mk.injEq] at hy\n      rw [\u2190 hy]\n      simp only [EqualizerFirstObjIso, Equalizer.forkMap, Iso.trans_hom, types_comp_apply,\n        Equalizer.firstObjEqFamily_hom, Types.pi_lift_\u03c0_apply]", "start": [318, 1], "end": [359, 63], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.isSheafFor_regular_of_projective", "code": "lemma isSheafFor_regular_of_projective {X : C} (S : Presieve X) [S.regular] [Projective X]\n    (F : C\u1d52\u1d56 \u2964 Type (max u v)) : S.IsSheafFor F := by\n  obtain \u27e8Y, f, rfl, hf\u27e9 := Presieve.regular.single_epi (R := S)\n  let g := Projective.factorThru (\ud835\udfd9 _) f\n  have hfg : g \u226b f = \ud835\udfd9 _ := by\n    simp only [Projective.factorThru_comp]\n  intro y hy\n  refine' \u27e8F.map g.op <| y f <| Presieve.ofArrows.mk (), fun Z h hZ => _, fun z hz => _\u27e9\n  \u00b7 cases' hZ with u\n    have := hy (f\u2081 := f) (f\u2082 := f) (\ud835\udfd9 Y) (f \u226b g) (Presieve.ofArrows.mk ())\n        (Presieve.ofArrows.mk ()) ?_\n    \u00b7 rw [op_id, F.map_id, types_id_apply] at this\n      rw [\u2190 types_comp_apply (F.map g.op) (F.map f.op), \u2190 F.map_comp, \u2190 op_comp]\n      exact this.symm\n    \u00b7 rw [Category.id_comp, Category.assoc, hfg, Category.comp_id]\n  \u00b7 have := congr_arg (F.map g.op) <| hz f (Presieve.ofArrows.mk ())\n    rwa [\u2190 types_comp_apply (F.map f.op) (F.map g.op), \u2190 F.map_comp, \u2190 op_comp, hfg, op_id,\n      F.map_id, types_id_apply] at this", "start": [361, 1], "end": [378, 40], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.isSheaf_iff_equalizerCondition", "code": "lemma isSheaf_iff_equalizerCondition (F : C\u1d52\u1d56 \u2964 Type (max u v)) [Preregular C] [HasPullbacks C] :\n    Presieve.IsSheaf (regularCoverage C).toGrothendieck F \u2194 EqualizerCondition F := by\n  rw [Presieve.isSheaf_coverage]\n  refine \u27e8?_, ?_\u27e9\n  \u00b7 intro h\n    apply IsSheafForRegular.equalizerCondition\n    intro B S _ _\n    apply h S\n    obtain \u27e8Y, f, rfl, _\u27e9 := Presieve.regular.single_epi (R := S)\n    use Y, f\n  \u00b7 intro h X S \u27e8Y, f, hh\u27e9\n    haveI : S.regular := \u27e8Y, f, hh\u27e9\n    exact h.isSheafFor", "start": [380, 1], "end": [392, 23], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.isSheaf_of_projective", "code": "lemma isSheaf_of_projective (F : C\u1d52\u1d56 \u2964 Type (max u v)) [Preregular C] [\u2200 (X : C), Projective X] :\n    Presieve.IsSheaf (regularCoverage C).toGrothendieck F := by\n  rw [Presieve.isSheaf_coverage]\n  intro X S \u27e8Y, f, hh\u27e9\n  haveI : S.regular := \u27e8Y, f, hh\u27e9\n  exact isSheafFor_regular_of_projective _ _", "start": [394, 1], "end": [399, 45], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Analysis/Convex/Extrema.lean", "imports": ["Mathlib/Topology/Algebra/Affine.lean", "Mathlib/Topology/MetricSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/LocalExtr.lean", "Mathlib/Analysis/Convex/Function.lean"], "premises": [{"full_name": "IsMinOn.of_isLocalMinOn_of_convexOn_Icc", "code": "theorem IsMinOn.of_isLocalMinOn_of_convexOn_Icc {f : \u211d \u2192 \u03b2} {a b : \u211d} (a_lt_b : a < b)\n    (h_local_min : IsLocalMinOn f (Icc a b) a) (h_conv : ConvexOn \u211d (Icc a b) f) :\n    IsMinOn f (Icc a b) a", "start": [28, 1], "end": [48, 85], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.of_isLocalMinOn_of_convexOn", "code": "theorem IsMinOn.of_isLocalMinOn_of_convexOn {f : E \u2192 \u03b2} {a : E} (a_in_s : a \u2208 s)\n    (h_localmin : IsLocalMinOn f s a) (h_conv : ConvexOn \u211d s f) : IsMinOn f s a", "start": [51, 1], "end": [68, 96], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.of_isLocalMaxOn_of_concaveOn", "code": "theorem IsMaxOn.of_isLocalMaxOn_of_concaveOn {f : E \u2192 \u03b2} {a : E} (a_in_s : a \u2208 s)\n    (h_localmax : IsLocalMaxOn f s a) (h_conc : ConcaveOn \u211d s f) : IsMaxOn f s a", "start": [71, 1], "end": [74, 92], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.of_isLocalMin_of_convex_univ", "code": "theorem IsMinOn.of_isLocalMin_of_convex_univ {f : E \u2192 \u03b2} {a : E} (h_local_min : IsLocalMin f a)\n    (h_conv : ConvexOn \u211d univ f) : \u2200 x, f a \u2264 f x", "start": [77, 1], "end": [80, 95], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.of_isLocalMax_of_convex_univ", "code": "theorem IsMaxOn.of_isLocalMax_of_convex_univ {f : E \u2192 \u03b2} {a : E} (h_local_max : IsLocalMax f a)\n    (h_conc : ConcaveOn \u211d univ f) : \u2200 x, f x \u2264 f a", "start": [83, 1], "end": [86, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Abelian/RightDerived.lean", "imports": ["Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean", "Mathlib/CategoryTheory/Abelian/Homology.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Constructions/EpiMono.lean", "Mathlib/CategoryTheory/Abelian/Exact.lean", "Mathlib/Algebra/Homology/Additive.lean"], "premises": [{"full_name": "CategoryTheory.Functor.rightDerived", "code": "def Functor.rightDerived (F : C \u2964 D) [F.Additive] (n : \u2115) : C \u2964 D :=\n  injectiveResolutions C \u22d9 F.mapHomotopyCategory _ \u22d9 HomotopyCategory.homologyFunctor D _ n", "start": [65, 1], "end": [67, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.rightDerivedObjIso", "code": "@[simps!]\ndef Functor.rightDerivedObjIso (F : C \u2964 D) [F.Additive] (n : \u2115) {X : C}\n    (P : InjectiveResolution X) :\n    (F.rightDerived n).obj X \u2245\n      (homologyFunctor D _ n).obj ((F.mapHomologicalComplex _).obj P.cocomplex) :=\n  (HomotopyCategory.homologyFunctor D _ n).mapIso\n      (HomotopyCategory.isoOfHomotopyEquiv\n        (F.mapHomotopyEquiv (InjectiveResolution.homotopyEquiv _ P))) \u226a\u226b\n    (HomotopyCategory.homologyFactors D _ n).app _", "start": [70, 1], "end": [79, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.rightDerivedObjInjectiveZero", "code": "@[simps!]\ndef Functor.rightDerivedObjInjectiveZero (F : C \u2964 D) [F.Additive] (X : C) [Injective X] :\n    (F.rightDerived 0).obj X \u2245 F.obj X :=\n  F.rightDerivedObjIso 0 (InjectiveResolution.self X) \u226a\u226b\n    (homologyFunctor _ _ _).mapIso ((CochainComplex.single\u2080MapHomologicalComplex F).app X) \u226a\u226b\n      (CochainComplex.homologyFunctor0Single\u2080 D).app (F.obj X)", "start": [82, 1], "end": [88, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.rightDerivedObjInjectiveSucc", "code": "@[simps! inv]\ndef Functor.rightDerivedObjInjectiveSucc (F : C \u2964 D) [F.Additive] (n : \u2115) (X : C) [Injective X] :\n    (F.rightDerived (n + 1)).obj X \u2245 0 :=\n  F.rightDerivedObjIso (n + 1) (InjectiveResolution.self X) \u226a\u226b\n    (homologyFunctor _ _ _).mapIso ((CochainComplex.single\u2080MapHomologicalComplex F).app X) \u226a\u226b\n      (CochainComplex.homologyFunctorSuccSingle\u2080 D n).app (F.obj X) \u226a\u226b (Functor.zero_obj _).isoZero", "start": [93, 1], "end": [99, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.rightDerived_map_eq", "code": "theorem Functor.rightDerived_map_eq (F : C \u2964 D) [F.Additive] (n : \u2115) {X Y : C} (f : Y \u27f6 X)\n    {P : InjectiveResolution X} {Q : InjectiveResolution Y} (g : Q.cocomplex \u27f6 P.cocomplex)\n    (w : Q.\u03b9 \u226b g = (CochainComplex.single\u2080 C).map f \u226b P.\u03b9) :\n    (F.rightDerived n).map f =\n      (F.rightDerivedObjIso n Q).hom \u226b\n        (homologyFunctor D _ n).map ((F.mapHomologicalComplex _).map g) \u226b\n          (F.rightDerivedObjIso n P).inv", "start": [102, 1], "end": [124, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.rightDerived", "code": "@[simps!]\ndef NatTrans.rightDerived {F G : C \u2964 D} [F.Additive] [G.Additive] (\u03b1 : F \u27f6 G) (n : \u2115) :\n    F.rightDerived n \u27f6 G.rightDerived n :=\n  whiskerLeft (injectiveResolutions C)\n    (whiskerRight (NatTrans.mapHomotopyCategory \u03b1 _) (HomotopyCategory.homologyFunctor D _ n))", "start": [127, 1], "end": [132, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.rightDerived_id", "code": "@[simp]\ntheorem NatTrans.rightDerived_id (F : C \u2964 D) [F.Additive] (n : \u2115) :\n    NatTrans.rightDerived (\ud835\udfd9 F) n = \ud835\udfd9 (F.rightDerived n)", "start": [135, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.rightDerived_comp", "code": "@[simp, nolint simpNF]\ntheorem NatTrans.rightDerived_comp {F G H : C \u2964 D} [F.Additive] [G.Additive] [H.Additive]\n    (\u03b1 : F \u27f6 G) (\u03b2 : G \u27f6 H) (n : \u2115) :\n    NatTrans.rightDerived (\u03b1 \u226b \u03b2) n = NatTrans.rightDerived \u03b1 n \u226b NatTrans.rightDerived \u03b2 n", "start": [142, 1], "end": [146, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.rightDerived_eq", "code": "theorem NatTrans.rightDerived_eq {F G : C \u2964 D} [F.Additive] [G.Additive] (\u03b1 : F \u27f6 G) (n : \u2115) {X : C}\n    (P : InjectiveResolution X) :\n    (NatTrans.rightDerived \u03b1 n).app X =\n      (F.rightDerivedObjIso n P).hom \u226b\n        (homologyFunctor D _ n).map ((NatTrans.mapHomologicalComplex \u03b1 _).app P.cocomplex) \u226b\n          (G.rightDerivedObjIso n P).inv", "start": [149, 1], "end": [169, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.preserves_exact_of_preservesFiniteLimits_of_mono", "code": "theorem preserves_exact_of_preservesFiniteLimits_of_mono [PreservesFiniteLimits F] [Mono f]\n    (ex : Exact f g) : Exact (F.map f) (F.map g)", "start": [190, 1], "end": [195, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.exact_of_map_injectiveResolution", "code": "theorem exact_of_map_injectiveResolution (P : InjectiveResolution X) [PreservesFiniteLimits F] :\n    Exact (F.map (P.\u03b9.f 0))\n      (((F.mapHomologicalComplex (ComplexShape.up \u2115)).obj P.cocomplex).dFrom 0)", "start": [198, 1], "end": [205, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.rightDerivedZeroToSelfApp", "code": "def rightDerivedZeroToSelfApp [EnoughInjectives C] [PreservesFiniteLimits F] {X : C}\n    (P : InjectiveResolution X) : (F.rightDerived 0).obj X \u27f6 F.obj X :=\n  (rightDerivedObjIso F 0 P).hom \u226b\n    (homologyIsoKernelDesc _ _ _).hom \u226b\n      kernel.map _ (((F.mapHomologicalComplex (ComplexShape.up \u2115)).obj P.cocomplex).dFrom 0)\n      (cokernel.desc _ (\ud835\udfd9 _) (by simp)) (\ud835\udfd9 _)\n          (by\n            ext\n            dsimp\n            simp) \u226b\n        have : IsIso <| kernel.lift _ _ (exact_of_map_injectiveResolution F P).w :=\n          isIso_kernel_lift_of_exact_of_mono _ _ (exact_of_map_injectiveResolution F P)\n        (asIso (kernel.lift _ _ (exact_of_map_injectiveResolution F P).w)).inv", "start": [208, 1], "end": [225, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.rightDerivedZeroToSelfAppInv", "code": "def rightDerivedZeroToSelfAppInv [EnoughInjectives C] {X : C} (P : InjectiveResolution X) :\n    F.obj X \u27f6 (F.rightDerived 0).obj X :=\n  homology.lift _ _ _ (F.map (P.\u03b9.f 0) \u226b cokernel.\u03c0 _)\n      (by\n        have : (ComplexShape.up \u2115).Rel 0 1 := rfl\n        rw [Category.assoc, cokernel.\u03c0_desc, HomologicalComplex.dFrom_eq _ this,\n          mapHomologicalComplex_obj_d, \u2190 Category.assoc, \u2190 Functor.map_comp]\n        simp only [InjectiveResolution.\u03b9_f_zero_comp_complex_d, Functor.map_zero, zero_comp]) \u226b\n    (rightDerivedObjIso F 0 P).inv", "start": [228, 1], "end": [237, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.rightDerivedZeroToSelfApp_comp_inv", "code": "theorem rightDerivedZeroToSelfApp_comp_inv [EnoughInjectives C] [PreservesFiniteLimits F] {X : C}\n    (P : InjectiveResolution X) :\n    rightDerivedZeroToSelfApp F P \u226b rightDerivedZeroToSelfAppInv F P = \ud835\udfd9 _", "start": [240, 1], "end": [260, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.rightDerivedZeroToSelfAppInv_comp", "code": "theorem rightDerivedZeroToSelfAppInv_comp [EnoughInjectives C] [PreservesFiniteLimits F] {X : C}\n    (P : InjectiveResolution X) :\n    rightDerivedZeroToSelfAppInv F P \u226b rightDerivedZeroToSelfApp F P = \ud835\udfd9 _", "start": [264, 1], "end": [281, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.rightDerivedZeroToSelfAppIso", "code": "def rightDerivedZeroToSelfAppIso [EnoughInjectives C] [PreservesFiniteLimits F] {X : C}\n    (P : InjectiveResolution X) : (F.rightDerived 0).obj X \u2245 F.obj X where\n  hom := rightDerivedZeroToSelfApp _ P\n  inv := rightDerivedZeroToSelfAppInv _ P\n  hom_inv_id := rightDerivedZeroToSelfApp_comp_inv _ P\n  inv_hom_id := rightDerivedZeroToSelfAppInv_comp _ P", "start": [284, 1], "end": [291, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.rightDerivedZeroToSelf_natural", "code": "theorem rightDerivedZeroToSelf_natural [EnoughInjectives C] {X : C} {Y : C} (f : X \u27f6 Y)\n    (P : InjectiveResolution X) (Q : InjectiveResolution Y) :\n    F.map f \u226b rightDerivedZeroToSelfAppInv F Q =\n      rightDerivedZeroToSelfAppInv F P \u226b (F.rightDerived 0).map f", "start": [294, 1], "end": [319, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.Functor.rightDerivedZeroIsoSelf", "code": "def rightDerivedZeroIsoSelf [EnoughInjectives C] [PreservesFiniteLimits F] : F.rightDerived 0 \u2245 F :=\n  Iso.symm <|\n    NatIso.ofComponents\n      (fun X => (rightDerivedZeroToSelfAppIso _ (InjectiveResolution.of X)).symm) fun _ =>\n      rightDerivedZeroToSelf_natural _ _ _ _", "start": [322, 1], "end": [327, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fin/Tuple/BubbleSortInduction.lean", "imports": ["Mathlib/Data/Fin/Tuple/Sort.lean", "Mathlib/Data/Fintype/Perm.lean", "Mathlib/Order/WellFounded.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Tuple.bubble_sort_induction'", "code": "theorem bubble_sort_induction' {n : \u2115} {\u03b1 : Type*} [LinearOrder \u03b1] {f : Fin n \u2192 \u03b1}\n    {P : (Fin n \u2192 \u03b1) \u2192 Prop} (hf : P f)\n    (h : \u2200 (\u03c3 : Equiv.Perm (Fin n)) (i j : Fin n),\n      i < j \u2192 (f \u2218 \u03c3) j < (f \u2218 \u03c3) i \u2192 P (f \u2218 \u03c3) \u2192 P (f \u2218 \u03c3 \u2218 Equiv.swap i j)) :\n    P (f \u2218 sort f)", "start": [32, 1], "end": [45, 78], "kind": "commanddeclaration"}, {"full_name": "Tuple.bubble_sort_induction", "code": "theorem bubble_sort_induction {n : \u2115} {\u03b1 : Type*} [LinearOrder \u03b1] {f : Fin n \u2192 \u03b1}\n    {P : (Fin n \u2192 \u03b1) \u2192 Prop} (hf : P f)\n    (h : \u2200 (g : Fin n \u2192 \u03b1) (i j : Fin n), i < j \u2192 g j < g i \u2192 P g \u2192 P (g \u2218 Equiv.swap i j)) :\n    P (f \u2218 sort f)", "start": [48, 1], "end": [54, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/GoldenRatio.lean", "imports": ["Mathlib/Tactic/NormNum/NatFib.lean", "Mathlib/Data/Nat/Fib.lean", "Mathlib/Data/Real/Irrational.lean", "Mathlib/Data/Nat/PrimeNormNum.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/LinearRecurrence.lean", "Mathlib/Data/Fin/VecNotation.lean"], "premises": [{"full_name": "goldenRatio", "code": "@[reducible]\ndef goldenRatio :=\n  (1 + Real.sqrt 5) / 2", "start": [31, 1], "end": [34, 24], "kind": "commanddeclaration"}, {"full_name": "goldenConj", "code": "@[reducible]\ndef goldenConj :=\n  (1 - Real.sqrt 5) / 2", "start": [37, 1], "end": [40, 24], "kind": "commanddeclaration"}, {"full_name": "inv_gold", "code": "theorem inv_gold : \u03c6\u207b\u00b9 = -\u03c8", "start": [47, 1], "end": [51, 11], "kind": "commanddeclaration"}, {"full_name": "inv_goldConj", "code": "theorem inv_goldConj : \u03c8\u207b\u00b9 = -\u03c6", "start": [54, 1], "end": [57, 22], "kind": "commanddeclaration"}, {"full_name": "gold_mul_goldConj", "code": "@[simp]\ntheorem gold_mul_goldConj : \u03c6 * \u03c8 = -1", "start": [60, 1], "end": [64, 11], "kind": "commanddeclaration"}, {"full_name": "goldConj_mul_gold", "code": "@[simp]\ntheorem goldConj_mul_gold : \u03c8 * \u03c6 = -1", "start": [67, 1], "end": [70, 26], "kind": "commanddeclaration"}, {"full_name": "gold_add_goldConj", "code": "@[simp]\ntheorem gold_add_goldConj : \u03c6 + \u03c8 = 1", "start": [73, 1], "end": [76, 7], "kind": "commanddeclaration"}, {"full_name": "one_sub_goldConj", "code": "theorem one_sub_goldConj : 1 - \u03c6 = \u03c8", "start": [79, 1], "end": [80, 31], "kind": "commanddeclaration"}, {"full_name": "one_sub_gold", "code": "theorem one_sub_gold : 1 - \u03c8 = \u03c6", "start": [83, 1], "end": [84, 31], "kind": "commanddeclaration"}, {"full_name": "gold_sub_goldConj", "code": "@[simp]\ntheorem gold_sub_goldConj : \u03c6 - \u03c8 = Real.sqrt 5", "start": [87, 1], "end": [90, 7], "kind": "commanddeclaration"}, {"full_name": "gold_sq", "code": "@[simp 1200]\ntheorem gold_sq : \u03c6 ^ 2 = \u03c6 + 1", "start": [93, 1], "end": [97, 33], "kind": "commanddeclaration"}, {"full_name": "goldConj_sq", "code": "@[simp 1200]\ntheorem goldConj_sq : \u03c8 ^ 2 = \u03c8 + 1", "start": [100, 1], "end": [104, 33], "kind": "commanddeclaration"}, {"full_name": "gold_pos", "code": "theorem gold_pos : 0 < \u03c6", "start": [107, 1], "end": [108, 67], "kind": "commanddeclaration"}, {"full_name": "gold_ne_zero", "code": "theorem gold_ne_zero : \u03c6 \u2260 0", "start": [111, 1], "end": [112, 20], "kind": "commanddeclaration"}, {"full_name": "one_lt_gold", "code": "theorem one_lt_gold : 1 < \u03c6", "start": [115, 1], "end": [117, 48], "kind": "commanddeclaration"}, {"full_name": "goldConj_neg", "code": "theorem goldConj_neg : \u03c8 < 0", "start": [120, 1], "end": [121, 43], "kind": "commanddeclaration"}, {"full_name": "goldConj_ne_zero", "code": "theorem goldConj_ne_zero : \u03c8 \u2260 0", "start": [124, 1], "end": [125, 24], "kind": "commanddeclaration"}, {"full_name": "neg_one_lt_goldConj", "code": "theorem neg_one_lt_goldConj : -1 < \u03c8", "start": [128, 1], "end": [130, 31], "kind": "commanddeclaration"}, {"full_name": "gold_irrational", "code": "theorem gold_irrational : Irrational \u03c6", "start": [138, 1], "end": [145, 13], "kind": "commanddeclaration"}, {"full_name": "goldConj_irrational", "code": "theorem goldConj_irrational : Irrational \u03c8", "start": [148, 1], "end": [155, 13], "kind": "commanddeclaration"}, {"full_name": "fibRec", "code": "def fibRec : LinearRecurrence \u03b1 where\n  order := 2\n  coeffs := ![1, 1]", "start": [167, 1], "end": [170, 20], "kind": "commanddeclaration"}, {"full_name": "fibRec_charPoly_eq", "code": "theorem fibRec_charPoly_eq {\u03b2 : Type*} [CommRing \u03b2] :\n    fibRec.charPoly = X ^ 2 - (X + (1 : \u03b2[X]))", "start": [177, 1], "end": [181, 83], "kind": "commanddeclaration"}, {"full_name": "fib_isSol_fibRec", "code": "theorem fib_isSol_fibRec : fibRec.IsSolution (fun x => x.fib : \u2115 \u2192 \u03b1)", "start": [186, 1], "end": [192, 61], "kind": "commanddeclaration"}, {"full_name": "geom_gold_isSol_fibRec", "code": "theorem geom_gold_isSol_fibRec : fibRec.IsSolution (\u03c6 ^ \u00b7)", "start": [195, 1], "end": [198, 32], "kind": "commanddeclaration"}, {"full_name": "geom_goldConj_isSol_fibRec", "code": "theorem geom_goldConj_isSol_fibRec : fibRec.IsSolution (\u03c8 ^ \u00b7)", "start": [201, 1], "end": [204, 32], "kind": "commanddeclaration"}, {"full_name": "Real.coe_fib_eq'", "code": "theorem Real.coe_fib_eq' :\n    (fun n => Nat.fib n : \u2115 \u2192 \u211d) = fun n => (\u03c6 ^ n - \u03c8 ^ n) / Real.sqrt 5", "start": [209, 1], "end": [229, 90], "kind": "commanddeclaration"}, {"full_name": "Real.coe_fib_eq", "code": "theorem Real.coe_fib_eq : \u2200 n, (Nat.fib n : \u211d) = (\u03c6 ^ n - \u03c8 ^ n) / Real.sqrt 5", "start": [232, 1], "end": [234, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Alternating/DomCoprod.lean", "imports": ["Mathlib/LinearAlgebra/Multilinear/TensorProduct.lean", "Mathlib/LinearAlgebra/Alternating/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Equiv.Perm.ModSumCongr", "code": "abbrev ModSumCongr (\u03b1 \u03b2 : Type*) :=\n  _ \u29f8 (Equiv.Perm.sumCongrHom \u03b1 \u03b2).range", "start": [30, 1], "end": [32, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.ModSumCongr.swap_smul_involutive", "code": "theorem ModSumCongr.swap_smul_involutive {\u03b1 \u03b2 : Type*} [DecidableEq (Sum \u03b1 \u03b2)] (i j : Sum \u03b1 \u03b2) :\n    Function.Involutive (SMul.smul (Equiv.swap i j) : ModSumCongr \u03b1 \u03b2 \u2192 ModSumCongr \u03b1 \u03b2)", "start": [35, 1], "end": [39, 75], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domCoprod.summand", "code": "def domCoprod.summand (a : AlternatingMap R' M\u1d62 N\u2081 \u03b9a) (b : AlternatingMap R' M\u1d62 N\u2082 \u03b9b)\n    (\u03c3 : Perm.ModSumCongr \u03b9a \u03b9b) : MultilinearMap R' (fun _ : Sum \u03b9a \u03b9b => M\u1d62) (N\u2081 \u2297[R'] N\u2082) :=\n  Quotient.liftOn' \u03c3\n    (fun \u03c3 =>\n      Equiv.Perm.sign \u03c3 \u2022\n        (MultilinearMap.domCoprod \u2191a \u2191b : MultilinearMap R' (fun _ => M\u1d62) (N\u2081 \u2297 N\u2082)).domDomCongr \u03c3)\n    fun \u03c3\u2081 \u03c3\u2082 H => by\n    rw [QuotientGroup.leftRel_apply] at H\n    obtain \u27e8\u27e8sl, sr\u27e9, h\u27e9 := H\n    ext v\n    simp only [MultilinearMap.domDomCongr_apply, MultilinearMap.domCoprod_apply,\n      coe_multilinearMap, MultilinearMap.smul_apply]\n    replace h := inv_mul_eq_iff_eq_mul.mp h.symm\n    have : Equiv.Perm.sign (\u03c3\u2081 * Perm.sumCongrHom _ _ (sl, sr))\n      = Equiv.Perm.sign \u03c3\u2081 * (Equiv.Perm.sign sl * Equiv.Perm.sign sr) := by simp\n    rw [h, this, mul_smul, mul_smul, smul_left_cancel_iff, \u2190 TensorProduct.tmul_smul,\n      TensorProduct.smul_tmul']\n    simp only [Sum.map_inr, Perm.sumCongrHom_apply, Perm.sumCongr_apply, Sum.map_inl,\n      Function.comp_apply, Perm.coe_mul]\n    erw [\u2190 a.map_congr_perm fun i => v (\u03c3\u2081 _), \u2190 b.map_congr_perm fun i => v (\u03c3\u2081 _)]", "start": [50, 1], "end": [71, 85], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domCoprod.summand_mk''", "code": "theorem domCoprod.summand_mk'' (a : AlternatingMap R' M\u1d62 N\u2081 \u03b9a) (b : AlternatingMap R' M\u1d62 N\u2082 \u03b9b)\n    (\u03c3 : Equiv.Perm (Sum \u03b9a \u03b9b)) :\n    domCoprod.summand a b (Quotient.mk'' \u03c3) =\n      Equiv.Perm.sign \u03c3 \u2022\n        (MultilinearMap.domCoprod \u2191a \u2191b : MultilinearMap R' (fun _ => M\u1d62) (N\u2081 \u2297 N\u2082)).domDomCongr\n          \u03c3", "start": [74, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domCoprod.summand_add_swap_smul_eq_zero", "code": "theorem domCoprod.summand_add_swap_smul_eq_zero (a : AlternatingMap R' M\u1d62 N\u2081 \u03b9a)\n    (b : AlternatingMap R' M\u1d62 N\u2082 \u03b9b) (\u03c3 : Perm.ModSumCongr \u03b9a \u03b9b) {v : Sum \u03b9a \u03b9b \u2192 M\u1d62}\n    {i j : Sum \u03b9a \u03b9b} (hv : v i = v j) (hij : i \u2260 j) :\n    domCoprod.summand a b \u03c3 v + domCoprod.summand a b (swap i j \u2022 \u03c3) v = 0", "start": [83, 1], "end": [97, 39], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domCoprod.summand_eq_zero_of_smul_invariant", "code": "theorem domCoprod.summand_eq_zero_of_smul_invariant (a : AlternatingMap R' M\u1d62 N\u2081 \u03b9a)\n    (b : AlternatingMap R' M\u1d62 N\u2082 \u03b9b) (\u03c3 : Perm.ModSumCongr \u03b9a \u03b9b) {v : Sum \u03b9a \u03b9b \u2192 M\u1d62}\n    {i j : Sum \u03b9a \u03b9b} (hv : v i = v j) (hij : i \u2260 j) :\n    swap i j \u2022 \u03c3 = \u03c3 \u2192 domCoprod.summand a b \u03c3 v = 0", "start": [100, 1], "end": [138, 79], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domCoprod", "code": "@[simps]\ndef domCoprod (a : AlternatingMap R' M\u1d62 N\u2081 \u03b9a) (b : AlternatingMap R' M\u1d62 N\u2082 \u03b9b) :\n    AlternatingMap R' M\u1d62 (N\u2081 \u2297[R'] N\u2082) (Sum \u03b9a \u03b9b) :=\n  { \u2211 \u03c3 : Perm.ModSumCongr \u03b9a \u03b9b, domCoprod.summand a b \u03c3 with\n    toFun := fun v => (\u21d1(\u2211 \u03c3 : Perm.ModSumCongr \u03b9a \u03b9b, domCoprod.summand a b \u03c3)) v\n    map_eq_zero_of_eq' := fun v i j hv hij => by\n      dsimp only\n      rw [MultilinearMap.sum_apply]\n      exact\n        Finset.sum_involution (fun \u03c3 _ => Equiv.swap i j \u2022 \u03c3)\n          (fun \u03c3 _ => domCoprod.summand_add_swap_smul_eq_zero a b \u03c3 hv hij)\n          (fun \u03c3 _ => mt <| domCoprod.summand_eq_zero_of_smul_invariant a b \u03c3 hv hij)\n          (fun \u03c3 _ => Finset.mem_univ _) fun \u03c3 _ =>\n          Equiv.Perm.ModSumCongr.swap_smul_involutive i j \u03c3 }", "start": [141, 1], "end": [174, 62], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domCoprod_coe", "code": "theorem domCoprod_coe (a : AlternatingMap R' M\u1d62 N\u2081 \u03b9a) (b : AlternatingMap R' M\u1d62 N\u2082 \u03b9b) :\n    (\u2191(a.domCoprod b) : MultilinearMap R' (fun _ => M\u1d62) _) =\n      \u2211 \u03c3 : Perm.ModSumCongr \u03b9a \u03b9b, domCoprod.summand a b \u03c3", "start": [178, 1], "end": [181, 34], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domCoprod'", "code": "def domCoprod' :\n    AlternatingMap R' M\u1d62 N\u2081 \u03b9a \u2297[R'] AlternatingMap R' M\u1d62 N\u2082 \u03b9b \u2192\u2097[R']\n      AlternatingMap R' M\u1d62 (N\u2081 \u2297[R'] N\u2082) (Sum \u03b9a \u03b9b) :=\n  TensorProduct.lift <| by\n    refine'\n      LinearMap.mk\u2082 R' domCoprod (fun m\u2081 m\u2082 n => _) (fun c m n => _) (fun m n\u2081 n\u2082 => _)\n        fun c m n => _ <;>\n    \u00b7 ext\n      simp only [domCoprod_apply, add_apply, smul_apply, \u2190 Finset.sum_add_distrib,\n        Finset.smul_sum, MultilinearMap.sum_apply, domCoprod.summand]\n      congr\n      ext \u03c3\n      refine Quotient.inductionOn' \u03c3 fun \u03c3 => ?_\n      simp only [Quotient.liftOn'_mk'', coe_add, coe_smul, MultilinearMap.smul_apply,\n        \u2190 MultilinearMap.domCoprod'_apply]\n      simp only [TensorProduct.add_tmul, \u2190 TensorProduct.smul_tmul', TensorProduct.tmul_add,\n        TensorProduct.tmul_smul, LinearMap.map_add, LinearMap.map_smul]\n      first | rw [\u2190 smul_add] | rw [smul_comm]\n      rfl", "start": [184, 1], "end": [204, 10], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domCoprod'_apply", "code": "@[simp]\ntheorem domCoprod'_apply (a : AlternatingMap R' M\u1d62 N\u2081 \u03b9a) (b : AlternatingMap R' M\u1d62 N\u2082 \u03b9b) :\n    domCoprod' (a \u2297\u209c[R'] b) = domCoprod a b", "start": [207, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.domCoprod_alternization_coe", "code": "theorem MultilinearMap.domCoprod_alternization_coe [DecidableEq \u03b9a] [DecidableEq \u03b9b]\n    (a : MultilinearMap R' (fun _ : \u03b9a => M\u1d62) N\u2081) (b : MultilinearMap R' (fun _ : \u03b9b => M\u1d62) N\u2082) :\n    MultilinearMap.domCoprod (MultilinearMap.alternatization a)\n      (MultilinearMap.alternatization b) =\n      \u2211 \u03c3a : Perm \u03b9a, \u2211 \u03c3b : Perm \u03b9b,\n        Equiv.Perm.sign \u03c3a \u2022 Equiv.Perm.sign \u03c3b \u2022\n          MultilinearMap.domCoprod (a.domDomCongr \u03c3a) (b.domDomCongr \u03c3b)", "start": [217, 1], "end": [228, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.domCoprod_alternization", "code": "theorem MultilinearMap.domCoprod_alternization [DecidableEq \u03b9a] [DecidableEq \u03b9b]\n    (a : MultilinearMap R' (fun _ : \u03b9a => M\u1d62) N\u2081) (b : MultilinearMap R' (fun _ : \u03b9b => M\u1d62) N\u2082) :\n    MultilinearMap.alternatization (MultilinearMap.domCoprod a b) =\n      a.alternatization.domCoprod (MultilinearMap.alternatization b)", "start": [233, 1], "end": [272, 91], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.domCoprod_alternization_eq", "code": "theorem MultilinearMap.domCoprod_alternization_eq [DecidableEq \u03b9a] [DecidableEq \u03b9b]\n    (a : AlternatingMap R' M\u1d62 N\u2081 \u03b9a) (b : AlternatingMap R' M\u1d62 N\u2082 \u03b9b) :\n    MultilinearMap.alternatization\n      (MultilinearMap.domCoprod a b : MultilinearMap R' (fun _ : Sum \u03b9a \u03b9b => M\u1d62) (N\u2081 \u2297 N\u2082)) =\n      ((Fintype.card \u03b9a).factorial * (Fintype.card \u03b9b).factorial) \u2022 a.domCoprod b", "start": [275, 1], "end": [287, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Multilinear/FiniteDimensional.lean", "imports": ["Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean", "Mathlib/LinearAlgebra/Multilinear/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MultilinearMap.free_and_finite_fin", "code": "private theorem free_and_finite_fin (n : \u2115) (N : Fin n \u2192 Type*) [\u2200 i, AddCommGroup (N i)]\n    [\u2200 i, Module R (N i)] [\u2200 i, Module.Finite R (N i)] [\u2200 i, Module.Free R (N i)] :\n    Module.Free R (MultilinearMap R N M\u2082) \u2227 Module.Finite R (MultilinearMap R N M\u2082)", "start": [35, 1], "end": [51, 69], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.free_and_finite", "code": "private theorem free_and_finite :\n    Module.Free R (MultilinearMap R M\u2081 M\u2082) \u2227 Module.Finite R (MultilinearMap R M\u2081 M\u2082)", "start": [58, 1], "end": [65, 66], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.multilinearMap", "code": "instance _root_.Module.Finite.multilinearMap : Module.Finite R (MultilinearMap R M\u2081 M\u2082) :=\n  free_and_finite.2", "start": [67, 1], "end": [68, 20], "kind": "commanddeclaration"}, {"full_name": "Module.Free.multilinearMap", "code": "instance _root_.Module.Free.multilinearMap : Module.Free R (MultilinearMap R M\u2081 M\u2082) :=\n  free_and_finite.1", "start": [71, 1], "end": [72, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/BinaryHeap.lean", "imports": ["Mathlib/Data/Fin/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "BinaryHeap", "code": "structure BinaryHeap (\u03b1) (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) where\n  arr : Array \u03b1", "start": [10, 1], "end": [12, 16], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.heapifyDown", "code": "def heapifyDown (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) (a : Array \u03b1) (i : Fin a.size) :\n    {a' : Array \u03b1 // a'.size = a.size} :=\n  let left := 2 * i.1 + 1\n  let right := left + 1\n  have left_le : i \u2264 left := Nat.le_trans\n    (by rw [Nat.succ_mul, Nat.one_mul]; exact Nat.le_add_left i i)\n    (Nat.le_add_right ..)\n  have right_le : i \u2264 right := Nat.le_trans left_le (Nat.le_add_right ..)\n  have i_le : i \u2264 i := Nat.le_refl _\n  have j : {j : Fin a.size // i \u2264 j} := if h : left < a.size then\n    if lt (a.get i) (a.get \u27e8left, h\u27e9) then \u27e8\u27e8left, h\u27e9, left_le\u27e9 else \u27e8i, i_le\u27e9 else \u27e8i, i_le\u27e9\n  have j := if h : right < a.size then\n    if lt (a.get j) (a.get \u27e8right, h\u27e9) then \u27e8\u27e8right, h\u27e9, right_le\u27e9 else j else j\n  if h : i.1 = j then \u27e8a, rfl\u27e9 else\n    let a' := a.swap i j\n    let j' := \u27e8j, by rw [a.size_swap i j]; exact j.1.2\u27e9\n    have : a'.size - j < a.size - i := by\n      rw [a.size_swap i j]; exact Nat.sub_lt_sub_left i.2 <| Nat.lt_of_le_of_ne j.2 h\n    let \u27e8a\u2082, h\u2082\u27e9 := heapifyDown lt a' j'\n    \u27e8a\u2082, h\u2082.trans (a.size_swap i j)\u27e9\ntermination_by _ => a.size - i\ndecreasing_by assumption", "start": [16, 1], "end": [39, 25], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.size_heapifyDown", "code": "@[simp] theorem size_heapifyDown (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) (a : Array \u03b1) (i : Fin a.size) :\n  (heapifyDown lt a i).1.size = a.size", "start": [41, 1], "end": [42, 65], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.mkHeap", "code": "def mkHeap (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) (a : Array \u03b1) : {a' : Array \u03b1 // a'.size = a.size} :=\n  let rec loop : (i : Nat) \u2192 (a : Array \u03b1) \u2192 i \u2264 a.size \u2192 {a' : Array \u03b1 // a'.size = a.size}\n  | 0, a, _ => \u27e8a, rfl\u27e9\n  | i+1, a, h =>\n    let h := Nat.lt_of_succ_le h\n    let a' := heapifyDown lt a \u27e8i, h\u27e9\n    let \u27e8a\u2082, h\u2082\u27e9 := loop i a' ((heapifyDown ..).2.symm \u25b8 le_of_lt h)\n    \u27e8a\u2082, h\u2082.trans a'.2\u27e9\n  loop (a.size / 2) a (Nat.div_le_self ..)", "start": [44, 1], "end": [54, 43], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.size_mkHeap", "code": "@[simp] theorem size_mkHeap (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) (a : Array \u03b1) :\n  (mkHeap lt a).1.size = a.size", "start": [56, 1], "end": [57, 51], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.heapifyUp", "code": "def heapifyUp (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) (a : Array \u03b1) (i : Fin a.size) :\n    {a' : Array \u03b1 // a'.size = a.size} :=\nif i0 : i.1 = 0 then \u27e8a, rfl\u27e9 else\n  have : (i.1 - 1) / 2 < i := lt_of_le_of_lt (Nat.div_le_self ..) $\n    Nat.sub_lt (Nat.pos_iff_ne_zero.2 i0) Nat.one_pos\n  let j := \u27e8(i.1 - 1) / 2, lt_trans this i.2\u27e9\n  if lt (a.get j) (a.get i) then\n    let a' := a.swap i j\n    let \u27e8a\u2082, h\u2082\u27e9 := heapifyUp lt a' \u27e8j.1, by rw [a.size_swap i j]; exact j.2\u27e9\n    \u27e8a\u2082, h\u2082.trans (a.size_swap i j)\u27e9\n  else \u27e8a, rfl\u27e9\ntermination_by _ => i.1\ndecreasing_by assumption", "start": [59, 1], "end": [73, 25], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.size_heapifyUp", "code": "@[simp] theorem size_heapifyUp (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) (a : Array \u03b1) (i : Fin a.size) :\n  (heapifyUp lt a i).1.size = a.size", "start": [75, 1], "end": [76, 61], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.empty", "code": "def empty (lt) : BinaryHeap \u03b1 lt := \u27e8#[]\u27e9", "start": [78, 1], "end": [79, 42], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.singleton", "code": "def singleton (lt) (x : \u03b1) : BinaryHeap \u03b1 lt := \u27e8#[x]\u27e9", "start": [84, 1], "end": [85, 55], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.size", "code": "def size {lt} (self : BinaryHeap \u03b1 lt) : Nat := self.1.size", "start": [87, 1], "end": [88, 60], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.get", "code": "def get {lt} (self : BinaryHeap \u03b1 lt) (i : Fin self.size) : \u03b1 := self.1.get i", "start": [90, 1], "end": [91, 78], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.insert", "code": "def insert {lt} (self : BinaryHeap \u03b1 lt) (x : \u03b1) : BinaryHeap \u03b1 lt where\n  arr := let n := self.size;\n    heapifyUp lt (self.1.push x) \u27e8n, by rw [Array.size_push]; apply Nat.lt_succ_self\u27e9", "start": [93, 1], "end": [96, 86], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.size_insert", "code": "@[simp] theorem size_insert {lt} (self : BinaryHeap \u03b1 lt) (x : \u03b1) :\n  (self.insert x).size = self.size + 1", "start": [98, 1], "end": [100, 38], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.max", "code": "def max {lt} (self : BinaryHeap \u03b1 lt) : Option \u03b1 := self.1.get? 0", "start": [102, 1], "end": [103, 66], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.popMaxAux", "code": "def popMaxAux {lt} (self : BinaryHeap \u03b1 lt) : {a' : BinaryHeap \u03b1 lt // a'.size = self.size - 1} :=\n  match e: self.1.size with\n  | 0 => \u27e8self, by simp [size, e]\u27e9\n  | n+1 =>\n    have h0 := by rw [e]; apply Nat.succ_pos\n    have hn := by rw [e]; apply Nat.lt_succ_self\n    if hn0 : 0 < n then\n      let a := self.1.swap \u27e80, h0\u27e9 \u27e8n, hn\u27e9 |>.pop\n      \u27e8\u27e8heapifyDown lt a \u27e80, by rwa [Array.size_pop, Array.size_swap, e]\u27e9\u27e9,\n        by simp [size]\u27e9\n    else\n      \u27e8\u27e8self.1.pop\u27e9, by simp [size]\u27e9", "start": [105, 1], "end": [117, 37], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.popMax", "code": "def popMax {lt} (self : BinaryHeap \u03b1 lt) : BinaryHeap \u03b1 lt := self.popMaxAux", "start": [119, 1], "end": [121, 77], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.size_popMax", "code": "@[simp] theorem size_popMax {lt} (self : BinaryHeap \u03b1 lt) :\n  self.popMax.size = self.size - 1", "start": [123, 1], "end": [124, 55], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.extractMax", "code": "def extractMax {lt} (self : BinaryHeap \u03b1 lt) : Option \u03b1 \u00d7 BinaryHeap \u03b1 lt :=\n  (self.max, self.popMax)", "start": [126, 1], "end": [128, 26], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.size_pos_of_max", "code": "theorem size_pos_of_max {lt} {self : BinaryHeap \u03b1 lt} (e : self.max = some x) : 0 < self.size", "start": [130, 1], "end": [131, 95], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.insertExtractMax", "code": "def insertExtractMax {lt} (self : BinaryHeap \u03b1 lt) (x : \u03b1) : \u03b1 \u00d7 BinaryHeap \u03b1 lt :=\n  match e: self.max with\n  | none => (x, self)\n  | some m =>\n    if lt x m then\n      let a := self.1.set \u27e80, size_pos_of_max e\u27e9 x\n      (m, \u27e8heapifyDown lt a \u27e80, by simp; exact size_pos_of_max e\u27e9\u27e9)\n    else (x, self)", "start": [133, 1], "end": [141, 19], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.replaceMax", "code": "def replaceMax {lt} (self : BinaryHeap \u03b1 lt) (x : \u03b1) : Option \u03b1 \u00d7 BinaryHeap \u03b1 lt :=\n  match e: self.max with\n  | none => (none, \u27e8self.1.push x\u27e9)\n  | some m =>\n    let a := self.1.set \u27e80, size_pos_of_max e\u27e9 x\n    (some m, \u27e8heapifyDown lt a \u27e80, by simp; exact size_pos_of_max e\u27e9\u27e9)", "start": [143, 1], "end": [149, 71], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.decreaseKey", "code": "def decreaseKey {lt} (self : BinaryHeap \u03b1 lt) (i : Fin self.size) (x : \u03b1) : BinaryHeap \u03b1 lt where\n  arr := heapifyDown lt (self.1.set i x) \u27e8i, by rw [self.1.size_set]; exact i.2\u27e9", "start": [151, 1], "end": [153, 81], "kind": "commanddeclaration"}, {"full_name": "BinaryHeap.increaseKey", "code": "def increaseKey {lt} (self : BinaryHeap \u03b1 lt) (i : Fin self.size) (x : \u03b1) : BinaryHeap \u03b1 lt where\n  arr := heapifyUp lt (self.1.set i x) \u27e8i, by rw [self.1.size_set]; exact i.2\u27e9", "start": [155, 1], "end": [157, 79], "kind": "commanddeclaration"}, {"full_name": "Array.toBinaryHeap", "code": "def Array.toBinaryHeap (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) (a : Array \u03b1) : BinaryHeap \u03b1 lt where\n  arr := BinaryHeap.mkHeap lt a", "start": [161, 1], "end": [163, 32], "kind": "commanddeclaration"}, {"full_name": "Array.heapSort", "code": "@[specialize] def Array.heapSort (a : Array \u03b1) (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) : Array \u03b1 :=\n  let gt y x := lt x y\n  let rec loop (a : BinaryHeap \u03b1 gt) (out : Array \u03b1) : Array \u03b1 :=\n    match e: a.max with\n    | none => out\n    | some x =>\n      have : a.popMax.size < a.size := by\n        simp; exact Nat.sub_lt (BinaryHeap.size_pos_of_max e) Nat.zero_lt_one\n      loop a.popMax (out.push x)\n  loop (a.toBinaryHeap gt) #[]\ntermination_by _ => a.size\ndecreasing_by assumption", "start": [165, 1], "end": [177, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Liouville/LiouvilleNumber.lean", "imports": ["Mathlib/NumberTheory/Liouville/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "liouvilleNumber", "code": "def liouvilleNumber (m : \u211d) : \u211d :=\n  \u2211' i : \u2115, 1 / m ^ i !", "start": [42, 1], "end": [50, 24], "kind": "commanddeclaration"}, {"full_name": "LiouvilleNumber.partialSum", "code": "def partialSum (m : \u211d) (k : \u2115) : \u211d :=\n  \u2211 i in range (k + 1), 1 / m ^ i !", "start": [55, 1], "end": [62, 36], "kind": "commanddeclaration"}, {"full_name": "LiouvilleNumber.remainder", "code": "def remainder (m : \u211d) (k : \u2115) : \u211d :=\n  \u2211' i, 1 / m ^ (i + (k + 1))!", "start": [65, 1], "end": [72, 31], "kind": "commanddeclaration"}, {"full_name": "LiouvilleNumber.summable", "code": "protected theorem summable {m : \u211d} (hm : 1 < m) : Summable fun i : \u2115 => 1 / m ^ i !", "start": [80, 1], "end": [81, 54], "kind": "commanddeclaration"}, {"full_name": "LiouvilleNumber.remainder_summable", "code": "theorem remainder_summable {m : \u211d} (hm : 1 < m) (k : \u2115) :\n    Summable fun i : \u2115 => 1 / m ^ (i + (k + 1))!", "start": [84, 1], "end": [86, 73], "kind": "commanddeclaration"}, {"full_name": "LiouvilleNumber.remainder_pos", "code": "theorem remainder_pos {m : \u211d} (hm : 1 < m) (k : \u2115) : 0 < remainder m k", "start": [89, 1], "end": [90, 80], "kind": "commanddeclaration"}, {"full_name": "LiouvilleNumber.partialSum_succ", "code": "theorem partialSum_succ (m : \u211d) (n : \u2115) :\n    partialSum m (n + 1) = partialSum m n + 1 / m ^ (n + 1)!", "start": [93, 1], "end": [95, 21], "kind": "commanddeclaration"}, {"full_name": "LiouvilleNumber.partialSum_add_remainder", "code": "theorem partialSum_add_remainder {m : \u211d} (hm : 1 < m) (k : \u2115) :\n    partialSum m k + remainder m k = liouvilleNumber m", "start": [98, 1], "end": [101, 55], "kind": "commanddeclaration"}, {"full_name": "LiouvilleNumber.remainder_lt'", "code": "theorem remainder_lt' (n : \u2115) {m : \u211d} (m1 : 1 < m) :\n    remainder m n < (1 - 1 / m)\u207b\u00b9 * (1 / m ^ (n + 1)!)", "start": [107, 1], "end": [134, 96], "kind": "commanddeclaration"}, {"full_name": "LiouvilleNumber.aux_calc", "code": "theorem aux_calc (n : \u2115) {m : \u211d} (hm : 2 \u2264 m) :\n    (1 - 1 / m)\u207b\u00b9 * (1 / m ^ (n + 1)!) \u2264 1 / (m ^ n !) ^ n", "start": [137, 1], "end": [159, 69], "kind": "commanddeclaration"}, {"full_name": "LiouvilleNumber.remainder_lt", "code": "theorem remainder_lt (n : \u2115) {m : \u211d} (m2 : 2 \u2264 m) : remainder m n < 1 / (m ^ n !) ^ n", "start": [162, 1], "end": [166, 71], "kind": "commanddeclaration"}, {"full_name": "LiouvilleNumber.partialSum_eq_rat", "code": "theorem partialSum_eq_rat {m : \u2115} (hm : 0 < m) (k : \u2115) :\n    \u2203 p : \u2115, partialSum m k = p / (m ^ k ! : \u211d)", "start": [172, 1], "end": [185, 25], "kind": "commanddeclaration"}, {"full_name": "liouville_liouvilleNumber", "code": "theorem liouville_liouvilleNumber {m : \u2115} (hm : 2 \u2264 m) : Liouville (liouvilleNumber m)", "start": [192, 1], "end": [205, 85], "kind": "commanddeclaration"}, {"full_name": "transcendental_liouvilleNumber", "code": "theorem transcendental_liouvilleNumber {m : \u2115} (hm : 2 \u2264 m) :\n    Transcendental \u2124 (liouvilleNumber m)", "start": [208, 1], "end": [210, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/ConnectedComponents.lean", "imports": ["Mathlib/CategoryTheory/FullSubcategory.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Sigma/Basic.lean", "Mathlib/Data/List/Chain.lean", "Mathlib/CategoryTheory/IsConnected.lean"], "premises": [{"full_name": "CategoryTheory.ConnectedComponents", "code": "def ConnectedComponents (J : Type u\u2081) [Category.{v\u2081} J] : Type u\u2081 :=\n  Quotient (Zigzag.setoid J)", "start": [42, 1], "end": [44, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Component", "code": "def Component (j : ConnectedComponents J) : Type u\u2081 :=\n  FullSubcategory fun k => Quotient.mk'' k = j", "start": [50, 1], "end": [52, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Component.\u03b9", "code": "@[simps!]\ndef Component.\u03b9 (j : ConnectedComponents J) : Component j \u2964 J :=\n  fullSubcategoryInclusion _", "start": [59, 1], "end": [62, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Decomposed", "code": "abbrev Decomposed (J : Type u\u2081) [Category.{v\u2081} J] :=\n  \u03a3j : ConnectedComponents J, Component j", "start": [104, 1], "end": [109, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.inclusion", "code": "abbrev inclusion (j : ConnectedComponents J) : Component j \u2964 Decomposed J :=\n  Sigma.incl _", "start": [113, 1], "end": [118, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.decomposedTo", "code": "@[simps!]\ndef decomposedTo (J : Type u\u2081) [Category.{v\u2081} J] : Decomposed J \u2964 J :=\n  Sigma.desc Component.\u03b9", "start": [122, 1], "end": [125, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.inclusion_comp_decomposedTo", "code": "@[simp]\ntheorem inclusion_comp_decomposedTo (j : ConnectedComponents J) :\n    inclusion j \u22d9 decomposedTo J = Component.\u03b9 j", "start": [128, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.decomposedEquiv", "code": "@[simps! functor]\ndef decomposedEquiv : Decomposed J \u224c J :=\n  (decomposedTo J).asEquivalence", "start": [163, 1], "end": [166, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Order/UpperLower.lean", "imports": ["Mathlib/Analysis/Normed/Order/Basic.lean", "Mathlib/Analysis/Normed/Group/Pointwise.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Algebra/Order/UpperLower.lean", "Mathlib/Algebra/Order/Field/Pi.lean"], "premises": [{"full_name": "IsUpperSet.thickening'", "code": "@[to_additive IsUpperSet.thickening]\nprotected theorem IsUpperSet.thickening' (hs : IsUpperSet s) (\u03b5 : \u211d) :\n    IsUpperSet (thickening \u03b5 s)", "start": [33, 1], "end": [37, 20], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.thickening'", "code": "@[to_additive IsLowerSet.thickening]\nprotected theorem IsLowerSet.thickening' (hs : IsLowerSet s) (\u03b5 : \u211d) :\n    IsLowerSet (thickening \u03b5 s)", "start": [41, 1], "end": [45, 20], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.cthickening'", "code": "@[to_additive IsUpperSet.cthickening]\nprotected theorem IsUpperSet.cthickening' (hs : IsUpperSet s) (\u03b5 : \u211d) :\n    IsUpperSet (cthickening \u03b5 s)", "start": [49, 1], "end": [53, 55], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.cthickening'", "code": "@[to_additive IsLowerSet.cthickening]\nprotected theorem IsLowerSet.cthickening' (hs : IsLowerSet s) (\u03b5 : \u211d) :\n    IsLowerSet (cthickening \u03b5 s)", "start": [57, 1], "end": [61, 55], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.mem_interior_of_forall_lt", "code": "theorem IsUpperSet.mem_interior_of_forall_lt (hs : IsUpperSet s) (hx : x \u2208 closure s)\n    (h : \u2200 i, x i < y i) : y \u2208 interior s", "start": [74, 1], "end": [89, 73], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.mem_interior_of_forall_lt", "code": "theorem IsLowerSet.mem_interior_of_forall_lt (hs : IsLowerSet s) (hx : x \u2208 closure s)\n    (h : \u2200 i, y i < x i) : y \u2208 interior s", "start": [92, 1], "end": [108, 51], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.exists_subset_ball", "code": "theorem IsUpperSet.exists_subset_ball (hs : IsUpperSet s) (hx : x \u2208 closure s) (h\u03b4 : 0 < \u03b4) :\n    \u2203 y, closedBall y (\u03b4 / 4) \u2286 closedBall x \u03b4 \u2227 closedBall y (\u03b4 / 4) \u2286 interior s", "start": [117, 1], "end": [133, 11], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.exists_subset_ball", "code": "theorem IsLowerSet.exists_subset_ball (hs : IsLowerSet s) (hx : x \u2208 closure s) (h\u03b4 : 0 < \u03b4) :\n    \u2203 y, closedBall y (\u03b4 / 4) \u2286 closedBall x \u03b4 \u2227 closedBall y (\u03b4 / 4) \u2286 interior s", "start": [136, 1], "end": [152, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Abelian/Generator.lean", "imports": ["Mathlib/CategoryTheory/Limits/EssentiallySmall.lean", "Mathlib/CategoryTheory/Preadditive/Generator.lean", "Mathlib/CategoryTheory/Preadditive/Injective.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Abelian/Subobject.lean", "Mathlib/CategoryTheory/Abelian/Opposite.lean"], "premises": [{"full_name": "CategoryTheory.Abelian.has_injective_coseparator", "code": "theorem has_injective_coseparator [HasLimits C] [EnoughInjectives C] (G : C) (hG : IsSeparator G) :\n    \u2203 G : C, Injective G \u2227 IsCoseparator G", "start": [35, 1], "end": [52, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.has_projective_separator", "code": "theorem has_projective_separator [HasColimits C] [EnoughProjectives C] (G : C)\n    (hG : IsCoseparator G) : \u2203 G : C, Projective G \u2227 IsSeparator G", "start": [55, 1], "end": [58, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/HierarchyDesign.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Util/LibraryNote.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Data/MLList/DepthFirst.lean", "imports": ["lake-packages/std/Std/Data/MLList/Basic.lean", "Mathlib/Control/Traversable/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "depthFirst'", "code": "partial def depthFirst' (f : Nat \u2192 \u03b1 \u2192 m \u03b1) (n : Nat) (a : \u03b1) : m \u03b1 :=\npure a <|> joinM ((f n a) <&> (depthFirst' f (n+1)))", "start": [26, 1], "end": [29, 53], "kind": "commanddeclaration"}, {"full_name": "depthFirst", "code": "def depthFirst (f : \u03b1 \u2192 m \u03b1) (a : \u03b1) (maxDepth : Option Nat := none) : m \u03b1 :=\n  match maxDepth with\n  | some d => depthFirst' (fun n a => if n \u2264 d then f a else failure) 0 a\n  | none => depthFirst' (fun _ a => f a) 0 a", "start": [31, 1], "end": [46, 45], "kind": "commanddeclaration"}, {"full_name": "depthFirstRemovingDuplicates", "code": "def depthFirstRemovingDuplicates {\u03b1 : Type u} [BEq \u03b1] [Hashable \u03b1]\n    (f : \u03b1 \u2192 MLList m \u03b1) (a : \u03b1) (maxDepth : Option Nat := none) : MLList m \u03b1 :=\nlet f' : \u03b1 \u2192 MLList (StateT.{u} (HashSet \u03b1) m) \u03b1 := fun a =>\n  (f a).liftM >>= fun b => do\n    let s \u2190 get\n    if s.contains b then failure\n    set <| s.insert b\n    pure b\n(depthFirst f' a maxDepth).runState' (HashSet.empty.insert a)", "start": [53, 1], "end": [74, 62], "kind": "commanddeclaration"}, {"full_name": "depthFirstRemovingDuplicates'", "code": "def depthFirstRemovingDuplicates' [BEq \u03b1] [Hashable \u03b1]\n    (f : \u03b1 \u2192 List \u03b1) (a : \u03b1) (maxDepth : Option Nat := none) : List \u03b1 :=\ndepthFirstRemovingDuplicates\n  (fun a => (.ofList (f a) : MLList Option \u03b1)) a maxDepth |>.force |>.get!", "start": [76, 1], "end": [85, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Booleanisation.lean", "imports": ["Mathlib/Order/Hom/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Booleanisation", "code": "def Booleanisation (\u03b1 : Type*) := \u03b1 \u2295 \u03b1", "start": [34, 1], "end": [38, 40], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instDecidableEq", "code": "instance instDecidableEq [DecidableEq \u03b1] : DecidableEq (Booleanisation \u03b1) := Sum.instDecidableEqSum", "start": [42, 1], "end": [42, 100], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.lift", "code": "@[match_pattern] def lift : \u03b1 \u2192 Booleanisation \u03b1 := Sum.inl", "start": [46, 1], "end": [48, 60], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.comp", "code": "@[match_pattern] def comp : \u03b1 \u2192 Booleanisation \u03b1 := Sum.inr", "start": [50, 1], "end": [51, 60], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.LE", "code": "protected inductive LE : Booleanisation \u03b1 \u2192 Booleanisation \u03b1 \u2192 Prop\n  | protected lift {a b} : a \u2264 b \u2192 Booleanisation.LE (lift a) (lift b)\n  | protected comp {a b} : a \u2264 b \u2192 Booleanisation.LE (comp b) (comp a)\n  | protected sep {a b} : Disjoint a b \u2192 Booleanisation.LE (lift a) (comp b)", "start": [53, 1], "end": [61, 77], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.LT", "code": "protected inductive LT : Booleanisation \u03b1 \u2192 Booleanisation \u03b1 \u2192 Prop\n  | protected lift {a b} : a < b \u2192 Booleanisation.LT (lift a) (lift b)\n  | protected comp {a b} : a < b \u2192 Booleanisation.LT (comp b) (comp a)\n  | protected sep {a b} : Disjoint a b \u2192 Booleanisation.LT (lift a) (comp b)", "start": [63, 1], "end": [71, 77], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instLE", "code": "@[inherit_doc Booleanisation.LE]\ninstance instLE : LE (Booleanisation \u03b1) where\n  le := Booleanisation.LE", "start": [73, 1], "end": [75, 26], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instLT", "code": "@[inherit_doc Booleanisation.LT]\ninstance instLT : LT (Booleanisation \u03b1) where\n  lt := Booleanisation.LT", "start": [77, 1], "end": [79, 26], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instSup", "code": "instance instSup : Sup (Booleanisation \u03b1) where\n  sup x y := match x, y with\n    | lift a, lift b => lift (a \u2294 b)\n    | lift a, comp b => comp (b \\ a)\n    | comp a, lift b => comp (a \\ b)\n    | comp a, comp b => comp (a \u2293 b)", "start": [81, 1], "end": [91, 37], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instInf", "code": "instance instInf : Inf (Booleanisation \u03b1) where\n  inf x y := match x, y with\n    | lift a, lift b => lift (a \u2293 b)\n    | lift a, comp b => lift (a \\ b)\n    | comp a, lift b => lift (b \\ a)\n    | comp a, comp b => comp (a \u2294 b)", "start": [93, 1], "end": [103, 37], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instBot", "code": "instance instBot : Bot (Booleanisation \u03b1) where\n  bot := lift \u22a5", "start": [105, 1], "end": [107, 16], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instTop", "code": "instance instTop : Top (Booleanisation \u03b1) where\n  top := comp \u22a5", "start": [109, 1], "end": [111, 16], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instCompl", "code": "instance instCompl : HasCompl (Booleanisation \u03b1) where\n  compl x := match x with\n    | lift a => comp a\n    | comp a => lift a", "start": [113, 1], "end": [117, 23], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instSDiff", "code": "instance instSDiff : SDiff (Booleanisation \u03b1) where\n  sdiff x y := match x, y with\n    | lift a, lift b => lift (a \\ b)\n    | lift a, comp b => lift (a \u2293 b)\n    | comp a, lift b => comp (a \u2294 b)\n    | comp a, comp b => lift (b \\ a)", "start": [119, 1], "end": [129, 37], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.lift_le_lift", "code": "@[simp] lemma lift_le_lift : lift a \u2264 lift b \u2194 a \u2264 b := \u27e8by rintro \u27e8_\u27e9; assumption, LE.lift\u27e9", "start": [131, 1], "end": [131, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.comp_le_comp", "code": "@[simp] lemma comp_le_comp : comp a \u2264 comp b \u2194 b \u2264 a := \u27e8by rintro \u27e8_\u27e9; assumption, LE.comp\u27e9", "start": [132, 1], "end": [132, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.lift_le_comp", "code": "@[simp] lemma lift_le_comp : lift a \u2264 comp b \u2194 Disjoint a b := \u27e8by rintro \u27e8_\u27e9; assumption, LE.sep\u27e9", "start": [133, 1], "end": [133, 99], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.not_comp_le_lift", "code": "@[simp] lemma not_comp_le_lift : \u00ac comp a \u2264 lift b := \u03bb h \u21a6 nomatch h", "start": [134, 1], "end": [134, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.lift_lt_lift", "code": "@[simp] lemma lift_lt_lift : lift a < lift b \u2194 a < b := \u27e8by rintro \u27e8_\u27e9; assumption, LT.lift\u27e9", "start": [136, 1], "end": [136, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.comp_lt_comp", "code": "@[simp] lemma comp_lt_comp : comp a < comp b \u2194 b < a := \u27e8by rintro \u27e8_\u27e9; assumption, LT.comp\u27e9", "start": [137, 1], "end": [137, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.lift_lt_comp", "code": "@[simp] lemma lift_lt_comp : lift a < comp b \u2194 Disjoint a b := \u27e8by rintro \u27e8_\u27e9; assumption, LT.sep\u27e9", "start": [138, 1], "end": [138, 99], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.not_comp_lt_lift", "code": "@[simp] lemma not_comp_lt_lift : \u00ac comp a < lift b := \u03bb h \u21a6 nomatch h", "start": [139, 1], "end": [139, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.lift_sup_lift", "code": "@[simp] lemma lift_sup_lift (a b : \u03b1) : lift a \u2294 lift b = lift (a \u2294 b) := rfl", "start": [141, 1], "end": [141, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.lift_sup_comp", "code": "@[simp] lemma lift_sup_comp (a b : \u03b1) : lift a \u2294 comp b = comp (b \\ a) := rfl", "start": [142, 1], "end": [142, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.comp_sup_lift", "code": "@[simp] lemma comp_sup_lift (a b : \u03b1) : comp a \u2294 lift b = comp (a \\ b) := rfl", "start": [143, 1], "end": [143, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.comp_sup_comp", "code": "@[simp] lemma comp_sup_comp (a b : \u03b1) : comp a \u2294 comp b = comp (a \u2293 b) := rfl", "start": [144, 1], "end": [144, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.lift_inf_lift", "code": "@[simp] lemma lift_inf_lift (a b : \u03b1) : lift a \u2293 lift b = lift (a \u2293 b) := rfl", "start": [146, 1], "end": [146, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.lift_inf_comp", "code": "@[simp] lemma lift_inf_comp (a b : \u03b1) : lift a \u2293 comp b = lift (a \\ b) := rfl", "start": [147, 1], "end": [147, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.comp_inf_lift", "code": "@[simp] lemma comp_inf_lift (a b : \u03b1) : comp a \u2293 lift b = lift (b \\ a) := rfl", "start": [148, 1], "end": [148, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.comp_inf_comp", "code": "@[simp] lemma comp_inf_comp (a b : \u03b1) : comp a \u2293 comp b = comp (a \u2294 b) := rfl", "start": [149, 1], "end": [149, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.lift_bot", "code": "@[simp] lemma lift_bot : lift (\u22a5 : \u03b1) = \u22a5 := rfl", "start": [151, 1], "end": [151, 49], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.comp_bot", "code": "@[simp] lemma comp_bot : comp (\u22a5 : \u03b1) = \u22a4 := rfl", "start": [152, 1], "end": [152, 49], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.compl_lift", "code": "@[simp] lemma compl_lift (a : \u03b1) : (lift a)\u1d9c = comp a := rfl", "start": [154, 1], "end": [154, 61], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.compl_comp", "code": "@[simp] lemma compl_comp (a : \u03b1) : (comp a)\u1d9c = lift a := rfl", "start": [155, 1], "end": [155, 61], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.lift_sdiff_lift", "code": "@[simp] lemma lift_sdiff_lift (a b : \u03b1) : lift a \\ lift b = lift (a \\ b) := rfl", "start": [157, 1], "end": [157, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.lift_sdiff_comp", "code": "@[simp] lemma lift_sdiff_comp (a b : \u03b1) : lift a \\ comp b = lift (a \u2293 b) := rfl", "start": [158, 1], "end": [158, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.comp_sdiff_lift", "code": "@[simp] lemma comp_sdiff_lift (a b : \u03b1) : comp a \\ lift b = comp (a \u2294 b) := rfl", "start": [159, 1], "end": [159, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.comp_sdiff_comp", "code": "@[simp] lemma comp_sdiff_comp (a b : \u03b1) : comp a \\ comp b = lift (b \\ a) := rfl", "start": [160, 1], "end": [160, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Booleanisation.instPreorder", "code": "instance instPreorder : Preorder (Booleanisation \u03b1) where\n  lt := (\u00b7 < \u00b7)\n  lt_iff_le_not_le x y := match x, y with\n    | lift a, lift b => by simp [lt_iff_le_not_le]\n    | lift a, comp b => by simp\n    | comp a, lift b => by simp\n    | comp a, comp b => by simp [lt_iff_le_not_le]\n  le_refl x := match x with\n    | lift a => LE.lift le_rfl\n    | comp a => LE.comp le_rfl\n  le_trans x y z hxy hyz := match x, y, z, hxy, hyz with\n    | lift a, lift b, lift c, LE.lift hab, LE.lift hbc => LE.lift $ hab.trans hbc\n    | lift a, lift b, comp c, LE.lift hab, LE.sep hbc => LE.sep $ hbc.mono_left hab\n    | lift a, comp b, comp c, LE.sep hab, LE.comp hcb => LE.sep $ hab.mono_right hcb\n    | comp a, comp b, comp c, LE.comp hba, LE.comp hcb => LE.comp $ hcb.trans hba", "start": [162, 1], "end": [176, 82], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instPartialOrder", "code": "instance instPartialOrder : PartialOrder (Booleanisation \u03b1) where\n  le_antisymm x y hxy hyx := match x, y, hxy, hyx with\n    | lift a, lift b, LE.lift hab, LE.lift hba => by rw [hab.antisymm hba]\n    | comp a, comp b, LE.comp hab, LE.comp hba => by rw [hab.antisymm hba]", "start": [178, 1], "end": [181, 75], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instSemilatticeSup", "code": "instance instSemilatticeSup : SemilatticeSup (Booleanisation \u03b1) where\n  le_sup_left x y := match x, y with\n    | lift a, lift b => LE.lift le_sup_left\n    | lift a, comp b => LE.sep disjoint_sdiff_self_right\n    | comp a, lift b => LE.comp sdiff_le\n    | comp a, comp b => LE.comp inf_le_left\n  le_sup_right x y := match x, y with\n    | lift a, lift b => LE.lift le_sup_right\n    | lift a, comp b => LE.comp sdiff_le\n    | comp a, lift b => LE.sep disjoint_sdiff_self_right\n    | comp a, comp b => LE.comp inf_le_right\n  sup_le x y z hxz hyz := match x, y, z, hxz, hyz with\n    | lift a, lift b, lift c, LE.lift hac, LE.lift hbc => LE.lift $ sup_le hac hbc\n    | lift a, lift b, comp c, LE.sep hac, LE.sep hbc => LE.sep $ hac.sup_left hbc\n    | lift a, comp b, comp c, LE.sep hac, LE.comp hcb => LE.comp $ le_sdiff.2 \u27e8hcb, hac.symm\u27e9\n    | comp a, lift b, comp c, LE.comp hca, LE.sep hbc => LE.comp $ le_sdiff.2 \u27e8hca, hbc.symm\u27e9\n    | comp a, comp b, comp c, LE.comp hca, LE.comp hcb => LE.comp $ le_inf hca hcb", "start": [185, 1], "end": [201, 83], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instSemilatticeInf", "code": "instance instSemilatticeInf : SemilatticeInf (Booleanisation \u03b1) where\n  inf_le_left x y := match x, y with\n    | lift a, lift b => LE.lift inf_le_left\n    | lift a, comp b => LE.lift sdiff_le\n    | comp a, lift b => LE.sep disjoint_sdiff_self_left\n    | comp a, comp b => LE.comp le_sup_left\n  inf_le_right x y := match x, y with\n    | lift a, lift b => LE.lift inf_le_right\n    | lift a, comp b => LE.sep disjoint_sdiff_self_left\n    | comp a, lift b => LE.lift sdiff_le\n    | comp a, comp b => LE.comp le_sup_right\n  le_inf x y z hxz hyz := match x, y, z, hxz, hyz with\n    | lift a, lift b, lift c, LE.lift hab, LE.lift hac => LE.lift $ le_inf hab hac\n    | lift a, lift b, comp c, LE.lift hab, LE.sep hac => LE.lift $ le_sdiff.2 \u27e8hab, hac\u27e9\n    | lift a, comp b, lift c, LE.sep hab, LE.lift hac => LE.lift $ le_sdiff.2 \u27e8hac, hab\u27e9\n    | lift a, comp b, comp c, LE.sep hab, LE.sep hac => LE.sep $ hab.sup_right hac\n    | comp a, comp b, comp c, LE.comp hba, LE.comp hca => LE.comp $ sup_le hba hca", "start": [205, 1], "end": [221, 83], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instDistribLattice", "code": "instance instDistribLattice : DistribLattice (Booleanisation \u03b1) where\n  inf_le_left _ _ := inf_le_left\n  inf_le_right _ _ := inf_le_right\n  le_inf _ _ _ := le_inf\n  le_sup_inf x y z := match x, y, z with\n    | lift a, lift b, lift c => LE.lift le_sup_inf\n    | lift a, lift b, comp c => LE.lift $ by simp [sup_left_comm, sup_comm]\n    | lift a, comp b, lift c => LE.lift $ by simp [sup_left_comm, sup_comm (a := b \\ a)]\n    | lift a, comp b, comp c => LE.comp $ by rw [sup_sdiff]\n    | comp a, lift b, lift c => LE.comp $ by rw [sdiff_inf]\n    | comp a, lift b, comp c => LE.comp $ by rw [sdiff_sdiff_right']\n    | comp a, comp b, lift c => LE.comp $ by rw [sdiff_sdiff_right', sup_comm]\n    | comp a, comp b, comp c => LE.comp inf_sup_left.le", "start": [223, 1], "end": [235, 56], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instBoundedOrder", "code": "instance instBoundedOrder : BoundedOrder (Booleanisation \u03b1) where\n  le_top x := match x with\n    | lift a => LE.sep disjoint_bot_right\n    | comp a => LE.comp bot_le\n  bot_le x := match x with\n    | lift a => LE.lift bot_le\n    | comp a => LE.sep disjoint_bot_left", "start": [239, 1], "end": [245, 41], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.instBooleanAlgebra", "code": "instance instBooleanAlgebra : BooleanAlgebra (Booleanisation \u03b1) where\n  le_top _ := le_top\n  bot_le _ := bot_le\n  inf_compl_le_bot x := match x with\n    | lift a => by simp\n    | comp a => by simp\n  top_le_sup_compl x := match x with\n    | lift a => by simp\n    | comp a => by simp\n  sdiff_eq x y := match x, y with\n    | lift a, lift b => by simp\n    | lift a, comp b => by simp\n    | comp a, lift b => by simp\n    | comp a, comp b => by simp", "start": [247, 1], "end": [260, 32], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.liftLatticeHom", "code": "def liftLatticeHom : LatticeHom \u03b1 (Booleanisation \u03b1) where\n  toFun := lift\n  map_sup' _ _ := rfl\n  map_inf' _ _ := rfl", "start": [262, 1], "end": [266, 22], "kind": "commanddeclaration"}, {"full_name": "Booleanisation.liftLatticeHom_injective", "code": "lemma liftLatticeHom_injective : Injective (liftLatticeHom (\u03b1 := \u03b1)) := Sum.inl_injective", "start": [268, 1], "end": [268, 90], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Analysis/Calculus/Taylor.lean", "imports": ["Mathlib/Analysis/Calculus/Deriv/Pow.lean", "Mathlib/Analysis/Calculus/MeanValue.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Polynomial/Module.lean", "Mathlib/Analysis/Calculus/IteratedDeriv.lean"], "premises": [{"full_name": "taylorCoeffWithin", "code": "noncomputable def taylorCoeffWithin (f : \u211d \u2192 E) (k : \u2115) (s : Set \u211d) (x\u2080 : \u211d) : E :=\n  (k ! : \u211d)\u207b\u00b9 \u2022 iteratedDerivWithin k f s x\u2080", "start": [54, 1], "end": [56, 45], "kind": "commanddeclaration"}, {"full_name": "taylorWithin", "code": "noncomputable def taylorWithin (f : \u211d \u2192 E) (n : \u2115) (s : Set \u211d) (x\u2080 : \u211d) : PolynomialModule \u211d E :=\n  (Finset.range (n + 1)).sum fun k =>\n    PolynomialModule.comp (Polynomial.X - Polynomial.C x\u2080)\n      (PolynomialModule.single \u211d k (taylorCoeffWithin f k s x\u2080))", "start": [59, 1], "end": [67, 65], "kind": "commanddeclaration"}, {"full_name": "taylorWithinEval", "code": "noncomputable def taylorWithinEval (f : \u211d \u2192 E) (n : \u2115) (s : Set \u211d) (x\u2080 x : \u211d) : E :=\n  PolynomialModule.eval x (taylorWithin f n s x\u2080)", "start": [70, 1], "end": [72, 50], "kind": "commanddeclaration"}, {"full_name": "taylorWithin_succ", "code": "theorem taylorWithin_succ (f : \u211d \u2192 E) (n : \u2115) (s : Set \u211d) (x\u2080 : \u211d) :\n    taylorWithin f (n + 1) s x\u2080 = taylorWithin f n s x\u2080 +\n      PolynomialModule.comp (Polynomial.X - Polynomial.C x\u2080)\n      (PolynomialModule.single \u211d (n + 1) (taylorCoeffWithin f (n + 1) s x\u2080))", "start": [75, 1], "end": [80, 29], "kind": "commanddeclaration"}, {"full_name": "taylorWithinEval_succ", "code": "@[simp]\ntheorem taylorWithinEval_succ (f : \u211d \u2192 E) (n : \u2115) (s : Set \u211d) (x\u2080 x : \u211d) :\n    taylorWithinEval f (n + 1) s x\u2080 x = taylorWithinEval f n s x\u2080 x +\n      (((n + 1 : \u211d) * n !)\u207b\u00b9 * (x - x\u2080) ^ (n + 1)) \u2022 iteratedDerivWithin (n + 1) f s x\u2080", "start": [83, 1], "end": [93, 17], "kind": "commanddeclaration"}, {"full_name": "taylor_within_zero_eval", "code": "@[simp]\ntheorem taylor_within_zero_eval (f : \u211d \u2192 E) (s : Set \u211d) (x\u2080 x : \u211d) :\n    taylorWithinEval f 0 s x\u2080 x = f x\u2080", "start": [96, 1], "end": [103, 7], "kind": "commanddeclaration"}, {"full_name": "taylorWithinEval_self", "code": "@[simp]\ntheorem taylorWithinEval_self (f : \u211d \u2192 E) (n : \u2115) (s : Set \u211d) (x\u2080 : \u211d) :\n    taylorWithinEval f n s x\u2080 x\u2080 = f x\u2080", "start": [106, 1], "end": [112, 12], "kind": "commanddeclaration"}, {"full_name": "taylor_within_apply", "code": "theorem taylor_within_apply (f : \u211d \u2192 E) (n : \u2115) (s : Set \u211d) (x\u2080 x : \u211d) :\n    taylorWithinEval f n s x\u2080 x =\n      \u2211 k in Finset.range (n + 1), ((k ! : \u211d)\u207b\u00b9 * (x - x\u2080) ^ k) \u2022 iteratedDerivWithin k f s x\u2080", "start": [115, 1], "end": [121, 23], "kind": "commanddeclaration"}, {"full_name": "continuousOn_taylorWithinEval", "code": "theorem continuousOn_taylorWithinEval {f : \u211d \u2192 E} {x : \u211d} {n : \u2115} {s : Set \u211d}\n    (hs : UniqueDiffOn \u211d s) (hf : ContDiffOn \u211d n f s) :\n    ContinuousOn (fun t => taylorWithinEval f n s t x) s", "start": [124, 1], "end": [137, 69], "kind": "commanddeclaration"}, {"full_name": "monomial_has_deriv_aux", "code": "theorem monomial_has_deriv_aux (t x : \u211d) (n : \u2115) :\n    HasDerivAt (fun y => (x - y) ^ (n + 1)) (-(n + 1) * (x - t) ^ n) t", "start": [140, 1], "end": [146, 41], "kind": "commanddeclaration"}, {"full_name": "hasDerivWithinAt_taylor_coeff_within", "code": "theorem hasDerivWithinAt_taylor_coeff_within {f : \u211d \u2192 E} {x y : \u211d} {k : \u2115} {s t : Set \u211d}\n    (ht : UniqueDiffWithinAt \u211d t y) (hs : s \u2208 \ud835\udcdd[t] y)\n    (hf : DifferentiableWithinAt \u211d (iteratedDerivWithin (k + 1) f s) s y) :\n    HasDerivWithinAt\n      (fun z => (((k + 1 : \u211d) * k !)\u207b\u00b9 * (x - z) ^ (k + 1)) \u2022 iteratedDerivWithin (k + 1) f s z)\n      ((((k + 1 : \u211d) * k !)\u207b\u00b9 * (x - y) ^ (k + 1)) \u2022 iteratedDerivWithin (k + 2) f s y -\n        ((k ! : \u211d)\u207b\u00b9 * (x - y) ^ k) \u2022 iteratedDerivWithin (k + 1) f s y) t y", "start": [149, 1], "end": [170, 41], "kind": "commanddeclaration"}, {"full_name": "hasDerivWithinAt_taylorWithinEval", "code": "theorem hasDerivWithinAt_taylorWithinEval {f : \u211d \u2192 E} {x y : \u211d} {n : \u2115} {s s' : Set \u211d}\n    (hs'_unique : UniqueDiffWithinAt \u211d s' y) (hs_unique : UniqueDiffOn \u211d s) (hs' : s' \u2208 \ud835\udcdd[s] y)\n    (hy : y \u2208 s') (h : s' \u2286 s) (hf : ContDiffOn \u211d n f s)\n    (hf' : DifferentiableWithinAt \u211d (iteratedDerivWithin n f s) s y) :\n    HasDerivWithinAt (fun t => taylorWithinEval f n s t x)\n      (((n ! : \u211d)\u207b\u00b9 * (x - y) ^ n) \u2022 iteratedDerivWithin (n + 1) f s y) s' y", "start": [173, 1], "end": [198, 41], "kind": "commanddeclaration"}, {"full_name": "taylorWithinEval_hasDerivAt_Ioo", "code": "theorem taylorWithinEval_hasDerivAt_Ioo {f : \u211d \u2192 E} {a b t : \u211d} (x : \u211d) {n : \u2115} (hx : a < b)\n    (ht : t \u2208 Ioo a b) (hf : ContDiffOn \u211d n f (Icc a b))\n    (hf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc a b)) (Ioo a b)) :\n    HasDerivAt (fun y => taylorWithinEval f n (Icc a b) y x)\n      (((n ! : \u211d)\u207b\u00b9 * (x - t) ^ n) \u2022 iteratedDerivWithin (n + 1) f (Icc a b) t) t", "start": [201, 1], "end": [212, 80], "kind": "commanddeclaration"}, {"full_name": "has_deriv_within_taylorWithinEval_at_Icc", "code": "theorem has_deriv_within_taylorWithinEval_at_Icc {f : \u211d \u2192 E} {a b t : \u211d} (x : \u211d) {n : \u2115}\n    (hx : a < b) (ht : t \u2208 Icc a b) (hf : ContDiffOn \u211d n f (Icc a b))\n    (hf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc a b)) (Icc a b)) :\n    HasDerivWithinAt (fun y => taylorWithinEval f n (Icc a b) y x)\n      (((n ! : \u211d)\u207b\u00b9 * (x - t) ^ n) \u2022 iteratedDerivWithin (n + 1) f (Icc a b) t) (Icc a b) t", "start": [215, 1], "end": [224, 52], "kind": "commanddeclaration"}, {"full_name": "taylor_mean_remainder", "code": "theorem taylor_mean_remainder {f : \u211d \u2192 \u211d} {g g' : \u211d \u2192 \u211d} {x x\u2080 : \u211d} {n : \u2115} (hx : x\u2080 < x)\n    (hf : ContDiffOn \u211d n f (Icc x\u2080 x))\n    (hf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x))\n    (gcont : ContinuousOn g (Icc x\u2080 x))\n    (gdiff : \u2200 x_1 : \u211d, x_1 \u2208 Ioo x\u2080 x \u2192 HasDerivAt g (g' x_1) x_1)\n    (g'_ne : \u2200 x_1 : \u211d, x_1 \u2208 Ioo x\u2080 x \u2192 g' x_1 \u2260 0) :\n    \u2203 (x' : \u211d) (_ : x' \u2208 Ioo x\u2080 x), f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n    ((x - x') ^ n / n ! * (g x - g x\u2080) / g' x') \u2022 iteratedDerivWithin (n + 1) f (Icc x\u2080 x) x'", "start": [230, 1], "end": [256, 7], "kind": "commanddeclaration"}, {"full_name": "taylor_mean_remainder_lagrange", "code": "theorem taylor_mean_remainder_lagrange {f : \u211d \u2192 \u211d} {x x\u2080 : \u211d} {n : \u2115} (hx : x\u2080 < x)\n    (hf : ContDiffOn \u211d n f (Icc x\u2080 x))\n    (hf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)) :\n    \u2203 (x' : \u211d) (_ : x' \u2208 Ioo x\u2080 x), f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n      iteratedDerivWithin (n + 1) f (Icc x\u2080 x) x' * (x - x\u2080) ^ (n + 1) / (n + 1)!", "start": [259, 1], "end": [288, 48], "kind": "commanddeclaration"}, {"full_name": "taylor_mean_remainder_cauchy", "code": "theorem taylor_mean_remainder_cauchy {f : \u211d \u2192 \u211d} {x x\u2080 : \u211d} {n : \u2115} (hx : x\u2080 < x)\n    (hf : ContDiffOn \u211d n f (Icc x\u2080 x))\n    (hf' : DifferentiableOn \u211d (iteratedDerivWithin n f (Icc x\u2080 x)) (Ioo x\u2080 x)) :\n    \u2203 (x' : \u211d) (_ : x' \u2208 Ioo x\u2080 x), f x - taylorWithinEval f n (Icc x\u2080 x) x\u2080 x =\n      iteratedDerivWithin (n + 1) f (Icc x\u2080 x) x' * (x - x') ^ n / n ! * (x - x\u2080)", "start": [291, 1], "end": [311, 7], "kind": "commanddeclaration"}, {"full_name": "taylor_mean_remainder_bound", "code": "theorem taylor_mean_remainder_bound {f : \u211d \u2192 E} {a b C x : \u211d} {n : \u2115} (hab : a \u2264 b)\n    (hf : ContDiffOn \u211d (n + 1) f (Icc a b)) (hx : x \u2208 Icc a b)\n    (hC : \u2200 y \u2208 Icc a b, \u2016iteratedDerivWithin (n + 1) f (Icc a b) y\u2016 \u2264 C) :\n    \u2016f x - taylorWithinEval f n (Icc a b) a x\u2016 \u2264 C * (x - a) ^ (n + 1) / n !", "start": [314, 1], "end": [354, 7], "kind": "commanddeclaration"}, {"full_name": "exists_taylor_mean_remainder_bound", "code": "theorem exists_taylor_mean_remainder_bound {f : \u211d \u2192 E} {a b : \u211d} {n : \u2115} (hab : a \u2264 b)\n    (hf : ContDiffOn \u211d (n + 1) f (Icc a b)) :\n    \u2203 C, \u2200 x \u2208 Icc a b, \u2016f x - taylorWithinEval f n (Icc a b) a x\u2016 \u2264 C * (x - a) ^ (n + 1)", "start": [357, 1], "end": [375, 98], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Enumerate.lean", "imports": ["Mathlib/Data/Set/Basic.lean", "Mathlib/Tactic/Common.lean", "Mathlib/Data/Nat/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.enumerate", "code": "def enumerate : Set \u03b1 \u2192 \u2115 \u2192 Option \u03b1\n  | s, 0 => sel s\n  | s, n + 1 => do\n    let a \u2190 sel s\n    enumerate (s \\ {a}) n", "start": [31, 1], "end": [38, 26], "kind": "commanddeclaration"}, {"full_name": "Set.enumerate_eq_none_of_sel", "code": "theorem enumerate_eq_none_of_sel {s : Set \u03b1} (h : sel s = none) : \u2200 {n}, enumerate sel s n = none", "start": [41, 1], "end": [43, 41], "kind": "commanddeclaration"}, {"full_name": "Set.enumerate_eq_none", "code": "theorem enumerate_eq_none :\n    \u2200 {s n\u2081 n\u2082}, enumerate sel s n\u2081 = none \u2192 n\u2081 \u2264 n\u2082 \u2192 enumerate sel s n\u2082 = none", "start": [46, 1], "end": [58, 37], "kind": "commanddeclaration"}, {"full_name": "Set.enumerate_mem", "code": "theorem enumerate_mem (h_sel : \u2200 s a, sel s = some a \u2192 a \u2208 s) :\n    \u2200 {s n a}, enumerate sel s n = some a \u2192 a \u2208 s", "start": [61, 1], "end": [71, 18], "kind": "commanddeclaration"}, {"full_name": "Set.enumerate_inj", "code": "theorem enumerate_inj {n\u2081 n\u2082 : \u2115} {a : \u03b1} {s : Set \u03b1} (h_sel : \u2200 s a, sel s = some a \u2192 a \u2208 s)\n    (h\u2081 : enumerate sel s n\u2081 = some a) (h\u2082 : enumerate sel s n\u2082 = some a) : n\u2081 = n\u2082", "start": [74, 1], "end": [100, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/LocalContext.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.LocalContext.firstDeclM", "code": "@[specialize] def firstDeclM (lctx : LocalContext) (f : LocalDecl \u2192 m \u03b2) : m \u03b2 :=\n  do match (\u2190 lctx.findDeclM? (optional \u2218 f)) with\n  | none   => failure\n  | some b => pure b", "start": [14, 1], "end": [18, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.lastDeclM", "code": "@[specialize] def lastDeclM (lctx : LocalContext) (f : LocalDecl \u2192 m \u03b2) : m \u03b2 :=\n  do match (\u2190 lctx.findDeclRevM? (optional \u2218 f)) with\n  | none   => failure\n  | some b => pure b", "start": [20, 1], "end": [24, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Computability/TMComputable.lean", "imports": ["Mathlib/Computability/TuringMachine.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Computability/Encoding.lean", "Mathlib/Data/Polynomial/Eval.lean", "Mathlib/Data/Polynomial/Basic.lean"], "premises": [{"full_name": "Turing.FinTM2", "code": "structure FinTM2 where\n  {K : Type} [kDecidableEq : DecidableEq K] [kFin : Fintype K] (k\u2080 k\u2081 : K) (\u0393 : K \u2192 Type) (\u039b : Type) (main : \u039b) [\u039bFin : Fintype \u039b] (\u03c3 : Type) (initialState : \u03c3) [\u03c3Fin : Fintype \u03c3]\n  [\u0393k\u2080Fin : Fintype (\u0393 k\u2080)]\n  (m : \u039b \u2192 Turing.TM2.Stmt \u0393 \u039b \u03c3)", "start": [42, 1], "end": [53, 34], "kind": "commanddeclaration"}, {"full_name": "Turing.FinTM2.decidableEqK", "code": "instance decidableEqK : DecidableEq tm.K :=\n  tm.kDecidableEq", "start": [62, 1], "end": [63, 18], "kind": "commanddeclaration"}, {"full_name": "Turing.FinTM2.inhabited\u03c3", "code": "instance inhabited\u03c3 : Inhabited tm.\u03c3 :=\n  \u27e8tm.initialState\u27e9", "start": [66, 1], "end": [67, 20], "kind": "commanddeclaration"}, {"full_name": "Turing.FinTM2.Stmt", "code": "def Stmt : Type :=\n  Turing.TM2.Stmt tm.\u0393 tm.\u039b tm.\u03c3", "start": [70, 1], "end": [72, 33], "kind": "commanddeclaration"}, {"full_name": "Turing.FinTM2.inhabitedStmt", "code": "instance inhabitedStmt : Inhabited (Stmt tm) :=\n  inferInstanceAs (Inhabited (Turing.TM2.Stmt tm.\u0393 tm.\u039b tm.\u03c3))", "start": [76, 1], "end": [77, 63], "kind": "commanddeclaration"}, {"full_name": "Turing.FinTM2.Cfg", "code": "def Cfg : Type :=\n  Turing.TM2.Cfg tm.\u0393 tm.\u039b tm.\u03c3", "start": [80, 1], "end": [82, 32], "kind": "commanddeclaration"}, {"full_name": "Turing.FinTM2.inhabitedCfg", "code": "instance inhabitedCfg : Inhabited (Cfg tm) :=\n  Turing.TM2.Cfg.inhabited _ _ _", "start": [85, 1], "end": [86, 33], "kind": "commanddeclaration"}, {"full_name": "Turing.FinTM2.step", "code": "@[simp]\ndef step : tm.Cfg \u2192 Option tm.Cfg :=\n  Turing.TM2.step tm.m", "start": [89, 1], "end": [92, 23], "kind": "commanddeclaration"}, {"full_name": "Turing.initList", "code": "def initList (tm : FinTM2) (s : List (tm.\u0393 tm.k\u2080)) : tm.Cfg where\n  l := Option.some tm.main\n  var := tm.initialState\n  stk k :=\n    @dite (List (tm.\u0393 k)) (k = tm.k\u2080) (tm.kDecidableEq k tm.k\u2080) (fun h => by rw [h]; exact s)\n      fun _ => []", "start": [99, 1], "end": [105, 18], "kind": "commanddeclaration"}, {"full_name": "Turing.haltList", "code": "def haltList (tm : FinTM2) (s : List (tm.\u0393 tm.k\u2081)) : tm.Cfg where\n  l := Option.none\n  var := tm.initialState\n  stk k :=\n    @dite (List (tm.\u0393 k)) (k = tm.k\u2081) (tm.kDecidableEq k tm.k\u2081) (fun h => by rw [h]; exact s)\n      fun _ => []", "start": [108, 1], "end": [114, 18], "kind": "commanddeclaration"}, {"full_name": "Turing.EvalsTo", "code": "structure EvalsTo {\u03c3 : Type*} (f : \u03c3 \u2192 Option \u03c3) (a : \u03c3) (b : Option \u03c3) where\n  steps : \u2115\n  evals_in_steps : (flip bind f)^[steps] a = b", "start": [117, 1], "end": [121, 47], "kind": "commanddeclaration"}, {"full_name": "Turing.EvalsToInTime", "code": "structure EvalsToInTime {\u03c3 : Type*} (f : \u03c3 \u2192 Option \u03c3) (a : \u03c3) (b : Option \u03c3) (m : \u2115) extends\n  EvalsTo f a b where\n  steps_le_m : steps \u2264 m", "start": [127, 1], "end": [131, 25], "kind": "commanddeclaration"}, {"full_name": "Turing.EvalsTo.refl", "code": "def EvalsTo.refl {\u03c3 : Type*} (f : \u03c3 \u2192 Option \u03c3) (a : \u03c3) : EvalsTo f a a :=\n  \u27e80, rfl\u27e9", "start": [134, 1], "end": [137, 11], "kind": "commanddeclaration"}, {"full_name": "Turing.EvalsTo.trans", "code": "@[trans]\ndef EvalsTo.trans {\u03c3 : Type*} (f : \u03c3 \u2192 Option \u03c3) (a : \u03c3) (b : \u03c3) (c : Option \u03c3)\n    (h\u2081 : EvalsTo f a b) (h\u2082 : EvalsTo f b c) : EvalsTo f a c :=\n  \u27e8h\u2082.steps + h\u2081.steps, by rw [Function.iterate_add_apply, h\u2081.evals_in_steps, h\u2082.evals_in_steps]\u27e9", "start": [140, 1], "end": [144, 98], "kind": "commanddeclaration"}, {"full_name": "Turing.EvalsToInTime.refl", "code": "def EvalsToInTime.refl {\u03c3 : Type*} (f : \u03c3 \u2192 Option \u03c3) (a : \u03c3) : EvalsToInTime f a a 0 :=\n  \u27e8EvalsTo.refl f a, le_refl 0\u27e9", "start": [147, 1], "end": [150, 32], "kind": "commanddeclaration"}, {"full_name": "Turing.EvalsToInTime.trans", "code": "@[trans]\ndef EvalsToInTime.trans {\u03c3 : Type*} (f : \u03c3 \u2192 Option \u03c3) (m\u2081 : \u2115) (m\u2082 : \u2115) (a : \u03c3) (b : \u03c3)\n    (c : Option \u03c3) (h\u2081 : EvalsToInTime f a b m\u2081) (h\u2082 : EvalsToInTime f b c m\u2082) :\n    EvalsToInTime f a c (m\u2082 + m\u2081) :=\n  \u27e8EvalsTo.trans f a b c h\u2081.toEvalsTo h\u2082.toEvalsTo, add_le_add h\u2082.steps_le_m h\u2081.steps_le_m\u27e9", "start": [153, 1], "end": [158, 92], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2Outputs", "code": "def TM2Outputs (tm : FinTM2) (l : List (tm.\u0393 tm.k\u2080)) (l' : Option (List (tm.\u0393 tm.k\u2081))) :=\n  EvalsTo tm.step (initList tm l) ((Option.map (haltList tm)) l')", "start": [161, 1], "end": [163, 66], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2OutputsInTime", "code": "def TM2OutputsInTime (tm : FinTM2) (l : List (tm.\u0393 tm.k\u2080)) (l' : Option (List (tm.\u0393 tm.k\u2081)))\n    (m : \u2115) :=\n  EvalsToInTime tm.step (initList tm l) ((Option.map (haltList tm)) l') m", "start": [166, 1], "end": [169, 74], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2OutputsInTime.toTM2Outputs", "code": "def TM2OutputsInTime.toTM2Outputs {tm : FinTM2} {l : List (tm.\u0393 tm.k\u2080)}\n    {l' : Option (List (tm.\u0393 tm.k\u2081))} {m : \u2115} (h : TM2OutputsInTime tm l l' m) :\n    TM2Outputs tm l l' :=\n  h.toEvalsTo", "start": [172, 1], "end": [176, 14], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2ComputableAux", "code": "structure TM2ComputableAux (\u0393\u2080 \u0393\u2081 : Type) where\n  tm : FinTM2\n  inputAlphabet : tm.\u0393 tm.k\u2080 \u2243 \u0393\u2080\n  outputAlphabet : tm.\u0393 tm.k\u2081 \u2243 \u0393\u2081", "start": [179, 1], "end": [183, 35], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2Computable", "code": "structure TM2Computable {\u03b1 \u03b2 : Type} (ea : FinEncoding \u03b1) (eb : FinEncoding \u03b2) (f : \u03b1 \u2192 \u03b2) extends\n  TM2ComputableAux ea.\u0393 eb.\u0393 where\n  outputsFun :\n    \u2200 a,\n      TM2Outputs tm (List.map inputAlphabet.invFun (ea.encode a))\n        (Option.some ((List.map outputAlphabet.invFun) (eb.encode (f a))))", "start": [186, 1], "end": [192, 75], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2ComputableInTime", "code": "structure TM2ComputableInTime {\u03b1 \u03b2 : Type} (ea : FinEncoding \u03b1) (eb : FinEncoding \u03b2)\n  (f : \u03b1 \u2192 \u03b2) extends TM2ComputableAux ea.\u0393 eb.\u0393 where\n  time : \u2115 \u2192 \u2115\n  outputsFun :\n    \u2200 a,\n      TM2OutputsInTime tm (List.map inputAlphabet.invFun (ea.encode a))\n        (Option.some ((List.map outputAlphabet.invFun) (eb.encode (f a))))\n        (time (ea.encode a).length)", "start": [195, 1], "end": [203, 36], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2ComputableInPolyTime", "code": "structure TM2ComputableInPolyTime {\u03b1 \u03b2 : Type} (ea : FinEncoding \u03b1) (eb : FinEncoding \u03b2)\n  (f : \u03b1 \u2192 \u03b2) extends TM2ComputableAux ea.\u0393 eb.\u0393 where\n  time : Polynomial \u2115\n  outputsFun :\n    \u2200 a,\n      TM2OutputsInTime tm (List.map inputAlphabet.invFun (ea.encode a))\n        (Option.some ((List.map outputAlphabet.invFun) (eb.encode (f a))))\n        (time.eval (ea.encode a).length)", "start": [206, 1], "end": [215, 41], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2ComputableInTime.toTM2Computable", "code": "def TM2ComputableInTime.toTM2Computable {\u03b1 \u03b2 : Type} {ea : FinEncoding \u03b1} {eb : FinEncoding \u03b2}\n    {f : \u03b1 \u2192 \u03b2} (h : TM2ComputableInTime ea eb f) : TM2Computable ea eb f :=\n  \u27e8h.toTM2ComputableAux, fun a => TM2OutputsInTime.toTM2Outputs (h.outputsFun a)\u27e9", "start": [218, 1], "end": [221, 82], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2ComputableInPolyTime.toTM2ComputableInTime", "code": "def TM2ComputableInPolyTime.toTM2ComputableInTime {\u03b1 \u03b2 : Type} {ea : FinEncoding \u03b1}\n    {eb : FinEncoding \u03b2} {f : \u03b1 \u2192 \u03b2} (h : TM2ComputableInPolyTime ea eb f) :\n    TM2ComputableInTime ea eb f :=\n  \u27e8h.toTM2ComputableAux, fun n => h.time.eval n, h.outputsFun\u27e9", "start": [224, 1], "end": [228, 63], "kind": "commanddeclaration"}, {"full_name": "Turing.idComputer", "code": "def idComputer {\u03b1 : Type} (ea : FinEncoding \u03b1) : FinTM2 where\n  K := Unit\n  k\u2080 := \u27e8\u27e9\n  k\u2081 := \u27e8\u27e9\n  \u0393 _ := ea.\u0393\n  \u039b := Unit\n  main := \u27e8\u27e9\n  \u03c3 := Unit\n  initialState := \u27e8\u27e9\n  \u0393k\u2080Fin := ea.\u0393Fin\n  m _ := halt", "start": [233, 1], "end": [244, 14], "kind": "commanddeclaration"}, {"full_name": "Turing.inhabitedFinTM2", "code": "instance inhabitedFinTM2 : Inhabited FinTM2 :=\n  \u27e8idComputer Computability.inhabitedFinEncoding.default\u27e9", "start": [247, 1], "end": [248, 58], "kind": "commanddeclaration"}, {"full_name": "Turing.idComputableInPolyTime", "code": "def idComputableInPolyTime {\u03b1 : Type} (ea : FinEncoding \u03b1) :\n    @TM2ComputableInPolyTime \u03b1 \u03b1 ea ea id where\n  tm := idComputer ea\n  inputAlphabet := Equiv.cast rfl\n  outputAlphabet := Equiv.cast rfl\n  time := 1\n  outputsFun _ :=\n    { steps := 1\n      evals_in_steps := rfl\n      steps_le_m := by simp only [Polynomial.eval_one] }", "start": [253, 1], "end": [263, 57], "kind": "commanddeclaration"}, {"full_name": "Turing.inhabitedTM2ComputableInPolyTime", "code": "instance inhabitedTM2ComputableInPolyTime :\n    Inhabited (TM2ComputableInPolyTime (default : FinEncoding Bool) default id) :=\n  \u27e8idComputableInPolyTime Computability.inhabitedFinEncoding.default\u27e9", "start": [266, 1], "end": [268, 70], "kind": "commanddeclaration"}, {"full_name": "Turing.inhabitedTM2OutputsInTime", "code": "instance inhabitedTM2OutputsInTime :\n    Inhabited\n      (TM2OutputsInTime (idComputer finEncodingBoolBool) (List.map (Equiv.cast rfl).invFun [false])\n        (some (List.map (Equiv.cast rfl).invFun [false])) (Polynomial.eval 1 1)) :=\n  \u27e8(idComputableInPolyTime finEncodingBoolBool).outputsFun false\u27e9", "start": [271, 1], "end": [275, 66], "kind": "commanddeclaration"}, {"full_name": "Turing.inhabitedTM2Outputs", "code": "instance inhabitedTM2Outputs :\n    Inhabited\n      (TM2Outputs (idComputer finEncodingBoolBool) (List.map (Equiv.cast rfl).invFun [false])\n        (some (List.map (Equiv.cast rfl).invFun [false]))) :=\n  \u27e8TM2OutputsInTime.toTM2Outputs Turing.inhabitedTM2OutputsInTime.default\u27e9", "start": [278, 1], "end": [282, 75], "kind": "commanddeclaration"}, {"full_name": "Turing.inhabitedEvalsToInTime", "code": "instance inhabitedEvalsToInTime :\n    Inhabited (EvalsToInTime (fun _ : Unit => some \u27e8\u27e9) \u27e8\u27e9 (some \u27e8\u27e9) 0) :=\n  \u27e8EvalsToInTime.refl _ _\u27e9", "start": [285, 1], "end": [287, 27], "kind": "commanddeclaration"}, {"full_name": "Turing.inhabitedTM2EvalsTo", "code": "instance inhabitedTM2EvalsTo : Inhabited (EvalsTo (fun _ : Unit => some \u27e8\u27e9) \u27e8\u27e9 (some \u27e8\u27e9)) :=\n  \u27e8EvalsTo.refl _ _\u27e9", "start": [290, 1], "end": [291, 21], "kind": "commanddeclaration"}, {"full_name": "Turing.idComputableInTime", "code": "def idComputableInTime {\u03b1 : Type} (ea : FinEncoding \u03b1) : @TM2ComputableInTime \u03b1 \u03b1 ea ea id :=\n  TM2ComputableInPolyTime.toTM2ComputableInTime <| idComputableInPolyTime ea", "start": [294, 1], "end": [296, 77], "kind": "commanddeclaration"}, {"full_name": "Turing.inhabitedTM2ComputableInTime", "code": "instance inhabitedTM2ComputableInTime :\n    Inhabited (TM2ComputableInTime finEncodingBoolBool finEncodingBoolBool id) :=\n  \u27e8idComputableInTime Computability.inhabitedFinEncoding.default\u27e9", "start": [299, 1], "end": [301, 66], "kind": "commanddeclaration"}, {"full_name": "Turing.idComputable", "code": "def idComputable {\u03b1 : Type} (ea : FinEncoding \u03b1) : @TM2Computable \u03b1 \u03b1 ea ea id :=\n  TM2ComputableInTime.toTM2Computable <| idComputableInTime ea", "start": [304, 1], "end": [306, 63], "kind": "commanddeclaration"}, {"full_name": "Turing.inhabitedTM2Computable", "code": "instance inhabitedTM2Computable :\n    Inhabited (TM2Computable finEncodingBoolBool finEncodingBoolBool id) :=\n  \u27e8idComputable Computability.inhabitedFinEncoding.default\u27e9", "start": [309, 1], "end": [311, 60], "kind": "commanddeclaration"}, {"full_name": "Turing.inhabitedTM2ComputableAux", "code": "instance inhabitedTM2ComputableAux : Inhabited (TM2ComputableAux Bool Bool) :=\n  \u27e8(default : TM2Computable finEncodingBoolBool finEncodingBoolBool id).toTM2ComputableAux\u27e9", "start": [314, 1], "end": [315, 92], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/WhitneyEmbedding.lean", "imports": ["Mathlib/Geometry/Manifold/Instances/Real.lean", "Mathlib/Geometry/Manifold/PartitionOfUnity.lean", "Mathlib/Geometry/Manifold/Diffeomorph.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SmoothBumpCovering.embeddingPiTangent", "code": "def embeddingPiTangent : C^\u221e\u27eeI, M; \ud835\udcd8(\u211d, \u03b9 \u2192 E \u00d7 \u211d), \u03b9 \u2192 E \u00d7 \u211d\u27ef where\n  val x i := (f i x \u2022 extChartAt I (f.c i) x, f i x)\n  property :=\n    contMDiff_pi_space.2 fun i =>\n      ((f i).smooth_smul contMDiffOn_extChartAt).prod_mk_space (f i).smooth", "start": [54, 1], "end": [59, 76], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.embeddingPiTangent_coe", "code": "@[local simp]\ntheorem embeddingPiTangent_coe :\n    \u21d1f.embeddingPiTangent = fun x i => (f i x \u2022 extChartAt I (f.c i) x, f i x)", "start": [62, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.embeddingPiTangent_injOn", "code": "theorem embeddingPiTangent_injOn : InjOn f.embeddingPiTangent s", "start": [68, 1], "end": [75, 80], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.embeddingPiTangent_injective", "code": "theorem embeddingPiTangent_injective (f : SmoothBumpCovering \u03b9 I M) :\n    Injective f.embeddingPiTangent", "start": [78, 1], "end": [80, 56], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.comp_embeddingPiTangent_mfderiv", "code": "theorem comp_embeddingPiTangent_mfderiv (x : M) (hx : x \u2208 s) :\n    ((ContinuousLinearMap.fst \u211d E \u211d).comp\n            (@ContinuousLinearMap.proj \u211d _ \u03b9 (fun _ => E \u00d7 \u211d) _ _ (fun _ => inferInstance)\n              (f.ind x hx))).comp\n        (mfderiv I \ud835\udcd8(\u211d, \u03b9 \u2192 E \u00d7 \u211d) f.embeddingPiTangent x) =\n      mfderiv I I (chartAt H (f.c (f.ind x hx))) x", "start": [83, 1], "end": [98, 34], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.embeddingPiTangent_ker_mfderiv", "code": "theorem embeddingPiTangent_ker_mfderiv (x : M) (hx : x \u2208 s) :\n    LinearMap.ker (mfderiv I \ud835\udcd8(\u211d, \u03b9 \u2192 E \u00d7 \u211d) f.embeddingPiTangent x) = \u22a5", "start": [101, 1], "end": [107, 38], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.embeddingPiTangent_injective_mfderiv", "code": "theorem embeddingPiTangent_injective_mfderiv (x : M) (hx : x \u2208 s) :\n    Injective (mfderiv I \ud835\udcd8(\u211d, \u03b9 \u2192 E \u00d7 \u211d) f.embeddingPiTangent x)", "start": [110, 1], "end": [112, 65], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.exists_immersion_euclidean", "code": "theorem exists_immersion_euclidean [Finite \u03b9] (f : SmoothBumpCovering \u03b9 I M) :\n    \u2203 (n : \u2115) (e : M \u2192 EuclideanSpace \u211d (Fin n)),\n      Smooth I (\ud835\udce1 n) e \u2227 Injective e \u2227 \u2200 x : M, Injective (mfderiv I (\ud835\udce1 n) e x)", "start": [115, 1], "end": [133, 78], "kind": "commanddeclaration"}, {"full_name": "exists_embedding_euclidean_of_compact", "code": "theorem exists_embedding_euclidean_of_compact [T2Space M] [CompactSpace M] :\n    \u2203 (n : \u2115) (e : M \u2192 EuclideanSpace \u211d (Fin n)),\n      Smooth I (\ud835\udce1 n) e \u2227 ClosedEmbedding e \u2227 \u2200 x : M, Injective (mfderiv I (\ud835\udce1 n) e x)", "start": [138, 1], "end": [148, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/PrimeIdeal.lean", "imports": ["Mathlib/Order/PFilter.lean", "Mathlib/Order/Ideal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Order.Ideal.PrimePair", "code": "structure PrimePair (P : Type*) [Preorder P] where\n  I : Ideal P\n  F : PFilter P\n  isCompl_I_F : IsCompl (I : Set P) F", "start": [44, 1], "end": [50, 38], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.PrimePair.compl_I_eq_F", "code": "theorem compl_I_eq_F : (IF.I : Set P)\u1d9c = IF.F", "start": [57, 1], "end": [58, 26], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.PrimePair.compl_F_eq_I", "code": "theorem compl_F_eq_I : (IF.F : Set P)\u1d9c = IF.I", "start": [62, 1], "end": [63, 31], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.PrimePair.I_isProper", "code": "theorem I_isProper : IsProper IF.I", "start": [67, 1], "end": [70, 31], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.PrimePair.disjoint", "code": "protected theorem disjoint : Disjoint (IF.I : Set P) IF.F", "start": [74, 1], "end": [75, 26], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.PrimePair.I_union_F", "code": "theorem I_union_F : (IF.I : Set P) \u222a IF.F = Set.univ", "start": [78, 1], "end": [79, 28], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.PrimePair.F_union_I", "code": "theorem F_union_I : (IF.F : Set P) \u222a IF.I = Set.univ", "start": [83, 1], "end": [84, 33], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsPrime", "code": "@[mk_iff]\nclass IsPrime [Preorder P] (I : Ideal P) extends IsProper I : Prop where\n  compl_filter : IsPFilter (I : Set P)\u1d9c", "start": [90, 1], "end": [94, 40], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsPrime.toPrimePair", "code": "def IsPrime.toPrimePair {I : Ideal P} (h : IsPrime I) : PrimePair P :=\n  { I\n    F := h.compl_filter.toPFilter\n    isCompl_I_F := isCompl_compl }", "start": [101, 1], "end": [106, 35], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.PrimePair.I_isPrime", "code": "theorem PrimePair.I_isPrime (IF : PrimePair P) : IsPrime IF.I", "start": [109, 1], "end": [113, 29], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsPrime.mem_or_mem", "code": "theorem IsPrime.mem_or_mem (hI : IsPrime I) {x y : P} : x \u2293 y \u2208 I \u2192 x \u2208 I \u2228 y \u2208 I", "start": [123, 1], "end": [127, 33], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsPrime.of_mem_or_mem", "code": "theorem IsPrime.of_mem_or_mem [IsProper I] (hI : \u2200 {x y : P}, x \u2293 y \u2208 I \u2192 x \u2208 I \u2228 y \u2208 I) :\n    IsPrime I", "start": [130, 1], "end": [138, 33], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.isPrime_iff_mem_or_mem", "code": "theorem isPrime_iff_mem_or_mem [IsProper I] : IsPrime I \u2194 \u2200 {x y : P}, x \u2293 y \u2208 I \u2192 x \u2208 I \u2228 y \u2208 I", "start": [141, 1], "end": [142, 46], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsMaximal.isPrime", "code": "instance (priority := 100) IsMaximal.isPrime [IsMaximal I] : IsPrime I := by\n  rw [isPrime_iff_mem_or_mem]\n  intro x y\n  contrapose!\n  rintro \u27e8hx, hynI\u27e9 hxy\n  apply hynI\n  let J := I \u2294 principal x\n  have hJuniv : (J : Set P) = Set.univ :=\n    IsMaximal.maximal_proper (lt_sup_principal_of_not_mem \u2039_\u203a)\n  have hyJ : y \u2208 \u2191J := Set.eq_univ_iff_forall.mp hJuniv y\n  rw [coe_sup_eq] at hyJ\n  rcases hyJ with \u27e8a, ha, b, hb, hy\u27e9\n  rw [hy]\n  refine' sup_mem ha (I.lower (le_inf hb _) hxy)\n  rw [hy]\n  exact le_sup_right", "start": [151, 1], "end": [166, 21], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsPrime.mem_or_compl_mem", "code": "theorem IsPrime.mem_or_compl_mem (hI : IsPrime I) : x \u2208 I \u2228 x\u1d9c \u2208 I", "start": [175, 1], "end": [178, 18], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsPrime.mem_compl_of_not_mem", "code": "theorem IsPrime.mem_compl_of_not_mem (hI : IsPrime I) (hxnI : x \u2209 I) : x\u1d9c \u2208 I", "start": [181, 1], "end": [182, 40], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.isPrime_of_mem_or_compl_mem", "code": "theorem isPrime_of_mem_or_compl_mem [IsProper I] (h : \u2200 {x : P}, x \u2208 I \u2228 x\u1d9c \u2208 I) : IsPrime I", "start": [185, 1], "end": [190, 43], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.isPrime_iff_mem_or_compl_mem", "code": "theorem isPrime_iff_mem_or_compl_mem [IsProper I] : IsPrime I \u2194 \u2200 {x : P}, x \u2208 I \u2228 x\u1d9c \u2208 I", "start": [193, 1], "end": [194, 63], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsPrime.isMaximal", "code": "instance (priority := 100) IsPrime.isMaximal [IsPrime I] : IsMaximal I := by\n  simp only [IsMaximal_iff, Set.eq_univ_iff_forall, IsPrime.toIsProper, true_and]\n  intro J hIJ x\n  rcases Set.exists_of_ssubset hIJ with \u27e8y, hyJ, hyI\u27e9\n  suffices ass : x \u2293 y \u2294 x \u2293 y\u1d9c \u2208 J by rwa [sup_inf_inf_compl] at ass\n  exact\n    sup_mem (J.lower inf_le_right hyJ)\n      (hIJ.le <| I.lower inf_le_right <| IsPrime.mem_compl_of_not_mem \u2039_\u203a hyI)", "start": [197, 1], "end": [204, 79], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.IsPrime", "code": "@[mk_iff]\nclass IsPrime (F : PFilter P) : Prop where\n  compl_ideal : IsIdeal (F : Set P)\u1d9c", "start": [215, 1], "end": [219, 37], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.IsPrime.toPrimePair", "code": "def IsPrime.toPrimePair {F : PFilter P} (h : IsPrime F) : Ideal.PrimePair P :=\n  { I := h.compl_ideal.toIdeal\n    F\n    isCompl_I_F := isCompl_compl.symm }", "start": [222, 1], "end": [227, 40], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.PrimePair.F_isPrime", "code": "theorem _root_.Order.Ideal.PrimePair.F_isPrime (IF : Ideal.PrimePair P) : IsPrime IF.F", "start": [230, 1], "end": [234, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Irreducible.lean", "imports": ["Mathlib/Data/Finset/Lattice.lean", "Mathlib/Data/Fintype/Card.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SupIrred", "code": "def SupIrred (a : \u03b1) : Prop :=\n  \u00acIsMin a \u2227 \u2200 \u2983b c\u2984, b \u2294 c = a \u2192 b = a \u2228 c = a", "start": [46, 1], "end": [49, 48], "kind": "commanddeclaration"}, {"full_name": "SupPrime", "code": "def SupPrime (a : \u03b1) : Prop :=\n  \u00acIsMin a \u2227 \u2200 \u2983b c\u2984, a \u2264 b \u2294 c \u2192 a \u2264 b \u2228 a \u2264 c", "start": [52, 1], "end": [55, 48], "kind": "commanddeclaration"}, {"full_name": "SupIrred.not_isMin", "code": "theorem SupIrred.not_isMin (ha : SupIrred a) : \u00acIsMin a", "start": [58, 1], "end": [59, 7], "kind": "commanddeclaration"}, {"full_name": "SupPrime.not_isMin", "code": "theorem SupPrime.not_isMin (ha : SupPrime a) : \u00acIsMin a", "start": [62, 1], "end": [63, 7], "kind": "commanddeclaration"}, {"full_name": "IsMin.not_supIrred", "code": "theorem IsMin.not_supIrred (ha : IsMin a) : \u00acSupIrred a", "start": [66, 1], "end": [66, 75], "kind": "commanddeclaration"}, {"full_name": "IsMin.not_supPrime", "code": "theorem IsMin.not_supPrime (ha : IsMin a) : \u00acSupPrime a", "start": [69, 1], "end": [69, 75], "kind": "commanddeclaration"}, {"full_name": "not_supIrred", "code": "@[simp]\ntheorem not_supIrred : \u00acSupIrred a \u2194 IsMin a \u2228 \u2203 b c, b \u2294 c = a \u2227 b < a \u2227 c < a", "start": [72, 1], "end": [77, 59], "kind": "commanddeclaration"}, {"full_name": "not_supPrime", "code": "@[simp]\ntheorem not_supPrime : \u00acSupPrime a \u2194 IsMin a \u2228 \u2203 b c, a \u2264 b \u2294 c \u2227 \u00aca \u2264 b \u2227 \u00aca \u2264 c", "start": [80, 1], "end": [82, 43], "kind": "commanddeclaration"}, {"full_name": "SupPrime.supIrred", "code": "protected theorem SupPrime.supIrred : SupPrime a \u2192 SupIrred a", "start": [85, 1], "end": [86, 62], "kind": "commanddeclaration"}, {"full_name": "SupPrime.le_sup", "code": "theorem SupPrime.le_sup (ha : SupPrime a) : a \u2264 b \u2294 c \u2194 a \u2264 b \u2228 a \u2264 c", "start": [89, 1], "end": [90, 74], "kind": "commanddeclaration"}, {"full_name": "not_supIrred_bot", "code": "@[simp]\ntheorem not_supIrred_bot : \u00acSupIrred (\u22a5 : \u03b1)", "start": [95, 1], "end": [97, 25], "kind": "commanddeclaration"}, {"full_name": "not_supPrime_bot", "code": "@[simp]\ntheorem not_supPrime_bot : \u00acSupPrime (\u22a5 : \u03b1)", "start": [100, 1], "end": [102, 25], "kind": "commanddeclaration"}, {"full_name": "SupIrred.ne_bot", "code": "theorem SupIrred.ne_bot (ha : SupIrred a) : a \u2260 \u22a5", "start": [105, 1], "end": [105, 94], "kind": "commanddeclaration"}, {"full_name": "SupPrime.ne_bot", "code": "theorem SupPrime.ne_bot (ha : SupPrime a) : a \u2260 \u22a5", "start": [108, 1], "end": [108, 94], "kind": "commanddeclaration"}, {"full_name": "SupIrred.finset_sup_eq", "code": "theorem SupIrred.finset_sup_eq (ha : SupIrred a) (h : s.sup f = a) : \u2203 i \u2208 s, f i = a", "start": [111, 1], "end": [117, 30], "kind": "commanddeclaration"}, {"full_name": "SupPrime.le_finset_sup", "code": "theorem SupPrime.le_finset_sup (ha : SupPrime a) : a \u2264 s.sup f \u2194 \u2203 i \u2208 s, a \u2264 f i", "start": [120, 1], "end": [124, 74], "kind": "commanddeclaration"}, {"full_name": "exists_supIrred_decomposition", "code": "theorem exists_supIrred_decomposition (a : \u03b1) :\n    \u2203 s : Finset \u03b1, s.sup id = a \u2227 \u2200 \u2983b\u2984, b \u2208 s \u2192 SupIrred b", "start": [129, 1], "end": [144, 56], "kind": "commanddeclaration"}, {"full_name": "InfIrred", "code": "def InfIrred (a : \u03b1) : Prop :=\n  \u00acIsMax a \u2227 \u2200 \u2983b c\u2984, b \u2293 c = a \u2192 b = a \u2228 c = a", "start": [153, 1], "end": [155, 48], "kind": "commanddeclaration"}, {"full_name": "InfPrime", "code": "def InfPrime (a : \u03b1) : Prop :=\n  \u00acIsMax a \u2227 \u2200 \u2983b c\u2984, b \u2293 c \u2264 a \u2192 b \u2264 a \u2228 c \u2264 a", "start": [158, 1], "end": [161, 48], "kind": "commanddeclaration"}, {"full_name": "IsMax.not_infIrred", "code": "@[simp]\ntheorem IsMax.not_infIrred (ha : IsMax a) : \u00acInfIrred a", "start": [164, 1], "end": [165, 75], "kind": "commanddeclaration"}, {"full_name": "IsMax.not_infPrime", "code": "@[simp]\ntheorem IsMax.not_infPrime (ha : IsMax a) : \u00acInfPrime a", "start": [168, 1], "end": [169, 75], "kind": "commanddeclaration"}, {"full_name": "not_infIrred", "code": "@[simp]\ntheorem not_infIrred : \u00acInfIrred a \u2194 IsMax a \u2228 \u2203 b c, b \u2293 c = a \u2227 a < b \u2227 a < c", "start": [172, 1], "end": [174, 24], "kind": "commanddeclaration"}, {"full_name": "not_infPrime", "code": "@[simp]\ntheorem not_infPrime : \u00acInfPrime a \u2194 IsMax a \u2228 \u2203 b c, b \u2293 c \u2264 a \u2227 \u00acb \u2264 a \u2227 \u00acc \u2264 a", "start": [177, 1], "end": [179, 24], "kind": "commanddeclaration"}, {"full_name": "InfPrime.infIrred", "code": "protected theorem InfPrime.infIrred : InfPrime a \u2192 InfIrred a", "start": [182, 1], "end": [183, 62], "kind": "commanddeclaration"}, {"full_name": "InfPrime.inf_le", "code": "theorem InfPrime.inf_le (ha : InfPrime a) : b \u2293 c \u2264 a \u2194 b \u2264 a \u2228 c \u2264 a", "start": [186, 1], "end": [187, 74], "kind": "commanddeclaration"}, {"full_name": "not_infIrred_top", "code": "theorem not_infIrred_top : \u00acInfIrred (\u22a4 : \u03b1)", "start": [193, 1], "end": [194, 25], "kind": "commanddeclaration"}, {"full_name": "not_infPrime_top", "code": "theorem not_infPrime_top : \u00acInfPrime (\u22a4 : \u03b1)", "start": [198, 1], "end": [199, 25], "kind": "commanddeclaration"}, {"full_name": "InfIrred.ne_top", "code": "theorem InfIrred.ne_top (ha : InfIrred a) : a \u2260 \u22a4", "start": [202, 1], "end": [202, 94], "kind": "commanddeclaration"}, {"full_name": "InfPrime.ne_top", "code": "theorem InfPrime.ne_top (ha : InfPrime a) : a \u2260 \u22a4", "start": [205, 1], "end": [205, 94], "kind": "commanddeclaration"}, {"full_name": "InfIrred.finset_inf_eq", "code": "theorem InfIrred.finset_inf_eq : InfIrred a \u2192 s.inf f = a \u2192 \u2203 i \u2208 s, f i = a", "start": [208, 1], "end": [209, 42], "kind": "commanddeclaration"}, {"full_name": "InfPrime.finset_inf_le", "code": "theorem InfPrime.finset_inf_le (ha : InfPrime a) : s.inf f \u2264 a \u2194 \u2203 i \u2208 s, f i \u2264 a", "start": [212, 1], "end": [213, 45], "kind": "commanddeclaration"}, {"full_name": "exists_infIrred_decomposition", "code": "theorem exists_infIrred_decomposition (a : \u03b1) :\n    \u2203 s : Finset \u03b1, s.inf id = a \u2227 \u2200 \u2983b\u2984, b \u2208 s \u2192 InfIrred b", "start": [218, 1], "end": [222, 45], "kind": "commanddeclaration"}, {"full_name": "infIrred_toDual", "code": "@[simp]\ntheorem infIrred_toDual {a : \u03b1} : InfIrred (toDual a) \u2194 SupIrred a", "start": [231, 1], "end": [233, 10], "kind": "commanddeclaration"}, {"full_name": "infPrime_toDual", "code": "@[simp]\ntheorem infPrime_toDual {a : \u03b1} : InfPrime (toDual a) \u2194 SupPrime a", "start": [236, 1], "end": [238, 10], "kind": "commanddeclaration"}, {"full_name": "supIrred_ofDual", "code": "@[simp]\ntheorem supIrred_ofDual {a : \u03b1\u1d52\u1d48} : SupIrred (ofDual a) \u2194 InfIrred a", "start": [241, 1], "end": [243, 10], "kind": "commanddeclaration"}, {"full_name": "supPrime_ofDual", "code": "@[simp]\ntheorem supPrime_ofDual {a : \u03b1\u1d52\u1d48} : SupPrime (ofDual a) \u2194 InfPrime a", "start": [246, 1], "end": [248, 10], "kind": "commanddeclaration"}, {"full_name": "SupIrred.dual", "code": "alias \u27e8_, SupIrred.dual\u27e9 := infIrred_toDual", "start": [251, 1], "end": [251, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SupPrime.dual", "code": "alias \u27e8_, SupPrime.dual\u27e9 := infPrime_toDual", "start": [254, 1], "end": [254, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "InfIrred.ofDual", "code": "alias \u27e8_, InfIrred.ofDual\u27e9 := supIrred_ofDual", "start": [257, 1], "end": [257, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "InfPrime.ofDual", "code": "alias \u27e8_, InfPrime.ofDual\u27e9 := supPrime_ofDual", "start": [260, 1], "end": [260, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "supIrred_toDual", "code": "@[simp]\ntheorem supIrred_toDual {a : \u03b1} : SupIrred (toDual a) \u2194 InfIrred a", "start": [269, 1], "end": [271, 10], "kind": "commanddeclaration"}, {"full_name": "supPrime_toDual", "code": "@[simp]\ntheorem supPrime_toDual {a : \u03b1} : SupPrime (toDual a) \u2194 InfPrime a", "start": [274, 1], "end": [276, 10], "kind": "commanddeclaration"}, {"full_name": "infIrred_ofDual", "code": "@[simp]\ntheorem infIrred_ofDual {a : \u03b1\u1d52\u1d48} : InfIrred (ofDual a) \u2194 SupIrred a", "start": [279, 1], "end": [281, 10], "kind": "commanddeclaration"}, {"full_name": "infPrime_ofDual", "code": "@[simp]\ntheorem infPrime_ofDual {a : \u03b1\u1d52\u1d48} : InfPrime (ofDual a) \u2194 SupPrime a", "start": [284, 1], "end": [286, 10], "kind": "commanddeclaration"}, {"full_name": "InfIrred.dual", "code": "alias \u27e8_, InfIrred.dual\u27e9 := supIrred_toDual", "start": [289, 1], "end": [289, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "InfPrime.dual", "code": "alias \u27e8_, InfPrime.dual\u27e9 := supPrime_toDual", "start": [292, 1], "end": [292, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SupIrred.ofDual", "code": "alias \u27e8_, SupIrred.ofDual\u27e9 := infIrred_ofDual", "start": [295, 1], "end": [295, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SupPrime.ofDual", "code": "alias \u27e8_, SupPrime.ofDual\u27e9 := infPrime_ofDual", "start": [298, 1], "end": [298, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "supPrime_iff_supIrred", "code": "@[simp]\ntheorem supPrime_iff_supIrred : SupPrime a \u2194 SupIrred a", "start": [307, 1], "end": [310, 87], "kind": "commanddeclaration"}, {"full_name": "infPrime_iff_infIrred", "code": "@[simp]\ntheorem infPrime_iff_infIrred : InfPrime a \u2194 InfIrred a", "start": [313, 1], "end": [316, 87], "kind": "commanddeclaration"}, {"full_name": "SupIrred.supPrime", "code": "alias \u27e8_, SupIrred.supPrime\u27e9 := supPrime_iff_supIrred", "start": [319, 1], "end": [319, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "InfIrred.infPrime", "code": "alias \u27e8_, InfIrred.infPrime\u27e9 := infPrime_iff_infIrred", "start": [322, 1], "end": [322, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "supPrime_iff_not_isMin", "code": "theorem supPrime_iff_not_isMin : SupPrime a \u2194 \u00acIsMin a", "start": [334, 1], "end": [335, 26], "kind": "commanddeclaration"}, {"full_name": "infPrime_iff_not_isMax", "code": "theorem infPrime_iff_not_isMax : InfPrime a \u2194 \u00acIsMax a", "start": [339, 1], "end": [340, 26], "kind": "commanddeclaration"}, {"full_name": "supIrred_iff_not_isMin", "code": "@[simp]\ntheorem supIrred_iff_not_isMin : SupIrred a \u2194 \u00acIsMin a", "start": [343, 1], "end": [345, 96], "kind": "commanddeclaration"}, {"full_name": "infIrred_iff_not_isMax", "code": "@[simp]\ntheorem infIrred_iff_not_isMax : InfIrred a \u2194 \u00acIsMax a", "start": [348, 1], "end": [350, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/DirectSum.lean", "imports": ["Mathlib/Algebra/Lie/Basic.lean", "Mathlib/Algebra/Lie/Submodule.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/DirectSum/Module.lean", "Mathlib/Algebra/Lie/OfAssociative.lean"], "premises": [{"full_name": "DirectSum.lie_module_bracket_apply", "code": "@[simp]\ntheorem lie_module_bracket_apply (x : L) (m : \u2a01 i, M i) (i : \u03b9) : \u2045x, m\u2046 i = \u2045x, m i\u2046", "start": [60, 1], "end": [62, 25], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lieModuleOf", "code": "def lieModuleOf [DecidableEq \u03b9] (j : \u03b9) : M j \u2192\u2097\u2045R,L\u2046 \u2a01 i, M i :=\n  { lof R \u03b9 M j with\n    map_lie' := fun {x m} => by\n      refine' DFinsupp.ext fun i => _ by_cases h : j = i\n      \u00b7 rw [\u2190 h]; simp\n      \u00b7 simp only [lof, lsingle, AddHom.toFun_eq_coe, lie_module_bracket_apply]\n        erw [AddHom.coe_mk]\n        simp [h] }", "start": [75, 1], "end": [86, 19], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lieModuleComponent", "code": "def lieModuleComponent (j : \u03b9) : (\u2a01 i, M i) \u2192\u2097\u2045R,L\u2046 M j :=\n  { component R \u03b9 M j with\n    map_lie' := fun {x m} => by simp [component, lapply] }", "start": [89, 1], "end": [92, 59], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lieRing", "code": "instance lieRing : LieRing (\u2a01 i, L i) :=\n  { (inferInstance : AddCommGroup _) with\n    bracket := zipWith (fun i => fun x y => \u2045x, y\u2046) fun i => lie_zero 0\n    add_lie := fun x y z => by\n      refine' DFinsupp.ext fun _ => _ simp only [zipWith_apply, add_apply, add_lie]\n    lie_add := fun x y z => by\n      refine' DFinsupp.ext fun _ => _ simp only [zipWith_apply, add_apply, lie_add]\n    lie_self := fun x => by\n      refine' DFinsupp.ext fun _ => _ simp only [zipWith_apply, add_apply, lie_self, zero_apply]\n    leibniz_lie := fun x y z => by\n      refine' DFinsupp.ext fun _ => _ simp only [sub_apply, zipWith_apply, add_apply, zero_apply]\n      apply leibniz_lie }", "start": [106, 1], "end": [121, 26], "kind": "commanddeclaration"}, {"full_name": "DirectSum.bracket_apply", "code": "@[simp]\ntheorem bracket_apply (x y : \u2a01 i, L i) (i : \u03b9) : \u2045x, y\u2046 i = \u2045x i, y i\u2046", "start": [124, 1], "end": [126, 26], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lieAlgebra", "code": "instance lieAlgebra : LieAlgebra R (\u2a01 i, L i) :=\n  { (inferInstance : Module R _) with\n    lie_smul := fun c x y => by\n      refine' DFinsupp.ext fun _ => _ simp only [zipWith_apply, smul_apply, bracket_apply, lie_smul] }", "start": [129, 1], "end": [133, 71], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lieAlgebraOf", "code": "@[simps]\ndef lieAlgebraOf [DecidableEq \u03b9] (j : \u03b9) : L j \u2192\u2097\u2045R\u2046 \u2a01 i, L i :=\n  { lof R \u03b9 L j with\n    toFun := of L j\n    map_lie' := fun {x y} => by\n      refine' DFinsupp.ext fun i => _ by_cases h : j = i\n      \u00b7 rw [\u2190 h]\n        simp only [of, singleAddHom, bracket_apply]\n        erw [AddHom.coe_mk, single_apply, single_apply]\n        simp [h]\n        intros\n        erw [single_add]\n      \u00b7 simp only [of, singleAddHom, bracket_apply]\n        erw [AddHom.coe_mk, single_apply, single_apply]\n        simp only [h, dite_false, single_apply, lie_self]\n        intros\n        erw [single_add] }", "start": [138, 1], "end": [160, 27], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lieAlgebraComponent", "code": "@[simps]\ndef lieAlgebraComponent (j : \u03b9) : (\u2a01 i, L i) \u2192\u2097\u2045R\u2046 L j :=\n  { component R \u03b9 L j with\n    toFun := component R \u03b9 L j\n    map_lie' := fun {x y} => by simp [component, lapply] }", "start": [163, 1], "end": [168, 59], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lieAlgebra_ext", "code": "@[ext]\ntheorem lieAlgebra_ext {x y : \u2a01 i, L i}\n    (h : \u2200 i, lieAlgebraComponent R \u03b9 L i x = lieAlgebraComponent R \u03b9 L i y) : x = y", "start": [171, 1], "end": [174, 17], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lie_of_of_ne", "code": "theorem lie_of_of_ne [DecidableEq \u03b9] {i j : \u03b9} (hij : j \u2260 i) (x : L i) (y : L j) :\n    \u2045of L i x, of L j y\u2046 = 0", "start": [177, 1], "end": [190, 54], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lie_of_of_eq", "code": "theorem lie_of_of_eq [DecidableEq \u03b9] {i j : \u03b9} (hij : j = i) (x : L i) (y : L j) :\n    \u2045of L i x, of L j y\u2046 = of L i \u2045x, hij.recOn y\u2046", "start": [193, 1], "end": [197, 24], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lie_of", "code": "@[simp]\ntheorem lie_of [DecidableEq \u03b9] {i j : \u03b9} (x : L i) (y : L j) :\n    \u2045of L i x, of L j y\u2046 = if hij : j = i then lieAlgebraOf R \u03b9 L i \u2045x, hij.recOn y\u2046 else 0", "start": [200, 1], "end": [205, 72], "kind": "commanddeclaration"}, {"full_name": "DirectSum.toLieAlgebra", "code": "@[simps]\ndef toLieAlgebra [DecidableEq \u03b9] (L' : Type w\u2081) [LieRing L'] [LieAlgebra R L']\n    (f : \u2200 i, L i \u2192\u2097\u2045R\u2046 L') (hf : \u2200 i j : \u03b9, i \u2260 j \u2192 \u2200 (x : L i) (y : L j), \u2045f i x, f j y\u2046 = 0) :\n    (\u2a01 i, L i) \u2192\u2097\u2045R\u2046 L' :=\n  { toModule R \u03b9 L' fun i => (f i : L i \u2192\u2097[R] L') with\n    toFun := toModule R \u03b9 L' fun i => (f i : L i \u2192\u2097[R] L')\n    map_lie' := fun {x y} => by\n      let f' i := (f i : L i \u2192\u2097[R] L')\n      \n      suffices \u2200 (i : \u03b9) (y : L i),\n          toModule R \u03b9 L' f' \u2045x, of L i y\u2046 =\n            \u2045toModule R \u03b9 L' f' x, toModule R \u03b9 L' f' (of L i y)\u2046 by\n        simp only [\u2190 LieAlgebra.ad_apply R]\n        rw [\u2190 LinearMap.comp_apply, \u2190 LinearMap.comp_apply]\n        congr; clear y; ext i y; exact this i y\n      suffices \u2200 (i j) (y : L i) (x : L j),\n          toModule R \u03b9 L' f' \u2045of L j x, of L i y\u2046 =\n            \u2045toModule R \u03b9 L' f' (of L j x), toModule R \u03b9 L' f' (of L i y)\u2046 by\n        intro i y\n        rw [\u2190 lie_skew x, \u2190 lie_skew (toModule R \u03b9 L' f' x)]\n        simp only [LinearMap.map_neg, neg_inj, \u2190 LieAlgebra.ad_apply R]\n        rw [\u2190 LinearMap.comp_apply, \u2190 LinearMap.comp_apply]\n        congr; clear x; ext j x; exact this j i x y\n      intro i j y x\n      simp only [lie_of R, lieAlgebraOf_apply, LieHom.coe_toLinearMap, toAddMonoid_of,\n        coe_toModule_eq_coe_toAddMonoid, LinearMap.toAddMonoidHom_coe]\n      rcases eq_or_ne i j with (h | h)\n      \u00b7 have h' : f j (h.recOn y) = f i y := Eq.rec (Eq.refl _) h\n        simp only [h, h', LieHom.coe_toLinearMap, dif_pos, LieHom.map_lie, toAddMonoid_of,\n          LinearMap.toAddMonoidHom_coe]\n      \u00b7 simp only [h, hf j i h.symm x y, dif_neg, not_false_iff, AddMonoidHom.map_zero] }", "start": [210, 1], "end": [248, 90], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lieRingOfIdeals", "code": "instance lieRingOfIdeals : LieRing (\u2a01 i, I i) :=\n  DirectSum.lieRing fun i => \u21a5(I i)", "start": [257, 1], "end": [261, 36], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lieAlgebraOfIdeals", "code": "instance lieAlgebraOfIdeals : LieAlgebra R (\u2a01 i, I i) :=\n  DirectSum.lieAlgebra fun i => \u21a5(I i)", "start": [264, 1], "end": [266, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/MLList/Split.lean", "imports": ["lake-packages/std/Std/Data/MLList/Basic.lean", "Mathlib/Data/ULift.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MLList.getUpToFirstM", "code": "partial def getUpToFirstM (L : MLList m \u03b1) (p : \u03b1 \u2192 m (ULift Bool)) : m (List \u03b1 \u00d7 MLList m \u03b1) := do\n  match \u2190 L.uncons with\n  | none => return ([], nil)\n  | some (x, xs) => (if (\u2190 p x).down then\n      return ([x], xs)\n    else do\n      let (acc, R) \u2190 getUpToFirstM xs p\n      return (x :: acc, R))", "start": [19, 1], "end": [31, 28], "kind": "commanddeclaration"}, {"full_name": "MLList.getUpToFirst", "code": "def getUpToFirst (L : MLList m \u03b1) (p : \u03b1 \u2192 Bool) : m (List \u03b1 \u00d7 MLList m \u03b1) :=\n  L.getUpToFirstM fun a => pure (.up (p a))", "start": [33, 1], "end": [39, 44], "kind": "commanddeclaration"}, {"full_name": "MLList.splitWhileM", "code": "partial def splitWhileM (L : MLList m \u03b1) (p : \u03b1 \u2192 m (ULift Bool)) :\n    m (List \u03b1 \u00d7 MLList m \u03b1) := do\n  match \u2190 L.uncons with\n  | none => return ([], nil)\n  | some (x, xs) => (if (\u2190 p x).down then do\n      let (acc, R) \u2190 splitWhileM xs p\n      return (x :: acc, R)\n    else\n      return ([], cons x xs))", "start": [41, 1], "end": [57, 30], "kind": "commanddeclaration"}, {"full_name": "MLList.splitWhile", "code": "def splitWhile (L : MLList m \u03b1) (p : \u03b1 \u2192 Bool) : m (List \u03b1 \u00d7 MLList m \u03b1) :=\n  L.splitWhileM fun a => pure (.up (p a))", "start": [59, 1], "end": [68, 42], "kind": "commanddeclaration"}, {"full_name": "MLList.groupByM", "code": "partial def groupByM [DecidableEq \u03b2] (L : MLList m \u03b1) (f : \u03b1 \u2192 m \u03b2) : MLList m (\u03b2 \u00d7 List \u03b1) :=\n  L.cases (fun _ => nil) fun a t => squash fun _ => do\n    let b \u2190 f a\n    let (l, t') \u2190 t.splitWhileM (fun a => do return .up ((\u2190 f a) = b))\n    return cons (b, a :: l) (t'.groupByM f)", "start": [70, 1], "end": [80, 44], "kind": "commanddeclaration"}, {"full_name": "MLList.groupBy", "code": "def groupBy [DecidableEq \u03b2] (L : MLList m \u03b1) (f : \u03b1 \u2192 \u03b2) : MLList m (\u03b2 \u00d7 List \u03b1) :=\n  L.groupByM fun a => pure (f a)", "start": [82, 1], "end": [88, 33], "kind": "commanddeclaration"}, {"full_name": "MLList.splitAtBecomesTrueM", "code": "partial def splitAtBecomesTrueM (L : MLList m \u03b1) (p : \u03b1 \u2192 m (ULift Bool)) : MLList m (List \u03b1) :=\n  aux (L.groupByM p)\nwhere aux (M : MLList m (ULift.{u} Bool \u00d7 List \u03b1)) : MLList m (List \u03b1) :=\n  M.cases (fun _ => nil) fun (b, l) t => (if b.down then\n    t.cases (fun _ => cons l nil)\n      fun (_, l') t' => cons (l ++ l') (aux t')\n  else\n    cons l (aux t))", "start": [93, 1], "end": [104, 20], "kind": "commanddeclaration"}, {"full_name": "MLList.splitAtBecomesTrue", "code": "def splitAtBecomesTrue (L : MLList m \u03b1) (p : \u03b1 \u2192 Bool) : MLList m (List \u03b1) :=\n  L.splitAtBecomesTrueM fun a => pure (.up (p a))", "start": [106, 1], "end": [111, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/PointwisePi.lean", "imports": ["Mathlib/Data/Set/Pointwise/SMul.lean", "Mathlib/GroupTheory/GroupAction/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "smul_pi_subset", "code": "@[to_additive]\ntheorem smul_pi_subset [\u2200 i, SMul K (R i)] (r : K) (s : Set \u03b9) (t : \u2200 i, Set (R i)) :\n    r \u2022 pi s t \u2286 pi s (r \u2022 t)", "start": [28, 1], "end": [32, 35], "kind": "commanddeclaration"}, {"full_name": "smul_univ_pi", "code": "@[to_additive]\ntheorem smul_univ_pi [\u2200 i, SMul K (R i)] (r : K) (t : \u2200 i, Set (R i)) :\n    r \u2022 pi (univ : Set \u03b9) t = pi (univ : Set \u03b9) (r \u2022 t)", "start": [37, 1], "end": [43, 66], "kind": "commanddeclaration"}, {"full_name": "smul_pi", "code": "@[to_additive]\ntheorem smul_pi [Group K] [\u2200 i, MulAction K (R i)] (r : K) (S : Set \u03b9) (t : \u2200 i, Set (R i)) :\n    r \u2022 S.pi t = S.pi (r \u2022 t)", "start": [47, 1], "end": [51, 89], "kind": "commanddeclaration"}, {"full_name": "smul_pi\u2080", "code": "theorem smul_pi\u2080 [GroupWithZero K] [\u2200 i, MulAction K (R i)] {r : K} (S : Set \u03b9) (t : \u2200 i, Set (R i))\n    (hr : r \u2260 0) : r \u2022 S.pi t = S.pi (r \u2022 t)", "start": [55, 1], "end": [57, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Valuation/RamificationGroup.lean", "imports": ["Mathlib/RingTheory/Ideal/LocalRing.lean", "Mathlib/RingTheory/Valuation/ValuationSubring.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ValuationSubring.decompositionSubgroup", "code": "@[reducible]\ndef decompositionSubgroup (A : ValuationSubring L) : Subgroup (L \u2243\u2090[K] L) :=\n  MulAction.stabilizer (L \u2243\u2090[K] L) A", "start": [26, 1], "end": [30, 37], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.subMulAction", "code": "def subMulAction (A : ValuationSubring L) : SubMulAction (A.decompositionSubgroup K) L where\n  carrier := A\n  smul_mem' g _ h := Set.mem_of_mem_of_subset (Set.smul_mem_smul_set h) g.prop.le", "start": [33, 1], "end": [37, 82], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.decompositionSubgroupMulSemiringAction", "code": "instance decompositionSubgroupMulSemiringAction (A : ValuationSubring L) :\n    MulSemiringAction (A.decompositionSubgroup K) A :=\n  { SubMulAction.mulAction (A.subMulAction K) with\n    smul_add := fun g k l => Subtype.ext <| smul_add (A := L) g k l\n    smul_zero := fun g => Subtype.ext <| smul_zero g\n    smul_one := fun g => Subtype.ext <| smul_one g\n    smul_mul := fun g k l => Subtype.ext <| smul_mul' (A := L) g k l }", "start": [40, 1], "end": [47, 71], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.inertiaSubgroup", "code": "def inertiaSubgroup (A : ValuationSubring L) : Subgroup (A.decompositionSubgroup K) :=\n  MonoidHom.ker <|\n    MulSemiringAction.toRingAut (A.decompositionSubgroup K) (LocalRing.ResidueField A)", "start": [50, 1], "end": [54, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Hofer.lean", "imports": ["Mathlib/Analysis/SpecificLimits/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "pos_div_pow_pos", "code": "@[simp]\ntheorem pos_div_pow_pos {\u03b1 : Type*} [LinearOrderedSemifield \u03b1] {a b : \u03b1} (ha : 0 < a) (hb : 0 < b)\n    (k : \u2115) : 0 < a / b ^ k", "start": [30, 1], "end": [33, 28], "kind": "commanddeclaration"}, {"full_name": "hofer", "code": "theorem hofer {X : Type*} [MetricSpace X] [CompleteSpace X] (x : X) (\u03b5 : \u211d) (\u03b5_pos : 0 < \u03b5)\n    {\u03d5 : X \u2192 \u211d} (cont : Continuous \u03d5) (nonneg : \u2200 y, 0 \u2264 \u03d5 y) : \u2203 \u03b5' > 0, \u2203 x' : X,\n    \u03b5' \u2264 \u03b5 \u2227 d x' x \u2264 2 * \u03b5 \u2227 \u03b5 * \u03d5 x \u2264 \u03b5' * \u03d5 x' \u2227 \u2200 y, d x' y \u2264 \u03b5' \u2192 \u03d5 y \u2264 2 * \u03d5 x'", "start": [36, 1], "end": [110, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/ExteriorAlgebra/OfAlternating.lean", "imports": ["Mathlib/LinearAlgebra/ExteriorAlgebra/Basic.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Fold.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlternatingMap.instModuleAddCommGroup", "code": "instance AlternatingMap.instModuleAddCommGroup {\u03b9 : Type*} :\n    Module R (AlternatingMap R M N \u03b9) := by\n  infer_instance", "start": [35, 1], "end": [37, 17], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.liftAlternating", "code": "def liftAlternating : (\u2200 i, AlternatingMap R M N (Fin i)) \u2192\u2097[R] ExteriorAlgebra R M \u2192\u2097[R] N := by\n  suffices\n    (\u2200 i, AlternatingMap R M N (Fin i)) \u2192\u2097[R]\n      ExteriorAlgebra R M \u2192\u2097[R] \u2200 i, AlternatingMap R M N (Fin i) by\n    refine' LinearMap.compr\u2082 this _\n    refine' (LinearEquiv.toLinearMap _).comp (LinearMap.proj 0)\n    exact AlternatingMap.constLinearEquivOfIsEmpty.symm\n  refine' CliffordAlgebra.foldl _ _ _\n  \u00b7 refine'\n      LinearMap.mk\u2082 R (fun m f i => (f i.succ).curryLeft m) (fun m\u2081 m\u2082 f => _) (fun c m f => _)\n        (fun m f\u2081 f\u2082 => _) fun c m f => _\n    all_goals\n      ext i : 1\n      simp only [map_smul, map_add, Pi.add_apply, Pi.smul_apply, AlternatingMap.curryLeft_add,\n        AlternatingMap.curryLeft_smul, map_add, map_smul, LinearMap.add_apply, LinearMap.smul_apply]\n  \u00b7 intro m x\n    dsimp only [LinearMap.mk\u2082_apply, QuadraticForm.coeFn_zero, Pi.zero_apply]\n    simp_rw [zero_smul]\n    ext i : 1\n    exact AlternatingMap.curryLeft_same _ _", "start": [44, 1], "end": [66, 44], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.liftAlternating_\u03b9", "code": "@[simp]\ntheorem liftAlternating_\u03b9 (f : \u2200 i, AlternatingMap R M N (Fin i)) (m : M) :\n    liftAlternating (R := R) (M := M) (N := N) f (\u03b9 R m) = f 1 ![m]", "start": [69, 1], "end": [78, 25], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.liftAlternating_\u03b9_mul", "code": "theorem liftAlternating_\u03b9_mul (f : \u2200 i, AlternatingMap R M N (Fin i)) (m : M)\n    (x : ExteriorAlgebra R M) :\n    liftAlternating (R := R) (M := M) (N := N) f (\u03b9 R m * x) =\n    liftAlternating (R := R) (M := M) (N := N) (fun i => (f i.succ).curryLeft m) x", "start": [81, 1], "end": [87, 6], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.liftAlternating_one", "code": "@[simp]\ntheorem liftAlternating_one (f : \u2200 i, AlternatingMap R M N (Fin i)) :\n    liftAlternating (R := R) (M := M) (N := N) f (1 : ExteriorAlgebra R M) = f 0 0", "start": [90, 1], "end": [94, 17], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.liftAlternating_algebraMap", "code": "@[simp]\ntheorem liftAlternating_algebraMap (f : \u2200 i, AlternatingMap R M N (Fin i)) (r : R) :\n    liftAlternating (R := R) (M := M) (N := N) f (algebraMap _ (ExteriorAlgebra R M) r) =\n    r \u2022 f 0 0", "start": [97, 1], "end": [101, 69], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.liftAlternating_apply_\u03b9Multi", "code": "@[simp]\ntheorem liftAlternating_apply_\u03b9Multi {n : \u2115} (f : \u2200 i, AlternatingMap R M N (Fin i))\n    (v : Fin n \u2192 M) : liftAlternating (R := R) (M := M) (N := N) f (\u03b9Multi R n v) = f n v", "start": [104, 1], "end": [117, 34], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.liftAlternating_comp_\u03b9Multi", "code": "@[simp]\ntheorem liftAlternating_comp_\u03b9Multi {n : \u2115} (f : \u2200 i, AlternatingMap R M N (Fin i)) :\n    (liftAlternating (R := R) (M := M) (N := N) f).compAlternatingMap (\u03b9Multi R n) = f n", "start": [120, 1], "end": [123, 55], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.liftAlternating_comp", "code": "@[simp]\ntheorem liftAlternating_comp (g : N \u2192\u2097[R] N') (f : \u2200 i, AlternatingMap R M N (Fin i)) :\n    (liftAlternating (R := R) (M := M) (N := N') fun i => g.compAlternatingMap (f i)) =\n    g \u2218\u2097 liftAlternating (R := R) (M := M) (N := N) f", "start": [126, 1], "end": [137, 58], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.liftAlternating_\u03b9Multi", "code": "@[simp]\ntheorem liftAlternating_\u03b9Multi :\n    liftAlternating (R := R) (M := M) (N := ExteriorAlgebra R M) (\u03b9Multi R) =\n    (LinearMap.id : ExteriorAlgebra R M \u2192\u2097[R] ExteriorAlgebra R M)", "start": [140, 1], "end": [150, 57], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.liftAlternatingEquiv", "code": "@[simps apply symm_apply]\ndef liftAlternatingEquiv : (\u2200 i, AlternatingMap R M N (Fin i)) \u2243\u2097[R] ExteriorAlgebra R M \u2192\u2097[R] N\n    where\n  toFun := liftAlternating (R := R)\n  map_add' := map_add _\n  map_smul' := map_smul _\n  invFun F i := F.compAlternatingMap (\u03b9Multi R i)\n  left_inv f := funext fun i => liftAlternating_comp_\u03b9Multi _\n  right_inv F :=\n    (liftAlternating_comp _ _).trans <| by rw [liftAlternating_\u03b9Multi, LinearMap.comp_id]", "start": [153, 1], "end": [163, 90], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.lhom_ext", "code": "@[ext]\ntheorem lhom_ext \u2983f g : ExteriorAlgebra R M \u2192\u2097[R] N\u2984\n    (h : \u2200 i, f.compAlternatingMap (\u03b9Multi R i) = g.compAlternatingMap (\u03b9Multi R i)) : f = g", "start": [166, 1], "end": [173, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Vector/Zip.lean", "imports": ["Mathlib/Data/Vector/Basic.lean", "Mathlib/Data/List/Zip.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Vector.zipWith", "code": "def zipWith : Vector \u03b1 n \u2192 Vector \u03b2 n \u2192 Vector \u03b3 n := fun x y => \u27e8List.zipWith f x.1 y.1, by simp\u27e9", "start": [22, 1], "end": [23, 99], "kind": "commanddeclaration"}, {"full_name": "Vector.zipWith_toList", "code": "@[simp]\ntheorem zipWith_toList (x : Vector \u03b1 n) (y : Vector \u03b2 n) :\n    (Vector.zipWith f x y).toList = List.zipWith f x.toList y.toList", "start": [26, 1], "end": [29, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.zipWith_get", "code": "@[simp]\ntheorem zipWith_get (x : Vector \u03b1 n) (y : Vector \u03b2 n) (i) :\n    (Vector.zipWith f x y).get i = f (x.get i) (y.get i)", "start": [32, 1], "end": [37, 33], "kind": "commanddeclaration"}, {"full_name": "Vector.zipWith_tail", "code": "@[simp]\ntheorem zipWith_tail (x : Vector \u03b1 n) (y : Vector \u03b2 n) :\n    (Vector.zipWith f x y).tail = Vector.zipWith f x.tail y.tail", "start": [40, 1], "end": [44, 18], "kind": "commanddeclaration"}, {"full_name": "Vector.prod_mul_prod_eq_prod_zipWith", "code": "@[to_additive]\ntheorem prod_mul_prod_eq_prod_zipWith [CommMonoid \u03b1] (x y : Vector \u03b1 n) :\n    x.toList.prod * y.toList.prod = (Vector.zipWith (\u00b7 * \u00b7) x y).toList.prod", "start": [47, 1], "end": [51, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/Morphisms/UniversallyClosed.lean", "imports": ["Mathlib/Topology/LocalAtTarget.lean", "Mathlib/AlgebraicGeometry/Morphisms/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicGeometry.UniversallyClosed", "code": "@[mk_iff]\nclass UniversallyClosed (f : X \u27f6 Y) : Prop where\n  out : universally (topologically @IsClosedMap) f", "start": [37, 1], "end": [42, 51], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.universallyClosed_eq", "code": "theorem universallyClosed_eq : @UniversallyClosed = universally (topologically @IsClosedMap)", "start": [45, 1], "end": [46, 40], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.universallyClosed_respectsIso", "code": "theorem universallyClosed_respectsIso : RespectsIso @UniversallyClosed", "start": [49, 1], "end": [50, 83], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.universallyClosed_stableUnderBaseChange", "code": "theorem universallyClosed_stableUnderBaseChange : StableUnderBaseChange @UniversallyClosed", "start": [53, 1], "end": [54, 93], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.universallyClosed_stableUnderComposition", "code": "theorem universallyClosed_stableUnderComposition : StableUnderComposition @UniversallyClosed", "start": [57, 1], "end": [60, 59], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.universallyClosedTypeComp", "code": "instance universallyClosedTypeComp {X Y Z : Scheme} (f : X \u27f6 Y) (g : Y \u27f6 Z)\n    [hf : UniversallyClosed f] [hg : UniversallyClosed g] : UniversallyClosed (f \u226b g) :=\n  universallyClosed_stableUnderComposition f g hf hg", "start": [63, 1], "end": [65, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.universallyClosedFst", "code": "instance universallyClosedFst {X Y Z : Scheme} (f : X \u27f6 Z) (g : Y \u27f6 Z) [hg : UniversallyClosed g] :\n    UniversallyClosed (pullback.fst : pullback f g \u27f6 _) :=\n  universallyClosed_stableUnderBaseChange.fst f g hg", "start": [68, 1], "end": [70, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.universallyClosedSnd", "code": "instance universallyClosedSnd {X Y Z : Scheme} (f : X \u27f6 Z) (g : Y \u27f6 Z) [hf : UniversallyClosed f] :\n    UniversallyClosed (pullback.snd : pullback f g \u27f6 _) :=\n  universallyClosed_stableUnderBaseChange.snd f g hf", "start": [73, 1], "end": [75, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.morphismRestrict_base", "code": "theorem morphismRestrict_base {X Y : Scheme} (f : X \u27f6 Y) (U : Opens Y.carrier) :\n    \u21d1(f \u2223_ U).1.base = U.1.restrictPreimage f.1.1", "start": [78, 1], "end": [80, 65], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.universallyClosed_is_local_at_target", "code": "theorem universallyClosed_is_local_at_target : PropertyIsLocalAtTarget @UniversallyClosed", "start": [83, 1], "end": [91, 64], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.UniversallyClosed.openCover_iff", "code": "theorem UniversallyClosed.openCover_iff {X Y : Scheme.{u}} (f : X \u27f6 Y)\n    (\ud835\udcb0 : Scheme.OpenCover.{u} Y) :\n    UniversallyClosed f \u2194 \u2200 i, UniversallyClosed (pullback.snd : pullback f (\ud835\udcb0.map i) \u27f6 _)", "start": [94, 1], "end": [97, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Products/Associator.lean", "imports": ["Mathlib/CategoryTheory/Products/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.prod.associator", "code": "@[simps]\ndef associator : (C \u00d7 D) \u00d7 E \u2964 C \u00d7 D \u00d7 E\n    where\n  obj X := (X.1.1, (X.1.2, X.2))\n  map := @fun _ _ f => (f.1.1, (f.1.2, f.2))", "start": [24, 1], "end": [30, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.prod.inverseAssociator", "code": "@[simps]\ndef inverseAssociator : C \u00d7 D \u00d7 E \u2964 (C \u00d7 D) \u00d7 E\n    where\n  obj X := ((X.1, X.2.1), X.2.2)\n  map := @fun _ _ f => ((f.1, f.2.1), f.2.2)", "start": [33, 1], "end": [39, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.prod.associativity", "code": "def associativity : (C \u00d7 D) \u00d7 E \u224c C \u00d7 D \u00d7 E :=\n  Equivalence.mk (associator C D E) (inverseAssociator C D E)\n    (NatIso.ofComponents fun X => eqToIso (by simp))\n    (NatIso.ofComponents fun X => eqToIso (by simp))", "start": [42, 1], "end": [47, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.prod.associatorIsEquivalence", "code": "instance associatorIsEquivalence : IsEquivalence (associator C D E) :=\n  (by infer_instance : IsEquivalence (associativity C D E).functor)", "start": [50, 1], "end": [51, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.prod.inverseAssociatorIsEquivalence", "code": "instance inverseAssociatorIsEquivalence : IsEquivalence (inverseAssociator C D E) :=\n  (by infer_instance : IsEquivalence (associativity C D E).inverse)", "start": [54, 1], "end": [55, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Internal/Module.lean", "imports": ["Mathlib/Algebra/Category/ModuleCat/Monoidal/Basic.lean", "Mathlib/Algebra/Category/AlgebraCat/Basic.lean", "Mathlib/CategoryTheory/Monoidal/Mon_.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ModuleCat.MonModuleEquivalenceAlgebra.Ring_of_Mon_", "code": "instance Ring_of_Mon_ (A : Mon_ (ModuleCat.{u} R)) : Ring A.X :=\n  { (inferInstance : AddCommGroup A.X) with\n    one := A.one (1 : R)\n    mul := fun x y => A.mul (x \u2297\u209c y)\n    one_mul := fun x => by\n      have := LinearMap.congr_fun A.one_mul ((1 : R) \u2297\u209c x)\n      convert this\n      rw [MonoidalCategory.leftUnitor_hom_apply, one_smul]\n    mul_one := fun x => by\n      have := LinearMap.congr_fun A.mul_one (x \u2297\u209c (1 : R))\n      convert this\n      erw [MonoidalCategory.leftUnitor_hom_apply, one_smul]\n    mul_assoc := fun x y z => by\n      have := LinearMap.congr_fun A.mul_assoc (x \u2297\u209c y \u2297\u209c z)\n      convert this\n    left_distrib := fun x y z => by\n      have := A.mul.map_add (x \u2297\u209c y) (x \u2297\u209c z)\n      convert this\n      rw [\u2190 TensorProduct.tmul_add]\n      rfl\n    right_distrib := fun x y z => by\n      have := A.mul.map_add (x \u2297\u209c z) (y \u2297\u209c z)\n      convert this\n      rw [\u2190 TensorProduct.add_tmul]\n      rfl\n    zero_mul := fun x => show A.mul _ = 0 by\n      rw [TensorProduct.zero_tmul, map_zero]\n    mul_zero := fun x => show A.mul _ = 0 by\n      rw [TensorProduct.tmul_zero, map_zero] }", "start": [46, 1], "end": [74, 47], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.MonModuleEquivalenceAlgebra.Algebra_of_Mon_", "code": "instance Algebra_of_Mon_ (A : Mon_ (ModuleCat.{u} R)) : Algebra R A.X :=\n  { A.one with\n    map_zero' := A.one.map_zero\n    map_one' := rfl\n    map_mul' := fun x y => by\n      have h := LinearMap.congr_fun A.one_mul.symm (x \u2297\u209c A.one y)\n      rwa [MonoidalCategory.leftUnitor_hom_apply, \u2190 A.one.map_smul] at h\n    commutes' := fun r a => by\n      dsimp\n      have h\u2081 := LinearMap.congr_fun A.one_mul (r \u2297\u209c a)\n      have h\u2082 := LinearMap.congr_fun A.mul_one (a \u2297\u209c r)\n      exact h\u2081.trans h\u2082.symm\n    smul_def' := fun r a => (LinearMap.congr_fun A.one_mul (r \u2297\u209c a)).symm }", "start": [76, 1], "end": [88, 76], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.MonModuleEquivalenceAlgebra.algebraMap", "code": "@[simp]\ntheorem algebraMap (A : Mon_ (ModuleCat.{u} R)) (r : R) : algebraMap R A.X r = A.one r", "start": [90, 1], "end": [92, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.MonModuleEquivalenceAlgebra.functor", "code": "@[simps!]\ndef functor : Mon_ (ModuleCat.{u} R) \u2964 AlgebraCat R where\n  obj A := AlgebraCat.of R A.X\n  map {A B} f :=\n    { f.hom.toAddMonoidHom with\n      toFun := f.hom\n      map_one' := LinearMap.congr_fun f.one_hom (1 : R)\n      map_mul' := fun x y => LinearMap.congr_fun f.mul_hom (x \u2297\u209c y)\n      commutes' := fun r => LinearMap.congr_fun f.one_hom r }", "start": [95, 1], "end": [105, 62], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.MonModuleEquivalenceAlgebra.inverseObj", "code": "@[simps]\ndef inverseObj (A : AlgebraCat.{u} R) : Mon_ (ModuleCat.{u} R) where\n  X := ModuleCat.of R A\n  one := Algebra.linearMap R A\n  mul := LinearMap.mul' R A\n  one_mul := by\n    refine TensorProduct.ext <| LinearMap.ext_ring <| LinearMap.ext fun x => ?_\n    erw [compr\u2082_apply, compr\u2082_apply, CategoryTheory.comp_apply]\n    erw [LinearMap.mul'_apply, MonoidalCategory.leftUnitor_hom_apply, \u2190 Algebra.smul_def]\n    rw [id_apply]\n  mul_one := by\n    refine TensorProduct.ext <| LinearMap.ext fun x => LinearMap.ext_ring ?_\n    erw [compr\u2082_apply, compr\u2082_apply]\n    erw [CategoryTheory.comp_apply]\n    erw [LinearMap.mul'_apply, ModuleCat.MonoidalCategory.rightUnitor_hom_apply, \u2190 Algebra.commutes,\n      \u2190 Algebra.smul_def]\n    rw [id_apply]\n  mul_assoc := by\n    refine TensorProduct.ext <| TensorProduct.ext <| LinearMap.ext fun x => LinearMap.ext fun y =>\n      LinearMap.ext fun z => ?_\n    rw [compr\u2082_apply, compr\u2082_apply, compr\u2082_apply, compr\u2082_apply]\n    erw [CategoryTheory.comp_apply,\n      CategoryTheory.comp_apply, CategoryTheory.comp_apply]\n    erw [LinearMap.mul'_apply, LinearMap.mul'_apply]\n    rw [id_apply, TensorProduct.mk_apply]\n    erw [TensorProduct.mk_apply, TensorProduct.mk_apply, id_apply, LinearMap.mul'_apply,\n      LinearMap.mul'_apply]\n    simp only [LinearMap.mul'_apply, mul_assoc]", "start": [108, 1], "end": [159, 48], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.MonModuleEquivalenceAlgebra.inverse", "code": "@[simps]\ndef inverse : AlgebraCat.{u} R \u2964 Mon_ (ModuleCat.{u} R) where\n  obj := inverseObj\n  map f :=\n    { hom := f.toLinearMap\n      one_hom := LinearMap.ext f.commutes\n      mul_hom := TensorProduct.ext <| LinearMap.ext\u2082 <| f.map_mul }", "start": [162, 1], "end": [170, 68], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.monModuleEquivalenceAlgebra", "code": "def monModuleEquivalenceAlgebra : Mon_ (ModuleCat.{u} R) \u224c AlgebraCat R where\n  functor := functor\n  inverse := inverse\n  unitIso :=\n    NatIso.ofComponents\n      (fun A =>\n        { hom :=\n            { hom :=\n                { toFun := _root_.id\n                  map_add' := fun x y => rfl\n                  map_smul' := fun r a => rfl }\n              mul_hom := by\n                refine TensorProduct.ext ?_\n                dsimp at *\n                rfl\n              one_hom := by ext; rfl }\n          inv :=\n            { hom :=\n                { toFun := _root_.id\n                  map_add' := fun x y => rfl\n                  map_smul' := fun r a => rfl }\n              mul_hom := by\n                refine TensorProduct.ext ?_\n                dsimp at *\n                rfl\n              one_hom := by ext; rfl }\n          hom_inv_id := by ext; rfl\n          inv_hom_id := by ext; rfl })\n      (by aesop_cat)\n  counitIso :=\n    NatIso.ofComponents\n      (fun A =>\n        { hom :=\n            { toFun := _root_.id\n              map_zero' := rfl\n              map_add' := fun x y => rfl\n              map_one' := (algebraMap R A).map_one\n              map_mul' := fun x y => @LinearMap.mul'_apply R _ _ _ _ _ _ x y\n              commutes' := fun r => rfl }\n          inv :=\n            { toFun := _root_.id\n              map_zero' := rfl\n              map_add' := fun x y => rfl\n              map_one' := (algebraMap R A).map_one.symm\n              map_mul' := fun x y => (@LinearMap.mul'_apply R _ _ _ _ _ _ x y).symm\n              commutes' := fun r => rfl } })\n      (by intros; rfl)", "start": [178, 1], "end": [229, 23], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.monModuleEquivalenceAlgebraForget", "code": "def monModuleEquivalenceAlgebraForget :\n    MonModuleEquivalenceAlgebra.functor \u22d9 forget\u2082 (AlgebraCat.{u} R) (ModuleCat.{u} R) \u2245\n      Mon_.forget (ModuleCat.{u} R) :=\n  NatIso.ofComponents\n    (fun A =>\n      { hom :=\n          { toFun := _root_.id\n            map_add' := fun x y => rfl\n            map_smul' := fun c x => rfl }\n        inv :=\n          { toFun := _root_.id\n            map_add' := fun x y => rfl\n            map_smul' := fun c x => rfl } })\n    (by aesop_cat)", "start": [235, 1], "end": [251, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Localization/Composition.lean", "imports": ["Mathlib/CategoryTheory/Localization/LocalizerMorphism.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.comp", "code": "def StrictUniversalPropertyFixedTarget.comp\n    (h\u2081 : StrictUniversalPropertyFixedTarget L\u2081 W\u2081 E)\n    (h\u2082 : StrictUniversalPropertyFixedTarget L\u2082 W\u2082 E)\n    (W\u2083 : MorphismProperty C\u2081) (hW\u2083 : W\u2083.IsInvertedBy (L\u2081 \u22d9 L\u2082))\n    (hW\u2081\u2083 : W\u2081 \u2286 W\u2083) (hW\u2082\u2083 : W\u2082 \u2286 W\u2083.map L\u2081) :\n    StrictUniversalPropertyFixedTarget (L\u2081 \u22d9 L\u2082) W\u2083 E where\n  inverts := hW\u2083\n  lift F hF := h\u2082.lift (h\u2081.lift F (MorphismProperty.IsInvertedBy.of_subset _ _  F hF hW\u2081\u2083)) (by\n    refine' MorphismProperty.IsInvertedBy.of_subset _ _ _ _ hW\u2082\u2083\n    simpa only [MorphismProperty.IsInvertedBy.map_iff, h\u2081.fac F] using hF)\n  fac F hF := by rw [Functor.assoc, h\u2082.fac, h\u2081.fac]\n  uniq F\u2081 F\u2082 h := h\u2082.uniq _ _ (h\u2081.uniq _ _ (by simpa only [Functor.assoc] using h))", "start": [31, 1], "end": [44, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.IsLocalization.comp", "code": "lemma comp [L\u2081.IsLocalization W\u2081] [L\u2082.IsLocalization W\u2082]\n    (W\u2083 : MorphismProperty C\u2081) (hW\u2083 : W\u2083.IsInvertedBy (L\u2081 \u22d9 L\u2082))\n    (hW\u2081\u2083 : W\u2081 \u2286 W\u2083) (hW\u2082\u2083 : W\u2082 \u2286 W\u2083.map L\u2081) :\n    (L\u2081 \u22d9 L\u2082).IsLocalization W\u2083 := by\n  let E\u2082 := Localization.uniq L\u2081 W\u2081.Q W\u2081\n  let W\u2082' := W\u2082.map E\u2082.functor\n  let \u03a6 : LocalizerMorphism W\u2082 W\u2082' :=\n    { functor := E\u2082.functor\n      map := by\n        have eq := W\u2082.isoClosure.inverseImage_map_eq_of_isEquivalence\n          W\u2082.isoClosure_respectsIso E\u2082.functor\n        rw [MorphismProperty.map_isoClosure] at eq\n        rw [eq]\n        apply W\u2082.subset_isoClosure }\n  have := LocalizerMorphism.IsLocalizedEquivalence.of_equivalence \u03a6 (by rfl)\n  let E\u2083 := (\u03a6.localizedFunctor L\u2082 W\u2082'.Q).asEquivalence\n  let iso : (W\u2081.Q \u22d9 W\u2082'.Q) \u22d9 E\u2083.inverse \u2245 L\u2081 \u22d9 L\u2082 := by\n    calc\n      _ \u2245 L\u2081 \u22d9 E\u2082.functor \u22d9 W\u2082'.Q \u22d9 E\u2083.inverse :=\n          Functor.associator _ _ _ \u226a\u226b isoWhiskerRight (compUniqFunctor L\u2081 W\u2081.Q W\u2081).symm _ \u226a\u226b\n            Functor.associator _ _ _\n      _ \u2245 L\u2081 \u22d9 L\u2082 \u22d9 E\u2083.functor \u22d9 E\u2083.inverse :=\n          isoWhiskerLeft _ ((Functor.associator _ _ _).symm \u226a\u226b\n            isoWhiskerRight (\u03a6.catCommSq L\u2082 W\u2082'.Q).iso E\u2083.inverse \u226a\u226b Functor.associator _ _ _)\n      _ \u2245 L\u2081 \u22d9 L\u2082 := isoWhiskerLeft _ (isoWhiskerLeft _ E\u2083.unitIso.symm \u226a\u226b L\u2082.rightUnitor)\n  have hW\u2083' : W\u2083.IsInvertedBy (W\u2081.Q \u22d9 W\u2082'.Q) := by\n    simpa only [\u2190 MorphismProperty.IsInvertedBy.iff_comp _ _ E\u2083.inverse,\n      MorphismProperty.IsInvertedBy.iff_of_iso W\u2083 iso] using hW\u2083\n  have hW\u2082\u2083' : W\u2082' \u2286 W\u2083.map W\u2081.Q := (MorphismProperty.monotone_map _ _ E\u2082.functor hW\u2082\u2083).trans\n    (by simpa only [W\u2083.map_map]\n      using subset_of_eq (W\u2083.map_eq_of_iso (compUniqFunctor L\u2081 W\u2081.Q W\u2081)))\n  have : (W\u2081.Q \u22d9 W\u2082'.Q).IsLocalization W\u2083 := by\n    refine' IsLocalization.mk' _ _ _ _\n    all_goals\n      exact (StrictUniversalPropertyFixedTarget.comp\n        (strictUniversalPropertyFixedTargetQ W\u2081 _)\n        (strictUniversalPropertyFixedTargetQ W\u2082' _) W\u2083 hW\u2083' hW\u2081\u2083 hW\u2082\u2083')\n  exact IsLocalization.of_equivalence_target _ W\u2083 _ E\u2083.symm iso", "start": [56, 1], "end": [107, 64], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.IsLocalization.of_comp", "code": "lemma of_comp (W\u2083 : MorphismProperty C\u2081)\n    [L\u2081.IsLocalization W\u2081] [(L\u2081 \u22d9 L\u2082).IsLocalization W\u2083]\n    (hW\u2081\u2083 : W\u2081 \u2286 W\u2083) (hW\u2082\u2083 : W\u2082 = W\u2083.map L\u2081) :\n    L\u2082.IsLocalization W\u2082 := by\n    have : (L\u2081 \u22d9 W\u2082.Q).IsLocalization W\u2083 :=\n      comp L\u2081 W\u2082.Q W\u2081 W\u2082 W\u2083 (fun X Y f hf => Localization.inverts W\u2082.Q W\u2082 _\n        (by simpa only [hW\u2082\u2083] using W\u2083.map_mem_map _ _ hf)) hW\u2081\u2083\n        (by rw [hW\u2082\u2083, MorphismProperty.subset_iff_le])\n    exact IsLocalization.of_equivalence_target W\u2082.Q W\u2082 L\u2082\n      (Localization.uniq (L\u2081 \u22d9 W\u2082.Q) (L\u2081 \u22d9 L\u2082) W\u2083)\n      (liftNatIso L\u2081 W\u2081 _ _ _ _\n        ((Functor.associator _ _ _).symm \u226a\u226b\n          Localization.compUniqFunctor (L\u2081 \u22d9 W\u2082.Q) (L\u2081 \u22d9 L\u2082) W\u2083))", "start": [109, 1], "end": [121, 66], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/CategoryTheory/Category/Cat/Limit.lean", "imports": ["Mathlib/CategoryTheory/Category/Cat.lean", "Mathlib/CategoryTheory/Limits/Types.lean", "Mathlib/CategoryTheory/Limits/Preserves/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Cat.HasLimits.categoryObjects", "code": "instance categoryObjects {F : J \u2964 Cat.{u, u}} {j} :\n    SmallCategory ((F \u22d9 Cat.objects.{u, u}).obj j) :=\n  (F.obj j).str", "start": [39, 1], "end": [41, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.HasLimits.homDiagram", "code": "@[simps]\ndef homDiagram {F : J \u2964 Cat.{v, v}} (X Y : limit (F \u22d9 Cat.objects.{v, v})) : J \u2964 Type v where\n  obj j := limit.\u03c0 (F \u22d9 Cat.objects) j X \u27f6 limit.\u03c0 (F \u22d9 Cat.objects) j Y\n  map f g := by\n    refine' eqToHom _ \u226b (F.map f).map g \u226b eqToHom _\n    exact (congr_fun (limit.w (F \u22d9 Cat.objects) f) X).symm\n    exact congr_fun (limit.w (F \u22d9 Cat.objects) f) Y\n  map_id X := by\n    funext f\n    letI : Category (objects.obj (F.obj X)) := (inferInstance : Category (F.obj X))\n    simp [Functor.congr_hom (F.map_id X) f]\n  map_comp {_ _ Z} f g := by\n    funext h\n    letI : Category (objects.obj (F.obj Z)) := (inferInstance : Category (F.obj Z))\n    simp [Functor.congr_hom (F.map_comp f g) h, eqToHom_map]", "start": [45, 1], "end": [61, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.HasLimits.limitConeX", "code": "@[simps]\ndef limitConeX (F : J \u2964 Cat.{v, v}) : Cat.{v, v} where \u03b1 := limit (F \u22d9 Cat.objects)", "start": [81, 1], "end": [83, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.HasLimits.limitCone", "code": "@[simps]\ndef limitCone (F : J \u2964 Cat.{v, v}) : Cone F where\n  pt := limitConeX F\n  \u03c0 :=\n    { app := fun j =>\n        { obj := limit.\u03c0 (F \u22d9 Cat.objects) j\n          map := fun f => limit.\u03c0 (homDiagram _ _) j f }\n      naturality := fun j j' f =>\n        CategoryTheory.Functor.ext (fun X => (congr_fun (limit.w (F \u22d9 Cat.objects) f) X).symm)\n          fun X Y h => (congr_fun (limit.w (homDiagram X Y) f) h).symm }", "start": [87, 1], "end": [97, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.HasLimits.limitConeLift", "code": "@[simps]\ndef limitConeLift (F : J \u2964 Cat.{v, v}) (s : Cone F) : s.pt \u27f6 limitConeX F where\n  obj :=\n    limit.lift (F \u22d9 Cat.objects)\n      { pt := s.pt\n        \u03c0 :=\n          { app := fun j => (s.\u03c0.app j).obj\n            naturality := fun _ _ f => Functor.congr_map objects (s.\u03c0.naturality f) } }\n  map f := by\n    fapply Types.Limit.mk.{v, v}\n    \u00b7 intro j\n      refine' eqToHom _ \u226b (s.\u03c0.app j).map f \u226b eqToHom _ <;> simp\n    \u00b7 intro j j' h\n      dsimp\n      simp only [Category.assoc, Functor.map_comp, eqToHom_map, eqToHom_trans,\n        eqToHom_trans_assoc, \u2190 Functor.comp_map]\n      have := (s.\u03c0.naturality h).symm\n      dsimp at this\n      rw [Category.id_comp] at this\n      erw [Functor.congr_hom this f]\n      simp", "start": [101, 1], "end": [122, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.HasLimits.limit_\u03c0_homDiagram_eqToHom", "code": "@[simp]\ntheorem limit_\u03c0_homDiagram_eqToHom {F : J \u2964 Cat.{v, v}} (X Y : limit (F \u22d9 Cat.objects.{v, v}))\n    (j : J) (h : X = Y) :\n    limit.\u03c0 (homDiagram X Y) j (eqToHom h) =\n      eqToHom (congr_arg (limit.\u03c0 (F \u22d9 Cat.objects.{v, v}) j) h)", "start": [126, 1], "end": [132, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.HasLimits.limitConeIsLimit", "code": "def limitConeIsLimit (F : J \u2964 Cat.{v, v}) : IsLimit (limitCone F) where\n  lift := limitConeLift F\n  fac s j := CategoryTheory.Functor.ext (by simp) fun X Y f => by\n    dsimp [limitConeLift]\n    exact Types.Limit.\u03c0_mk.{v, v} _ _ _ _\n  uniq s m w := by\n    symm\n    refine' CategoryTheory.Functor.ext _ _\n    \u00b7 intro X\n      apply Types.limit_ext.{v, v}\n      intro j\n      simp [Types.Limit.lift_\u03c0_apply', \u2190 w j]\n    \u00b7 intro X Y f\n      dsimp\n      simp [fun j => Functor.congr_hom (w j).symm f]", "start": [136, 1], "end": [151, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/LazyList/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/LazyList.lean", "Mathlib/Lean/Thunk.lean", "Mathlib/Control/Traversable/Equiv.lean", "Mathlib/Control/Traversable/Instances.lean"], "premises": [{"full_name": "LazyList.listEquivLazyList", "code": "def listEquivLazyList (\u03b1 : Type*) : List \u03b1 \u2243 LazyList \u03b1 where\n  toFun := LazyList.ofList\n  invFun := LazyList.toList\n  right_inv := by\n    intro xs\n    induction' xs using LazyList.rec with _ _ _ _ ih\n    \u00b7 rfl\n    \u00b7 simpa only [toList, ofList, cons.injEq, true_and]\n    \u00b7 rw [Thunk.get, ih]\n  left_inv := by\n    intro xs\n    induction xs\n    \u00b7 rfl\n    \u00b7 simpa [ofList, toList]", "start": [28, 1], "end": [42, 29], "kind": "commanddeclaration"}, {"full_name": "LazyList.decidableEq", "code": "instance decidableEq {\u03b1 : Type u} [DecidableEq \u03b1] : DecidableEq (LazyList \u03b1)\n  | nil, nil => isTrue rfl\n  | cons x xs, cons y ys =>\n    if h : x = y then\n      match decidableEq xs.get ys.get with\n      | isFalse h2 => by\n        apply isFalse; simp only [cons.injEq, not_and]; intro _ xs_ys; apply h2; rw [xs_ys]\n      | isTrue h2 => by apply isTrue; congr; ext; exact h2\n    else by apply isFalse; simp only [cons.injEq, not_and]; intro; contradiction\n  | nil, cons _ _ => by apply isFalse; simp\n  | cons _ _, nil => by apply isFalse; simp", "start": [46, 1], "end": [56, 44], "kind": "commanddeclaration"}, {"full_name": "LazyList.traverse", "code": "protected def traverse {m : Type u \u2192 Type u} [Applicative m] {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 m \u03b2) :\n    LazyList \u03b1 \u2192 m (LazyList \u03b2)\n  | LazyList.nil => pure LazyList.nil\n  | LazyList.cons x xs => LazyList.cons <$> f x <*> Thunk.pure <$> xs.get.traverse f", "start": [58, 1], "end": [62, 85], "kind": "commanddeclaration"}, {"full_name": "LazyList.init", "code": "def init {\u03b1} : LazyList \u03b1 \u2192 LazyList \u03b1\n  | LazyList.nil => LazyList.nil\n  | LazyList.cons x xs =>\n    let xs' := xs.get\n    match xs' with\n    | LazyList.nil => LazyList.nil\n    | LazyList.cons _ _ => LazyList.cons x (init xs')", "start": [90, 1], "end": [98, 54], "kind": "commanddeclaration"}, {"full_name": "LazyList.find", "code": "def find {\u03b1} (p : \u03b1 \u2192 Prop) [DecidablePred p] : LazyList \u03b1 \u2192 Option \u03b1\n  | nil => none\n  | cons h t => if p h then some h else t.get.find p", "start": [101, 1], "end": [105, 53], "kind": "commanddeclaration"}, {"full_name": "LazyList.interleave", "code": "def interleave {\u03b1} : LazyList \u03b1 \u2192 LazyList \u03b1 \u2192 LazyList \u03b1\n  | LazyList.nil, xs => xs\n  | a@(LazyList.cons _ _), LazyList.nil => a\n  | LazyList.cons x xs, LazyList.cons y ys =>\n    LazyList.cons x (LazyList.cons y (interleave xs.get ys.get))", "start": [108, 1], "end": [113, 65], "kind": "commanddeclaration"}, {"full_name": "LazyList.interleaveAll", "code": "def interleaveAll {\u03b1} : List (LazyList \u03b1) \u2192 LazyList \u03b1\n  | [] => LazyList.nil\n  | x :: xs => interleave x (interleaveAll xs)", "start": [116, 1], "end": [121, 47], "kind": "commanddeclaration"}, {"full_name": "LazyList.bind", "code": "protected def bind {\u03b1 \u03b2} : LazyList \u03b1 \u2192 (\u03b1 \u2192 LazyList \u03b2) \u2192 LazyList \u03b2\n  | LazyList.nil, _ => LazyList.nil\n  | LazyList.cons x xs, f => (f x).append (xs.get.bind f)", "start": [124, 1], "end": [127, 58], "kind": "commanddeclaration"}, {"full_name": "LazyList.reverse", "code": "def reverse {\u03b1} (xs : LazyList \u03b1) : LazyList \u03b1 :=\n  ofList xs.toList.reverse", "start": [130, 1], "end": [135, 27], "kind": "commanddeclaration"}, {"full_name": "LazyList.append_nil", "code": "theorem append_nil {\u03b1} (xs : LazyList \u03b1) : xs.append (Thunk.pure LazyList.nil) = xs", "start": [143, 1], "end": [147, 18], "kind": "commanddeclaration"}, {"full_name": "LazyList.append_assoc", "code": "theorem append_assoc {\u03b1} (xs ys zs : LazyList \u03b1) :\n    (xs.append ys).append zs = xs.append (ys.append zs)", "start": [150, 1], "end": [155, 18], "kind": "commanddeclaration"}, {"full_name": "LazyList.append_bind", "code": "theorem append_bind {\u03b1 \u03b2} (xs : LazyList \u03b1) (ys : Thunk (LazyList \u03b1)) (f : \u03b1 \u2192 LazyList \u03b2) :\n    (xs.append ys).bind f = (xs.bind f).append (ys.get.bind f)", "start": [159, 1], "end": [167, 28], "kind": "commanddeclaration"}, {"full_name": "LazyList.mfirst", "code": "def mfirst {m} [Alternative m] {\u03b1 \u03b2} (f : \u03b1 \u2192 m \u03b2) : LazyList \u03b1 \u2192 m \u03b2\n  | nil => failure\n  | cons x xs => f x <|> xs.get.mfirst f", "start": [196, 1], "end": [200, 41], "kind": "commanddeclaration"}, {"full_name": "LazyList.Mem", "code": "protected def Mem {\u03b1} (x : \u03b1) : LazyList \u03b1 \u2192 Prop\n  | nil => False\n  | cons y ys => x = y \u2228 ys.get.Mem x", "start": [203, 1], "end": [206, 38], "kind": "commanddeclaration"}, {"full_name": "LazyList.Mem.decidable", "code": "instance Mem.decidable {\u03b1} [DecidableEq \u03b1] (x : \u03b1) : \u2200 xs : LazyList \u03b1, Decidable (x \u2208 xs)\n  | LazyList.nil => by\n    apply Decidable.isFalse\n    simp [Membership.mem, LazyList.Mem]\n  | LazyList.cons y ys =>\n    if h : x = y then by\n      apply Decidable.isTrue\n      simp only [Membership.mem, LazyList.Mem]\n      exact Or.inl h\n    else by\n      have := Mem.decidable x ys.get\n      have : (x \u2208 ys.get) \u2194 (x \u2208 cons y ys) := by simp [(\u00b7 \u2208 \u00b7), LazyList.Mem, h]\n      exact decidable_of_decidable_of_iff this", "start": [212, 1], "end": [224, 47], "kind": "commanddeclaration"}, {"full_name": "LazyList.mem_nil", "code": "@[simp]\ntheorem mem_nil {\u03b1} (x : \u03b1) : x \u2208 @LazyList.nil \u03b1 \u2194 False", "start": [227, 1], "end": [229, 10], "kind": "commanddeclaration"}, {"full_name": "LazyList.mem_cons", "code": "@[simp]\ntheorem mem_cons {\u03b1} (x y : \u03b1) (ys : Thunk (LazyList \u03b1)) :\n    x \u2208 @LazyList.cons \u03b1 y ys \u2194 x = y \u2228 x \u2208 ys.get", "start": [232, 1], "end": [235, 38], "kind": "commanddeclaration"}, {"full_name": "LazyList.forall_mem_cons", "code": "theorem forall_mem_cons {\u03b1} {p : \u03b1 \u2192 Prop} {a : \u03b1} {l : Thunk (LazyList \u03b1)} :\n    (\u2200 x \u2208 @LazyList.cons _ a l, p x) \u2194 p a \u2227 \u2200 x \u2208 l.get, p x", "start": [238, 1], "end": [240, 74], "kind": "commanddeclaration"}, {"full_name": "LazyList.pmap", "code": "@[simp]\ndef pmap {\u03b1 \u03b2} {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) : \u2200 l : LazyList \u03b1, (\u2200 a \u2208 l, p a) \u2192 LazyList \u03b2\n  | LazyList.nil, _ => LazyList.nil\n  | LazyList.cons x xs, H =>\n    LazyList.cons (f x (forall_mem_cons.1 H).1) (xs.get.pmap f (forall_mem_cons.1 H).2)", "start": [246, 1], "end": [254, 88], "kind": "commanddeclaration"}, {"full_name": "LazyList.attach", "code": "def attach {\u03b1} (l : LazyList \u03b1) : LazyList { x // x \u2208 l } :=\n  pmap Subtype.mk l fun _ \u21a6 id", "start": [257, 1], "end": [260, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/QPF/Multivariate/Constructions/Sigma.lean", "imports": ["Mathlib/Data/PFunctor/Multivariate/Basic.lean", "Mathlib/Data/QPF/Multivariate/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvQPF.Sigma", "code": "def Sigma (v : TypeVec.{u} n) : Type u :=\n  \u03a3 \u03b1 : A, F \u03b1 v", "start": [26, 1], "end": [29, 17], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Pi", "code": "def Pi (v : TypeVec.{u} n) : Type u :=\n  \u2200 \u03b1 : A, F \u03b1 v", "start": [32, 1], "end": [35, 17], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Sigma.inhabited", "code": "instance Sigma.inhabited {\u03b1} [Inhabited A] [Inhabited (F default \u03b1)] : Inhabited (Sigma F \u03b1) :=\n  \u27e8\u27e8default, default\u27e9\u27e9", "start": [38, 1], "end": [39, 23], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Pi.inhabited", "code": "instance Pi.inhabited {\u03b1} [\u2200 a, Inhabited (F a \u03b1)] : Inhabited (Pi F \u03b1) :=\n  \u27e8fun _a => default\u27e9", "start": [42, 1], "end": [43, 22], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Sigma.P", "code": "protected def P : MvPFunctor n :=\n  \u27e8\u03a3 a, (P (F a)).A, fun x => (P (F x.1)).B x.2\u27e9", "start": [54, 1], "end": [56, 49], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Sigma.abs", "code": "protected def abs \u2983\u03b1\u2984 : Sigma.P F \u03b1 \u2192 Sigma F \u03b1\n  | \u27e8a, f\u27e9 => \u27e8a.1, MvQPF.abs \u27e8a.2, f\u27e9\u27e9", "start": [60, 1], "end": [62, 40], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Sigma.repr", "code": "protected def repr \u2983\u03b1\u2984 : Sigma F \u03b1 \u2192 Sigma.P F \u03b1\n  | \u27e8a, f\u27e9 =>\n    let x := MvQPF.repr f\n    \u27e8\u27e8a, x.1\u27e9, x.2\u27e9", "start": [65, 1], "end": [69, 20], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Pi.P", "code": "protected def P : MvPFunctor n :=\n  \u27e8\u2200 a, (P (F a)).A, fun x i => \u03a3 a, (P (F a)).B (x a) i\u27e9", "start": [88, 1], "end": [90, 58], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Pi.abs", "code": "protected def abs \u2983\u03b1\u2984 : Pi.P F \u03b1 \u2192 Pi F \u03b1\n  | \u27e8a, f\u27e9 => fun x => MvQPF.abs \u27e8a x, fun i y => f i \u27e8_, y\u27e9\u27e9", "start": [94, 1], "end": [96, 62], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Pi.repr", "code": "protected def repr \u2983\u03b1\u2984 : Pi F \u03b1 \u2192 Pi.P F \u03b1\n  | f => \u27e8fun a => (MvQPF.repr (f a)).1, fun _i a => (MvQPF.repr (f _)).2 _ a.2\u27e9", "start": [99, 1], "end": [101, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/InnerProductSpace/ProdL2.lean", "imports": ["Mathlib/Analysis/InnerProductSpace/Projection.lean", "Mathlib/Analysis/NormedSpace/ProdLp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WithLp.instProdInnerProductSpace", "code": "noncomputable instance instProdInnerProductSpace :\n    InnerProductSpace \ud835\udd5c (WithLp 2 (E \u00d7 F)) where\n  inner x y := inner x.fst y.fst + inner x.snd y.snd\n  norm_sq_eq_inner x := by\n    simp [prod_norm_sq_eq_of_L2, \u2190 norm_sq_eq_inner]\n  conj_symm x y := by\n    simp\n  add_left x y z := by\n    simp only [add_fst, add_snd, inner_add_left]\n    ring\n  smul_left x y r := by\n    simp only [smul_fst, inner_smul_left, smul_snd]\n    ring", "start": [26, 1], "end": [38, 9], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_inner_apply", "code": "@[simp]\ntheorem prod_inner_apply (x y : WithLp 2 (E \u00d7 F)) :\n    inner (\ud835\udd5c := \ud835\udd5c) x y = inner x.fst y.fst + inner x.snd y.snd", "start": [42, 1], "end": [44, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Additive/Behrend.lean", "imports": ["Mathlib/Combinatorics/Pigeonhole.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Complex/ExponentialBounds.lean", "Mathlib/Combinatorics/Additive/SalemSpencer.lean", "Mathlib/Analysis/InnerProductSpace/PiL2.lean"], "premises": [{"full_name": "Behrend.box", "code": "def box (n d : \u2115) : Finset (Fin n \u2192 \u2115) :=\n  Fintype.piFinset fun _ => range d", "start": [69, 1], "end": [71, 36], "kind": "commanddeclaration"}, {"full_name": "Behrend.mem_box", "code": "theorem mem_box : x \u2208 box n d \u2194 \u2200 i, x i < d", "start": [74, 1], "end": [74, 100], "kind": "commanddeclaration"}, {"full_name": "Behrend.card_box", "code": "@[simp]\ntheorem card_box : (box n d).card = d ^ n", "start": [77, 1], "end": [78, 59], "kind": "commanddeclaration"}, {"full_name": "Behrend.box_zero", "code": "@[simp]\ntheorem box_zero : box (n + 1) 0 = \u2205", "start": [81, 1], "end": [82, 54], "kind": "commanddeclaration"}, {"full_name": "Behrend.sphere", "code": "def sphere (n d k : \u2115) : Finset (Fin n \u2192 \u2115) :=\n  (box n d).filter fun x => \u2211 i, x i ^ 2 = k", "start": [85, 1], "end": [88, 45], "kind": "commanddeclaration"}, {"full_name": "Behrend.sphere_zero_subset", "code": "theorem sphere_zero_subset : sphere n d 0 \u2286 0", "start": [91, 1], "end": [91, 96], "kind": "commanddeclaration"}, {"full_name": "Behrend.sphere_zero_right", "code": "@[simp]\ntheorem sphere_zero_right (n k : \u2115) : sphere (n + 1) 0 k = \u2205", "start": [94, 1], "end": [95, 81], "kind": "commanddeclaration"}, {"full_name": "Behrend.sphere_subset_box", "code": "theorem sphere_subset_box : sphere n d k \u2286 box n d", "start": [98, 1], "end": [99, 20], "kind": "commanddeclaration"}, {"full_name": "Behrend.norm_of_mem_sphere", "code": "theorem norm_of_mem_sphere {x : Fin n \u2192 \u2115} (hx : x \u2208 sphere n d k) :\n    \u2016(WithLp.equiv 2 _).symm ((\u2191) \u2218 x : Fin n \u2192 \u211d)\u2016 = Real.sqrt k", "start": [102, 1], "end": [106, 66], "kind": "commanddeclaration"}, {"full_name": "Behrend.sphere_subset_preimage_metric_sphere", "code": "theorem sphere_subset_preimage_metric_sphere : (sphere n d k : Set (Fin n \u2192 \u2115)) \u2286\n    (fun x : Fin n \u2192 \u2115 => (WithLp.equiv 2 _).symm ((\u2191) \u2218 x : Fin n \u2192 \u211d)) \u207b\u00b9'\n      Metric.sphere (0 : PiLp 2 fun _ : Fin n => \u211d) (Real.sqrt k)", "start": [109, 1], "end": [112, 88], "kind": "commanddeclaration"}, {"full_name": "Behrend.map", "code": "@[simps]\ndef map (d : \u2115) : (Fin n \u2192 \u2115) \u2192+ \u2115 where\n  toFun a := \u2211 i, a i * d ^ (i : \u2115)\n  map_zero' := by simp_rw [Pi.zero_apply, zero_mul, sum_const_zero]\n  map_add' a b := by simp_rw [Pi.add_apply, add_mul, sum_add_distrib]", "start": [115, 1], "end": [120, 70], "kind": "commanddeclaration"}, {"full_name": "Behrend.map_zero", "code": "theorem map_zero (d : \u2115) (a : Fin 0 \u2192 \u2115) : map d a = 0", "start": [124, 1], "end": [124, 72], "kind": "commanddeclaration"}, {"full_name": "Behrend.map_succ", "code": "theorem map_succ (a : Fin (n + 1) \u2192 \u2115) :\n    map d a = a 0 + (\u2211 x : Fin n, a x.succ * d ^ (x : \u2115)) * d", "start": [127, 1], "end": [129, 74], "kind": "commanddeclaration"}, {"full_name": "Behrend.map_succ'", "code": "theorem map_succ' (a : Fin (n + 1) \u2192 \u2115) : map d a = a 0 + map d (a \u2218 Fin.succ) * d", "start": [132, 1], "end": [133, 13], "kind": "commanddeclaration"}, {"full_name": "Behrend.map_monotone", "code": "theorem map_monotone (d : \u2115) : Monotone (map d : (Fin n \u2192 \u2115) \u2192 \u2115)", "start": [136, 1], "end": [137, 67], "kind": "commanddeclaration"}, {"full_name": "Behrend.map_mod", "code": "theorem map_mod (a : Fin n.succ \u2192 \u2115) : map d a % d = a 0 % d", "start": [140, 1], "end": [141, 44], "kind": "commanddeclaration"}, {"full_name": "Behrend.map_eq_iff", "code": "theorem map_eq_iff {x\u2081 x\u2082 : Fin n.succ \u2192 \u2115} (hx\u2081 : \u2200 i, x\u2081 i < d) (hx\u2082 : \u2200 i, x\u2082 i < d) :\n    map d x\u2081 = map d x\u2082 \u2194 x\u2081 0 = x\u2082 0 \u2227 map d (x\u2081 \u2218 Fin.succ) = map d (x\u2082 \u2218 Fin.succ)", "start": [144, 1], "end": [150, 56], "kind": "commanddeclaration"}, {"full_name": "Behrend.map_injOn", "code": "theorem map_injOn : {x : Fin n \u2192 \u2115 | \u2200 i, x i < d}.InjOn (map d)", "start": [153, 1], "end": [162, 16], "kind": "commanddeclaration"}, {"full_name": "Behrend.map_le_of_mem_box", "code": "theorem map_le_of_mem_box (hx : x \u2208 box n d) :\n    map (2 * d - 1) x \u2264 \u2211 i : Fin n, (d - 1) * (2 * d - 1) ^ (i : \u2115)", "start": [165, 1], "end": [167, 72], "kind": "commanddeclaration"}, {"full_name": "Behrend.addSalemSpencer_sphere", "code": "nonrec theorem addSalemSpencer_sphere : AddSalemSpencer (sphere n d k : Set (Fin n \u2192 \u2115))", "start": [170, 1], "end": [179, 27], "kind": "commanddeclaration"}, {"full_name": "Behrend.addSalemSpencer_image_sphere", "code": "theorem addSalemSpencer_image_sphere :\n    AddSalemSpencer ((sphere n d k).image (map (2 * d - 1)) : Set \u2115)", "start": [182, 1], "end": [193, 72], "kind": "commanddeclaration"}, {"full_name": "Behrend.sum_sq_le_of_mem_box", "code": "theorem sum_sq_le_of_mem_box (hx : x \u2208 box n d) : \u2211 i : Fin n, x i ^ 2 \u2264 n * (d - 1) ^ 2", "start": [196, 1], "end": [200, 93], "kind": "commanddeclaration"}, {"full_name": "Behrend.sum_eq", "code": "theorem sum_eq : (\u2211 i : Fin n, d * (2 * d + 1) ^ (i : \u2115)) = ((2 * d + 1) ^ n - 1) / 2", "start": [203, 1], "end": [206, 55], "kind": "commanddeclaration"}, {"full_name": "Behrend.sum_lt", "code": "theorem sum_lt : (\u2211 i : Fin n, d * (2 * d + 1) ^ (i : \u2115)) < (2 * d + 1) ^ n", "start": [209, 1], "end": [210, 92], "kind": "commanddeclaration"}, {"full_name": "Behrend.card_sphere_le_rothNumberNat", "code": "theorem card_sphere_le_rothNumberNat (n d k : \u2115) :\n    (sphere n d k).card \u2264 rothNumberNat ((2 * d - 1) ^ n)", "start": [213, 1], "end": [228, 48], "kind": "commanddeclaration"}, {"full_name": "Behrend.exists_large_sphere_aux", "code": "theorem exists_large_sphere_aux (n d : \u2115) : \u2203 k \u2208 range (n * (d - 1) ^ 2 + 1),\n    (\u2191(d ^ n) / (\u2191(n * (d - 1) ^ 2) + 1) : \u211d) \u2264 (sphere n d k).card", "start": [241, 1], "end": [248, 35], "kind": "commanddeclaration"}, {"full_name": "Behrend.exists_large_sphere", "code": "theorem exists_large_sphere (n d : \u2115) : \u2203 k, (d ^ n / \u2191(n * d ^ 2) : \u211d) \u2264 (sphere n d k).card", "start": [251, 1], "end": [268, 25], "kind": "commanddeclaration"}, {"full_name": "Behrend.bound_aux'", "code": "theorem bound_aux' (n d : \u2115) : (d ^ n / \u2191(n * d ^ 2) : \u211d) \u2264 rothNumberNat ((2 * d - 1) ^ n)", "start": [271, 1], "end": [273, 61], "kind": "commanddeclaration"}, {"full_name": "Behrend.bound_aux", "code": "theorem bound_aux (hd : d \u2260 0) (hn : 2 \u2264 n) :\n    (d ^ (n - 2) / n : \u211d) \u2264 rothNumberNat ((2 * d - 1) ^ n)", "start": [276, 1], "end": [280, 72], "kind": "commanddeclaration"}, {"full_name": "Behrend.log_two_mul_two_le_sqrt_log_eight", "code": "theorem log_two_mul_two_le_sqrt_log_eight : log 2 * 2 \u2264 sqrt (log 8)", "start": [289, 1], "end": [297, 22], "kind": "commanddeclaration"}, {"full_name": "Behrend.two_div_one_sub_two_div_e_le_eight", "code": "theorem two_div_one_sub_two_div_e_le_eight : 2 / (1 - 2 / exp 1) \u2264 8", "start": [300, 1], "end": [304, 72], "kind": "commanddeclaration"}, {"full_name": "Behrend.le_sqrt_log", "code": "theorem le_sqrt_log (hN : 4096 \u2264 N) : log (2 / (1 - 2 / exp 1)) * (69 / 50) \u2264 sqrt (log \u2191N)", "start": [307, 1], "end": [329, 43], "kind": "commanddeclaration"}, {"full_name": "Behrend.exp_neg_two_mul_le", "code": "theorem exp_neg_two_mul_le {x : \u211d} (hx : 0 < x) : exp (-2 * x) < exp (2 - \u2308x\u2309\u208a) / \u2308x\u2309\u208a", "start": [332, 1], "end": [344, 43], "kind": "commanddeclaration"}, {"full_name": "Behrend.div_lt_floor", "code": "theorem div_lt_floor {x : \u211d} (hx : 2 / (1 - 2 / exp 1) \u2264 x) : x / exp 1 < (\u230ax / 2\u230b\u208a : \u211d)", "start": [347, 1], "end": [355, 22], "kind": "commanddeclaration"}, {"full_name": "Behrend.ceil_lt_mul", "code": "theorem ceil_lt_mul {x : \u211d} (hx : 50 / 19 \u2264 x) : (\u2308x\u2309\u208a : \u211d) < 1.38 * x", "start": [358, 1], "end": [364, 12], "kind": "commanddeclaration"}, {"full_name": "Behrend.nValue", "code": "noncomputable def nValue (N : \u2115) : \u2115 :=\n  \u2308sqrt (log N)\u2309\u208a", "start": [369, 1], "end": [371, 18], "kind": "commanddeclaration"}, {"full_name": "Behrend.dValue", "code": "noncomputable def dValue (N : \u2115) : \u2115 :=\n  \u230a(N : \u211d) ^ (1 / nValue N : \u211d) / 2\u230b\u208a", "start": [374, 1], "end": [376, 38], "kind": "commanddeclaration"}, {"full_name": "Behrend.nValue_pos", "code": "theorem nValue_pos (hN : 2 \u2264 N) : 0 < nValue N", "start": [379, 1], "end": [380, 66], "kind": "commanddeclaration"}, {"full_name": "Behrend.two_le_nValue", "code": "theorem two_le_nValue (hN : 3 \u2264 N) : 2 \u2264 nValue N", "start": [383, 1], "end": [389, 37], "kind": "commanddeclaration"}, {"full_name": "Behrend.three_le_nValue", "code": "theorem three_le_nValue (hN : 64 \u2264 N) : 3 \u2264 nValue N", "start": [392, 1], "end": [403, 36], "kind": "commanddeclaration"}, {"full_name": "Behrend.dValue_pos", "code": "theorem dValue_pos (hN\u2083 : 8 \u2264 N) : 0 < dValue N", "start": [406, 1], "end": [426, 54], "kind": "commanddeclaration"}, {"full_name": "Behrend.le_N", "code": "theorem le_N (hN : 2 \u2264 N) : (2 * dValue N - 1) ^ nValue N \u2264 N", "start": [429, 1], "end": [441, 20], "kind": "commanddeclaration"}, {"full_name": "Behrend.bound", "code": "theorem bound (hN : 4096 \u2264 N) : (N : \u211d) ^ (1 / nValue N : \u211d) / exp 1 < dValue N", "start": [445, 1], "end": [478, 36], "kind": "commanddeclaration"}, {"full_name": "Behrend.roth_lower_bound_explicit", "code": "theorem roth_lower_bound_explicit (hN : 4096 \u2264 N) :\n    (N : \u211d) * exp (-4 * sqrt (log N)) < rothNumberNat N", "start": [481, 1], "end": [512, 38], "kind": "commanddeclaration"}, {"full_name": "Behrend.exp_four_lt", "code": "theorem exp_four_lt : exp 4 < 64", "start": [515, 1], "end": [519, 11], "kind": "commanddeclaration"}, {"full_name": "Behrend.four_zero_nine_six_lt_exp_sixteen", "code": "theorem four_zero_nine_six_lt_exp_sixteen : 4096 < exp 16", "start": [522, 1], "end": [526, 27], "kind": "commanddeclaration"}, {"full_name": "Behrend.lower_bound_le_one'", "code": "theorem lower_bound_le_one' (hN : 2 \u2264 N) (hN' : N \u2264 4096) :\n    (N : \u211d) * exp (-4 * sqrt (log N)) \u2264 1", "start": [529, 1], "end": [538, 21], "kind": "commanddeclaration"}, {"full_name": "Behrend.lower_bound_le_one", "code": "theorem lower_bound_le_one (hN : 1 \u2264 N) (hN' : N \u2264 4096) :\n    (N : \u211d) * exp (-4 * sqrt (log N)) \u2264 1", "start": [541, 1], "end": [545, 37], "kind": "commanddeclaration"}, {"full_name": "Behrend.roth_lower_bound", "code": "theorem roth_lower_bound : (N : \u211d) * exp (-4 * sqrt (log N)) \u2264 rothNumberNat N", "start": [548, 1], "end": [554, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Constructions/Filtered.lean", "imports": ["Mathlib/CategoryTheory/Limits/Constructions/LimitsOfProductsAndEqualizers.lean", "Mathlib/CategoryTheory/Limits/Opposites.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinset", "code": "@[simps!]\ndef liftToFinset [HasFiniteCoproducts C] (F : Discrete \u03b1 \u2964 C) : Finset (Discrete \u03b1) \u2964 C where\n  obj s := \u2210 fun x : s => F.obj x\n  map {_ Y} h := Sigma.desc fun y =>\n    Sigma.\u03b9 (fun (x : { x // x \u2208 Y }) => F.obj x) \u27e8y, h.down.down y.2\u27e9", "start": [37, 1], "end": [43, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinsetColimitCocone", "code": "@[simps!]\ndef liftToFinsetColimitCocone [HasFiniteCoproducts C] [HasFilteredColimitsOfSize.{w, w} C]\n    (F : Discrete \u03b1 \u2964 C) : ColimitCocone F where\n  cocone :=\n    { pt := colimit (liftToFinset F)\n      \u03b9 :=\n        Discrete.natTrans fun j =>\n          @Sigma.\u03b9 _ _ _ (fun x : ({j} : Finset (Discrete \u03b1)) => F.obj x) _ \u27e8j, by simp\u27e9 \u226b\n            colimit.\u03b9 (liftToFinset F) {j} }\n  isColimit :=\n    { desc := fun s =>\n        colimit.desc (liftToFinset F)\n          { pt := s.pt\n            \u03b9 := { app := fun t => Sigma.desc fun x => s.\u03b9.app x } }\n      uniq := fun s m h => by\n        apply colimit.hom_ext\n        rintro t\n        dsimp [liftToFinset]\n        apply colimit.hom_ext\n        rintro \u27e8\u27e8j, hj\u27e9\u27e9\n        convert h j using 1\n        \u00b7 simp [\u2190 colimit.w (liftToFinset F) \u27e8\u27e8Finset.singleton_subset_iff.2 hj\u27e9\u27e9]\n          rfl\n        \u00b7 aesop_cat }", "start": [46, 1], "end": [72, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoproducts_of_finite_and_filtered", "code": "theorem hasCoproducts_of_finite_and_filtered [HasFiniteCoproducts C]\n    [HasFilteredColimitsOfSize.{w, w} C] : HasCoproducts.{w} C", "start": [79, 1], "end": [81, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.has_colimits_of_finite_and_filtered", "code": "theorem has_colimits_of_finite_and_filtered [HasFiniteColimits C]\n    [HasFilteredColimitsOfSize.{w, w} C] : HasColimitsOfSize.{w, w} C", "start": [84, 1], "end": [87, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasProducts_of_finite_and_cofiltered", "code": "theorem hasProducts_of_finite_and_cofiltered [HasFiniteProducts C]\n    [HasCofilteredLimitsOfSize.{w, w} C] : HasProducts.{w} C", "start": [90, 1], "end": [93, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.has_limits_of_finite_and_cofiltered", "code": "theorem has_limits_of_finite_and_cofiltered [HasFiniteLimits C]\n    [HasCofilteredLimitsOfSize.{w, w} C] : HasLimitsOfSize.{w, w} C", "start": [96, 1], "end": [99, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/Types.lean", "imports": ["Mathlib/ModelTheory/Satisfiability.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FirstOrder.Language.Theory.CompleteType", "code": "structure CompleteType where\n  toTheory : L[[\u03b1]].Theory\n  subset' : (L.lhomWithConstants \u03b1).onTheory T \u2286 toTheory\n  isMaximal' : toTheory.IsMaximal", "start": [54, 1], "end": [59, 34], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.Sentence.instSetLike", "code": "instance Sentence.instSetLike : SetLike (T.CompleteType \u03b1) (L[[\u03b1]].Sentence) :=\n  \u27e8fun p => p.toTheory, fun p q h => by\n    cases p\n    cases q\n    congr \u27e9", "start": [71, 1], "end": [75, 12], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.isMaximal", "code": "theorem isMaximal (p : T.CompleteType \u03b1) : IsMaximal (p : L[[\u03b1]].Theory)", "start": [78, 1], "end": [79, 15], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.subset", "code": "theorem subset (p : T.CompleteType \u03b1) : (L.lhomWithConstants \u03b1).onTheory T \u2286 (p : L[[\u03b1]].Theory)", "start": [82, 1], "end": [83, 12], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.mem_or_not_mem", "code": "theorem mem_or_not_mem (p : T.CompleteType \u03b1) (\u03c6 : L[[\u03b1]].Sentence) : \u03c6 \u2208 p \u2228 \u03c6.not \u2208 p", "start": [86, 1], "end": [87, 31], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.mem_of_models", "code": "theorem mem_of_models (p : T.CompleteType \u03b1) {\u03c6 : L[[\u03b1]].Sentence}\n    (h : (L.lhomWithConstants \u03b1).onTheory T \u22a8\u1d47 \u03c6) : \u03c6 \u2208 p", "start": [90, 1], "end": [94, 80], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.not_mem_iff", "code": "theorem not_mem_iff (p : T.CompleteType \u03b1) (\u03c6 : L[[\u03b1]].Sentence) : \u03c6.not \u2208 p \u2194 \u00ac\u03c6 \u2208 p", "start": [97, 1], "end": [105, 55], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.compl_setOf_mem", "code": "@[simp]\ntheorem compl_setOf_mem {\u03c6 : L[[\u03b1]].Sentence} :\n    { p : T.CompleteType \u03b1 | \u03c6 \u2208 p }\u1d9c = { p : T.CompleteType \u03b1 | \u03c6.not \u2208 p }", "start": [108, 1], "end": [111, 38], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.setOf_subset_eq_empty_iff", "code": "theorem setOf_subset_eq_empty_iff (S : L[[\u03b1]].Theory) :\n    { p : T.CompleteType \u03b1 | S \u2286 \u2191p } = \u2205 \u2194\n      \u00ac((L.lhomWithConstants \u03b1).onTheory T \u222a S).IsSatisfiable", "start": [114, 1], "end": [125, 54], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.setOf_mem_eq_univ_iff", "code": "theorem setOf_mem_eq_univ_iff (\u03c6 : L[[\u03b1]].Sentence) :\n    { p : T.CompleteType \u03b1 | \u03c6 \u2208 p } = Set.univ \u2194 (L.lhomWithConstants \u03b1).onTheory T \u22a8\u1d47 \u03c6", "start": [128, 1], "end": [131, 7], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.setOf_subset_eq_univ_iff", "code": "theorem setOf_subset_eq_univ_iff (S : L[[\u03b1]].Theory) :\n    { p : T.CompleteType \u03b1 | S \u2286 \u2191p } = Set.univ \u2194\n      \u2200 \u03c6, \u03c6 \u2208 S \u2192 (L.lhomWithConstants \u03b1).onTheory T \u22a8\u1d47 \u03c6", "start": [134, 1], "end": [143, 15], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.nonempty_iff", "code": "theorem nonempty_iff : Nonempty (T.CompleteType \u03b1) \u2194 T.IsSatisfiable", "start": [146, 1], "end": [150, 7], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.instNonempty", "code": "instance instNonempty : Nonempty (CompleteType (\u2205 : L.Theory) \u03b1) :=\n  nonempty_iff.2 (isSatisfiable_empty L)", "start": [153, 1], "end": [154, 41], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.iInter_setOf_subset", "code": "theorem iInter_setOf_subset {\u03b9 : Type*} (S : \u03b9 \u2192 L[[\u03b1]].Theory) :\n    \u22c2 i : \u03b9, { p : T.CompleteType \u03b1 | S i \u2286 p } =\n      { p : T.CompleteType \u03b1 | \u22c3 i : \u03b9, S i \u2286 p }", "start": [157, 1], "end": [161, 58], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.toList_foldr_inf_mem", "code": "theorem toList_foldr_inf_mem {p : T.CompleteType \u03b1} {t : Finset (L[[\u03b1]]).Sentence} :\n    t.toList.foldr (\u00b7 \u2293 \u00b7) \u22a4 \u2208 p \u2194 (t : L[[\u03b1]].Theory) \u2286 \u2191p", "start": [164, 1], "end": [168, 61], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.typeOf", "code": "def typeOf (v : \u03b1 \u2192 M) : T.CompleteType \u03b1 :=\n  haveI : (constantsOn \u03b1).Structure M := constantsOn.structure v\n  { toTheory := L[[\u03b1]].completeTheory M\n    subset' := model_iff_subset_completeTheory.1 ((LHom.onTheory_model _ T).2 inferInstance)\n    isMaximal' := completeTheory.isMaximal _ _ }", "start": [175, 1], "end": [180, 49], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.mem_typeOf", "code": "@[simp]\ntheorem mem_typeOf {\u03c6 : L[[\u03b1]].Sentence} :\n    \u03c6 \u2208 T.typeOf v \u2194 (Formula.equivSentence.symm \u03c6).Realize v", "start": [187, 1], "end": [191, 75], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.CompleteType.formula_mem_typeOf", "code": "theorem formula_mem_typeOf {\u03c6 : L.Formula \u03b1} : Formula.equivSentence \u03c6 \u2208 T.typeOf v \u2194 \u03c6.Realize v", "start": [194, 1], "end": [195, 10], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.realizedTypes", "code": "@[simp]\ndef realizedTypes (\u03b1 : Type w) : Set (T.CompleteType \u03b1) :=\n  Set.range (T.typeOf : (\u03b1 \u2192 M) \u2192 T.CompleteType \u03b1)", "start": [202, 1], "end": [206, 52], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.exists_modelType_is_realized_in", "code": "theorem exists_modelType_is_realized_in (p : T.CompleteType \u03b1) :\n    \u2203 M : Theory.ModelType.{u, v, max u v w} T, p \u2208 T.realizedTypes M \u03b1", "start": [213, 1], "end": [224, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/Laurent.lean", "imports": ["Mathlib/Data/Polynomial/Taylor.lean", "Mathlib/FieldTheory/RatFunc.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RatFunc.taylor_mem_nonZeroDivisors", "code": "theorem taylor_mem_nonZeroDivisors (hp : p \u2208 R[X]\u2070) : taylor r p \u2208 R[X]\u2070", "start": [39, 1], "end": [45, 60], "kind": "commanddeclaration"}, {"full_name": "RatFunc.laurentAux", "code": "def laurentAux : RatFunc R \u2192+* RatFunc R :=\n  RatFunc.mapRingHom\n    ( { toFun := taylor r\n        map_add' := map_add (taylor r)\n        map_mul' := taylor_mul _\n        map_zero' := map_zero (taylor r)\n        map_one' := taylor_one r } : R[X] \u2192+* R[X])\n    (taylor_mem_nonZeroDivisors _)", "start": [48, 1], "end": [57, 35], "kind": "commanddeclaration"}, {"full_name": "RatFunc.laurentAux_ofFractionRing_mk", "code": "theorem laurentAux_ofFractionRing_mk (q : R[X]\u2070) :\n    laurentAux r (ofFractionRing (Localization.mk p q)) =\n      ofFractionRing (.mk (taylor r p) \u27e8taylor r q, taylor_mem_nonZeroDivisors r q q.prop\u27e9)", "start": [60, 1], "end": [63, 38], "kind": "commanddeclaration"}, {"full_name": "RatFunc.laurentAux_div", "code": "theorem laurentAux_div :\n    laurentAux r (algebraMap _ _ p / algebraMap _ _ q) =\n      algebraMap _ _ (taylor r p) / algebraMap _ _ (taylor r q)", "start": [66, 1], "end": [70, 62], "kind": "commanddeclaration"}, {"full_name": "RatFunc.laurentAux_algebraMap", "code": "@[simp]\ntheorem laurentAux_algebraMap : laurentAux r (algebraMap _ _ p) = algebraMap _ _ (taylor r p)", "start": [73, 1], "end": [76, 13], "kind": "commanddeclaration"}, {"full_name": "RatFunc.laurent", "code": "def laurent : RatFunc R \u2192\u2090[R] RatFunc R :=\n  RatFunc.mapAlgHom (.ofLinearMap (taylor r) (taylor_one _) (taylor_mul _))\n    (taylor_mem_nonZeroDivisors _)", "start": [79, 1], "end": [82, 35], "kind": "commanddeclaration"}, {"full_name": "RatFunc.laurent_div", "code": "theorem laurent_div :\n    laurent r (algebraMap _ _ p / algebraMap _ _ q) =\n      algebraMap _ _ (taylor r p) / algebraMap _ _ (taylor r q)", "start": [85, 1], "end": [88, 23], "kind": "commanddeclaration"}, {"full_name": "RatFunc.laurent_algebraMap", "code": "@[simp]\ntheorem laurent_algebraMap : laurent r (algebraMap _ _ p) = algebraMap _ _ (taylor r p)", "start": [91, 1], "end": [93, 28], "kind": "commanddeclaration"}, {"full_name": "RatFunc.laurent_X", "code": "@[simp]\ntheorem laurent_X : laurent r X = X + C r", "start": [96, 1], "end": [98, 82], "kind": "commanddeclaration"}, {"full_name": "RatFunc.laurent_C", "code": "@[simp]\ntheorem laurent_C (x : R) : laurent r (C x) = C x", "start": [102, 1], "end": [104, 52], "kind": "commanddeclaration"}, {"full_name": "RatFunc.laurent_at_zero", "code": "@[simp]\ntheorem laurent_at_zero : laurent 0 f = f", "start": [108, 1], "end": [109, 93], "kind": "commanddeclaration"}, {"full_name": "RatFunc.laurent_laurent", "code": "theorem laurent_laurent : laurent r (laurent s f) = laurent (r + s) f", "start": [112, 1], "end": [114, 39], "kind": "commanddeclaration"}, {"full_name": "RatFunc.laurent_injective", "code": "theorem laurent_injective : Function.Injective (laurent r)", "start": [117, 1], "end": [118, 59], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/LLVMBindings.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LLVM.CodegenFileType", "code": "structure CodegenFileType where\n  private mk :: val : UInt64", "start": [18, 1], "end": [19, 29], "kind": "commanddeclaration"}, {"full_name": "LLVM.CodegenFileType.AssemblyFile", "code": "def CodegenFileType.AssemblyFile : CodegenFileType := { val := 0 }", "start": [21, 1], "end": [21, 67], "kind": "commanddeclaration"}, {"full_name": "LLVM.CodegenFileType.ObjectFile", "code": "def CodegenFileType.ObjectFile : CodegenFileType := { val := 1 }", "start": [22, 1], "end": [22, 65], "kind": "commanddeclaration"}, {"full_name": "LLVM.IntPredicate", "code": "structure IntPredicate where\n  private mk :: val : UInt64", "start": [25, 1], "end": [26, 29], "kind": "commanddeclaration"}, {"full_name": "LLVM.IntPredicate.EQ", "code": "def IntPredicate.EQ : IntPredicate := { val := 32 }", "start": [28, 1], "end": [28, 52], "kind": "commanddeclaration"}, {"full_name": "LLVM.IntPredicate.NE", "code": "def IntPredicate.NE : IntPredicate := { val := IntPredicate.EQ.val + 1 }", "start": [29, 1], "end": [29, 73], "kind": "commanddeclaration"}, {"full_name": "LLVM.IntPredicate.UGT", "code": "def IntPredicate.UGT : IntPredicate := { val := IntPredicate.NE.val + 1 }", "start": [30, 1], "end": [30, 74], "kind": "commanddeclaration"}, {"full_name": "LLVM.AttributeIndex", "code": "structure AttributeIndex where\n  private mk :: val : UInt64", "start": [33, 1], "end": [34, 29], "kind": "commanddeclaration"}, {"full_name": "LLVM.AttributeIndex.AttributeReturnIndex", "code": "def AttributeIndex.AttributeReturnIndex : AttributeIndex := { val := 0 }", "start": [36, 1], "end": [36, 73], "kind": "commanddeclaration"}, {"full_name": "LLVM.AttributeIndex.AttributeFunctionIndex", "code": "def AttributeIndex.AttributeFunctionIndex : AttributeIndex := { val := 18446744073709551615 }", "start": [38, 1], "end": [38, 94], "kind": "commanddeclaration"}, {"full_name": "LLVM.BasicBlock", "code": "structure BasicBlock (ctx : Context)  where\n  private mk :: ptr : USize", "start": [40, 1], "end": [41, 28], "kind": "commanddeclaration"}, {"full_name": "LLVM.Builder", "code": "structure Builder (ctx : Context) where\n  private mk :: ptr : USize", "start": [44, 1], "end": [45, 28], "kind": "commanddeclaration"}, {"full_name": "LLVM.Context", "code": "structure Context where\n  private mk :: ptr : USize", "start": [48, 1], "end": [49, 28], "kind": "commanddeclaration"}, {"full_name": "LLVM.LLVMType", "code": "structure LLVMType (ctx : Context) where\n  private mk :: ptr : USize", "start": [52, 1], "end": [53, 28], "kind": "commanddeclaration"}, {"full_name": "LLVM.MemoryBuffer", "code": "structure MemoryBuffer (ctx : Context) where\n  private mk :: ptr : USize", "start": [56, 1], "end": [57, 28], "kind": "commanddeclaration"}, {"full_name": "LLVM.Module", "code": "structure Module (ctx : Context) where\n  private mk :: ptr : USize", "start": [60, 1], "end": [61, 28], "kind": "commanddeclaration"}, {"full_name": "LLVM.PassManager", "code": "structure PassManager (ctx : Context) where\n  private mk :: ptr : USize", "start": [64, 1], "end": [65, 28], "kind": "commanddeclaration"}, {"full_name": "LLVM.PassManagerBuilder", "code": "structure PassManagerBuilder (ctx : Context) where\n  private mk :: ptr : USize", "start": [68, 1], "end": [69, 28], "kind": "commanddeclaration"}, {"full_name": "LLVM.Target", "code": "structure Target (ctx : Context) where\n  private mk :: ptr : USize", "start": [72, 1], "end": [73, 28], "kind": "commanddeclaration"}, {"full_name": "LLVM.TargetMachine", "code": "structure TargetMachine (ctx : Context) where\n  private mk :: ptr : USize", "start": [76, 1], "end": [77, 28], "kind": "commanddeclaration"}, {"full_name": "LLVM.Value", "code": "structure Value (ctx : Context) where\n  private mk :: ptr : USize", "start": [80, 1], "end": [81, 28], "kind": "commanddeclaration"}, {"full_name": "LLVM.Value.isNull", "code": "def Value.isNull (v : Value ctx) : Bool := v.ptr == 0", "start": [84, 1], "end": [85, 54], "kind": "commanddeclaration"}, {"full_name": "LLVM.Value.getName", "code": "@[extern \"lean_llvm_get_value_name2\"]\nopaque Value.getName {ctx : Context} (value : Value ctx) : BaseIO String", "start": [87, 1], "end": [88, 73], "kind": "commanddeclaration"}, {"full_name": "LLVM.Attribute", "code": "structure Attribute (ctx : Context) where\n  private mk :: ptr : USize", "start": [90, 1], "end": [91, 28], "kind": "commanddeclaration"}, {"full_name": "LLVM.llvmInitializeTargetInfo", "code": "@[extern \"lean_llvm_initialize_target_info\"]\nopaque llvmInitializeTargetInfo : BaseIO (Unit)", "start": [94, 1], "end": [95, 48], "kind": "commanddeclaration"}, {"full_name": "LLVM.createContext", "code": "@[extern \"lean_llvm_create_context\"]\nopaque createContext : BaseIO (Context)", "start": [97, 1], "end": [98, 40], "kind": "commanddeclaration"}, {"full_name": "LLVM.createModule", "code": "@[extern \"lean_llvm_create_module\"]\nopaque createModule (ctx : Context) (name : @&String) : BaseIO (Module ctx)", "start": [100, 1], "end": [101, 76], "kind": "commanddeclaration"}, {"full_name": "LLVM.moduleToString", "code": "@[extern \"lean_llvm_module_to_string\"]\nopaque moduleToString (m : Module ctx) : BaseIO String", "start": [103, 1], "end": [104, 55], "kind": "commanddeclaration"}, {"full_name": "LLVM.writeBitcodeToFile", "code": "@[extern \"lean_llvm_write_bitcode_to_file\"]\nopaque writeBitcodeToFile (m : Module ctx) (path : @&String) : BaseIO Unit", "start": [106, 1], "end": [107, 75], "kind": "commanddeclaration"}, {"full_name": "LLVM.addFunction", "code": "@[extern \"lean_llvm_add_function\"]\nopaque addFunction (m : Module ctx) (name : @&String) (type : LLVMType ctx) : BaseIO (Value ctx)", "start": [109, 1], "end": [110, 97], "kind": "commanddeclaration"}, {"full_name": "LLVM.getFirstFunction", "code": "@[extern \"lean_llvm_get_first_function\"]\nopaque getFirstFunction (m : Module ctx) : BaseIO (Value ctx)", "start": [112, 1], "end": [113, 62], "kind": "commanddeclaration"}, {"full_name": "LLVM.getNextFunction", "code": "@[extern \"lean_llvm_get_next_function\"]\nopaque getNextFunction (glbl : Value ctx) : BaseIO (Value ctx)", "start": [115, 1], "end": [116, 63], "kind": "commanddeclaration"}, {"full_name": "LLVM.getNamedFunction", "code": "@[extern \"lean_llvm_get_named_function\"]\nopaque getNamedFunction (m : Module ctx) (name : @&String) : BaseIO (Option (Value ctx))", "start": [118, 1], "end": [119, 89], "kind": "commanddeclaration"}, {"full_name": "LLVM.addGlobal", "code": "@[extern \"lean_llvm_add_global\"]\nopaque addGlobal (m : Module ctx) (name : @&String) (type : LLVMType ctx) : BaseIO (Value ctx)", "start": [121, 1], "end": [122, 95], "kind": "commanddeclaration"}, {"full_name": "LLVM.getNamedGlobal", "code": "@[extern \"lean_llvm_get_named_global\"]\nopaque getNamedGlobal (m : Module ctx) (name : @&String) : BaseIO (Option (Value ctx))", "start": [124, 1], "end": [125, 87], "kind": "commanddeclaration"}, {"full_name": "LLVM.getFirstGlobal", "code": "@[extern \"lean_llvm_get_first_global\"]\nopaque getFirstGlobal (m : Module ctx) : BaseIO (Value ctx)", "start": [127, 1], "end": [128, 60], "kind": "commanddeclaration"}, {"full_name": "LLVM.getNextGlobal", "code": "@[extern \"lean_llvm_get_next_global\"]\nopaque getNextGlobal (glbl : Value ctx) : BaseIO (Value ctx)", "start": [130, 1], "end": [131, 61], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildGlobalString", "code": "@[extern \"lean_llvm_build_global_string\"]\nopaque buildGlobalString (builder : Builder ctx) (value : @&String) (name : @&String := \"\") : BaseIO (Value ctx)", "start": [133, 1], "end": [134, 113], "kind": "commanddeclaration"}, {"full_name": "LLVM.isDeclaration", "code": "@[extern \"llvm_is_declaration\"]\nopaque isDeclaration (global : Value ctx) : BaseIO Bool", "start": [136, 1], "end": [137, 56], "kind": "commanddeclaration"}, {"full_name": "LLVM.setInitializer", "code": "@[extern \"lean_llvm_set_initializer\"]\nopaque setInitializer (glbl : Value ctx) (val : Value ctx) : BaseIO Unit", "start": [139, 1], "end": [140, 73], "kind": "commanddeclaration"}, {"full_name": "LLVM.functionType", "code": "@[extern \"lean_llvm_function_type\"]\nopaque functionType (retty : LLVMType ctx) (args : @&Array (LLVMType ctx)) (isVarArg : Bool := false) : BaseIO (LLVMType ctx)", "start": [142, 1], "end": [143, 126], "kind": "commanddeclaration"}, {"full_name": "LLVM.voidType", "code": "@[extern \"lean_llvm_void_type_in_context\"]\nopaque voidType (ctx : Context) : BaseIO (LLVMType ctx)", "start": [145, 1], "end": [146, 56], "kind": "commanddeclaration"}, {"full_name": "LLVM.intTypeInContext", "code": "@[extern \"lean_llvm_int_type_in_context\"]\nopaque intTypeInContext (ctx : Context) (width : UInt64) : BaseIO (LLVMType ctx)", "start": [148, 1], "end": [149, 81], "kind": "commanddeclaration"}, {"full_name": "LLVM.opaquePointerTypeInContext", "code": "@[extern \"lean_llvm_opaque_pointer_type_in_context\"]\nopaque opaquePointerTypeInContext (ctx : Context) (addrspace: UInt64 := 0) : BaseIO (LLVMType ctx)", "start": [151, 1], "end": [152, 99], "kind": "commanddeclaration"}, {"full_name": "LLVM.floatTypeInContext", "code": "@[extern \"lean_llvm_float_type_in_context\"]\nopaque floatTypeInContext (ctx : Context) : BaseIO (LLVMType ctx)", "start": [154, 1], "end": [155, 66], "kind": "commanddeclaration"}, {"full_name": "LLVM.doubleTypeInContext", "code": "@[extern \"lean_llvm_double_type_in_context\"]\nopaque doubleTypeInContext (ctx : Context) : BaseIO (LLVMType ctx)", "start": [157, 1], "end": [158, 67], "kind": "commanddeclaration"}, {"full_name": "LLVM.pointerType", "code": "@[extern \"lean_llvm_pointer_type\"]\nopaque pointerType (elemty : LLVMType ctx) : BaseIO (LLVMType ctx)", "start": [160, 1], "end": [161, 67], "kind": "commanddeclaration"}, {"full_name": "LLVM.arrayType", "code": "@[extern \"lean_llvm_array_type\"]\nopaque arrayType (elemty : LLVMType ctx) (nelem : UInt64) : BaseIO (LLVMType ctx)", "start": [163, 1], "end": [164, 82], "kind": "commanddeclaration"}, {"full_name": "LLVM.constArray", "code": "@[extern \"lean_llvm_const_array\"]\nopaque constArray (elemty : LLVMType ctx) (vals : @&Array (Value ctx)) : BaseIO (LLVMType ctx)", "start": [166, 1], "end": [167, 95], "kind": "commanddeclaration"}, {"full_name": "LLVM.constString", "code": "@[extern \"lean_llvm_const_string\"]\nopaque constString (ctx : Context) (str : @&String) : BaseIO (Value ctx)", "start": [170, 1], "end": [171, 73], "kind": "commanddeclaration"}, {"full_name": "LLVM.constPointerNull", "code": "@[extern \"lean_llvm_const_pointer_null\"]\nopaque constPointerNull (elemty : LLVMType ctx) : BaseIO (Value ctx)", "start": [173, 1], "end": [174, 69], "kind": "commanddeclaration"}, {"full_name": "LLVM.getUndef", "code": "@[extern \"lean_llvm_get_undef\"]\nopaque getUndef (elemty : LLVMType ctx) : BaseIO (Value ctx)", "start": [176, 1], "end": [177, 61], "kind": "commanddeclaration"}, {"full_name": "LLVM.createBuilderInContext", "code": "@[extern \"lean_llvm_create_builder_in_context\"]\nopaque createBuilderInContext (ctx : Context) : BaseIO (Builder ctx)", "start": [179, 1], "end": [180, 69], "kind": "commanddeclaration"}, {"full_name": "LLVM.appendBasicBlockInContext", "code": "@[extern \"lean_llvm_append_basic_block_in_context\"]\nopaque appendBasicBlockInContext (ctx : Context) (fn :  Value ctx) (name :  @&String) : BaseIO (BasicBlock ctx)", "start": [182, 1], "end": [183, 112], "kind": "commanddeclaration"}, {"full_name": "LLVM.positionBuilderAtEnd", "code": "@[extern \"lean_llvm_position_builder_at_end\"]\nopaque positionBuilderAtEnd (builder : Builder ctx) (bb :  BasicBlock ctx) : BaseIO Unit", "start": [185, 1], "end": [186, 89], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildCall2", "code": "@[extern \"lean_llvm_build_call2\"]\nopaque buildCall2 (builder : Builder ctx) (ty: LLVMType ctx) (fn : Value ctx) (args : @&Array (Value ctx)) (name :  @&String := \"\") : BaseIO (Value ctx)", "start": [188, 1], "end": [189, 153], "kind": "commanddeclaration"}, {"full_name": "LLVM.setTailCall", "code": "@[extern \"lean_llvm_set_tail_call\"]\nopaque setTailCall (fn : Value ctx) (istail : Bool) : BaseIO Unit", "start": [191, 1], "end": [192, 66], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildCondBr", "code": "@[extern \"lean_llvm_build_cond_br\"]\nopaque buildCondBr (builder : Builder ctx) (if_ : Value ctx) (thenbb : BasicBlock ctx) (elsebb : BasicBlock ctx) : BaseIO (Value ctx)", "start": [194, 1], "end": [195, 134], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildBr", "code": "@[extern \"lean_llvm_build_br\"]\nopaque buildBr (builder : Builder ctx) (bb : BasicBlock ctx) : BaseIO (Value ctx)", "start": [197, 1], "end": [198, 82], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildAlloca", "code": "@[extern \"lean_llvm_build_alloca\"]\nopaque buildAlloca (builder : Builder ctx) (ty : LLVMType ctx) (name : @&String := \"\") : BaseIO (Value ctx)", "start": [200, 1], "end": [201, 108], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildLoad2", "code": "@[extern \"lean_llvm_build_load2\"]\nopaque buildLoad2 (builder : Builder ctx) (ty: LLVMType ctx) (val : Value ctx) (name : @&String := \"\") : BaseIO (Value ctx)", "start": [203, 1], "end": [204, 124], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildStore", "code": "@[extern \"lean_llvm_build_store\"]\nopaque buildStore (builder : Builder ctx) (val : Value ctx) (store_loc_ptr : Value ctx) : BaseIO Unit", "start": [206, 1], "end": [207, 102], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildRet", "code": "@[extern \"lean_llvm_build_ret\"]\nopaque buildRet (builder : Builder ctx) (val : Value ctx) : BaseIO (Value ctx)", "start": [209, 1], "end": [210, 79], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildUnreachable", "code": "@[extern \"lean_llvm_build_unreachable\"]\nopaque buildUnreachable (builder : Builder ctx) : BaseIO (Value ctx)", "start": [212, 1], "end": [213, 69], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildGEP2", "code": "@[extern \"lean_llvm_build_gep2\"]\nopaque buildGEP2 (builder : Builder ctx) (ty: LLVMType ctx) (base : Value ctx) (ixs : @&Array (Value ctx)) (name : @&String := \"\") : BaseIO (Value ctx)", "start": [215, 1], "end": [216, 152], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildInBoundsGEP2", "code": "@[extern \"lean_llvm_build_inbounds_gep2\"]\nopaque buildInBoundsGEP2 (builder : Builder ctx) (ty: LLVMType ctx) (base : Value ctx) (ixs : @&Array (Value ctx)) (name : @&String := \"\") : BaseIO (Value ctx)", "start": [218, 1], "end": [219, 160], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildSext", "code": "@[extern \"lean_llvm_build_sext\"]\nopaque buildSext (builder : Builder ctx) (val : Value ctx) (destTy : LLVMType ctx) (name : @&String := \"\") : BaseIO (Value ctx)", "start": [221, 1], "end": [222, 128], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildZext", "code": "@[extern \"lean_llvm_build_zext\"]\nopaque buildZext (builder : Builder ctx) (val : Value ctx) (destTy : LLVMType ctx) (name : @&String := \"\") : BaseIO (Value ctx)", "start": [224, 1], "end": [225, 128], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildSextOrTrunc", "code": "@[extern \"lean_llvm_build_sext_or_trunc\"]\nopaque buildSextOrTrunc (builder : Builder ctx) (val : Value ctx) (destTy : LLVMType ctx) (name : @&String := \"\") : BaseIO (Value ctx)", "start": [227, 1], "end": [228, 135], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildSwitch", "code": "@[extern \"lean_llvm_build_switch\"]\nopaque buildSwitch (builder : Builder ctx) (val : Value ctx) (elseBB : BasicBlock ctx) (numCasesHint : UInt64) : BaseIO (Value ctx)", "start": [230, 1], "end": [231, 132], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildPtrToInt", "code": "@[extern \"lean_llvm_build_ptr_to_int\"]\nopaque buildPtrToInt (builder : Builder ctx) (ptr : Value ctx) (destTy : LLVMType ctx) (name : @&String := \"\") : BaseIO (Value ctx)", "start": [233, 1], "end": [234, 132], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildMul", "code": "@[extern \"lean_llvm_build_mul\"]\nopaque buildMul (builder : Builder ctx) (x y : Value ctx) (name : @&String := \"\") : BaseIO (Value ctx)", "start": [236, 1], "end": [237, 103], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildAdd", "code": "@[extern \"lean_llvm_build_add\"]\nopaque buildAdd (builder : Builder ctx) (x y : Value ctx) (name : @&String := \"\") : BaseIO (Value ctx)", "start": [239, 1], "end": [240, 103], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildSub", "code": "@[extern \"lean_llvm_build_sub\"]\nopaque buildSub (builder : Builder ctx) (x y : Value ctx) (name : @&String := \"\") : BaseIO (Value ctx)", "start": [242, 1], "end": [243, 103], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildNot", "code": "@[extern \"lean_llvm_build_not\"]\nopaque buildNot (builder : Builder ctx) (x : Value ctx) (name : @&String := \"\") : BaseIO (Value ctx)", "start": [245, 1], "end": [246, 101], "kind": "commanddeclaration"}, {"full_name": "LLVM.buildICmp", "code": "@[extern \"lean_llvm_build_icmp\"]\nopaque buildICmp (builder : Builder ctx) (predicate : IntPredicate) (x y : Value ctx) (name : @&String := \"\") : BaseIO (Value ctx)", "start": [248, 1], "end": [249, 131], "kind": "commanddeclaration"}, {"full_name": "LLVM.addCase", "code": "@[extern \"lean_llvm_add_case\"]\nopaque addCase (switch onVal : Value ctx) (destBB : BasicBlock ctx) : BaseIO Unit", "start": [251, 1], "end": [252, 82], "kind": "commanddeclaration"}, {"full_name": "LLVM.getInsertBlock", "code": "@[extern \"lean_llvm_get_insert_block\"]\nopaque getInsertBlock (builder : Builder ctx) : BaseIO (BasicBlock ctx)", "start": [254, 1], "end": [255, 72], "kind": "commanddeclaration"}, {"full_name": "LLVM.clearInsertionPosition", "code": "@[extern \"lean_llvm_clear_insertion_position\"]\nopaque clearInsertionPosition (builder : Builder ctx) : BaseIO Unit", "start": [257, 1], "end": [258, 68], "kind": "commanddeclaration"}, {"full_name": "LLVM.getBasicBlockParent", "code": "@[extern \"lean_llvm_get_basic_block_parent\"]\nopaque getBasicBlockParent (bb : BasicBlock ctx) : BaseIO (Value ctx)", "start": [260, 1], "end": [261, 70], "kind": "commanddeclaration"}, {"full_name": "LLVM.typeOf", "code": "@[extern \"lean_llvm_type_of\"]\nopaque typeOf (val : Value ctx) : BaseIO (LLVMType ctx)", "start": [263, 1], "end": [264, 56], "kind": "commanddeclaration"}, {"full_name": "LLVM.constInt", "code": "@[extern \"lean_llvm_const_int\"]\nopaque constInt (intty : LLVMType ctx) (value : UInt64) (signExtend : @Bool := false) : BaseIO (Value ctx)", "start": [266, 1], "end": [267, 107], "kind": "commanddeclaration"}, {"full_name": "LLVM.printModuletoString", "code": "@[extern \"lean_llvm_print_module_to_string\"]\nopaque printModuletoString (mod : Module ctx) : BaseIO (String)", "start": [269, 1], "end": [270, 64], "kind": "commanddeclaration"}, {"full_name": "LLVM.printModuletoFile", "code": "@[extern \"lean_llvm_print_module_to_file\"]\nopaque printModuletoFile (mod : Module ctx) (file : @&String) : BaseIO Unit", "start": [272, 1], "end": [273, 76], "kind": "commanddeclaration"}, {"full_name": "LLVM.countParams", "code": "@[extern \"llvm_count_params\"]\nopaque countParams (fn : Value ctx) : BaseIO UInt64", "start": [275, 1], "end": [276, 52], "kind": "commanddeclaration"}, {"full_name": "LLVM.getParam", "code": "@[extern \"llvm_get_param\"]\nopaque getParam (fn : Value ctx) (ix : UInt64) : BaseIO (Value ctx)", "start": [278, 1], "end": [279, 68], "kind": "commanddeclaration"}, {"full_name": "LLVM.createMemoryBufferWithContentsOfFile", "code": "@[extern \"lean_llvm_create_memory_buffer_with_contents_of_file\"]\nopaque createMemoryBufferWithContentsOfFile (path : @&String) : BaseIO (MemoryBuffer ctx)", "start": [281, 1], "end": [282, 90], "kind": "commanddeclaration"}, {"full_name": "LLVM.parseBitcode", "code": "@[extern \"lean_llvm_parse_bitcode\"]\nopaque parseBitcode (ctx : Context) (membuf : MemoryBuffer ctx) : BaseIO (Module ctx)", "start": [284, 1], "end": [285, 86], "kind": "commanddeclaration"}, {"full_name": "LLVM.linkModules", "code": "@[extern \"lean_llvm_link_modules\"]\nopaque linkModules (dest : Module ctx) (src : Module ctx) : BaseIO Unit", "start": [287, 1], "end": [288, 72], "kind": "commanddeclaration"}, {"full_name": "LLVM.getDefaultTargetTriple", "code": "@[extern \"lean_llvm_get_default_target_triple\"]\nopaque getDefaultTargetTriple : BaseIO String", "start": [290, 1], "end": [291, 46], "kind": "commanddeclaration"}, {"full_name": "LLVM.getTargetFromTriple", "code": "@[extern \"lean_llvm_get_target_from_triple\"]\nopaque getTargetFromTriple (triple : @&String) : BaseIO (Target ctx)", "start": [293, 1], "end": [294, 69], "kind": "commanddeclaration"}, {"full_name": "LLVM.createTargetMachine", "code": "@[extern \"lean_llvm_create_target_machine\"]\nopaque createTargetMachine (target : Target ctx) (tripleStr : @&String) (cpu : @&String) (features : @&String) : BaseIO (TargetMachine ctx)", "start": [296, 1], "end": [297, 140], "kind": "commanddeclaration"}, {"full_name": "LLVM.targetMachineEmitToFile", "code": "@[extern \"lean_llvm_target_machine_emit_to_file\"]\nopaque targetMachineEmitToFile (targetMachine : TargetMachine ctx) (module : Module ctx) (filepath : @&String) (codegenType : LLVM.CodegenFileType) : BaseIO Unit", "start": [299, 1], "end": [300, 162], "kind": "commanddeclaration"}, {"full_name": "LLVM.createPassManager", "code": "@[extern \"lean_llvm_create_pass_manager\"]\nopaque createPassManager : BaseIO (PassManager ctx)", "start": [302, 1], "end": [303, 52], "kind": "commanddeclaration"}, {"full_name": "LLVM.disposePassManager", "code": "@[extern \"lean_llvm_dispose_pass_manager\"]\nopaque disposePassManager (pm : PassManager ctx) : BaseIO Unit", "start": [305, 1], "end": [306, 63], "kind": "commanddeclaration"}, {"full_name": "LLVM.runPassManager", "code": "@[extern \"lean_llvm_run_pass_manager\"]\nopaque runPassManager (pm : PassManager ctx) (mod : Module ctx): BaseIO Unit", "start": [308, 1], "end": [309, 77], "kind": "commanddeclaration"}, {"full_name": "LLVM.createPassManagerBuilder", "code": "@[extern \"lean_llvm_create_pass_manager_builder\"]\nopaque createPassManagerBuilder : BaseIO (PassManagerBuilder ctx)", "start": [311, 1], "end": [312, 66], "kind": "commanddeclaration"}, {"full_name": "LLVM.disposePassManagerBuilder", "code": "@[extern \"lean_llvm_dispose_pass_manager_builder\"]\nopaque disposePassManagerBuilder (pmb : PassManagerBuilder ctx) : BaseIO Unit", "start": [314, 1], "end": [315, 78], "kind": "commanddeclaration"}, {"full_name": "LLVM.PassManagerBuilder.setOptLevel", "code": "@[extern \"lean_llvm_pass_manager_builder_set_opt_level\"]\nopaque PassManagerBuilder.setOptLevel (pmb : PassManagerBuilder ctx) (optLevel : unsigned) : BaseIO Unit", "start": [317, 1], "end": [318, 105], "kind": "commanddeclaration"}, {"full_name": "LLVM.PassManagerBuilder.populateModulePassManager", "code": "@[extern \"lean_llvm_pass_manager_builder_populate_module_pass_manager\"]\nopaque PassManagerBuilder.populateModulePassManager (pmb : PassManagerBuilder ctx) (pm : PassManager ctx): BaseIO Unit", "start": [320, 1], "end": [321, 119], "kind": "commanddeclaration"}, {"full_name": "LLVM.disposeTargetMachine", "code": "@[extern \"lean_llvm_dispose_target_machine\"]\nopaque disposeTargetMachine (tm : TargetMachine ctx) : BaseIO Unit", "start": [323, 1], "end": [324, 67], "kind": "commanddeclaration"}, {"full_name": "LLVM.disposeModule", "code": "@[extern \"lean_llvm_dispose_module\"]\nopaque disposeModule (m : Module ctx) : BaseIO Unit", "start": [326, 1], "end": [327, 52], "kind": "commanddeclaration"}, {"full_name": "LLVM.createStringAttribute", "code": "@[extern \"lean_llvm_create_string_attribute\"]\nopaque createStringAttribute (key : String) (value : String) : BaseIO (Attribute ctx)", "start": [329, 1], "end": [330, 86], "kind": "commanddeclaration"}, {"full_name": "LLVM.addAttributeAtIndex", "code": "@[extern \"lean_llvm_add_attribute_at_index\"]\nopaque addAttributeAtIndex (fn : Value ctx) (idx: AttributeIndex) (attr: Attribute ctx) : BaseIO Unit", "start": [332, 1], "end": [333, 102], "kind": "commanddeclaration"}, {"full_name": "LLVM.Visibility", "code": "structure Visibility where\n  private mk :: val : UInt64", "start": [337, 1], "end": [338, 29], "kind": "commanddeclaration"}, {"full_name": "LLVM.Visibility.default", "code": "def Visibility.default   : Visibility := { val := 0 }", "start": [340, 1], "end": [340, 54], "kind": "commanddeclaration"}, {"full_name": "LLVM.Visibility.hidden", "code": "def Visibility.hidden    : Visibility := { val := 1 }", "start": [341, 1], "end": [341, 54], "kind": "commanddeclaration"}, {"full_name": "LLVM.Visibility.protected", "code": "def Visibility.protected : Visibility := { val := 2 }", "start": [342, 1], "end": [342, 54], "kind": "commanddeclaration"}, {"full_name": "LLVM.setVisibility", "code": "@[extern \"lean_llvm_set_visibility\"]\nopaque setVisibility {ctx : Context} (value : Value ctx) (visibility : Visibility) : BaseIO Unit", "start": [344, 1], "end": [345, 97], "kind": "commanddeclaration"}, {"full_name": "LLVM.DLLStorageClass", "code": "structure DLLStorageClass where\n  private mk :: val : UInt64", "start": [348, 1], "end": [349, 29], "kind": "commanddeclaration"}, {"full_name": "LLVM.DLLStorageClass.default", "code": "def DLLStorageClass.default : DLLStorageClass := { val := 0 }", "start": [351, 1], "end": [351, 62], "kind": "commanddeclaration"}, {"full_name": "LLVM.DLLStorageClass.import", "code": "def DLLStorageClass.import  : DLLStorageClass := { val := 1 }", "start": [352, 1], "end": [352, 62], "kind": "commanddeclaration"}, {"full_name": "LLVM.DLLStorageClass.export", "code": "def DLLStorageClass.export  : DLLStorageClass := { val := 2 }", "start": [353, 1], "end": [353, 62], "kind": "commanddeclaration"}, {"full_name": "LLVM.setDLLStorageClass", "code": "@[extern \"lean_llvm_set_dll_storage_class\"]\nopaque setDLLStorageClass {ctx : Context} (value : Value ctx) (dllStorageClass : DLLStorageClass) : BaseIO Unit", "start": [355, 1], "end": [356, 112], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage", "code": "structure Linkage where\n  private mk :: val : UInt64", "start": [359, 1], "end": [360, 29], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.external", "code": "def Linkage.external : Linkage := { val := 0 }", "start": [362, 1], "end": [363, 47], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.availableExternally", "code": "def Linkage.availableExternally : Linkage := { val := 1 }", "start": [364, 1], "end": [364, 58], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.linkOnceAny", "code": "def Linkage.linkOnceAny : Linkage := { val := 2 }", "start": [365, 1], "end": [366, 50], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.linkOnceODR", "code": "def Linkage.linkOnceODR : Linkage := { val := 3 }", "start": [367, 1], "end": [368, 50], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.linkOnceODRAutoHide", "code": "def Linkage.linkOnceODRAutoHide : Linkage := { val := 4 }", "start": [369, 1], "end": [370, 58], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.weakAny", "code": "def Linkage.weakAny : Linkage := { val := 5 }", "start": [371, 1], "end": [372, 46], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.weakODR", "code": "def Linkage.weakODR : Linkage := { val := 6 }", "start": [373, 1], "end": [374, 46], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.appending", "code": "def Linkage.appending : Linkage := { val := 7 }", "start": [375, 1], "end": [376, 48], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.internal", "code": "def Linkage.internal : Linkage := { val := 8 }", "start": [377, 1], "end": [378, 47], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.private", "code": "def Linkage.private : Linkage := { val := 9 }", "start": [379, 1], "end": [380, 46], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.dllImport", "code": "def Linkage.dllImport : Linkage := { val := 10 }", "start": [381, 1], "end": [382, 49], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.dllExport", "code": "def Linkage.dllExport : Linkage := { val := 11 }", "start": [383, 1], "end": [384, 49], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.externalWeak", "code": "def Linkage.externalWeak : Linkage := { val := 12 }", "start": [385, 1], "end": [386, 52], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.ghost", "code": "def Linkage.ghost : Linkage := { val := 13 }", "start": [387, 1], "end": [388, 45], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.common", "code": "def Linkage.common : Linkage := { val := 14 }", "start": [389, 1], "end": [390, 46], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.linkerPrivate", "code": "def Linkage.linkerPrivate : Linkage := { val := 15 }", "start": [391, 1], "end": [392, 53], "kind": "commanddeclaration"}, {"full_name": "LLVM.Linkage.linkerPrivateWeak", "code": "def Linkage.linkerPrivateWeak : Linkage := { val := 16 }", "start": [393, 1], "end": [394, 57], "kind": "commanddeclaration"}, {"full_name": "LLVM.setLinkage", "code": "@[extern \"lean_llvm_set_linkage\"]\nopaque setLinkage {ctx : Context} (value : Value ctx) (linkage : Linkage) : BaseIO Unit", "start": [396, 1], "end": [397, 88], "kind": "commanddeclaration"}, {"full_name": "LLVM.i1Type", "code": "def i1Type (ctx : LLVM.Context) : BaseIO (LLVM.LLVMType ctx) :=\n  LLVM.intTypeInContext ctx 1", "start": [400, 1], "end": [401, 30], "kind": "commanddeclaration"}, {"full_name": "LLVM.i8Type", "code": "def i8Type (ctx : LLVM.Context) : BaseIO (LLVM.LLVMType ctx) :=\n  LLVM.intTypeInContext ctx 8", "start": [403, 1], "end": [404, 30], "kind": "commanddeclaration"}, {"full_name": "LLVM.i16Type", "code": "def i16Type (ctx : LLVM.Context) : BaseIO (LLVM.LLVMType ctx) :=\n  LLVM.intTypeInContext ctx 16", "start": [406, 1], "end": [407, 31], "kind": "commanddeclaration"}, {"full_name": "LLVM.i32Type", "code": "def i32Type (ctx : LLVM.Context) : BaseIO (LLVM.LLVMType ctx) :=\n  LLVM.intTypeInContext ctx 32", "start": [409, 1], "end": [410, 31], "kind": "commanddeclaration"}, {"full_name": "LLVM.i64Type", "code": "def i64Type (ctx : LLVM.Context) : BaseIO (LLVM.LLVMType ctx) :=\n  LLVM.intTypeInContext ctx 64", "start": [412, 1], "end": [413, 31], "kind": "commanddeclaration"}, {"full_name": "LLVM.voidPtrType", "code": "def voidPtrType (ctx : LLVM.Context) : BaseIO (LLVM.LLVMType ctx) :=\n  do LLVM.pointerType (\u2190 LLVM.intTypeInContext ctx 8)", "start": [415, 1], "end": [416, 54], "kind": "commanddeclaration"}, {"full_name": "LLVM.i8PtrType", "code": "def i8PtrType (ctx : LLVM.Context) : BaseIO (LLVM.LLVMType ctx) :=\n  voidPtrType ctx", "start": [418, 1], "end": [419, 18], "kind": "commanddeclaration"}, {"full_name": "LLVM.constTrue", "code": "def constTrue (ctx : Context) : BaseIO (Value ctx) :=\n  do constInt (\u2190 i1Type ctx) 1 (signExtend := false)", "start": [421, 1], "end": [422, 53], "kind": "commanddeclaration"}, {"full_name": "LLVM.constFalse", "code": "def constFalse (ctx : Context) : BaseIO (Value ctx) :=\n  do constInt (\u2190 i1Type ctx) 0 (signExtend := false)", "start": [424, 1], "end": [425, 53], "kind": "commanddeclaration"}, {"full_name": "LLVM.constInt'", "code": "def constInt' (ctx : Context) (width : UInt64) (value : UInt64) (signExtend : Bool := false) : BaseIO (Value ctx) :=\n do constInt (\u2190 LLVM.intTypeInContext ctx width) value signExtend", "start": [427, 1], "end": [428, 66], "kind": "commanddeclaration"}, {"full_name": "LLVM.constInt1", "code": "def constInt1 (ctx : Context) (value : UInt64) (signExtend : Bool := false) : BaseIO (Value ctx) :=\n  constInt' ctx 1 value signExtend", "start": [430, 1], "end": [431, 35], "kind": "commanddeclaration"}, {"full_name": "LLVM.constInt8", "code": "def constInt8 (ctx : Context) (value : UInt64) (signExtend : Bool := false) : BaseIO (Value ctx) :=\n  constInt' ctx 8 value signExtend", "start": [433, 1], "end": [434, 35], "kind": "commanddeclaration"}, {"full_name": "LLVM.constInt32", "code": "def constInt32 (ctx : Context) (value : UInt64) (signExtend : Bool := false) : BaseIO (Value ctx) :=\n  constInt' ctx 32 value signExtend", "start": [436, 1], "end": [437, 36], "kind": "commanddeclaration"}, {"full_name": "LLVM.constInt64", "code": "def constInt64 (ctx : Context) (value : UInt64) (signExtend : Bool := false) : BaseIO (Value ctx) :=\n  constInt' ctx 64 value signExtend", "start": [439, 1], "end": [440, 36], "kind": "commanddeclaration"}, {"full_name": "LLVM.constIntUnsigned", "code": "def constIntUnsigned (ctx : Context) (value : UInt64) (signExtend : Bool := false) : BaseIO (Value ctx) :=\n  constInt' ctx 64 value signExtend", "start": [442, 1], "end": [443, 36], "kind": "commanddeclaration"}]}
{"path": "lake-packages/proofwidgets/ProofWidgets/Component/HtmlDisplay.lean", "imports": ["lake-packages/proofwidgets/ProofWidgets/Data/Html.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProofWidgets.HtmlDisplayProps", "code": "structure HtmlDisplayProps where\n  html : Html", "start": [8, 1], "end": [9, 14], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.HtmlDisplay", "code": "@[widget_module]\ndef HtmlDisplay : Component HtmlDisplayProps where\n  javascript := include_str \"..\" / \"..\" / \"build\" / \"js\" / \"htmlDisplay.js\"", "start": [13, 1], "end": [15, 76], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.HtmlDisplayPanel", "code": "@[widget_module]\ndef HtmlDisplayPanel : Component HtmlDisplayProps where\n  javascript := include_str \"..\" / \"..\" / \"build\" / \"js\" / \"htmlDisplayPanel.js\"", "start": [17, 1], "end": [19, 81], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.evalHtmlUnsafe", "code": "unsafe def evalHtmlUnsafe (stx : Term) : TermElabM Html := do\n  let htmlT := mkConst ``Html\n  Term.evalTerm Html htmlT stx", "start": [22, 1], "end": [24, 31], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.evalHtml", "code": "@[implemented_by evalHtmlUnsafe]\nopaque evalHtml : Term \u2192 TermElabM Html", "start": [27, 1], "end": [28, 40], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.elabHtmlCmd", "code": "@[command_elab htmlCmd]\ndef elabHtmlCmd : CommandElab := fun\n  | stx@`(#html $t:term) =>\n    runTermElabM fun _ => do\n      let ht \u2190 evalHtml t\n      savePanelWidgetInfo stx ``HtmlDisplayPanel do\n        return json% { html: $(\u2190 rpcEncode ht) }\n  | stx => throwError \"Unexpected syntax {stx}.\"", "start": [33, 1], "end": [40, 49], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.elabHtmlTac", "code": "@[tactic htmlTac]\ndef elabHtmlTac : Tactic\n  | stx@`(tactic| html! $t:term) => do\n    let ht \u2190 evalHtml t\n    savePanelWidgetInfo stx ``HtmlDisplayPanel do\n      return json% { html: $(\u2190 rpcEncode ht) }\n  | stx => throwError \"Unexpected syntax {stx}.\"", "start": [45, 1], "end": [51, 49], "kind": "commanddeclaration"}]}
{"path": "lake-packages/proofwidgets/ProofWidgets/Component/InteractiveSvg.lean", "imports": ["lake-packages/proofwidgets/ProofWidgets/Data/Svg.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Float.toInt", "code": "private def _root_.Float.toInt (x : Float) : Int :=\n  if x >= 0 then\n    x.toUInt64.toNat\n  else\n    -((-x).toUInt64.toNat)", "start": [6, 1], "end": [10, 27], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.ActionKind", "code": "inductive ActionKind where\n  | timeout\n  | mousedown\n  | mouseup\n  | mousemove deriving ToJson, FromJson, DecidableEq", "start": [14, 1], "end": [19, 41], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Action", "code": "structure Action where\n  kind : ActionKind\n  id : Option String\n  data : Option Json\n  deriving ToJson, FromJson", "start": [21, 1], "end": [25, 28], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.SvgState", "code": "structure SvgState (State : Type) where\n  state : State\n  time : Float \n  selected : Option String\n  mousePos : Option (Int \u00d7 Int)\n  idToData : List (String \u00d7 Json)\nderiving ToJson, FromJson", "start": [27, 1], "end": [36, 26], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.UpdateParams", "code": "structure UpdateParams (State : Type) where\n  elapsed : Float\n  actions : Array Action\n  state : SvgState State\n  mousePos : Option (Float \u00d7 Float) deriving ToJson, FromJson", "start": [40, 1], "end": [45, 28], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.UpdateResult", "code": "structure UpdateResult (State : Type) where\n  html : Html\n  state : SvgState State\n  \n  callbackTime : Option Float := some 33", "start": [47, 1], "end": [51, 41], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.InteractiveSvg", "code": "structure InteractiveSvg (State : Type) where\n  init : State\n  frame : Svg.Frame\n  update (time_ms \u0394t_ms : Float) (action : Action)\n         (mouseStart mouseEnd : Option (Svg.Point frame))\n         (selectedId : Option String) (getSelectedData : (\u03b1 : Type) \u2192 [FromJson \u03b1] \u2192 Option \u03b1)\n         : State \u2192 State\n  render (time_ms : Float) (mouseStart mouseEnd : Option (Svg.Point frame)) : State \u2192 Svg frame", "start": [56, 1], "end": [63, 96], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.InteractiveSvg.serverRpcMethod", "code": "def InteractiveSvg.serverRpcMethod {State : Type} (isvg : InteractiveSvg State) (params : UpdateParams State)\n  : RequestM (RequestTask (UpdateResult State)) := do\n\n  let \u0394t := (params.elapsed - params.state.time) / params.actions.size.toFloat\n\n  let idToData : HashMap String Json := HashMap.ofList params.state.idToData\n\n  let mut time := params.state.time\n  let mut state := params.state.state\n  let mut selected := params.state.selected\n\n  let getData := \u03bb (\u03b1 : Type) [FromJson \u03b1] => do\n    let id \u2190 selected;\n    let data \u2190 idToData[id]\n    match fromJson? (\u03b1:=\u03b1) data with\n    | .error _ => none\n    | .ok val => some val\n\n\n  let mouseStart := params.state.mousePos.map \u03bb (i,j) => (i, j)\n  let mouseEnd := params.mousePos.map \u03bb (x,y) => (x.toInt, y.toInt)\n\n  for action in params.actions do\n    state := isvg.update time \u0394t action mouseStart mouseEnd selected getData state\n\n    if action.kind == ActionKind.mousedown then\n      selected := action.id\n    if action.kind == ActionKind.mouseup then\n      selected := none\n\n    time := time + \u0394t\n\n  let mut svg := isvg.render time mouseStart mouseEnd state\n\n  let svgState : SvgState State :=\n    { state := state\n      time := params.elapsed\n      selected := selected\n      mousePos := mouseEnd.map \u03bb p => p.toPixels\n      idToData := svg.idToDataList }\n\n\n  if let some id := selected then\n    if let some idx := svg.idToIdx[id] then\n      svg := { elements := svg.elements.modify idx \u03bb e => e.setStroke (1.,1.,0.) (.px 5) }\n\n\n  return RequestTask.pure {\n    html := <div>\n        {svg.toHtml}\n      </div>,\n    state := svgState,\n    callbackTime := some 33,\n  }", "start": [66, 1], "end": [127, 4], "kind": "commanddeclaration"}]}
{"path": "lake-packages/proofwidgets/ProofWidgets/Component/Recharts.lean", "imports": ["lake-packages/proofwidgets/ProofWidgets/Component/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProofWidgets.Recharts.Recharts", "code": "@[widget_module]\ndef Recharts : Module where\n  javascript := include_str \"../../build/js/recharts.js\"", "start": [6, 1], "end": [8, 57], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Recharts.LineChartLayout", "code": "inductive LineChartLayout where\n  | horizontal\n  | vertical\n  deriving FromJson, ToJson", "start": [10, 1], "end": [13, 28], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Recharts.LineChartSyncMethod", "code": "inductive LineChartSyncMethod where\n  | index | value\n  deriving FromJson, ToJson", "start": [15, 1], "end": [17, 28], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Recharts.LineChartMargin", "code": "structure LineChartMargin where\n  top : Nat := 5\n  right : Nat := 5\n  bottom : Nat := 5\n  left : Nat := 5\n  deriving FromJson, ToJson", "start": [19, 1], "end": [24, 28], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Recharts.LineChartProps", "code": "structure LineChartProps where\n  layout : LineChartLayout := .horizontal\n  syncId? : Option String := none\n  syncMethod? : Option LineChartSyncMethod := some .index\n  width : Nat\n  height : Nat\n  data : Array Json\n  margin : LineChartMargin := {}\n  deriving FromJson, ToJson", "start": [26, 1], "end": [34, 28], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Recharts.LineChart", "code": "def LineChart : Component LineChartProps where\n  javascript := Recharts.javascript\n  \u00abexport\u00bb := \"LineChart\"", "start": [36, 1], "end": [39, 26], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Recharts.AxisProps", "code": "structure AxisProps where\n  dataKey? : Option Json := none\n  domain? : Option (Array Json) := none\n  allowDataOverflow : Bool := false\n  deriving FromJson, ToJson", "start": [41, 1], "end": [46, 28], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Recharts.XAxis", "code": "def XAxis : Component AxisProps where\n  javascript := Recharts.javascript\n  \u00abexport\u00bb := \"XAxis\"", "start": [48, 1], "end": [51, 22], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Recharts.YAxis", "code": "def YAxis : Component AxisProps where\n  javascript := Recharts.javascript\n  \u00abexport\u00bb := \"YAxis\"", "start": [53, 1], "end": [56, 22], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Recharts.LineType", "code": "inductive LineType where\n  | basis | basisClosed | basisOpen | linear | linearClosed | natural | monotoneX | monotoneY\n  | monotone | step | stepBefore | stepAfter\n  deriving FromJson, ToJson", "start": [58, 1], "end": [61, 28], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Recharts.LineProps", "code": "structure LineProps where\n  type : LineType := .linear\n  dataKey : Json\n  stroke : String\n  dot? : Option Bool := none\n  deriving FromJson, ToJson", "start": [63, 1], "end": [69, 28], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Recharts.Line", "code": "def Line : Component LineProps where\n  javascript := Recharts.javascript\n  \u00abexport\u00bb := \"Line\"", "start": [71, 1], "end": [74, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/proofwidgets/ProofWidgets/Component/Panel/GoalTypePanel.lean", "imports": ["lake-packages/proofwidgets/ProofWidgets/Component/Panel/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProofWidgets.GoalTypePanel", "code": "@[widget_module]\ndef GoalTypePanel : Component PanelWidgetProps where\n  javascript := include_str \"..\" / \"..\" / \"..\" / \"build\" / \"js\" / \"goalTypePanel.js\"", "start": [5, 1], "end": [8, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib.lean", "imports": ["Mathlib/NumberTheory/ClassNumber/AdmissibleAbs.lean", "Mathlib/Geometry/Manifold/ContMDiffMap.lean", "Mathlib/AlgebraicTopology/FundamentalGroupoid/Product.lean", "Mathlib/Topology/Instances/Real.lean", "Mathlib/Logic/Function/Iterate.lean", "Mathlib/CategoryTheory/Functor/LeftDerived.lean", "Mathlib/FieldTheory/Laurent.lean", "Mathlib/Algebra/Order/Group/Abs.lean", "Mathlib/Data/Sign.lean", "Mathlib/Order/RelSeries.lean", "Mathlib/Data/PFunctor/Multivariate/W.lean", "Mathlib/ModelTheory/Types.lean", "Mathlib/Combinatorics/Quiver/SingleObj.lean", "Mathlib/ModelTheory/Satisfiability.lean", "Mathlib/Algebra/CharP/Pi.lean", "Mathlib/MeasureTheory/Measure/AEDisjoint.lean", "Mathlib/Topology/MetricSpace/Gluing.lean", "Mathlib/Data/Int/Cast/Field.lean", "Mathlib/FieldTheory/Finite/GaloisField.lean", "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean", "Mathlib/Tactic/Classical.lean", "Mathlib/Algebra/Invertible/GroupWithZero.lean", "Mathlib/Data/Set/Pointwise/BigOperators.lean", "Mathlib/AlgebraicTopology/DoldKan/PInfty.lean", "Mathlib/CategoryTheory/Limits/Constructions/Filtered.lean", "Mathlib/Analysis/Normed/Group/AddTorsor.lean", "Mathlib/CategoryTheory/Sites/Plus.lean", "Mathlib/MeasureTheory/Function/Egorov.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/Manifold.lean", "Mathlib/Control/Traversable/Instances.lean", "Mathlib/CategoryTheory/Arrow.lean", "Mathlib/Tactic/Lift.lean", "Mathlib/RingTheory/ClassGroup.lean", "Mathlib/Analysis/NormedSpace/Extr.lean", "Mathlib/Algebra/GroupWithZero/Semiconj.lean", "Mathlib/AlgebraicGeometry/PrimeSpectrum/Maximal.lean", "Mathlib/Data/Nat/Cast/Commute.lean", "Mathlib/Combinatorics/Additive/Behrend.lean", "Mathlib/Topology/Filter.lean", "Mathlib/Analysis/InnerProductSpace/ProdL2.lean", "Mathlib/Data/Set/Sigma.lean", "Mathlib/CategoryTheory/Functor/Flat.lean", "Mathlib/Data/QPF/Multivariate/Constructions/Sigma.lean", "Mathlib/Tactic/Widget/CommDiag.lean", "Mathlib/Topology/DiscreteSubset.lean", "Mathlib/Data/LazyList/Basic.lean", "Mathlib/Data/Int/AbsoluteValue.lean", "Mathlib/Data/ULift.lean", "Mathlib/Algebra/Tropical/Basic.lean", "Mathlib/CategoryTheory/Category/Cat/Limit.lean", "Mathlib/Data/Multiset/FinsetOps.lean", "Mathlib/Data/Multiset/Pi.lean", "Mathlib/Data/DFinsupp/Lex.lean", "Mathlib/Algebra/NeZero.lean", "Mathlib/Algebra/Algebra/Operations.lean", "Mathlib/AlgebraicTopology/TopologicalSimplex.lean", "Mathlib/CategoryTheory/Localization/Composition.lean", "Mathlib/Data/DFinsupp/Basic.lean", "Mathlib/Data/Nat/PrimeNormNum.lean", "Mathlib/Probability/IdentDistrib.lean", "Mathlib/RingTheory/IntegrallyClosed.lean", "Mathlib/Algebra/Hom/Equiv/TypeTags.lean", "Mathlib/Analysis/SpecialFunctions/Bernstein.lean", "Mathlib/Topology/UnitInterval.lean", "Mathlib/AlgebraicGeometry/ProjectiveSpectrum/StructureSheaf.lean", "Mathlib/CategoryTheory/Shift/Opposite.lean", "Mathlib/CategoryTheory/Monoidal/Internal/Module.lean", "Mathlib/LinearAlgebra/TensorAlgebra/Basic.lean", "Mathlib/Topology/Category/TopCat/Adjunctions.lean", "Mathlib/Algebra/DirectSum/Ring.lean", "Mathlib/Data/Finset/NatAntidiagonal.lean", "Mathlib/Order/Category/FinBddDistLat.lean", "Mathlib/CategoryTheory/Products/Associator.lean", "Mathlib/Algebra/CharP/CharAndCard.lean", "Mathlib/Tactic/ProxyType.lean", "Mathlib/Data/Finite/Basic.lean", "Mathlib/Algebra/DirectLimit.lean", "Mathlib/Algebra/EuclideanDomain/Basic.lean", "Mathlib/Topology/Category/TopCat/Limits/Products.lean", "Mathlib/Tactic/Congr!.lean", "Mathlib/AlgebraicGeometry/Morphisms/UniversallyClosed.lean", "Mathlib/Data/Vector/Zip.lean", "Mathlib/Algebra/GroupWithZero/Bitwise.lean", "Mathlib/Analysis/Complex/ReImTopology.lean", "Mathlib/Data/DFinsupp/Order.lean", "Mathlib/Algebra/Category/GroupCat/EquivalenceGroupAddGroup.lean", "Mathlib/Geometry/RingedSpace/PresheafedSpace/HasColimits.lean", "Mathlib/LinearAlgebra/ExteriorAlgebra/OfAlternating.lean", "Mathlib/LinearAlgebra/Matrix/Charpoly/LinearMap.lean", "Mathlib/MeasureTheory/Measure/AEMeasurable.lean", "Mathlib/Analysis/Hofer.lean", "Mathlib/CategoryTheory/Bicategory/Basic.lean", "Mathlib/Data/ZMod/Basic.lean", "Mathlib/RingTheory/Adjoin/FG.lean", "Mathlib/Tactic/Linarith/Parsing.lean", "Mathlib/Topology/Instances/Discrete.lean", "Mathlib/CategoryTheory/Limits/ColimitLimit.lean", "Mathlib/NumberTheory/Padics/PadicNumbers.lean", "Mathlib/Tactic/ScopedNS.lean", "Mathlib/Data/Polynomial/Degree/Definitions.lean", "Mathlib/Order/RelIso/Set.lean", "Mathlib/RingTheory/Valuation/RamificationGroup.lean", "Mathlib/CategoryTheory/Monoidal/Rigid/FunctorCategory.lean", "Mathlib/Algebra/Module/PointwisePi.lean", "Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "Mathlib/SetTheory/Ordinal/Principal.lean", "Mathlib/Topology/Category/TopCat/OpenNhds.lean", "Mathlib/RingTheory/Polynomial/Bernstein.lean", "Mathlib/Tactic/Explode/Datatypes.lean", "Mathlib/MeasureTheory/Function/L1Space.lean", "Mathlib/Data/MLList/Split.lean", "Mathlib/MeasureTheory/Measure/Sub.lean", "Mathlib/GroupTheory/Solvable.lean", "Mathlib/Algebra/Lie/DirectSum.lean", "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "Mathlib/Analysis/Calculus/Monotone.lean", "Mathlib/Analysis/BoxIntegral/Basic.lean", "Mathlib/Order/Irreducible.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Kernels.lean", "Mathlib/Geometry/Manifold/Instances/Real.lean", "Mathlib/Algebra/Category/GroupCat/Kernels.lean", "Mathlib/Logic/IsEmpty.lean", "Mathlib/Data/Polynomial/Degree/CardPowDegree.lean", "Mathlib/Combinatorics/Quiver/Basic.lean", "Mathlib/Data/Bool/Basic.lean", "Mathlib/MeasureTheory/Function/ConvergenceInMeasure.lean", "Mathlib/Data/MvPolynomial/Rename.lean", "Mathlib/Analysis/Normed/Order/Basic.lean", "Mathlib/Order/PrimeIdeal.lean", "Mathlib/Algebra/Order/SMul.lean", "Mathlib/LinearAlgebra/ExteriorAlgebra/Basic.lean", "Mathlib/Topology/Algebra/GroupCompletion.lean", "Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean", "Mathlib/Analysis/LocallyConvex/Polar.lean", "Mathlib/Order/Filter/Bases.lean", "Mathlib/Data/Finset/NAry.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "Mathlib/Geometry/Manifold/WhitneyEmbedding.lean", "Mathlib/Logic/Equiv/Functor.lean", "Mathlib/Computability/TMComputable.lean", "Mathlib/Data/Finset/MulAntidiagonal.lean", "Mathlib/Analysis/BoxIntegral/Box/SubboxInduction.lean", "Mathlib/Lean/LocalContext.lean", "Mathlib/Data/Set/Enumerate.lean", "Mathlib/Algebra/Order/Ring/Canonical.lean", "Mathlib/Topology/DiscreteQuotient.lean", "Mathlib/Analysis/Calculus/Taylor.lean", "Mathlib/Topology/Algebra/Order/LiminfLimsup.lean", "Mathlib/Order/Filter/Germ.lean", "Mathlib/Data/Nat/Units.lean", "Mathlib/LinearAlgebra/Matrix/Basis.lean", "Mathlib/Order/Booleanisation.lean", "Mathlib/Algebra/ContinuedFractions/Computation/ApproximationCorollaries.lean", "Mathlib/Combinatorics/SimpleGraph/Prod.lean", "Mathlib/Data/MLList/DepthFirst.lean", "Mathlib/Algebra/DirectSum/Finsupp.lean", "Mathlib/Algebra/Group/Commute/Units.lean", "Mathlib/AlgebraicTopology/SplitSimplicialObject.lean", "Mathlib/Algebra/Order/Pi.lean", "Mathlib/Algebra/Order/Archimedean.lean", "Mathlib/CategoryTheory/IsConnected.lean", "Mathlib/Topology/UniformSpace/Separation.lean", "Mathlib/CategoryTheory/Limits/Shapes/FiniteProducts.lean", "Mathlib/Order/Filter/CountableSeparatingOn.lean", "Mathlib/Data/Set/Intervals/Image.lean", "Mathlib/Mathport/Rename.lean", "Mathlib/Algebra/HierarchyDesign.lean", "Mathlib/Data/ZMod/Quotient.lean", "Mathlib/Init/ZeroOne.lean", "Mathlib/CategoryTheory/Abelian/Generator.lean", "Mathlib/Init/Meta/WellFoundedTactics.lean", "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "Mathlib/Analysis/Normed/Order/UpperLower.lean", "Mathlib/CategoryTheory/Monoidal/OfChosenFiniteProducts/Symmetric.lean", "Mathlib/Tactic/NormNum/Core.lean", "Mathlib/Algebra/Ring/Units.lean", "Mathlib/CategoryTheory/ConnectedComponents.lean", "Mathlib/Logic/Small/List.lean", "Mathlib/MeasureTheory/Function/AEEqFun/DomAct.lean", "Mathlib/Analysis/InnerProductSpace/Calculus.lean", "Mathlib/NumberTheory/Liouville/LiouvilleNumber.lean", "Mathlib/Algebra/Ring/InjSurj.lean", "Mathlib/GroupTheory/GroupAction/ConjAct.lean", "Mathlib/CategoryTheory/Preadditive/Injective.lean", "Mathlib/Logic/Nontrivial/Defs.lean", "Mathlib/Mathport/Attributes.lean", "Mathlib/Data/Finsupp/Fin.lean", "Mathlib/Probability/Martingale/Convergence.lean", "Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "Mathlib/Geometry/Manifold/VectorBundle/Basic.lean", "Mathlib/Data/BinaryHeap.lean", "Mathlib/LinearAlgebra/DirectSum/TensorProduct.lean", "Mathlib/Data/Set/BoolIndicator.lean", "Mathlib/Algebra/Order/Field/InjSurj.lean", "Mathlib/LinearAlgebra/Multilinear/FiniteDimensional.lean", "Mathlib/MeasureTheory/Function/AEEqOfIntegral.lean", "Mathlib/LinearAlgebra/Alternating/DomCoprod.lean", "Mathlib/Algebra/Hom/Equiv/Units/Basic.lean", "Mathlib/GroupTheory/SemidirectProduct.lean", "Mathlib/Order/Hom/Order.lean", "Mathlib/Data/Complex/Basic.lean", "Mathlib/Topology/Category/CompHaus/EffectiveEpi.lean", "Mathlib/Data/Real/GoldenRatio.lean", "Mathlib/Data/Nat/Fib.lean", "Mathlib/CategoryTheory/Monoidal/Functor.lean", "Mathlib/Algebra/Order/AbsoluteValue.lean", "Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "Mathlib/Algebra/Group/Semiconj/Basic.lean", "Mathlib/Analysis/SpecialFunctions/SmoothTransition.lean", "Mathlib/Data/Polynomial/HasseDeriv.lean", "Mathlib/Topology/ContinuousFunction/Basic.lean", "Mathlib/Algebra/Order/Hom/Basic.lean", "Mathlib/Data/Fin/Tuple/BubbleSortInduction.lean", "Mathlib/RingTheory/Jacobson.lean", "Mathlib/RingTheory/RootsOfUnity/Minpoly.lean", "Mathlib/Analysis/BoundedVariation.lean", "Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean", "Mathlib/Algebra/ContinuedFractions/ConvergentsEquiv.lean", "Mathlib/Data/QPF/Multivariate/Basic.lean", "Mathlib/CategoryTheory/Abelian/RightDerived.lean", "Mathlib/MeasureTheory/Function/ContinuousMapDense.lean", "Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean", "Mathlib/Tactic/PrintPrefix.lean", "Mathlib/Analysis/Convex/Extrema.lean", "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "Mathlib/CategoryTheory/Sites/RegularExtensive.lean", "Mathlib/CategoryTheory/Subobject/WellPowered.lean", "Mathlib/LinearAlgebra/AnnihilatingPolynomial.lean", "Mathlib/Topology/Category/Profinite/AsLimit.lean", "Mathlib/LinearAlgebra/TensorProduct.lean", "Mathlib/Tactic/Observe.lean", "Mathlib/Tactic/PushNeg.lean", "Mathlib/RingTheory/Trace.lean", "Mathlib/CategoryTheory/Category/KleisliCat.lean", "Mathlib/Data/Set/Equitable.lean", "Mathlib/Analysis/Analytic/Basic.lean", "Mathlib/Geometry/Euclidean/Angle/Unoriented/Conformal.lean", "Mathlib/Data/Finsupp/BigOperators.lean", "Mathlib/RepresentationTheory/Action.lean", "Mathlib/Data/Nat/Factorial/SuperFactorial.lean", "Mathlib/Tactic/Continuity.lean", "Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean", "Mathlib/Analysis/Fourier/AddCircle.lean", "Mathlib/Analysis/Matrix.lean", "Mathlib/CategoryTheory/Category/Pointed.lean", "Mathlib/Analysis/Distribution/SchwartzSpace.lean", "Mathlib/Data/MLList/IO.lean", "Mathlib/AlgebraicTopology/DoldKan/HomotopyEquivalence.lean", "Mathlib/Data/QPF/Multivariate/Constructions/Cofix.lean", "Mathlib/Order/Filter/Curry.lean", "Mathlib/Probability/ConditionalProbability.lean", "Mathlib/Topology/Instances/Sign.lean", "Mathlib/CategoryTheory/Limits/ConeCategory.lean", "Mathlib/Geometry/Euclidean/Inversion/Basic.lean", "Mathlib/Geometry/Euclidean/MongePoint.lean", "Mathlib/Algebra/Homology/Homotopy.lean", "Mathlib/NumberTheory/SumFourSquares.lean", "Mathlib/Data/Seq/WSeq.lean", "Mathlib/CategoryTheory/Limits/Connected.lean", "Mathlib/Tactic/ToLevel.lean", "Mathlib/CategoryTheory/Abelian/Exact.lean", "Mathlib/Tactic/Linarith/Elimination.lean", "Mathlib/Data/Buffer/Parser/Numeral.lean", "Mathlib/Control/Traversable/Basic.lean", "Mathlib/Data/Num/Basic.lean", "Mathlib/Tactic/Substs.lean", "Mathlib/Order/Category/PartOrd.lean", "Mathlib/Data/Complex/Determinant.lean", "Mathlib/Topology/Bases.lean", "Mathlib/Probability/Kernel/Disintegration.lean", "Mathlib/CategoryTheory/Bicategory/Functor.lean", "Mathlib/Data/Real/ConjugateExponents.lean", "Mathlib/AlgebraicTopology/DoldKan/Normalized.lean", "Mathlib/Topology/Algebra/InfiniteSum/Real.lean", "Mathlib/CategoryTheory/Limits/Constructions/FiniteProductsOfBinaryProducts.lean", "Mathlib/Data/List/Palindrome.lean", "Mathlib/Computability/Reduce.lean", "Mathlib/Analysis/LocallyConvex/ContinuousOfBounded.lean", "Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean", "Mathlib/AlgebraicTopology/DoldKan/Faces.lean", "Mathlib/Algebra/Lie/Engel.lean", "Mathlib/Data/List/Rotate.lean", "Mathlib/Topology/Category/TopCat/Limits/Konig.lean", "Mathlib/RingTheory/MvPolynomial/Ideal.lean", "Mathlib/CategoryTheory/Limits/Shapes/KernelPair.lean", "Mathlib/LinearAlgebra/Matrix/Block.lean", "Mathlib/LinearAlgebra/Matrix/SesquilinearForm.lean", "Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean", "Mathlib/Init/Propext.lean", "Mathlib/Topology/Instances/Matrix.lean", "Mathlib/CategoryTheory/Elementwise.lean", "Mathlib/Algebra/ContinuedFractions/TerminatedStable.lean", "Mathlib/Data/Set/Intervals/Monotone.lean", "Mathlib/GroupTheory/FreeGroup/Basic.lean", "Mathlib/Topology/ContinuousFunction/T0Sierpinski.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Biproducts.lean", "Mathlib/CategoryTheory/Sigma/Basic.lean", "Mathlib/Data/Rat/Basic.lean", "Mathlib/MeasureTheory/Function/AEMeasurableSequence.lean", "Mathlib/Probability/ProbabilityMassFunction/Basic.lean", "Mathlib/Tactic/ByContra.lean", "Mathlib/Algebra/Hom/Freiman.lean", "Mathlib/LinearAlgebra/AffineSpace/Basis.lean", "Mathlib/Analysis/Complex/LocallyUniformLimit.lean", "Mathlib/RingTheory/Noetherian.lean", "Mathlib/Tactic/Widget/Conv.lean", "Mathlib/LinearAlgebra/FreeAlgebra.lean", "Mathlib/CategoryTheory/Monoidal/Subcategory.lean", "Mathlib/CategoryTheory/Subobject/Limits.lean", "Mathlib/Algebra/Category/Ring/Adjunctions.lean", "Mathlib/AlgebraicGeometry/ProjectiveSpectrum/Scheme.lean", "Mathlib/Data/UnionFind.lean", "Mathlib/Algebra/GroupWithZero/Divisibility.lean", "Mathlib/Data/List/Lattice.lean", "Mathlib/Combinatorics/Composition.lean", "Mathlib/Algebra/Module/Basic.lean", "Mathlib/AlgebraicTopology/DoldKan/NCompGamma.lean", "Mathlib/LinearAlgebra/FreeModule/PID.lean", "Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean", "Mathlib/Data/Set/Intervals/Monoid.lean", "Mathlib/Combinatorics/SimpleGraph/Clique.lean", "Mathlib/CategoryTheory/EqToHom.lean", "Mathlib/LinearAlgebra/Matrix/SchurComplement.lean", "Mathlib/Topology/UrysohnsBounded.lean", "Mathlib/LinearAlgebra/TensorProduct/Matrix.lean", "Mathlib/FieldTheory/Normal.lean", "Mathlib/AlgebraicGeometry/EllipticCurve/Weierstrass.lean", "Mathlib/Data/Polynomial/Lifts.lean", "Mathlib/LinearAlgebra/LinearIndependent.lean", "Mathlib/NumberTheory/ModularForms/JacobiTheta/Manifold.lean", "Mathlib/GroupTheory/Coprod/Basic.lean", "Mathlib/CategoryTheory/Adjunction/Limits.lean", "Mathlib/Logic/Nontrivial/Basic.lean", "Mathlib/Data/Finset/Pointwise.lean", "Mathlib/LinearAlgebra/Matrix/Spectrum.lean", "Mathlib/Algebra/Homology/ShortComplex/Abelian.lean", "Mathlib/Analysis/Calculus/Deriv/Polynomial.lean", "Mathlib/Order/Filter/Cofinite.lean", "Mathlib/AlgebraicTopology/CechNerve.lean", "Mathlib/Algebra/Algebra/Basic.lean", "Mathlib/Data/Nat/Squarefree.lean", "Mathlib/GroupTheory/Subsemigroup/Membership.lean", "Mathlib/Tactic/NormNum.lean", "Mathlib/Order/Lattice.lean", "Mathlib/Data/Multiset/Dedup.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "Mathlib/Data/PFunctor/Multivariate/M.lean", "Mathlib/RingTheory/Polynomial/Eisenstein/Basic.lean", "Mathlib/LinearAlgebra/Orientation.lean", "Mathlib/Geometry/Manifold/Sheaf/Smooth.lean", "Mathlib/CategoryTheory/Closed/Monoidal.lean", "Mathlib/Probability/Kernel/Basic.lean", "Mathlib/Algebra/Category/GroupCat/FilteredColimits.lean", "Mathlib/Order/RelIso/Group.lean", "Mathlib/Geometry/Manifold/ContMDiff.lean", "Mathlib/AlgebraicGeometry/Limits.lean", "Mathlib/Analysis/NormedSpace/BoundedLinearMaps.lean", "Mathlib/Order/Category/FinBoolAlg.lean", "Mathlib/CategoryTheory/Monoidal/Transport.lean", "Mathlib/Algebra/Group/WithOne/Defs.lean", "Mathlib/ModelTheory/Fraisse.lean", "Mathlib/Init/Data/Int/CompLemmas.lean", "Mathlib/Analysis/SpecialFunctions/Complex/LogDeriv.lean", "Mathlib/Topology/ContinuousFunction/CocompactMap.lean", "Mathlib/Algebra/CharP/Basic.lean", "Mathlib/Algebra/Lie/NonUnitalNonAssocAlgebra.lean", "Mathlib/Data/Nat/Choose/Dvd.lean", "Mathlib/AlgebraicGeometry/EllipticCurve/Point.lean", "Mathlib/Topology/Order/Category/FrameAdjunction.lean", "Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean", "Mathlib/CategoryTheory/Preadditive/Opposite.lean", "Mathlib/GroupTheory/GroupAction/Units.lean", "Mathlib/Analysis/NormedSpace/LpEquiv.lean", "Mathlib/Analysis/Convex/Radon.lean", "Mathlib/Data/Finset/Fin.lean", "Mathlib/Algebra/Group/Units.lean", "Mathlib/AlgebraicGeometry/ProjectiveSpectrum/Topology.lean", "Mathlib/Order/Copy.lean", "Mathlib/Tactic/Replace.lean", "Mathlib/SetTheory/Lists.lean", "Mathlib/Init/Data/Subtype/Basic.lean", "Mathlib/RingTheory/PowerBasis.lean", "Mathlib/Topology/Algebra/Module/StrongTopology.lean", "Mathlib/RingTheory/Prime.lean", "Mathlib/Algebra/Star/Free.lean", "Mathlib/MeasureTheory/Function/SimpleFuncDenseLp.lean", "Mathlib/Control/EquivFunctor.lean", "Mathlib/Algebra/Module/Equiv.lean", "Mathlib/NumberTheory/FunctionField.lean", "Mathlib/Data/FP/Basic.lean", "Mathlib/Data/Finsupp/Order.lean", "Mathlib/Tactic/FinCases.lean", "Mathlib/Topology/Order/Priestley.lean", "Mathlib/RingTheory/Adjoin/PowerBasis.lean", "Mathlib/Analysis/Complex/Isometry.lean", "Mathlib/Data/Finite/Defs.lean", "Mathlib/Tactic/FBinop.lean", "Mathlib/Analysis/Subadditive.lean", "Mathlib/Analysis/Calculus/ParametricIntervalIntegral.lean", "Mathlib/RingTheory/PrincipalIdealDomain.lean", "Mathlib/Algebra/Group/Conj.lean", "Mathlib/NumberTheory/Basic.lean", "Mathlib/Init/Data/Fin/Basic.lean", "Mathlib/LinearAlgebra/QuadraticForm/Complex.lean", "Mathlib/RingTheory/Ideal/Norm.lean", "Mathlib/CategoryTheory/Limits/Shapes/Equivalence.lean", "Mathlib/Algebra/Order/Monoid/Basic.lean", "Mathlib/CategoryTheory/Limits/Preserves/Finite.lean", "Mathlib/Data/Nat/Cast/Prod.lean", "Mathlib/Analysis/Calculus/BumpFunction/FiniteDimension.lean", "Mathlib/CategoryTheory/Monoidal/Types/Symmetric.lean", "Mathlib/Algebra/Order/Positive/Ring.lean", "Mathlib/Analysis/InnerProductSpace/Positive.lean", "Mathlib/CategoryTheory/Limits/Preserves/Filtered.lean", "Mathlib/Data/Finsupp/Basic.lean", "Mathlib/Data/Bitvec/Lemmas.lean", "Mathlib/Data/Num/Prime.lean", "Mathlib/Topology/Algebra/Constructions.lean", "Mathlib/Topology/MetricSpace/Kuratowski.lean", "Mathlib/CategoryTheory/Functor/Currying.lean", "Mathlib/Algebra/Order/Monoid/Cancel/Basic.lean", "Mathlib/Data/Prod/Basic.lean", "Mathlib/NumberTheory/Primorial.lean", "Mathlib/Tactic/FieldSimp.lean", "Mathlib/Algebra/BigOperators/Fin.lean", "Mathlib/CategoryTheory/Sites/Pretopology.lean", "Mathlib/Algebra/Homology/Homology.lean", "Mathlib/Data/Polynomial/Laurent.lean", "Mathlib/Tactic/Positivity/Basic.lean", "Mathlib/Data/Vector/Basic.lean", "Mathlib/Order/Category/Semilat.lean", "Mathlib/Analysis/Calculus/Deriv/AffineMap.lean", "Mathlib/Data/Multiset/Lattice.lean", "Mathlib/Combinatorics/Quiver/Push.lean", "Mathlib/Algebra/Polynomial/BigOperators.lean", "Mathlib/CategoryTheory/Limits/Shapes/StrictInitial.lean", "Mathlib/Combinatorics/SimpleGraph/Basic.lean", "Mathlib/Data/PNat/Factors.lean", "Mathlib/Data/Real/CauSeq.lean", "Mathlib/LinearAlgebra/Matrix/MvPolynomial.lean", "Mathlib/CategoryTheory/Monoidal/NaturalTransformation.lean", "Mathlib/Order/Category/LinOrd.lean", "Mathlib/GroupTheory/GroupAction/Sum.lean", "Mathlib/Data/Finset/Powerset.lean", "Mathlib/RingTheory/Algebraic.lean", "Mathlib/Data/Buffer/Parser/Basic.lean", "Mathlib/CategoryTheory/Monad/Products.lean", "Mathlib/Combinatorics/SimpleGraph/IncMatrix.lean", "Mathlib/MeasureTheory/Integral/IntervalAverage.lean", "Mathlib/NumberTheory/ClassNumber/FunctionField.lean", "Mathlib/NumberTheory/ModularForms/CongruenceSubgroups.lean", "Mathlib/Algebra/Ring/Divisibility/Basic.lean", "Mathlib/RingTheory/Kaehler.lean", "Mathlib/Algebra/QuaternionBasis.lean", "Mathlib/LinearAlgebra/Matrix/Gershgorin.lean", "Mathlib/Topology/Algebra/Order/MonotoneConvergence.lean", "Mathlib/Algebra/Category/ModuleCat/Presheaf.lean", "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "Mathlib/Combinatorics/SimpleGraph/Partition.lean", "Mathlib/Logic/Function/Basic.lean", "Mathlib/Analysis/Calculus/MeanValue.lean", "Mathlib/GroupTheory/Submonoid/ZeroDivisors.lean", "Mathlib/Order/Interval.lean", "Mathlib/Algebra/ContinuedFractions/Translations.lean", "Mathlib/GroupTheory/Subsemigroup/Basic.lean", "Mathlib/NumberTheory/ModularForms/SlashActions.lean", "Mathlib/Topology/Separation/NotNormal.lean", "Mathlib/Data/Finset/Finsupp.lean", "Mathlib/Algebra/Lie/Weights/Basic.lean", "Mathlib/Data/Nat/Periodic.lean", "Mathlib/GroupTheory/Subgroup/MulOpposite.lean", "Mathlib/MeasureTheory/Integral/MeanInequalities.lean", "Mathlib/Algebra/Module/LinearMap.lean", "Mathlib/Order/CompletePartialOrder.lean", "Mathlib/RingTheory/Polynomial/Basic.lean", "Mathlib/Algebra/Support.lean", "Mathlib/CategoryTheory/Category/Bipointed.lean", "Mathlib/Data/Real/CauSeqCompletion.lean", "Mathlib/Data/Nat/Choose/Basic.lean", "Mathlib/RingTheory/Coprime/Ideal.lean", "Mathlib/Analysis/Calculus/FDeriv/Add.lean", "Mathlib/Analysis/ConstantSpeed.lean", "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "Mathlib/Algebra/Module/Pi.lean", "Mathlib/Topology/Algebra/Order/MonotoneContinuity.lean", "Mathlib/LinearAlgebra/AffineSpace/Pointwise.lean", "Mathlib/Order/BooleanAlgebra.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Zero.lean", "Mathlib/MeasureTheory/Function/StronglyMeasurable/Inner.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/Series.lean", "Mathlib/Analysis/Calculus/Deriv/Star.lean", "Mathlib/Tactic/Ring/RingNF.lean", "Mathlib/LinearAlgebra/AffineSpace/Slope.lean", "Mathlib/CategoryTheory/ConcreteCategory/ReflectsIso.lean", "Mathlib/Dynamics/BirkhoffSum/NormedSpace.lean", "Mathlib/GroupTheory/GroupAction/Prod.lean", "Mathlib/CategoryTheory/Limits/Constructions/Over/Basic.lean", "Mathlib/LinearAlgebra/BilinearMap.lean", "Mathlib/Tactic/Clean.lean", "Mathlib/Tactic/RenameBVar.lean", "Mathlib/Topology/Algebra/InfiniteSum/Ring.lean", "Mathlib/Topology/VectorBundle/Hom.lean", "Mathlib/CategoryTheory/MorphismProperty.lean", "Mathlib/Data/Real/Pi/Wallis.lean", "Mathlib/LinearAlgebra/Determinant.lean", "Mathlib/LinearAlgebra/DFinsupp.lean", "Mathlib/GroupTheory/Subsemigroup/Centralizer.lean", "Mathlib/SetTheory/Game/Ordinal.lean", "Mathlib/Data/KVMap.lean", "Mathlib/ModelTheory/Quotients.lean", "Mathlib/Topology/Instances/Irrational.lean", "Mathlib/Algebra/Order/Hom/Ring.lean", "Mathlib/RingTheory/Subring/Basic.lean", "Mathlib/Algebra/Hom/Group/Defs.lean", "Mathlib/CategoryTheory/Limits/Shapes/Products.lean", "Mathlib/RingTheory/IsAdjoinRoot.lean", "Mathlib/Algebra/Homology/ShortExact/Preadditive.lean", "Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean", "Mathlib/LinearAlgebra/TensorProductBasis.lean", "Mathlib/Data/Fintype/Quotient.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Equalizers.lean", "Mathlib/Analysis/Asymptotics/SuperpolynomialDecay.lean", "Mathlib/FieldTheory/IsAlgClosed/Basic.lean", "Mathlib/RingTheory/Valuation/Integers.lean", "Mathlib/Analysis/NormedSpace/HahnBanach/Extension.lean", "Mathlib/CategoryTheory/CommSq.lean", "Mathlib/CategoryTheory/Elements.lean", "Mathlib/CategoryTheory/Monoidal/CoherenceLemmas.lean", "Mathlib/Control/ULift.lean", "Mathlib/Analysis/Fourier/PoissonSummation.lean", "Mathlib/Order/Disjointed.lean", "Mathlib/Data/Nat/Cast/Synonym.lean", "Mathlib/Algebra/Group/Semiconj/Units.lean", "Mathlib/Util/Syntax.lean", "Mathlib/CategoryTheory/Preadditive/OfBiproducts.lean", "Mathlib/Order/SuccPred/Limit.lean", "Mathlib/Algebra/Category/Ring/Basic.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/Complex.lean", "Mathlib/AlgebraicTopology/DoldKan/Homotopies.lean", "Mathlib/CategoryTheory/Linear/Yoneda.lean", "Mathlib/Analysis/Convolution.lean", "Mathlib/CategoryTheory/Limits/Shapes/NormalMono/Basic.lean", "Mathlib/Analysis/Seminorm.lean", "Mathlib/Analysis/SpecificLimits/Normed.lean", "Mathlib/Data/Option/NAry.lean", "Mathlib/Probability/ProbabilityMassFunction/Integrals.lean", "Mathlib/Order/Estimator.lean", "Mathlib/ModelTheory/Algebra/Ring/Basic.lean", "Mathlib/Algebra/Lie/OfAssociative.lean", "Mathlib/Analysis/Calculus/FDeriv/Linear.lean", "Mathlib/Data/Fin/Basic.lean", "Mathlib/Algebra/Ring/CompTypeclasses.lean", "Mathlib/LinearAlgebra/PID.lean", "Mathlib/AlgebraicGeometry/Morphisms/QuasiSeparated.lean", "Mathlib/Analysis/NormedSpace/PiLp.lean", "Mathlib/CategoryTheory/Limits/ConcreteCategory.lean", "Mathlib/Data/DFinsupp/Multiset.lean", "Mathlib/Tactic/Monotonicity/Basic.lean", "Mathlib/RingTheory/Polynomial/Dickson.lean", "Mathlib/GroupTheory/Archimedean.lean", "Mathlib/CategoryTheory/Sites/CompatibleSheafification.lean", "Mathlib/Data/Nat/Factorial/Basic.lean", "Mathlib/Analysis/Calculus/FDeriv/Extend.lean", "Mathlib/Algebra/Homology/ShortComplex/Preadditive.lean", "Mathlib/Data/Matrix/Basis.lean", "Mathlib/Lean/Meta.lean", "Mathlib/MeasureTheory/Integral/Periodic.lean", "Mathlib/RingTheory/Adjoin/Field.lean", "Mathlib/SetTheory/Ordinal/Topology.lean", "Mathlib/Algebra/Polynomial/GroupRingAction.lean", "Mathlib/CategoryTheory/Closed/Types.lean", "Mathlib/Geometry/Euclidean/Sphere/Basic.lean", "Mathlib/Order/Category/NonemptyFinLinOrd.lean", "Mathlib/RingTheory/Polynomial/Vieta.lean", "Mathlib/Algebra/Category/ModuleCat/Biproducts.lean", "Mathlib/CategoryTheory/Limits/Unit.lean", "Mathlib/Order/Category/CompleteLat.lean", "Mathlib/Topology/Homotopy/HomotopyGroup.lean", "Mathlib/Algebra/Category/ModuleCat/Subobject.lean", "Mathlib/Geometry/Euclidean/Sphere/SecondInter.lean", "Mathlib/Data/Sym/Sym2.lean", "Mathlib/Data/Pi/Algebra.lean", "Mathlib/Computability/ContextFreeGrammar.lean", "Mathlib/Topology/Order/Lattice.lean", "Mathlib/Data/Nat/Choose/Central.lean", "Mathlib/Analysis/Calculus/Conformal/InnerProduct.lean", "Mathlib/Data/Rbmap/Default.lean", "Mathlib/GroupTheory/Submonoid/Operations.lean", "Mathlib/CategoryTheory/Limits/MonoCoprod.lean", "Mathlib/Tactic/Widget/SelectInsertParamsClass.lean", "Mathlib/CategoryTheory/Category/Preorder.lean", "Mathlib/Tactic/Lint.lean", "Mathlib/Tactic/SwapVar.lean", "Mathlib/MeasureTheory/Measure/OuterMeasure.lean", "Mathlib/Algebra/Homology/QuasiIso.lean", "Mathlib/Algebra/BigOperators/Multiset/Lemmas.lean", "Mathlib/SetTheory/Ordinal/FixedPoint.lean", "Mathlib/Logic/Encodable/Basic.lean", "Mathlib/Tactic/GeneralizeProofs.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/Chebyshev.lean", "Mathlib/CategoryTheory/DiscreteCategory.lean", "Mathlib/MeasureTheory/Function/SpecialFunctions/Inner.lean", "Mathlib/Algebra/Exact.lean", "Mathlib/Tactic/Linarith/Datatypes.lean", "Mathlib/Topology/Algebra/InfiniteSum/Order.lean", "Mathlib/Combinatorics/Additive/SalemSpencer.lean", "Mathlib/NumberTheory/NumberField/Basic.lean", "Mathlib/MeasureTheory/Function/Floor.lean", "Mathlib/AlgebraicGeometry/Morphisms/Basic.lean", "Mathlib/CategoryTheory/Pi/Basic.lean", "Mathlib/Order/WithBot.lean", "Mathlib/RingTheory/RootsOfUnity/Basic.lean", "Mathlib/CategoryTheory/Monad/Monadicity.lean", "Mathlib/Tactic/Monotonicity.lean", "Mathlib/LinearAlgebra/FreeModule/Rank.lean", "Mathlib/Topology/ContinuousFunction/StoneWeierstrass.lean", "Mathlib/Data/Finset/Sum.lean", "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "Mathlib/Order/Filter/IndicatorFunction.lean", "Mathlib/Topology/MetricSpace/Infsep.lean", "Mathlib/Data/Rbtree/Basic.lean", "Mathlib/Tactic/Monotonicity/Lemmas.lean", "Mathlib/Tactic/NormCast.lean", "Mathlib/RingTheory/Localization/Integral.lean", "Mathlib/Topology/Sheaves/SheafOfFunctions.lean", "Mathlib/Data/Nat/Set.lean", "Mathlib/Analysis/InnerProductSpace/Rayleigh.lean", "Mathlib/Data/Finsupp/Pointwise.lean", "Mathlib/Algebra/Category/ModuleCat/ChangeOfRings.lean", "Mathlib/Data/Set/MulAntidiagonal.lean", "Mathlib/Algebra/Order/WithZero.lean", "Mathlib/CategoryTheory/Preadditive/EndoFunctor.lean", "Mathlib/Data/Multiset/Fintype.lean", "Mathlib/Data/Rbtree/Init.lean", "Mathlib/SetTheory/Game/Birthday.lean", "Mathlib/Tactic/PPWithUniv.lean", "Mathlib/Algebra/Lie/TensorProduct.lean", "Mathlib/Algebra/Group/WithOne/Units.lean", "Mathlib/Analysis/NormedSpace/Extend.lean", "Mathlib/Algebra/Order/Monoid/Cancel/Defs.lean", "Mathlib/MeasureTheory/Constructions/Prod/Integral.lean", "Mathlib/NumberTheory/FermatPsp.lean", "Mathlib/Tactic/HelpCmd.lean", "Mathlib/Data/MvPolynomial/Derivation.lean", "Mathlib/Order/UpperLower/Basic.lean", "Mathlib/Deprecated/Subring.lean", "Mathlib/CategoryTheory/Limits/Shapes/ZeroObjects.lean", "Mathlib/CategoryTheory/Adjunction/Basic.lean", "Mathlib/RingTheory/Ideal/LocalRing.lean", "Mathlib/Algebra/Order/Group/Units.lean", "Mathlib/CategoryTheory/Monoidal/Category.lean", "Mathlib/CategoryTheory/Idempotents/Karoubi.lean", "Mathlib/Algebra/Homology/ShortComplex/QuasiIso.lean", "Mathlib/MeasureTheory/Measure/VectorMeasure.lean", "Mathlib/NumberTheory/LegendreSymbol/AddCharacter.lean", "Mathlib/Probability/Martingale/OptionalStopping.lean", "Mathlib/Tactic/NormNum/Ineq.lean", "Mathlib/Topology/UniformSpace/Pi.lean", "Mathlib/Analysis/SpecialFunctions/NonIntegrable.lean", "Mathlib/Topology/Category/CompHaus/Basic.lean", "Mathlib/Tactic/HigherOrder.lean", "Mathlib/Tactic/SimpIntro.lean", "Mathlib/Algebra/Expr.lean", "Mathlib/Topology/Algebra/Valuation.lean", "Mathlib/Order/BoundedOrder.lean", "Mathlib/Order/Filter/Partial.lean", "Mathlib/Algebra/Order/Sub/Prod.lean", "Mathlib/Topology/MetricSpace/GromovHausdorffRealized.lean", "Mathlib/Data/Set/Countable.lean", "Mathlib/Tactic/Widget/Gcongr.lean", "Mathlib/Data/Sigma/Lex.lean", "Mathlib/LinearAlgebra/QuadraticForm/Basic.lean", "Mathlib/Analysis/Calculus/ContDiffDef.lean", "Mathlib/Tactic/Find.lean", "Mathlib/CategoryTheory/Abelian/Images.lean", "Mathlib/Data/Set/Intervals/Instances.lean", "Mathlib/Geometry/Euclidean/PerpBisector.lean", "Mathlib/Algebra/Lie/CartanMatrix.lean", "Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean", "Mathlib/Topology/UniformSpace/CompactConvergence.lean", "Mathlib/Algebra/Order/Field/Pi.lean", "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "Mathlib/GroupTheory/ClassEquation.lean", "Mathlib/MeasureTheory/Measure/Doubling.lean", "Mathlib/Algebra/BigOperators/Order.lean", "Mathlib/Algebra/Lie/Killing.lean", "Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "Mathlib/Topology/ProperMap.lean", "Mathlib/Data/Nat/Bitwise.lean", "Mathlib/Tactic/NormNum/Prime.lean", "Mathlib/Analysis/NormedSpace/Algebra.lean", "Mathlib/Order/Filter/Basic.lean", "Mathlib/Order/SymmDiff.lean", "Mathlib/Tactic/Clear_.lean", "Mathlib/Topology/PartitionOfUnity.lean", "Mathlib/Data/Sigma/Interval.lean", "Mathlib/RepresentationTheory/Maschke.lean", "Mathlib/Algebra/Category/ModuleCat/Projective.lean", "Mathlib/MeasureTheory/Integral/Average.lean", "Mathlib/MeasureTheory/Function/ConditionalExpectation/CondexpL1.lean", "Mathlib/Topology/UniformSpace/AbstractCompletion.lean", "Mathlib/CategoryTheory/FullSubcategory.lean", "Mathlib/Data/Int/Log.lean", "Mathlib/Data/Part.lean", "Mathlib/Algebra/Module/Submodule/Bilinear.lean", "Mathlib/CategoryTheory/Category/Quiv.lean", "Mathlib/RingTheory/Valuation/ExtendToLocalization.lean", "Mathlib/Analysis/NormedSpace/Star/Unitization.lean", "Mathlib/LinearAlgebra/ProjectiveSpace/Subspace.lean", "Mathlib/Order/Closure.lean", "Mathlib/LinearAlgebra/Matrix/Charpoly/Eigs.lean", "Mathlib/MeasureTheory/Measure/NullMeasurable.lean", "Mathlib/Topology/MetricSpace/HausdorffDimension.lean", "Mathlib/Algebra/Order/Module.lean", "Mathlib/Data/Fintype/Sigma.lean", "Mathlib/CategoryTheory/Adjunction/Over.lean", "Mathlib/Algebra/Category/Ring/FilteredColimits.lean", "Mathlib/Analysis/Normed/Group/Completion.lean", "Mathlib/Data/Fintype/Perm.lean", "Mathlib/MeasureTheory/Function/LpOrder.lean", "Mathlib/Order/OmegaCompletePartialOrder.lean", "Mathlib/Probability/Integration.lean", "Mathlib/Logic/Equiv/Defs.lean", "Mathlib/Topology/ContinuousFunction/Ordered.lean", "Mathlib/Data/Finset/Sort.lean", "Mathlib/Probability/Process/Filtration.lean", "Mathlib/Combinatorics/SimpleGraph/Init.lean", "Mathlib/Data/Polynomial/Derivative.lean", "Mathlib/Geometry/Euclidean/Angle/Oriented/RightAngle.lean", "Mathlib/LinearAlgebra/ProjectiveSpace/Independence.lean", "Mathlib/CategoryTheory/Preadditive/Mat.lean", "Mathlib/Algebra/Quandle.lean", "Mathlib/Data/Set/Sups.lean", "Mathlib/RingTheory/Localization/Module.lean", "Mathlib/Order/CompleteLatticeIntervals.lean", "Mathlib/CategoryTheory/Idempotents/KaroubiKaroubi.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Grading.lean", "Mathlib/CategoryTheory/Abelian/Ext.lean", "Mathlib/Data/Rbtree/Main.lean", "Mathlib/Order/Filter/ENNReal.lean", "Mathlib/SetTheory/Game/State.lean", "Mathlib/CategoryTheory/Limits/Shapes/WidePullbacks.lean", "Mathlib/Probability/Kernel/MeasurableIntegral.lean", "Mathlib/Topology/Sheaves/Sheafify.lean", "Mathlib/Algebra/Star/Order.lean", "Mathlib/Data/List/Card.lean", "Mathlib/Analysis/Calculus/LagrangeMultipliers.lean", "Mathlib/Computability/PartrecCode.lean", "Mathlib/CategoryTheory/Limits/Over.lean", "Mathlib/Data/HashMap.lean", "Mathlib/SetTheory/Game/Impartial.lean", "Mathlib/Lean/CoreM.lean", "Mathlib/Algebra/Divisibility/Units.lean", "Mathlib/Combinatorics/SetFamily/Compression/UV.lean", "Mathlib/Data/Polynomial/RingDivision.lean", "Mathlib/Analysis/Complex/RemovableSingularity.lean", "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "Mathlib/Topology/ExtremallyDisconnected.lean", "Mathlib/Topology/MetricSpace/MetrizableUniformity.lean", "Mathlib/Analysis/NormedSpace/Star/Exponential.lean", "Mathlib/RingTheory/DedekindDomain/PID.lean", "Mathlib/Analysis/NormedSpace/AddTorsorBases.lean", "Mathlib/Analysis/NormedSpace/WithLp.lean", "Mathlib/Data/Finite/Set.lean", "Mathlib/Logic/Pairwise.lean", "Mathlib/Geometry/RingedSpace/LocallyRingedSpace.lean", "Mathlib/Tactic/NormNum/Result.lean", "Mathlib/Control/ULiftable.lean", "Mathlib/Algebra/Ring/MinimalAxioms.lean", "Mathlib/RingTheory/Ideal/Prod.lean", "Mathlib/Algebra/Ring/Semiconj.lean", "Mathlib/Topology/MetricSpace/DilationEquiv.lean", "Mathlib/CategoryTheory/CofilteredSystem.lean", "Mathlib/MeasureTheory/Function/ConditionalExpectation/CondexpL2.lean", "Mathlib/AlgebraicTopology/DoldKan/EquivalenceAdditive.lean", "Mathlib/RingTheory/Ideal/Operations.lean", "Mathlib/Analysis/NormedSpace/Int.lean", "Mathlib/CategoryTheory/ConcreteCategory/UnbundledHom.lean", "Mathlib/Data/MLList/Dedup.lean", "Mathlib/Order/Category/Preord.lean", "Mathlib/LinearAlgebra/FreeModule/Determinant.lean", "Mathlib/LinearAlgebra/FiniteDimensional.lean", "Mathlib/Order/Monotone/Basic.lean", "Mathlib/GroupTheory/DoubleCoset.lean", "Mathlib/Combinatorics/SimpleGraph/StronglyRegular.lean", "Mathlib/CategoryTheory/Idempotents/HomologicalComplex.lean", "Mathlib/CategoryTheory/Preadditive/Schur.lean", "Mathlib/Data/Bool/Set.lean", "Mathlib/Logic/UnivLE.lean", "Mathlib/RingTheory/Coprime/Basic.lean", "Mathlib/Topology/Algebra/UniformConvergence.lean", "Mathlib/CategoryTheory/Preadditive/LeftExact.lean", "Mathlib/Algebra/Category/ModuleCat/Algebra.lean", "Mathlib/FieldTheory/Fixed.lean", "Mathlib/Data/Rat/Order.lean", "Mathlib/Init/Data/Int/Bitwise.lean", "Mathlib/Data/Set/Intervals/Infinite.lean", "Mathlib/Data/Polynomial/Reverse.lean", "Mathlib/RingTheory/Henselian.lean", "Mathlib/Algebra/Order/UpperLower.lean", "Mathlib/FieldTheory/NormalClosure.lean", "Mathlib/Dynamics/Ergodic/Conservative.lean", "Mathlib/Init/Data/Nat/Notation.lean", "Mathlib/Algebra/Order/Monoid/TypeTags.lean", "Mathlib/Algebra/MonoidAlgebra/Division.lean", "Mathlib/Data/Set/Finite.lean", "Mathlib/Algebra/GradedMulAction.lean", "Mathlib/Topology/Compactness/Compact.lean", "Mathlib/CategoryTheory/Limits/Shapes/DisjointCoproduct.lean", "Mathlib/FieldTheory/IsSepClosed.lean", "Mathlib/CategoryTheory/Limits/HasLimits.lean", "Mathlib/RingTheory/Valuation/Quotient.lean", "Mathlib/Topology/Basic.lean", "Mathlib/Data/Nat/Count.lean", "Mathlib/Geometry/RingedSpace/Stalks.lean", "Mathlib/Lean/Expr/Basic.lean", "Mathlib/Probability/Independence/Basic.lean", "Mathlib/CategoryTheory/Adjunction/AdjointFunctorTheorems.lean", "Mathlib/Data/Sym/Card.lean", "Mathlib/NumberTheory/ModularForms/SlashInvariantForms.lean", "Mathlib/Algebra/Module/Opposites.lean", "Mathlib/ModelTheory/Algebra/Field/CharP.lean", "Mathlib/Algebra/Category/ModuleCat/Tannaka.lean", "Mathlib/Data/Opposite.lean", "Mathlib/SetTheory/Surreal/Basic.lean", "Mathlib/Topology/MetricSpace/Dilation.lean", "Mathlib/NumberTheory/ZetaValues.lean", "Mathlib/Algebra/Lie/UniversalEnveloping.lean", "Mathlib/MeasureTheory/Integral/LebesgueNormedSpace.lean", "Mathlib/Data/Finset/Order.lean", "Mathlib/Tactic/Linarith/Verification.lean", "Mathlib/Data/Bitvec/Defs.lean", "Mathlib/Data/Rat/Floor.lean", "Mathlib/Data/Finset/Basic.lean", "Mathlib/Algebra/Group/Basic.lean", "Mathlib/MeasureTheory/Measure/FiniteMeasure.lean", "Mathlib/LinearAlgebra/Basis.lean", "Mathlib/Tactic/Explode.lean", "Mathlib/Init/Data/Option/Lemmas.lean", "Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean", "Mathlib/MeasureTheory/Group/LIntegral.lean", "Mathlib/Topology/Inseparable.lean", "Mathlib/Algebra/Star/Prod.lean", "Mathlib/RingTheory/Localization/Submodule.lean", "Mathlib/Tactic/ExtractLets.lean", "Mathlib/Data/Set/Intervals/SurjOn.lean", "Mathlib/FieldTheory/PolynomialGaloisGroup.lean", "Mathlib/Probability/Kernel/Condexp.lean", "Mathlib/NumberTheory/Wilson.lean", "Mathlib/MeasureTheory/Function/AEMeasurableOrder.lean", "Mathlib/Algebra/Regular/SMul.lean", "Mathlib/Combinatorics/SetFamily/LYM.lean", "Mathlib/MeasureTheory/Decomposition/UnsignedHahn.lean", "Mathlib/RingTheory/Coprime/Lemmas.lean", "Mathlib/CategoryTheory/Functor/ReflectsIso.lean", "Mathlib/LinearAlgebra/Basis/Bilinear.lean", "Mathlib/Analysis/NormedSpace/Unitization.lean", "Mathlib/Analysis/InnerProductSpace/OfNorm.lean", "Mathlib/Analysis/Calculus/BumpFunction/Basic.lean", "Mathlib/NumberTheory/Liouville/Residual.lean", "Mathlib/Init/Function.lean", "Mathlib/Combinatorics/SimpleGraph/Regularity/Energy.lean", "Mathlib/Algebra/Order/Sub/Defs.lean", "Mathlib/Analysis/Calculus/Deriv/ZPow.lean", "Mathlib/Order/Hom/CompleteLattice.lean", "Mathlib/LinearAlgebra/BilinearForm/TensorProduct.lean", "Mathlib/GroupTheory/GroupAction/SubMulAction/Pointwise.lean", "Mathlib/Geometry/Euclidean/Sphere/Power.lean", "Mathlib/MeasureTheory/Function/SimpleFuncDense.lean", "Mathlib/CategoryTheory/Limits/Constructions/Pullbacks.lean", "Mathlib/Topology/Order/LowerUpperTopology.lean", "Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean", "Mathlib/CategoryTheory/ConcreteCategory/Bundled.lean", "Mathlib/Tactic/Choose.lean", "Mathlib/Analysis/SpecificLimits/Basic.lean", "Mathlib/Lean/Data/NameMap.lean", "Mathlib/NumberTheory/Bertrand.lean", "Mathlib/Data/Nat/SuccPred.lean", "Mathlib/LinearAlgebra/Matrix/LDL.lean", "Mathlib/Logic/Encodable/Lattice.lean", "Mathlib/Data/Analysis/Filter.lean", "Mathlib/Logic/Equiv/Fin.lean", "Mathlib/Util/Time.lean", "Mathlib/Tactic/LibrarySearch.lean", "Mathlib/Order/Filter/Interval.lean", "Mathlib/Topology/IsLocallyHomeomorph.lean", "Mathlib/RepresentationTheory/Rep.lean", "Mathlib/Algebra/GroupWithZero/Basic.lean", "Mathlib/Util/Qq.lean", "Mathlib/AlgebraicTopology/ExtraDegeneracy.lean", "Mathlib/AlgebraicTopology/DoldKan/FunctorN.lean", "Mathlib/CategoryTheory/Shift/CommShift.lean", "Mathlib/Algebra/Category/AlgebraCat/Limits.lean", "Mathlib/LinearAlgebra/Matrix/FiniteDimensional.lean", "Mathlib/Topology/ContinuousFunction/Bounded.lean", "Mathlib/Data/List/Lemmas.lean", "Mathlib/Data/SetLike/Basic.lean", "Mathlib/CategoryTheory/NatTrans.lean", "Mathlib/Data/Finsupp/NeLocus.lean", "Mathlib/Analysis/Convex/StoneSeparation.lean", "Mathlib/Analysis/SpecialFunctions/Arsinh.lean", "Mathlib/Geometry/RingedSpace/OpenImmersion.lean", "Mathlib/Data/MvPolynomial/Funext.lean", "Mathlib/Analysis/Calculus/FDeriv/Comp.lean", "Mathlib/MeasureTheory/Function/ConditionalExpectation/Unique.lean", "Mathlib/Tactic/Constructor.lean", "Mathlib/Algebra/Order/LatticeGroup.lean", "Mathlib/MeasureTheory/Covering/BesicovitchVectorSpace.lean", "Mathlib/Analysis/Calculus/Deriv/Inv.lean", "Mathlib/GroupTheory/Perm/Cycle/Type.lean", "Mathlib/AlgebraicTopology/FundamentalGroupoid/SimplyConnected.lean", "Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean", "Mathlib/Analysis/Calculus/FDeriv/Bilinear.lean", "Mathlib/Algebra/Category/AlgebraCat/Basic.lean", "Mathlib/Analysis/LocallyConvex/AbsConvex.lean", "Mathlib/Topology/Maps.lean", "Mathlib/CategoryTheory/Monoidal/Bimod.lean", "Mathlib/Data/Fin/Tuple/Basic.lean", "Mathlib/Data/Polynomial/Monic.lean", "Mathlib/CategoryTheory/Monoidal/Mon_.lean", "Mathlib/CategoryTheory/Groupoid/FreeGroupoid.lean", "Mathlib/GroupTheory/Perm/Subgroup.lean", "Mathlib/LinearAlgebra/TensorAlgebra/Grading.lean", "Mathlib/Topology/Algebra/Module/Determinant.lean", "Mathlib/Testing/SlimCheck/Functions.lean", "Mathlib/Algebra/Homology/ComplexShape.lean", "Mathlib/CategoryTheory/Quotient.lean", "Mathlib/Probability/Process/Stopping.lean", "Mathlib/Tactic/Use.lean", "Mathlib/RingTheory/MvPolynomial/Tower.lean", "Mathlib/Algebra/Ring/Divisibility/Lemmas.lean", "Mathlib/Topology/Connected/LocallyConnected.lean", "Mathlib/Topology/ContinuousOn.lean", "Mathlib/GroupTheory/Complement.lean", "Mathlib/Algebra/Lie/Normalizer.lean", "Mathlib/Data/Int/Order/Basic.lean", "Mathlib/LinearAlgebra/CrossProduct.lean", "Mathlib/Tactic/ClearExcept.lean", "Mathlib/Topology/CountableSeparatingOn.lean", "Mathlib/Topology/Instances/RealVectorSpace.lean", "Mathlib/AlgebraicTopology/DoldKan/EquivalencePseudoabelian.lean", "Mathlib/RingTheory/DiscreteValuationRing/Basic.lean", "Mathlib/Tactic/Linarith/Frontend.lean", "Mathlib/Testing/SlimCheck/Sampleable.lean", "Mathlib/Data/Erased.lean", "Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean", "Mathlib/Order/Category/BddDistLat.lean", "Mathlib/Algebra/Algebra/Bilinear.lean", "Mathlib/Algebra/Ring/BooleanRing.lean", "Mathlib/Topology/Sheaves/Forget.lean", "Mathlib/Analysis/Calculus/Deriv/Comp.lean", "Mathlib/Data/Nat/Hyperoperation.lean", "Mathlib/Data/Set/Pairwise/Basic.lean", "Mathlib/Data/Set/Image.lean", "Mathlib/Analysis/NormedSpace/ENorm.lean", "Mathlib/Deprecated/Submonoid.lean", "Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean", "Mathlib/Data/List/OfFn.lean", "Mathlib/MeasureTheory/Measure/MutuallySingular.lean", "Mathlib/Data/Sym/Basic.lean", "Mathlib/Topology/Algebra/Order/Floor.lean", "Mathlib/RingTheory/TensorProduct.lean", "Mathlib/GroupTheory/GroupAction/Defs.lean", "Mathlib/Order/Category/Frm.lean", "Mathlib/Topology/Category/CompHaus/Limits.lean", "Mathlib/RingTheory/Ideal/Cotangent.lean", "Mathlib/Data/Stream/Init.lean", "Mathlib/FieldTheory/SplittingField/IsSplittingField.lean", "Mathlib/Geometry/Manifold/PartitionOfUnity.lean", "Mathlib/Geometry/Manifold/Sheaf/Basic.lean", "Mathlib/CategoryTheory/Extensive.lean", "Mathlib/Data/Rat/Lemmas.lean", "Mathlib/NumberTheory/LegendreSymbol/ZModChar.lean", "Mathlib/Data/Set/Opposite.lean", "Mathlib/Analysis/Calculus/FDeriv/Analytic.lean", "Mathlib/Algebra/Category/GroupCat/Subobject.lean", "Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean", "Mathlib/Algebra/GroupPower/NegOnePow.lean", "Mathlib/Tactic/Convert.lean", "Mathlib/Data/Int/Range.lean", "Mathlib/LinearAlgebra/FreeModule/Finite/Rank.lean", "Mathlib/Control/EquivFunctor/Instances.lean", "Mathlib/GroupTheory/GroupAction/Opposite.lean", "Mathlib/Analysis/Calculus/Implicit.lean", "Mathlib/Analysis/Normed/Group/Pointwise.lean", "Mathlib/Analysis/NormedSpace/AddTorsor.lean", "Mathlib/Data/Int/ModEq.lean", "Mathlib/Data/Polynomial/Taylor.lean", "Mathlib/Topology/Algebra/Order/Group.lean", "Mathlib/Algebra/Hom/Centroid.lean", "Mathlib/Data/Multiset/Powerset.lean", "Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean", "Mathlib/CategoryTheory/Adjunction/Comma.lean", "Mathlib/Analysis/Complex/RealDeriv.lean", "Mathlib/Data/ZMod/Algebra.lean", "Mathlib/CategoryTheory/EpiMono.lean", "Mathlib/Data/Multiset/Interval.lean", "Mathlib/LinearAlgebra/ExteriorAlgebra/Grading.lean", "Mathlib/Data/Fintype/Sort.lean", "Mathlib/Combinatorics/Quiver/Covering.lean", "Mathlib/Data/Set/UnionLift.lean", "Mathlib/Probability/Process/Adapted.lean", "Mathlib/Algebra/GroupRingAction/Invariant.lean", "Mathlib/Computability/Halting.lean", "Mathlib/RingTheory/ChainOfDivisors.lean", "Mathlib/Util/IncludeStr.lean", "Mathlib/RingTheory/Int/Basic.lean", "Mathlib/Algebra/Category/GroupCat/Biproducts.lean", "Mathlib/Algebra/Order/Monoid/NatCast.lean", "Mathlib/Algebra/Order/Monoid/WithZero/Defs.lean", "Mathlib/Algebra/Order/Sub/Canonical.lean", "Mathlib/Data/Nat/Factorial/Cast.lean", "Mathlib/Dynamics/Ergodic/AddCircle.lean", "Mathlib/Init/Data/Ordering/Lemmas.lean", "Mathlib/Logic/Embedding/Basic.lean", "Mathlib/Algebra/MonoidAlgebra/Ideal.lean", "Mathlib/Topology/Category/Locale.lean", "Mathlib/Order/SupIndep.lean", "Mathlib/Analysis/InnerProductSpace/Orientation.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Terminal.lean", "Mathlib/Topology/Covering.lean", "Mathlib/Analysis/Convex/Strong.lean", "Mathlib/Data/Matrix/Reflection.lean", "Mathlib/Data/Int/Bitwise.lean", "Mathlib/Control/Monad/Cont.lean", "Mathlib/Data/Seq/Seq.lean", "Mathlib/Data/Num/Lemmas.lean", "Mathlib/Data/Real/Sqrt.lean", "Mathlib/Algebra/ContinuedFractions/Computation/Approximations.lean", "Mathlib/Data/Int/Dvd/Pow.lean", "Mathlib/Data/Int/Basic.lean", "Mathlib/Init/Align.lean", "Mathlib/Probability/Cdf.lean", "Mathlib/Init/Data/Int/DivMod.lean", "Mathlib/LinearAlgebra/QuadraticForm/IsometryEquiv.lean", "Mathlib/CategoryTheory/Sites/Spaces.lean", "Mathlib/Data/Matrix/Invertible.lean", "Mathlib/Algebra/Group/OrderSynonym.lean", "Mathlib/Order/Cover.lean", "Mathlib/Topology/Category/Stonean/Basic.lean", "Mathlib/Geometry/Manifold/VectorBundle/SmoothSection.lean", "Mathlib/Combinatorics/SetFamily/Shadow.lean", "Mathlib/NumberTheory/Cyclotomic/Gal.lean", "Mathlib/Combinatorics/Catalan.lean", "Mathlib/NumberTheory/Zsqrtd/QuadraticReciprocity.lean", "Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean", "Mathlib/Analysis/Convex/SimplicialComplex/Basic.lean", "Mathlib/Data/Polynomial/Degree/TrailingDegree.lean", "Mathlib/Algebra/Order/ZeroLEOne.lean", "Mathlib/Init/Data/Bool/Lemmas.lean", "Mathlib/Algebra/Lie/Matrix.lean", "Mathlib/Tactic/Attr/Core.lean", "Mathlib/Topology/ContinuousFunction/Algebra.lean", "Mathlib/GroupTheory/Submonoid/Centralizer.lean", "Mathlib/Algebra/Category/ModuleCat/Images.lean", "Mathlib/Analysis/Normed/Group/SemiNormedGroupCat.lean", "Mathlib/RepresentationTheory/GroupCohomology/Resolution.lean", "Mathlib/Analysis/InnerProductSpace/Adjoint.lean", "Mathlib/Topology/Perfect.lean", "Mathlib/Data/Polynomial/Mirror.lean", "Mathlib/NumberTheory/DirichletCharacter/Basic.lean", "Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean", "Mathlib/RingTheory/DiscreteValuationRing/TFAE.lean", "Mathlib/CategoryTheory/SingleObj.lean", "Mathlib/Data/Countable/Basic.lean", "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "Mathlib/GroupTheory/Subgroup/Actions.lean", "Mathlib/NumberTheory/ADEInequality.lean", "Mathlib/Analysis/Calculus/LineDeriv/Basic.lean", "Mathlib/Topology/MetricSpace/Closeds.lean", "Mathlib/Combinatorics/SimpleGraph/Density.lean", "Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean", "Mathlib/RingTheory/Polynomial/Selmer.lean", "Mathlib/Algebra/ContinuedFractions/ContinuantsRecurrence.lean", "Mathlib/MeasureTheory/MeasurableSpace/Invariants.lean", "Mathlib/Analysis/Convex/Strict.lean", "Mathlib/LinearAlgebra/Matrix/AbsoluteValue.lean", "Mathlib/RingTheory/RootsOfUnity/Complex.lean", "Mathlib/Algebra/Field/Opposite.lean", "Mathlib/Init/Data/Ordering/Basic.lean", "Mathlib/Topology/Algebra/Module/Alternating.lean", "Mathlib/Util/WithWeakNamespace.lean", "Mathlib/Order/Circular.lean", "Mathlib/NumberTheory/NumberField/ClassNumber.lean", "Mathlib/Algebra/Ring/Idempotents.lean", "Mathlib/Util/SleepHeartbeats.lean", "Mathlib/GroupTheory/Abelianization.lean", "Mathlib/Topology/Homotopy/Equiv.lean", "Mathlib/GroupTheory/QuotientGroup.lean", "Mathlib/Data/Sym/Sym2/Init.lean", "Mathlib/CategoryTheory/Monoidal/Skeleton.lean", "Mathlib/SetTheory/Ordinal/CantorNormalForm.lean", "Mathlib/CategoryTheory/Groupoid/Basic.lean", "Mathlib/Tactic/Contrapose.lean", "Mathlib/CategoryTheory/Limits/IsLimit.lean", "Mathlib/Data/Int/Cast/Basic.lean", "Mathlib/RingTheory/FinitePresentation.lean", "Mathlib/SetTheory/Cardinal/Ordinal.lean", "Mathlib/RingTheory/Polynomial/Content.lean", "Mathlib/Topology/Algebra/Field.lean", "Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean", "Mathlib/Data/List/Sort.lean", "Mathlib/CategoryTheory/Abelian/Injective.lean", "Mathlib/MeasureTheory/Measure/Portmanteau.lean", "Mathlib/Data/Nat/Cast/Defs.lean", "Mathlib/Computability/TMToPartrec.lean", "Mathlib/Topology/Algebra/Module/Multilinear.lean", "Mathlib/Topology/MetricSpace/Polish.lean", "Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean", "Mathlib/CategoryTheory/IsomorphismClasses.lean", "Mathlib/CategoryTheory/Abelian/Subobject.lean", "Mathlib/CategoryTheory/Preadditive/Yoneda/Limits.lean", "Mathlib/Analysis/Calculus/DiffContOnCl.lean", "Mathlib/Geometry/Manifold/Complex.lean", "Mathlib/Tactic/Widget/Congrm.lean", "Mathlib/Data/UInt.lean", "Mathlib/Data/Prod/TProd.lean", "Mathlib/Analysis/Calculus/TangentCone.lean", "Mathlib/Probability/Martingale/Centering.lean", "Mathlib/Data/PFunctor/Univariate/M.lean", "Mathlib/Data/Array/Defs.lean", "Mathlib/Control/Bifunctor.lean", "Mathlib/RingTheory/Polynomial/Chebyshev.lean", "Mathlib/CategoryTheory/Limits/Final.lean", "Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean", "Mathlib/Data/List/BigOperators/Lemmas.lean", "Mathlib/MeasureTheory/Function/AEEqFun.lean", "Mathlib/Tactic/NormNum/GCD.lean", "Mathlib/RingTheory/WittVector/MulP.lean", "Mathlib/Analysis/Convex/Hull.lean", "Mathlib/Algebra/GCDMonoid/IntegrallyClosed.lean", "Mathlib/RingTheory/Artinian.lean", "Mathlib/GroupTheory/Subgroup/Saturated.lean", "Mathlib/RingTheory/Nakayama.lean", "Mathlib/Tactic/Cases.lean", "Mathlib/CategoryTheory/Idempotents/SimplicialObject.lean", "Mathlib/ModelTheory/Algebra/Ring/FreeCommRing.lean", "Mathlib/GroupTheory/Schreier.lean", "Mathlib/NumberTheory/Liouville/Basic.lean", "Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean", "Mathlib/NumberTheory/Padics/PadicIntegers.lean", "Mathlib/Data/Fin/Fin2.lean", "Mathlib/LinearAlgebra/QuadraticForm/Dual.lean", "Mathlib/CategoryTheory/Sites/EffectiveEpimorphic.lean", "Mathlib/Data/Real/Irrational.lean", "Mathlib/Order/Bounded.lean", "Mathlib/FieldTheory/SeparableDegree.lean", "Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "Mathlib/Combinatorics/Quiver/Symmetric.lean", "Mathlib/Init/Data/Int/Basic.lean", "Mathlib/LinearAlgebra/Matrix/Symmetric.lean", "Mathlib/ModelTheory/Definability.lean", "Mathlib/Probability/CondCount.lean", "Mathlib/Topology/NoetherianSpace.lean", "Mathlib/Data/MvPolynomial/Monad.lean", "Mathlib/Analysis/Calculus/Deriv/Support.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/BinaryProducts.lean", "Mathlib/Order/OrderIsoNat.lean", "Mathlib/SetTheory/Cardinal/CountableCover.lean", "Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean", "Mathlib/Analysis/Convex/Basic.lean", "Mathlib/Data/Nat/Fib/Zeckendorf.lean", "Mathlib/Analysis/NormedSpace/BanachSteinhaus.lean", "Mathlib/SetTheory/Ordinal/Notation.lean", "Mathlib/Algebra/Module/Bimodule.lean", "Mathlib/Analysis/NormedSpace/HahnBanach/Separation.lean", "Mathlib/Algebra/Homology/Flip.lean", "Mathlib/CategoryTheory/Category/ULift.lean", "Mathlib/Algebra/Algebra/RestrictScalars.lean", "Mathlib/GroupTheory/Perm/Basic.lean", "Mathlib/SetTheory/Cardinal/Finite.lean", "Mathlib/Combinatorics/SimpleGraph/Finsubgraph.lean", "Mathlib/CategoryTheory/Abelian/Basic.lean", "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "Mathlib/CategoryTheory/Limits/KanExtension.lean", "Mathlib/ModelTheory/Skolem.lean", "Mathlib/CategoryTheory/Bicategory/End.lean", "Mathlib/Analysis/Calculus/BumpFunction/Convolution.lean", "Mathlib/Algebra/Algebra/Subalgebra/Unitization.lean", "Mathlib/LinearAlgebra/Coevaluation.lean", "Mathlib/Topology/Order/Hom/Esakia.lean", "Mathlib/Data/Int/SuccPred.lean", "Mathlib/Analysis/Normed/Group/Basic.lean", "Mathlib/Algebra/GCDMonoid/Basic.lean", "Mathlib/Deprecated/Group.lean", "Mathlib/Tactic/DeriveToExpr.lean", "Mathlib/MeasureTheory/Constructions/BorelSpace/ContinuousLinearMap.lean", "Mathlib/FieldTheory/Finite/Trace.lean", "Mathlib/Analysis/NormedSpace/MatrixExponential.lean", "Mathlib/CategoryTheory/Iso.lean", "Mathlib/Data/Nat/GCD/BigOperators.lean", "Mathlib/Algebra/Category/MonCat/Adjunctions.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Fold.lean", "Mathlib/Analysis/NormedSpace/Exponential.lean", "Mathlib/CategoryTheory/Closed/FunctorCategory.lean", "Mathlib/Topology/MetricSpace/Metrizable.lean", "Mathlib/Combinatorics/Partition.lean", "Mathlib/GroupTheory/GroupAction/DomAct/ActionHom.lean", "Mathlib/MeasureTheory/Constructions/Pi.lean", "Mathlib/Data/Set/Intervals/WithBotTop.lean", "Mathlib/CategoryTheory/PathCategory.lean", "Mathlib/Algebra/Homology/LocalCohomology.lean", "Mathlib/Tactic/CategoryTheory/Coherence.lean", "Mathlib/Topology/Algebra/FilterBasis.lean", "Mathlib/Topology/Tactic.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/EvenEquiv.lean", "Mathlib/Topology/MetricSpace/PiNat.lean", "Mathlib/Order/SemiconjSup.lean", "Mathlib/MeasureTheory/Measure/Haar/Basic.lean", "Mathlib/CategoryTheory/Category/TwoP.lean", "Mathlib/Data/W/Cardinal.lean", "Mathlib/Analysis/Convex/Caratheodory.lean", "Mathlib/Analysis/NormedSpace/lpSpace.lean", "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean", "Mathlib/Data/MvPolynomial/Invertible.lean", "Mathlib/Topology/Algebra/Algebra.lean", "Mathlib/Data/Rat/Cast/Defs.lean", "Mathlib/Topology/Bornology/Basic.lean", "Mathlib/Data/Polynomial/Module.lean", "Mathlib/Analysis/Asymptotics/Theta.lean", "Mathlib/Data/PNat/Interval.lean", "Mathlib/NumberTheory/ArithmeticFunction.lean", "Mathlib/Tactic/InferParam.lean", "Mathlib/Data/Polynomial/Coeff.lean", "Mathlib/Algebra/Group/Commute/Basic.lean", "Mathlib/Algebra/Order/Monoid/Prod.lean", "Mathlib/CategoryTheory/ConcreteCategory/Elementwise.lean", "Mathlib/Data/Finset/LocallyFinite.lean", "Mathlib/Order/Bounds/Basic.lean", "Mathlib/Geometry/Manifold/ConformalGroupoid.lean", "Mathlib/Data/Fintype/Parity.lean", "Mathlib/Topology/Algebra/Group/Compact.lean", "Mathlib/Util/PiNotation.lean", "Mathlib/Topology/MetricSpace/GromovHausdorff.lean", "Mathlib/Topology/Compactness/LocallyCompact.lean", "Mathlib/FieldTheory/IsAlgClosed/Spectrum.lean", "Mathlib/RingTheory/Discriminant.lean", "Mathlib/Topology/Algebra/Order/UpperLower.lean", "Mathlib/Algebra/GCDMonoid/Div.lean", "Mathlib/Util/SynthesizeUsing.lean", "Mathlib/Algebra/LinearRecurrence.lean", "Mathlib/Algebra/CharP/Algebra.lean", "Mathlib/Data/Nat/Choose/Vandermonde.lean", "Mathlib/Computability/Primrec.lean", "Mathlib/RingTheory/RingHomProperties.lean", "Mathlib/LinearAlgebra/TensorProduct/Opposite.lean", "Mathlib/Topology/MetricSpace/Basic.lean", "Mathlib/FieldTheory/KrullTopology.lean", "Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean", "Mathlib/Analysis/Calculus/Deriv/Linear.lean", "Mathlib/Data/Multiset/Fold.lean", "Mathlib/Algebra/Order/CompleteField.lean", "Mathlib/Topology/ContinuousFunction/Sigma.lean", "Mathlib/Tactic/TryThis.lean", "Mathlib/MeasureTheory/Function/ConditionalExpectation/Indicator.lean", "Mathlib/Data/Matrix/ColumnRowPartitioned.lean", "Mathlib/Data/MvPolynomial/Basic.lean", "Mathlib/Logic/Equiv/LocalEquiv.lean", "Mathlib/Topology/Compactness/SigmaCompact.lean", "Mathlib/RingTheory/FreeCommRing.lean", "Mathlib/Topology/Algebra/Module/LocallyConvex.lean", "Mathlib/Analysis/Convex/Body.lean", "Mathlib/Init/Data/Buffer/Parser.lean", "Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "Mathlib/Tactic/Sat/FromLRAT.lean", "Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean", "Mathlib/CategoryTheory/Quotient/Preadditive.lean", "Mathlib/Tactic/LeftRight.lean", "Mathlib/Tactic/Core.lean", "Mathlib/Data/List/Sublists.lean", "Mathlib/Data/Nat/Dist.lean", "Mathlib/NumberTheory/Multiplicity.lean", "Mathlib/Util/Superscript.lean", "Mathlib/LinearAlgebra/QuadraticForm/QuadraticModuleCat.lean", "Mathlib/CategoryTheory/Monoidal/Discrete.lean", "Mathlib/Data/Rat/Cast/CharZero.lean", "Mathlib/AlgebraicTopology/DoldKan/Equivalence.lean", "Mathlib/MeasureTheory/PiSystem.lean", "Mathlib/CategoryTheory/Limits/Yoneda.lean", "Mathlib/Analysis/Calculus/Series.lean", "Mathlib/Analysis/Analytic/IsolatedZeros.lean", "Mathlib/Algebra/Category/Ring/Colimits.lean", "Mathlib/Order/Extension/Well.lean", "Mathlib/Data/Set/Pointwise/SMul.lean", "Mathlib/CategoryTheory/Limits/Preserves/Opposites.lean", "Mathlib/RingTheory/Finiteness.lean", "Mathlib/FieldTheory/Minpoly/IsIntegrallyClosed.lean", "Mathlib/Combinatorics/Additive/PluenneckeRuzsa.lean", "Mathlib/Geometry/RingedSpace/PresheafedSpace/Gluing.lean", "Mathlib/NumberTheory/Padics/Hensel.lean", "Mathlib/CategoryTheory/Limits/Preserves/Basic.lean", "Mathlib/LinearAlgebra/Contraction.lean", "Mathlib/Analysis/NormedSpace/Spectrum.lean", "Mathlib/Order/Filter/Lift.lean", "Mathlib/Topology/Sheaves/Sheaf.lean", "Mathlib/CategoryTheory/Idempotents/FunctorExtension.lean", "Mathlib/GroupTheory/GroupAction/Group.lean", "Mathlib/Algebra/Homology/HomotopyCategory/Shift.lean", "Mathlib/Algebra/Hom/GroupAction.lean", "Mathlib/Logic/Small/Ring.lean", "Mathlib/CategoryTheory/Endomorphism.lean", "Mathlib/Control/Fix.lean", "Mathlib/Algebra/Field/Power.lean", "Mathlib/CategoryTheory/Subobject/Lattice.lean", "Mathlib/Analysis/Calculus/Deriv/Pi.lean", "Mathlib/Tactic/Simps/Basic.lean", "Mathlib/Analysis/Normed/Group/ControlledClosure.lean", "Mathlib/CategoryTheory/Monad/Algebra.lean", "Mathlib/Data/Finsupp/Multiset.lean", "Mathlib/GroupTheory/Perm/Option.lean", "Mathlib/RingTheory/Polynomial/Cyclotomic/Eval.lean", "Mathlib/CategoryTheory/Bicategory/FunctorBicategory.lean", "Mathlib/Data/List/Range.lean", "Mathlib/Topology/Algebra/Order/Archimedean.lean", "Mathlib/Algebra/Lie/Submodule.lean", "Mathlib/CategoryTheory/Products/Bifunctor.lean", "Mathlib/Data/Set/Prod.lean", "Mathlib/LinearAlgebra/DirectSum/Finsupp.lean", "Mathlib/RingTheory/RingHom/FiniteType.lean", "Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/Data/List/Forall2.lean", "Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "Mathlib/Algebra/Lie/Basic.lean", "Mathlib/CategoryTheory/Preadditive/Yoneda/Injective.lean", "Mathlib/Data/Fintype/Prod.lean", "Mathlib/Data/Int/Order/Lemmas.lean", "Mathlib/Analysis/ODE/Gronwall.lean", "Mathlib/MeasureTheory/Measure/Haar/InnerProductSpace.lean", "Mathlib/Data/List/Pairwise.lean", "Mathlib/Algebra/GroupRingAction/Basic.lean", "Mathlib/Data/List/Infix.lean", "Mathlib/AlgebraicTopology/DoldKan/Projections.lean", "Mathlib/CategoryTheory/Category/Init.lean", "Mathlib/Data/Polynomial/Monomial.lean", "Mathlib/LinearAlgebra/Dual.lean", "Mathlib/Order/Filter/ModEq.lean", "Mathlib/Topology/Algebra/Module/FiniteDimension.lean", "Mathlib/MeasureTheory/Covering/LiminfLimsup.lean", "Mathlib/Analysis/MeanInequalities.lean", "Mathlib/Order/UpperLower/LocallyFinite.lean", "Mathlib/SetTheory/Ordinal/Basic.lean", "Mathlib/CategoryTheory/ConcreteCategory/BundledHom.lean", "Mathlib/LinearAlgebra/QuadraticForm/Real.lean", "Mathlib/Order/Atoms/Finite.lean", "Mathlib/LinearAlgebra/GeneralLinearGroup.lean", "Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean", "Mathlib/NumberTheory/BernoulliPolynomials.lean", "Mathlib/Algebra/QuadraticDiscriminant.lean", "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "Mathlib/Dynamics/Flow.lean", "Mathlib/Order/FixedPoints.lean", "Mathlib/Algebra/Group/Opposite.lean", "Mathlib/AlgebraicTopology/Nerve.lean", "Mathlib/GroupTheory/MonoidLocalization.lean", "Mathlib/Topology/Category/Profinite/Basic.lean", "Mathlib/Geometry/Euclidean/Basic.lean", "Mathlib/Data/Complex/Module.lean", "Mathlib/FieldTheory/AxGrothendieck.lean", "Mathlib/CategoryTheory/Monoidal/Internal/Types.lean", "Mathlib/Topology/Connected/TotallyDisconnected.lean", "Mathlib/Topology/FiberBundle/IsHomeomorphicTrivialBundle.lean", "Mathlib/Analysis/SpecialFunctions/Log/Monotone.lean", "Mathlib/Tactic/SimpRw.lean", "Mathlib/NumberTheory/FLT/Basic.lean", "Mathlib/Topology/Instances/NNReal.lean", "Mathlib/Data/Prod/PProd.lean", "Mathlib/Analysis/SpecialFunctions/Exp.lean", "Mathlib/LinearAlgebra/Matrix/DotProduct.lean", "Mathlib/GroupTheory/Submonoid/Center.lean", "Mathlib/Order/Heyting/Boundary.lean", "Mathlib/MeasureTheory/Decomposition/Jordan.lean", "Mathlib/Algebra/Lie/SkewAdjoint.lean", "Mathlib/RingTheory/WittVector/WittPolynomial.lean", "Mathlib/RingTheory/Filtration.lean", "Mathlib/Topology/Algebra/Order/ExtrClosure.lean", "Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "Mathlib/Logic/Nonempty.lean", "Mathlib/Algebra/Hom/Aut.lean", "Mathlib/CategoryTheory/PUnit.lean", "Mathlib/Data/List/Rdrop.lean", "Mathlib/Combinatorics/Additive/Energy.lean", "Mathlib/Logic/Equiv/List.lean", "Mathlib/RingTheory/Polynomial/Hermite/Gaussian.lean", "Mathlib/Topology/Algebra/ConstMulAction.lean", "Mathlib/Analysis/NormedSpace/WeakDual.lean", "Mathlib/Topology/Algebra/UniformGroup.lean", "Mathlib/Order/Synonym.lean", "Mathlib/CategoryTheory/Preadditive/SingleObj.lean", "Mathlib/Order/Filter/AtTopBot.lean", "Mathlib/Analysis/Convex/Topology.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "Mathlib/Algebra/Star/Unitary.lean", "Mathlib/Order/KrullDimension.lean", "Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus.lean", "Mathlib/Algebra/Category/AlgebraCat/Monoidal.lean", "Mathlib/Algebra/Order/Ring/Abs.lean", "Mathlib/Algebra/Homology/ImageToKernel.lean", "Mathlib/RingTheory/PowerSeries/Basic.lean", "Mathlib/CategoryTheory/Shift/Pullback.lean", "Mathlib/Algebra/Periodic.lean", "Mathlib/Algebra/Category/ModuleCat/Limits.lean", "Mathlib/Algebra/GCDMonoid/Finset.lean", "Mathlib/Analysis/Calculus/LocalExtr/Rolle.lean", "Mathlib/CategoryTheory/Localization/Adjunction.lean", "Mathlib/CategoryTheory/Subterminal.lean", "Mathlib/Order/Partition/Equipartition.lean", "Mathlib/RingTheory/WittVector/FrobeniusFractionField.lean", "Mathlib/Algebra/FreeMonoid/Count.lean", "Mathlib/Algebra/Order/Ring/CharZero.lean", "Mathlib/Analysis/Normed/Group/HomCompletion.lean", "Mathlib/Data/IsROrC/Basic.lean", "Mathlib/Data/Fintype/Card.lean", "Mathlib/LinearAlgebra/AffineSpace/Ordered.lean", "Mathlib/CategoryTheory/Shift/Quotient.lean", "Mathlib/Algebra/AlgebraicCard.lean", "Mathlib/NumberTheory/Zsqrtd/ToReal.lean", "Mathlib/Tactic/Nontriviality/Core.lean", "Mathlib/CategoryTheory/Limits/Shapes/NormalMono/Equalizers.lean", "Mathlib/Init/IteSimp.lean", "Mathlib/LinearAlgebra/AffineSpace/Basic.lean", "Mathlib/Data/Rbtree/Find.lean", "Mathlib/RingTheory/Ideal/IdempotentFG.lean", "Mathlib/Algebra/Ring/Aut.lean", "Mathlib/Data/Matrix/DualNumber.lean", "Mathlib/GroupTheory/GroupAction/Basic.lean", "Mathlib/MeasureTheory/Function/UniformIntegrable.lean", "Mathlib/Combinatorics/SimpleGraph/Matching.lean", "Mathlib/Algebra/CovariantAndContravariant.lean", "Mathlib/GroupTheory/Divisible.lean", "Mathlib/CategoryTheory/Bicategory/Coherence.lean", "Mathlib/Data/Int/Sqrt.lean", "Mathlib/Mathport/Syntax.lean", "Mathlib/Algebra/CharP/Subring.lean", "Mathlib/NumberTheory/DiophantineApproximation.lean", "Mathlib/Analysis/InnerProductSpace/Projection.lean", "Mathlib/LinearAlgebra/Ray.lean", "Mathlib/Data/Finsupp/WellFounded.lean", "Mathlib/Topology/Algebra/Group/OpenMapping.lean", "Mathlib/Data/PFunctor/Univariate/Basic.lean", "Mathlib/Geometry/Manifold/Metrizable.lean", "Mathlib/Tactic/Set.lean", "Mathlib/CategoryTheory/UnivLE.lean", "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean", "Mathlib/Data/Finset/NoncommProd.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean", "Mathlib/Algebra/Star/SelfAdjoint.lean", "Mathlib/Algebra/DirectSum/Decomposition.lean", "Mathlib/NumberTheory/LegendreSymbol/GaussEisensteinLemmas.lean", "Mathlib/Data/List/Intervals.lean", "Mathlib/RingTheory/Polynomial/GaussLemma.lean", "Mathlib/Data/Finset/Sym.lean", "Mathlib/Topology/AlexandrovDiscrete.lean", "Mathlib/Algebra/Category/ModuleCat/Monoidal/Closed.lean", "Mathlib/Analysis/InnerProductSpace/PiL2.lean", "Mathlib/RingTheory/PolynomialAlgebra.lean", "Mathlib/MeasureTheory/Group/Measure.lean", "Mathlib/Tactic/Propose.lean", "Mathlib/Combinatorics/Hindman.lean", "Mathlib/Data/Nat/Choose/Bounds.lean", "Mathlib/Algebra/Order/Positive/Field.lean", "Mathlib/Data/Polynomial/DenomsClearable.lean", "Mathlib/NumberTheory/ModularForms/Basic.lean", "Mathlib/Order/SuccPred/Relation.lean", "Mathlib/Logic/Basic.lean", "Mathlib/Topology/MetricSpace/Lipschitz.lean", "Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "Mathlib/Data/List/TFAE.lean", "Mathlib/Analysis/MeanInequalitiesPow.lean", "Mathlib/Algebra/Lie/IdealOperations.lean", "Mathlib/Tactic/PermuteGoals.lean", "Mathlib/Algebra/Module/Injective.lean", "Mathlib/LinearAlgebra/AffineSpace/Restrict.lean", "Mathlib/Analysis/Calculus/Deriv/Mul.lean", "Mathlib/Algebra/Algebra/Pi.lean", "Mathlib/GroupTheory/SpecificGroups/Alternating.lean", "Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean", "Mathlib/Algebra/Order/Monoid/OrderDual.lean", "Mathlib/CategoryTheory/Over.lean", "Mathlib/Tactic/SetLike.lean", "Mathlib/Data/Nat/Cast/Field.lean", "Mathlib/Geometry/Manifold/Algebra/Monoid.lean", "Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean", "Mathlib/Data/Nat/Order/Lemmas.lean", "Mathlib/Topology/Sequences.lean", "Mathlib/ModelTheory/Algebra/Field/Basic.lean", "Mathlib/Probability/Martingale/BorelCantelli.lean", "Mathlib/Algebra/BigOperators/Associated.lean", "Mathlib/Analysis/Calculus/LocalExtr/Basic.lean", "Mathlib/Analysis/Calculus/ParametricIntegral.lean", "Mathlib/Combinatorics/Hall/Finite.lean", "Mathlib/CategoryTheory/Bicategory/Strict.lean", "Mathlib/Data/Polynomial/Eval.lean", "Mathlib/Topology/Specialization.lean", "Mathlib/Data/List/Perm.lean", "Mathlib/Data/Set/Functor.lean", "Mathlib/Data/List/Zip.lean", "Mathlib/Analysis/NormedSpace/BallAction.lean", "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "Mathlib/RingTheory/Valuation/ValuationRing.lean", "Mathlib/Tactic/Linarith/Preprocessing.lean", "Mathlib/RingTheory/Norm.lean", "Mathlib/Analysis/NormedSpace/Star/Matrix.lean", "Mathlib/CategoryTheory/Functor/EpiMono.lean", "Mathlib/Topology/Algebra/Order/Compact.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/FunctionsBoundedAtInfty.lean", "Mathlib/GroupTheory/Subgroup/Pointwise.lean", "Mathlib/Tactic/NormNum/IsCoprime.lean", "Mathlib/Algebra/PEmptyInstances.lean", "Mathlib/Data/Set/Pointwise/Interval.lean", "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean", "Mathlib/Init/Data/Nat/Div.lean", "Mathlib/Analysis/Calculus/IteratedDeriv.lean", "Mathlib/Analysis/SpecificLimits/IsROrC.lean", "Mathlib/Topology/Sheaves/Presheaf.lean", "Mathlib/Combinatorics/SetFamily/Intersecting.lean", "Mathlib/Order/Hom/Bounded.lean", "Mathlib/Order/Filter/EventuallyConst.lean", "Mathlib/Order/Minimal.lean", "Mathlib/Topology/Connected/PathConnected.lean", "Mathlib/Tactic/Linarith/Lemmas.lean", "Mathlib/Data/List/NatAntidiagonal.lean", "Mathlib/Algebra/BigOperators/Finprod.lean", "Mathlib/Data/MvPolynomial/Polynomial.lean", "Mathlib/Topology/Algebra/MulAction.lean", "Mathlib/Data/Set/Intervals/Basic.lean", "Mathlib/Analysis/InnerProductSpace/Basic.lean", "Mathlib/Init/Data/Sigma/Lex.lean", "Mathlib/CategoryTheory/Category/Grpd.lean", "Mathlib/Data/Finsupp/Lex.lean", "Mathlib/Data/Int/Order/Units.lean", "Mathlib/Data/Finset/Lattice.lean", "Mathlib/Data/Set/Lattice.lean", "Mathlib/Algebra/Star/Basic.lean", "Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean", "Mathlib/Combinatorics/Additive/Etransform.lean", "Mathlib/Algebra/CharZero/Lemmas.lean", "Mathlib/Data/Real/NNReal.lean", "Mathlib/Topology/Instances/RatLemmas.lean", "Mathlib/Tactic/Change.lean", "Mathlib/Data/Matrix/DMatrix.lean", "Mathlib/Order/Chain.lean", "Mathlib/Data/Int/Units.lean", "Mathlib/Topology/NhdsSet.lean", "Mathlib/Topology/UniformSpace/Cauchy.lean", "Mathlib/CategoryTheory/Core.lean", "Mathlib/CategoryTheory/Limits/FunctorCategory.lean", "Mathlib/Probability/Kernel/IntegralCompProd.lean", "Mathlib/Algebra/Category/GroupWithZeroCat.lean", "Mathlib/Algebra/Star/Module.lean", "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean", "Mathlib/RingTheory/SimpleModule.lean", "Mathlib/MeasureTheory/Function/ConditionalExpectation/Basic.lean", "Mathlib/Analysis/LocallyConvex/StrongTopology.lean", "Mathlib/Data/Countable/Small.lean", "Mathlib/Data/MvPolynomial/PDeriv.lean", "Mathlib/AlgebraicGeometry/Morphisms/FiniteType.lean", "Mathlib/Data/List/FinRange.lean", "Mathlib/Util/Tactic.lean", "Mathlib/Analysis/BoxIntegral/Box/Basic.lean", "Mathlib/Init/Data/Option/Basic.lean", "Mathlib/Combinatorics/Quiver/Subquiver.lean", "Mathlib/Order/Category/DistLat.lean", "Mathlib/Tactic/DeriveTraversable.lean", "Mathlib/CategoryTheory/Monad/Basic.lean", "Mathlib/CategoryTheory/Sites/LeftExact.lean", "Mathlib/GroupTheory/GroupAction/BigOperators.lean", "Mathlib/Topology/Algebra/Order/Field.lean", "Mathlib/Combinatorics/SimpleGraph/Hasse.lean", "Mathlib/MeasureTheory/Integral/RieszMarkovKakutani.lean", "Mathlib/Analysis/Calculus/Deriv/Basic.lean", "Mathlib/CategoryTheory/Bicategory/Adjunction.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "Mathlib/Algebra/Lie/Subalgebra.lean", "Mathlib/Data/Multiset/Functor.lean", "Mathlib/Data/Bracket.lean", "Mathlib/Algebra/BigOperators/NatAntidiagonal.lean", "Mathlib/Tactic/Positivity.lean", "Mathlib/Algebra/Module/Torsion.lean", "Mathlib/Data/Fintype/List.lean", "Mathlib/Order/Category/BddLat.lean", "Mathlib/Analysis/NormedSpace/ConformalLinearMap.lean", "Mathlib/Analysis/NormedSpace/IndicatorFunction.lean", "Mathlib/Data/Finset/Prod.lean", "Mathlib/Data/Semiquot.lean", "Mathlib/Topology/Algebra/Module/Simple.lean", "Mathlib/Topology/Bornology/Constructions.lean", "Mathlib/Topology/MetricSpace/IsometricSMul.lean", "Mathlib/LinearAlgebra/Finrank.lean", "Mathlib/Topology/MetricSpace/PartitionOfUnity.lean", "Mathlib/Algebra/Order/Group/OrderIso.lean", "Mathlib/Probability/Independence/ZeroOne.lean", "Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean", "Mathlib/Order/Category/Lat.lean", "Mathlib/Algebra/DirectSum/Internal.lean", "Mathlib/Analysis/Convex/Exposed.lean", "Mathlib/RingTheory/DedekindDomain/Dvr.lean", "Mathlib/RingTheory/JacobsonIdeal.lean", "Mathlib/AlgebraicGeometry/Spec.lean", "Mathlib/RingTheory/Localization/Away/Basic.lean", "Mathlib/Topology/MetricSpace/CantorScheme.lean", "Mathlib/Algebra/DirectSum/Algebra.lean", "Mathlib/Lean/Exception.lean", "Mathlib/CategoryTheory/Monoidal/Rigid/OfEquivalence.lean", "Mathlib/Geometry/Euclidean/Triangle.lean", "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "Mathlib/LinearAlgebra/ProjectiveSpace/Basic.lean", "Mathlib/Topology/Sheaves/Init.lean", "Mathlib/Data/MvPolynomial/Division.lean", "Mathlib/Algebra/Category/MonCat/Limits.lean", "Mathlib/MeasureTheory/Function/EssSup.lean", "Mathlib/Analysis/Convex/StrictConvexBetween.lean", "Mathlib/CategoryTheory/Abelian/FunctorCategory.lean", "Mathlib/RingTheory/IntegralClosure.lean", "Mathlib/MeasureTheory/Integral/Layercake.lean", "Mathlib/Algebra/Parity.lean", "Mathlib/Tactic/FailIfNoProgress.lean", "Mathlib/Topology/TietzeExtension.lean", "Mathlib/Tactic/Nontriviality.lean", "Mathlib/Order/Monotone/Odd.lean", "Mathlib/RingTheory/FiniteType.lean", "Mathlib/CategoryTheory/Groupoid/Subgroupoid.lean", "Mathlib/Algebra/Order/Chebyshev.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Pullbacks.lean", "Mathlib/Algebra/Category/ModuleCat/Products.lean", "Mathlib/Data/Real/Basic.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean", "Mathlib/Topology/FiberBundle/Basic.lean", "Mathlib/Analysis/Convex/Join.lean", "Mathlib/GroupTheory/EckmannHilton.lean", "Mathlib/Computability/Language.lean", "Mathlib/Topology/ContinuousFunction/LocallyConstant.lean", "Mathlib/CategoryTheory/Sites/Limits.lean", "Mathlib/Init/Quot.lean", "Mathlib/AlgebraicGeometry/Morphisms/QuasiCompact.lean", "Mathlib/Data/PNat/Find.lean", "Mathlib/CategoryTheory/Monoidal/Free/Basic.lean", "Mathlib/NumberTheory/LegendreSymbol/MulCharacter.lean", "Mathlib/Data/Real/ENNReal.lean", "Mathlib/LinearAlgebra/Basis/VectorSpace.lean", "Mathlib/Algebra/Ring/Pi.lean", "Mathlib/Data/PEquiv.lean", "Mathlib/MeasureTheory/Group/FundamentalDomain.lean", "Mathlib/MeasureTheory/Function/SimpleFunc.lean", "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "Mathlib/Topology/Semicontinuous.lean", "Mathlib/MeasureTheory/Function/SpecialFunctions/Arctan.lean", "Mathlib/Data/QPF/Univariate/Basic.lean", "Mathlib/Analysis/SpecialFunctions/Exponential.lean", "Mathlib/LinearAlgebra/Pi.lean", "Mathlib/FieldTheory/Adjoin.lean", "Mathlib/Logic/Equiv/Set.lean", "Mathlib/AlgebraicTopology/FundamentalGroupoid/FundamentalGroup.lean", "Mathlib/Topology/Homotopy/Path.lean", "Mathlib/Combinatorics/SimpleGraph/Triangle/Basic.lean", "Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean", "Mathlib/Tactic/NormNum/NatSqrt.lean", "Mathlib/LinearAlgebra/TensorAlgebra/ToTensorPower.lean", "Mathlib/Algebra/Order/Monoid/Defs.lean", "Mathlib/Probability/Density.lean", "Mathlib/RingTheory/Etale.lean", "Mathlib/Algebra/Group/ULift.lean", "Mathlib/Algebra/Group/Ext.lean", "Mathlib/NumberTheory/LucasPrimality.lean", "Mathlib/CategoryTheory/Limits/Shapes/RegularMono.lean", "Mathlib/Algebra/Category/GroupCat/Colimits.lean", "Mathlib/Dynamics/FixedPoints/Topology.lean", "Mathlib/Util/AssertNoSorry.lean", "Mathlib/CategoryTheory/Sites/Subsheaf.lean", "Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "Mathlib/Order/GameAdd.lean", "Mathlib/Topology/Sheaves/Operations.lean", "Mathlib/Tactic/IrreducibleDef.lean", "Mathlib/Algebra/Hom/GroupInstances.lean", "Mathlib/Algebra/Group/Pi.lean", "Mathlib/Lean/Linter.lean", "Mathlib/CategoryTheory/Localization/Construction.lean", "Mathlib/CategoryTheory/Monoidal/End.lean", "Mathlib/FieldTheory/Minpoly/Basic.lean", "Mathlib/Geometry/Euclidean/Angle/Oriented/Rotation.lean", "Mathlib/Data/PNat/Xgcd.lean", "Mathlib/Algebra/Category/ModuleCat/Colimits.lean", "Mathlib/MeasureTheory/Measure/Regular.lean", "Mathlib/Topology/Algebra/Module/CharacterSpace.lean", "Mathlib/Init/Data/Int/Order.lean", "Mathlib/Init/Data/Prod.lean", "Mathlib/RingTheory/Ideal/Quotient.lean", "Mathlib/Lean/Expr.lean", "Mathlib/Algebra/Lie/Abelian.lean", "Mathlib/Analysis/Calculus/AffineMap.lean", "Mathlib/Analysis/Convex/Complex.lean", "Mathlib/Data/Nat/Multiplicity.lean", "Mathlib/Data/Int/Parity.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/ArctanDeriv.lean", "Mathlib/Control/Applicative.lean", "Mathlib/Order/CompleteLattice.lean", "Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "Mathlib/Algebra/Divisibility/Prod.lean", "Mathlib/Tactic/Widget/Calc.lean", "Mathlib/NumberTheory/Rayleigh.lean", "Mathlib/CategoryTheory/Limits/Constructions/WeaklyInitial.lean", "Mathlib/Algebra/Module/Submodule/Basic.lean", "Mathlib/Tactic/Variable.lean", "Mathlib/MeasureTheory/Measure/Haar/Disintegration.lean", "Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.lean", "Mathlib/Topology/Support.lean", "Mathlib/Data/Int/Div.lean", "Mathlib/LinearAlgebra/Projection.lean", "Mathlib/Lean/Expr/ReplaceRec.lean", "Mathlib/MeasureTheory/Covering/Differentiation.lean", "Mathlib/Algebra/Ring/Opposite.lean", "Mathlib/Combinatorics/SimpleGraph/DegreeSum.lean", "Mathlib/Algebra/Hom/Ring/Defs.lean", "Mathlib/CategoryTheory/Sites/Coherent.lean", "Mathlib/Computability/DFA.lean", "Mathlib/GroupTheory/FreeAbelianGroupFinsupp.lean", "Mathlib/CategoryTheory/Sites/Sheafification.lean", "Mathlib/Tactic/GCongr/Core.lean", "Mathlib/NumberTheory/PrimesCongruentOne.lean", "Mathlib/GroupTheory/Perm/Sign.lean", "Mathlib/RepresentationTheory/FdRep.lean", "Mathlib/SetTheory/Game/Basic.lean", "Mathlib/AlgebraicGeometry/Gluing.lean", "Mathlib/Algebra/Tropical/BigOperators.lean", "Mathlib/Combinatorics/Configuration.lean", "Mathlib/Data/Pi/Lex.lean", "Mathlib/Data/TwoPointing.lean", "Mathlib/Analysis/InnerProductSpace/Dual.lean", "Mathlib/Topology/UniformSpace/Equicontinuity.lean", "Mathlib/Data/Nat/Factors.lean", "Mathlib/RingTheory/Ideal/Basic.lean", "Mathlib/Topology/MetricSpace/Antilipschitz.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Products.lean", "Mathlib/CategoryTheory/Endofunctor/Algebra.lean", "Mathlib/MeasureTheory/Decomposition/SignedHahn.lean", "Mathlib/Topology/LocalExtr.lean", "Mathlib/NumberTheory/LegendreSymbol/GaussSum.lean", "Mathlib/RingTheory/Localization/Integer.lean", "Mathlib/CategoryTheory/Linear/LinearFunctor.lean", "Mathlib/Tactic/Existsi.lean", "Mathlib/Analysis/Complex/Polynomial.lean", "Mathlib/Data/List/Indexes.lean", "Mathlib/Algebra/Category/GroupCat/Basic.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Basic.lean", "Mathlib/Data/Real/Cardinality.lean", "Mathlib/Algebra/Algebra/Spectrum.lean", "Mathlib/MeasureTheory/Decomposition/Lebesgue.lean", "Mathlib/Topology/Algebra/UniformMulAction.lean", "Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean", "Mathlib/Algebra/Order/Nonneg/Floor.lean", "Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "Mathlib/CategoryTheory/Limits/Shapes/Types.lean", "Mathlib/Data/Rbtree/DefaultLt.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/EulerSineProd.lean", "Mathlib/NumberTheory/Bernoulli.lean", "Mathlib/Data/Polynomial/PartialFractions.lean", "Mathlib/SetTheory/Cardinal/Divisibility.lean", "Mathlib/Topology/Category/Profinite/Product.lean", "Mathlib/Combinatorics/Colex.lean", "Mathlib/Data/Nat/Lattice.lean", "Mathlib/CategoryTheory/Filtered/Basic.lean", "Mathlib/CategoryTheory/Limits/FinallySmall.lean", "Mathlib/CategoryTheory/Category/Factorisation.lean", "Mathlib/CategoryTheory/Adjunction/Mates.lean", "Mathlib/CategoryTheory/Adjunction/Opposites.lean", "Mathlib/CategoryTheory/Sites/Sheaf.lean", "Mathlib/Tactic/Relation/Trans.lean", "Mathlib/Algebra/FreeNonUnitalNonAssocAlgebra.lean", "Mathlib/Data/LazyList.lean", "Mathlib/CategoryTheory/Abelian/Pseudoelements.lean", "Mathlib/CategoryTheory/Sites/InducedTopology.lean", "Mathlib/Lean/Elab/Tactic/Basic.lean", "Mathlib/Algebra/DualQuaternion.lean", "Mathlib/Algebra/Homology/ShortComplex/PreservesHomology.lean", "Mathlib/Data/Nat/Factorization/PrimePow.lean", "Mathlib/CategoryTheory/Limits/Shapes/Multiequalizer.lean", "Mathlib/CategoryTheory/Monad/Adjunction.lean", "Mathlib/Order/MinMax.lean", "Mathlib/Control/Bitraversable/Instances.lean", "Mathlib/Algebra/Bounds.lean", "Mathlib/AlgebraicTopology/FundamentalGroupoid/PUnit.lean", "Mathlib/CategoryTheory/Monad/Kleisli.lean", "Mathlib/CategoryTheory/Bicategory/SingleObj.lean", "Mathlib/CategoryTheory/Limits/Constructions/LimitsOfProductsAndEqualizers.lean", "Mathlib/Data/Nat/Sqrt.lean", "Mathlib/Topology/Algebra/UniformRing.lean", "Mathlib/Order/Filter/ZeroAndBoundedAtFilter.lean", "Mathlib/CategoryTheory/Idempotents/Basic.lean", "Mathlib/Geometry/Manifold/BumpFunction.lean", "Mathlib/Order/Category/FinPartOrd.lean", "Mathlib/Tactic/ModCases.lean", "Mathlib/Topology/MetricSpace/ThickenedIndicator.lean", "Mathlib/GroupTheory/Exponent.lean", "Mathlib/Order/Filter/Extr.lean", "Mathlib/RingTheory/Polynomial/ScaleRoots.lean", "Mathlib/CategoryTheory/Sites/CompatiblePlus.lean", "Mathlib/RingTheory/Polynomial/Opposites.lean", "Mathlib/Tactic/Eqns.lean", "Mathlib/Analysis/InnerProductSpace/Spectrum.lean", "Mathlib/Init/Data/Rat/Basic.lean", "Mathlib/Topology/Separation.lean", "Mathlib/Algebra/Algebra/Subalgebra/Tower.lean", "Mathlib/Data/Finsupp/Pwo.lean", "Mathlib/Combinatorics/Quiver/Path.lean", "Mathlib/Algebra/Algebra/Tower.lean", "Mathlib/Order/Filter/FilterProduct.lean", "Mathlib/Order/Bounds/OrderIso.lean", "Mathlib/Data/Finsupp/ToDFinsupp.lean", "Mathlib/Control/Basic.lean", "Mathlib/Algebra/Abs.lean", "Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "Mathlib/Data/Matrix/Block.lean", "Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean", "Mathlib/Analysis/NormedSpace/Ray.lean", "Mathlib/GroupTheory/Submonoid/Membership.lean", "Mathlib/Probability/ProbabilityMassFunction/Constructions.lean", "Mathlib/NumberTheory/LSeries.lean", "Mathlib/Logic/Embedding/Set.lean", "Mathlib/Analysis/Convex/Cone/Basic.lean", "Mathlib/Order/Hom/Lattice.lean", "Mathlib/Topology/CompactOpen.lean", "Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "Mathlib/Data/Finsupp/AList.lean", "Mathlib/Data/Fintype/Lattice.lean", "Mathlib/Data/IsROrC/Lemmas.lean", "Mathlib/Analysis/Calculus/FDeriv/Star.lean", "Mathlib/Analysis/Normed/Group/AddCircle.lean", "Mathlib/Deprecated/Ring.lean", "Mathlib/GroupTheory/Coset.lean", "Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "Mathlib/Probability/BorelCantelli.lean", "Mathlib/Algebra/Homology/ShortComplex/FunctorEquivalence.lean", "Mathlib/Topology/MetricSpace/MetricSeparated.lean", "Mathlib/Algebra/GroupPower/Identities.lean", "Mathlib/Analysis/NormedSpace/TrivSqZeroExt.lean", "Mathlib/Init/Data/Int/Lemmas.lean", "Mathlib/GroupTheory/PGroup.lean", "Mathlib/Probability/ProbabilityMassFunction/Binomial.lean", "Mathlib/RingTheory/Fintype.lean", "Mathlib/Algebra/ContinuedFractions/Computation/TerminatesIffRat.lean", "Mathlib/CategoryTheory/Category/GaloisConnection.lean", "Mathlib/Analysis/Convex/SpecificFunctions/Pow.lean", "Mathlib/Algebra/Module/Hom.lean", "Mathlib/Data/Fintype/Basic.lean", "Mathlib/Data/Set/Constructions.lean", "Mathlib/Analysis/NormedSpace/MStructure.lean", "Mathlib/CategoryTheory/Sites/Types.lean", "Mathlib/Data/TypeVec.lean", "Mathlib/Control/Functor/Multivariate.lean", "Mathlib/Analysis/Normed/Field/Basic.lean", "Mathlib/LinearAlgebra/FreeModule/Basic.lean", "Mathlib/MeasureTheory/Integral/SetToL1.lean", "Mathlib/CategoryTheory/Triangulated/Rotate.lean", "Mathlib/Algebra/Algebra/Unitization.lean", "Mathlib/Tactic/Relation/Symm.lean", "Mathlib/Analysis/BoxIntegral/Integrability.lean", "Mathlib/Algebra/Ring/Prod.lean", "Mathlib/Lean/Meta/Simp.lean", "Mathlib/CategoryTheory/Preadditive/Generator.lean", "Mathlib/SetTheory/Game/PGame.lean", "Mathlib/Util/MemoFix.lean", "Mathlib/Logic/Equiv/Array.lean", "Mathlib/Topology/Algebra/Order/LeftRightLim.lean", "Mathlib/Data/Set/Accumulate.lean", "Mathlib/Analysis/SpecialFunctions/PolarCoord.lean", "Mathlib/Analysis/Analytic/Composition.lean", "Mathlib/Tactic/CancelDenoms.lean", "Mathlib/CategoryTheory/Sites/Whiskering.lean", "Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean", "Mathlib/Algebra/Category/SemigroupCat/Basic.lean", "Mathlib/CategoryTheory/Groupoid/VertexGroup.lean", "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "Mathlib/Algebra/BigOperators/Pi.lean", "Mathlib/Data/SProd.lean", "Mathlib/RingTheory/WittVector/Frobenius.lean", "Mathlib/Geometry/Manifold/DerivationBundle.lean", "Mathlib/Analysis/Complex/Conformal.lean", "Mathlib/Algebra/Hom/Iterate.lean", "Mathlib/CategoryTheory/Limits/Pi.lean", "Mathlib/Order/ConditionallyCompleteLattice/Group.lean", "Mathlib/Probability/Moments.lean", "Mathlib/Data/List/Permutation.lean", "Mathlib/CategoryTheory/Equivalence.lean", "Mathlib/CategoryTheory/Monoidal/Functorial.lean", "Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "Mathlib/RingTheory/LocalProperties.lean", "Mathlib/Algebra/MonoidAlgebra/ToDirectSum.lean", "Mathlib/LinearAlgebra/FreeModule/Norm.lean", "Mathlib/CategoryTheory/Noetherian.lean", "Mathlib/CategoryTheory/Preadditive/Basic.lean", "Mathlib/Logic/Equiv/Basic.lean", "Mathlib/Probability/Kernel/CondDistrib.lean", "Mathlib/CategoryTheory/Abelian/LeftDerived.lean", "Mathlib/CategoryTheory/Localization/Equivalence.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/InverseDeriv.lean", "Mathlib/Analysis/NormedSpace/RieszLemma.lean", "Mathlib/Analysis/NormedSpace/ProdLp.lean", "Mathlib/NumberTheory/PythagoreanTriples.lean", "Mathlib/Topology/Algebra/Star.lean", "Mathlib/Analysis/BoxIntegral/Partition/Filter.lean", "Mathlib/Data/String/Basic.lean", "Mathlib/MeasureTheory/Measure/Content.lean", "Mathlib/AlgebraicGeometry/Properties.lean", "Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean", "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "Mathlib/CategoryTheory/Adhesive.lean", "Mathlib/CategoryTheory/Triangulated/Opposite.lean", "Mathlib/Data/Finite/Card.lean", "Mathlib/Data/String/Lemmas.lean", "Mathlib/Init/Data/Nat/Bitwise.lean", "Mathlib/Util/AddRelatedDecl.lean", "Mathlib/Tactic/NormNum/NatFib.lean", "Mathlib/Data/Set/Pointwise/Support.lean", "Mathlib/Data/Nat/PartENat.lean", "Mathlib/Tactic/NormNum/Inv.lean", "Mathlib/LinearAlgebra/AffineSpace/MidpointZero.lean", "Mathlib/CategoryTheory/Monoidal/Linear.lean", "Mathlib/Order/UpperLower/Hom.lean", "Mathlib/LinearAlgebra/Isomorphisms.lean", "Mathlib/Tactic/Rewrites.lean", "Mathlib/Topology/MetricSpace/Contracting.lean", "Mathlib/Algebra/GroupRingAction/Subobjects.lean", "Mathlib/FieldTheory/Subfield.lean", "Mathlib/LinearAlgebra/Matrix/PosDef.lean", "Mathlib/Data/List/Chain.lean", "Mathlib/ModelTheory/Ultraproducts.lean", "Mathlib/Algebra/Order/Algebra.lean", "Mathlib/Order/ULift.lean", "Mathlib/Data/Nat/Factorial/BigOperators.lean", "Mathlib/RingTheory/WittVector/Isocrystal.lean", "Mathlib/Algebra/Category/Ring/Limits.lean", "Mathlib/Tactic/Common.lean", "Mathlib/Data/Buffer/Basic.lean", "Mathlib/Data/Rat/Cast/Lemmas.lean", "Mathlib/CategoryTheory/Monoidal/Free/Coherence.lean", "Mathlib/Topology/Sheaves/LocalPredicate.lean", "Mathlib/Analysis/Convex/Cone/Dual.lean", "Mathlib/Analysis/Convex/Between.lean", "Mathlib/Topology/Order.lean", "Mathlib/Analysis/BoxIntegral/Partition/Tagged.lean", "Mathlib/Topology/Algebra/Nonarchimedean/Bases.lean", "Mathlib/Combinatorics/SimpleGraph/Regularity/Chunk.lean", "Mathlib/Analysis/NormedSpace/Pointwise.lean", "Mathlib/Tactic/CategoryTheory/Elementwise.lean", "Mathlib/Data/List/ProdSigma.lean", "Mathlib/Topology/Homotopy/HSpaces.lean", "Mathlib/Analysis/SpecialFunctions/Sqrt.lean", "Mathlib/Algebra/CharZero/Defs.lean", "Mathlib/SetTheory/Cardinal/SchroederBernstein.lean", "Mathlib/MeasureTheory/Measure/Count.lean", "Mathlib/RingTheory/FractionalIdeal.lean", "Mathlib/CategoryTheory/Subobject/Basic.lean", "Mathlib/Data/Int/ConditionallyCompleteOrder.lean", "Mathlib/NumberTheory/VonMangoldt.lean", "Mathlib/Algebra/Order/Hom/Monoid.lean", "Mathlib/NumberTheory/LucasLehmer.lean", "Mathlib/ModelTheory/DirectLimit.lean", "Mathlib/Analysis/NormedSpace/MazurUlam.lean", "Mathlib/MeasureTheory/Measure/ProbabilityMeasure.lean", "Mathlib/Algebra/Category/FGModuleCat/Basic.lean", "Mathlib/GroupTheory/Subgroup/Basic.lean", "Mathlib/Init/Algebra/Classes.lean", "Mathlib/AlgebraicGeometry/OpenImmersion.lean", "Mathlib/Probability/StrongLaw.lean", "Mathlib/Order/Category/BoolAlg.lean", "Mathlib/Data/Rbtree/Insert.lean", "Mathlib/Algebra/Module/DedekindDomain.lean", "Mathlib/ModelTheory/ElementaryMaps.lean", "Mathlib/LinearAlgebra/TensorProduct/Prod.lean", "Mathlib/Data/Set/Intervals/UnorderedInterval.lean", "Mathlib/Algebra/Hom/Equiv/Units/GroupWithZero.lean", "Mathlib/Algebra/Lie/Semisimple.lean", "Mathlib/Algebra/Module/Submodule/Lattice.lean", "Mathlib/Tactic/Congrm.lean", "Mathlib/Logic/Unique.lean", "Mathlib/CategoryTheory/Localization/LocalizerMorphism.lean", "Mathlib/Algebra/Homology/Single.lean", "Mathlib/Order/Filter/Pointwise.lean", "Mathlib/CategoryTheory/Bicategory/Extension.lean", "Mathlib/Analysis/NormedSpace/Basic.lean", "Mathlib/Data/W/Basic.lean", "Mathlib/Logic/Small/Module.lean", "Mathlib/Topology/Algebra/Semigroup.lean", "Mathlib/Topology/Sheaves/Functors.lean", "Mathlib/MeasureTheory/Function/L2Space.lean", "Mathlib/Algebra/Category/GroupCat/Images.lean", "Mathlib/Analysis/NormedSpace/Units.lean", "Mathlib/CategoryTheory/Skeletal.lean", "Mathlib/Algebra/Order/Group/Defs.lean", "Mathlib/Order/Basic.lean", "Mathlib/Control/Traversable/Lemmas.lean", "Mathlib/Algebra/Order/Monoid/ToMulBot.lean", "Mathlib/Analysis/InnerProductSpace/Orthogonal.lean", "Mathlib/Control/Fold.lean", "Mathlib/RingTheory/Localization/AsSubring.lean", "Mathlib/Algebra/Order/Monoid/Units.lean", "Mathlib/Dynamics/Ergodic/Ergodic.lean", "Mathlib/Dynamics/Ergodic/Function.lean", "Mathlib/FieldTheory/Perfect.lean", "Mathlib/CategoryTheory/Preadditive/EilenbergMoore.lean", "Mathlib/Analysis/SpecialFunctions/Stirling.lean", "Mathlib/MeasureTheory/Group/Arithmetic.lean", "Mathlib/Order/Filter/SmallSets.lean", "Mathlib/RingTheory/Bezout.lean", "Mathlib/Data/Polynomial/Div.lean", "Mathlib/AlgebraicTopology/DoldKan/SplitSimplicialObject.lean", "Mathlib/RingTheory/WittVector/Defs.lean", "Mathlib/CategoryTheory/Triangulated/Basic.lean", "Mathlib/Tactic/SplitIfs.lean", "Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean", "Mathlib/Algebra/BigOperators/Finsupp.lean", "Mathlib/Data/Polynomial/Expand.lean", "Mathlib/MeasureTheory/Measure/Hausdorff.lean", "Mathlib/CategoryTheory/Limits/Types.lean", "Mathlib/Data/FunLike/Basic.lean", "Mathlib/RingTheory/RingHom/Integral.lean", "Mathlib/Topology/Sheaves/Skyscraper.lean", "Mathlib/Data/DFinsupp/NeLocus.lean", "Mathlib/GroupTheory/FiniteAbelian.lean", "Mathlib/Analysis/Complex/UnitDisc/Basic.lean", "Mathlib/Topology/Instances/EReal.lean", "Mathlib/Data/Bool/Count.lean", "Mathlib/Algebra/IndicatorFunction.lean", "Mathlib/Algebra/Module/Submodule/Pointwise.lean", "Mathlib/Algebra/Star/Pointwise.lean", "Mathlib/CategoryTheory/Sites/Adjunction.lean", "Mathlib/Tactic/Abel.lean", "Mathlib/RingTheory/Derivation/Basic.lean", "Mathlib/MeasureTheory/Measure/Lebesgue/Complex.lean", "Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean", "Mathlib/Data/DFinsupp/Interval.lean", "Mathlib/Algebra/Divisibility/Basic.lean", "Mathlib/Data/Finset/Interval.lean", "Mathlib/Tactic/NormNum/Pow.lean", "Mathlib/Data/Finset/Sups.lean", "Mathlib/Algebra/Category/BoolRing.lean", "Mathlib/LinearAlgebra/SModEq.lean", "Mathlib/Algebra/Order/Field/Defs.lean", "Mathlib/Data/Equiv/Functor.lean", "Mathlib/Algebra/EuclideanDomain/Instances.lean", "Mathlib/LinearAlgebra/Matrix/Transvection.lean", "Mathlib/Analysis/Convex/Normed.lean", "Mathlib/Tactic/Tauto.lean", "Mathlib/Algebra/Hom/Commute.lean", "Mathlib/RingTheory/Adjoin/Basic.lean", "Mathlib/Topology/LocalHomeomorph.lean", "Mathlib/Algebra/Category/ModuleCat/Adjunctions.lean", "Mathlib/Analysis/Normed/Group/BallSphere.lean", "Mathlib/Topology/Sheaves/Limits.lean", "Mathlib/Tactic/NormNum/OfScientific.lean", "Mathlib/GroupTheory/Submonoid/MulOpposite.lean", "Mathlib/LinearAlgebra/Matrix/Reindex.lean", "Mathlib/Algebra/Homology/Exact.lean", "Mathlib/Order/Zorn.lean", "Mathlib/Data/Array/Lemmas.lean", "Mathlib/LinearAlgebra/Dimension.lean", "Mathlib/Probability/Process/HittingTime.lean", "Mathlib/Topology/UniformSpace/Completion.lean", "Mathlib/Analysis/Convex/Combination.lean", "Mathlib/ModelTheory/LanguageMap.lean", "Mathlib/Algebra/Category/ModuleCat/EpiMono.lean", "Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "Mathlib/Data/Matrix/Hadamard.lean", "Mathlib/GroupTheory/SchurZassenhaus.lean", "Mathlib/LinearAlgebra/Matrix/Charpoly/FiniteField.lean", "Mathlib/LinearAlgebra/TensorPower.lean", "Mathlib/FieldTheory/Galois.lean", "Mathlib/RingTheory/WittVector/DiscreteValuationRing.lean", "Mathlib/Data/Set/Function.lean", "Mathlib/CategoryTheory/Limits/Shapes/Diagonal.lean", "Mathlib/Topology/Algebra/Order/LeftRight.lean", "Mathlib/RingTheory/GradedAlgebra/Radical.lean", "Mathlib/Deprecated/Subfield.lean", "Mathlib/Tactic/NthRewrite.lean", "Mathlib/Algebra/Group/ConjFinite.lean", "Mathlib/LinearAlgebra/TensorAlgebra/Basis.lean", "Mathlib/RingTheory/RingHom/Finite.lean", "Mathlib/Topology/Algebra/Polynomial.lean", "Mathlib/Analysis/NormedSpace/Dual.lean", "Mathlib/GroupTheory/Perm/Fin.lean", "Mathlib/Analysis/BoxIntegral/Partition/Split.lean", "Mathlib/CategoryTheory/Sites/CoverLifting.lean", "Mathlib/Topology/Category/Compactum.lean", "Mathlib/Analysis/Calculus/Deriv/Slope.lean", "Mathlib/Combinatorics/SimpleGraph/Regularity/Uniform.lean", "Mathlib/Data/Finmap.lean", "Mathlib/Data/Real/Sign.lean", "Mathlib/Topology/Instances/Complex.lean", "Mathlib/SetTheory/Game/Short.lean", "Mathlib/NumberTheory/Liouville/LiouvilleWith.lean", "Mathlib/Topology/QuasiSeparated.lean", "Mathlib/LinearAlgebra/QuotientPi.lean", "Mathlib/Tactic/Says.lean", "Mathlib/Data/Int/Cast/Prod.lean", "Mathlib/Analysis/Analytic/Uniqueness.lean", "Mathlib/Analysis/Calculus/Conformal/NormedSpace.lean", "Mathlib/CategoryTheory/Limits/Cones.lean", "Mathlib/RingTheory/Polynomial/IntegralNormalization.lean", "Mathlib/MeasureTheory/Group/GeometryOfNumbers.lean", "Mathlib/Tactic/CasesM.lean", "Mathlib/Algebra/Ring/Defs.lean", "Mathlib/Topology/Category/TopCat/Basic.lean", "Mathlib/Combinatorics/SimpleGraph/Connectivity.lean", "Mathlib/CategoryTheory/Closed/Cartesian.lean", "Mathlib/Data/FunLike/Equiv.lean", "Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "Mathlib/Topology/Partial.lean", "Mathlib/Tactic/NormCast/Tactic.lean", "Mathlib/Data/Finset/PiInduction.lean", "Mathlib/Topology/Algebra/ContinuousAffineMap.lean", "Mathlib/Analysis/Complex/Circle.lean", "Mathlib/CategoryTheory/Limits/EssentiallySmall.lean", "Mathlib/CategoryTheory/Limits/Fubini.lean", "Mathlib/Combinatorics/SetFamily/Compression/Down.lean", "Mathlib/Tactic/Inhabit.lean", "Mathlib/Analysis/InnerProductSpace/LaxMilgram.lean", "Mathlib/CategoryTheory/Enriched/Basic.lean", "Mathlib/Tactic/MoveAdd.lean", "Mathlib/Algebra/MonoidAlgebra/NoZeroDivisors.lean", "Mathlib/Data/Polynomial/Inductions.lean", "Mathlib/GroupTheory/FreeGroup/IsFreeGroup.lean", "Mathlib/Logic/Equiv/Nat.lean", "Mathlib/RepresentationTheory/Character.lean", "Mathlib/RingTheory/Flat.lean", "Mathlib/Algebra/Category/GroupCat/Limits.lean", "Mathlib/Probability/Kernel/Composition.lean", "Mathlib/GroupTheory/PresentedGroup.lean", "Mathlib/RepresentationTheory/GroupCohomology/Basic.lean", "Mathlib/CategoryTheory/Preadditive/Yoneda/Basic.lean", "Mathlib/LinearAlgebra/Eigenspace/Basic.lean", "Mathlib/Analysis/Convex/Measure.lean", "Mathlib/RepresentationTheory/Basic.lean", "Mathlib/RingTheory/Localization/Cardinality.lean", "Mathlib/LinearAlgebra/Matrix/Charpoly/Minpoly.lean", "Mathlib/Combinatorics/Hall/Basic.lean", "Mathlib/CategoryTheory/Whiskering.lean", "Mathlib/Analysis/NormedSpace/Completion.lean", "Mathlib/RingTheory/LaurentSeries.lean", "Mathlib/Init/Control/Combinators.lean", "Mathlib/Algebra/Order/Field/Canonical/Basic.lean", "Mathlib/Data/MvPolynomial/Comap.lean", "Mathlib/Analysis/Normed/Group/SemiNormedGroupCat/Completion.lean", "Mathlib/CategoryTheory/Category/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Category/GroupCat/Zero.lean", "Mathlib/CategoryTheory/Monoidal/Braided.lean", "Mathlib/Data/Nat/Basic.lean", "Mathlib/Data/Sum/Basic.lean", "Mathlib/RingTheory/Localization/Basic.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Conjugation.lean", "Mathlib/GroupTheory/Commensurable.lean", "Mathlib/Combinatorics/SimpleGraph/Regularity/Bound.lean", "Mathlib/Algebra/ContinuedFractions/Basic.lean", "Mathlib/Init/Data/Sigma/Basic.lean", "Mathlib/Tactic/NormNum/LegendreSymbol.lean", "Mathlib/Data/Rbtree/MinMax.lean", "Mathlib/Data/List/Sigma.lean", "Mathlib/CategoryTheory/Limits/FullSubcategory.lean", "Mathlib/Tactic/NormNum/BigOperators.lean", "Mathlib/Tactic/LiftLets.lean", "Mathlib/Algebra/DualNumber.lean", "Mathlib/Data/Fin/FlagRange.lean", "Mathlib/Data/PNat/Basic.lean", "Mathlib/RingTheory/WittVector/MulCoeff.lean", "Mathlib/Algebra/Symmetrized.lean", "Mathlib/CategoryTheory/PEmpty.lean", "Mathlib/GroupTheory/GroupAction/Quotient.lean", "Mathlib/Analysis/Convex/Segment.lean", "Mathlib/Algebra/Ring/Equiv.lean", "Mathlib/CategoryTheory/Limits/Constructions/BinaryProducts.lean", "Mathlib/Order/WellFounded.lean", "Mathlib/Algebra/Quaternion.lean", "Mathlib/Data/Set/Intervals/IsoIoo.lean", "Mathlib/Analysis/NormedSpace/HomeomorphBall.lean", "Mathlib/Algebra/Category/GroupCat/EpiMono.lean", "Mathlib/CategoryTheory/Category/PartialFun.lean", "Mathlib/Data/Fintype/Vector.lean", "Mathlib/Topology/Order/Hom/Basic.lean", "Mathlib/Tactic/NormNum/Eq.lean", "Mathlib/GroupTheory/Perm/ViaEmbedding.lean", "Mathlib/Algebra/Star/Pi.lean", "Mathlib/RingTheory/Subsemiring/Pointwise.lean", "Mathlib/Analysis/Complex/Schwarz.lean", "Mathlib/LinearAlgebra/AdicCompletion.lean", "Mathlib/Algebra/GroupWithZero/Power.lean", "Mathlib/Computability/Partrec.lean", "Mathlib/LinearAlgebra/Charpoly/Basic.lean", "Mathlib/CategoryTheory/Idempotents/Biproducts.lean", "Mathlib/MeasureTheory/Function/SpecialFunctions/IsROrC.lean", "Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean", "Mathlib/Data/Sigma/Basic.lean", "Mathlib/Topology/Algebra/Module/Cardinality.lean", "Mathlib/LinearAlgebra/LinearPMap.lean", "Mathlib/RingTheory/WittVector/Teichmuller.lean", "Mathlib/Order/Height.lean", "Mathlib/CategoryTheory/DifferentialObject.lean", "Mathlib/Mathport/Notation.lean", "Mathlib/Data/Nat/PrimeFin.lean", "Mathlib/MeasureTheory/Function/LpSpace/DomAct/Basic.lean", "Mathlib/Analysis/Calculus/FDeriv/RestrictScalars.lean", "Mathlib/CategoryTheory/Limits/Shapes/StrongEpi.lean", "Mathlib/ModelTheory/Encoding.lean", "Mathlib/MeasureTheory/Integral/FundThmCalculus.lean", "Mathlib/Topology/Gluing.lean", "Mathlib/Data/Nat/PSub.lean", "Mathlib/Analysis/Calculus/FDeriv/Prod.lean", "Mathlib/Algebra/Algebra/Equiv.lean", "Mathlib/Combinatorics/Quiver/Cast.lean", "Mathlib/ModelTheory/Semantics.lean", "Mathlib/Control/Functor.lean", "Mathlib/Data/Multiset/Antidiagonal.lean", "Mathlib/NumberTheory/NumberField/Norm.lean", "Mathlib/Data/Fin/SuccPred.lean", "Mathlib/Control/LawfulFix.lean", "Mathlib/Data/Nat/Choose/Factorization.lean", "Mathlib/Algebra/MonoidAlgebra/Degree.lean", "Mathlib/Order/SupClosed.lean", "Mathlib/Data/Finset/Pairwise.lean", "Mathlib/Data/MLList/Basic.lean", "Mathlib/CategoryTheory/Monoidal/FunctorCategory.lean", "Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean", "Mathlib/Logic/Hydra.lean", "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "Mathlib/CategoryTheory/Functor/Basic.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "Mathlib/NumberTheory/Cyclotomic/Rat.lean", "Mathlib/MeasureTheory/Integral/PeakFunction.lean", "Mathlib/Algebra/Module/PID.lean", "Mathlib/Analysis/SpecialFunctions/CompareExp.lean", "Mathlib/FieldTheory/IntermediateField.lean", "Mathlib/Analysis/Convex/StrictConvexSpace.lean", "Mathlib/MeasureTheory/Covering/Besicovitch.lean", "Mathlib/Control/Monad/Basic.lean", "Mathlib/Algebra/Star/CHSH.lean", "Mathlib/Topology/Algebra/ProperConstSMul.lean", "Mathlib/Tactic/Recall.lean", "Mathlib/CategoryTheory/Subobject/Comma.lean", "Mathlib/Condensed/Equivalence.lean", "Mathlib/Lean/Json.lean", "Mathlib/LinearAlgebra/Matrix/InvariantBasisNumber.lean", "Mathlib/SetTheory/Cardinal/Cofinality.lean", "Mathlib/Analysis/Convex/Independent.lean", "Mathlib/Data/Fin/Interval.lean", "Mathlib/Algebra/Order/Ring/WithTop.lean", "Mathlib/Algebra/Homology/ShortExact/Abelian.lean", "Mathlib/Tactic/Ring/Basic.lean", "Mathlib/Tactic/SudoSetOption.lean", "Mathlib/Data/List/EditDistance/Defs.lean", "Mathlib/Algebra/Ring/Fin.lean", "Mathlib/Probability/ProbabilityMassFunction/Uniform.lean", "Mathlib/Data/Multiset/Basic.lean", "Mathlib/Probability/Variance.lean", "Mathlib/ModelTheory/Graph.lean", "Mathlib/FieldTheory/ChevalleyWarning.lean", "Mathlib/Topology/Category/Stonean/EffectiveEpi.lean", "Mathlib/GroupTheory/GroupAction/DomAct/Basic.lean", "Mathlib/Topology/Homeomorph.lean", "Mathlib/CategoryTheory/Limits/Preserves/FunctorCategory.lean", "Mathlib/Data/Int/Dvd/Basic.lean", "Mathlib/Dynamics/Minimal.lean", "Mathlib/Data/Analysis/Topology.lean", "Mathlib/RingTheory/WittVector/InitTail.lean", "Mathlib/Tactic/Continuity/Init.lean", "Mathlib/CategoryTheory/Sites/Pushforward.lean", "Mathlib/Algebra/CharP/Invertible.lean", "Mathlib/Probability/Kernel/Invariance.lean", "Mathlib/Init/Data/Option/Init/Lemmas.lean", "Mathlib/Data/Nat/Parity.lean", "Mathlib/Algebra/AddTorsor.lean", "Mathlib/Data/QPF/Multivariate/Constructions/Prj.lean", "Mathlib/Topology/Algebra/StarSubalgebra.lean", "Mathlib/Algebra/GroupPower/Ring.lean", "Mathlib/Data/Multiset/Sum.lean", "Mathlib/CategoryTheory/Balanced.lean", "Mathlib/Algebra/Group/Semiconj/Defs.lean", "Mathlib/Algebra/GradedMonoid.lean", "Mathlib/RingTheory/WittVector/Verschiebung.lean", "Mathlib/Probability/ProbabilityMassFunction/Monad.lean", "Mathlib/Tactic/CategoryTheory/Slice.lean", "Mathlib/Data/Sigma/Order.lean", "Mathlib/LinearAlgebra/QuadraticForm/Prod.lean", "Mathlib/Algebra/Field/IsField.lean", "Mathlib/Lean/System/IO.lean", "Mathlib/Algebra/Hom/Group/Basic.lean", "Mathlib/Geometry/Manifold/Algebra/Structures.lean", "Mathlib/AlgebraicGeometry/Pullbacks.lean", "Mathlib/FieldTheory/MvPolynomial.lean", "Mathlib/Init/Data/List/Instances.lean", "Mathlib/LinearAlgebra/Matrix/Polynomial.lean", "Mathlib/Order/Extension/Linear.lean", "Mathlib/Topology/GDelta.lean", "Mathlib/Topology/UniformSpace/CompareReals.lean", "Mathlib/Topology/Sets/Compacts.lean", "Mathlib/RingTheory/Polynomial/Cyclotomic/Expand.lean", "Mathlib/Topology/Homotopy/Basic.lean", "Mathlib/Data/Vector3.lean", "Mathlib/Analysis/Calculus/Deriv/Pow.lean", "Mathlib/CategoryTheory/Functor/Hom.lean", "Mathlib/Topology/UniformSpace/UniformConvergence.lean", "Mathlib/Geometry/Euclidean/Inversion/Calculus.lean", "Mathlib/GroupTheory/GroupAction/SubMulAction.lean", "Mathlib/Topology/Algebra/GroupWithZero.lean", "Mathlib/NumberTheory/KummerDedekind.lean", "Mathlib/Data/Set/Intervals/ProjIcc.lean", "Mathlib/SetTheory/Game/Domineering.lean", "Mathlib/Topology/Algebra/UniformFilterBasis.lean", "Mathlib/Init/Classes/Order.lean", "Mathlib/CategoryTheory/Monad/Types.lean", "Mathlib/Tactic/GCongr/ForwardAttr.lean", "Mathlib/Analysis/Fourier/RiemannLebesgueLemma.lean", "Mathlib/RingTheory/Localization/NormTrace.lean", "Mathlib/RingTheory/MvPolynomial/Symmetric.lean", "Mathlib/Algebra/Star/NonUnitalSubalgebra.lean", "Mathlib/CategoryTheory/Limits/Constructions/Over/Connected.lean", "Mathlib/CategoryTheory/Monoidal/Mod_.lean", "Mathlib/Data/Nat/Digits.lean", "Mathlib/GroupTheory/Congruence.lean", "Mathlib/Data/Nat/Order/Basic.lean", "Mathlib/ModelTheory/Basic.lean", "Mathlib/CategoryTheory/Preadditive/AdditiveFunctor.lean", "Mathlib/Tactic/Coe.lean", "Mathlib/LinearAlgebra/Vandermonde.lean", "Mathlib/Tactic/UnsetOption.lean", "Mathlib/Data/List/MinMax.lean", "Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "Mathlib/Combinatorics/Derangements/Basic.lean", "Mathlib/Order/Monotone/Monovary.lean", "Mathlib/RingTheory/MvPolynomial/Basic.lean", "Mathlib/Algebra/Ring/ULift.lean", "Mathlib/Data/Fintype/Sum.lean", "Mathlib/Analysis/Normed/Group/Hom.lean", "Mathlib/Data/Finset/Fold.lean", "Mathlib/Data/Fintype/CardEmbedding.lean", "Mathlib/Init/Order/Defs.lean", "Mathlib/Order/Atoms.lean", "Mathlib/Topology/Algebra/InfiniteSum/Module.lean", "Mathlib/Algebra/Category/GroupCat/Injective.lean", "Mathlib/CategoryTheory/Bicategory/IsKan.lean", "Mathlib/CategoryTheory/Limits/Constructions/EpiMono.lean", "Mathlib/Geometry/Manifold/MFDeriv.lean", "Mathlib/Init/Data/Nat/GCD.lean", "Mathlib/MeasureTheory/Integral/BoundedContinuousFunction.lean", "Mathlib/Analysis/Convex/Star.lean", "Mathlib/Order/OrdContinuous.lean", "Mathlib/CategoryTheory/Thin.lean", "Mathlib/Data/QPF/Multivariate/Constructions/Comp.lean", "Mathlib/Topology/EMetricSpace/Basic.lean", "Mathlib/Combinatorics/Quiver/Arborescence.lean", "Mathlib/Data/FunLike/Fintype.lean", "Mathlib/Lean/Message.lean", "Mathlib/RingTheory/NonZeroDivisors.lean", "Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean", "Mathlib/Algebra/Category/ModuleCat/Monoidal/Symmetric.lean", "Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "Mathlib/Tactic/ExtractGoal.lean", "Mathlib/Combinatorics/Quiver/ConnectedComponent.lean", "Mathlib/CategoryTheory/Monoidal/Center.lean", "Mathlib/CategoryTheory/Monoidal/Tor.lean", "Mathlib/Combinatorics/Additive/RuzsaCovering.lean", "Mathlib/Util/CountHeartbeats.lean", "Mathlib/Data/Fintype/Powerset.lean", "Mathlib/LinearAlgebra/BilinearForm.lean", "Mathlib/Data/Fintype/Pi.lean", "Mathlib/CategoryTheory/Limits/Shapes/SplitCoequalizer.lean", "Mathlib/Topology/Instances/ENNReal.lean", "Mathlib/Topology/Hom/Open.lean", "Mathlib/Combinatorics/DoubleCounting.lean", "Mathlib/CategoryTheory/Closed/Ideal.lean", "Mathlib/Lean/EnvExtension.lean", "Mathlib/MeasureTheory/Function/StronglyMeasurable/Lp.lean", "Mathlib/MeasureTheory/Constructions/Prod/Basic.lean", "Mathlib/AlgebraicTopology/DoldKan/Compatibility.lean", "Mathlib/NumberTheory/Pell.lean", "Mathlib/Analysis/Convex/Extreme.lean", "Mathlib/Order/Filter/Pi.lean", "Mathlib/RingTheory/Multiplicity.lean", "Mathlib/Analysis/InnerProductSpace/Symmetric.lean", "Mathlib/AlgebraicGeometry/StructureSheaf.lean", "Mathlib/Order/Category/HeytAlg.lean", "Mathlib/MeasureTheory/Covering/VitaliFamily.lean", "Mathlib/Data/Nat/Choose/Sum.lean", "Mathlib/CategoryTheory/GradedObject.lean", "Mathlib/Algebra/Order/Group/MinMax.lean", "Mathlib/Tactic/SuppressCompilation.lean", "Mathlib/Analysis/Complex/Liouville.lean", "Mathlib/NumberTheory/NumberField/Discriminant.lean", "Mathlib/Algebra/Category/GroupCat/Abelian.lean", "Mathlib/GroupTheory/Subgroup/Finite.lean", "Mathlib/Data/List/NodupEquivFin.lean", "Mathlib/Algebra/Field/Defs.lean", "Mathlib/Tactic/TFAE.lean", "Mathlib/Analysis/Complex/Arg.lean", "Mathlib/RingTheory/DedekindDomain/SelmerGroup.lean", "Mathlib/Topology/ContinuousFunction/Compact.lean", "Mathlib/Util/AtomM.lean", "Mathlib/Data/Rbmap/Basic.lean", "Mathlib/RingTheory/IsTensorProduct.lean", "Mathlib/Data/Array/Basic.lean", "Mathlib/Topology/Algebra/Order/Rolle.lean", "Mathlib/MeasureTheory/Tactic.lean", "Mathlib/Tactic/Trace.lean", "Mathlib/GroupTheory/GroupAction/Pi.lean", "Mathlib/Geometry/Manifold/LocalInvariantProperties.lean", "Mathlib/Topology/Category/Profinite/CofilteredLimit.lean", "Mathlib/Order/SuccPred/IntervalSucc.lean", "Mathlib/Analysis/SumIntegralComparisons.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Images.lean", "Mathlib/MeasureTheory/Measure/Haar/OfBasis.lean", "Mathlib/Algebra/Category/MonCat/Basic.lean", "Mathlib/CategoryTheory/Adjunction/Reflective.lean", "Mathlib/Data/Quot.lean", "Mathlib/Data/Set/Intervals/Pi.lean", "Mathlib/Algebra/Order/Sub/WithTop.lean", "Mathlib/Data/Rat/Sqrt.lean", "Mathlib/FieldTheory/PrimitiveElement.lean", "Mathlib/GroupTheory/HNNExtension.lean", "Mathlib/SetTheory/Ordinal/Exponential.lean", "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean", "Mathlib/FieldTheory/Finite/Basic.lean", "Mathlib/Data/Int/CharZero.lean", "Mathlib/Analysis/Normed/Ring/Seminorm.lean", "Mathlib/Data/Multiset/Bind.lean", "Mathlib/Algebra/Star/Center.lean", "Mathlib/MeasureTheory/Constructions/Polish.lean", "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "Mathlib/NumberTheory/Modular.lean", "Mathlib/Order/Disjoint.lean", "Mathlib/SetTheory/ZFC/Ordinal.lean", "Mathlib/Topology/LocalAtTarget.lean", "Mathlib/CategoryTheory/Preadditive/Yoneda/Projective.lean", "Mathlib/GroupTheory/Transfer.lean", "Mathlib/Topology/StoneCech.lean", "Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean", "Mathlib/Tactic/Zify.lean", "Mathlib/Topology/Homotopy/Product.lean", "Mathlib/Data/QPF/Multivariate/Constructions/Fix.lean", "Mathlib/Analysis/Convex/Integral.lean", "Mathlib/RingTheory/Derivation/ToSquareZero.lean", "Mathlib/Order/Ideal.lean", "Mathlib/NumberTheory/PrimeCounting.lean", "Mathlib/Data/Polynomial/Identities.lean", "Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/GaussSum.lean", "Mathlib/MeasureTheory/Integral/CircleTransform.lean", "Mathlib/Algebra/EuclideanDomain/Defs.lean", "Mathlib/Algebra/Module/Projective.lean", "Mathlib/Order/Grade.lean", "Mathlib/Analysis/Analytic/RadiusLiminf.lean", "Mathlib/Topology/Category/Stonean/Adjunctions.lean", "Mathlib/Computability/EpsilonNFA.lean", "Mathlib/CategoryTheory/Functor/FullyFaithful.lean", "Mathlib/Topology/Algebra/OpenSubgroup.lean", "Mathlib/Data/Set/Pairwise/Lattice.lean", "Mathlib/NumberTheory/LegendreSymbol/Basic.lean", "Mathlib/Algebra/Star/StarAlgHom.lean", "Mathlib/Data/ZMod/Defs.lean", "Mathlib/LinearAlgebra/FinsuppVectorSpace.lean", "Mathlib/RingTheory/Localization/NumDen.lean", "Mathlib/Topology/Algebra/UniformField.lean", "Mathlib/Data/TypeMax.lean", "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "Mathlib/CategoryTheory/Category/RelCat.lean", "Mathlib/NumberTheory/Padics/PadicVal.lean", "Mathlib/Order/Hom/Basic.lean", "Mathlib/Init/Set.lean", "Mathlib/Algebra/Order/Group/Instances.lean", "Mathlib/Analysis/Convex/Quasiconvex.lean", "Mathlib/Analysis/Convex/Gauge.lean", "Mathlib/Data/Matrix/Basic.lean", "Mathlib/RingTheory/Polynomial/Tower.lean", "Mathlib/GroupTheory/Submonoid/Pointwise.lean", "Mathlib/LinearAlgebra/Prod.lean", "Mathlib/Data/MLList/BestFirst.lean", "Mathlib/Analysis/Calculus/ContDiff.lean", "Mathlib/Analysis/SpecificLimits/FloorPow.lean", "Mathlib/Algebra/Algebra/Subalgebra/Pointwise.lean", "Mathlib/CategoryTheory/Sums/Associator.lean", "Mathlib/Data/PFunctor/Multivariate/Basic.lean", "Mathlib/Data/Rat/NNRat.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "Mathlib/Data/Vector/Snoc.lean", "Mathlib/Order/Filter/NAry.lean", "Mathlib/RingTheory/IntegralDomain.lean", "Mathlib/ModelTheory/Syntax.lean", "Mathlib/Analysis/Calculus/FormalMultilinearSeries.lean", "Mathlib/Data/Set/Intervals/Disjoint.lean", "Mathlib/Topology/EMetricSpace/Paracompact.lean", "Mathlib/Analysis/VonNeumannAlgebra/Basic.lean", "Mathlib/Algebra/Regular/Basic.lean", "Mathlib/Algebra/Lie/BaseChange.lean", "Mathlib/Analysis/Normed/Group/Seminorm.lean", "Mathlib/LinearAlgebra/QuadraticForm/TensorProduct/Isometries.lean", "Mathlib/Tactic/RunCmd.lean", "Mathlib/Analysis/Normed/Group/InfiniteSum.lean", "Mathlib/Analysis/Convex/SpecificFunctions/Basic.lean", "Mathlib/RingTheory/Subring/Pointwise.lean", "Mathlib/Topology/Sheaves/SheafCondition/UniqueGluing.lean", "Mathlib/SetTheory/Cardinal/Continuum.lean", "Mathlib/AlgebraicTopology/SimplicialSet.lean", "Mathlib/Geometry/Euclidean/Inversion/ImageHyperplane.lean", "Mathlib/Topology/MetricSpace/Holder.lean", "Mathlib/Data/Nat/Prime.lean", "Mathlib/RingTheory/Perfection.lean", "Mathlib/Order/PartialSups.lean", "Mathlib/Data/Set/Basic.lean", "Mathlib/Algebra/CharP/LocalRing.lean", "Mathlib/Algebra/BigOperators/RingEquiv.lean", "Mathlib/Data/ByteArray.lean", "Mathlib/CategoryTheory/Monoidal/Internal/FunctorCategory.lean", "Mathlib/CategoryTheory/Sites/Coverage.lean", "Mathlib/CategoryTheory/Sites/Sieves.lean", "Mathlib/Tactic/Polyrith.lean", "Mathlib/Control/Random.lean", "Mathlib/Topology/Category/UniformSpace.lean", "Mathlib/CategoryTheory/Abelian/Transfer.lean", "Mathlib/Algebra/GroupWithZero/Defs.lean", "Mathlib/LinearAlgebra/Matrix/Diagonal.lean", "Mathlib/Data/List/ToFinsupp.lean", "Mathlib/Util/DischargerAsTactic.lean", "Mathlib/Topology/FiberBundle/Constructions.lean", "Mathlib/Data/Fintype/Small.lean", "Mathlib/CategoryTheory/Abelian/Projective.lean", "Mathlib/Algebra/BigOperators/Intervals.lean", "Mathlib/Tactic/IntervalCases.lean", "Mathlib/Topology/Sheaves/PUnit.lean", "Mathlib/Data/Matrix/Notation.lean", "Mathlib/CategoryTheory/Limits/Lattice.lean", "Mathlib/GroupTheory/Index.lean", "Mathlib/RingTheory/Localization/FractionRing.lean", "Mathlib/Algebra/CharP/Quotient.lean", "Mathlib/Algebra/DirectSum/Module.lean", "Mathlib/Data/Real/ENatENNReal.lean", "Mathlib/MeasureTheory/Measure/Haar/NormedSpace.lean", "Mathlib/NumberTheory/Cyclotomic/Basic.lean", "Mathlib/Init/Data/List/Basic.lean", "Mathlib/Algebra/Hom/Ring/Basic.lean", "Mathlib/Algebra/Homology/DifferentialObject.lean", "Mathlib/GroupTheory/Submonoid/Basic.lean", "Mathlib/Order/Antichain.lean", "Mathlib/Combinatorics/SimpleGraph/Ends/Defs.lean", "Mathlib/CategoryTheory/Sites/DenseSubsite.lean", "Mathlib/Algebra/Ring/Basic.lean", "Mathlib/Data/List/Join.lean", "Mathlib/AlgebraicGeometry/PrimeSpectrum/IsOpenComapC.lean", "Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean", "Mathlib/Analysis/Calculus/Inverse.lean", "Mathlib/Combinatorics/Pigeonhole.lean", "Mathlib/Data/Real/Pi/Leibniz.lean", "Mathlib/Geometry/Manifold/VectorBundle/Tangent.lean", "Mathlib/Tactic/Positivity/Core.lean", "Mathlib/NumberTheory/NumberField/CanonicalEmbedding.lean", "Mathlib/Algebra/Order/Sub/Basic.lean", "Mathlib/Tactic/TermCongr.lean", "Mathlib/Algebra/Order/Group/Bounds.lean", "Mathlib/Order/RelIso/Basic.lean", "Mathlib/Analysis/NormedSpace/DualNumber.lean", "Mathlib/Topology/Sheaves/SheafCondition/PairwiseIntersections.lean", "Mathlib/AlgebraicTopology/DoldKan/NReflectsIso.lean", "Mathlib/Data/ZMod/Units.lean", "Mathlib/Data/Matrix/CharP.lean", "Mathlib/Init/Classical.lean", "Mathlib/Tactic/RSuffices.lean", "Mathlib/NumberTheory/NumberField/Embeddings.lean", "Mathlib/Data/Nat/ModEq.lean", "Mathlib/Tactic/Basic.lean", "Mathlib/Analysis/Convex/PartitionOfUnity.lean", "Mathlib/Data/List/Basic.lean", "Mathlib/AlgebraicTopology/DoldKan/Decomposition.lean", "Mathlib/Algebra/Lie/Free.lean", "Mathlib/Geometry/RingedSpace/PresheafedSpace.lean", "Mathlib/Topology/Algebra/Affine.lean", "Mathlib/Algebra/Order/Group/TypeTags.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean", "Mathlib/Logic/Relator.lean", "Mathlib/RingTheory/Valuation/Integral.lean", "Mathlib/RingTheory/Nullstellensatz.lean", "Mathlib/NumberTheory/FrobeniusNumber.lean", "Mathlib/CategoryTheory/Abelian/DiagramLemmas/Four.lean", "Mathlib/Algebra/Group/Commutator.lean", "Mathlib/Data/Sum/Order.lean", "Mathlib/Algebra/Regular/Pow.lean", "Mathlib/Topology/Algebra/Ring/Ideal.lean", "Mathlib/Algebra/Order/Kleene.lean", "Mathlib/CategoryTheory/Limits/Bicones.lean", "Mathlib/Analysis/Analytic/Inverse.lean", "Mathlib/SetTheory/Ordinal/NaturalOps.lean", "Mathlib/Logic/Equiv/Fintype.lean", "Mathlib/Algebra/GroupPower/Basic.lean", "Mathlib/Algebra/Associated.lean", "Mathlib/Topology/ContinuousFunction/Polynomial.lean", "Mathlib/Geometry/Euclidean/Angle/Sphere.lean", "Mathlib/NumberTheory/ClassNumber/Finite.lean", "Mathlib/Analysis/NormedSpace/Connected.lean", "Mathlib/Data/DList/Basic.lean", "Mathlib/RingTheory/Ideal/AssociatedPrime.lean", "Mathlib/MeasureTheory/Function/Jacobian.lean", "Mathlib/CategoryTheory/Sums/Basic.lean", "Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "Mathlib/LinearAlgebra/Lagrange.lean", "Mathlib/Algebra/Homology/ShortComplex/Limits.lean", "Mathlib/Algebra/GroupWithZero/NeZero.lean", "Mathlib/ModelTheory/Substructures.lean", "Mathlib/Data/Vector.lean", "Mathlib/Topology/LocallyConstant/Algebra.lean", "Mathlib/RingTheory/Polynomial/RationalRoot.lean", "Mathlib/Testing/SlimCheck/Testable.lean", "Mathlib/CategoryTheory/Monoidal/CommMon_.lean", "Mathlib/Algebra/CharP/ExpChar.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Even.lean", "Mathlib/Algebra/Homology/ShortComplex/Exact.lean", "Mathlib/Topology/OmegaCompletePartialOrder.lean", "Mathlib/Data/Finset/Preimage.lean", "Mathlib/Geometry/Manifold/Algebra/LeftInvariantDerivation.lean", "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean", "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "Mathlib/CategoryTheory/Generator.lean", "Mathlib/Tactic/Ring.lean", "Mathlib/Algebra/GCDMonoid/Multiset.lean", "Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean", "Mathlib/Order/PFilter.lean", "Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "Mathlib/Tactic/CategoryTheory/BicategoryCoherence.lean", "Mathlib/Topology/Algebra/WithZeroTopology.lean", "Mathlib/GroupTheory/GroupAction/Support.lean", "Mathlib/Algebra/Module/BigOperators.lean", "Mathlib/AlgebraicTopology/DoldKan/GammaCompN.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Data/Finset/PImage.lean", "Mathlib/CategoryTheory/Preadditive/ProjectiveResolution.lean", "Mathlib/Tactic/ComputeDegree.lean", "Mathlib/Init/Logic.lean", "Mathlib/Geometry/Manifold/ChartedSpace.lean", "Mathlib/LinearAlgebra/PerfectPairing.lean", "Mathlib/Data/MvPolynomial/Expand.lean", "Mathlib/AlgebraicGeometry/AffineScheme.lean", "Mathlib/Data/Fintype/Order.lean", "Mathlib/CategoryTheory/Category/Pairwise.lean", "Mathlib/MeasureTheory/Measure/Dirac.lean", "Mathlib/Algebra/Module/Zlattice.lean", "Mathlib/Algebra/Algebra/Prod.lean", "Mathlib/Analysis/Convex/Jensen.lean", "Mathlib/Init/Data/Nat/Lemmas.lean", "Mathlib/Data/Polynomial/EraseLead.lean", "Mathlib/RingTheory/FreeRing.lean", "Mathlib/LinearAlgebra/Multilinear/TensorProduct.lean", "Mathlib/CategoryTheory/Sites/CoverPreserving.lean", "Mathlib/Tactic/Relation/Rfl.lean", "Mathlib/Tactic/TypeCheck.lean", "Mathlib/GroupTheory/OrderOfElement.lean", "Mathlib/MeasureTheory/Measure/Haar/Quotient.lean", "Mathlib/Data/Set/Intervals/Group.lean", "Mathlib/Algebra/Homology/Opposite.lean", "Mathlib/Topology/Instances/Rat.lean", "Mathlib/Control/Bitraversable/Lemmas.lean", "Mathlib/Algebra/Ring/Regular.lean", "Mathlib/Data/Finsupp/Defs.lean", "Mathlib/RingTheory/GradedAlgebra/Basic.lean", "Mathlib/Tactic/NormNum/Basic.lean", "Mathlib/Data/Fin/VecNotation.lean", "Mathlib/Topology/LocallyFinite.lean", "Mathlib/Algebra/Category/GroupCat/Preadditive.lean", "Mathlib/LinearAlgebra/Matrix/Trace.lean", "Mathlib/LinearAlgebra/StdBasis.lean", "Mathlib/GroupTheory/Subgroup/Simple.lean", "Mathlib/LinearAlgebra/Quotient.lean", "Mathlib/Analysis/NormedSpace/HahnBanach/SeparatingDual.lean", "Mathlib/Analysis/Calculus/LineDeriv/Measurable.lean", "Mathlib/Analysis/NormedSpace/QuaternionExponential.lean", "Mathlib/Topology/DenseEmbedding.lean", "Mathlib/CategoryTheory/Closed/Zero.lean", "Mathlib/Dynamics/Ergodic/MeasurePreserving.lean", "Mathlib/LinearAlgebra/Multilinear/Basis.lean", "Mathlib/Algebra/Homology/Functor.lean", "Mathlib/Data/Nat/Nth.lean", "Mathlib/Data/Real/Pointwise.lean", "Mathlib/Analysis/LocallyConvex/WeakDual.lean", "Mathlib/Data/Polynomial/Derivation.lean", "Mathlib/Analysis/Calculus/FDeriv/Measurable.lean", "Mathlib/Data/Nat/Cast/Order.lean", "Mathlib/Order/Concept.lean", "Mathlib/Data/Nat/Choose/Cast.lean", "Mathlib/Analysis/SpecialFunctions/Integrals.lean", "Mathlib/Topology/Algebra/Order/T5.lean", "Mathlib/Data/Seq/Parallel.lean", "Mathlib/Topology/Order/Basic.lean", "Mathlib/LinearAlgebra/Matrix/Circulant.lean", "Mathlib/Algebra/Ring/AddAut.lean", "Mathlib/LinearAlgebra/QuadraticForm/TensorProduct.lean", "Mathlib/Data/Set/Intervals/OrdConnectedComponent.lean", "Mathlib/Data/MvPolynomial/CommRing.lean", "Mathlib/Data/Set/NAry.lean", "Mathlib/RingTheory/QuotientNoetherian.lean", "Mathlib/CategoryTheory/NatIso.lean", "Mathlib/CategoryTheory/Bicategory/NaturalTransformation.lean", "Mathlib/Data/Nat/Interval.lean", "Mathlib/LinearAlgebra/UnitaryGroup.lean", "Mathlib/Analysis/NormedSpace/ContinuousLinearMap.lean", "Mathlib/CategoryTheory/Limits/Constructions/Equalizers.lean", "Mathlib/Algebra/Order/Monoid/WithTop.lean", "Mathlib/NumberTheory/FLT/Four.lean", "Mathlib/CategoryTheory/Preadditive/Projective.lean", "Mathlib/GroupTheory/CoprodI.lean", "Mathlib/Order/Heyting/Regular.lean", "Mathlib/NumberTheory/Padics/PadicNorm.lean", "Mathlib/Data/Polynomial/AlgebraMap.lean", "Mathlib/Algebra/Hom/Units.lean", "Mathlib/Analysis/Convex/Cone/Proper.lean", "Mathlib/LinearAlgebra/QuadraticForm/Isometry.lean", "Mathlib/CategoryTheory/Opposites.lean", "Mathlib/Topology/ContinuousFunction/Weierstrass.lean", "Mathlib/Data/Rat/Denumerable.lean", "Mathlib/Tactic/Widget/SelectPanelUtils.lean", "Mathlib/Logic/Lemmas.lean", "Mathlib/Algebra/Jordan/Basic.lean", "Mathlib/Tactic/Linarith.lean", "Mathlib/Data/Char.lean", "Mathlib/Logic/Equiv/Embedding.lean", "Mathlib/Data/Finset/Card.lean", "Mathlib/Data/Nat/Choose/Multinomial.lean", "Mathlib/Topology/Algebra/Module/LinearPMap.lean", "Mathlib/Data/Fin/Tuple/NatAntidiagonal.lean", "Mathlib/Data/List/AList.lean", "Mathlib/Data/Nat/Bits.lean", "Mathlib/MeasureTheory/Function/SpecialFunctions/Basic.lean", "Mathlib/Data/Vector/MapLemmas.lean", "Mathlib/LinearAlgebra/Multilinear/Basic.lean", "Mathlib/NumberTheory/Padics/Harmonic.lean", "Mathlib/CategoryTheory/Category/Cat.lean", "Mathlib/Data/MvPolynomial/Cardinal.lean", "Mathlib/Algebra/Module/Algebra.lean", "Mathlib/Data/Bundle.lean", "Mathlib/Logic/Function/OfArity.lean", "Mathlib/Order/Directed.lean", "Mathlib/Analysis/Calculus/Rademacher.lean", "Mathlib/Algebra/Group/Commute/Defs.lean", "Mathlib/CategoryTheory/Limits/Presheaf.lean", "Mathlib/Data/Nat/Cast/WithTop.lean", "Mathlib/Topology/Algebra/Localization.lean", "Mathlib/Init/Order/LinearOrder.lean", "Mathlib/Probability/ConditionalExpectation.lean", "Mathlib/Data/Nat/Pow.lean", "Mathlib/Analysis/Fourier/FourierTransform.lean", "Mathlib/Algebra/PUnitInstances.lean", "Mathlib/Init/Data/Quot.lean", "Mathlib/CategoryTheory/Monoidal/Types/Coyoneda.lean", "Mathlib/Analysis/Calculus/BumpFunction/Normed.lean", "Mathlib/Algebra/Order/Group/WithTop.lean", "Mathlib/Data/Nat/EvenOddRec.lean", "Mathlib/MeasureTheory/Group/Action.lean", "Mathlib/LinearAlgebra/FreeModule/Finite/Basic.lean", "Mathlib/FieldTheory/SplittingField/Construction.lean", "Mathlib/Order/Compare.lean", "Mathlib/Data/Nat/Pairing.lean", "Mathlib/Data/Matrix/PEquiv.lean", "Mathlib/Control/Traversable/Equiv.lean", "Mathlib/Algebra/FreeMonoid/Basic.lean", "Mathlib/Geometry/RingedSpace/Basic.lean", "Mathlib/GroupTheory/Subsemigroup/Operations.lean", "Mathlib/Logic/Small/Basic.lean", "Mathlib/RingTheory/WittVector/Compare.lean", "Mathlib/Data/Nondet/Basic.lean", "Mathlib/CategoryTheory/CatCommSq.lean", "Mathlib/RingTheory/QuotientNilpotent.lean", "Mathlib/Data/Set/Pointwise/Iterate.lean", "Mathlib/MeasureTheory/Group/Prod.lean", "Mathlib/CategoryTheory/Triangulated/Triangulated.lean", "Mathlib/LinearAlgebra/SesquilinearForm.lean", "Mathlib/RingTheory/AlgebraTower.lean", "Mathlib/AlgebraicGeometry/Scheme.lean", "Mathlib/Algebra/Homology/Augment.lean", "Mathlib/CategoryTheory/EssentialImage.lean", "Mathlib/RingTheory/Polynomial/Hermite/Basic.lean", "Mathlib/Tactic/Cache.lean", "Mathlib/Algebra/Order/Group/Prod.lean", "Mathlib/Data/QPF/Multivariate/Constructions/Quot.lean", "Mathlib/Analysis/Convex/Contractible.lean", "Mathlib/Data/MvPolynomial/Supported.lean", "Mathlib/FieldTheory/Finiteness.lean", "Mathlib/Analysis/NormedSpace/Star/Basic.lean", "Mathlib/SetTheory/Surreal/Dyadic.lean", "Mathlib/Algebra/Order/Nonneg/Field.lean", "Mathlib/Algebra/Category/ModuleCat/Monoidal/Basic.lean", "Mathlib/Analysis/Calculus/BumpFunction/InnerProduct.lean", "Mathlib/Data/Sum/Interval.lean", "Mathlib/Topology/Compactness/Paracompact.lean", "Mathlib/CategoryTheory/Idempotents/FunctorCategories.lean", "Mathlib/AlgebraicTopology/DoldKan/Notations.lean", "Mathlib/CategoryTheory/Linear/FunctorCategory.lean", "Mathlib/Topology/Algebra/Ring/Basic.lean", "Mathlib/Topology/ExtendFrom.lean", "Mathlib/CategoryTheory/Limits/Filtered.lean", "Mathlib/Combinatorics/SimpleGraph/Coloring.lean", "Mathlib/CategoryTheory/Sites/Surjective.lean", "Mathlib/Tactic/Qify.lean", "Mathlib/Topology/Compactification/OnePoint.lean", "Mathlib/LinearAlgebra/Matrix/Nondegenerate.lean", "Mathlib/Order/Max.lean", "Mathlib/RingTheory/Localization/LocalizationLocalization.lean", "Mathlib/Topology/MetricSpace/Completion.lean", "Mathlib/Data/Polynomial/FieldDivision.lean", "Mathlib/RingTheory/WittVector/StructurePolynomial.lean", "Mathlib/Analysis/InnerProductSpace/LinearPMap.lean", "Mathlib/Tactic/Measurability.lean", "Mathlib/CategoryTheory/Monoidal/Opposite.lean", "Mathlib/Order/CompleteBooleanAlgebra.lean", "Mathlib/Algebra/Order/Nonneg/Module.lean", "Mathlib/AlgebraicTopology/SimplicialObject.lean", "Mathlib/Analysis/LocallyConvex/Bounded.lean", "Mathlib/Analysis/Calculus/LocalExtr/Polynomial.lean", "Mathlib/Data/List/EditDistance/Estimator.lean", "Mathlib/Algebra/CharP/MixedCharZero.lean", "Mathlib/CategoryTheory/Monad/Limits.lean", "Mathlib/Data/Nat/Factorial/DoubleFactorial.lean", "Mathlib/Topology/ContinuousFunction/Units.lean", "Mathlib/MeasureTheory/Covering/OneDim.lean", "Mathlib/Algebra/Order/Group/DenselyOrdered.lean", "Mathlib/Data/Polynomial/Splits.lean", "Mathlib/Algebra/Category/FGModuleCat/Limits.lean", "Mathlib/Topology/MetricSpace/CauSeqFilter.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/BaseChange.lean", "Mathlib/Analysis/Normed/MulAction.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/CategoryTheory.lean", "Mathlib/Topology/Algebra/ValuedField.lean", "Mathlib/Data/Multiset/NatAntidiagonal.lean", "Mathlib/Control/Monad/Writer.lean", "Mathlib/Order/Hom/Set.lean", "Mathlib/Init/Data/List/Lemmas.lean", "Mathlib/Order/LatticeIntervals.lean", "Mathlib/MeasureTheory/Covering/Vitali.lean", "Mathlib/Algebra/Order/Floor.lean", "Mathlib/Data/Set/Pointwise/Finite.lean", "Mathlib/Lean/Meta/CongrTheorems.lean", "Mathlib/Topology/UrysohnsLemma.lean", "Mathlib/Algebra/RingQuot.lean", "Mathlib/Algebra/Order/Pointwise.lean", "Mathlib/CategoryTheory/Monad/EquivMon.lean", "Mathlib/Analysis/Complex/CauchyIntegral.lean", "Mathlib/RingTheory/Congruence.lean", "Mathlib/RingTheory/PowerSeries/WellKnown.lean", "Mathlib/Data/Finsupp/Fintype.lean", "Mathlib/MeasureTheory/Measure/Complex.lean", "Mathlib/Algebra/Invertible/Basic.lean", "Mathlib/CategoryTheory/FintypeCat.lean", "Mathlib/NumberTheory/Liouville/Measure.lean", "Mathlib/GroupTheory/Subsemigroup/Center.lean", "Mathlib/Order/Antisymmetrization.lean", "Mathlib/Algebra/Hom/Embedding.lean", "Mathlib/Data/Nat/Factorization/Basic.lean", "Mathlib/Data/PNat/Defs.lean", "Mathlib/GroupTheory/GroupAction/Sigma.lean", "Mathlib/NumberTheory/Cyclotomic/Discriminant.lean", "Mathlib/CategoryTheory/GlueData.lean", "Mathlib/Probability/Notation.lean", "Mathlib/Tactic/Recover.lean", "Mathlib/Algebra/Quotient.lean", "Mathlib/CategoryTheory/ConcreteCategory/Basic.lean", "Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "Mathlib/LinearAlgebra/Matrix/Dual.lean", "Mathlib/RingTheory/EisensteinCriterion.lean", "Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean", "Mathlib/Data/Setoid/Basic.lean", "Mathlib/Analysis/NormedSpace/Multilinear.lean", "Mathlib/Combinatorics/Derangements/Exponential.lean", "Mathlib/MeasureTheory/Integral/Indicator.lean", "Mathlib/Logic/Equiv/TransferInstance.lean", "Mathlib/LinearAlgebra/Trace.lean", "Mathlib/Tactic/DeriveFintype.lean", "Mathlib/Topology/UniformSpace/Compact.lean", "Mathlib/Analysis/Convex/KreinMilman.lean", "Mathlib/Topology/UniformSpace/Basic.lean", "Mathlib/Order/SuccPred/LinearLocallyFinite.lean", "Mathlib/Data/Fin/Tuple/Monotone.lean", "Mathlib/Order/Partition/Finpartition.lean", "Mathlib/Init/Data/Bool/Basic.lean", "Mathlib/RingTheory/Complex.lean", "Mathlib/RingTheory/Ideal/Over.lean", "Mathlib/Algebra/Group/WithOne/Basic.lean", "Mathlib/Data/Nat/Size.lean", "Mathlib/Topology/Sheaves/Abelian.lean", "Mathlib/CategoryTheory/Monoidal/Internal/Limits.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/Metric.lean", "Mathlib/Topology/Bornology/Hom.lean", "Mathlib/Order/ModularLattice.lean", "Mathlib/Algebra/ContinuedFractions/Computation/CorrectnessTerminating.lean", "Mathlib/CategoryTheory/Functor/Category.lean", "Mathlib/NumberTheory/Zsqrtd/Basic.lean", "Mathlib/Combinatorics/Derangements/Finite.lean", "Mathlib/RingTheory/AdjoinRoot.lean", "Mathlib/Data/Finsupp/Notation.lean", "Mathlib/Logic/Denumerable.lean", "Mathlib/Tactic/Rename.lean", "Mathlib/Probability/Distributions/Gaussian.lean", "Mathlib/LinearAlgebra/Alternating/Basic.lean", "Mathlib/RingTheory/Adjoin/Tower.lean", "Mathlib/Computability/RegularExpressions.lean", "Mathlib/Topology/UniformSpace/CompleteSeparated.lean", "Mathlib/Order/WellFoundedSet.lean", "Mathlib/Tactic/Explode/Pretty.lean", "Mathlib/FieldTheory/IsAlgClosed/Classification.lean", "Mathlib/Geometry/Euclidean/Sphere/Ptolemy.lean", "Mathlib/NumberTheory/Padics/RingHoms.lean", "Mathlib/Algebra/MonoidAlgebra/Grading.lean", "Mathlib/Analysis/Normed/Group/Quotient.lean", "Mathlib/FieldTheory/Finite/Polynomial.lean", "Mathlib/AlgebraicTopology/DoldKan/Degeneracies.lean", "Mathlib/NumberTheory/RamificationInertia.lean", "Mathlib/Analysis/NormedSpace/AffineIsometry.lean", "Mathlib/LinearAlgebra/InvariantBasisNumber.lean", "Mathlib/Data/Set/Card.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean", "Mathlib/Data/Option/Basic.lean", "Mathlib/CategoryTheory/Conj.lean", "Mathlib/Data/Fin/Tuple/Reflection.lean", "Mathlib/Algebra/Order/Monoid/WithZero/Basic.lean", "Mathlib/GroupTheory/Perm/List.lean", "Mathlib/Tactic/ApplyFun.lean", "Mathlib/Data/Prod/Lex.lean", "Mathlib/Algebra/Category/ModuleCat/Basic.lean", "Mathlib/MeasureTheory/Function/ConditionalExpectation/Real.lean", "Mathlib/RingTheory/ReesAlgebra.lean", "Mathlib/LinearAlgebra/FreeModule/IdealQuotient.lean", "Mathlib/Algebra/Category/GroupCat/Adjunctions.lean", "Mathlib/Topology/Order/NhdsSet.lean", "Mathlib/RingTheory/OreLocalization/Basic.lean", "Mathlib/CategoryTheory/Bicategory/Free.lean", "Mathlib/Deprecated/Subgroup.lean", "Mathlib/Topology/MetricSpace/Equicontinuity.lean", "Mathlib/CategoryTheory/Abelian/Homology.lean", "Mathlib/Algebra/Homology/HomotopyCategory.lean", "Mathlib/RingTheory/DedekindDomain/Ideal.lean", "Mathlib/FieldTheory/Minpoly/Field.lean", "Mathlib/CategoryTheory/Monoidal/Preadditive.lean", "Mathlib/Util/Export.lean", "Mathlib/Analysis/Calculus/Dslope.lean", "Mathlib/Geometry/RingedSpace/SheafedSpace.lean", "Mathlib/Analysis/Convex/Slope.lean", "Mathlib/Analysis/Calculus/Deriv/Prod.lean", "Mathlib/Data/Stream/Defs.lean", "Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean", "Mathlib/Data/Set/Semiring.lean", "Mathlib/Logic/Function/Conjugate.lean", "Mathlib/Analysis/Calculus/FDeriv/Pi.lean", "Mathlib/Analysis/SpecialFunctions/PolynomialExp.lean", "Mathlib/Topology/List.lean", "Mathlib/RingTheory/OreLocalization/OreSet.lean", "Mathlib/CategoryTheory/LiftingProperties/Basic.lean", "Mathlib/Order/LocallyFinite.lean", "Mathlib/Data/Nat/Cast/Basic.lean", "Mathlib/Tactic/ApplyCongr.lean", "Mathlib/Dynamics/BirkhoffSum/Basic.lean", "Mathlib/Algebra/Tropical/Lattice.lean", "Mathlib/RingTheory/RingInvo.lean", "Mathlib/Data/W/Constructions.lean", "Mathlib/Data/Nat/Log.lean", "Mathlib/Algebra/Hom/NonUnitalAlg.lean", "Mathlib/Data/Matrix/Auto.lean", "Mathlib/NumberTheory/NumberField/Units.lean", "Mathlib/Tactic/GuardGoalNums.lean", "Mathlib/Data/Complex/ExponentialBounds.lean", "Mathlib/CategoryTheory/Adjunction/Whiskering.lean", "Mathlib/Geometry/Manifold/VectorBundle/Hom.lean", "Mathlib/Data/Matrix/Rank.lean", "Mathlib/Analysis/InnerProductSpace/l2Space.lean", "Mathlib/Analysis/LocallyConvex/Barrelled.lean", "Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean", "Mathlib/Algebra/Lie/Quotient.lean", "Mathlib/CategoryTheory/Sites/Closed.lean", "Mathlib/MeasureTheory/Measure/WithDensity.lean", "Mathlib/Topology/LocallyConstant/Basic.lean", "Mathlib/Algebra/Group/UniqueProds.lean", "Mathlib/NumberTheory/ModularForms/JacobiTheta/Basic.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Contraction.lean", "Mathlib/Tactic/Measurability/Init.lean", "Mathlib/Topology/Category/Profinite/EffectiveEpi.lean", "Mathlib/Data/PNat/Prime.lean", "Mathlib/Topology/ContinuousFunction/Ideals.lean", "Mathlib/Topology/Category/Profinite/Limits.lean", "Mathlib/CategoryTheory/Linear/Basic.lean", "Mathlib/CategoryTheory/Abelian/Opposite.lean", "Mathlib/Data/Holor.lean", "Mathlib/Tactic/MkIffOfInductiveProp.lean", "Mathlib/Algebra/Group/Defs.lean", "Mathlib/Tactic/Monotonicity/Attr.lean", "Mathlib/Topology/ShrinkingLemma.lean", "Mathlib/Analysis/Normed/Group/SemiNormedGroupCat/Kernels.lean", "Mathlib/GroupTheory/Sylow.lean", "Mathlib/RingTheory/WittVector/Truncated.lean", "Mathlib/Data/Pi/Interval.lean", "Mathlib/Topology/Irreducible.lean", "Mathlib/Topology/UniformSpace/AbsoluteValue.lean", "Mathlib/Computability/Ackermann.lean", "Mathlib/Algebra/Homology/Additive.lean", "Mathlib/Algebra/GroupWithZero/Commute.lean", "Mathlib/CategoryTheory/Limits/SmallComplete.lean", "Mathlib/LinearAlgebra/Matrix/Hermitian.lean", "Mathlib/Analysis/Calculus/FDeriv/Equiv.lean", "Mathlib/MeasureTheory/MeasurableSpace/Card.lean", "Mathlib/Init/Core.lean", "Mathlib/Data/List/Nodup.lean", "Mathlib/Tactic/CancelDenoms/Core.lean", "Mathlib/Topology/MetricSpace/Algebra.lean", "Mathlib/Algebra/Category/ModuleCat/Simple.lean", "Mathlib/Data/Rat/Star.lean", "Mathlib/Condensed/Abelian.lean", "Mathlib/GroupTheory/Finiteness.lean", "Mathlib/RingTheory/WittVector/Basic.lean", "Mathlib/Combinatorics/SimpleGraph/Ends/Properties.lean", "Mathlib/GroupTheory/Nilpotent.lean", "Mathlib/Tactic/GuardHypNums.lean", "Mathlib/Data/Int/Associated.lean", "Mathlib/Probability/Kernel/CondCdf.lean", "Mathlib/Analysis/Calculus/Deriv/Add.lean", "Mathlib/Data/Finset/Sigma.lean", "Mathlib/CategoryTheory/Sites/SheafOfTypes.lean", "Mathlib/Algebra/Homology/ShortComplex/LeftHomology.lean", "Mathlib/Algebra/Order/Field/Power.lean", "Mathlib/Geometry/Euclidean/Angle/Unoriented/RightAngle.lean", "Mathlib/Data/Real/EReal.lean", "Mathlib/GroupTheory/Perm/Support.lean", "Mathlib/RingTheory/RingHom/Surjective.lean", "Mathlib/Order/SuccPred/Basic.lean", "Mathlib/Lean/Name.lean", "Mathlib/Topology/Sober.lean", "Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "Mathlib/FieldTheory/PerfectClosure.lean", "Mathlib/Algebra/CubicDiscriminant.lean", "Mathlib/CategoryTheory/Limits/Preserves/Limits.lean", "Mathlib/Analysis/Distribution/AEEqOfIntegralContDiff.lean", "Mathlib/CategoryTheory/Action.lean", "Mathlib/Topology/MetricSpace/Isometry.lean", "Mathlib/Tactic/ToExpr.lean", "Mathlib/Data/Tree.lean", "Mathlib/Data/Multiset/Sort.lean", "Mathlib/CategoryTheory/Functor/Functorial.lean", "Mathlib/Data/Multiset/Range.lean", "Mathlib/Analysis/InnerProductSpace/ConformalLinearMap.lean", "Mathlib/Topology/Algebra/Monoid.lean", "Mathlib/Data/DFinsupp/WellFounded.lean", "Mathlib/Data/Int/Interval.lean", "Mathlib/CategoryTheory/Limits/Constructions/ZeroObjects.lean", "Mathlib/Analysis/InnerProductSpace/MeanErgodic.lean", "Mathlib/Data/Int/Cast/Defs.lean", "Mathlib/Probability/Martingale/Upcrossing.lean", "Mathlib/Analysis/Complex/OpenMapping.lean", "Mathlib/CategoryTheory/EssentiallySmall.lean", "Mathlib/Data/Fin/Tuple/Sort.lean", "Mathlib/Data/Finset/Option.lean", "Mathlib/Data/List/Defs.lean", "Mathlib/Tactic.lean", "Mathlib/Algebra/Ring/Commute.lean", "Mathlib/Data/Int/GCD.lean", "Mathlib/Data/Rat/Cast/Order.lean", "Mathlib/CategoryTheory/Monoidal/Types/Basic.lean", "Mathlib/Combinatorics/Young/SemistandardTableau.lean", "Mathlib/Data/List/BigOperators/Basic.lean", "Mathlib/CategoryTheory/Localization/Opposite.lean", "Mathlib/Probability/Martingale/Basic.lean", "Mathlib/FieldTheory/RatFunc.lean", "Mathlib/Topology/MetricSpace/ShrinkingLemma.lean", "Mathlib/RingTheory/DedekindDomain/Factorization.lean", "Mathlib/Topology/Algebra/Module/WeakDual.lean", "Mathlib/Data/Ordmap/Ordnode.lean", "Mathlib/Algebra/Category/ModuleCat/Abelian.lean", "Mathlib/Data/List/Duplicate.lean", "Mathlib/Algebra/GroupWithZero/InjSurj.lean", "Mathlib/CategoryTheory/Shift/Localization.lean", "Mathlib/Algebra/Category/MonCat/FilteredColimits.lean", "Mathlib/MeasureTheory/Integral/IntervalIntegral.lean", "Mathlib/MeasureTheory/Measure/OpenPos.lean", "Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean", "Mathlib/Order/Monotone/Union.lean", "Mathlib/Topology/MetricSpace/Baire.lean", "Mathlib/Geometry/Manifold/VectorBundle/FiberwiseLinear.lean", "Mathlib/Order/CompactlyGenerated.lean", "Mathlib/MeasureTheory/Lattice.lean", "Mathlib/Topology/Algebra/Nonarchimedean/AdicTopology.lean", "Mathlib/Order/Heyting/Hom.lean", "Mathlib/Analysis/BoxIntegral/Partition/Measure.lean", "Mathlib/GroupTheory/Commutator.lean", "Mathlib/Combinatorics/SetFamily/HarrisKleitman.lean", "Mathlib/Analysis/Normed/Field/InfiniteSum.lean", "Mathlib/Tactic/NoncommRing.lean", "Mathlib/Geometry/Manifold/Diffeomorph.lean", "Mathlib/Data/Finset/Image.lean", "Mathlib/Topology/VectorBundle/Constructions.lean", "Mathlib/LinearAlgebra/Basis/Flag.lean", "Mathlib/Topology/Category/Born.lean", "Mathlib/MeasureTheory/Covering/DensityTheorem.lean", "Mathlib/Dynamics/FixedPoints/Basic.lean", "Mathlib/FieldTheory/Tower.lean", "Mathlib/Data/DList/Instances.lean", "Mathlib/Algebra/Order/Ring/Cone.lean", "Mathlib/CategoryTheory/Subobject/FactorThru.lean", "Mathlib/Analysis/Normed/Order/Lattice.lean", "Mathlib/Data/Int/NatPrime.lean", "Mathlib/RingTheory/ZMod.lean", "Mathlib/Tactic/SlimCheck.lean", "Mathlib/Algebra/Order/Field/Basic.lean", "Mathlib/AlgebraicTopology/DoldKan/FunctorGamma.lean", "Mathlib/Data/List/Destutter.lean", "Mathlib/Geometry/Manifold/VectorBundle/Pullback.lean", "Mathlib/FieldTheory/AbelRuffini.lean", "Mathlib/SetTheory/ZFC/Basic.lean", "Mathlib/Data/Setoid/Partition.lean", "Mathlib/FieldTheory/Cardinality.lean", "Mathlib/Order/Iterate.lean", "Mathlib/NumberTheory/Cyclotomic/PrimitiveRoots.lean", "Mathlib/ModelTheory/Order.lean", "Mathlib/Algebra/Order/Nonneg/Ring.lean", "Mathlib/Order/InitialSeg.lean", "Mathlib/Analysis/Normed/Field/UnitBall.lean", "Mathlib/CategoryTheory/Adjunction/FullyFaithful.lean", "Mathlib/Algebra/Order/EuclideanAbsoluteValue.lean", "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "Mathlib/RingTheory/Localization/AtPrime.lean", "Mathlib/Data/Countable/Defs.lean", "Mathlib/Algebra/CharZero/Infinite.lean", "Mathlib/Analysis/Convex/Cone/Pointed.lean", "Mathlib/Topology/Sheaves/LocallySurjective.lean", "Mathlib/CategoryTheory/Limits/Shapes/Images.lean", "Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean", "Mathlib/Data/ZMod/Parity.lean", "Mathlib/MeasureTheory/Measure/WithDensityVectorMeasure.lean", "Mathlib/Algebra/Group/TypeTags.lean", "Mathlib/Topology/Sheaves/Stalks.lean", "Mathlib/Algebra/DirectSum/Basic.lean", "Mathlib/Util/WhatsNew.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/ComplexDeriv.lean", "Mathlib/MeasureTheory/Integral/DivergenceTheorem.lean", "Mathlib/Algebra/BigOperators/Ring.lean", "Mathlib/Combinatorics/SimpleGraph/Girth.lean", "Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean", "Mathlib/Data/Polynomial/Basic.lean", "Mathlib/LinearAlgebra/Finsupp.lean", "Mathlib/Order/RelClasses.lean", "Mathlib/Combinatorics/SimpleGraph/Metric.lean", "Mathlib/MeasureTheory/Function/LpSpace.lean", "Mathlib/MeasureTheory/Integral/TorusIntegral.lean", "Mathlib/Analysis/NormedSpace/Complemented.lean", "Mathlib/Data/Multiset/Nodup.lean", "Mathlib/RingTheory/GradedAlgebra/HomogeneousLocalization.lean", "Mathlib/Tactic/DefEqTransformations.lean", "Mathlib/Data/Seq/Computation.lean", "Mathlib/FieldTheory/IsAlgClosed/AlgebraicClosure.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Star.lean", "Mathlib/Geometry/Manifold/Instances/UnitsOfNormedAlgebra.lean", "Mathlib/Algebra/SMulWithZero.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Equivs.lean", "Mathlib/Util/Imports.lean", "Mathlib/CategoryTheory/Limits/Opposites.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/Topology.lean", "Mathlib/Algebra/GeomSum.lean", "Mathlib/Algebra/BigOperators/Option.lean", "Mathlib/Data/Rat/Defs.lean", "Mathlib/Data/Polynomial/Cardinal.lean", "Mathlib/Tactic/LinearCombination.lean", "Mathlib/Algebra/Star/BigOperators.lean", "Mathlib/RingTheory/WittVector/Identities.lean", "Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean", "Mathlib/Testing/SlimCheck/Gen.lean", "Mathlib/Data/Finsupp/Indicator.lean", "Mathlib/Algebra/Order/Ring/InjSurj.lean", "Mathlib/Lean/Thunk.lean", "Mathlib/Data/MvPolynomial/Equiv.lean", "Mathlib/Topology/Constructions.lean", "Mathlib/CategoryTheory/Monoidal/OfHasFiniteProducts.lean", "Mathlib/Order/Filter/Ultrafilter.lean", "Mathlib/Data/Set/List.lean", "Mathlib/GroupTheory/CommutingProbability.lean", "Mathlib/CategoryTheory/Sites/Grothendieck.lean", "Mathlib/RingTheory/Localization/InvSubmonoid.lean", "Mathlib/RingTheory/WittVector/Domain.lean", "Mathlib/MeasureTheory/Integral/ExpDecay.lean", "Mathlib/Algebra/Field/MinimalAxioms.lean", "Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/Algebra/MonoidAlgebra/Support.lean", "Mathlib/SetTheory/Cardinal/Basic.lean", "Mathlib/Algebra/ContinuedFractions/Computation/Basic.lean", "Mathlib/Order/ConditionallyCompleteLattice/Finset.lean", "Mathlib/Topology/Algebra/Module/Star.lean", "Mathlib/Algebra/Lie/Character.lean", "Mathlib/Algebra/Module/Prod.lean", "Mathlib/Algebra/ModEq.lean", "Mathlib/MeasureTheory/Category/MeasCat.lean", "Mathlib/LinearAlgebra/AffineSpace/Midpoint.lean", "Mathlib/NumberTheory/ZetaFunction.lean", "Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "Mathlib/Analysis/SpecialFunctions/ExpDeriv.lean", "Mathlib/Algebra/Module/ULift.lean", "Mathlib/LinearAlgebra/Eigenspace/IsAlgClosed.lean", "Mathlib/Topology/Sheaves/PresheafOfFunctions.lean", "Mathlib/Dynamics/OmegaLimit.lean", "Mathlib/Logic/Relation.lean", "Mathlib/MeasureTheory/Measure/GiryMonad.lean", "Mathlib/Topology/Algebra/Order/ProjIcc.lean", "Mathlib/Data/Num/Bitwise.lean", "Mathlib/Topology/Sets/Closeds.lean", "Mathlib/CategoryTheory/Functor/Const.lean", "Mathlib/Data/List/Count.lean", "Mathlib/AlgebraicGeometry/PrimeSpectrum/Noetherian.lean", "Mathlib/Topology/Category/TopCommRingCat.lean", "Mathlib/Data/QPF/Multivariate/Constructions/Const.lean", "Mathlib/GroupTheory/FreeGroup/NielsenSchreier.lean", "Mathlib/Topology/Order/UpperLowerSetTopology.lean", "Mathlib/Order/Heyting/Basic.lean", "Mathlib/Topology/VectorBundle/Basic.lean", "Mathlib/Analysis/Convex/Uniform.lean", "Mathlib/Algebra/Opposites.lean", "Mathlib/Algebra/Lie/CartanSubalgebra.lean", "Mathlib/Tactic/Backtrack.lean", "Mathlib/Algebra/Category/Ring/Constructions.lean", "Mathlib/MeasureTheory/Measure/Trim.lean", "Mathlib/Algebra/Order/Ring/Lemmas.lean", "Mathlib/AlgebraicTopology/SimplexCategory.lean", "Mathlib/Combinatorics/SimpleGraph/Trails.lean", "Mathlib/LinearAlgebra/FreeModule/StrongRankCondition.lean", "Mathlib/CategoryTheory/Sites/Canonical.lean", "Mathlib/LinearAlgebra/Matrix/ToLinearEquiv.lean", "Mathlib/LinearAlgebra/AffineSpace/Matrix.lean", "Mathlib/Data/List/Prime.lean", "Mathlib/Algebra/Order/Field/Canonical/Defs.lean", "Mathlib/Order/Category/BddOrd.lean", "Mathlib/Topology/UniformSpace/Matrix.lean", "Mathlib/Topology/Algebra/Group/Basic.lean", "Mathlib/CategoryTheory/Functor/InvIsos.lean", "Mathlib/Order/CountableDenseLinearOrder.lean", "Mathlib/Algebra/Free.lean", "Mathlib/Data/Rat/Init.lean", "Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean", "Mathlib/Data/Finsupp/Antidiagonal.lean", "Mathlib/RingTheory/HahnSeries.lean", "Mathlib/Analysis/SpecialFunctions/Complex/Circle.lean", "Mathlib/Data/ENat/Basic.lean", "Mathlib/Topology/Category/TopCat/Limits/Basic.lean", "Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "Mathlib/CategoryTheory/Filtered/Small.lean", "Mathlib/CategoryTheory/WithTerminal.lean", "Mathlib/Algebra/Field/Basic.lean", "Mathlib/MeasureTheory/Group/AddCircle.lean", "Mathlib/CategoryTheory/Limits/ExactFunctor.lean", "Mathlib/Analysis/NormedSpace/IsROrC.lean", "Mathlib/Util/LongNames.lean", "Mathlib/Analysis/Convex/Intrinsic.lean", "Mathlib/Data/Polynomial/UnitTrinomial.lean", "Mathlib/Algebra/Homology/HomologicalComplex.lean", "Mathlib/Data/Matrix/Kronecker.lean", "Mathlib/Tactic/Group.lean", "Mathlib/MeasureTheory/Function/LocallyIntegrable.lean", "Mathlib/Lean/Meta/DiscrTree.lean", "Mathlib/RingTheory/Valuation/ValuationSubring.lean", "Mathlib/Data/Complex/Exponential.lean", "Mathlib/Algebra/Squarefree.lean", "Mathlib/Analysis/SpecialFunctions/Polynomials.lean", "Mathlib/Analysis/MellinTransform.lean", "Mathlib/Tactic/HaveI.lean", "Mathlib/LinearAlgebra/Matrix/IsDiag.lean", "Mathlib/CategoryTheory/Shift/Basic.lean", "Mathlib/Data/Finset/Functor.lean", "Mathlib/Analysis/SpecialFunctions/Log/Deriv.lean", "Mathlib/CategoryTheory/Adjunction/Evaluation.lean", "Mathlib/Data/Ordmap/Ordset.lean", "Mathlib/CategoryTheory/Simple.lean", "Mathlib/Data/PFun.lean", "Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "Mathlib/Probability/Kernel/WithDensity.lean", "Mathlib/Tactic/ToAdditive.lean", "Mathlib/LinearAlgebra/TensorProduct/RightExactness.lean", "Mathlib/Algebra/Order/Group/InjSurj.lean", "Mathlib/RingTheory/NonUnitalSubring/Basic.lean", "Mathlib/Order/JordanHolder.lean", "Mathlib/Tactic/ApplyWith.lean", "Mathlib/RingTheory/DedekindDomain/Basic.lean", "Mathlib/RingTheory/Polynomial/Nilpotent.lean", "Mathlib/CategoryTheory/Monoidal/OfChosenFiniteProducts/Basic.lean", "Mathlib/GroupTheory/FreeAbelianGroup.lean", "Mathlib/CategoryTheory/Preadditive/FunctorCategory.lean", "Mathlib/Combinatorics/SetFamily/Kleitman.lean", "Mathlib/Data/Set/Pointwise/Basic.lean", "Mathlib/Data/Nat/SqrtNormNum.lean", "Mathlib/CategoryTheory/Limits/Creates.lean", "Mathlib/Analysis/NormedSpace/CompactOperator.lean", "Mathlib/AlgebraicGeometry/Morphisms/OpenImmersion.lean", "Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "Mathlib/Data/Finset/Pi.lean", "Mathlib/Data/Set/Intervals/OrderIso.lean", "Mathlib/RingTheory/Localization/Away/AdjoinRoot.lean", "Mathlib/Data/Nat/Totient.lean", "Mathlib/Data/List/Func.lean", "Mathlib/Topology/Sheaves/SheafCondition/EqualizerProducts.lean", "Mathlib/Data/PSigma/Order.lean", "Mathlib/Algebra/Star/Subalgebra.lean", "Mathlib/Order/PropInstances.lean", "Mathlib/Analysis/Convex/Side.lean", "Mathlib/Data/Complex/Cardinality.lean", "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "Mathlib/Algebra/Homology/ShortComplex/RightHomology.lean", "Mathlib/Condensed/Basic.lean", "Mathlib/Analysis/NormedSpace/Star/GelfandDuality.lean", "Mathlib/Algebra/Category/ModuleCat/Kernels.lean", "Mathlib/CategoryTheory/Triangulated/TriangleShift.lean", "Mathlib/Topology/Algebra/Nonarchimedean/Basic.lean", "Mathlib/Data/Nat/MaxPowDiv.lean", "Mathlib/NumberTheory/Dioph.lean", "Mathlib/ModelTheory/FinitelyGenerated.lean", "Mathlib/Analysis/Analytic/Linear.lean", "Mathlib/Data/Rat/Encodable.lean", "Mathlib/Topology/Algebra/ContinuousMonoidHom.lean", "Mathlib/Data/Bool/AllAny.lean", "Mathlib/GroupTheory/Perm/Cycle/Concrete.lean", "Mathlib/Algebra/GroupPower/Lemmas.lean", "Mathlib/Analysis/NormedSpace/OperatorNorm.lean", "Mathlib/Lean/IO/Process.lean", "Mathlib/Data/Subtype.lean", "Mathlib/Init/Control/Lawful.lean", "Mathlib/Algebra/Category/ModuleCat/Free.lean", "Mathlib/MeasureTheory/Integral/SetIntegral.lean", "Mathlib/GroupTheory/NoncommPiCoprod.lean", "Mathlib/Data/Fintype/Option.lean", "Mathlib/GroupTheory/SpecificGroups/Quaternion.lean", "Mathlib/RingTheory/DedekindDomain/AdicValuation.lean", "Mathlib/Analysis/NormedSpace/FiniteDimension.lean", "Mathlib/Analysis/NormedSpace/Banach.lean", "Mathlib/Algebra/Homology/ShortComplex/Basic.lean", "Mathlib/CategoryTheory/Shift/Induced.lean", "Mathlib/Topology/UniformSpace/Equiv.lean", "Mathlib/Data/DList/Defs.lean", "Mathlib/Tactic/Simps/NotationClass.lean", "Mathlib/Analysis/NormedSpace/Star/Spectrum.lean", "Mathlib/LinearAlgebra/Matrix/Orthogonal.lean", "Mathlib/Algebra/Order/Invertible.lean", "Mathlib/Data/Int/Cast/Lemmas.lean", "Mathlib/GroupTheory/GroupAction/Option.lean", "Mathlib/Topology/Algebra/Order/Filter.lean", "Mathlib/Order/Filter/Prod.lean", "Mathlib/CategoryTheory/Limits/Shapes/CommSq.lean", "Mathlib/MeasureTheory/Function/LpSeminorm.lean", "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "Mathlib/Data/List/Cycle.lean", "Mathlib/Analysis/Calculus/LHopital.lean", "Mathlib/GroupTheory/Subgroup/ZPowers.lean", "Mathlib/RingTheory/Ideal/MinimalPrime.lean", "Mathlib/Algebra/Order/Monoid/MinMax.lean", "Mathlib/FieldTheory/Separable.lean", "Mathlib/Order/GaloisConnection.lean", "Mathlib/Topology/Algebra/Equicontinuity.lean", "Mathlib/Topology/Instances/Nat.lean", "Mathlib/Algebra/Field/ULift.lean", "Mathlib/LinearAlgebra/QuadraticForm/QuadraticModuleCat/Symmetric.lean", "Mathlib/LinearAlgebra/Matrix/Determinant.lean", "Mathlib/Analysis/BoxIntegral/Partition/Additive.lean", "Mathlib/GroupTheory/Torsion.lean", "Mathlib/Lean/Meta/Basic.lean", "Mathlib/LinearAlgebra/PiTensorProduct.lean", "Mathlib/Init/CCLemmas.lean", "Mathlib/Algebra/Order/Rearrangement.lean", "Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean", "Mathlib/Tactic/ProjectionNotation.lean", "Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/CategoryTheory/Subobject/MonoOver.lean", "Mathlib/Combinatorics/Young/YoungDiagram.lean", "Mathlib/Analysis/Complex/PhragmenLindelof.lean", "Mathlib/CategoryTheory/Closed/Functor.lean", "Mathlib/Topology/ContinuousFunction/ZeroAtInfty.lean", "Mathlib/Combinatorics/HalesJewett.lean", "Mathlib/Topology/Instances/Int.lean", "Mathlib/Geometry/Manifold/Algebra/LieGroup.lean", "Mathlib/LinearAlgebra/SymplecticGroup.lean", "Mathlib/Tactic/SuccessIfFailWithMsg.lean", "Mathlib/Data/Rel.lean", "Mathlib/Data/Nat/GCD/Basic.lean", "Mathlib/MeasureTheory/Group/MeasurableEquiv.lean", "Mathlib/Tactic/Attr/Register.lean", "Mathlib/CategoryTheory/Preadditive/Biproducts.lean", "Mathlib/Data/Fintype/Fin.lean", "Mathlib/RingTheory/Polynomial/Pochhammer.lean", "Mathlib/LinearAlgebra/TensorProduct/Tower.lean", "Mathlib/Data/List/Dedup.lean", "Mathlib/RingTheory/Nilpotent.lean", "Mathlib/Geometry/Manifold/ContMDiffMFDeriv.lean", "Mathlib/Data/Polynomial/CancelLeads.lean", "Mathlib/AlgebraicGeometry/FunctionField.lean", "Mathlib/Algebra/CharZero/Quotient.lean", "Mathlib/Algebra/Lie/Classical.lean", "Mathlib/MeasureTheory/Measure/Stieltjes.lean", "Mathlib/Analysis/BoxIntegral/Partition/Basic.lean", "Mathlib/RingTheory/Valuation/Basic.lean", "Mathlib/Data/DFinsupp/Encodable.lean", "Mathlib/Tactic/CategoryTheory/Reassoc.lean", "Mathlib/RingTheory/MvPolynomial/Homogeneous.lean", "Mathlib/Order/Monotone/Extension.lean", "Mathlib/CategoryTheory/Products/Basic.lean", "Mathlib/Dynamics/PeriodicPts.lean", "Mathlib/Computability/TuringMachine.lean", "Mathlib/Combinatorics/SimpleGraph/Regularity/Lemma.lean", "Mathlib/MeasureTheory/Measure/Lebesgue/Integral.lean", "Mathlib/Analysis/NormedSpace/Star/Multiplier.lean", "Mathlib/CategoryTheory/Monad/Coequalizer.lean", "Mathlib/GroupTheory/GroupAction/FixingSubgroup.lean", "Mathlib/Tactic/Have.lean", "Mathlib/Algebra/Invertible/Defs.lean", "Mathlib/Topology/Spectral/Hom.lean", "Mathlib/Data/Nat/WithBot.lean", "Mathlib/Algebra/Module/GradedModule.lean", "Mathlib/Data/ZMod/Coprime.lean", "Mathlib/RingTheory/DedekindDomain/FiniteAdeleRing.lean", "Mathlib/CategoryTheory/Yoneda.lean", "Mathlib/Data/Set/Pointwise/ListOfFn.lean", "Mathlib/Data/MvPolynomial/Counit.lean", "Mathlib/Data/Nat/Cast/NeZero.lean", "Mathlib/Algebra/Homology/ShortComplex/Homology.lean", "Mathlib/Order/Category/OmegaCompletePartialOrder.lean", "Mathlib/Topology/Sets/Opens.lean", "Mathlib/Topology/Instances/AddCircle.lean", "Mathlib/Data/Complex/Orientation.lean", "Mathlib/Data/Nat/ForSqrt.lean", "Mathlib/Probability/Independence/Kernel.lean", "Mathlib/CategoryTheory/FinCategory.lean", "Mathlib/RepresentationTheory/Invariants.lean", "Mathlib/Topology/Connected/Basic.lean", "Mathlib/NumberTheory/Divisors.lean", "Mathlib/LinearAlgebra/AffineSpace/AffineEquiv.lean", "Mathlib/RingTheory/AlgebraicIndependent.lean", "Mathlib/Algebra/TrivSqZeroExt.lean", "Mathlib/LinearAlgebra/Span.lean", "Mathlib/Data/Real/Hyperreal.lean", "Mathlib/Algebra/Order/Interval.lean", "Mathlib/CategoryTheory/Limits/Constructions/Over/Products.lean", "Mathlib/Data/Vector/Mem.lean", "Mathlib/Algebra/Group/InjSurj.lean", "Mathlib/Order/LiminfLimsup.lean", "Mathlib/Data/Nat/Upto.lean", "Mathlib/CategoryTheory/Monoidal/Limits.lean", "Mathlib/Probability/Martingale/OptionalSampling.lean", "Mathlib/Data/FunLike/Embedding.lean", "Mathlib/Data/Polynomial/Degree/Lemmas.lean", "Mathlib/RingTheory/EuclideanDomain.lean", "Mathlib/Order/Filter/CountableInter.lean", "Mathlib/Algebra/Category/MonCat/Colimits.lean", "Mathlib/CategoryTheory/Types.lean", "Mathlib/Data/Fintype/Array.lean", "Mathlib/Topology/Sets/Order.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/Arctan.lean", "Mathlib/MeasureTheory/Integral/Bochner.lean", "Mathlib/CategoryTheory/Limits/Shapes/FunctorCategory.lean", "Mathlib/Analysis/Complex/AbsMax.lean", "Mathlib/Geometry/Manifold/Instances/Sphere.lean", "Mathlib/Analysis/Convex/Function.lean", "Mathlib/Data/Int/LeastGreatest.lean", "Mathlib/LinearAlgebra/Matrix/BilinearForm.lean", "Mathlib/LinearAlgebra/Matrix/GeneralLinearGroup.lean", "Mathlib/Data/Finset/Slice.lean", "Mathlib/Logic/Small/Group.lean", "Mathlib/Algebra/Category/Ring/Instances.lean", "Mathlib/Analysis/PSeries.lean", "Mathlib/NumberTheory/LegendreSymbol/QuadraticReciprocity.lean", "Mathlib/CategoryTheory/Localization/Predicate.lean", "Mathlib/Order/Filter/Archimedean.lean", "Mathlib/RingTheory/Derivation/Lie.lean", "Mathlib/Data/Finsupp/Interval.lean", "Mathlib/Topology/Category/Profinite/Projective.lean", "Mathlib/Analysis/NormedSpace/ContinuousAffineMap.lean", "Mathlib/Data/FinEnum.lean", "Mathlib/Data/Rat/BigOperators.lean", "Mathlib/Tactic/Spread.lean", "Mathlib/Algebra/GroupPower/Order.lean", "Mathlib/Analysis/Calculus/Deriv/Inverse.lean", "Mathlib/Lean/SMap.lean", "Mathlib/Analysis/Complex/OperatorNorm.lean", "Mathlib/Topology/Algebra/Order/ExtendFrom.lean", "Mathlib/Data/Fintype/Units.lean", "Mathlib/Topology/Clopen.lean", "Mathlib/Topology/FiberBundle/Trivialization.lean", "Mathlib/Data/List/Lex.lean", "Mathlib/Algebra/Category/ModuleCat/FilteredColimits.lean", "Mathlib/RingTheory/DedekindDomain/SInteger.lean", "Mathlib/GroupTheory/Submonoid/Inverses.lean", "Mathlib/Util/AssertExists.lean", "Mathlib/Algebra/Algebra/Hom.lean", "Mathlib/Data/Multiset/LocallyFinite.lean", "Mathlib/Lean/Expr/Traverse.lean", "Mathlib/Dynamics/BirkhoffSum/Average.lean", "Mathlib/Topology/Category/Stonean/Limits.lean", "Mathlib/Algebra/Module/LocalizedModule.lean", "Mathlib/Analysis/ODE/PicardLindelof.lean", "Mathlib/Data/List/Sections.lean", "Mathlib/Analysis/BoxIntegral/Partition/SubboxInduction.lean", "Mathlib/Data/Set/Intervals/OrdConnected.lean", "Mathlib/Data/String/Defs.lean", "Mathlib/Analysis/LocallyConvex/Basic.lean", "Mathlib/RingTheory/Subsemiring/Basic.lean", "Mathlib/Init/Data/Nat/Basic.lean", "Mathlib/Analysis/SpecialFunctions/Gaussian.lean", "Mathlib/CategoryTheory/LiftingProperties/Adjunction.lean", "Mathlib/Geometry/Euclidean/Circumcenter.lean", "Mathlib/CategoryTheory/Limits/Comma.lean", "Mathlib/SetTheory/Game/Nim.lean", "Mathlib/Data/Int/Lemmas.lean", "Mathlib/CategoryTheory/Subobject/Types.lean", "Mathlib/InformationTheory/Hamming.lean", "Mathlib/Data/List/EditDistance/Bounds.lean", "Mathlib/Data/Option/Defs.lean", "Mathlib/LinearAlgebra/Charpoly/ToMatrix.lean", "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean", "Mathlib/Data/Multiset/Sections.lean", "Mathlib/Topology/Category/TopCat/EpiMono.lean", "Mathlib/RingTheory/Localization/Ideal.lean", "Mathlib/GroupTheory/GroupAction/Embedding.lean", "Mathlib/Algebra/Category/GroupCat/ZModuleEquivalence.lean", "Mathlib/Combinatorics/SimpleGraph/Regularity/Increment.lean", "Mathlib/AlgebraicTopology/MooreComplex.lean", "Mathlib/NumberTheory/PellMatiyasevic.lean", "Mathlib/Algebra/Lie/Weights/Cartan.lean", "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean", "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean", "Mathlib/Data/Complex/Order.lean", "Mathlib/Algebra/Order/ToIntervalMod.lean", "Mathlib/Topology/Order/Category/AlexDisc.lean", "Mathlib/NumberTheory/WellApproximable.lean", "Mathlib/Analysis/Complex/Basic.lean", "Mathlib/CategoryTheory/Groupoid.lean", "Mathlib/Algebra/Homology/ShortComplex/HomologicalComplex.lean", "Mathlib/CategoryTheory/Comma.lean", "Mathlib/Algebra/Group/MinimalAxioms.lean", "Mathlib/Algebra/IsPrimePow.lean", "Mathlib/Computability/NFA.lean", "Mathlib/Data/MvPolynomial/Variables.lean", "Mathlib/Algebra/Order/Ring/Defs.lean", "Mathlib/Tactic/Conv.lean", "Mathlib/Topology/Category/TopCat/Opens.lean", "Mathlib/Data/Finsupp/Encodable.lean", "Mathlib/CategoryTheory/Grothendieck.lean", "Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean", "Mathlib/Tactic/Clear!.lean", "Mathlib/LinearAlgebra/Basic.lean", "Mathlib/CategoryTheory/Preadditive/HomOrthogonal.lean", "Mathlib/Algebra/Homology/ModuleCat.lean", "Mathlib/Logic/Equiv/Option.lean", "Mathlib/Order/ZornAtoms.lean", "Mathlib/MeasureTheory/Group/Pointwise.lean", "Mathlib/Topology/Sheaves/SheafCondition/Sites.lean", "Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean", "Mathlib/AlgebraicGeometry/Restrict.lean", "Mathlib/RingTheory/MatrixAlgebra.lean", "Mathlib/Analysis/Quaternion.lean", "Mathlib/Tactic/GCongr.lean", "Mathlib/Topology/Category/CompHaus/Projective.lean", "Mathlib/LinearAlgebra/Eigenspace/Minpoly.lean", "Mathlib/Algebra/Group/Prod.lean", "Mathlib/RingTheory/WittVector/IsPoly.lean", "Mathlib/Topology/Instances/TrivSqZeroExt.lean", "Mathlib/Tactic/SolveByElim.lean", "Mathlib/Data/ENat/Lattice.lean", "Mathlib/Topology/Homotopy/Contractible.lean", "Mathlib/Analysis/Calculus/Darboux.lean", "Mathlib/Data/Real/Pi/Bounds.lean", "Mathlib/CategoryTheory/Adjunction/Lifting.lean", "Mathlib/NumberTheory/SumTwoSquares.lean", "Mathlib/Data/SetLike/Fintype.lean", "Mathlib/Util/CompileInductive.lean", "Mathlib/Algebra/Lie/Nilpotent.lean", "Mathlib/LinearAlgebra/QuadraticForm/QuadraticModuleCat/Monoidal.lean", "Mathlib/CategoryTheory/StructuredArrow.lean", "Mathlib/Algebra/FreeAlgebra.lean", "Mathlib/Geometry/RingedSpace/LocallyRingedSpace/HasColimits.lean", "Mathlib/MeasureTheory/Constructions/BorelSpace/Complex.lean", "Mathlib/Computability/Encoding.lean", "Mathlib/Algebra/Category/AlgebraCat/Symmetric.lean", "Mathlib/LinearAlgebra/Matrix/ZPow.lean", "Mathlib/MeasureTheory/Function/ConditionalExpectation/AEMeasurable.lean", "Mathlib/Algebra/Algebra/Opposite.lean", "Mathlib/RingTheory/MvPolynomial/NewtonIdentities.lean", "Mathlib/RingTheory/Polynomial/Quotient.lean", "Mathlib/Data/Polynomial/Induction.lean", "Mathlib/Control/Bitraversable/Basic.lean", "Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "Mathlib/ModelTheory/Bundled.lean", "Mathlib/CategoryTheory/Bicategory/LocallyDiscrete.lean", "Mathlib/Tactic/WLOG.lean", "Mathlib/MeasureTheory/Group/Integral.lean", "Mathlib/Order/Filter/Subsingleton.lean", "Mathlib/Geometry/Manifold/Algebra/SmoothFunctions.lean", "Mathlib/Algebra/CharP/Two.lean", "Mathlib/Algebra/Lie/Solvable.lean", "Mathlib/Algebra/Ring/OrderSynonym.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/EmitLLVM.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/ExportAttr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/ResetReuse.lean", "lake-packages/lean4/src/lean/Lean/Compiler/NameMangling.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/SimpCase.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/Boxing.lean", "lake-packages/lean4/src/lean/Lean/Runtime.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/EmitUtil.lean", "lake-packages/lean4/src/lean/Lean/Compiler/InitAttr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/NormIds.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/LLVMBindings.lean", "lake-packages/lean4/src/lean/Lean/Data/HashMap.lean"], "premises": [{"full_name": "Lean.IR.leanMainFn", "code": "def leanMainFn := \"_lean_main\"", "start": [24, 1], "end": [24, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LLVM.size_tType", "code": "def size_tType (llvmctx : LLVM.Context) : IO (LLVM.LLVMType llvmctx) :=\n  LLVM.i64Type llvmctx", "start": [28, 1], "end": [29, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LLVM.getOrAddFunction", "code": "def getOrAddFunction (m : LLVM.Module ctx) (name : String) (type : LLVM.LLVMType ctx) : BaseIO (LLVM.Value ctx) :=  do\n  match (\u2190 LLVM.getNamedFunction m name) with\n  | some fn => return fn\n  | none =>\n    \n    let fn \u2190 LLVM.addFunction m name type\n    let attr \u2190 LLVM.createStringAttribute \"probe-stack\" \"inline-asm\"\n    LLVM.addAttributeAtIndex fn LLVM.AttributeIndex.AttributeFunctionIndex attr\n    return fn", "start": [32, 1], "end": [44, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LLVM.getOrAddGlobal", "code": "def getOrAddGlobal (m : LLVM.Module ctx) (name : String) (type : LLVM.LLVMType ctx) : BaseIO (LLVM.Value ctx) :=  do\n  match (\u2190 LLVM.getNamedGlobal m name) with\n  | .some fn => return fn\n  | .none => LLVM.addGlobal m name type", "start": [46, 1], "end": [49, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.Context", "code": "structure Context (llvmctx : LLVM.Context) where\n  env        : Environment\n  modName    : Name\n  jpMap      : JPParamsMap := {}\n  mainFn     : FunId := default\n  mainParams : Array Param := #[]\n  llvmmodule : LLVM.Module llvmctx", "start": [55, 1], "end": [61, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.State", "code": "structure State (llvmctx : LLVM.Context) where\n  var2val : HashMap VarId (LLVM.LLVMType llvmctx \u00d7 LLVM.Value llvmctx)\n  jp2bb   : HashMap JoinPointId (LLVM.BasicBlock llvmctx)", "start": [63, 1], "end": [65, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.Error", "code": "abbrev Error := String", "start": [67, 1], "end": [67, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.M", "code": "abbrev M (llvmctx : LLVM.Context) :=\n  StateRefT (State llvmctx) (ReaderT (Context llvmctx) (ExceptT Error IO))", "start": [69, 1], "end": [70, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.addVartoState", "code": "def addVartoState (x : VarId) (v : LLVM.Value llvmctx) (ty : LLVM.LLVMType llvmctx) : M llvmctx Unit := do\n  modify (fun s => { s with var2val := s.var2val.insert x (ty, v) })", "start": [75, 1], "end": [76, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.addJpTostate", "code": "def addJpTostate (jp : JoinPointId) (bb : LLVM.BasicBlock llvmctx) : M llvmctx Unit :=\n  modify (fun s => { s with jp2bb := s.jp2bb.insert jp bb })", "start": [78, 1], "end": [79, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitJp", "code": "def emitJp (jp : JoinPointId) : M llvmctx (LLVM.BasicBlock llvmctx) := do\n  let state \u2190 get\n  match state.jp2bb.find? jp with\n  | .some bb => return bb\n  | .none => throw s!\"unable to find join point {jp}\"", "start": [81, 1], "end": [85, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.getLLVMModule", "code": "def getLLVMModule : M llvmctx (LLVM.Module llvmctx) := Context.llvmmodule <$> read", "start": [87, 1], "end": [87, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.getEnv", "code": "def getEnv : M llvmctx Environment := Context.env <$> read", "start": [89, 1], "end": [89, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.getModName", "code": "def getModName : M llvmctx  Name := Context.modName <$> read", "start": [91, 1], "end": [91, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.getDecl", "code": "def getDecl (n : Name) : M llvmctx Decl := do\n  let env \u2190 getEnv\n  match findEnvDecl env n with\n  | some d => pure d\n  | none   => throw s!\"unknown declaration {n}\"", "start": [93, 1], "end": [97, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.constIntUnsigned", "code": "def constIntUnsigned (n : Nat) : M llvmctx (LLVM.Value llvmctx) :=  do\n    LLVM.constIntUnsigned llvmctx (UInt64.ofNat n)", "start": [99, 1], "end": [100, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.getOrCreateFunctionPrototype", "code": "def getOrCreateFunctionPrototype (mod : LLVM.Module llvmctx)\n    (retty : LLVM.LLVMType llvmctx) (name : String) (args : Array (LLVM.LLVMType llvmctx)) : M llvmctx  (LLVM.Value llvmctx) := do\n  LLVM.getOrAddFunction mod name $ \u2190 LLVM.functionType retty args (isVarArg := false)", "start": [102, 1], "end": [104, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanBox", "code": "def callLeanBox (builder : LLVM.Builder llvmctx)\n    (arg : LLVM.Value llvmctx) (name : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_box\"\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let argtys := #[ \u2190 LLVM.size_tType llvmctx ]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn  #[arg] name", "start": [106, 1], "end": [113, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanMarkPersistentFn", "code": "def callLeanMarkPersistentFn (builder : LLVM.Builder llvmctx) (arg : LLVM.Value llvmctx) : M llvmctx  Unit := do\n  let fnName :=  \"lean_mark_persistent\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx ]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let _ \u2190   LLVM.buildCall2 builder fnty fn  #[arg]", "start": [115, 1], "end": [121, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.RefcountKind", "code": "inductive RefcountKind where\n  | inc | dec", "start": [124, 1], "end": [125, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanRefcountFn", "code": "def callLeanRefcountFn (builder : LLVM.Builder llvmctx)\n    (kind : RefcountKind) (checkRef? : Bool) (arg : LLVM.Value llvmctx)\n    (delta : Option (LLVM.Value llvmctx) := Option.none) : M llvmctx Unit := do\n  let fnName :=  s!\"lean_{kind}{if checkRef? then \"\" else \"_ref\"}{if delta.isNone then \"\" else \"_n\"}\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := if delta.isNone then #[\u2190 LLVM.voidPtrType llvmctx] else #[\u2190 LLVM.voidPtrType llvmctx, \u2190 LLVM.size_tType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  match delta with\n  | .none => do\n    let _ \u2190 LLVM.buildCall2 builder fnty fn #[arg]\n  | .some n => do\n    let _ \u2190 LLVM.buildCall2 builder fnty fn #[arg, n]", "start": [132, 1], "end": [145, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanDecRef", "code": "def callLeanDecRef (builder : LLVM.Builder llvmctx) (res : LLVM.Value llvmctx) : M llvmctx Unit := do\n  let fnName :=  \"lean_dec_ref\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := #[ \u2190 LLVM.i8PtrType llvmctx ]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn  #[res]", "start": [150, 1], "end": [156, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanUnsignedToNatFn", "code": "def callLeanUnsignedToNatFn (builder : LLVM.Builder llvmctx)\n    (n : Nat) (name : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let mod \u2190 getLLVMModule\n  let argtys := #[\u2190 LLVM.i32Type llvmctx]\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let f \u2190   getOrCreateFunctionPrototype mod retty \"lean_unsigned_to_nat\"  argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let nv \u2190 LLVM.constInt32 llvmctx (UInt64.ofNat n)\n  LLVM.buildCall2 builder fnty f #[nv] name", "start": [158, 1], "end": [166, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanMkStringFromBytesFn", "code": "def callLeanMkStringFromBytesFn (builder : LLVM.Builder llvmctx)\n    (strPtr nBytes : LLVM.Value llvmctx) (name : String) : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_mk_string_from_bytes\"\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let argtys :=  #[\u2190 LLVM.voidPtrType llvmctx, \u2190 LLVM.i64Type llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[strPtr, nBytes] name", "start": [168, 1], "end": [175, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanMkString", "code": "def callLeanMkString (builder : LLVM.Builder llvmctx)\n    (strPtr : LLVM.Value llvmctx) (name : String) : M llvmctx (LLVM.Value llvmctx) := do\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let argtys :=  #[\u2190 LLVM.voidPtrType llvmctx]\n  let fn \u2190  getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty \"lean_mk_string\" argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[strPtr] name", "start": [177, 1], "end": [183, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanCStrToNatFn", "code": "def callLeanCStrToNatFn (builder : LLVM.Builder llvmctx)\n    (n : Nat) (name : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_cstr_to_nat\"\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let argtys :=  #[\u2190 LLVM.voidPtrType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let s \u2190 LLVM.buildGlobalString builder (value := toString n)\n  LLVM.buildCall2 builder fnty fn #[s] name", "start": [185, 1], "end": [193, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanIOMkWorld", "code": "def callLeanIOMkWorld (builder : LLVM.Builder llvmctx) : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_io_mk_world\"\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let argtys :=  #[]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[] \"mk_io_out\"", "start": [195, 1], "end": [201, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanIOResultIsError", "code": "def callLeanIOResultIsError (builder : LLVM.Builder llvmctx)\n    (arg : LLVM.Value llvmctx) (name : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_io_result_is_error\"\n  let retty \u2190 LLVM.i1Type llvmctx\n  let argtys :=  #[\u2190 LLVM.voidPtrType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[arg] name", "start": [203, 1], "end": [210, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanAllocCtor", "code": "def callLeanAllocCtor (builder : LLVM.Builder llvmctx)\n    (tag num_objs scalar_sz : Nat) (name : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_alloc_ctor\"\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let i32 \u2190 LLVM.i32Type llvmctx\n  let argtys :=  #[i32, i32, i32]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n\n  let tag \u2190 LLVM.constInt32 llvmctx (UInt64.ofNat tag)\n  let num_objs \u2190 LLVM.constInt32 llvmctx (UInt64.ofNat num_objs)\n  let scalar_sz \u2190 LLVM.constInt32 llvmctx (UInt64.ofNat scalar_sz)\n  LLVM.buildCall2 builder fnty fn #[tag, num_objs, scalar_sz] name", "start": [212, 1], "end": [224, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanCtorSet", "code": "def callLeanCtorSet (builder : LLVM.Builder llvmctx)\n    (o i v : LLVM.Value llvmctx) : M llvmctx Unit := do\n  let fnName := \"lean_ctor_set\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let voidptr \u2190 LLVM.voidPtrType llvmctx\n  let unsigned \u2190 LLVM.size_tType llvmctx\n  let argtys :=  #[voidptr, unsigned, voidptr]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  _ <- LLVM.buildCall2 builder fnty fn  #[o, i, v]", "start": [226, 1], "end": [235, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanIOResultMKOk", "code": "def callLeanIOResultMKOk (builder : LLVM.Builder llvmctx)\n    (v : LLVM.Value llvmctx) (name : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_io_result_mk_ok\"\n  let voidptr \u2190 LLVM.voidPtrType llvmctx\n  let retty := voidptr\n  let argtys :=  #[voidptr]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[v] name", "start": [237, 1], "end": [245, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanAllocClosureFn", "code": "def callLeanAllocClosureFn (builder : LLVM.Builder llvmctx)\n    (f arity nys : LLVM.Value llvmctx) (retName : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_alloc_closure\"\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx, \u2190 LLVM.size_tType llvmctx, \u2190 LLVM.size_tType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn  #[f, arity, nys] retName", "start": [247, 1], "end": [254, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanClosureSetFn", "code": "def callLeanClosureSetFn (builder : LLVM.Builder llvmctx)\n    (closure ix arg : LLVM.Value llvmctx) (retName : String := \"\") : M llvmctx Unit := do\n  let fnName :=  \"lean_closure_set\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx, \u2190 LLVM.size_tType llvmctx, \u2190 LLVM.voidPtrType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn  #[closure, ix, arg] retName", "start": [256, 1], "end": [263, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanObjTag", "code": "def callLeanObjTag (builder : LLVM.Builder llvmctx)\n    (closure : LLVM.Value llvmctx) (retName : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_obj_tag\"\n  let retty \u2190 LLVM.i32Type llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let out \u2190 LLVM.buildCall2 builder fnty fn  #[closure] retName\n  LLVM.buildSextOrTrunc builder out (\u2190 LLVM.i64Type llvmctx)", "start": [265, 1], "end": [273, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanIOResultGetValue", "code": "def callLeanIOResultGetValue (builder : LLVM.Builder llvmctx)\n    (v : LLVM.Value llvmctx) (name : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_io_result_get_value\"\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[v] name", "start": [275, 1], "end": [282, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanCtorRelease", "code": "def callLeanCtorRelease (builder : LLVM.Builder llvmctx)\n    (closure i : LLVM.Value llvmctx) (retName : String := \"\") : M llvmctx Unit := do\n  let fnName :=  \"lean_ctor_release\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx, \u2190 LLVM.size_tType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn  #[closure, i] retName", "start": [284, 1], "end": [291, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanCtorSetTag", "code": "def callLeanCtorSetTag (builder : LLVM.Builder llvmctx)\n    (closure i : LLVM.Value llvmctx) (retName : String := \"\") : M llvmctx Unit := do\n  let fnName :=  \"lean_ctor_set_tag\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx, \u2190 LLVM.size_tType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn  #[closure, i] retName", "start": [293, 1], "end": [300, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.toLLVMType", "code": "def toLLVMType (t : IRType) : M llvmctx (LLVM.LLVMType llvmctx) := do\n  match t with\n  | IRType.float      => LLVM.doubleTypeInContext llvmctx\n  | IRType.uint8      => LLVM.intTypeInContext llvmctx 8\n  | IRType.uint16     => LLVM.intTypeInContext llvmctx 16\n  | IRType.uint32     => LLVM.intTypeInContext llvmctx 32\n  | IRType.uint64     => LLVM.intTypeInContext llvmctx 64\n  | IRType.usize      => LLVM.size_tType llvmctx\n  | IRType.object     => do LLVM.pointerType (\u2190 LLVM.i8Type llvmctx)\n  | IRType.tobject    => do LLVM.pointerType (\u2190 LLVM.i8Type llvmctx)\n  | IRType.irrelevant => do LLVM.pointerType (\u2190 LLVM.i8Type llvmctx)\n  | IRType.struct _ _ => panic! \"not implemented yet\"\n  | IRType.union _ _  => panic! \"not implemented yet\"", "start": [302, 1], "end": [315, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.throwInvalidExportName", "code": "def throwInvalidExportName {\u03b1 : Type} (n : Name) : M llvmctx \u03b1 := do\n  throw s!\"invalid export name {n.toString}\"", "start": [317, 1], "end": [318, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.toCName", "code": "def toCName (n : Name) : M llvmctx String := do\n  match getExportNameFor? (\u2190 getEnv) n with\n  | some (.str .anonymous s) => pure s\n  | some _                   => throwInvalidExportName n\n  | none                     => if n == `main then pure leanMainFn else pure n.mangle", "start": [320, 1], "end": [324, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.toCInitName", "code": "def toCInitName (n : Name) : M llvmctx String := do\n  match getExportNameFor? (\u2190 getEnv) n with\n  | some (.str .anonymous s) => return \"_init_\" ++ s\n  | some _                   => throwInvalidExportName n\n  | none                     => pure (\"_init_\" ++ n.mangle)", "start": [326, 1], "end": [330, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.ShouldForwardControlFlow", "code": "inductive ShouldForwardControlFlow where\n| yes | no", "start": [332, 1], "end": [339, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.builderGetInsertionFn", "code": "def builderGetInsertionFn (builder : LLVM.Builder llvmctx) : M llvmctx (LLVM.Value llvmctx) := do\n  let builderBB \u2190 LLVM.getInsertBlock builder\n  LLVM.getBasicBlockParent builderBB", "start": [342, 1], "end": [344, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.builderAppendBasicBlock", "code": "def builderAppendBasicBlock (builder : LLVM.Builder llvmctx) (name : String) : M llvmctx (LLVM.BasicBlock llvmctx) := do\n  let fn \u2190 builderGetInsertionFn builder\n  LLVM.appendBasicBlockInContext llvmctx fn name", "start": [346, 1], "end": [348, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.buildWhile_", "code": "def buildWhile_ (builder : LLVM.Builder llvmctx) (name : String)\n    (condcodegen : LLVM.Builder llvmctx \u2192 M llvmctx (LLVM.Value llvmctx))\n    (bodycodegen : LLVM.Builder llvmctx \u2192 M llvmctx Unit) : M llvmctx Unit := do\n  let fn \u2190 builderGetInsertionFn builder\n\n  let nameHeader := name ++ \"header\"\n  let nameBody := name ++ \"body\"\n  let nameMerge := name ++ \"merge\"\n\n  let headerbb \u2190 LLVM.appendBasicBlockInContext llvmctx fn nameHeader\n  let _ \u2190 LLVM.buildBr builder headerbb\n\n  let bodybb \u2190 LLVM.appendBasicBlockInContext llvmctx fn nameBody\n  let mergebb \u2190 LLVM.appendBasicBlockInContext llvmctx fn nameMerge\n\n  LLVM.positionBuilderAtEnd builder headerbb\n  let cond \u2190 condcodegen builder\n  let _ \u2190 LLVM.buildCondBr builder cond bodybb mergebb\n\n  LLVM.positionBuilderAtEnd builder bodybb\n  bodycodegen builder\n  let _ \u2190 LLVM.buildBr builder headerbb\n\n  LLVM.positionBuilderAtEnd builder mergebb", "start": [350, 1], "end": [377, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.buildIfThen_", "code": "def buildIfThen_ (builder : LLVM.Builder llvmctx) (name : String) (brval : LLVM.Value llvmctx)\n    (thencodegen : LLVM.Builder llvmctx \u2192 M llvmctx ShouldForwardControlFlow) : M llvmctx Unit := do\n  let fn \u2190 builderGetInsertionFn builder\n\n  let nameThen := name ++ \"Then\"\n  let nameElse := name ++ \"Else\"\n  let nameMerge := name ++ \"Merge\"\n\n  let thenbb \u2190 LLVM.appendBasicBlockInContext llvmctx fn nameThen\n  let elsebb \u2190 LLVM.appendBasicBlockInContext llvmctx fn nameElse\n  let mergebb \u2190 LLVM.appendBasicBlockInContext llvmctx fn nameMerge\n  let _ \u2190 LLVM.buildCondBr builder brval thenbb elsebb\n  LLVM.positionBuilderAtEnd builder thenbb\n  let fwd? \u2190 thencodegen builder\n  match fwd? with\n  | .yes => let _ \u2190 LLVM.buildBr builder mergebb\n  | .no => pure ()\n  LLVM.positionBuilderAtEnd builder elsebb\n  let _ \u2190 LLVM.buildBr builder mergebb\n  LLVM.positionBuilderAtEnd builder mergebb", "start": [381, 1], "end": [403, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.buildIfThenElse_", "code": "def buildIfThenElse_ (builder : LLVM.Builder llvmctx)  (name : String) (brval : LLVM.Value llvmctx)\n    (thencodegen : LLVM.Builder llvmctx \u2192 M llvmctx ShouldForwardControlFlow)\n    (elsecodegen : LLVM.Builder llvmctx \u2192 M llvmctx ShouldForwardControlFlow) : M llvmctx Unit := do\n  let fn \u2190 LLVM.getBasicBlockParent (\u2190 LLVM.getInsertBlock builder)\n  let thenbb \u2190 LLVM.appendBasicBlockInContext llvmctx fn (name ++ \"Then\")\n  let elsebb \u2190 LLVM.appendBasicBlockInContext llvmctx fn (name ++ \"Else\")\n  let mergebb \u2190 LLVM.appendBasicBlockInContext llvmctx fn (name ++ \"Merge\")\n  let _ \u2190 LLVM.buildCondBr builder brval thenbb elsebb\n  LLVM.positionBuilderAtEnd builder thenbb\n  let fwd? \u2190 thencodegen builder\n  match fwd? with\n  | .yes => let _ \u2190 LLVM.buildBr builder mergebb\n  | .no => pure ()\n  LLVM.positionBuilderAtEnd builder elsebb\n  let fwd? \u2190 elsecodegen builder\n  match fwd? with\n  | .yes => let _ \u2190 LLVM.buildBr builder mergebb\n  | .no => pure ()\n  LLVM.positionBuilderAtEnd builder mergebb", "start": [405, 1], "end": [426, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.buildLeanBoolTrue?", "code": "def buildLeanBoolTrue? (builder : LLVM.Builder llvmctx)\n    (b : LLVM.Value llvmctx) (name : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  LLVM.buildICmp builder LLVM.IntPredicate.NE b (\u2190 LLVM.constInt8 llvmctx 0) name", "start": [429, 1], "end": [431, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitFnDeclAux", "code": "def emitFnDeclAux (mod : LLVM.Module llvmctx)\n    (decl : Decl) (cppBaseName : String) (isExternal : Bool) : M llvmctx (LLVM.Value llvmctx) := do\n  let ps := decl.params\n  let env \u2190 getEnv\n  let global \u2190\n    if ps.isEmpty then\n        let retty \u2190 (toLLVMType decl.resultType)\n        let global \u2190 LLVM.getOrAddGlobal mod cppBaseName retty\n        if !isExternal then\n          LLVM.setInitializer global (\u2190 LLVM.getUndef retty)\n        pure global\n    else\n        let retty \u2190 (toLLVMType decl.resultType)\n        let mut argtys := #[]\n        for p in ps do\n          if !(isExternC env decl.name) || !p.ty.isIrrelevant then\n            argtys := argtys.push (\u2190 toLLVMType p.ty)\n        if argtys.size > closureMaxArgs && isBoxedName decl.name then\n          argtys := #[\u2190 LLVM.pointerType (\u2190 LLVM.voidPtrType llvmctx)]\n        let fnty \u2190 LLVM.functionType retty argtys (isVarArg := false)\n        LLVM.getOrAddFunction mod cppBaseName fnty\n  if ps.isEmpty then\n    if isClosedTermName env decl.name then LLVM.setVisibility global LLVM.Visibility.hidden else if isExternal then pure () else LLVM.setDLLStorageClass global LLVM.DLLStorageClass.export  else if !isExternal\n    then LLVM.setDLLStorageClass global LLVM.DLLStorageClass.export\n  return global", "start": [433, 1], "end": [469, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitFnDecl", "code": "def emitFnDecl (decl : Decl) (isExternal : Bool) : M llvmctx Unit := do\n  let cppBaseName \u2190 toCName decl.name\n  let _ \u2190 emitFnDeclAux (\u2190 getLLVMModule) decl cppBaseName isExternal", "start": [472, 1], "end": [474, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitExternDeclAux", "code": "def emitExternDeclAux (decl : Decl) (cNameStr : String) : M llvmctx Unit := do\n  let env \u2190 getEnv\n  let extC := isExternC env decl.name\n  let _ \u2190 emitFnDeclAux (\u2190 getLLVMModule) decl cNameStr extC", "start": [476, 1], "end": [479, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitFnDecls", "code": "def emitFnDecls : M llvmctx Unit := do\n  let env \u2190 getEnv\n  let decls := getDecls env\n  let modDecls  : NameSet := decls.foldl (fun s d => s.insert d.name) {}\n  let usedDecls : NameSet := decls.foldl (fun s d => collectUsedDecls env d (s.insert d.name)) {}\n  let usedDecls := usedDecls.toList\n  for n in usedDecls do\n    let decl \u2190 getDecl n\n    match getExternNameFor env `c decl.name with\n    | some cName => emitExternDeclAux decl cName\n    | none       => emitFnDecl decl (!modDecls.contains n)\n  return ()", "start": [481, 1], "end": [492, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitLhsSlot_", "code": "def emitLhsSlot_ (x : VarId) : M llvmctx (LLVM.LLVMType llvmctx \u00d7 LLVM.Value llvmctx) := do\n  let state \u2190 get\n  match state.var2val.find? x with\n  | .some v => return v\n  | .none => throw s!\"unable to find variable {x}\"", "start": [494, 1], "end": [498, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitLhsVal", "code": "def emitLhsVal (builder : LLVM.Builder llvmctx)\n    (x : VarId) (name : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let (xty, xslot) \u2190 emitLhsSlot_ x\n  LLVM.buildLoad2 builder xty xslot name", "start": [500, 1], "end": [503, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitLhsSlotStore", "code": "def emitLhsSlotStore (builder : LLVM.Builder llvmctx)\n    (x : VarId) (v : LLVM.Value llvmctx) : M llvmctx Unit := do\n  let (_, slot) \u2190 emitLhsSlot_ x\n  LLVM.buildStore builder v slot", "start": [505, 1], "end": [508, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitArgSlot_", "code": "def emitArgSlot_ (builder : LLVM.Builder llvmctx)\n    (x : Arg) : M llvmctx (LLVM.LLVMType llvmctx \u00d7 LLVM.Value llvmctx) := do\n  match x with\n  | Arg.var x => emitLhsSlot_ x\n  | _ => do\n    let slotty \u2190 LLVM.voidPtrType llvmctx\n    let slot \u2190 LLVM.buildAlloca builder slotty \"irrelevant_slot\"\n    let v \u2190 callLeanBox builder (\u2190 LLVM.constIntUnsigned llvmctx 0) \"irrelevant_val\"\n    let _ \u2190 LLVM.buildStore builder v slot\n    return (slotty, slot)", "start": [510, 1], "end": [519, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitArgVal", "code": "def emitArgVal (builder : LLVM.Builder llvmctx)\n    (x : Arg) (name : String := \"\") : M llvmctx (LLVM.LLVMType llvmctx \u00d7 LLVM.Value llvmctx) := do\n  let (xty, xslot) \u2190 emitArgSlot_ builder x\n  let xval \u2190 LLVM.buildLoad2 builder xty xslot name\n  return (xty, xval)", "start": [521, 1], "end": [525, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitAllocCtor", "code": "def emitAllocCtor (builder : LLVM.Builder llvmctx)\n    (c : CtorInfo) : M llvmctx (LLVM.Value llvmctx) := do\n  let hackSizeofVoidPtr := 8\n  let scalarSize := hackSizeofVoidPtr * c.usize + c.ssize\n  callLeanAllocCtor builder c.cidx c.size scalarSize \"lean_alloc_ctor_out\"", "start": [527, 1], "end": [532, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitCtorSetArgs", "code": "def emitCtorSetArgs (builder : LLVM.Builder llvmctx)\n    (z : VarId) (ys : Array Arg) : M llvmctx Unit := do\n  ys.size.forM fun i => do\n    let zv \u2190 emitLhsVal builder z\n    let (_yty, yv) \u2190 emitArgVal builder ys[i]!\n    let iv \u2190 LLVM.constIntUnsigned llvmctx (UInt64.ofNat i)\n    callLeanCtorSet builder zv iv yv\n    emitLhsSlotStore builder z zv\n    pure ()", "start": [534, 1], "end": [542, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitCtor", "code": "def emitCtor (builder : LLVM.Builder llvmctx)\n    (z : VarId) (c : CtorInfo) (ys : Array Arg) : M llvmctx Unit := do\n  let (_llvmty, slot) \u2190 emitLhsSlot_ z\n  if c.size == 0 && c.usize == 0 && c.ssize == 0 then do\n    let v \u2190 callLeanBox builder (\u2190 constIntUnsigned c.cidx) \"lean_box_outv\"\n    let _ \u2190 LLVM.buildStore builder v slot\n  else do\n    let v \u2190 emitAllocCtor builder c\n    let _ \u2190 LLVM.buildStore builder v slot\n    emitCtorSetArgs builder z ys", "start": [544, 1], "end": [553, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitInc", "code": "def emitInc (builder : LLVM.Builder llvmctx)\n    (x : VarId) (n : Nat) (checkRef? : Bool) : M llvmctx Unit := do\n  let xv \u2190 emitLhsVal builder x\n  if n != 1\n  then do\n     let nv \u2190 LLVM.constIntUnsigned llvmctx (UInt64.ofNat n)\n     callLeanRefcountFn builder (kind := RefcountKind.inc) (checkRef? := checkRef?) (delta := nv) xv\n  else callLeanRefcountFn builder (kind := RefcountKind.inc) (checkRef? := checkRef?) xv", "start": [555, 1], "end": [562, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitDec", "code": "def emitDec (builder : LLVM.Builder llvmctx)\n    (x : VarId) (n : Nat) (checkRef? : Bool) : M llvmctx Unit := do\n  let xv \u2190 emitLhsVal builder x\n  if n != 1\n  then throw \"expected n = 1 for emitDec\"\n  else callLeanRefcountFn builder (kind := RefcountKind.dec) (checkRef? := checkRef?) xv", "start": [564, 1], "end": [569, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitNumLit", "code": "def emitNumLit (builder : LLVM.Builder llvmctx)\n    (t : IRType) (v : Nat) : M llvmctx (LLVM.Value llvmctx) := do\n  if t.isObj then\n    if v < UInt32.size then\n      callLeanUnsignedToNatFn builder v\n    else\n      callLeanCStrToNatFn builder v\n  else\n    LLVM.constInt (\u2190 toLLVMType t) (UInt64.ofNat v)", "start": [571, 1], "end": [579, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.toHexDigit", "code": "def toHexDigit (c : Nat) : String :=\n  String.singleton c.digitChar", "start": [581, 1], "end": [582, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.quoteString", "code": "def quoteString (s : String) : String :=\n  let q := \"\\\"\";\n  let q := s.foldl\n    (fun q c => q ++\n      if c == '\\n' then \"\\\\n\"\n      else if c == '\\r' then \"\\\\r\"\n      else if c == '\\t' then \"\\\\t\"\n      else if c == '\\\\' then \"\\\\\\\\\"\n      else if c == '\\\"' then \"\\\\\\\"\"\n      else if c.toNat <= 31 then\n        \"\\\\x\" ++ toHexDigit (c.toNat / 16) ++ toHexDigit (c.toNat % 16)\n      else String.singleton c)\n    q;\n  q ++ \"\\\"\"", "start": [585, 1], "end": [599, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitSimpleExternalCall", "code": "def emitSimpleExternalCall (builder : LLVM.Builder llvmctx)\n    (f : String)\n    (ps : Array Param)\n    (ys : Array Arg)\n    (retty : IRType)\n    (name : String) : M llvmctx (LLVM.Value llvmctx) := do\n  let mut args := #[]\n  let mut argTys := #[]\n  for (p, y) in ps.zip ys do\n    if !p.ty.isIrrelevant then\n      let (_yty, yv) \u2190 emitArgVal builder y \"\"\n      argTys := argTys.push (\u2190 toLLVMType p.ty)\n      args := args.push yv\n  let fnty \u2190 LLVM.functionType (\u2190 toLLVMType retty) argTys\n  let fn \u2190 LLVM.getOrAddFunction (\u2190 getLLVMModule) f fnty\n  LLVM.buildCall2 builder fnty fn args name", "start": [601, 1], "end": [616, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitExternCall", "code": "def emitExternCall (builder : LLVM.Builder llvmctx)\n    (f : FunId)\n    (ps : Array Param)\n    (extData : ExternAttrData)\n    (ys : Array Arg) (retty : IRType)\n    (name : String := \"\") : M llvmctx (LLVM.Value llvmctx) :=\n  match getExternEntryFor extData `c with\n  | some (ExternEntry.standard _ extFn) => emitSimpleExternalCall builder extFn ps ys retty name\n  | some (ExternEntry.inline \"llvm\" _pat) => throw \"Unimplemented codegen of inline LLVM\"\n  | some (ExternEntry.inline _ pat) => throw s!\"Cannot codegen non-LLVM inline code '{pat}'.\"\n  | some (ExternEntry.foreign _ extFn)  => emitSimpleExternalCall builder extFn ps ys retty name\n  | _ => throw s!\"Failed to emit extern application '{f}'.\"", "start": [620, 1], "end": [631, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.getFunIdTy", "code": "def getFunIdTy (f : FunId) : M llvmctx (LLVM.LLVMType llvmctx) := do\n  let decl \u2190 getDecl f\n  let retty \u2190 toLLVMType decl.resultType\n  let argtys \u2190 decl.params.mapM (fun p => do toLLVMType p.ty)\n  LLVM.functionType retty argtys", "start": [633, 1], "end": [637, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.getOrAddFunIdValue", "code": "def getOrAddFunIdValue (builder : LLVM.Builder llvmctx) (f : FunId) : M llvmctx (LLVM.Value llvmctx) := do\n  let decl \u2190 getDecl f\n  let fcname \u2190 toCName f\n  let retty \u2190 toLLVMType decl.resultType\n  if decl.params.isEmpty then\n     let gslot \u2190 LLVM.getOrAddGlobal (\u2190 getLLVMModule) fcname retty\n     LLVM.buildLoad2 builder retty gslot\n  else\n    let argtys \u2190 decl.params.mapM (fun p => do toLLVMType p.ty)\n    let fnty \u2190 LLVM.functionType retty argtys\n    LLVM.getOrAddFunction (\u2190 getLLVMModule) fcname fnty", "start": [639, 1], "end": [656, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitPartialApp", "code": "def emitPartialApp (builder : LLVM.Builder llvmctx) (z : VarId) (f : FunId) (ys : Array Arg) : M llvmctx Unit := do\n  let decl \u2190 getDecl f\n  let fv \u2190 getOrAddFunIdValue builder f\n  let arity := decl.params.size\n  let (_zty, zslot) \u2190 emitLhsSlot_ z\n  let zval \u2190 callLeanAllocClosureFn builder fv\n                                    (\u2190 constIntUnsigned arity)\n                                    (\u2190 constIntUnsigned ys.size)\n  LLVM.buildStore builder zval zslot\n  ys.size.forM fun i => do\n    let (yty, yslot) \u2190 emitArgSlot_ builder ys[i]!\n    let yval \u2190 LLVM.buildLoad2 builder yty yslot\n    callLeanClosureSetFn builder zval (\u2190 constIntUnsigned i) yval", "start": [658, 1], "end": [670, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitApp", "code": "def emitApp (builder : LLVM.Builder llvmctx) (z : VarId) (f : VarId) (ys : Array Arg) : M llvmctx Unit := do\n  if ys.size > closureMaxArgs then do\n    let aargs \u2190 LLVM.buildAlloca builder (\u2190 LLVM.arrayType (\u2190 LLVM.voidPtrType llvmctx) (UInt64.ofNat ys.size)) \"aargs\"\n    for i in List.range ys.size do\n      let (yty, yv) \u2190 emitArgVal builder ys[i]!\n      let aslot \u2190 LLVM.buildInBoundsGEP2 builder yty aargs #[\u2190 constIntUnsigned 0, \u2190 constIntUnsigned i] s!\"param_{i}_slot\"\n      LLVM.buildStore builder yv aslot\n    let fnName :=  s!\"lean_apply_m\"\n    let retty \u2190 LLVM.voidPtrType llvmctx\n    let args := #[\u2190 emitLhsVal builder f, \u2190 constIntUnsigned ys.size, aargs]\n    let argtys := #[\u2190 LLVM.voidPtrType llvmctx]\n    let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n    let fnty \u2190 LLVM.functionType retty argtys\n    let zv \u2190 LLVM.buildCall2 builder fnty fn args\n    emitLhsSlotStore builder z zv\n  else do\n\n    let fnName :=  s!\"lean_apply_{ys.size}\"\n    let retty \u2190 LLVM.voidPtrType llvmctx\n    let args : Array (LLVM.Value llvmctx) := #[\u2190 emitLhsVal builder f] ++ (\u2190 ys.mapM (fun y => Prod.snd <$> (emitArgVal builder y)))\n    let argtys := (List.replicate (1 + ys.size) (\u2190 LLVM.voidPtrType llvmctx)).toArray\n    let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n    let fnty \u2190 LLVM.functionType retty argtys\n    let zv \u2190 LLVM.buildCall2 builder fnty fn args\n    emitLhsSlotStore builder z zv", "start": [672, 1], "end": [698, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitFullApp", "code": "def emitFullApp (builder : LLVM.Builder llvmctx)\n    (z : VarId) (f : FunId) (ys : Array Arg) : M llvmctx Unit := do\n  let (__zty, zslot) \u2190 emitLhsSlot_ z\n  let decl \u2190 getDecl f\n  match decl with\n  | Decl.extern _ ps retty extData =>\n     let zv \u2190 emitExternCall builder f ps extData ys retty\n     LLVM.buildStore builder zv zslot\n  | Decl.fdecl .. =>\n    if ys.size > 0 then\n        let fv \u2190 getOrAddFunIdValue builder f\n        let ys \u2190  ys.mapM (fun y => do\n            let (yty, yslot) \u2190 emitArgSlot_ builder y\n            let yv \u2190 LLVM.buildLoad2 builder yty yslot\n            return yv)\n        let zv \u2190 LLVM.buildCall2 builder (\u2190 getFunIdTy f) fv ys\n        LLVM.buildStore builder zv zslot\n    else\n       let zv \u2190 getOrAddFunIdValue builder f\n       LLVM.buildStore builder zv zslot", "start": [700, 1], "end": [719, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitLit", "code": "def emitLit (builder : LLVM.Builder llvmctx)\n    (z : VarId) (t : IRType) (v : LitVal) : M llvmctx (LLVM.Value llvmctx) := do\n  let llvmty \u2190 toLLVMType t\n  let zslot \u2190 LLVM.buildAlloca builder llvmty\n  addVartoState z zslot llvmty\n  let zv \u2190 match v with\n            | LitVal.num v => emitNumLit builder t v\n            | LitVal.str v =>\n                 let zero \u2190 LLVM.constIntUnsigned llvmctx 0\n                 let str_global \u2190 LLVM.buildGlobalString builder v\n                 let strPtr \u2190 LLVM.buildInBoundsGEP2 builder\n                                (\u2190 LLVM.opaquePointerTypeInContext llvmctx)\n                                str_global #[zero] \"\"\n                 let nbytes \u2190 LLVM.constIntUnsigned llvmctx (UInt64.ofNat (v.utf8ByteSize))\n                 callLeanMkStringFromBytesFn builder strPtr nbytes \"\"\n  LLVM.buildStore builder zv zslot\n  return zslot", "start": [722, 1], "end": [739, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanCtorGet", "code": "def callLeanCtorGet (builder : LLVM.Builder llvmctx)\n    (x i : LLVM.Value llvmctx) (retName : String) : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_ctor_get\"\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx, \u2190 LLVM.i32Type llvmctx]\n  let fnty \u2190 LLVM.functionType retty argtys\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let i \u2190 LLVM.buildSextOrTrunc builder i (\u2190 LLVM.i32Type llvmctx)\n  LLVM.buildCall2 builder fnty fn  #[x, i] retName", "start": [741, 1], "end": [749, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitProj", "code": "def emitProj (builder : LLVM.Builder llvmctx) (z : VarId) (i : Nat) (x : VarId) : M llvmctx Unit := do\n  let xval \u2190 emitLhsVal builder x\n  let zval \u2190 callLeanCtorGet builder xval (\u2190 constIntUnsigned i) \"\"\n  emitLhsSlotStore builder z zval", "start": [751, 1], "end": [754, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanCtorGetUsize", "code": "def callLeanCtorGetUsize (builder : LLVM.Builder llvmctx)\n    (x i : LLVM.Value llvmctx) (retName : String) : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_ctor_get_usize\"\n  let retty \u2190 LLVM.size_tType llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx, \u2190 LLVM.size_tType llvmctx]\n  let fnty \u2190 LLVM.functionType retty argtys\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  LLVM.buildCall2 builder fnty fn  #[x, i] retName", "start": [756, 1], "end": [763, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitUProj", "code": "def emitUProj (builder : LLVM.Builder llvmctx) (z : VarId) (i : Nat) (x : VarId) : M llvmctx Unit := do\n  let xval \u2190 emitLhsVal builder x\n  let zval \u2190 callLeanCtorGetUsize builder xval (\u2190 constIntUnsigned i) \"\"\n  emitLhsSlotStore builder z zval", "start": [765, 1], "end": [768, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitOffset", "code": "def emitOffset (builder : LLVM.Builder llvmctx)\n    (n : Nat) (offset : Nat) : M llvmctx (LLVM.Value llvmctx) := do\n   let out \u2190 constIntUnsigned 8\n   let out \u2190 LLVM.buildMul builder out (\u2190 constIntUnsigned n) \"\" LLVM.buildAdd builder out (\u2190 constIntUnsigned offset) \"\"", "start": [770, 1], "end": [775, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitSProj", "code": "def emitSProj (builder : LLVM.Builder llvmctx)\n    (z : VarId) (t : IRType) (n offset : Nat) (x : VarId) : M llvmctx Unit := do\n  let (fnName, retty) \u2190\n    match t with\n    | IRType.float  => pure (\"lean_ctor_get_float\", \u2190 LLVM.doubleTypeInContext llvmctx)\n    | IRType.uint8  => pure (\"lean_ctor_get_uint8\", \u2190 LLVM.i8Type llvmctx)\n    | IRType.uint16 => pure (\"lean_ctor_get_uint16\", \u2190  LLVM.i16Type llvmctx)\n    | IRType.uint32 => pure (\"lean_ctor_get_uint32\", \u2190 LLVM.i32Type llvmctx)\n    | IRType.uint64 => pure (\"lean_ctor_get_uint64\", \u2190 LLVM.i64Type llvmctx)\n    | _             => throw s!\"Invalid type for lean_ctor_get: '{t}'\"\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx, \u2190 LLVM.size_tType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let xval \u2190 emitLhsVal builder x\n  let offset \u2190 emitOffset builder n offset\n  let fnty \u2190 LLVM.functionType retty argtys\n  let zval \u2190 LLVM.buildCall2 builder fnty fn  #[xval, offset]\n  emitLhsSlotStore builder z zval", "start": [777, 1], "end": [793, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanIsExclusive", "code": "def callLeanIsExclusive (builder : LLVM.Builder llvmctx)\n    (closure : LLVM.Value llvmctx) (retName : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_is_exclusive\"\n  let retty \u2190 LLVM.i1Type llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let out \u2190 LLVM.buildCall2 builder fnty fn  #[closure] retName\n  LLVM.buildSextOrTrunc builder out (\u2190 LLVM.i8Type llvmctx)", "start": [795, 1], "end": [803, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanIsScalar", "code": "def callLeanIsScalar (builder : LLVM.Builder llvmctx)\n    (closure : LLVM.Value llvmctx) (retName : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_is_scalar\"\n  let retty \u2190 LLVM.i8Type llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn  #[closure] retName", "start": [805, 1], "end": [812, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitIsShared", "code": "def emitIsShared (builder : LLVM.Builder llvmctx) (z : VarId) (x : VarId) : M llvmctx Unit := do\n    let xv \u2190 emitLhsVal builder x\n    let exclusive? \u2190 callLeanIsExclusive builder xv\n    let exclusive? \u2190 LLVM.buildSextOrTrunc builder exclusive? (\u2190 LLVM.i1Type llvmctx)\n    let shared? \u2190 LLVM.buildNot builder exclusive?\n    let shared? \u2190 LLVM.buildSext builder shared? (\u2190 LLVM.i8Type llvmctx)\n    emitLhsSlotStore builder z shared?", "start": [814, 1], "end": [820, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitBox", "code": "def emitBox (builder : LLVM.Builder llvmctx) (z : VarId) (x : VarId) (xType : IRType) : M llvmctx Unit := do\n  let xv \u2190 emitLhsVal builder x\n  let (fnName, argTy, xv) \u2190\n    match xType with\n    | IRType.usize  => pure (\"lean_box_usize\", \u2190 LLVM.size_tType llvmctx, xv)\n    | IRType.uint32 => pure (\"lean_box_uint32\", \u2190 LLVM.i32Type llvmctx, xv)\n    | IRType.uint64 => pure (\"lean_box_uint64\", \u2190 LLVM.size_tType llvmctx, xv)\n    | IRType.float  => pure (\"lean_box_float\", \u2190 LLVM.doubleTypeInContext llvmctx, xv)\n    | _             => do\n         let xv \u2190 LLVM.buildSext builder xv (\u2190 LLVM.size_tType llvmctx)\n         pure (\"lean_box\", \u2190 LLVM.size_tType llvmctx, xv)\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let argtys := #[argTy]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let zv \u2190 LLVM.buildCall2 builder fnty fn  #[xv]\n  emitLhsSlotStore builder z zv", "start": [822, 1], "end": [839, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.IRType.isIntegerType", "code": "def IRType.isIntegerType (t : IRType) : Bool :=\n  match t with\n  | .uint8 => true\n  | .uint16 => true\n  | .uint32 => true\n  | .uint64 => true\n  | .usize => true\n  | _ => false", "start": [841, 1], "end": [848, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callUnboxForType", "code": "def callUnboxForType (builder : LLVM.Builder llvmctx)\n    (t : IRType)\n    (v : LLVM.Value llvmctx)\n    (retName : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let (fnName, retty) \u2190\n     match t with\n     | IRType.usize  => pure (\"lean_unbox_usize\", \u2190 toLLVMType t)\n     | IRType.uint32 => pure (\"lean_unbox_uint32\", \u2190 toLLVMType t)\n     | IRType.uint64 => pure (\"lean_unbox_uint64\", \u2190 toLLVMType t)\n     | IRType.float  => pure (\"lean_unbox_float\", \u2190 toLLVMType t)\n     | _             => pure (\"lean_unbox\", \u2190 LLVM.size_tType llvmctx)\n  let argtys := #[\u2190 LLVM.voidPtrType llvmctx ]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[v] retName", "start": [850, 1], "end": [864, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitUnbox", "code": "def emitUnbox (builder : LLVM.Builder llvmctx)\n    (z : VarId) (t : IRType) (x : VarId) (retName : String := \"\") : M llvmctx Unit := do\n  let zval \u2190 callUnboxForType builder t (\u2190 emitLhsVal builder x) retName\n  let zval \u2190\n    if IRType.isIntegerType t\n    then LLVM.buildSextOrTrunc builder zval (\u2190 toLLVMType t)\n    else pure zval\n  emitLhsSlotStore builder z zval", "start": [868, 1], "end": [877, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitReset", "code": "def emitReset (builder : LLVM.Builder llvmctx) (z : VarId) (n : Nat) (x : VarId) : M llvmctx Unit := do\n  let xv \u2190 emitLhsVal builder x\n  let isExclusive \u2190 callLeanIsExclusive builder xv\n  let isExclusive \u2190 buildLeanBoolTrue? builder isExclusive\n  buildIfThenElse_ builder \"isExclusive\" isExclusive\n   (fun builder => do\n     let xv \u2190 emitLhsVal builder x\n     n.forM fun i => do\n         callLeanCtorRelease builder xv (\u2190 constIntUnsigned i)\n     emitLhsSlotStore builder z xv\n     return ShouldForwardControlFlow.yes\n   )\n   (fun builder => do\n      let xv \u2190 emitLhsVal builder x\n      callLeanDecRef builder xv\n      let box0 \u2190 callLeanBox builder (\u2190 constIntUnsigned 0) \"box0\"\n      emitLhsSlotStore builder z box0\n      return ShouldForwardControlFlow.yes\n   )", "start": [879, 1], "end": [897, 5], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitReuse", "code": "def emitReuse (builder : LLVM.Builder llvmctx)\n    (z : VarId) (x : VarId) (c : CtorInfo) (updtHeader : Bool) (ys : Array Arg) : M llvmctx Unit := do\n  let xv \u2190 emitLhsVal builder x\n  let isScalar \u2190 callLeanIsScalar builder xv\n  let isScalar \u2190 buildLeanBoolTrue? builder isScalar\n  buildIfThenElse_ builder  \"isScalar\" isScalar\n    (fun builder => do\n      let cv \u2190 emitAllocCtor builder c\n      emitLhsSlotStore builder z cv\n      return ShouldForwardControlFlow.yes\n   )\n   (fun builder => do\n       let xv \u2190 emitLhsVal builder x\n       emitLhsSlotStore builder z xv\n       if updtHeader then\n          let zv \u2190 emitLhsVal builder z\n          callLeanCtorSetTag builder zv (\u2190 constIntUnsigned c.cidx)\n       return ShouldForwardControlFlow.yes\n   )\n  emitCtorSetArgs builder z ys", "start": [899, 1], "end": [918, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitVDecl", "code": "def emitVDecl (builder : LLVM.Builder llvmctx) (z : VarId) (t : IRType) (v : Expr) : M llvmctx Unit := do\n  match v with\n  | Expr.ctor c ys      => emitCtor builder z c ys\n  | Expr.reset n x      => emitReset builder z n x\n  | Expr.reuse x c u ys => emitReuse builder z x c u ys\n  | Expr.proj i x       => emitProj builder z i x\n  | Expr.uproj i x      => emitUProj builder z i x\n  | Expr.sproj n o x    => emitSProj builder z t n o x\n  | Expr.fap c ys       => emitFullApp builder z c ys\n  | Expr.pap c ys       => emitPartialApp builder z c ys\n  | Expr.ap x ys        => emitApp builder z x ys\n  | Expr.box t x        => emitBox builder z x t\n  | Expr.unbox x        => emitUnbox builder z t x\n  | Expr.isShared x     => emitIsShared builder z x\n  | Expr.lit v          => let _ \u2190 emitLit builder z t v", "start": [920, 1], "end": [934, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.declareVar", "code": "def declareVar (builder : LLVM.Builder llvmctx) (x : VarId) (t : IRType) : M llvmctx Unit := do\n  let llvmty \u2190 toLLVMType t\n  let alloca \u2190 LLVM.buildAlloca builder llvmty \"varx\"\n  addVartoState x alloca llvmty", "start": [936, 1], "end": [939, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.declareVars", "code": "partial def declareVars (builder : LLVM.Builder llvmctx) (f : FnBody) : M llvmctx Unit := do\n  match f with\n  | FnBody.vdecl x t _ b => do\n      declareVar builder x t\n      declareVars builder b\n  | FnBody.jdecl _ xs _ b => do\n      for param in xs do declareVar builder param.x param.ty\n      declareVars builder b\n  | e => do\n      if e.isTerminal then pure () else declareVars builder e.body", "start": [941, 1], "end": [950, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitTag", "code": "def emitTag (builder : LLVM.Builder llvmctx) (x : VarId) (xType : IRType) : M llvmctx (LLVM.Value llvmctx) := do\n  if xType.isObj then do\n    let xval \u2190 emitLhsVal builder x\n    callLeanObjTag builder xval\n  else if xType.isScalar then do\n    emitLhsVal builder x\n  else\n    throw \"Do not know how to `emitTag` in general.\"", "start": [952, 1], "end": [959, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitSet", "code": "def emitSet (builder : LLVM.Builder llvmctx) (x : VarId) (i : Nat) (y : Arg) : M llvmctx Unit := do\n  let fnName :=  \"lean_ctor_set\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx, \u2190 LLVM.size_tType llvmctx, \u2190 LLVM.voidPtrType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn  #[\u2190 emitLhsVal builder x, \u2190 constIntUnsigned i, (\u2190 emitArgVal builder y).2]", "start": [961, 1], "end": [967, 119], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitUSet", "code": "def emitUSet (builder : LLVM.Builder llvmctx) (x : VarId) (i : Nat) (y : VarId) : M llvmctx Unit := do\n  let fnName :=  \"lean_ctor_set_usize\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx, \u2190 LLVM.size_tType llvmctx, \u2190 LLVM.size_tType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn  #[\u2190 emitLhsVal builder x, \u2190 constIntUnsigned i, (\u2190 emitLhsVal builder y)]", "start": [969, 1], "end": [975, 117], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitTailCall", "code": "def emitTailCall (builder : LLVM.Builder llvmctx) (f : FunId) (v : Expr) : M llvmctx Unit := do\n   match v with\n  | Expr.fap _ ys => do\n    let llvmctx \u2190 read\n    let ps := llvmctx.mainParams\n    unless ps.size == ys.size do throw s!\"Invalid tail call. f:'{f}' v:'{v}'\"\n    let args \u2190 ys.mapM (fun y => Prod.snd <$> emitArgVal builder y)\n    let fn \u2190 builderGetInsertionFn builder\n    let call \u2190 LLVM.buildCall2 builder (\u2190 getFunIdTy f) fn args\n    LLVM.setTailCall call true let _ \u2190 LLVM.buildRet builder call\n  | _ => throw s!\"EmitTailCall expects function application, found '{v}'\"", "start": [977, 1], "end": [989, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitJmp", "code": "def emitJmp (builder : LLVM.Builder llvmctx) (jp : JoinPointId) (xs : Array Arg) : M llvmctx Unit := do\n let llvmctx \u2190 read\n  let ps \u2190 match llvmctx.jpMap.find? jp with\n  | some ps => pure ps\n  | none    => throw s!\"Unknown join point {jp}\"\n  unless xs.size == ps.size do throw s!\"Invalid goto, mismatched sizes between arguments, formal parameters.\"\n  for (p, x)  in ps.zip xs do\n    let (_xty, xv) \u2190 emitArgVal builder x\n    emitLhsSlotStore builder p.x xv\n  let _ \u2190 LLVM.buildBr builder (\u2190 emitJp jp)", "start": [991, 1], "end": [1000, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitSSet", "code": "def emitSSet (builder : LLVM.Builder llvmctx) (x : VarId) (n : Nat) (offset : Nat) (y : VarId) (t : IRType) : M llvmctx Unit := do\n  let (fnName, setty) \u2190\n  match t with\n  | IRType.float  => pure (\"lean_ctor_set_float\", \u2190 LLVM.doubleTypeInContext llvmctx)\n  | IRType.uint8  => pure (\"lean_ctor_set_uint8\", \u2190 LLVM.i8Type llvmctx)\n  | IRType.uint16 => pure (\"lean_ctor_set_uint16\", \u2190 LLVM.i16Type llvmctx)\n  | IRType.uint32 => pure (\"lean_ctor_set_uint32\", \u2190 LLVM.i32Type llvmctx)\n  | IRType.uint64 => pure (\"lean_ctor_set_uint64\", \u2190 LLVM.i64Type llvmctx)\n  | _             => throw s!\"invalid type for 'lean_ctor_set': '{t}'\"\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx, \u2190 LLVM.size_tType llvmctx, setty]\n  let retty  \u2190 LLVM.voidType llvmctx\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let xv \u2190 emitLhsVal builder x\n  let offset \u2190 emitOffset builder n offset\n  let yv \u2190 emitLhsVal builder y\n  let fnty \u2190 LLVM.functionType retty argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn  #[xv, offset, yv]", "start": [1002, 1], "end": [1018, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitDel", "code": "def emitDel (builder : LLVM.Builder llvmctx) (x : VarId) : M llvmctx Unit := do\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx]\n  let retty  \u2190 LLVM.voidType llvmctx\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty \"lean_free_object\" argtys\n  let xv \u2190 emitLhsVal builder x\n  let fnty \u2190 LLVM.functionType retty argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn  #[xv]", "start": [1020, 1], "end": [1026, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitSetTag", "code": "def emitSetTag (builder : LLVM.Builder llvmctx) (x : VarId) (i : Nat) : M llvmctx Unit := do\n  let argtys := #[\u2190 LLVM.voidPtrType llvmctx, \u2190 LLVM.size_tType llvmctx]\n  let retty  \u2190 LLVM.voidType llvmctx\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty \"lean_ctor_set_tag\" argtys\n  let xv \u2190 emitLhsVal builder x\n  let fnty \u2190 LLVM.functionType retty argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn  #[xv, \u2190 constIntUnsigned i]", "start": [1028, 1], "end": [1034, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.ensureHasDefault'", "code": "def ensureHasDefault' (alts : Array Alt) : Array Alt :=\n  if alts.any Alt.isDefault then alts\n  else\n    let last := alts.back\n    let alts := alts.pop\n    alts.push (Alt.default last.body)", "start": [1036, 1], "end": [1041, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitCase", "code": "partial def emitCase (builder : LLVM.Builder llvmctx)\n    (x : VarId) (xType : IRType) (alts : Array Alt) : M llvmctx Unit := do\n  let oldBB \u2190 LLVM.getInsertBlock builder\n  let tag \u2190 emitTag builder x xType\n  let tag \u2190 LLVM.buildZext builder tag (\u2190 LLVM.i64Type llvmctx)\n  let alts := ensureHasDefault' alts\n  let defaultBB \u2190 builderAppendBasicBlock builder s!\"case_{xType}_default\"\n  let numCasesHint := alts.size\n  let switch \u2190 LLVM.buildSwitch builder tag defaultBB (UInt64.ofNat numCasesHint)\n  alts.forM fun alt => do\n    match alt with\n    | Alt.ctor c b  =>\n       let destbb \u2190 builderAppendBasicBlock builder s!\"case_{xType}_{c.name}_{c.cidx}\"\n       LLVM.addCase switch (\u2190 constIntUnsigned c.cidx) destbb\n       LLVM.positionBuilderAtEnd builder destbb\n       emitFnBody builder b\n    | Alt.default b =>\n       LLVM.positionBuilderAtEnd builder defaultBB\n       emitFnBody builder b\n  LLVM.clearInsertionPosition builder\n  LLVM.positionBuilderAtEnd builder oldBB", "start": [1044, 1], "end": [1067, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitJDecl", "code": "partial def emitJDecl (builder : LLVM.Builder llvmctx)\n    (jp : JoinPointId) (_ps : Array Param) (b : FnBody) : M llvmctx Unit := do\n  let oldBB \u2190 LLVM.getInsertBlock builder\n  let jpbb \u2190 builderAppendBasicBlock builder s!\"jp_{jp.idx}\"\n  addJpTostate jp jpbb\n  LLVM.positionBuilderAtEnd builder jpbb\n  declareVars builder b\n  emitBlock builder b\n  LLVM.positionBuilderAtEnd builder oldBB", "start": [1070, 1], "end": [1083, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitUnreachable", "code": "partial def emitUnreachable (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := #[]\n  let fn \u2190 getOrCreateFunctionPrototype  (\u2190 getLLVMModule) retty \"lean_internal_panic_unreachable\" argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn #[]\n  let _ \u2190 LLVM.buildUnreachable builder", "start": [1085, 1], "end": [1091, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitBlock", "code": "partial def emitBlock (builder : LLVM.Builder llvmctx) (b : FnBody) : M llvmctx Unit := do\n  match b with\n  | FnBody.jdecl j xs  v b      =>\n       emitJDecl builder j xs v\n       emitBlock builder b\n  | d@(FnBody.vdecl x t v b)   => do\n    let llvmctx \u2190 read\n    if isTailCallTo llvmctx.mainFn d then\n      emitTailCall builder llvmctx.mainFn v\n    else\n      emitVDecl builder x t v\n      emitBlock builder b\n  | FnBody.inc x n c p b       =>\n    unless p do emitInc builder x n c\n    emitBlock builder b\n  | FnBody.dec x n c p b       =>\n    unless p do emitDec builder x n c\n    emitBlock builder b\n  | FnBody.del x b             =>  emitDel builder x; emitBlock builder b\n  | FnBody.setTag x i b        =>  emitSetTag builder x i; emitBlock builder b\n  | FnBody.set x i y b         => emitSet builder x i y; emitBlock builder b\n  | FnBody.uset x i y b        => emitUSet builder x i y; emitBlock builder b\n  | FnBody.sset x i o y t b    => emitSSet builder x i o y t; emitBlock builder b\n  | FnBody.mdata _ b           => emitBlock builder b\n  | FnBody.ret x               => do\n      let (_xty, xv) \u2190 emitArgVal builder x \"ret_val\"\n      let _ \u2190 LLVM.buildRet builder xv\n  | FnBody.case _ x xType alts =>\n     emitCase builder x xType alts\n  | FnBody.jmp j xs            =>\n     emitJmp builder j xs\n  | FnBody.unreachable         => emitUnreachable builder", "start": [1093, 1], "end": [1124, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitFnBody", "code": "partial def emitFnBody  (builder : LLVM.Builder llvmctx)  (b : FnBody) : M llvmctx Unit := do\n  declareVars builder b\n  emitBlock builder b", "start": [1126, 1], "end": [1128, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitFnArgs", "code": "def emitFnArgs (builder : LLVM.Builder llvmctx)\n    (needsPackedArgs? : Bool)  (llvmfn : LLVM.Value llvmctx) (params : Array Param) : M llvmctx Unit := do\n  if needsPackedArgs? then do\n      let argsp \u2190 LLVM.getParam llvmfn 0 for i in List.range params.size do\n          let param := params[i]!\n          let argsi \u2190 LLVM.buildGEP2 builder (\u2190 LLVM.voidPtrType llvmctx) argsp #[\u2190 constIntUnsigned i] s!\"packed_arg_{i}_slot\"\n          let llvmty \u2190 toLLVMType param.ty\n          let pv \u2190 LLVM.buildLoad2 builder llvmty argsi\n          let alloca \u2190 LLVM.buildAlloca builder llvmty s!\"arg_{i}\"\n          LLVM.buildStore builder pv alloca\n          addVartoState params[i]!.x alloca llvmty\n  else\n      let n \u2190 LLVM.countParams llvmfn\n      for i in (List.range n.toNat) do\n        let llvmty \u2190 toLLVMType params[i]!.ty\n        let alloca \u2190 LLVM.buildAlloca builder  llvmty s!\"arg_{i}\"\n        let arg \u2190 LLVM.getParam llvmfn (UInt64.ofNat i)\n        let _ \u2190 LLVM.buildStore builder arg alloca\n        addVartoState params[i]!.x alloca llvmty", "start": [1132, 1], "end": [1154, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitDeclAux", "code": "def emitDeclAux (mod : LLVM.Module llvmctx) (builder : LLVM.Builder llvmctx) (d : Decl) : M llvmctx Unit := do\n  let env \u2190 getEnv\n  let (_, jpMap) := mkVarJPMaps d\n  withReader (fun llvmctx => { llvmctx with jpMap := jpMap }) do\n  unless hasInitAttr env d.name do\n    match d with\n    | .fdecl (f := f) (xs := xs) (type := t) (body := b) .. =>\n      let baseName \u2190 toCName f\n      let name := if xs.size > 0 then baseName else \"_init_\" ++ baseName\n      let retty \u2190 toLLVMType t\n      let mut argtys := #[]\n      let needsPackedArgs? := xs.size > closureMaxArgs && isBoxedName d.name\n      if needsPackedArgs? then\n          argtys := #[\u2190 LLVM.pointerType (\u2190 LLVM.voidPtrType llvmctx)]\n      else\n        for x in xs do\n          argtys := argtys.push (\u2190 toLLVMType x.ty)\n      let fnty \u2190 LLVM.functionType retty argtys (isVarArg := false)\n      let llvmfn \u2190 LLVM.getOrAddFunction mod name fnty\n      if xs.size == 0 then\n        LLVM.setVisibility llvmfn LLVM.Visibility.hidden else\n        LLVM.setDLLStorageClass llvmfn LLVM.DLLStorageClass.export  withReader (fun llvmctx => { llvmctx with mainFn := f, mainParams := xs }) do\n        set { var2val := default, jp2bb := default : EmitLLVM.State llvmctx } let bb \u2190 LLVM.appendBasicBlockInContext llvmctx llvmfn \"entry\"\n        LLVM.positionBuilderAtEnd builder bb\n        emitFnArgs builder needsPackedArgs? llvmfn xs\n        emitFnBody builder b\n      pure ()\n    | _ => pure ()", "start": [1156, 1], "end": [1190, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitDecl", "code": "def emitDecl (mod : LLVM.Module llvmctx) (builder : LLVM.Builder llvmctx) (d : Decl) : M llvmctx Unit := do\n  let d := d.normalizeIds try\n    emitDeclAux mod builder d\n    return ()\n  catch err =>\n    throw (s!\"emitDecl:\\ncompiling:\\n{d}\\nerr:\\n{err}\\n\")", "start": [1192, 1], "end": [1198, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitFns", "code": "def emitFns (mod : LLVM.Module llvmctx) (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let env \u2190 getEnv\n  let decls := getDecls env\n  decls.reverse.forM (emitDecl mod builder)", "start": [1200, 1], "end": [1203, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callIODeclInitFn", "code": "def callIODeclInitFn (builder : LLVM.Builder llvmctx)\n    (initFnName : String)\n    (world : LLVM.Value llvmctx): M llvmctx (LLVM.Value llvmctx) := do\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let argtys := #[\u2190 LLVM.voidPtrType llvmctx]\n  let fn \u2190 getOrCreateFunctionPrototype  (\u2190 getLLVMModule) retty initFnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[world]", "start": [1205, 1], "end": [1212, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callPureDeclInitFn", "code": "def callPureDeclInitFn (builder : LLVM.Builder llvmctx)\n    (initFnName : String)\n    (retty : LLVM.LLVMType llvmctx): M llvmctx (LLVM.Value llvmctx) := do\n  let argtys := #[]\n  let fn \u2190 getOrCreateFunctionPrototype  (\u2190 getLLVMModule) retty initFnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[]", "start": [1214, 1], "end": [1220, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitDeclInit", "code": "def emitDeclInit (builder : LLVM.Builder llvmctx)\n    (parentFn : LLVM.Value llvmctx) (d : Decl) : M llvmctx Unit := do\n  let env \u2190 getEnv\n  if isIOUnitInitFn env d.name then do\n    let world \u2190 callLeanIOMkWorld builder\n    let resv \u2190 callIODeclInitFn builder (\u2190 toCName d.name) world\n    let err? \u2190 callLeanIOResultIsError builder resv \"is_error\"\n    buildIfThen_ builder s!\"init_{d.name}_isError\" err?\n      (fun builder => do\n        let _ \u2190 LLVM.buildRet builder resv\n        pure ShouldForwardControlFlow.no)\n    else if d.params.size == 0 then\n    match getInitFnNameFor? env d.name with\n    | some initFn =>\n      let llvmty \u2190 toLLVMType d.resultType\n      let dslot \u2190  LLVM.getOrAddGlobal (\u2190 getLLVMModule) (\u2190 toCName d.name) llvmty\n      LLVM.setInitializer dslot (\u2190 LLVM.getUndef llvmty)\n      let initBB \u2190 builderAppendBasicBlock builder s!\"do_{d.name}_init\"\n      let restBB \u2190 builderAppendBasicBlock builder s!\"post_{d.name}_init\"\n      let checkBuiltin? := getBuiltinInitFnNameFor? env d.name |>.isSome\n      if checkBuiltin? then\n        let builtinParam \u2190 LLVM.getParam parentFn 0\n        let cond \u2190 buildLeanBoolTrue? builder builtinParam \"is_builtin_true\"\n        let _ \u2190 LLVM.buildCondBr builder cond initBB restBB\n       else\n        let _ \u2190 LLVM.buildBr builder initBB\n      LLVM.positionBuilderAtEnd builder initBB\n      let world \u2190 callLeanIOMkWorld builder\n      let resv \u2190 callIODeclInitFn builder (\u2190 toCName initFn) world\n      let err? \u2190 callLeanIOResultIsError builder resv s!\"{d.name}_is_error\"\n      buildIfThen_ builder s!\"init_{d.name}_isError\" err?\n        (fun builder => do\n          let _ \u2190 LLVM.buildRet builder resv\n          pure ShouldForwardControlFlow.no)\n      if d.resultType.isScalar then\n        let dval \u2190 callLeanIOResultGetValue builder resv s!\"{d.name}_res\"\n        let dval \u2190 callUnboxForType builder d.resultType dval\n        LLVM.buildStore builder dval dslot\n      else\n         let dval \u2190 callLeanIOResultGetValue builder resv s!\"{d.name}_res\"\n         LLVM.buildStore builder dval dslot\n         callLeanMarkPersistentFn builder dval\n      let _ \u2190 LLVM.buildBr builder restBB\n      LLVM.positionBuilderAtEnd builder restBB\n    | none => do\n      let llvmty \u2190 toLLVMType d.resultType\n      let dslot \u2190  LLVM.getOrAddGlobal (\u2190 getLLVMModule) (\u2190 toCName d.name) llvmty\n      LLVM.setInitializer dslot (\u2190 LLVM.getUndef llvmty)\n      let dval \u2190 callPureDeclInitFn builder (\u2190 toCInitName d.name) (\u2190 toLLVMType d.resultType)\n      LLVM.buildStore builder dval dslot\n      if d.resultType.isObj then\n         callLeanMarkPersistentFn builder dval", "start": [1222, 1], "end": [1276, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callModInitFn", "code": "def callModInitFn (builder : LLVM.Builder llvmctx)\n    (modName : Name) (input world : LLVM.Value llvmctx) (retName : String): M llvmctx (LLVM.Value llvmctx) := do\n  let fnName := mkModuleInitializationFunctionName modName\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let argtys := #[ (\u2190 LLVM.i8Type llvmctx), (\u2190 LLVM.voidPtrType llvmctx)]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[input, world] retName", "start": [1278, 1], "end": [1285, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitInitFn", "code": "def emitInitFn (mod : LLVM.Module llvmctx) (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let env \u2190 getEnv\n  let modName \u2190 getModName\n\n  let initFnTy \u2190 LLVM.functionType (\u2190 LLVM.voidPtrType llvmctx) #[ (\u2190 LLVM.i8Type llvmctx), (\u2190 LLVM.voidPtrType llvmctx)] (isVarArg := false)\n  let initFn \u2190 LLVM.getOrAddFunction mod (mkModuleInitializationFunctionName modName) initFnTy\n  LLVM.setDLLStorageClass initFn LLVM.DLLStorageClass.export  let entryBB \u2190 LLVM.appendBasicBlockInContext llvmctx initFn \"entry\"\n  LLVM.positionBuilderAtEnd builder entryBB\n  let ginit?ty := \u2190 LLVM.i1Type llvmctx\n  let ginit?slot \u2190 LLVM.getOrAddGlobal mod (modName.mangle ++ \"_G_initialized\") ginit?ty\n  LLVM.setVisibility ginit?slot LLVM.Visibility.hidden LLVM.setInitializer ginit?slot (\u2190 LLVM.constFalse llvmctx)\n  let ginit?v \u2190 LLVM.buildLoad2 builder ginit?ty ginit?slot \"init_v\"\n  buildIfThen_ builder \"isGInitialized\" ginit?v\n    (fun builder => do\n      let box0 \u2190 callLeanBox builder (\u2190 LLVM.constIntUnsigned llvmctx 0) \"box0\"\n      let out \u2190 callLeanIOResultMKOk builder box0 \"retval\"\n      let _ \u2190 LLVM.buildRet builder out\n      pure ShouldForwardControlFlow.no)\n  LLVM.buildStore builder (\u2190 LLVM.constTrue llvmctx) ginit?slot\n\n  env.imports.forM fun import_ => do\n    let builtin \u2190 LLVM.getParam initFn 0\n    let world \u2190 callLeanIOMkWorld builder\n    let res \u2190 callModInitFn builder import_.module builtin world (\"res_\" ++ import_.module.mangle)\n    let err? \u2190 callLeanIOResultIsError builder res (\"res_is_error_\"  ++ import_.module.mangle)\n    buildIfThen_ builder (\"IsError\" ++ import_.module.mangle) err?\n      (fun builder => do\n        let _ \u2190 LLVM.buildRet builder res\n        pure ShouldForwardControlFlow.no)\n    callLeanDecRef builder res\n  let decls := getDecls env\n  decls.reverse.forM (emitDeclInit builder initFn)\n  let box0 \u2190 callLeanBox builder (\u2190 LLVM.constIntUnsigned llvmctx 0) \"box0\"\n  let out \u2190 callLeanIOResultMKOk builder box0 \"retval\"\n  let _ \u2190 LLVM.buildRet builder out", "start": [1287, 1], "end": [1323, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanInitialize", "code": "def callLeanInitialize (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let fnName :=  \"lean_initialize\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := #[]\n  let fnty \u2190 LLVM.functionType retty argtys\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn #[]", "start": [1325, 1], "end": [1331, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanInitializeRuntimeModule", "code": "def callLeanInitializeRuntimeModule (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let fnName :=  \"lean_initialize_runtime_module\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := #[]\n  let fnty \u2190 LLVM.functionType retty argtys\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn #[]", "start": [1333, 1], "end": [1339, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanSetPanicMessages", "code": "def callLeanSetPanicMessages (builder : LLVM.Builder llvmctx)\n    (enable? : LLVM.Value llvmctx) : M llvmctx Unit := do\n  let fnName :=  \"lean_set_panic_messages\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := #[ \u2190 LLVM.i1Type llvmctx ]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn #[enable?]", "start": [1341, 1], "end": [1348, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanIOMarkEndInitialization", "code": "def callLeanIOMarkEndInitialization (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let fnName :=  \"lean_io_mark_end_initialization\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := #[]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn #[]", "start": [1350, 1], "end": [1356, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanIOResultIsOk", "code": "def callLeanIOResultIsOk (builder : LLVM.Builder llvmctx)\n    (arg : LLVM.Value llvmctx) (name : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_io_result_is_ok\"\n  let retty \u2190 LLVM.i1Type llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx ]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn #[arg] name", "start": [1358, 1], "end": [1365, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanInitTaskManager", "code": "def callLeanInitTaskManager (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let fnName :=  \"lean_init_task_manager\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := #[]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n   let _ \u2190 LLVM.buildCall2 builder fnty fn #[]", "start": [1367, 1], "end": [1373, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanFinalizeTaskManager", "code": "def callLeanFinalizeTaskManager (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let fnName :=  \"lean_finalize_task_manager\"\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let argtys := #[]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n   let _ \u2190 LLVM.buildCall2 builder fnty fn #[]", "start": [1375, 1], "end": [1381, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanUnboxUint32", "code": "def callLeanUnboxUint32 (builder : LLVM.Builder llvmctx)\n    (v : LLVM.Value llvmctx) (name : String := \"\") : M llvmctx (LLVM.Value llvmctx) := do\n  let fnName :=  \"lean_unbox_uint32\"\n  let retty \u2190 LLVM.i32Type llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx ]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  LLVM.buildCall2 builder fnty fn  #[v] name", "start": [1383, 1], "end": [1390, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanIOResultShowError", "code": "def callLeanIOResultShowError (builder : LLVM.Builder llvmctx)\n    (v : LLVM.Value llvmctx) (name : String := \"\") : M llvmctx Unit := do\n  let fnName :=  \"lean_io_result_show_error\"\n  let retty \u2190 LLVM.voidType llvmctx\n  let argtys := #[ \u2190 LLVM.voidPtrType llvmctx ]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty fnName argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let _ \u2190 LLVM.buildCall2 builder fnty fn #[v] name", "start": [1392, 1], "end": [1399, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.callLeanMainFn", "code": "def callLeanMainFn (builder : LLVM.Builder llvmctx)\n    (argv? : Option (LLVM.Value llvmctx))\n    (world : LLVM.Value llvmctx)\n    (name : String) : M llvmctx (LLVM.Value llvmctx) := do\n  let retty \u2190 LLVM.voidPtrType llvmctx\n  let voidptr \u2190 LLVM.voidPtrType llvmctx\n  let argtys := if argv?.isSome then #[ voidptr, voidptr ] else #[ voidptr ]\n  let fn \u2190 getOrCreateFunctionPrototype (\u2190 getLLVMModule) retty leanMainFn argtys\n  let fnty \u2190 LLVM.functionType retty argtys\n  let args := match argv? with\n              | .some argv => #[argv, world]\n              | .none => #[world]\n  LLVM.buildCall2 builder fnty fn args name", "start": [1401, 1], "end": [1413, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitMainFn", "code": "def emitMainFn (mod : LLVM.Module llvmctx) (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  let d \u2190 getDecl `main\n  let xs \u2190 match d with\n   | .fdecl (xs := xs) .. => pure xs\n   | _ =>  throw \"Function declaration expected for 'main'\"\n\n  unless xs.size == 2 || xs.size == 1 do throw s!\"Invalid main function, main expected to have '2' or '1' arguments, found '{xs.size}' arguments\"\n  let env \u2190 getEnv\n  let usesLeanAPI := usesModuleFrom env `Lean\n  let mainTy \u2190 LLVM.functionType (\u2190 LLVM.i64Type llvmctx)\n      #[(\u2190 LLVM.i64Type llvmctx), (\u2190 LLVM.pointerType (\u2190 LLVM.voidPtrType llvmctx))]\n  let main \u2190 LLVM.getOrAddFunction mod \"main\" mainTy\n  let entry \u2190 LLVM.appendBasicBlockInContext llvmctx main \"entry\"\n  LLVM.positionBuilderAtEnd builder entry\n  \n  let inty \u2190 LLVM.voidPtrType llvmctx\n  let inslot \u2190 LLVM.buildAlloca builder (\u2190 LLVM.pointerType inty) \"in\"\n  let resty \u2190 LLVM.voidPtrType llvmctx\n  let res \u2190 LLVM.buildAlloca builder (\u2190 LLVM.pointerType resty) \"res\"\n  if usesLeanAPI then callLeanInitialize builder else callLeanInitializeRuntimeModule builder\n    \n  callLeanSetPanicMessages builder (\u2190 LLVM.constFalse llvmctx)\n  let world \u2190 callLeanIOMkWorld builder\n  let resv \u2190 callModInitFn builder (\u2190 getModName) (\u2190 LLVM.constInt8 llvmctx 1) world ((\u2190 getModName).toString ++ \"_init_out\")\n  let _ \u2190 LLVM.buildStore builder resv res\n\n  callLeanSetPanicMessages builder (\u2190 LLVM.constTrue llvmctx)\n  callLeanIOMarkEndInitialization builder\n\n  let resv \u2190 LLVM.buildLoad2 builder resty res \"resv\"\n  let res_is_ok \u2190 callLeanIOResultIsOk builder resv \"res_is_ok\"\n  buildIfThen_ builder \"resIsOkBranches\"  res_is_ok\n    (fun builder => do callLeanDecRef builder resv\n      callLeanInitTaskManager builder\n      if xs.size == 2 then\n        let inv \u2190 callLeanBox builder (\u2190 LLVM.constInt (\u2190 LLVM.size_tType llvmctx) 0) \"inv\"\n        let _ \u2190 LLVM.buildStore builder inv inslot\n        let ity \u2190 LLVM.size_tType llvmctx\n        let islot \u2190 LLVM.buildAlloca builder ity \"islot\"\n        let argcval \u2190 LLVM.getParam main 0\n        let argvval \u2190 LLVM.getParam main 1\n        LLVM.buildStore builder argcval islot\n        buildWhile_ builder \"argv\"\n          (condcodegen := fun builder => do\n            let iv \u2190 LLVM.buildLoad2 builder ity islot \"iv\"\n            let i_gt_1 \u2190 LLVM.buildICmp builder LLVM.IntPredicate.UGT iv (\u2190 constIntUnsigned 1) \"i_gt_1\"\n            return i_gt_1)\n          (bodycodegen := fun builder => do\n            let iv \u2190 LLVM.buildLoad2 builder ity islot \"iv\"\n            let iv_next \u2190 LLVM.buildSub builder iv (\u2190 constIntUnsigned 1) \"iv.next\"\n            LLVM.buildStore builder iv_next islot\n            let nv \u2190 callLeanAllocCtor builder 1 2 0 \"nv\"\n            let argv_i_next_slot \u2190 LLVM.buildGEP2 builder (\u2190 LLVM.voidPtrType llvmctx) argvval #[iv_next] \"argv.i.next.slot\"\n            let argv_i_next_val \u2190 LLVM.buildLoad2 builder (\u2190 LLVM.voidPtrType llvmctx) argv_i_next_slot \"argv.i.next.val\"\n            let argv_i_next_val_str \u2190 callLeanMkString builder argv_i_next_val \"arg.i.next.val.str\"\n            callLeanCtorSet builder nv (\u2190 constIntUnsigned 0) argv_i_next_val_str\n            let inv \u2190 LLVM.buildLoad2 builder inty inslot \"inv\"\n            callLeanCtorSet builder nv (\u2190 constIntUnsigned 1) inv\n            LLVM.buildStore builder nv inslot)\n        let world \u2190 callLeanIOMkWorld builder\n        let inv \u2190 LLVM.buildLoad2 builder inty inslot \"inv\"\n        let resv \u2190 callLeanMainFn builder (argv? := .some inv) (world := world) \"resv\"\n        let _ \u2190 LLVM.buildStore builder resv res\n        pure ShouldForwardControlFlow.yes\n      else\n          let world \u2190 callLeanIOMkWorld builder\n          let resv \u2190 callLeanMainFn builder (argv? := .none) (world := world) \"resv\"\n          let _ \u2190 LLVM.buildStore builder resv res\n          pure ShouldForwardControlFlow.yes\n  )\n\n  let retTy := env.find? `main |>.get! |>.type |>.getForallBody\n  let retTy := retTy.appArg!\n  callLeanFinalizeTaskManager builder\n  let resv \u2190 LLVM.buildLoad2 builder resty res \"resv\"\n  let res_is_ok \u2190 callLeanIOResultIsOk builder resv \"res_is_ok\"\n  buildIfThenElse_ builder \"res.is.ok\" res_is_ok\n    (fun builder => if retTy.constName? == some ``UInt32 then do\n        let resv \u2190 LLVM.buildLoad2 builder resty res \"resv\"\n        let retv \u2190 callLeanUnboxUint32 builder (\u2190 callLeanIOResultGetValue builder resv \"io_val\") \"retv\"\n        let retv \u2190 LLVM.buildSext builder retv (\u2190 LLVM.i64Type llvmctx) \"retv_sext\"\n        callLeanDecRef builder resv\n        let _ \u2190 LLVM.buildRet builder retv\n        pure ShouldForwardControlFlow.no\n      else do\n        callLeanDecRef builder resv\n        let _ \u2190 LLVM.buildRet builder (\u2190 LLVM.constInt64 llvmctx 0)\n        pure ShouldForwardControlFlow.no\n\n    )\n    (fun builder => do let resv \u2190 LLVM.buildLoad2 builder resty res \"resv\"\n        callLeanIOResultShowError builder resv\n        callLeanDecRef builder resv\n        let _ \u2190 LLVM.buildRet builder (\u2190 LLVM.constInt64 llvmctx 1)\n        pure ShouldForwardControlFlow.no)\n  let _ \u2190 LLVM.buildUnreachable builder", "start": [1415, 1], "end": [1523, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.hasMainFn", "code": "def hasMainFn : M llvmctx Bool := do\n  let env \u2190 getEnv\n  let decls := getDecls env\n  return decls.any (fun d => d.name == `main)", "start": [1525, 1], "end": [1528, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.emitMainFnIfNeeded", "code": "def emitMainFnIfNeeded (mod : LLVM.Module llvmctx) (builder : LLVM.Builder llvmctx) : M llvmctx Unit := do\n  if (\u2190 hasMainFn) then emitMainFn mod builder", "start": [1530, 1], "end": [1531, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitLLVM.main", "code": "def main : M llvmctx Unit := do\n  emitFnDecls\n  let builder \u2190 LLVM.createBuilderInContext llvmctx\n  emitFns (\u2190 getLLVMModule) builder\n  emitInitFn (\u2190 getLLVMModule) builder\n  emitMainFnIfNeeded (\u2190 getLLVMModule) builder", "start": [1533, 1], "end": [1538, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.getLeanHBcPath", "code": "def getLeanHBcPath : IO System.FilePath := do\n  return (\u2190 getLibDir (\u2190 getBuildDir)) / \"lean.h.bc\"", "start": [1541, 1], "end": [1542, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.optimizeLLVMModule", "code": "def optimizeLLVMModule (mod : LLVM.Module ctx) : IO Unit := do\n  let pm  \u2190 LLVM.createPassManager\n  let pmb \u2190 LLVM.createPassManagerBuilder\n  pmb.setOptLevel 3\n  pmb.populateModulePassManager pm\n  LLVM.runPassManager pm mod\n  LLVM.disposePassManager pm\n  LLVM.disposePassManagerBuilder pmb", "start": [1544, 1], "end": [1551, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.getModuleGlobals", "code": "partial def getModuleGlobals (mod : LLVM.Module llvmctx) : IO (Array (LLVM.Value llvmctx)) := do\n  let rec go (v : LLVM.Value llvmctx) (acc : Array (LLVM.Value llvmctx)) : IO (Array (LLVM.Value llvmctx)) := do\n    if v.isNull then return acc\n    else go (\u2190 LLVM.getNextGlobal v) (acc.push v)\n  go (\u2190 LLVM.getFirstGlobal mod) #[]", "start": [1553, 1], "end": [1558, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.getModuleFunctions", "code": "partial def getModuleFunctions (mod : LLVM.Module llvmctx) : IO (Array (LLVM.Value llvmctx)) := do\n  let rec go (v : LLVM.Value llvmctx) (acc : Array (LLVM.Value llvmctx)) : IO (Array (LLVM.Value llvmctx)) := do\n    if v.isNull then return acc\n    else go (\u2190 LLVM.getNextFunction v) (acc.push v)\n  go (\u2190 LLVM.getFirstFunction mod) #[]", "start": [1560, 1], "end": [1565, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.emitLLVM", "code": "@[export lean_ir_emit_llvm]\ndef emitLLVM (env : Environment) (modName : Name) (filepath : String) (tripleStr? : Option String) : IO Unit := do\n  LLVM.llvmInitializeTargetInfo\n  let llvmctx \u2190 LLVM.createContext\n  let module \u2190 LLVM.createModule llvmctx modName.toString\n  let emitLLVMCtx : EmitLLVM.Context llvmctx := {env := env, modName := modName, llvmmodule := module}\n  let initState := { var2val := default, jp2bb := default : EmitLLVM.State llvmctx}\n  let out? \u2190 ((EmitLLVM.main (llvmctx := llvmctx)).run initState).run emitLLVMCtx\n  match out? with\n  | .ok _ => do\n         let membuf \u2190 LLVM.createMemoryBufferWithContentsOfFile (\u2190 getLeanHBcPath).toString\n         let modruntime \u2190 LLVM.parseBitcode llvmctx membuf\n         \n         let runtimeGlobals \u2190 (\u2190 getModuleGlobals modruntime).mapM (\u00b7.getName)\n         let filter func := do\n           if (\u2190 LLVM.isDeclaration func) then\n             return none\n           else\n             return some (\u2190 func.getName)\n         let runtimeFunctions \u2190 (\u2190 getModuleFunctions modruntime).filterMapM filter\n         LLVM.linkModules (dest := emitLLVMCtx.llvmmodule) (src := modruntime)\n         for name in runtimeGlobals do\n           let some global \u2190 LLVM.getNamedGlobal emitLLVMCtx.llvmmodule name\n              | throw <| IO.Error.userError s!\"ERROR: linked module must have global from runtime module: '{name}'\"\n           LLVM.setLinkage global LLVM.Linkage.internal\n         for name in runtimeFunctions do\n           let some fn \u2190 LLVM.getNamedFunction emitLLVMCtx.llvmmodule name\n              | throw <| IO.Error.userError s!\"ERROR: linked module must have function from runtime module: '{name}'\"\n           LLVM.setLinkage fn LLVM.Linkage.internal\n\n         optimizeLLVMModule emitLLVMCtx.llvmmodule\n         LLVM.writeBitcodeToFile emitLLVMCtx.llvmmodule filepath\n         let tripleStr := tripleStr?.getD (\u2190 LLVM.getDefaultTargetTriple)\n         let target \u2190 LLVM.getTargetFromTriple tripleStr\n         let cpu := \"generic\"\n         let features := \"\"\n         let targetMachine \u2190 LLVM.createTargetMachine target tripleStr cpu features\n         let codegenType := LLVM.CodegenFileType.ObjectFile\n         LLVM.targetMachineEmitToFile targetMachine emitLLVMCtx.llvmmodule (filepath ++ \".o\") codegenType\n         LLVM.disposeModule emitLLVMCtx.llvmmodule\n         LLVM.disposeTargetMachine targetMachine\n  | .error err => throw (IO.Error.userError err)", "start": [1567, 1], "end": [1616, 49], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Probing.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ForEachExpr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PhaseExt.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Probe", "code": "abbrev Probe \u03b1 \u03b2 := Array \u03b1 \u2192 CompilerM (Array \u03b2)", "start": [13, 1], "end": [13, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.map", "code": "@[inline]\ndef map (f : \u03b1 \u2192 CompilerM \u03b2) : Probe \u03b1 \u03b2 := fun data => data.mapM f", "start": [17, 1], "end": [18, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.filter", "code": "@[inline]\ndef filter (f : \u03b1 \u2192 CompilerM Bool) : Probe \u03b1 \u03b1 := fun data => data.filterM f", "start": [20, 1], "end": [21, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.sorted", "code": "@[inline]\ndef sorted [Inhabited \u03b1] [inst : LT \u03b1] [DecidableRel inst.lt] : Probe \u03b1 \u03b1 := fun data => return data.qsort (\u00b7 < \u00b7)", "start": [23, 1], "end": [24, 115], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.sortedBySize", "code": "@[inline]\ndef sortedBySize : Probe Decl (Nat \u00d7 Decl) := fun decls =>\n  let decls := decls.map fun decl => (decl.size, decl)\n  return decls.qsort fun (sz\u2081, decl\u2081) (sz\u2082, decl\u2082) =>\n    if sz\u2081 == sz\u2082 then Name.lt decl\u2081.name decl\u2082.name else sz\u2081 < sz\u2082", "start": [26, 1], "end": [30, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.countUnique", "code": "def countUnique [ToString \u03b1] [BEq \u03b1] [Hashable \u03b1] : Probe \u03b1 (\u03b1 \u00d7 Nat) := fun data => do\n  let mut map := HashMap.empty\n  for d in data do\n    if let some count := map.find? d then\n      map := map.insert d (count + 1)\n    else\n      map := map.insert d 1\n  return map.toArray", "start": [32, 1], "end": [39, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.countUniqueSorted", "code": "@[inline]\ndef countUniqueSorted [ToString \u03b1] [BEq \u03b1] [Hashable \u03b1] [Inhabited \u03b1] : Probe \u03b1 (\u03b1 \u00d7 Nat) :=\n  countUnique >=> fun data => return data.qsort (fun l r => l.snd < r.snd)", "start": [41, 1], "end": [43, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.getLetValues", "code": "partial def getLetValues : Probe Decl LetValue := fun decls => do\n  let (_, res) \u2190 start decls |>.run #[]\n  return res\nwhere\n  go (c : Code) : StateRefT (Array LetValue) CompilerM Unit := do\n    match c with\n    | .let (decl : LetDecl) (k : Code) =>\n      modify fun s => s.push decl.value\n      go k\n    | .fun decl k | .jp decl k =>\n      go decl.value\n      go k\n    | .cases (cases : CasesCore Code) => cases.alts.forM (go \u00b7.getCode)\n    | .jmp .. | .return .. | .unreach .. => return ()\n  start (decls : Array Decl) : StateRefT (Array LetValue) CompilerM Unit :=\n    decls.forM (go \u00b7.value)", "start": [45, 1], "end": [60, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.getJps", "code": "partial def getJps : Probe Decl FunDecl := fun decls => do\n  let (_, res) \u2190 start decls |>.run #[]\n  return res\nwhere\n  go (code : Code) : StateRefT (Array FunDecl) CompilerM Unit := do\n    match code with\n    | .let _ k => go k\n    | .fun decl k => go decl.value; go k\n    | .jp decl k => modify (\u00b7.push decl); go decl.value; go k\n    | .cases cs => cs.alts.forM (go \u00b7.getCode)\n    | .jmp .. | .return .. | .unreach .. => return ()\n\n  start (decls : Array Decl) : StateRefT (Array FunDecl) CompilerM Unit :=\n    decls.forM fun decl => go decl.value", "start": [62, 1], "end": [75, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.filterByLet", "code": "partial def filterByLet (f : LetDecl \u2192 CompilerM Bool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Code \u2192 CompilerM Bool\n  | .let decl k => do if (\u2190 f decl) then return true else go k\n  | .fun decl k | .jp decl k => go decl.value <||> go k\n  | .cases cs => cs.alts.anyM (go \u00b7.getCode)\n  | .jmp .. | .return .. | .unreach .. => return false", "start": [77, 1], "end": [84, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.filterByFun", "code": "partial def filterByFun (f : FunDecl \u2192 CompilerM Bool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Code \u2192 CompilerM Bool\n  | .let _ k | .jp _ k  => go k\n  | .fun decl k => do if (\u2190 f decl) then return true else go decl.value <||> go k\n  | .cases cs => cs.alts.anyM (go \u00b7.getCode)\n  | .jmp .. | .return .. | .unreach .. => return false", "start": [86, 1], "end": [93, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.filterByJp", "code": "partial def filterByJp (f : FunDecl \u2192 CompilerM Bool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Code \u2192 CompilerM Bool\n  | .let _ k => go k\n  | .fun decl k => go decl.value <||> go k\n  | .jp decl k => do if (\u2190 f decl) then return true else go decl.value <||> go k\n  | .cases cs => cs.alts.anyM (go \u00b7.getCode)\n  | .jmp .. | .return .. | .unreach .. => return false", "start": [95, 1], "end": [103, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.filterByFunDecl", "code": "partial def filterByFunDecl (f : FunDecl \u2192 CompilerM Bool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Code \u2192 CompilerM Bool\n  | .let _ k => go k\n  | .fun decl k | .jp decl k => do if (\u2190 f decl) then return true else go decl.value <||> go k\n  | .cases cs => cs.alts.anyM (go \u00b7.getCode)\n  | .jmp .. | .return .. | .unreach .. => return false", "start": [105, 1], "end": [112, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.filterByCases", "code": "partial def filterByCases (f : Cases \u2192 CompilerM Bool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Code \u2192 CompilerM Bool\n  | .let _ k => go k\n  | .fun decl k | .jp decl k => go decl.value <||> go k\n  | .cases cs => do if (\u2190 f cs) then return true else cs.alts.anyM (go \u00b7.getCode)\n  | .jmp .. | .return .. | .unreach .. => return false", "start": [114, 1], "end": [121, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.filterByJmp", "code": "partial def filterByJmp (f : FVarId \u2192 Array Arg \u2192 CompilerM Bool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Code \u2192 CompilerM Bool\n  | .let _ k => go k\n  | .fun decl k | .jp decl k => go decl.value <||> go k\n  | .cases cs => cs.alts.anyM (go \u00b7.getCode)\n  | .jmp fn var => f fn var\n  | .return .. | .unreach .. => return false", "start": [123, 1], "end": [131, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.filterByReturn", "code": "partial def filterByReturn (f : FVarId \u2192 CompilerM Bool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Code \u2192 CompilerM Bool\n  | .let _ k => go k\n  | .fun decl k | .jp decl k => go decl.value <||> go k\n  | .cases cs => cs.alts.anyM (go \u00b7.getCode)\n  | .jmp .. | .unreach .. => return false\n  | .return var  => f var", "start": [133, 1], "end": [141, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.filterByUnreach", "code": "partial def filterByUnreach (f : Expr \u2192 CompilerM Bool) : Probe Decl Decl :=\n  filter (fun decl => go decl.value)\nwhere\n  go : Code \u2192 CompilerM Bool\n  | .let _ k => go k\n  | .fun decl k | .jp decl k => go decl.value <||> go k\n  | .cases cs => cs.alts.anyM (go \u00b7.getCode)\n  | .jmp .. | .return .. => return false\n  | .unreach typ  => f typ", "start": [143, 1], "end": [151, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.declNames", "code": "@[inline]\ndef declNames : Probe Decl Name :=\n  Probe.map (fun decl => return decl.name)", "start": [153, 1], "end": [155, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.toString", "code": "@[inline]\ndef toString [ToString \u03b1] : Probe \u03b1 String :=\n  Probe.map (return ToString.toString \u00b7)", "start": [157, 1], "end": [159, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.count", "code": "@[inline]\ndef count : Probe \u03b1 Nat := fun data => return #[data.size]", "start": [161, 1], "end": [162, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.sum", "code": "@[inline]\ndef sum : Probe Nat Nat := fun data => return #[data.foldl (init := 0) (\u00b7+\u00b7)]", "start": [164, 1], "end": [165, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.tail", "code": "@[inline]\ndef tail (n : Nat) : Probe \u03b1 \u03b1 := fun data => return data[data.size - n:]", "start": [167, 1], "end": [168, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.head", "code": "@[inline]\ndef head (n : Nat) : Probe \u03b1 \u03b1 := fun data => return data[:n]", "start": [170, 1], "end": [171, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.runOnModule", "code": "def runOnModule (moduleName : Name) (probe : Probe Decl \u03b2) (phase : Phase := Phase.base): CoreM (Array \u03b2) := do\n  let ext := getExt phase\n  let env \u2190 getEnv\n  let some modIdx := env.getModuleIdx? moduleName | throwError \"module `{moduleName}` not found\"\n  let decls := ext.getModuleEntries env modIdx\n  probe decls |>.run (phase := phase)", "start": [173, 1], "end": [178, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.runGlobally", "code": "def runGlobally (probe : Probe Decl \u03b2) (phase : Phase := Phase.base) : CoreM (Array \u03b2) := do\n  let ext := getExt phase\n  let env \u2190 getEnv\n  let mut decls := #[]\n  for modIdx in [:env.allImportedModuleNames.size] do\n    decls := decls.append <| ext.getModuleEntries env modIdx\n  probe decls |>.run (phase := phase)", "start": [180, 1], "end": [186, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Probe.toPass", "code": "def toPass [ToString \u03b2] (probe : Probe Decl \u03b2) (phase : Phase) : Pass where\n  phase := phase\n  name := `probe\n  run := fun decls => do\n    let res \u2190 probe decls\n    trace[Compiler.probe] s!\"{res}\"\n    return decls", "start": [188, 1], "end": [194, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Match/MVarRenaming.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/ReplaceExpr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.MVarRenaming", "code": "structure MVarRenaming where\n  map : MVarIdMap MVarId := {}", "start": [10, 1], "end": [12, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.MVarRenaming.isEmpty", "code": "def MVarRenaming.isEmpty (s : MVarRenaming) : Bool :=\n  s.map.isEmpty", "start": [14, 1], "end": [15, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.MVarRenaming.find?", "code": "def MVarRenaming.find? (s : MVarRenaming) (mvarId : MVarId) : Option MVarId :=\n  s.map.find? mvarId", "start": [17, 1], "end": [18, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.MVarRenaming.find!", "code": "def MVarRenaming.find! (s : MVarRenaming) (mvarId : MVarId) : MVarId :=\n  (s.find? mvarId).get!", "start": [20, 1], "end": [21, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.MVarRenaming.insert", "code": "def MVarRenaming.insert (s : MVarRenaming) (mvarId mvarId' : MVarId) : MVarRenaming :=\n  { s with map := s.map.insert mvarId mvarId' }", "start": [23, 1], "end": [24, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.MVarRenaming.apply", "code": "def MVarRenaming.apply (s : MVarRenaming) (e : Expr) : Expr :=\n  if !e.hasMVar then e\n  else if s.map.isEmpty then e\n  else e.replace fun e => match e with\n    | Expr.mvar mvarId => match s.map.find? mvarId with\n      | none           => e\n      | some newMVarId => mkMVar newMVarId\n    | _ => none", "start": [26, 1], "end": [33, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/proofwidgets/ProofWidgets.lean", "imports": ["lake-packages/proofwidgets/ProofWidgets/Presentation/Expr.lean", "lake-packages/proofwidgets/ProofWidgets/Compat.lean", "lake-packages/proofwidgets/ProofWidgets/Component/Panel/GoalTypePanel.lean", "lake-packages/proofwidgets/ProofWidgets/Component/MakeEditLink.lean", "lake-packages/proofwidgets/ProofWidgets/Component/Recharts.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/proofwidgets/ProofWidgets/Component/PenroseDiagram.lean", "lake-packages/proofwidgets/ProofWidgets/Data/Html.lean", "lake-packages/proofwidgets/ProofWidgets/Component/OfRpcMethod.lean", "lake-packages/proofwidgets/ProofWidgets/Component/InteractiveSvg.lean", "lake-packages/proofwidgets/ProofWidgets/Component/HtmlDisplay.lean", "lake-packages/proofwidgets/ProofWidgets/Data/Json.lean", "lake-packages/proofwidgets/ProofWidgets/Component/Panel/SelectionPanel.lean", "lake-packages/proofwidgets/ProofWidgets/Component/Basic.lean", "lake-packages/proofwidgets/ProofWidgets/Component/Panel/Basic.lean", "lake-packages/proofwidgets/ProofWidgets/Data/Svg.lean"], "premises": []}
{"path": "Mathlib/FieldTheory/Finite/Polynomial.lean", "imports": ["Mathlib/Data/MvPolynomial/Expand.lean", "Mathlib/LinearAlgebra/Basic.lean", "Mathlib/LinearAlgebra/FiniteDimensional.lean", "Mathlib/RingTheory/MvPolynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/FieldTheory/Finite/Basic.lean"], "premises": [{"full_name": "MvPolynomial.C_dvd_iff_zmod", "code": "theorem C_dvd_iff_zmod (n : \u2115) (\u03c6 : MvPolynomial \u03c3 \u2124) :\n    C (n : \u2124) \u2223 \u03c6 \u2194 map (Int.castRingHom (ZMod n)) \u03c6 = 0", "start": [23, 1], "end": [27, 74], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.frobenius_zmod", "code": "theorem frobenius_zmod (f : MvPolynomial \u03c3 (ZMod p)) : frobenius _ p f = expand p f", "start": [35, 1], "end": [40, 41], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.expand_zmod", "code": "theorem expand_zmod (f : MvPolynomial \u03c3 (ZMod p)) : expand p f = f ^ p", "start": [43, 1], "end": [44, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.indicator", "code": "def indicator [CommRing K] (a : \u03c3 \u2192 K) : MvPolynomial \u03c3 K :=\n  \u220f n, (1 - (X n - C (a n)) ^ (Fintype.card K - 1))", "start": [65, 1], "end": [67, 52], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_indicator_apply_eq_one", "code": "theorem eval_indicator_apply_eq_one (a : \u03c3 \u2192 K) : eval a (indicator a) = 1", "start": [74, 1], "end": [78, 52], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_indicator", "code": "theorem degrees_indicator (c : \u03c3 \u2192 K) :\n    degrees (indicator c) \u2264 \u2211 s : \u03c3, (Fintype.card K - 1) \u2022 {s}", "start": [81, 1], "end": [90, 21], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.indicator_mem_restrictDegree", "code": "theorem indicator_mem_restrictDegree (c : \u03c3 \u2192 K) :\n    indicator c \u2208 restrictDegree \u03c3 K (Fintype.card K - 1)", "start": [93, 1], "end": [105, 48], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_indicator_apply_eq_zero", "code": "theorem eval_indicator_apply_eq_zero (a b : \u03c3 \u2192 K) (h : a \u2260 b) : eval a (indicator b) = 0", "start": [112, 1], "end": [118, 24], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2097", "code": "@[simps]\ndef eval\u2097 [CommSemiring K] : MvPolynomial \u03c3 K \u2192\u2097[K] (\u03c3 \u2192 K) \u2192 K where\n  toFun p e := eval e p\n  map_add' p q := by ext x; simp\n  map_smul' a p := by ext e; simp", "start": [127, 1], "end": [132, 34], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_restrict_dom_eval\u2097", "code": "theorem map_restrict_dom_eval\u2097 : (restrictDegree \u03c3 K (Fintype.card K - 1)).map (eval\u2097 K \u03c3) = \u22a4", "start": [139, 1], "end": [152, 61], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.R", "code": "def R [CommRing K] : Type u :=\n  restrictDegree \u03c3 K (Fintype.card K - 1)", "start": [172, 1], "end": [175, 42], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u1d62", "code": "def eval\u1d62 [CommRing K] : R \u03c3 K \u2192\u2097[K] (\u03c3 \u2192 K) \u2192 K :=\n  (eval\u2097 K \u03c3).comp (restrictDegree \u03c3 K (Fintype.card K - 1)).subtype", "start": [188, 1], "end": [190, 69], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.decidableRestrictDegree", "code": "noncomputable instance decidableRestrictDegree (m : \u2115) :\n    DecidablePred (\u00b7 \u2208 { n : \u03c3 \u2192\u2080 \u2115 | \u2200 i, n i \u2264 m }) := by\n  simp only [Set.mem_setOf_eq]; infer_instance", "start": [197, 1], "end": [199, 47], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.rank_R", "code": "theorem rank_R [Fintype \u03c3] : Module.rank K (R \u03c3 K) = Fintype.card (\u03c3 \u2192 K)", "start": [206, 1], "end": [222, 54], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.finrank_R", "code": "theorem finrank_R [Fintype \u03c3] : FiniteDimensional.finrank K (R \u03c3 K) = Fintype.card (\u03c3 \u2192 K)", "start": [233, 1], "end": [234, 55], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.range_eval\u1d62", "code": "theorem range_eval\u1d62 [Finite \u03c3] : range (eval\u1d62 \u03c3 K) = \u22a4", "start": [239, 1], "end": [241, 35], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.ker_eval\u2097", "code": "theorem ker_eval\u2097 [Finite \u03c3] : ker (eval\u1d62 \u03c3 K) = \u22a5", "start": [245, 1], "end": [248, 64], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eq_zero_of_eval_eq_zero", "code": "theorem eq_zero_of_eval_eq_zero [Finite \u03c3] (p : MvPolynomial \u03c3 K) (h : \u2200 v : \u03c3 \u2192 K, eval v p = 0)\n    (hp : p \u2208 restrictDegree \u03c3 K (Fintype.card K - 1)) : p = 0", "start": [251, 1], "end": [255, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/ConditionalExpectation/Basic.lean", "imports": ["Mathlib/MeasureTheory/Function/ConditionalExpectation/CondexpL1.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.condexp", "code": "noncomputable irreducible_def condexp (m : MeasurableSpace \u03b1) {m0 : MeasurableSpace \u03b1}\n    (\u03bc : Measure \u03b1) (f : \u03b1 \u2192 F') : \u03b1 \u2192 F' :=\n  if hm : m \u2264 m0 then\n    if h : SigmaFinite (\u03bc.trim hm) \u2227 Integrable f \u03bc then\n      if StronglyMeasurable[m] f then f\n      else (@aestronglyMeasurable'_condexpL1 _ _ _ _ _ m m0 \u03bc hm h.1 _).mk\n        (@condexpL1 _ _ _ _ _ _ _ hm \u03bc h.1 f)\n    else 0\n  else 0", "start": [87, 1], "end": [100, 9], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "MeasureTheory.condexp_of_not_le", "code": "theorem condexp_of_not_le (hm_not : \u00acm \u2264 m0) : \u03bc[f|m] = 0", "start": [106, 1], "end": [106, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_of_not_sigmaFinite", "code": "theorem condexp_of_not_sigmaFinite (hm : m \u2264 m0) (h\u03bcm_not : \u00acSigmaFinite (\u03bc.trim hm)) :\n    \u03bc[f|m] = 0", "start": [109, 1], "end": [110, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_of_sigmaFinite", "code": "theorem condexp_of_sigmaFinite (hm : m \u2264 m0) [h\u03bcm : SigmaFinite (\u03bc.trim hm)] :\n    \u03bc[f|m] =\n      if Integrable f \u03bc then\n        if StronglyMeasurable[m] f then f\n        else aestronglyMeasurable'_condexpL1.mk (condexpL1 hm \u03bc f)\n      else 0", "start": [113, 1], "end": [123, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_of_stronglyMeasurable", "code": "theorem condexp_of_stronglyMeasurable (hm : m \u2264 m0) [h\u03bcm : SigmaFinite (\u03bc.trim hm)] {f : \u03b1 \u2192 F'}\n    (hf : StronglyMeasurable[m] f) (hfi : Integrable f \u03bc) : \u03bc[f|m] = f", "start": [126, 1], "end": [128, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_const", "code": "theorem condexp_const (hm : m \u2264 m0) (c : F') [IsFiniteMeasure \u03bc] :\n    \u03bc[fun _ : \u03b1 => c|m] = fun _ => c", "start": [131, 1], "end": [133, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_ae_eq_condexpL1", "code": "theorem condexp_ae_eq_condexpL1 (hm : m \u2264 m0) [h\u03bcm : SigmaFinite (\u03bc.trim hm)] (f : \u03b1 \u2192 F') :\n    \u03bc[f|m] =\u1d50[\u03bc] condexpL1 hm \u03bc f", "start": [136, 1], "end": [148, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_ae_eq_condexpL1Clm", "code": "theorem condexp_ae_eq_condexpL1Clm (hm : m \u2264 m0) [SigmaFinite (\u03bc.trim hm)] (hf : Integrable f \u03bc) :\n    \u03bc[f|m] =\u1d50[\u03bc] condexpL1Clm F' hm \u03bc (hf.toL1 f)", "start": [152, 1], "end": [155, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_undef", "code": "theorem condexp_undef (hf : \u00acIntegrable f \u03bc) : \u03bc[f|m] = 0", "start": [159, 1], "end": [165, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_zero", "code": "@[simp]\ntheorem condexp_zero : \u03bc[(0 : \u03b1 \u2192 F')|m] = 0", "start": [168, 1], "end": [176, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.stronglyMeasurable_condexp", "code": "theorem stronglyMeasurable_condexp : StronglyMeasurable[m] (\u03bc[f|m])", "start": [179, 1], "end": [189, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_congr_ae", "code": "theorem condexp_congr_ae (h : f =\u1d50[\u03bc] g) : \u03bc[f|m] =\u1d50[\u03bc] \u03bc[g|m]", "start": [192, 1], "end": [200, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_of_aestronglyMeasurable'", "code": "theorem condexp_of_aestronglyMeasurable' (hm : m \u2264 m0) [h\u03bcm : SigmaFinite (\u03bc.trim hm)] {f : \u03b1 \u2192 F'}\n    (hf : AEStronglyMeasurable' m f \u03bc) (hfi : Integrable f \u03bc) : \u03bc[f|m] =\u1d50[\u03bc] f", "start": [203, 1], "end": [207, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.integrable_condexp", "code": "theorem integrable_condexp : Integrable (\u03bc[f|m]) \u03bc", "start": [210, 1], "end": [216, 75], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.set_integral_condexp", "code": "theorem set_integral_condexp (hm : m \u2264 m0) [SigmaFinite (\u03bc.trim hm)] (hf : Integrable f \u03bc)\n    (hs : MeasurableSet[m] s) : \u222b x in s, (\u03bc[f|m]) x \u2202\u03bc = \u222b x in s, f x \u2202\u03bc", "start": [219, 1], "end": [224, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.integral_condexp", "code": "theorem integral_condexp (hm : m \u2264 m0) [h\u03bcm : SigmaFinite (\u03bc.trim hm)] (hf : Integrable f \u03bc) :\n    \u222b x, (\u03bc[f|m]) x \u2202\u03bc = \u222b x, f x \u2202\u03bc", "start": [227, 1], "end": [231, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_condexp_of_forall_set_integral_eq", "code": "theorem ae_eq_condexp_of_forall_set_integral_eq (hm : m \u2264 m0) [SigmaFinite (\u03bc.trim hm)]\n    {f g : \u03b1 \u2192 F'} (hf : Integrable f \u03bc)\n    (hg_int_finite : \u2200 s, MeasurableSet[m] s \u2192 \u03bc s < \u221e \u2192 IntegrableOn g s \u03bc)\n    (hg_eq : \u2200 s : Set \u03b1, MeasurableSet[m] s \u2192 \u03bc s < \u221e \u2192 \u222b x in s, g x \u2202\u03bc = \u222b x in s, f x \u2202\u03bc)\n    (hgm : AEStronglyMeasurable' m g \u03bc) : g =\u1d50[\u03bc] \u03bc[f|m]", "start": [234, 1], "end": [245, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_bot'", "code": "theorem condexp_bot' [h\u03bc : NeZero \u03bc] (f : \u03b1 \u2192 F') :\n    \u03bc[f|\u22a5] = fun _ => (\u03bc Set.univ).toReal\u207b\u00b9 \u2022 \u222b x, f x \u2202\u03bc", "start": [248, 1], "end": [266, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_bot_ae_eq", "code": "theorem condexp_bot_ae_eq (f : \u03b1 \u2192 F') :\n    \u03bc[f|\u22a5] =\u1d50[\u03bc] fun _ => (\u03bc Set.univ).toReal\u207b\u00b9 \u2022 \u222b x, f x \u2202\u03bc", "start": [269, 1], "end": [273, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_bot", "code": "theorem condexp_bot [IsProbabilityMeasure \u03bc] (f : \u03b1 \u2192 F') : \u03bc[f|\u22a5] = fun _ => \u222b x, f x \u2202\u03bc", "start": [276, 1], "end": [277, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_add", "code": "theorem condexp_add (hf : Integrable f \u03bc) (hg : Integrable g \u03bc) :\n    \u03bc[f + g|m] =\u1d50[\u03bc] \u03bc[f|m] + \u03bc[g|m]", "start": [280, 1], "end": [290, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_finset_sum", "code": "theorem condexp_finset_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1 \u2192 F'}\n    (hf : \u2200 i \u2208 s, Integrable (f i) \u03bc) : \u03bc[\u2211 i in s, f i|m] =\u1d50[\u03bc] \u2211 i in s, \u03bc[f i|m]", "start": [293, 1], "end": [300, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_smul", "code": "theorem condexp_smul (c : \ud835\udd5c) (f : \u03b1 \u2192 F') : \u03bc[c \u2022 f|m] =\u1d50[\u03bc] c \u2022 \u03bc[f|m]", "start": [303, 1], "end": [313, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_neg", "code": "theorem condexp_neg (f : \u03b1 \u2192 F') : \u03bc[-f|m] =\u1d50[\u03bc] -\u03bc[f|m]", "start": [316, 1], "end": [321, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_sub", "code": "theorem condexp_sub (hf : Integrable f \u03bc) (hg : Integrable g \u03bc) :\n    \u03bc[f - g|m] =\u1d50[\u03bc] \u03bc[f|m] - \u03bc[g|m]", "start": [324, 1], "end": [327, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_condexp_of_le", "code": "theorem condexp_condexp_of_le {m\u2081 m\u2082 m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} (hm\u2081\u2082 : m\u2081 \u2264 m\u2082)\n    (hm\u2082 : m\u2082 \u2264 m0) [SigmaFinite (\u03bc.trim hm\u2082)] : \u03bc[\u03bc[f|m\u2082]|m\u2081] =\u1d50[\u03bc] \u03bc[f|m\u2081]", "start": [330, 1], "end": [344, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_mono", "code": "theorem condexp_mono {E} [NormedLatticeAddCommGroup E] [CompleteSpace E] [NormedSpace \u211d E]\n    [OrderedSMul \u211d E] {f g : \u03b1 \u2192 E} (hf : Integrable f \u03bc) (hg : Integrable g \u03bc) (hfg : f \u2264\u1d50[\u03bc] g) :\n    \u03bc[f|m] \u2264\u1d50[\u03bc] \u03bc[g|m]", "start": [347, 1], "end": [356, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_nonneg", "code": "theorem condexp_nonneg {E} [NormedLatticeAddCommGroup E] [CompleteSpace E] [NormedSpace \u211d E]\n    [OrderedSMul \u211d E] {f : \u03b1 \u2192 E} (hf : 0 \u2264\u1d50[\u03bc] f) : 0 \u2264\u1d50[\u03bc] \u03bc[f|m]", "start": [359, 1], "end": [364, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_nonpos", "code": "theorem condexp_nonpos {E} [NormedLatticeAddCommGroup E] [CompleteSpace E] [NormedSpace \u211d E]\n    [OrderedSMul \u211d E] {f : \u03b1 \u2192 E} (hf : f \u2264\u1d50[\u03bc] 0) : \u03bc[f|m] \u2264\u1d50[\u03bc] 0", "start": [367, 1], "end": [372, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_condexpL1_of_dominated_convergence", "code": "theorem tendsto_condexpL1_of_dominated_convergence (hm : m \u2264 m0) [SigmaFinite (\u03bc.trim hm)]\n    {fs : \u2115 \u2192 \u03b1 \u2192 F'} {f : \u03b1 \u2192 F'} (bound_fs : \u03b1 \u2192 \u211d)\n    (hfs_meas : \u2200 n, AEStronglyMeasurable (fs n) \u03bc) (h_int_bound_fs : Integrable bound_fs \u03bc)\n    (hfs_bound : \u2200 n, \u2200\u1d50 x \u2202\u03bc, \u2016fs n x\u2016 \u2264 bound_fs x)\n    (hfs : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => fs n x) atTop (\ud835\udcdd (f x))) :\n    Tendsto (fun n => condexpL1 hm \u03bc (fs n)) atTop (\ud835\udcdd (condexpL1 hm \u03bc f))", "start": [375, 1], "end": [384, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_condexp_unique", "code": "theorem tendsto_condexp_unique (fs gs : \u2115 \u2192 \u03b1 \u2192 F') (f g : \u03b1 \u2192 F')\n    (hfs_int : \u2200 n, Integrable (fs n) \u03bc) (hgs_int : \u2200 n, Integrable (gs n) \u03bc)\n    (hfs : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => fs n x) atTop (\ud835\udcdd (f x)))\n    (hgs : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => gs n x) atTop (\ud835\udcdd (g x))) (bound_fs : \u03b1 \u2192 \u211d)\n    (h_int_bound_fs : Integrable bound_fs \u03bc) (bound_gs : \u03b1 \u2192 \u211d)\n    (h_int_bound_gs : Integrable bound_gs \u03bc) (hfs_bound : \u2200 n, \u2200\u1d50 x \u2202\u03bc, \u2016fs n x\u2016 \u2264 bound_fs x)\n    (hgs_bound : \u2200 n, \u2200\u1d50 x \u2202\u03bc, \u2016gs n x\u2016 \u2264 bound_gs x) (hfg : \u2200 n, \u03bc[fs n|m] =\u1d50[\u03bc] \u03bc[gs n|m]) :\n    \u03bc[f|m] =\u1d50[\u03bc] \u03bc[g|m]", "start": [388, 1], "end": [415, 91], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/ConvergenceInMeasure.lean", "imports": ["Mathlib/MeasureTheory/Function/Egorov.lean", "Mathlib/MeasureTheory/Function/LpSpace.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.TendstoInMeasure", "code": "def TendstoInMeasure [Dist E] {_ : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) (f : \u03b9 \u2192 \u03b1 \u2192 E) (l : Filter \u03b9)\n    (g : \u03b1 \u2192 E) : Prop :=\n  \u2200 (\u03b5) (_ : 0 < \u03b5), Tendsto (fun i => \u03bc { x | \u03b5 \u2264 dist (f i x) (g x) }) l (\ud835\udcdd 0)", "start": [50, 1], "end": [55, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendstoInMeasure_iff_norm", "code": "theorem tendstoInMeasure_iff_norm [SeminormedAddCommGroup E] {l : Filter \u03b9} {f : \u03b9 \u2192 \u03b1 \u2192 E}\n    {g : \u03b1 \u2192 E} :\n    TendstoInMeasure \u03bc f l g \u2194\n      \u2200 (\u03b5) (h\u03b5 : 0 < \u03b5), Tendsto (fun i => \u03bc { x | \u03b5 \u2264 \u2016f i x - g x\u2016 }) l (\ud835\udcdd 0)", "start": [58, 1], "end": [62, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.TendstoInMeasure.congr'", "code": "protected theorem congr' (h_left : \u2200\u1da0 i in l, f i =\u1d50[\u03bc] f' i) (h_right : g =\u1d50[\u03bc] g')\n    (h_tendsto : TendstoInMeasure \u03bc f l g) : TendstoInMeasure \u03bc f' l g'", "start": [69, 1], "end": [81, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.TendstoInMeasure.congr", "code": "protected theorem congr (h_left : \u2200 i, f i =\u1d50[\u03bc] f' i) (h_right : g =\u1d50[\u03bc] g')\n    (h_tendsto : TendstoInMeasure \u03bc f l g) : TendstoInMeasure \u03bc f' l g'", "start": [84, 1], "end": [86, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.TendstoInMeasure.congr_left", "code": "theorem congr_left (h : \u2200 i, f i =\u1d50[\u03bc] f' i) (h_tendsto : TendstoInMeasure \u03bc f l g) :\n    TendstoInMeasure \u03bc f' l g", "start": [89, 1], "end": [91, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.TendstoInMeasure.congr_right", "code": "theorem congr_right (h : g =\u1d50[\u03bc] g') (h_tendsto : TendstoInMeasure \u03bc f l g) :\n    TendstoInMeasure \u03bc f l g'", "start": [94, 1], "end": [96, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendstoInMeasure_of_tendsto_ae_of_stronglyMeasurable", "code": "theorem tendstoInMeasure_of_tendsto_ae_of_stronglyMeasurable [IsFiniteMeasure \u03bc]\n    (hf : \u2200 n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g)\n    (hfg : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (g x))) : TendstoInMeasure \u03bc f atTop g", "start": [107, 1], "end": [125, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendstoInMeasure_of_tendsto_ae", "code": "theorem tendstoInMeasure_of_tendsto_ae [IsFiniteMeasure \u03bc] (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc)\n    (hfg : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (g x))) : TendstoInMeasure \u03bc f atTop g", "start": [128, 1], "end": [139, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ExistsSeqTendstoAe.exists_nat_measure_lt_two_inv", "code": "theorem exists_nat_measure_lt_two_inv (hfg : TendstoInMeasure \u03bc f atTop g) (n : \u2115) :\n    \u2203 N, \u2200 m \u2265 N, \u03bc { x | (2 : \u211d)\u207b\u00b9 ^ n \u2264 dist (f m x) (g x) } \u2264 (2\u207b\u00b9 : \u211d\u22650\u221e) ^ n", "start": [146, 1], "end": [150, 101], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ExistsSeqTendstoAe.seqTendstoAeSeqAux", "code": "noncomputable def seqTendstoAeSeqAux (hfg : TendstoInMeasure \u03bc f atTop g) (n : \u2115) :=\n  Classical.choose (exists_nat_measure_lt_two_inv hfg n)", "start": [153, 1], "end": [157, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ExistsSeqTendstoAe.seqTendstoAeSeq", "code": "noncomputable def seqTendstoAeSeq (hfg : TendstoInMeasure \u03bc f atTop g) : \u2115 \u2192 \u2115\n  | 0 => seqTendstoAeSeqAux hfg 0\n  | n + 1 => max (seqTendstoAeSeqAux hfg (n + 1)) (seqTendstoAeSeq hfg n + 1)", "start": [160, 1], "end": [163, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ExistsSeqTendstoAe.seqTendstoAeSeq_succ", "code": "theorem seqTendstoAeSeq_succ (hfg : TendstoInMeasure \u03bc f atTop g) {n : \u2115} :\n    seqTendstoAeSeq hfg (n + 1) =\n      max (seqTendstoAeSeqAux hfg (n + 1)) (seqTendstoAeSeq hfg n + 1)", "start": [166, 1], "end": [169, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ExistsSeqTendstoAe.seqTendstoAeSeq_spec", "code": "theorem seqTendstoAeSeq_spec (hfg : TendstoInMeasure \u03bc f atTop g) (n k : \u2115)\n    (hn : seqTendstoAeSeq hfg n \u2264 k) :\n    \u03bc { x | (2 : \u211d)\u207b\u00b9 ^ n \u2264 dist (f k x) (g x) } \u2264 (2 : \u211d\u22650\u221e)\u207b\u00b9 ^ n", "start": [172, 1], "end": [178, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ExistsSeqTendstoAe.seqTendstoAeSeq_strictMono", "code": "theorem seqTendstoAeSeq_strictMono (hfg : TendstoInMeasure \u03bc f atTop g) :\n    StrictMono (seqTendstoAeSeq hfg)", "start": [181, 1], "end": [185, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.TendstoInMeasure.exists_seq_tendsto_ae", "code": "theorem TendstoInMeasure.exists_seq_tendsto_ae (hfg : TendstoInMeasure \u03bc f atTop g) :\n    \u2203 ns : \u2115 \u2192 \u2115, StrictMono ns \u2227 \u2200\u1d50 x \u2202\u03bc, Tendsto (fun i => f (ns i) x) atTop (\ud835\udcdd (g x))", "start": [190, 1], "end": [237, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.TendstoInMeasure.exists_seq_tendstoInMeasure_atTop", "code": "theorem TendstoInMeasure.exists_seq_tendstoInMeasure_atTop {u : Filter \u03b9} [NeBot u]\n    [IsCountablyGenerated u] {f : \u03b9 \u2192 \u03b1 \u2192 E} {g : \u03b1 \u2192 E} (hfg : TendstoInMeasure \u03bc f u g) :\n    \u2203 ns : \u2115 \u2192 \u03b9, TendstoInMeasure \u03bc (fun n => f (ns n)) atTop g", "start": [240, 1], "end": [244, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.TendstoInMeasure.exists_seq_tendsto_ae'", "code": "theorem TendstoInMeasure.exists_seq_tendsto_ae' {u : Filter \u03b9} [NeBot u] [IsCountablyGenerated u]\n    {f : \u03b9 \u2192 \u03b1 \u2192 E} {g : \u03b1 \u2192 E} (hfg : TendstoInMeasure \u03bc f u g) :\n    \u2203 ns : \u2115 \u2192 \u03b9, \u2200\u1d50 x \u2202\u03bc, Tendsto (fun i => f (ns i) x) atTop (\ud835\udcdd (g x))", "start": [247, 1], "end": [252, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.TendstoInMeasure.aemeasurable", "code": "theorem TendstoInMeasure.aemeasurable {u : Filter \u03b9} [NeBot u] [IsCountablyGenerated u]\n    {f : \u03b9 \u2192 \u03b1 \u2192 E} {g : \u03b1 \u2192 E} (hf : \u2200 n, AEMeasurable (f n) \u03bc)\n    (h_tendsto : TendstoInMeasure \u03bc f u g) : AEMeasurable g \u03bc", "start": [261, 1], "end": [265, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendstoInMeasure_of_tendsto_snorm_of_stronglyMeasurable", "code": "theorem tendstoInMeasure_of_tendsto_snorm_of_stronglyMeasurable (hp_ne_zero : p \u2260 0)\n    (hp_ne_top : p \u2260 \u221e) (hf : \u2200 n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g)\n    {l : Filter \u03b9} (hfg : Tendsto (fun n => snorm (f n - g) p \u03bc) l (\ud835\udcdd 0)) :\n    TendstoInMeasure \u03bc f l g", "start": [276, 1], "end": [299, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendstoInMeasure_of_tendsto_snorm_of_ne_top", "code": "theorem tendstoInMeasure_of_tendsto_snorm_of_ne_top (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e)\n    (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc) (hg : AEStronglyMeasurable g \u03bc) {l : Filter \u03b9}\n    (hfg : Tendsto (fun n => snorm (f n - g) p \u03bc) l (\ud835\udcdd 0)) : TendstoInMeasure \u03bc f l g", "start": [302, 1], "end": [313, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendstoInMeasure_of_tendsto_snorm_top", "code": "theorem tendstoInMeasure_of_tendsto_snorm_top {E} [NormedAddCommGroup E] {f : \u03b9 \u2192 \u03b1 \u2192 E} {g : \u03b1 \u2192 E}\n    {l : Filter \u03b9} (hfg : Tendsto (fun n => snorm (f n - g) \u221e \u03bc) l (\ud835\udcdd 0)) :\n    TendstoInMeasure \u03bc f l g", "start": [316, 1], "end": [337, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendstoInMeasure_of_tendsto_snorm", "code": "theorem tendstoInMeasure_of_tendsto_snorm {l : Filter \u03b9} (hp_ne_zero : p \u2260 0)\n    (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc) (hg : AEStronglyMeasurable g \u03bc)\n    (hfg : Tendsto (fun n => snorm (f n - g) p \u03bc) l (\ud835\udcdd 0)) : TendstoInMeasure \u03bc f l g", "start": [340, 1], "end": [347, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendstoInMeasure_of_tendsto_Lp", "code": "theorem tendstoInMeasure_of_tendsto_Lp [hp : Fact (1 \u2264 p)] {f : \u03b9 \u2192 Lp E p \u03bc} {g : Lp E p \u03bc}\n    {l : Filter \u03b9} (hfg : Tendsto f l (\ud835\udcdd g)) : TendstoInMeasure \u03bc (fun n => f n) l g", "start": [350, 1], "end": [355, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/IsTensorProduct.lean", "imports": ["Mathlib/RingTheory/TensorProduct.lean", "Mathlib/Algebra/Module/ULift.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsTensorProduct", "code": "def IsTensorProduct : Prop :=\n  Function.Bijective (TensorProduct.lift f)", "start": [57, 1], "end": [62, 44], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.isTensorProduct", "code": "theorem TensorProduct.isTensorProduct : IsTensorProduct (TensorProduct.mk R M N)", "start": [67, 1], "end": [72, 32], "kind": "commanddeclaration"}, {"full_name": "IsTensorProduct.equiv", "code": "@[simps! apply]\nnoncomputable def IsTensorProduct.equiv (h : IsTensorProduct f) : M\u2081 \u2297[R] M\u2082 \u2243\u2097[R] M :=\n  LinearEquiv.ofBijective _ h", "start": [77, 1], "end": [80, 30], "kind": "commanddeclaration"}, {"full_name": "IsTensorProduct.equiv_toLinearMap", "code": "@[simp]\ntheorem IsTensorProduct.equiv_toLinearMap (h : IsTensorProduct f) :\n    h.equiv.toLinearMap = TensorProduct.lift f", "start": [83, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "IsTensorProduct.equiv_symm_apply", "code": "@[simp]\ntheorem IsTensorProduct.equiv_symm_apply (h : IsTensorProduct f) (x\u2081 : M\u2081) (x\u2082 : M\u2082) :\n    h.equiv.symm (f x\u2081 x\u2082) = x\u2081 \u2297\u209c x\u2082", "start": [89, 1], "end": [94, 7], "kind": "commanddeclaration"}, {"full_name": "IsTensorProduct.lift", "code": "noncomputable def IsTensorProduct.lift (h : IsTensorProduct f) (f' : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M') :\n    M \u2192\u2097[R] M' :=\n  (TensorProduct.lift f').comp h.equiv.symm.toLinearMap", "start": [97, 1], "end": [101, 56], "kind": "commanddeclaration"}, {"full_name": "IsTensorProduct.lift_eq", "code": "theorem IsTensorProduct.lift_eq (h : IsTensorProduct f) (f' : M\u2081 \u2192\u2097[R] M\u2082 \u2192\u2097[R] M') (x\u2081 : M\u2081)\n    (x\u2082 : M\u2082) : h.lift f' (f x\u2081 x\u2082) = f' x\u2081 x\u2082", "start": [104, 1], "end": [107, 7], "kind": "commanddeclaration"}, {"full_name": "IsTensorProduct.map", "code": "noncomputable def IsTensorProduct.map (hf : IsTensorProduct f) (hg : IsTensorProduct g)\n    (i\u2081 : M\u2081 \u2192\u2097[R] N\u2081) (i\u2082 : M\u2082 \u2192\u2097[R] N\u2082) : M \u2192\u2097[R] N :=\n  hg.equiv.toLinearMap.comp ((TensorProduct.map i\u2081 i\u2082).comp hf.equiv.symm.toLinearMap)", "start": [110, 1], "end": [113, 87], "kind": "commanddeclaration"}, {"full_name": "IsTensorProduct.map_eq", "code": "theorem IsTensorProduct.map_eq (hf : IsTensorProduct f) (hg : IsTensorProduct g) (i\u2081 : M\u2081 \u2192\u2097[R] N\u2081)\n    (i\u2082 : M\u2082 \u2192\u2097[R] N\u2082) (x\u2081 : M\u2081) (x\u2082 : M\u2082) : hf.map hg i\u2081 i\u2082 (f x\u2081 x\u2082) = g (i\u2081 x\u2081) (i\u2082 x\u2082)", "start": [116, 1], "end": [119, 7], "kind": "commanddeclaration"}, {"full_name": "IsTensorProduct.inductionOn", "code": "theorem IsTensorProduct.inductionOn (h : IsTensorProduct f) {C : M \u2192 Prop} (m : M) (h0 : C 0)\n    (htmul : \u2200 x y, C (f x y)) (hadd : \u2200 x y, C x \u2192 C y \u2192 C (x + y)) : C m", "start": [122, 1], "end": [134, 30], "kind": "commanddeclaration"}, {"full_name": "IsBaseChange", "code": "def IsBaseChange : Prop :=\n  IsTensorProduct\n    (((Algebra.linearMap S <| Module.End S (M \u2192\u2097[R] N)).flip f).restrictScalars R)", "start": [149, 1], "end": [154, 83], "kind": "commanddeclaration"}, {"full_name": "IsBaseChange.lift", "code": "noncomputable nonrec def IsBaseChange.lift (g : M \u2192\u2097[R] Q) : N \u2192\u2097[S] Q :=\n  { h.lift\n      (((Algebra.linearMap S <| Module.End S (M \u2192\u2097[R] Q)).flip g).restrictScalars R) with\n    map_smul' := fun r x => by\n      let F := ((Algebra.linearMap S <| Module.End S (M \u2192\u2097[R] Q)).flip g).restrictScalars R\n      have hF : \u2200 (s : S) (m : M), h.lift F (s \u2022 f m) = s \u2022 g m := h.lift_eq F\n      change h.lift F (r \u2022 x) = r \u2022 h.lift F x\n      apply h.inductionOn x\n      \u00b7 rw [smul_zero, map_zero, smul_zero]\n      \u00b7 intro s m\n        change h.lift F (r \u2022 s \u2022 f m) = r \u2022 h.lift F (s \u2022 f m)\n        rw [\u2190 mul_smul, hF, hF]\n        rw [mul_smul] apply mul_smul\n      \u00b7 intro x\u2081 x\u2082 e\u2081 e\u2082\n        rw [map_add, smul_add, map_add, smul_add, e\u2081, e\u2082] }", "start": [169, 1], "end": [186, 60], "kind": "commanddeclaration"}, {"full_name": "IsBaseChange.lift_eq", "code": "nonrec theorem IsBaseChange.lift_eq (g : M \u2192\u2097[R] Q) (x : M) : h.lift g (f x) = g x", "start": [189, 1], "end": [191, 35], "kind": "commanddeclaration"}, {"full_name": "IsBaseChange.lift_comp", "code": "theorem IsBaseChange.lift_comp (g : M \u2192\u2097[R] Q) : ((h.lift g).restrictScalars R).comp f = g", "start": [194, 1], "end": [195, 30], "kind": "commanddeclaration"}, {"full_name": "IsBaseChange.inductionOn", "code": "@[elab_as_elim]\nnonrec theorem IsBaseChange.inductionOn (x : N) (P : N \u2192 Prop) (h\u2081 : P 0) (h\u2082 : \u2200 m : M, P (f m))\n    (h\u2083 : \u2200 (s : S) (n), P n \u2192 P (s \u2022 n)) (h\u2084 : \u2200 n\u2081 n\u2082, P n\u2081 \u2192 P n\u2082 \u2192 P (n\u2081 + n\u2082)) : P x", "start": [200, 1], "end": [203, 51], "kind": "commanddeclaration"}, {"full_name": "IsBaseChange.algHom_ext", "code": "theorem IsBaseChange.algHom_ext (g\u2081 g\u2082 : N \u2192\u2097[S] Q) (e : \u2200 x, g\u2081 (f x) = g\u2082 (f x)) : g\u2081 = g\u2082", "start": [206, 1], "end": [214, 34], "kind": "commanddeclaration"}, {"full_name": "IsBaseChange.algHom_ext'", "code": "theorem IsBaseChange.algHom_ext' [Module R Q] [IsScalarTower R S Q] (g\u2081 g\u2082 : N \u2192\u2097[S] Q)\n    (e : (g\u2081.restrictScalars R).comp f = (g\u2082.restrictScalars R).comp f) : g\u2081 = g\u2082", "start": [217, 1], "end": [219, 45], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.isBaseChange", "code": "theorem TensorProduct.isBaseChange : IsBaseChange S (TensorProduct.mk R S M 1)", "start": [224, 1], "end": [231, 18], "kind": "commanddeclaration"}, {"full_name": "IsBaseChange.equiv", "code": "noncomputable nonrec def IsBaseChange.equiv : S \u2297[R] M \u2243\u2097[S] N :=\n  { h.equiv with\n    map_smul' := fun r x => by\n      change h.equiv (r \u2022 x) = r \u2022 h.equiv x\n      refine TensorProduct.induction_on x ?_ ?_ ?_\n      \u00b7 rw [smul_zero, map_zero, smul_zero]\n      \u00b7 intro x y\n        simp only [Algebra.linearMap_apply, lift.tmul, smul_eq_mul,\n          LinearMap.mul_apply, LinearMap.smul_apply, IsTensorProduct.equiv_apply,\n          Module.algebraMap_end_apply, _root_.map_mul, smul_tmul', eq_self_iff_true,\n          LinearMap.coe_restrictScalars, LinearMap.flip_apply]\n      \u00b7 intro x y hx hy\n        rw [map_add, smul_add, map_add, smul_add, hx, hy] }", "start": [236, 1], "end": [250, 60], "kind": "commanddeclaration"}, {"full_name": "IsBaseChange.equiv_tmul", "code": "theorem IsBaseChange.equiv_tmul (s : S) (m : M) : h.equiv (s \u2297\u209c m) = s \u2022 f m", "start": [253, 1], "end": [254, 30], "kind": "commanddeclaration"}, {"full_name": "IsBaseChange.equiv_symm_apply", "code": "theorem IsBaseChange.equiv_symm_apply (m : M) : h.equiv.symm (f m) = 1 \u2297\u209c m", "start": [257, 1], "end": [258, 53], "kind": "commanddeclaration"}, {"full_name": "IsBaseChange.of_lift_unique", "code": "theorem IsBaseChange.of_lift_unique\n    (h : \u2200 (Q : Type max v\u2081 v\u2082 v\u2083) [AddCommMonoid Q],\n      \u2200 [Module R Q] [Module S Q], \u2200 [IsScalarTower R S Q],\n        \u2200 g : M \u2192\u2097[R] Q, \u2203! g' : N \u2192\u2097[S] Q, (g'.restrictScalars R).comp f = g) :\n    IsBaseChange S f", "start": [263, 1], "end": [294, 8], "kind": "commanddeclaration"}, {"full_name": "IsBaseChange.iff_lift_unique", "code": "theorem IsBaseChange.iff_lift_unique :\n    IsBaseChange S f \u2194\n      \u2200 (Q : Type max v\u2081 v\u2082 v\u2083) [AddCommMonoid Q],\n        \u2200 [Module R Q] [Module S Q],\n          \u2200 [IsScalarTower R S Q],\n            \u2200 g : M \u2192\u2097[R] Q, \u2203! g' : N \u2192\u2097[S] Q, (g'.restrictScalars R).comp f = g", "start": [299, 1], "end": [308, 35], "kind": "commanddeclaration"}, {"full_name": "IsBaseChange.ofEquiv", "code": "theorem IsBaseChange.ofEquiv (e : M \u2243\u2097[R] N) : IsBaseChange R e.toLinearMap", "start": [311, 1], "end": [327, 7], "kind": "commanddeclaration"}, {"full_name": "IsBaseChange.comp", "code": "theorem IsBaseChange.comp {f : M \u2192\u2097[R] N} (hf : IsBaseChange S f) {g : N \u2192\u2097[S] O}\n    (hg : IsBaseChange T g) : IsBaseChange T ((g.restrictScalars R).comp f)", "start": [336, 1], "end": [358, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.IsPushout", "code": "@[mk_iff]\nclass Algebra.IsPushout : Prop where\n  out : IsBaseChange S (toAlgHom R R' S').toLinearMap", "start": [371, 1], "end": [379, 54], "kind": "commanddeclaration"}, {"full_name": "Algebra.IsPushout.symm", "code": "@[symm]\ntheorem Algebra.IsPushout.symm (h : Algebra.IsPushout R S R' S') : Algebra.IsPushout R R' S S'", "start": [384, 1], "end": [410, 74], "kind": "commanddeclaration"}, {"full_name": "Algebra.IsPushout.comm", "code": "theorem Algebra.IsPushout.comm : Algebra.IsPushout R S R' S' \u2194 Algebra.IsPushout R R' S S'", "start": [415, 1], "end": [416, 51], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.isPushout", "code": "instance TensorProduct.isPushout {R S T : Type*} [CommRing R] [CommRing S] [CommRing T]\n    [Algebra R S] [Algebra R T] : Algebra.IsPushout R S T (TensorProduct R S T) :=\n  \u27e8TensorProduct.isBaseChange R T S\u27e9", "start": [423, 1], "end": [425, 37], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.isPushout'", "code": "instance TensorProduct.isPushout' {R S T : Type*} [CommRing R] [CommRing S] [CommRing T]\n    [Algebra R S] [Algebra R T] : Algebra.IsPushout R T S (TensorProduct R S T) :=\n  Algebra.IsPushout.symm inferInstance", "start": [428, 1], "end": [430, 39], "kind": "commanddeclaration"}, {"full_name": "Algebra.pushoutDesc", "code": "noncomputable def Algebra.pushoutDesc [H : Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]\n    [Algebra R A] (f : S \u2192\u2090[R] A) (g : R' \u2192\u2090[R] A) (hf : \u2200 x y, f x * g y = g y * f x) :\n    S' \u2192\u2090[R] A := by\n  letI := Module.compHom A f.toRingHom\n  haveI : IsScalarTower R S A :=\n    { smul_assoc := fun r s a =>\n        show f (r \u2022 s) * a = r \u2022 (f s * a) by rw [f.map_smul, smul_mul_assoc] }\n  haveI : IsScalarTower S A A := { smul_assoc := fun r a b => mul_assoc _ _ _ }\n  have : \u2200 x, H.out.lift g.toLinearMap (algebraMap R' S' x) = g x := H.out.lift_eq _\n  refine' AlgHom.ofLinearMap ((H.out.lift g.toLinearMap).restrictScalars R) _ _\n  \u00b7 dsimp only [LinearMap.restrictScalars_apply]\n    rw [\u2190 (algebraMap R' S').map_one, this, g.map_one]\n  \u00b7 intro x y\n    refine H.out.inductionOn x ?_ ?_ ?_ ?_\n    \u00b7 rw [zero_mul, map_zero, zero_mul]\n    rotate_left\n    \u00b7 intro s s' e\n      dsimp only [LinearMap.restrictScalars_apply] at e \u22a2\n      rw [LinearMap.map_smul, smul_mul_assoc, LinearMap.map_smul, e, smul_mul_assoc]\n    \u00b7 intro s s' e\u2081 e\u2082\n      dsimp only [LinearMap.restrictScalars_apply] at e\u2081 e\u2082 \u22a2\n      rw [add_mul, map_add, map_add, add_mul, e\u2081, e\u2082]\n    intro x\n    dsimp\n    rw [this]\n    refine H.out.inductionOn y ?_ ?_ ?_ ?_\n    \u00b7 rw [mul_zero, map_zero, mul_zero]\n    \u00b7 intro y\n      dsimp\n      rw [\u2190 _root_.map_mul, this, this, _root_.map_mul]\n    \u00b7 intro s s' e\n      rw [mul_comm, smul_mul_assoc, LinearMap.map_smul, LinearMap.map_smul, mul_comm, e]\n      change f s * (g x * _) = g x * (f s * _)\n      rw [\u2190 mul_assoc, \u2190 mul_assoc, hf]\n    \u00b7 intro s s' e\u2081 e\u2082\n      rw [mul_add, map_add, map_add, mul_add, e\u2081, e\u2082]", "start": [433, 1], "end": [472, 54], "kind": "commanddeclaration"}, {"full_name": "Algebra.pushoutDesc_apply", "code": "theorem Algebra.pushoutDesc_apply [H : Algebra.IsPushout R S R' S'] {A : Type*}\n    [Semiring A] [Algebra R A] (f : S \u2192\u2090[R] A) (g : R' \u2192\u2090[R] A) (hf : \u2200 x y, f x * g y = g y * f x)\n    (s : S') : by\n  letI := Module.compHom A f.toRingHom\n  haveI : IsScalarTower R S A :=\n    { smul_assoc := fun r s a =>\n      show f (r \u2022 s) * a = r \u2022 (f s * a) by rw [f.map_smul, smul_mul_assoc] }\n  exact Algebra.pushoutDesc S' f g hf s = H.out.lift g.toLinearMap s", "start": [476, 1], "end": [483, 76], "kind": "commanddeclaration"}, {"full_name": "Algebra.pushoutDesc_left", "code": "@[simp]\ntheorem Algebra.pushoutDesc_left [H : Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]\n    [Algebra R A] (f : S \u2192\u2090[R] A) (g : R' \u2192\u2090[R] A) (H) (x : S) :\n    Algebra.pushoutDesc S' f g H (algebraMap S S' x) = f x", "start": [485, 1], "end": [496, 22], "kind": "commanddeclaration"}, {"full_name": "Algebra.lift_algHom_comp_left", "code": "theorem Algebra.lift_algHom_comp_left [Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]\n    [Algebra R A] (f : S \u2192\u2090[R] A) (g : R' \u2192\u2090[R] A) (H) :\n    (Algebra.pushoutDesc S' f g H).comp (toAlgHom R S S') = f", "start": [499, 1], "end": [502, 64], "kind": "commanddeclaration"}, {"full_name": "Algebra.pushoutDesc_right", "code": "@[simp]\ntheorem Algebra.pushoutDesc_right [H : Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]\n    [Algebra R A] (f : S \u2192\u2090[R] A) (g : R' \u2192\u2090[R] A) (H) (x : R') :\n    Algebra.pushoutDesc S' f g H (algebraMap R' S' x) = g x", "start": [505, 1], "end": [513, 29], "kind": "commanddeclaration"}, {"full_name": "Algebra.lift_algHom_comp_right", "code": "theorem Algebra.lift_algHom_comp_right [Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]\n    [Algebra R A] (f : S \u2192\u2090[R] A) (g : R' \u2192\u2090[R] A) (H) :\n    (Algebra.pushoutDesc S' f g H).comp (toAlgHom R R' S') = g", "start": [516, 1], "end": [519, 65], "kind": "commanddeclaration"}, {"full_name": "Algebra.IsPushout.algHom_ext", "code": "@[ext]\ntheorem Algebra.IsPushout.algHom_ext [H : Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]\n    [Algebra R A] {f g : S' \u2192\u2090[R] A} (h\u2081 : f.comp (toAlgHom R R' S') = g.comp (toAlgHom R R' S'))\n    (h\u2082 : f.comp (toAlgHom R S S') = g.comp (toAlgHom R S S')) : f = g", "start": [522, 1], "end": [535, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Sheaves/LocalPredicate.lean", "imports": ["Mathlib/Topology/Sheaves/SheafOfFunctions.lean", "Mathlib/Topology/LocalHomeomorph.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Sheaves/Stalks.lean", "Mathlib/Topology/Sheaves/SheafCondition/UniqueGluing.lean"], "premises": [{"full_name": "TopCat.PrelocalPredicate", "code": "structure PrelocalPredicate where\n  \n  pred : \u2200 {U : Opens X}, (\u2200 x : U, T x) \u2192 Prop\n  \n  res : \u2200 {U V : Opens X} (i : U \u27f6 V) (f : \u2200 x : V, T x) (_ : pred f), pred fun x : U => f (i x)", "start": [61, 1], "end": [71, 97], "kind": "commanddeclaration"}, {"full_name": "TopCat.continuousPrelocal", "code": "@[simps!]\ndef continuousPrelocal (T : TopCat.{v}) : PrelocalPredicate fun _ : X => T where\n  pred {_} f := Continuous f\n  res {_ _} i _ h := Continuous.comp h (Opens.openEmbedding_of_le i.le).continuous", "start": [77, 1], "end": [82, 83], "kind": "commanddeclaration"}, {"full_name": "TopCat.inhabitedPrelocalPredicate", "code": "instance inhabitedPrelocalPredicate (T : TopCat.{v}) :\n    Inhabited (PrelocalPredicate fun _ : X => T) :=\n  \u27e8continuousPrelocal X T\u27e9", "start": [86, 1], "end": [89, 27], "kind": "commanddeclaration"}, {"full_name": "TopCat.LocalPredicate", "code": "structure LocalPredicate extends PrelocalPredicate T where\n  \n  locality :\n    \u2200 {U : Opens X} (f : \u2200 x : U, T x)\n      (_ : \u2200 x : U, \u2203 (V : Opens X) (_ : x.1 \u2208 V) (i : V \u27f6 U),\n        pred fun x : V => f (i x : U)), pred f", "start": [95, 1], "end": [111, 47], "kind": "commanddeclaration"}, {"full_name": "TopCat.continuousLocal", "code": "def continuousLocal (T : TopCat.{v}) : LocalPredicate fun _ : X => T :=\n  { continuousPrelocal X T with\n    locality := fun {U} f w => by\n      apply continuous_iff_continuousAt.2\n      intro x\n      specialize w x\n      rcases w with \u27e8V, m, i, w\u27e9\n      dsimp at w\n      rw [continuous_iff_continuousAt] at w\n      specialize w \u27e8x, m\u27e9\n      simpa using (Opens.openEmbedding_of_le i.le).continuousAt_iff.1 w }", "start": [117, 1], "end": [129, 74], "kind": "commanddeclaration"}, {"full_name": "TopCat.inhabitedLocalPredicate", "code": "instance inhabitedLocalPredicate (T : TopCat.{v}) : Inhabited (LocalPredicate fun _ : X => T) :=\n  \u27e8continuousLocal X T\u27e9", "start": [133, 1], "end": [135, 24], "kind": "commanddeclaration"}, {"full_name": "TopCat.PrelocalPredicate.sheafify", "code": "def PrelocalPredicate.sheafify {T : X \u2192 Type v} (P : PrelocalPredicate T) : LocalPredicate T where\n  pred {U} f := \u2200 x : U, \u2203 (V : Opens X) (_ : x.1 \u2208 V) (i : V \u27f6 U), P.pred fun x : V => f (i x : U)\n  res {V U} i f w x := by\n    specialize w (i x)\n    rcases w with \u27e8V', m', i', p\u27e9\n    refine' \u27e8V \u2293 V', \u27e8x.2, m'\u27e9, Opens.infLELeft _ _, _\u27e9\n    convert P.res (Opens.infLERight V V') _ p\n  locality {U} f w x := by\n    specialize w x\n    rcases w with \u27e8V, m, i, p\u27e9\n    specialize p \u27e8x.1, m\u27e9\n    rcases p with \u27e8V', m', i', p'\u27e9\n    exact \u27e8V', m', i' \u226b i, p'\u27e9", "start": [141, 1], "end": [156, 31], "kind": "commanddeclaration"}, {"full_name": "TopCat.PrelocalPredicate.sheafifyOf", "code": "theorem PrelocalPredicate.sheafifyOf {T : X \u2192 Type v} {P : PrelocalPredicate T} {U : Opens X}\n    {f : \u2200 x : U, T x} (h : P.pred f) : P.sheafify.pred f", "start": [160, 1], "end": [162, 30], "kind": "commanddeclaration"}, {"full_name": "TopCat.subpresheafToTypes", "code": "@[simps!]\ndef subpresheafToTypes (P : PrelocalPredicate T) : Presheaf (Type v) X where\n  obj U := { f : \u2200 x : U.unop , T x // P.pred f }\n  map {U V} i f := \u27e8fun x => f.1 (i.unop x), P.res i.unop f.1 f.2\u27e9", "start": [166, 1], "end": [171, 67], "kind": "commanddeclaration"}, {"full_name": "TopCat.subpresheafToTypes.subtype", "code": "def subtype : subpresheafToTypes P \u27f6 presheafToTypes X T where app U f := f.1", "start": [179, 1], "end": [182, 78], "kind": "commanddeclaration"}, {"full_name": "TopCat.subpresheafToTypes.isSheaf", "code": "theorem isSheaf (P : LocalPredicate T) : (subpresheafToTypes P.toPrelocalPredicate).IsSheaf", "start": [188, 1], "end": [220, 66], "kind": "commanddeclaration"}, {"full_name": "TopCat.subsheafToTypes", "code": "@[simps]\ndef subsheafToTypes (P : LocalPredicate T) : Sheaf (Type v) X :=\n  \u27e8subpresheafToTypes P.toPrelocalPredicate, subpresheafToTypes.isSheaf P\u27e9", "start": [226, 1], "end": [230, 75], "kind": "commanddeclaration"}, {"full_name": "TopCat.stalkToFiber", "code": "def stalkToFiber (P : LocalPredicate T) (x : X) : (subsheafToTypes P).presheaf.stalk x \u27f6 T x := by\n  refine'\n    colimit.desc _\n      { pt := T x\n        \u03b9 :=\n          { app := fun U f => _\n            naturality := _ } }\n  \u00b7 exact f.1 \u27e8x, (unop U).2\u27e9\n  \u00b7 aesop", "start": [234, 1], "end": [244, 10], "kind": "commanddeclaration"}, {"full_name": "TopCat.stalkToFiber_germ", "code": "theorem stalkToFiber_germ (P : LocalPredicate T) (U : Opens X) (x : U) (f) :\n    stalkToFiber P x ((subsheafToTypes P).presheaf.germ x f) = f.1 x", "start": [249, 1], "end": [253, 7], "kind": "commanddeclaration"}, {"full_name": "TopCat.stalkToFiber_surjective", "code": "theorem stalkToFiber_surjective (P : LocalPredicate T) (x : X)\n    (w : \u2200 t : T x, \u2203 (U : OpenNhds x) (f : \u2200 y : U.1, T y) (_ : P.pred f), f \u27e8x, U.2\u27e9 = t) :\n    Function.Surjective (stalkToFiber P x)", "start": [257, 1], "end": [266, 50], "kind": "commanddeclaration"}, {"full_name": "TopCat.stalkToFiber_injective", "code": "theorem stalkToFiber_injective (P : LocalPredicate T) (x : X)\n    (w :\n      \u2200 (U V : OpenNhds x) (fU : \u2200 y : U.1, T y) (_ : P.pred fU) (fV : \u2200 y : V.1, T y)\n        (_ : P.pred fV) (_ : fU \u27e8x, U.2\u27e9 = fV \u27e8x, V.2\u27e9),\n        \u2203 (W : OpenNhds x) (iU : W \u27f6 U) (iV : W \u27f6 V), \u2200 w : W.1,\n          fU (iU w : U.1) = fV (iV w : V.1)) :\n    Function.Injective (stalkToFiber P x)", "start": [270, 1], "end": [300, 101], "kind": "commanddeclaration"}, {"full_name": "TopCat.subpresheafContinuousPrelocalIsoPresheafToTop", "code": "def subpresheafContinuousPrelocalIsoPresheafToTop (T : TopCat.{v}) :\n    subpresheafToTypes (continuousPrelocal X T) \u2245 presheafToTop X T :=\n  NatIso.ofComponents fun X =>\n    { hom := by rintro \u27e8f, c\u27e9; exact \u27e8f, c\u27e9\n      inv := by rintro \u27e8f, c\u27e9; exact \u27e8f, c\u27e9 }", "start": [304, 1], "end": [312, 46], "kind": "commanddeclaration"}, {"full_name": "TopCat.sheafToTop", "code": "def sheafToTop (T : TopCat.{v}) : Sheaf (Type v) X :=\n  \u27e8presheafToTop X T,\n    Presheaf.isSheaf_of_iso (subpresheafContinuousPrelocalIsoPresheafToTop T)\n      (subpresheafToTypes.isSheaf (continuousLocal X T))\u27e9", "start": [316, 1], "end": [321, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean", "imports": ["Mathlib/Topology/Sets/Closeds.lean", "Mathlib/RingTheory/Ideal/Over.lean", "Mathlib/RingTheory/Localization/Away/Basic.lean", "Mathlib/RingTheory/Ideal/Prod.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Nilpotent.lean", "Mathlib/Topology/Sober.lean", "Mathlib/LinearAlgebra/Finsupp.lean"], "premises": [{"full_name": "PrimeSpectrum", "code": "@[ext]\nstructure PrimeSpectrum where\n  asIdeal : Ideal R\n  IsPrime : asIdeal.IsPrime", "start": [55, 1], "end": [63, 28], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.primeSpectrumProdOfSum", "code": "@[simp]\ndef primeSpectrumProdOfSum : Sum (PrimeSpectrum R) (PrimeSpectrum S) \u2192 PrimeSpectrum (R \u00d7 S)\n  | Sum.inl \u27e8I, _\u27e9 => \u27e8Ideal.prod I \u22a4, Ideal.isPrime_ideal_prod_top\u27e9\n  | Sum.inr \u27e8J, _\u27e9 => \u27e8Ideal.prod \u22a4 J, Ideal.isPrime_ideal_prod_top'\u27e9", "start": [83, 1], "end": [87, 70], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.primeSpectrumProd", "code": "noncomputable def primeSpectrumProd :\n    PrimeSpectrum (R \u00d7 S) \u2243 Sum (PrimeSpectrum R) (PrimeSpectrum S) :=\n  Equiv.symm <|\n    Equiv.ofBijective (primeSpectrumProdOfSum R S) (by\n        constructor\n        \u00b7 rintro (\u27e8I, hI\u27e9 | \u27e8J, hJ\u27e9) (\u27e8I', hI'\u27e9 | \u27e8J', hJ'\u27e9) h <;>\n          simp only [mk.injEq, Ideal.prod.ext_iff, primeSpectrumProdOfSum] at h\n          \u00b7 simp only [h]\n          \u00b7 exact False.elim (hI.ne_top h.left)\n          \u00b7 exact False.elim (hJ.ne_top h.right)\n          \u00b7 simp only [h]\n        \u00b7 rintro \u27e8I, hI\u27e9\n          rcases (Ideal.ideal_prod_prime I).mp hI with (\u27e8p, \u27e8hp, rfl\u27e9\u27e9 | \u27e8p, \u27e8hp, rfl\u27e9\u27e9)\n          \u00b7 exact \u27e8Sum.inl \u27e8p, hp\u27e9, rfl\u27e9\n          \u00b7 exact \u27e8Sum.inr \u27e8p, hp\u27e9, rfl\u27e9)", "start": [90, 1], "end": [106, 42], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.primeSpectrumProd_symm_inl_asIdeal", "code": "@[simp]\ntheorem primeSpectrumProd_symm_inl_asIdeal (x : PrimeSpectrum R) :\n    ((primeSpectrumProd R S).symm <| Sum.inl x).asIdeal = Ideal.prod x.asIdeal \u22a4", "start": [111, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.primeSpectrumProd_symm_inr_asIdeal", "code": "@[simp]\ntheorem primeSpectrumProd_symm_inr_asIdeal (x : PrimeSpectrum S) :\n    ((primeSpectrumProd R S).symm <| Sum.inr x).asIdeal = Ideal.prod \u22a4 x.asIdeal", "start": [118, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus", "code": "def zeroLocus (s : Set R) : Set (PrimeSpectrum R) :=\n  { x | s \u2286 x.asIdeal }", "start": [125, 1], "end": [134, 24], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.mem_zeroLocus", "code": "@[simp]\ntheorem mem_zeroLocus (x : PrimeSpectrum R) (s : Set R) : x \u2208 zeroLocus s \u2194 s \u2286 x.asIdeal", "start": [137, 1], "end": [139, 10], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_span", "code": "@[simp]\ntheorem zeroLocus_span (s : Set R) : zeroLocus (Ideal.span s : Set R) = zeroLocus s", "start": [142, 1], "end": [145, 42], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.vanishingIdeal", "code": "def vanishingIdeal (t : Set (PrimeSpectrum R)) : Ideal R :=\n  \u2a05 (x : PrimeSpectrum R) (_ : x \u2208 t), x.asIdeal", "start": [148, 1], "end": [157, 49], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.coe_vanishingIdeal", "code": "theorem coe_vanishingIdeal (t : Set (PrimeSpectrum R)) :\n    (vanishingIdeal t : Set R) = { f : R | \u2200 x : PrimeSpectrum R, x \u2208 t \u2192 f \u2208 x.asIdeal }", "start": [160, 1], "end": [165, 26], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.mem_vanishingIdeal", "code": "theorem mem_vanishingIdeal (t : Set (PrimeSpectrum R)) (f : R) :\n    f \u2208 vanishingIdeal t \u2194 \u2200 x : PrimeSpectrum R, x \u2208 t \u2192 f \u2208 x.asIdeal", "start": [168, 1], "end": [170, 63], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.vanishingIdeal_singleton", "code": "@[simp]\ntheorem vanishingIdeal_singleton (x : PrimeSpectrum R) :\n    vanishingIdeal ({x} : Set (PrimeSpectrum R)) = x.asIdeal", "start": [173, 1], "end": [175, 89], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.subset_zeroLocus_iff_le_vanishingIdeal", "code": "theorem subset_zeroLocus_iff_le_vanishingIdeal (t : Set (PrimeSpectrum R)) (I : Ideal R) :\n    t \u2286 zeroLocus I \u2194 I \u2264 vanishingIdeal t", "start": [178, 1], "end": [181, 100], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.gc", "code": "theorem gc :\n    @GaloisConnection (Ideal R) (Set (PrimeSpectrum R))\u1d52\u1d48 _ _ (fun I => zeroLocus I) fun t =>\n      vanishingIdeal t", "start": [188, 1], "end": [192, 56], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.gc_set", "code": "theorem gc_set :\n    @GaloisConnection (Set R) (Set (PrimeSpectrum R))\u1d52\u1d48 _ _ (fun s => zeroLocus s) fun t =>\n      vanishingIdeal t", "start": [195, 1], "end": [200, 70], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.subset_zeroLocus_iff_subset_vanishingIdeal", "code": "theorem subset_zeroLocus_iff_subset_vanishingIdeal (t : Set (PrimeSpectrum R)) (s : Set R) :\n    t \u2286 zeroLocus s \u2194 s \u2286 vanishingIdeal t", "start": [203, 1], "end": [205, 17], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.subset_vanishingIdeal_zeroLocus", "code": "theorem subset_vanishingIdeal_zeroLocus (s : Set R) : s \u2286 vanishingIdeal (zeroLocus s)", "start": [210, 1], "end": [211, 22], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.le_vanishingIdeal_zeroLocus", "code": "theorem le_vanishingIdeal_zeroLocus (I : Ideal R) : I \u2264 vanishingIdeal (zeroLocus I)", "start": [214, 1], "end": [215, 18], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.vanishingIdeal_zeroLocus_eq_radical", "code": "@[simp]\ntheorem vanishingIdeal_zeroLocus_eq_radical (I : Ideal R) :\n    vanishingIdeal (zeroLocus (I : Set R)) = I.radical", "start": [218, 1], "end": [223, 74], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_radical", "code": "@[simp]\ntheorem zeroLocus_radical (I : Ideal R) : zeroLocus (I.radical : Set R) = zeroLocus I", "start": [226, 1], "end": [228, 62], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.subset_zeroLocus_vanishingIdeal", "code": "theorem subset_zeroLocus_vanishingIdeal (t : Set (PrimeSpectrum R)) :\n    t \u2286 zeroLocus (vanishingIdeal t)", "start": [231, 1], "end": [233, 18], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_anti_mono", "code": "theorem zeroLocus_anti_mono {s t : Set R} (h : s \u2286 t) : zeroLocus t \u2286 zeroLocus s", "start": [236, 1], "end": [237, 26], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_anti_mono_ideal", "code": "theorem zeroLocus_anti_mono_ideal {s t : Ideal R} (h : s \u2264 t) :\n    zeroLocus (t : Set R) \u2286 zeroLocus (s : Set R)", "start": [240, 1], "end": [242, 22], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.vanishingIdeal_anti_mono", "code": "theorem vanishingIdeal_anti_mono {s t : Set (PrimeSpectrum R)} (h : s \u2286 t) :\n    vanishingIdeal t \u2264 vanishingIdeal s", "start": [245, 1], "end": [247, 22], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_subset_zeroLocus_iff", "code": "theorem zeroLocus_subset_zeroLocus_iff (I J : Ideal R) :\n    zeroLocus (I : Set R) \u2286 zeroLocus (J : Set R) \u2194 J \u2264 I.radical", "start": [250, 1], "end": [252, 83], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_subset_zeroLocus_singleton_iff", "code": "theorem zeroLocus_subset_zeroLocus_singleton_iff (f g : R) :\n    zeroLocus ({f} : Set R) \u2286 zeroLocus {g} \u2194 g \u2208 (Ideal.span ({f} : Set R)).radical", "start": [255, 1], "end": [258, 47], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_bot", "code": "theorem zeroLocus_bot : zeroLocus ((\u22a5 : Ideal R) : Set R) = Set.univ", "start": [261, 1], "end": [262, 15], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_singleton_zero", "code": "@[simp]\ntheorem zeroLocus_singleton_zero : zeroLocus ({0} : Set R) = Set.univ", "start": [265, 1], "end": [267, 16], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_empty", "code": "@[simp]\ntheorem zeroLocus_empty : zeroLocus (\u2205 : Set R) = Set.univ", "start": [270, 1], "end": [272, 19], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.vanishingIdeal_univ", "code": "@[simp]\ntheorem vanishingIdeal_univ : vanishingIdeal (\u2205 : Set (PrimeSpectrum R)) = \u22a4", "start": [275, 1], "end": [277, 27], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_empty_of_one_mem", "code": "theorem zeroLocus_empty_of_one_mem {s : Set R} (h : (1 : R) \u2208 s) : zeroLocus s = \u2205", "start": [280, 1], "end": [288, 30], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_singleton_one", "code": "@[simp]\ntheorem zeroLocus_singleton_one : zeroLocus ({1} : Set R) = \u2205", "start": [291, 1], "end": [293, 57], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_empty_iff_eq_top", "code": "theorem zeroLocus_empty_iff_eq_top {I : Ideal R} : zeroLocus (I : Set R) = \u2205 \u2194 I = \u22a4", "start": [296, 1], "end": [304, 12], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_univ", "code": "@[simp]\ntheorem zeroLocus_univ : zeroLocus (Set.univ : Set R) = \u2205", "start": [307, 1], "end": [309, 46], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.vanishingIdeal_eq_top_iff", "code": "theorem vanishingIdeal_eq_top_iff {s : Set (PrimeSpectrum R)} : vanishingIdeal s = \u22a4 \u2194 s = \u2205", "start": [312, 1], "end": [314, 26], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_sup", "code": "theorem zeroLocus_sup (I J : Ideal R) :\n    zeroLocus ((I \u2294 J : Ideal R) : Set R) = zeroLocus I \u2229 zeroLocus J", "start": [317, 1], "end": [319, 15], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_union", "code": "theorem zeroLocus_union (s s' : Set R) : zeroLocus (s \u222a s') = zeroLocus s \u2229 zeroLocus s'", "start": [322, 1], "end": [323, 19], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.vanishingIdeal_union", "code": "theorem vanishingIdeal_union (t t' : Set (PrimeSpectrum R)) :\n    vanishingIdeal (t \u222a t') = vanishingIdeal t \u2293 vanishingIdeal t'", "start": [326, 1], "end": [328, 15], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_iSup", "code": "theorem zeroLocus_iSup {\u03b9 : Sort*} (I : \u03b9 \u2192 Ideal R) :\n    zeroLocus ((\u2a06 i, I i : Ideal R) : Set R) = \u22c2 i, zeroLocus (I i)", "start": [331, 1], "end": [333, 16], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_iUnion", "code": "theorem zeroLocus_iUnion {\u03b9 : Sort*} (s : \u03b9 \u2192 Set R) :\n    zeroLocus (\u22c3 i, s i) = \u22c2 i, zeroLocus (s i)", "start": [336, 1], "end": [338, 20], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_bUnion", "code": "theorem zeroLocus_bUnion (s : Set (Set R)) :\n    zeroLocus (\u22c3 s' \u2208 s, s' : Set R) = \u22c2 s' \u2208 s, zeroLocus s'", "start": [341, 1], "end": [342, 97], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.vanishingIdeal_iUnion", "code": "theorem vanishingIdeal_iUnion {\u03b9 : Sort*} (t : \u03b9 \u2192 Set (PrimeSpectrum R)) :\n    vanishingIdeal (\u22c3 i, t i) = \u2a05 i, vanishingIdeal (t i)", "start": [345, 1], "end": [347, 16], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_inf", "code": "theorem zeroLocus_inf (I J : Ideal R) :\n    zeroLocus ((I \u2293 J : Ideal R) : Set R) = zeroLocus I \u222a zeroLocus J", "start": [350, 1], "end": [352, 30], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.union_zeroLocus", "code": "theorem union_zeroLocus (s s' : Set R) :\n    zeroLocus s \u222a zeroLocus s' = zeroLocus (Ideal.span s \u2293 Ideal.span s' : Ideal R)", "start": [355, 1], "end": [358, 7], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_mul", "code": "theorem zeroLocus_mul (I J : Ideal R) :\n    zeroLocus ((I * J : Ideal R) : Set R) = zeroLocus I \u222a zeroLocus J", "start": [361, 1], "end": [363, 30], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_singleton_mul", "code": "theorem zeroLocus_singleton_mul (f g : R) :\n    zeroLocus ({f * g} : Set R) = zeroLocus {f} \u222a zeroLocus {g}", "start": [366, 1], "end": [368, 61], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_pow", "code": "@[simp]\ntheorem zeroLocus_pow (I : Ideal R) {n : \u2115} (hn : 0 < n) :\n    zeroLocus ((I ^ n : Ideal R) : Set R) = zeroLocus I", "start": [371, 1], "end": [374, 78], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_singleton_pow", "code": "@[simp]\ntheorem zeroLocus_singleton_pow (f : R) (n : \u2115) (hn : 0 < n) :\n    zeroLocus ({f ^ n} : Set R) = zeroLocus {f}", "start": [377, 1], "end": [380, 59], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.sup_vanishingIdeal_le", "code": "theorem sup_vanishingIdeal_le (t t' : Set (PrimeSpectrum R)) :\n    vanishingIdeal t \u2294 vanishingIdeal t' \u2264 vanishingIdeal (t \u2229 t')", "start": [383, 1], "end": [389, 44], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.mem_compl_zeroLocus_iff_not_mem", "code": "theorem mem_compl_zeroLocus_iff_not_mem {f : R} {I : PrimeSpectrum R} :\n    I \u2208 (zeroLocus {f} : Set (PrimeSpectrum R))\u1d9c \u2194 f \u2209 I.asIdeal", "start": [392, 1], "end": [394, 71], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zariskiTopology", "code": "instance zariskiTopology : TopologicalSpace (PrimeSpectrum R) :=\n  TopologicalSpace.ofClosed (Set.range PrimeSpectrum.zeroLocus) \u27e8Set.univ, by simp\u27e9\n    (by\n      intro Zs h\n      rw [Set.sInter_eq_iInter]\n      choose f hf using fun i : Zs => h i.prop\n      simp only [\u2190 hf]\n      exact \u27e8_, zeroLocus_iUnion _\u27e9)\n    (by\n      rintro _ \u27e8s, rfl\u27e9 _ \u27e8t, rfl\u27e9\n      exact \u27e8_, (union_zeroLocus s t).symm\u27e9)", "start": [397, 1], "end": [409, 45], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isOpen_iff", "code": "theorem isOpen_iff (U : Set (PrimeSpectrum R)) : IsOpen U \u2194 \u2203 s, U\u1d9c = zeroLocus s", "start": [412, 1], "end": [413, 33], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isClosed_iff_zeroLocus", "code": "theorem isClosed_iff_zeroLocus (Z : Set (PrimeSpectrum R)) : IsClosed Z \u2194 \u2203 s, Z = zeroLocus s", "start": [416, 1], "end": [417, 51], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isClosed_iff_zeroLocus_ideal", "code": "theorem isClosed_iff_zeroLocus_ideal (Z : Set (PrimeSpectrum R)) :\n    IsClosed Z \u2194 \u2203 I : Ideal R, Z = zeroLocus I", "start": [420, 1], "end": [423, 79], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isClosed_iff_zeroLocus_radical_ideal", "code": "theorem isClosed_iff_zeroLocus_radical_ideal (Z : Set (PrimeSpectrum R)) :\n    IsClosed Z \u2194 \u2203 I : Ideal R, I.IsRadical \u2227 Z = zeroLocus I", "start": [426, 1], "end": [430, 15], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isClosed_zeroLocus", "code": "theorem isClosed_zeroLocus (s : Set R) : IsClosed (zeroLocus s)", "start": [433, 1], "end": [435, 17], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.zeroLocus_vanishingIdeal_eq_closure", "code": "theorem zeroLocus_vanishingIdeal_eq_closure (t : Set (PrimeSpectrum R)) :\n    zeroLocus (vanishingIdeal t : Set R) = closure t", "start": [438, 1], "end": [444, 60], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.vanishingIdeal_closure", "code": "theorem vanishingIdeal_closure (t : Set (PrimeSpectrum R)) :\n    vanishingIdeal (closure t) = vanishingIdeal t", "start": [447, 1], "end": [449, 62], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.closure_singleton", "code": "theorem closure_singleton (x) : closure ({x} : Set (PrimeSpectrum R)) = zeroLocus x.asIdeal", "start": [452, 1], "end": [453, 71], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isClosed_singleton_iff_isMaximal", "code": "theorem isClosed_singleton_iff_isMaximal (x : PrimeSpectrum R) :\n    IsClosed ({x} : Set (PrimeSpectrum R)) \u2194 x.asIdeal.IsMaximal", "start": [456, 1], "end": [463, 70], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isRadical_vanishingIdeal", "code": "theorem isRadical_vanishingIdeal (s : Set (PrimeSpectrum R)) : (vanishingIdeal s).IsRadical", "start": [466, 1], "end": [469, 32], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.vanishingIdeal_anti_mono_iff", "code": "theorem vanishingIdeal_anti_mono_iff {s t : Set (PrimeSpectrum R)} (ht : IsClosed t) :\n    s \u2286 t \u2194 vanishingIdeal t \u2264 vanishingIdeal s", "start": [472, 1], "end": [476, 89], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.vanishingIdeal_strict_anti_mono_iff", "code": "theorem vanishingIdeal_strict_anti_mono_iff {s t : Set (PrimeSpectrum R)} (hs : IsClosed s)\n    (ht : IsClosed t) : s \u2282 t \u2194 vanishingIdeal t < vanishingIdeal s", "start": [479, 1], "end": [482, 22], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.closedsEmbedding", "code": "def closedsEmbedding (R : Type*) [CommRing R] :\n    (TopologicalSpace.Closeds <| PrimeSpectrum R)\u1d52\u1d48 \u21aao Ideal R :=\n  OrderEmbedding.ofMapLEIff (fun s => vanishingIdeal <| OrderDual.ofDual s) fun s _ =>\n    (vanishingIdeal_anti_mono_iff s.2).symm", "start": [485, 1], "end": [489, 44], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.t1Space_iff_isField", "code": "theorem t1Space_iff_isField [IsDomain R] : T1Space (PrimeSpectrum R) \u2194 IsField R", "start": [492, 1], "end": [506, 82], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isIrreducible_zeroLocus_iff_of_radical", "code": "theorem isIrreducible_zeroLocus_iff_of_radical (I : Ideal R) (hI : I.IsRadical) :\n    IsIrreducible (zeroLocus (I : Set R)) \u2194 I.IsPrime", "start": [511, 1], "end": [533, 81], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isIrreducible_zeroLocus_iff", "code": "theorem isIrreducible_zeroLocus_iff (I : Ideal R) :\n    IsIrreducible (zeroLocus (I : Set R)) \u2194 I.radical.IsPrime", "start": [536, 1], "end": [538, 85], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isIrreducible_iff_vanishingIdeal_isPrime", "code": "theorem isIrreducible_iff_vanishingIdeal_isPrime {s : Set (PrimeSpectrum R)} :\n    IsIrreducible s \u2194 (vanishingIdeal s).IsPrime", "start": [541, 1], "end": [544, 75], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.irreducibleSpace", "code": "instance irreducibleSpace [IsDomain R] : IrreducibleSpace (PrimeSpectrum R) := by\n  rw [irreducibleSpace_def, Set.top_eq_univ, \u2190 zeroLocus_bot, isIrreducible_zeroLocus_iff]\n  simpa using Ideal.bot_prime", "start": [547, 1], "end": [549, 30], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.quasiSober", "code": "instance quasiSober : QuasiSober (PrimeSpectrum R) :=\n  \u27e8fun {S} h\u2081 h\u2082 =>\n    \u27e8\u27e8_, isIrreducible_iff_vanishingIdeal_isPrime.1 h\u2081\u27e9, by\n      rw [IsGenericPoint, closure_singleton, zeroLocus_vanishingIdeal_eq_closure, h\u2082.closure_eq]\u27e9\u27e9", "start": [551, 1], "end": [554, 99], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.compactSpace", "code": "instance compactSpace : CompactSpace (PrimeSpectrum R) := by\n  refine compactSpace_of_finite_subfamily_closed fun S S_closed S_empty \u21a6 ?_\n  choose I hI using fun i \u21a6 (isClosed_iff_zeroLocus_ideal (S i)).mp (S_closed i)\n  simp_rw [hI, \u2190 zeroLocus_iSup, zeroLocus_empty_iff_eq_top, \u2190 top_le_iff] at S_empty \u22a2\n  exact Ideal.isCompactElement_top.exists_finset_of_le_iSup _ _ S_empty", "start": [556, 1], "end": [561, 72], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.preimage_comap_zeroLocus_aux", "code": "theorem preimage_comap_zeroLocus_aux (f : R \u2192+* S) (s : Set R) :\n    (fun y => \u27e8Ideal.comap f y.asIdeal, inferInstance\u27e9 : PrimeSpectrum S \u2192 PrimeSpectrum R) \u207b\u00b9'\n        zeroLocus s =\n      zeroLocus (f '' s)", "start": [567, 1], "end": [572, 100], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.comap", "code": "def comap (f : R \u2192+* S) : C(PrimeSpectrum S, PrimeSpectrum R) where\n  toFun y := \u27e8Ideal.comap f y.asIdeal, inferInstance\u27e9\n  continuous_toFun := by\n    simp only [continuous_iff_isClosed, isClosed_iff_zeroLocus]\n    rintro _ \u27e8s, rfl\u27e9\n    exact \u27e8_, preimage_comap_zeroLocus_aux f s\u27e9", "start": [575, 1], "end": [582, 48], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.comap_asIdeal", "code": "@[simp]\ntheorem comap_asIdeal (y : PrimeSpectrum S) : (comap f y).asIdeal = Ideal.comap f y.asIdeal", "start": [587, 1], "end": [589, 6], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.comap_id", "code": "@[simp]\ntheorem comap_id : comap (RingHom.id R) = ContinuousMap.id _", "start": [592, 1], "end": [595, 6], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.comap_comp", "code": "@[simp]\ntheorem comap_comp (f : R \u2192+* S) (g : S \u2192+* S') : comap (g.comp f) = (comap f).comp (comap g)", "start": [598, 1], "end": [600, 6], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.comap_comp_apply", "code": "theorem comap_comp_apply (f : R \u2192+* S) (g : S \u2192+* S') (x : PrimeSpectrum S') :\n    PrimeSpectrum.comap (g.comp f) x = (PrimeSpectrum.comap f) (PrimeSpectrum.comap g x)", "start": [603, 1], "end": [605, 6], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.preimage_comap_zeroLocus", "code": "@[simp]\ntheorem preimage_comap_zeroLocus (s : Set R) : comap f \u207b\u00b9' zeroLocus s = zeroLocus (f '' s)", "start": [608, 1], "end": [610, 35], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.comap_injective_of_surjective", "code": "theorem comap_injective_of_surjective (f : R \u2192+* S) (hf : Function.Surjective f) :\n    Function.Injective (comap f)", "start": [613, 1], "end": [617, 87], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.comap_singleton_isClosed_of_surjective", "code": "theorem comap_singleton_isClosed_of_surjective (f : R \u2192+* S) (hf : Function.Surjective f)\n    (x : PrimeSpectrum S) (hx : IsClosed ({x} : Set (PrimeSpectrum S))) :\n    IsClosed ({comap f x} : Set (PrimeSpectrum R))", "start": [620, 1], "end": [624, 84], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.comap_singleton_isClosed_of_isIntegral", "code": "theorem comap_singleton_isClosed_of_isIntegral (f : R \u2192+* S) (hf : f.IsIntegral)\n    (x : PrimeSpectrum S) (hx : IsClosed ({x} : Set (PrimeSpectrum S))) :\n    IsClosed ({comap f x} : Set (PrimeSpectrum R))", "start": [627, 1], "end": [632, 49], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.localization_comap_inducing", "code": "theorem localization_comap_inducing [Algebra R S] (M : Submonoid R) [IsLocalization M S] :\n    Inducing (comap (algebraMap R S))", "start": [637, 1], "end": [654, 19], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.localization_comap_injective", "code": "theorem localization_comap_injective [Algebra R S] (M : Submonoid R) [IsLocalization M S] :\n    Function.Injective (comap (algebraMap R S))", "start": [657, 1], "end": [664, 10], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.localization_comap_embedding", "code": "theorem localization_comap_embedding [Algebra R S] (M : Submonoid R) [IsLocalization M S] :\n    Embedding (comap (algebraMap R S))", "start": [667, 1], "end": [669, 70], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.localization_comap_range", "code": "theorem localization_comap_range [Algebra R S] (M : Submonoid R) [IsLocalization M S] :\n    Set.range (comap (algebraMap R S)) = { p | Disjoint (M : Set R) p.asIdeal }", "start": [672, 1], "end": [682, 67], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.comap_inducing_of_surjective", "code": "theorem comap_inducing_of_surjective (hf : Surjective f) : Inducing (comap f) where", "start": [692, 1], "end": [704, 65], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.image_comap_zeroLocus_eq_zeroLocus_comap", "code": "theorem image_comap_zeroLocus_eq_zeroLocus_comap (hf : Surjective f) (I : Ideal S) :\n    comap f '' zeroLocus I = zeroLocus (I.comap f)", "start": [707, 1], "end": [723, 42], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.range_comap_of_surjective", "code": "theorem range_comap_of_surjective (hf : Surjective f) :\n    Set.range (comap f) = zeroLocus (ker f)", "start": [726, 1], "end": [730, 21], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isClosed_range_comap_of_surjective", "code": "theorem isClosed_range_comap_of_surjective (hf : Surjective f) :\n    IsClosed (Set.range (comap f))", "start": [733, 1], "end": [736, 29], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.closedEmbedding_comap_of_surjective", "code": "theorem closedEmbedding_comap_of_surjective (hf : Surjective f) : ClosedEmbedding (comap f)", "start": [739, 1], "end": [742, 64], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.basicOpen", "code": "def basicOpen (r : R) : TopologicalSpace.Opens (PrimeSpectrum R) where\n  carrier := { x | r \u2209 x.asIdeal }\n  is_open' := \u27e8{r}, Set.ext fun _ => Set.singleton_subset_iff.trans <| Classical.not_not.symm\u27e9", "start": [751, 1], "end": [754, 95], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.mem_basicOpen", "code": "@[simp]\ntheorem mem_basicOpen (f : R) (x : PrimeSpectrum R) : x \u2208 basicOpen f \u2194 f \u2209 x.asIdeal", "start": [757, 1], "end": [759, 10], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isOpen_basicOpen", "code": "theorem isOpen_basicOpen {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R))", "start": [762, 1], "end": [763, 23], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.basicOpen_eq_zeroLocus_compl", "code": "@[simp]\ntheorem basicOpen_eq_zeroLocus_compl (r : R) :\n    (basicOpen r : Set (PrimeSpectrum R)) = (zeroLocus {r})\u1d9c", "start": [766, 1], "end": [770, 30], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.basicOpen_one", "code": "@[simp]\ntheorem basicOpen_one : basicOpen (1 : R) = \u22a4", "start": [773, 1], "end": [775, 40], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.basicOpen_zero", "code": "@[simp]\ntheorem basicOpen_zero : basicOpen (0 : R) = \u22a5", "start": [778, 1], "end": [780, 40], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.basicOpen_le_basicOpen_iff", "code": "theorem basicOpen_le_basicOpen_iff (f g : R) :\n    basicOpen f \u2264 basicOpen g \u2194 f \u2208 (Ideal.span ({g} : Set R)).radical", "start": [783, 1], "end": [786, 70], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.basicOpen_mul", "code": "theorem basicOpen_mul (f g : R) : basicOpen (f * g) = basicOpen f \u2293 basicOpen g", "start": [789, 1], "end": [790, 66], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.basicOpen_mul_le_left", "code": "theorem basicOpen_mul_le_left (f g : R) : basicOpen (f * g) \u2264 basicOpen f", "start": [793, 1], "end": [795, 20], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.basicOpen_mul_le_right", "code": "theorem basicOpen_mul_le_right (f g : R) : basicOpen (f * g) \u2264 basicOpen g", "start": [798, 1], "end": [800, 21], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.basicOpen_pow", "code": "@[simp]\ntheorem basicOpen_pow (f : R) (n : \u2115) (hn : 0 < n) : basicOpen (f ^ n) = basicOpen f", "start": [803, 1], "end": [805, 78], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isTopologicalBasis_basic_opens", "code": "theorem isTopologicalBasis_basic_opens :\n    TopologicalSpace.IsTopologicalBasis\n      (Set.range fun r : R => (basicOpen r : Set (PrimeSpectrum R)))", "start": [808, 1], "end": [819, 65], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isBasis_basic_opens", "code": "theorem isBasis_basic_opens : TopologicalSpace.Opens.IsBasis (Set.range (@basicOpen R _))", "start": [822, 1], "end": [826, 6], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.basicOpen_eq_bot_iff", "code": "@[simp]\ntheorem basicOpen_eq_bot_iff (f : R) : basicOpen f = \u22a5 \u2194 IsNilpotent f", "start": [829, 1], "end": [834, 59], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.localization_away_comap_range", "code": "theorem localization_away_comap_range (S : Type v) [CommRing S] [Algebra R S] (r : R)\n    [IsLocalization.Away r S] : Set.range (comap (algebraMap R S)) = basicOpen r", "start": [837, 1], "end": [847, 39], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.localization_away_openEmbedding", "code": "theorem localization_away_openEmbedding (S : Type v) [CommRing S] [Algebra R S] (r : R)\n    [IsLocalization.Away r S] : OpenEmbedding (comap (algebraMap R S))", "start": [850, 1], "end": [855, 31], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.isCompact_basicOpen", "code": "theorem isCompact_basicOpen (f : R) : IsCompact (basicOpen f : Set (PrimeSpectrum R))", "start": [858, 1], "end": [860, 43], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.asIdeal_le_asIdeal", "code": "@[simp]\ntheorem asIdeal_le_asIdeal (x y : PrimeSpectrum R) : x.asIdeal \u2264 y.asIdeal \u2194 x \u2264 y", "start": [877, 1], "end": [879, 10], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.asIdeal_lt_asIdeal", "code": "@[simp]\ntheorem asIdeal_lt_asIdeal (x y : PrimeSpectrum R) : x.asIdeal < y.asIdeal \u2194 x < y", "start": [882, 1], "end": [884, 10], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.le_iff_mem_closure", "code": "theorem le_iff_mem_closure (x y : PrimeSpectrum R) :\n    x \u2264 y \u2194 y \u2208 closure ({x} : Set (PrimeSpectrum R))", "start": [887, 1], "end": [890, 54], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.le_iff_specializes", "code": "theorem le_iff_specializes (x y : PrimeSpectrum R) : x \u2264 y \u2194 x \u2933 y", "start": [893, 1], "end": [894, 66], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.nhdsOrderEmbedding", "code": "@[simps!]\ndef nhdsOrderEmbedding : PrimeSpectrum R \u21aao Filter (PrimeSpectrum R) :=\n  OrderEmbedding.ofMapLEIff nhds fun a b => (le_iff_specializes a b).symm", "start": [897, 1], "end": [900, 74], "kind": "commanddeclaration"}, {"full_name": "PrimeSpectrum.localizationMapOfSpecializes", "code": "def localizationMapOfSpecializes {x y : PrimeSpectrum R} (h : x \u2933 y) :\n    Localization.AtPrime y.asIdeal \u2192+* Localization.AtPrime x.asIdeal :=\n  @IsLocalization.lift _ _ _ _ _ _ _ _ Localization.isLocalization\n    (algebraMap R (Localization.AtPrime x.asIdeal))\n    (by\n      rintro \u27e8a, ha\u27e9\n      rw [\u2190 PrimeSpectrum.le_iff_specializes, \u2190 asIdeal_le_asIdeal, \u2190 SetLike.coe_subset_coe, \u2190\n        Set.compl_subset_compl] at h\n      exact (IsLocalization.map_units (Localization.AtPrime x.asIdeal)\n        \u27e8a, show a \u2208 x.asIdeal.primeCompl from h ha\u27e9 : _))", "start": [916, 1], "end": [927, 59], "kind": "commanddeclaration"}, {"full_name": "LocalRing.closedPoint", "code": "def closedPoint : PrimeSpectrum R :=\n  \u27e8maximalIdeal R, (maximalIdeal.isMaximal R).isPrime\u27e9", "start": [936, 1], "end": [938, 55], "kind": "commanddeclaration"}, {"full_name": "LocalRing.isLocalRingHom_iff_comap_closedPoint", "code": "theorem isLocalRingHom_iff_comap_closedPoint {S : Type v} [CommRing S] [LocalRing S] (f : R \u2192+* S) :\n    IsLocalRingHom f \u2194 PrimeSpectrum.comap f (closedPoint S) = closedPoint R", "start": [943, 1], "end": [948, 6], "kind": "commanddeclaration"}, {"full_name": "LocalRing.comap_closedPoint", "code": "@[simp]\ntheorem comap_closedPoint {S : Type v} [CommRing S] [LocalRing S] (f : R \u2192+* S) [IsLocalRingHom f] :\n    PrimeSpectrum.comap f (closedPoint S) = closedPoint R", "start": [951, 1], "end": [954, 60], "kind": "commanddeclaration"}, {"full_name": "LocalRing.specializes_closedPoint", "code": "theorem specializes_closedPoint (x : PrimeSpectrum R) : x \u2933 closedPoint R", "start": [957, 1], "end": [958, 78], "kind": "commanddeclaration"}, {"full_name": "LocalRing.closedPoint_mem_iff", "code": "theorem closedPoint_mem_iff (U : TopologicalSpace.Opens <| PrimeSpectrum R) :\n    closedPoint R \u2208 U \u2194 U = \u22a4", "start": [961, 1], "end": [967, 12], "kind": "commanddeclaration"}, {"full_name": "LocalRing.PrimeSpectrum.comap_residue", "code": "@[simp]\ntheorem PrimeSpectrum.comap_residue (x : PrimeSpectrum (ResidueField R)) :\n    PrimeSpectrum.comap (residue R) x = closedPoint R", "start": [970, 1], "end": [975, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/RingedSpace/Stalks.lean", "imports": ["Mathlib/Topology/Sheaves/Stalks.lean", "Mathlib/CategoryTheory/Limits/Final.lean", "Mathlib/Geometry/RingedSpace/PresheafedSpace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicGeometry.PresheafedSpace.stalk", "code": "abbrev stalk (X : PresheafedSpace C) (x : X) : C :=\n  X.presheaf.stalk x", "start": [40, 1], "end": [43, 21], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.stalkMap", "code": "def stalkMap {X Y : PresheafedSpace.{_, _, v} C} (\u03b1 : X \u27f6 Y) (x : X) :\n    Y.stalk (\u03b1.base x) \u27f6 X.stalk x :=\n  (stalkFunctor C (\u03b1.base x)).map \u03b1.c \u226b X.presheaf.stalkPushforward C \u03b1.base x", "start": [47, 1], "end": [51, 79], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.stalkMap_germ", "code": "@[elementwise, reassoc]\ntheorem stalkMap_germ {X Y : PresheafedSpace.{_, _, v} C} (\u03b1 : X \u27f6 Y) (U : Opens Y)\n    (x : (Opens.map \u03b1.base).obj U) :\n    Y.presheaf.germ \u27e8\u03b1.base x.1, x.2\u27e9 \u226b stalkMap \u03b1 \u2191x = \u03b1.c.app (op U) \u226b X.presheaf.germ x", "start": [55, 1], "end": [59, 68], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.stalkMap_germ'", "code": "@[simp, elementwise, reassoc]\ntheorem stalkMap_germ' {X Y : PresheafedSpace.{_, _, v} C}\n    (\u03b1 : X \u27f6 Y) (U : Opens Y) (x : X) (hx : \u03b1.base x \u2208 U) :\n    Y.presheaf.germ \u27e8\u03b1.base x, hx\u27e9 \u226b stalkMap \u03b1 x = \u03b1.c.app (op U) \u226b\n      X.presheaf.germ (U := (Opens.map \u03b1.base).obj U) \u27e8x, hx\u27e9", "start": [63, 1], "end": [68, 44], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.restrictStalkIso", "code": "def restrictStalkIso {U : TopCat} (X : PresheafedSpace.{_, _, v} C) {f : U \u27f6 (X : TopCat.{v})}\n    (h : OpenEmbedding f) (x : U) : (X.restrict h).stalk x \u2245 X.stalk (f x) :=\n  haveI := initial_of_adjunction (h.isOpenMap.adjunctionNhds x)\n  Final.colimitIso (h.isOpenMap.functorNhds x).op ((OpenNhds.inclusion (f x)).op \u22d9 X.presheaf)", "start": [72, 1], "end": [78, 95], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.restrictStalkIso_hom_eq_germ", "code": "@[elementwise, reassoc]\ntheorem restrictStalkIso_hom_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U \u27f6 (X : TopCat.{v})} (h : OpenEmbedding f) (V : Opens U) (x : U) (hx : x \u2208 V) :\n    (X.restrict h).presheaf.germ \u27e8x, hx\u27e9 \u226b (restrictStalkIso X h x).hom =\n    X.presheaf.germ \u27e8f x, show f x \u2208 h.isOpenMap.functor.obj V from \u27e8x, hx, rfl\u27e9\u27e9", "start": [86, 1], "end": [92, 17], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.restrictStalkIso_inv_eq_germ", "code": "@[simp, elementwise, reassoc]\ntheorem restrictStalkIso_inv_eq_germ {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U \u27f6 (X : TopCat.{v})} (h : OpenEmbedding f) (V : Opens U) (x : U) (hx : x \u2208 V) :\n    X.presheaf.germ \u27e8f x, show f x \u2208 h.isOpenMap.functor.obj V from \u27e8x, hx, rfl\u27e9\u27e9 \u226b\n        (restrictStalkIso X h x).inv =\n      (X.restrict h).presheaf.germ \u27e8x, hx\u27e9", "start": [98, 1], "end": [104, 91], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.restrictStalkIso_inv_eq_ofRestrict", "code": "theorem restrictStalkIso_inv_eq_ofRestrict {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U \u27f6 (X : TopCat.{v})} (h : OpenEmbedding f) (x : U) :\n    (X.restrictStalkIso h x).inv = stalkMap (X.ofRestrict h) x", "start": [108, 1], "end": [121, 75], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.ofRestrict_stalkMap_isIso", "code": "instance ofRestrict_stalkMap_isIso {U : TopCat} (X : PresheafedSpace.{_, _, v} C)\n    {f : U \u27f6 (X : TopCat.{v})} (h : OpenEmbedding f) (x : U) :\n    IsIso (stalkMap (X.ofRestrict h) x) := by\n  rw [\u2190 restrictStalkIso_inv_eq_ofRestrict]; infer_instance", "start": [125, 1], "end": [128, 60], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.stalkMap.id", "code": "@[simp]\ntheorem id (X : PresheafedSpace.{_, _, v} C) (x : X) :\n    stalkMap (\ud835\udfd9 X) x = \ud835\udfd9 (X.stalk x)", "start": [136, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.stalkMap.comp", "code": "@[simp]\ntheorem comp {X Y Z : PresheafedSpace.{_, _, v} C} (\u03b1 : X \u27f6 Y) (\u03b2 : Y \u27f6 Z) (x : X) :\n    stalkMap (\u03b1 \u226b \u03b2) x =\n      (stalkMap \u03b2 (\u03b1.base x) : Z.stalk (\u03b2.base (\u03b1.base x)) \u27f6 Y.stalk (\u03b1.base x)) \u226b\n        (stalkMap \u03b1 x : Y.stalk (\u03b1.base x) \u27f6 X.stalk x)", "start": [149, 1], "end": [162, 25], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.stalkMap.congr", "code": "theorem congr {X Y : PresheafedSpace.{_, _, v} C} (\u03b1 \u03b2 : X \u27f6 Y)\n    (h\u2081 : \u03b1 = \u03b2) (x x' : X) (h\u2082 : x = x') :\n    stalkMap \u03b1 x \u226b eqToHom (show X.stalk x = X.stalk x' by rw [h\u2082]) =\n      eqToHom (show Y.stalk (\u03b1.base x) = Y.stalk (\u03b2.base x') by rw [h\u2081, h\u2082]) \u226b stalkMap \u03b2 x'", "start": [166, 1], "end": [177, 7], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.stalkMap.congr_hom", "code": "theorem congr_hom {X Y : PresheafedSpace.{_, _, v} C} (\u03b1 \u03b2 : X \u27f6 Y) (h : \u03b1 = \u03b2) (x : X) :\n    stalkMap \u03b1 x =\n      eqToHom (show Y.stalk (\u03b1.base x) = Y.stalk (\u03b2.base x) by rw [h]) \u226b stalkMap \u03b2 x", "start": [181, 1], "end": [184, 73], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.stalkMap.congr_point", "code": "theorem congr_point {X Y : PresheafedSpace.{_, _, v} C}\n    (\u03b1 : X \u27f6 Y) (x x' : X) (h : x = x') :\n    stalkMap \u03b1 x \u226b eqToHom (show X.stalk x = X.stalk x' by rw [h]) =\n      eqToHom (show Y.stalk (\u03b1.base x) = Y.stalk (\u03b1.base x') by rw [h]) \u226b stalkMap \u03b1 x'", "start": [188, 1], "end": [192, 40], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.stalkMap.isIso", "code": "instance isIso {X Y : PresheafedSpace.{_, _, v} C} (\u03b1 : X \u27f6 Y) [IsIso \u03b1] (x : X) :\n    IsIso (stalkMap \u03b1 x) where\n  out := by\n    let \u03b2 : Y \u27f6 X := CategoryTheory.inv \u03b1\n    have h_eq : (\u03b1 \u226b \u03b2).base x = x := by rw [IsIso.hom_inv_id \u03b1, id_base, TopCat.id_app]\n    refine'\n      \u27e8eqToHom (show X.stalk x = X.stalk ((\u03b1 \u226b \u03b2).base x) by rw [h_eq]) \u226b\n          (stalkMap \u03b2 (\u03b1.base x) : _),\n        _, _\u27e9\n    \u00b7 rw [\u2190 Category.assoc, congr_point \u03b1 x ((\u03b1 \u226b \u03b2).base x) h_eq.symm, Category.assoc]\n      erw [\u2190 stalkMap.comp \u03b2 \u03b1 (\u03b1.base x)]\n      rw [congr_hom _ _ (IsIso.inv_hom_id \u03b1), stalkMap.id, eqToHom_trans_assoc, eqToHom_refl,\n        Category.id_comp]\n    \u00b7 rw [Category.assoc, \u2190 stalkMap.comp, congr_hom _ _ (IsIso.hom_inv_id \u03b1), stalkMap.id,\n        eqToHom_trans_assoc, eqToHom_refl, Category.id_comp]", "start": [196, 1], "end": [216, 61], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.stalkMap.stalkIso", "code": "def stalkIso {X Y : PresheafedSpace.{_, _, v} C} (\u03b1 : X \u2245 Y) (x : X) :\n    Y.stalk (\u03b1.hom.base x) \u2245 X.stalk x :=\n  asIso (stalkMap \u03b1.hom x)", "start": [220, 1], "end": [224, 27], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PresheafedSpace.stalkMap.stalkSpecializes_stalkMap", "code": "@[simp, reassoc, elementwise]\ntheorem stalkSpecializes_stalkMap {X Y : PresheafedSpace.{_, _, v} C}\n    (f : X \u27f6 Y) {x y : X} (h : x \u2933 y) :\n    Y.presheaf.stalkSpecializes (f.base.map_specializes h) \u226b stalkMap f x =\n      stalkMap f y \u226b X.presheaf.stalkSpecializes h", "start": [228, 1], "end": [246, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/RingedSpace/Basic.lean", "imports": ["Mathlib/Algebra/Category/Ring/Limits.lean", "Mathlib/Algebra/Category/Ring/FilteredColimits.lean", "Mathlib/Algebra/Category/Ring/Colimits.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Sheaves/Stalks.lean", "Mathlib/Geometry/RingedSpace/SheafedSpace.lean"], "premises": [{"full_name": "AlgebraicGeometry.RingedSpace", "code": "abbrev RingedSpace : TypeMax.{u+1, v+1} :=\n  SheafedSpace.{_, v, u} CommRingCat.{v}", "start": [38, 1], "end": [40, 41], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.RingedSpace.isUnit_res_of_isUnit_germ", "code": "theorem isUnit_res_of_isUnit_germ (U : Opens X) (f : X.presheaf.obj (op U)) (x : U)\n    (h : IsUnit (X.presheaf.germ x f)) :\n    \u2203 (V : Opens X) (i : V \u27f6 U) (_ : x.1 \u2208 V), IsUnit (X.presheaf.map i.op f)", "start": [54, 1], "end": [79, 38], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.RingedSpace.isUnit_of_isUnit_germ", "code": "theorem isUnit_of_isUnit_germ (U : Opens X) (f : X.presheaf.obj (op U))\n    (h : \u2200 x : U, IsUnit (X.presheaf.germ x f)) : IsUnit f", "start": [83, 1], "end": [126, 13], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.RingedSpace.basicOpen", "code": "def basicOpen {U : Opens X} (f : X.presheaf.obj (op U)) : Opens X where\n  carrier := Subtype.val '' { x : U | IsUnit (X.presheaf.germ x f) }\n  is_open' := by\n    rw [isOpen_iff_forall_mem_open]\n    rintro _ \u27e8x, hx, rfl\u27e9\n    obtain \u27e8V, i, hxV, hf\u27e9 := X.isUnit_res_of_isUnit_germ U f x hx\n    use V.1\n    refine' \u27e8_, V.2, hxV\u27e9\n    intro y hy\n    use (\u27e8y, i.le hy\u27e9 : U)\n    rw [Set.mem_setOf_eq]\n    constructor\n    \u00b7 convert RingHom.isUnit_map (X.presheaf.germ \u27e8y, hy\u27e9) hf\n      exact (X.presheaf.germ_res_apply i \u27e8y, hy\u27e9 f).symm\n    \u00b7 rfl", "start": [130, 1], "end": [148, 10], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.RingedSpace.mem_basicOpen", "code": "@[simp]\ntheorem mem_basicOpen {U : Opens X} (f : X.presheaf.obj (op U)) (x : U) :\n    \u2191x \u2208 X.basicOpen f \u2194 IsUnit (X.presheaf.germ x f)", "start": [152, 1], "end": [157, 31], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.RingedSpace.mem_top_basicOpen", "code": "@[simp]\ntheorem mem_top_basicOpen (f : X.presheaf.obj (op \u22a4)) (x : X) :\n    x \u2208 X.basicOpen f \u2194 IsUnit (X.presheaf.germ \u27e8x, show x \u2208 (\u22a4 : Opens X) by trivial\u27e9 f)", "start": [161, 1], "end": [164, 27], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.RingedSpace.basicOpen_le", "code": "theorem basicOpen_le {U : Opens X} (f : X.presheaf.obj (op U)) : X.basicOpen f \u2264 U", "start": [168, 1], "end": [169, 34], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.RingedSpace.isUnit_res_basicOpen", "code": "theorem isUnit_res_basicOpen {U : Opens X} (f : X.presheaf.obj (op U)) :\n    IsUnit (X.presheaf.map (@homOfLE (Opens X) _ _ _ (X.basicOpen_le f)).op f)", "start": [173, 1], "end": [179, 42], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.RingedSpace.basicOpen_res", "code": "@[simp]\ntheorem basicOpen_res {U V : (Opens X)\u1d52\u1d56} (i : U \u27f6 V) (f : X.presheaf.obj U) :\n    @basicOpen X (unop V) (X.presheaf.map i f) = unop V \u2293 @basicOpen X (unop U) f", "start": [183, 1], "end": [196, 13], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.RingedSpace.basicOpen_res_eq", "code": "@[simp (high)]\ntheorem basicOpen_res_eq {U V : (Opens X)\u1d52\u1d56} (i : U \u27f6 V) [IsIso i] (f : X.presheaf.obj U) :\n    @basicOpen X (unop V) (X.presheaf.map i f) = @RingedSpace.basicOpen X (unop U) f", "start": [204, 1], "end": [212, 23], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.RingedSpace.basicOpen_mul", "code": "@[simp]\ntheorem basicOpen_mul {U : Opens X} (f g : X.presheaf.obj (op U)) :\n    X.basicOpen (f * g) = X.basicOpen f \u2293 X.basicOpen g", "start": [216, 1], "end": [224, 32], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.RingedSpace.basicOpen_of_isUnit", "code": "theorem basicOpen_of_isUnit {U : Opens X} {f : X.presheaf.obj (op U)} (hf : IsUnit f) :\n    X.basicOpen f = U", "start": [228, 1], "end": [234, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/BoxIntegral/Partition/Filter.lean", "imports": ["Mathlib/Analysis/BoxIntegral/Partition/Split.lean", "Mathlib/Analysis/BoxIntegral/Partition/SubboxInduction.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "BoxIntegral.IntegrationParams", "code": "@[ext]\nstructure IntegrationParams : Type where\n  (bRiemann bHenstock bDistortion : Bool)", "start": [182, 1], "end": [200, 42], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.equivProd", "code": "def equivProd : IntegrationParams \u2243 Bool \u00d7 Bool\u1d52\u1d48 \u00d7 Bool\u1d52\u1d48 where\n  toFun l := \u27e8l.1, OrderDual.toDual l.2, OrderDual.toDual l.3\u27e9\n  invFun l := \u27e8l.1, OrderDual.ofDual l.2.1, OrderDual.ofDual l.2.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [207, 1], "end": [212, 21], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.isoProd", "code": "def isoProd : IntegrationParams \u2243o Bool \u00d7 Bool\u1d52\u1d48 \u00d7 Bool\u1d52\u1d48 :=\n  \u27e8equivProd, Iff.rfl\u27e9", "start": [218, 1], "end": [220, 23], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.Riemann", "code": "def Riemann : IntegrationParams where\n  bRiemann := true\n  bHenstock := true\n  bDistortion := false", "start": [239, 1], "end": [246, 23], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.Henstock", "code": "def Henstock : IntegrationParams :=\n  \u27e8false, true, false\u27e9", "start": [250, 1], "end": [254, 23], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.McShane", "code": "def McShane : IntegrationParams :=\n  \u27e8false, false, false\u27e9", "start": [258, 1], "end": [263, 24], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.GP", "code": "def GP : IntegrationParams := \u22a5", "start": [267, 1], "end": [271, 32], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.henstock_le_riemann", "code": "theorem henstock_le_riemann : Henstock \u2264 Riemann", "start": [275, 1], "end": [275, 63], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.henstock_le_mcShane", "code": "theorem henstock_le_mcShane : Henstock \u2264 McShane", "start": [279, 1], "end": [279, 63], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.gp_le", "code": "theorem gp_le : GP \u2264 l", "start": [283, 1], "end": [284, 9], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.MemBaseSet", "code": "structure MemBaseSet (l : IntegrationParams) (I : Box \u03b9) (c : \u211d\u22650) (r : (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d))\n    (\u03c0 : TaggedPrepartition I) : Prop where\n  protected isSubordinate : \u03c0.IsSubordinate r\n  protected isHenstock : l.bHenstock \u2192 \u03c0.IsHenstock\n  protected distortion_le : l.bDistortion \u2192 \u03c0.distortion \u2264 c\n  protected exists_compl : l.bDistortion \u2192 \u2203 \u03c0' : Prepartition I,\n    \u03c0'.iUnion = \u2191I \\ \u03c0.iUnion \u2227 \u03c0'.distortion \u2264 c", "start": [288, 1], "end": [309, 50], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.RCond", "code": "def RCond {\u03b9 : Type*} (l : IntegrationParams) (r : (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d)) : Prop :=\n  l.bRiemann \u2192 \u2200 x, r x = r 0", "start": [312, 1], "end": [314, 30], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.toFilterDistortion", "code": "def toFilterDistortion (l : IntegrationParams) (I : Box \u03b9) (c : \u211d\u22650) :\n    Filter (TaggedPrepartition I) :=\n  \u2a05 (r : (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d)) (_ : l.RCond r), \ud835\udcdf { \u03c0 | l.MemBaseSet I c r \u03c0 }", "start": [317, 1], "end": [322, 80], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.toFilter", "code": "def toFilter (l : IntegrationParams) (I : Box \u03b9) : Filter (TaggedPrepartition I) :=\n  \u2a06 c : \u211d\u22650, l.toFilterDistortion I c", "start": [325, 1], "end": [329, 38], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.toFilterDistortioniUnion", "code": "def toFilterDistortioniUnion (l : IntegrationParams) (I : Box \u03b9) (c : \u211d\u22650) (\u03c0\u2080 : Prepartition I) :=\n  l.toFilterDistortion I c \u2293 \ud835\udcdf { \u03c0 | \u03c0.iUnion = \u03c0\u2080.iUnion }", "start": [332, 1], "end": [336, 60], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.toFilteriUnion", "code": "def toFilteriUnion (l : IntegrationParams) (I : Box \u03b9) (\u03c0\u2080 : Prepartition I) :=\n  \u2a06 c : \u211d\u22650, l.toFilterDistortioniUnion I c \u03c0\u2080", "start": [339, 1], "end": [343, 47], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.rCond_of_bRiemann_eq_false", "code": "theorem rCond_of_bRiemann_eq_false {\u03b9} (l : IntegrationParams) (hl : l.bRiemann = false)\n    {r : (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d)} : l.RCond r", "start": [346, 1], "end": [348, 19], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.toFilter_inf_iUnion_eq", "code": "theorem toFilter_inf_iUnion_eq (l : IntegrationParams) (I : Box \u03b9) (\u03c0\u2080 : Prepartition I) :\n    l.toFilter I \u2293 \ud835\udcdf { \u03c0 | \u03c0.iUnion = \u03c0\u2080.iUnion } = l.toFilteriUnion I \u03c0\u2080", "start": [352, 1], "end": [354, 32], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.MemBaseSet.mono'", "code": "theorem MemBaseSet.mono' (I : Box \u03b9) (h : l\u2081 \u2264 l\u2082) (hc : c\u2081 \u2264 c\u2082) {\u03c0 : TaggedPrepartition I}\n    (hr : \u2200 J \u2208 \u03c0, r\u2081 (\u03c0.tag J) \u2264 r\u2082 (\u03c0.tag J)) (h\u03c0 : l\u2081.MemBaseSet I c\u2081 r\u2081 \u03c0) :\n    l\u2082.MemBaseSet I c\u2082 r\u2082 \u03c0", "start": [357, 1], "end": [362, 84], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.MemBaseSet.mono", "code": "@[mono]\ntheorem MemBaseSet.mono (I : Box \u03b9) (h : l\u2081 \u2264 l\u2082) (hc : c\u2081 \u2264 c\u2082) {\u03c0 : TaggedPrepartition I}\n    (hr : \u2200 x \u2208 Box.Icc I, r\u2081 x \u2264 r\u2082 x) (h\u03c0 : l\u2081.MemBaseSet I c\u2081 r\u2081 \u03c0) : l\u2082.MemBaseSet I c\u2082 r\u2082 \u03c0", "start": [365, 1], "end": [368, 53], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.MemBaseSet.exists_common_compl", "code": "theorem MemBaseSet.exists_common_compl (h\u2081 : l.MemBaseSet I c\u2081 r\u2081 \u03c0\u2081) (h\u2082 : l.MemBaseSet I c\u2082 r\u2082 \u03c0\u2082)\n    (hU : \u03c0\u2081.iUnion = \u03c0\u2082.iUnion) :\n    \u2203 \u03c0 : Prepartition I, \u03c0.iUnion = \u2191I \\ \u03c0\u2081.iUnion \u2227\n      (l.bDistortion \u2192 \u03c0.distortion \u2264 c\u2081) \u2227 (l.bDistortion \u2192 \u03c0.distortion \u2264 c\u2082)", "start": [371, 1], "end": [382, 50], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.MemBaseSet.unionComplToSubordinate", "code": "protected theorem MemBaseSet.unionComplToSubordinate (h\u03c0\u2081 : l.MemBaseSet I c r\u2081 \u03c0\u2081)\n    (hle : \u2200 x \u2208 Box.Icc I, r\u2082 x \u2264 r\u2081 x) {\u03c0\u2082 : Prepartition I} (hU : \u03c0\u2082.iUnion = \u2191I \\ \u03c0\u2081.iUnion)\n    (hc : l.bDistortion \u2192 \u03c0\u2082.distortion \u2264 c) :\n    l.MemBaseSet I c r\u2081 (\u03c0\u2081.unionComplToSubordinate \u03c0\u2082 hU r\u2082)", "start": [385, 1], "end": [392, 27], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.MemBaseSet.filter", "code": "protected theorem MemBaseSet.filter (h\u03c0 : l.MemBaseSet I c r \u03c0) (p : Box \u03b9 \u2192 Prop) :\n    l.MemBaseSet I c r (\u03c0.filter p)", "start": [395, 1], "end": [415, 15], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.biUnionTagged_memBaseSet", "code": "theorem biUnionTagged_memBaseSet {\u03c0 : Prepartition I} {\u03c0i : \u2200 J, TaggedPrepartition J}\n    (h : \u2200 J \u2208 \u03c0, l.MemBaseSet J c r (\u03c0i J)) (hp : \u2200 J \u2208 \u03c0, (\u03c0i J).IsPartition)\n    (hc : l.bDistortion \u2192 \u03c0.compl.distortion \u2264 c) : l.MemBaseSet I c r (\u03c0.biUnionTagged \u03c0i)", "start": [418, 1], "end": [428, 8], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.RCond.mono", "code": "@[mono]\ntheorem RCond.mono {\u03b9 : Type*} {r : (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d)} (h : l\u2081 \u2264 l\u2082) (hr : l\u2082.RCond r) :\n    l\u2081.RCond r", "start": [431, 1], "end": [434, 37], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.RCond.min", "code": "nonrec theorem RCond.min {\u03b9 : Type*} {r\u2081 r\u2082 : (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d)} (h\u2081 : l.RCond r\u2081)\n    (h\u2082 : l.RCond r\u2082) : l.RCond fun x => min (r\u2081 x) (r\u2082 x)", "start": [437, 1], "end": [439, 49], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.toFilterDistortion_mono", "code": "@[mono]\ntheorem toFilterDistortion_mono (I : Box \u03b9) (h : l\u2081 \u2264 l\u2082) (hc : c\u2081 \u2264 c\u2082) :\n    l\u2081.toFilterDistortion I c\u2081 \u2264 l\u2082.toFilterDistortion I c\u2082", "start": [442, 1], "end": [447, 86], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.toFilter_mono", "code": "@[mono]\ntheorem toFilter_mono (I : Box \u03b9) {l\u2081 l\u2082 : IntegrationParams} (h : l\u2081 \u2264 l\u2082) :\n    l\u2081.toFilter I \u2264 l\u2082.toFilter I", "start": [450, 1], "end": [453, 56], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.toFilteriUnion_mono", "code": "@[mono]\ntheorem toFilteriUnion_mono (I : Box \u03b9) {l\u2081 l\u2082 : IntegrationParams} (h : l\u2081 \u2264 l\u2082)\n    (\u03c0\u2080 : Prepartition I) : l\u2081.toFilteriUnion I \u03c0\u2080 \u2264 l\u2082.toFilteriUnion I \u03c0\u2080", "start": [456, 1], "end": [459, 78], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.toFilteriUnion_congr", "code": "theorem toFilteriUnion_congr (I : Box \u03b9) (l : IntegrationParams) {\u03c0\u2081 \u03c0\u2082 : Prepartition I}\n    (h : \u03c0\u2081.iUnion = \u03c0\u2082.iUnion) : l.toFilteriUnion I \u03c0\u2081 = l.toFilteriUnion I \u03c0\u2082", "start": [462, 1], "end": [464, 58], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.hasBasis_toFilterDistortion", "code": "theorem hasBasis_toFilterDistortion (l : IntegrationParams) (I : Box \u03b9) (c : \u211d\u22650) :\n    (l.toFilterDistortion I c).HasBasis l.RCond fun r => { \u03c0 | l.MemBaseSet I c r \u03c0 }", "start": [467, 1], "end": [473, 62], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.hasBasis_toFilterDistortioniUnion", "code": "theorem hasBasis_toFilterDistortioniUnion (l : IntegrationParams) (I : Box \u03b9) (c : \u211d\u22650)\n    (\u03c0\u2080 : Prepartition I) :\n    (l.toFilterDistortioniUnion I c \u03c0\u2080).HasBasis l.RCond fun r =>\n      { \u03c0 | l.MemBaseSet I c r \u03c0 \u2227 \u03c0.iUnion = \u03c0\u2080.iUnion }", "start": [476, 1], "end": [480, 54], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.hasBasis_toFilteriUnion", "code": "theorem hasBasis_toFilteriUnion (l : IntegrationParams) (I : Box \u03b9) (\u03c0\u2080 : Prepartition I) :\n    (l.toFilteriUnion I \u03c0\u2080).HasBasis (fun r : \u211d\u22650 \u2192 (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d) => \u2200 c, l.RCond (r c))\n      fun r => { \u03c0 | \u2203 c, l.MemBaseSet I c (r c) \u03c0 \u2227 \u03c0.iUnion = \u03c0\u2080.iUnion }", "start": [483, 1], "end": [487, 64], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.hasBasis_toFilteriUnion_top", "code": "theorem hasBasis_toFilteriUnion_top (l : IntegrationParams) (I : Box \u03b9) :\n    (l.toFilteriUnion I \u22a4).HasBasis (fun r : \u211d\u22650 \u2192 (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d) => \u2200 c, l.RCond (r c))\n      fun r => { \u03c0 | \u2203 c, l.MemBaseSet I c (r c) \u03c0 \u2227 \u03c0.IsPartition }", "start": [490, 1], "end": [494, 34], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.hasBasis_toFilter", "code": "theorem hasBasis_toFilter (l : IntegrationParams) (I : Box \u03b9) :\n    (l.toFilter I).HasBasis (fun r : \u211d\u22650 \u2192 (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d) => \u2200 c, l.RCond (r c))\n      fun r => { \u03c0 | \u2203 c, l.MemBaseSet I c (r c) \u03c0 }", "start": [497, 1], "end": [500, 82], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.tendsto_embedBox_toFilteriUnion_top", "code": "theorem tendsto_embedBox_toFilteriUnion_top (l : IntegrationParams) (h : I \u2264 J) :\n    Tendsto (TaggedPrepartition.embedBox I J h) (l.toFilteriUnion I \u22a4)\n      (l.toFilteriUnion J (Prepartition.single J I h))", "start": [503, 1], "end": [517, 57], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.exists_memBaseSet_le_iUnion_eq", "code": "theorem exists_memBaseSet_le_iUnion_eq (l : IntegrationParams) (\u03c0\u2080 : Prepartition I)\n    (hc\u2081 : \u03c0\u2080.distortion \u2264 c) (hc\u2082 : \u03c0\u2080.compl.distortion \u2264 c) (r : (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d)) :\n    \u2203 \u03c0, l.MemBaseSet I c r \u03c0 \u2227 \u03c0.toPrepartition \u2264 \u03c0\u2080 \u2227 \u03c0.iUnion = \u03c0\u2080.iUnion", "start": [520, 1], "end": [525, 68], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.exists_memBaseSet_isPartition", "code": "theorem exists_memBaseSet_isPartition (l : IntegrationParams) (I : Box \u03b9) (hc : I.distortion \u2264 c)\n    (r : (\u03b9 \u2192 \u211d) \u2192 Ioi (0 : \u211d)) : \u2203 \u03c0, l.MemBaseSet I c r \u03c0 \u2227 \u03c0.IsPartition", "start": [528, 1], "end": [532, 86], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.toFilterDistortioniUnion_neBot", "code": "theorem toFilterDistortioniUnion_neBot (l : IntegrationParams) (I : Box \u03b9) (\u03c0\u2080 : Prepartition I)\n    (hc\u2081 : \u03c0\u2080.distortion \u2264 c) (hc\u2082 : \u03c0\u2080.compl.distortion \u2264 c) :\n    (l.toFilterDistortioniUnion I c \u03c0\u2080).NeBot", "start": [535, 1], "end": [539, 96], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.toFilterDistortioniUnion_neBot'", "code": "instance toFilterDistortioniUnion_neBot' (l : IntegrationParams) (I : Box \u03b9) (\u03c0\u2080 : Prepartition I) :\n    (l.toFilterDistortioniUnion I (max \u03c0\u2080.distortion \u03c0\u2080.compl.distortion) \u03c0\u2080).NeBot :=\n  l.toFilterDistortioniUnion_neBot I \u03c0\u2080 (le_max_left _ _) (le_max_right _ _)", "start": [542, 1], "end": [544, 77], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.toFilterDistortion_neBot", "code": "instance toFilterDistortion_neBot (l : IntegrationParams) (I : Box \u03b9) :\n    (l.toFilterDistortion I I.distortion).NeBot := by\n  simpa using (l.toFilterDistortioniUnion_neBot' I \u22a4).mono inf_le_left", "start": [547, 1], "end": [549, 71], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.toFilter_neBot", "code": "instance toFilter_neBot (l : IntegrationParams) (I : Box \u03b9) : (l.toFilter I).NeBot :=\n  (l.toFilterDistortion_neBot I).mono <| le_iSup _ _", "start": [552, 1], "end": [553, 53], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.toFilteriUnion_neBot", "code": "instance toFilteriUnion_neBot (l : IntegrationParams) (I : Box \u03b9) (\u03c0\u2080 : Prepartition I) :\n    (l.toFilteriUnion I \u03c0\u2080).NeBot :=\n  (l.toFilterDistortioniUnion_neBot' I \u03c0\u2080).mono <|\n    le_iSup (fun c => l.toFilterDistortioniUnion I c \u03c0\u2080) _", "start": [556, 1], "end": [559, 59], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.IntegrationParams.eventually_isPartition", "code": "theorem eventually_isPartition (l : IntegrationParams) (I : Box \u03b9) :\n    \u2200\u1da0 \u03c0 in l.toFilteriUnion I \u22a4, TaggedPrepartition.IsPartition \u03c0", "start": [562, 1], "end": [567, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/BoxIntegral/Partition/Measure.lean", "imports": ["Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean", "Mathlib/Analysis/BoxIntegral/Partition/Additive.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "BoxIntegral.Box.measure_Icc_lt_top", "code": "theorem measure_Icc_lt_top (\u03bc : Measure (\u03b9 \u2192 \u211d)) [IsLocallyFiniteMeasure \u03bc] : \u03bc (Box.Icc I) < \u221e", "start": [45, 1], "end": [46, 71], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Box.measure_coe_lt_top", "code": "theorem measure_coe_lt_top (\u03bc : Measure (\u03b9 \u2192 \u211d)) [IsLocallyFiniteMeasure \u03bc] : \u03bc I < \u221e", "start": [49, 1], "end": [50, 69], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Box.measurableSet_coe", "code": "theorem measurableSet_coe : MeasurableSet (I : Set (\u03b9 \u2192 \u211d))", "start": [57, 1], "end": [59, 57], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Box.measurableSet_Icc", "code": "theorem measurableSet_Icc : MeasurableSet (Box.Icc I)", "start": [62, 1], "end": [63, 27], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Box.measurableSet_Ioo", "code": "theorem measurableSet_Ioo : MeasurableSet (Box.Ioo I)", "start": [66, 1], "end": [67, 58], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Box.coe_ae_eq_Icc", "code": "theorem coe_ae_eq_Icc : (I : Set (\u03b9 \u2192 \u211d)) =\u1d50[volume] Box.Icc I", "start": [74, 1], "end": [76, 38], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Box.Ioo_ae_eq_Icc", "code": "theorem Ioo_ae_eq_Icc : Box.Ioo I =\u1d50[volume] Box.Icc I", "start": [79, 1], "end": [80, 32], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Prepartition.measure_iUnion_toReal", "code": "theorem Prepartition.measure_iUnion_toReal [Finite \u03b9] {I : Box \u03b9} (\u03c0 : Prepartition I)\n    (\u03bc : Measure (\u03b9 \u2192 \u211d)) [IsLocallyFiniteMeasure \u03bc] :\n    (\u03bc \u03c0.iUnion).toReal = \u2211 J in \u03c0.boxes, (\u03bc J).toReal", "start": [85, 1], "end": [89, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.toBoxAdditive", "code": "@[simps]\ndef toBoxAdditive (\u03bc : Measure (\u03b9 \u2192 \u211d)) [IsLocallyFiniteMeasure \u03bc] : \u03b9 \u2192\u1d47\u1d43[\u22a4] \u211d where\n  toFun J := (\u03bc J).toReal\n  sum_partition_boxes' J _ \u03c0 h\u03c0 := by rw [\u2190 \u03c0.measure_iUnion_toReal, h\u03c0.iUnion_eq]", "start": [102, 1], "end": [107, 83], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Box.volume_apply", "code": "theorem volume_apply (I : Box \u03b9) :\n    (volume : Measure (\u03b9 \u2192 \u211d)).toBoxAdditive I = \u220f i, (I.upper i - I.lower i)", "start": [121, 1], "end": [123, 90], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Box.volume_apply'", "code": "@[simp]\ntheorem volume_apply' (I : Box \u03b9) :\n    ((volume : Measure (\u03b9 \u2192 \u211d)) I).toReal = \u220f i, (I.upper i - I.lower i)", "start": [126, 1], "end": [129, 61], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Box.volume_face_mul", "code": "theorem volume_face_mul {n} (i : Fin (n + 1)) (I : Box (Fin (n + 1))) :\n    (\u220f j, ((I.face i).upper j - (I.face i).lower j)) * (I.upper i - I.lower i) =\n      \u220f j, (I.upper j - I.lower j)", "start": [131, 1], "end": [134, 85], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.BoxAdditiveMap.volume", "code": "protected def volume {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] E :=\n  (volume : Measure (\u03b9 \u2192 \u211d)).toBoxAdditive.toSMul", "start": [141, 1], "end": [144, 50], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.BoxAdditiveMap.volume_apply", "code": "theorem volume_apply {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] (I : Box \u03b9) (x : E) :\n    BoxAdditiveMap.volume I x = (\u220f j, (I.upper j - I.lower j)) \u2022 x", "start": [147, 1], "end": [150, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Orientation.lean", "imports": ["Mathlib/LinearAlgebra/Determinant.lean", "Mathlib/LinearAlgebra/Ray.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Orientation", "code": "abbrev Orientation := Module.Ray R (AlternatingMap R M R \u03b9)", "start": [51, 1], "end": [53, 60], "kind": "commanddeclaration"}, {"full_name": "Module.Oriented", "code": "class Module.Oriented where\n  \n  positiveOrientation : Orientation R M \u03b9", "start": [56, 1], "end": [59, 42], "kind": "commanddeclaration"}, {"full_name": "Orientation.map", "code": "def Orientation.map (e : M \u2243\u2097[R] N) : Orientation R M \u03b9 \u2243 Orientation R N \u03b9 :=\n  Module.Ray.map <| AlternatingMap.domLCongr R R \u03b9 R e", "start": [66, 1], "end": [68, 55], "kind": "commanddeclaration"}, {"full_name": "Orientation.map_apply", "code": "@[simp]\ntheorem Orientation.map_apply (e : M \u2243\u2097[R] N) (v : AlternatingMap R M R \u03b9) (hv : v \u2260 0) :\n    Orientation.map \u03b9 e (rayOfNeZero _ v hv) =\n      rayOfNeZero _ (v.compLinearMap e.symm) (mt (v.compLinearEquiv_eq_zero_iff e.symm).mp hv)", "start": [71, 1], "end": [75, 6], "kind": "commanddeclaration"}, {"full_name": "Orientation.map_refl", "code": "@[simp]\ntheorem Orientation.map_refl : (Orientation.map \u03b9 <| LinearEquiv.refl R M) = Equiv.refl _", "start": [78, 1], "end": [80, 75], "kind": "commanddeclaration"}, {"full_name": "Orientation.map_symm", "code": "@[simp]\ntheorem Orientation.map_symm (e : M \u2243\u2097[R] N) :\n    (Orientation.map \u03b9 e).symm = Orientation.map \u03b9 e.symm", "start": [83, 1], "end": [85, 65], "kind": "commanddeclaration"}, {"full_name": "Orientation.reindex", "code": "def Orientation.reindex (e : \u03b9 \u2243 \u03b9') : Orientation R M \u03b9 \u2243 Orientation R M \u03b9' :=\n  Module.Ray.map <| AlternatingMap.domDomLcongr R e", "start": [92, 1], "end": [94, 52], "kind": "commanddeclaration"}, {"full_name": "Orientation.reindex_apply", "code": "@[simp]\ntheorem Orientation.reindex_apply (e : \u03b9 \u2243 \u03b9') (v : AlternatingMap R M R \u03b9) (hv : v \u2260 0) :\n    Orientation.reindex R M e (rayOfNeZero _ v hv) =\n      rayOfNeZero _ (v.domDomCongr e) (mt (v.domDomCongr_eq_zero_iff e).mp hv)", "start": [97, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "Orientation.reindex_refl", "code": "@[simp]\ntheorem Orientation.reindex_refl : (Orientation.reindex R M <| Equiv.refl \u03b9) = Equiv.refl _", "start": [104, 1], "end": [106, 82], "kind": "commanddeclaration"}, {"full_name": "Orientation.reindex_symm", "code": "@[simp]\ntheorem Orientation.reindex_symm (e : \u03b9 \u2243 \u03b9') :\n    (Orientation.reindex R M e).symm = Orientation.reindex R M e.symm", "start": [109, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "IsEmpty.oriented", "code": "instance (priority := 100) IsEmpty.oriented [Nontrivial R] [IsEmpty \u03b9] : Module.Oriented R M \u03b9 where\n  positiveOrientation :=\n    rayOfNeZero R (AlternatingMap.constLinearEquivOfIsEmpty 1) <|\n      AlternatingMap.constLinearEquivOfIsEmpty.injective.ne (by exact one_ne_zero)", "start": [117, 1], "end": [121, 83], "kind": "commanddeclaration"}, {"full_name": "Orientation.map_positiveOrientation_of_isEmpty", "code": "@[simp]\ntheorem Orientation.map_positiveOrientation_of_isEmpty [Nontrivial R] [IsEmpty \u03b9] (f : M \u2243\u2097[R] N) :\n    Orientation.map \u03b9 f positiveOrientation = positiveOrientation", "start": [124, 1], "end": [126, 73], "kind": "commanddeclaration"}, {"full_name": "Orientation.map_of_isEmpty", "code": "@[simp]\ntheorem Orientation.map_of_isEmpty [IsEmpty \u03b9] (x : Orientation R M \u03b9) (f : M \u2243\u2097[R] M) :\n    Orientation.map \u03b9 f x = x", "start": [129, 1], "end": [138, 63], "kind": "commanddeclaration"}, {"full_name": "Orientation.map_neg", "code": "@[simp]\nprotected theorem Orientation.map_neg {\u03b9 : Type*} (f : M \u2243\u2097[R] N) (x : Orientation R M \u03b9) :\n    Orientation.map \u03b9 f (-x) = -Orientation.map \u03b9 f x", "start": [149, 1], "end": [152, 25], "kind": "commanddeclaration"}, {"full_name": "Orientation.reindex_neg", "code": "@[simp]\nprotected theorem Orientation.reindex_neg {\u03b9 \u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') (x : Orientation R M \u03b9) :\n    Orientation.reindex R M e (-x) = -Orientation.reindex R M e x", "start": [155, 1], "end": [158, 25], "kind": "commanddeclaration"}, {"full_name": "Basis.map_orientation_eq_det_inv_smul", "code": "theorem map_orientation_eq_det_inv_smul [Finite \u03b9] (e : Basis \u03b9 R M) (x : Orientation R M \u03b9)\n    (f : M \u2243\u2097[R] M) : Orientation.map \u03b9 f x = (LinearEquiv.det f)\u207b\u00b9 \u2022 x", "start": [165, 1], "end": [177, 29], "kind": "commanddeclaration"}, {"full_name": "Basis.orientation", "code": "protected def orientation [Nontrivial R] (e : Basis \u03b9 R M) : Orientation R M \u03b9 :=\n  rayOfNeZero R _ e.det_ne_zero", "start": [182, 1], "end": [184, 32], "kind": "commanddeclaration"}, {"full_name": "Basis.orientation_map", "code": "theorem orientation_map [Nontrivial R] (e : Basis \u03b9 R M) (f : M \u2243\u2097[R] N) :\n    (e.map f).orientation = Orientation.map \u03b9 f e.orientation", "start": [187, 1], "end": [189, 69], "kind": "commanddeclaration"}, {"full_name": "Basis.orientation_reindex", "code": "theorem orientation_reindex [Nontrivial R] (e : Basis \u03b9 R M) (e\u03b9 : \u03b9 \u2243 \u03b9') :\n    (e.reindex e\u03b9).orientation = Orientation.reindex R M e\u03b9 e.orientation", "start": [192, 1], "end": [194, 77], "kind": "commanddeclaration"}, {"full_name": "Basis.orientation_unitsSMul", "code": "theorem orientation_unitsSMul [Nontrivial R] (e : Basis \u03b9 R M) (w : \u03b9 \u2192 Units R) :\n    (e.unitsSMul w).orientation = (\u220f i, w i)\u207b\u00b9 \u2022 e.orientation", "start": [197, 1], "end": [205, 20], "kind": "commanddeclaration"}, {"full_name": "Basis.orientation_isEmpty", "code": "@[simp]\ntheorem orientation_isEmpty [Nontrivial R] [IsEmpty \u03b9] (b : Basis \u03b9 R M) :\n    b.orientation = positiveOrientation", "start": [208, 1], "end": [213, 22], "kind": "commanddeclaration"}, {"full_name": "Orientation.eq_or_eq_neg_of_isEmpty", "code": "theorem eq_or_eq_neg_of_isEmpty [Nontrivial R] [IsEmpty \u03b9] (o : Orientation R M \u03b9) :\n    o = positiveOrientation \u2228 o = -positiveOrientation", "start": [230, 1], "end": [246, 81], "kind": "commanddeclaration"}, {"full_name": "Basis.orientation_eq_iff_det_pos", "code": "theorem orientation_eq_iff_det_pos (e\u2081 e\u2082 : Basis \u03b9 R M) :\n    e\u2081.orientation = e\u2082.orientation \u2194 0 < e\u2081.det e\u2082", "start": [255, 1], "end": [262, 95], "kind": "commanddeclaration"}, {"full_name": "Basis.orientation_eq_or_eq_neg", "code": "theorem orientation_eq_or_eq_neg (e : Basis \u03b9 R M) (x : Orientation R M \u03b9) :\n    x = e.orientation \u2228 x = -e.orientation", "start": [266, 1], "end": [273, 30], "kind": "commanddeclaration"}, {"full_name": "Basis.orientation_ne_iff_eq_neg", "code": "theorem orientation_ne_iff_eq_neg (e : Basis \u03b9 R M) (x : Orientation R M \u03b9) :\n    x \u2260 e.orientation \u2194 x = -e.orientation", "start": [276, 1], "end": [281, 58], "kind": "commanddeclaration"}, {"full_name": "Basis.orientation_comp_linearEquiv_eq_iff_det_pos", "code": "theorem orientation_comp_linearEquiv_eq_iff_det_pos (e : Basis \u03b9 R M) (f : M \u2243\u2097[R] M) :\n    (e.map f).orientation = e.orientation \u2194 0 < LinearMap.det (f : M \u2192\u2097[R] M)", "start": [284, 1], "end": [289, 25], "kind": "commanddeclaration"}, {"full_name": "Basis.orientation_comp_linearEquiv_eq_neg_iff_det_neg", "code": "theorem orientation_comp_linearEquiv_eq_neg_iff_det_neg (e : Basis \u03b9 R M) (f : M \u2243\u2097[R] M) :\n    (e.map f).orientation = -e.orientation \u2194 LinearMap.det (f : M \u2192\u2097[R] M) < 0", "start": [292, 1], "end": [297, 25], "kind": "commanddeclaration"}, {"full_name": "Basis.orientation_neg_single", "code": "@[simp]\ntheorem orientation_neg_single [Nontrivial R] (e : Basis \u03b9 R M) (i : \u03b9) :\n    (e.unitsSMul (Function.update 1 i (-1))).orientation = -e.orientation", "start": [300, 1], "end": [306, 7], "kind": "commanddeclaration"}, {"full_name": "Basis.adjustToOrientation", "code": "def adjustToOrientation [Nontrivial R] [Nonempty \u03b9] (e : Basis \u03b9 R M) (x : Orientation R M \u03b9) :\n    Basis \u03b9 R M :=\n  haveI := Classical.decEq (Orientation R M \u03b9)\n  if e.orientation = x then e else e.unitsSMul (Function.update 1 (Classical.arbitrary \u03b9) (-1))", "start": [309, 1], "end": [314, 96], "kind": "commanddeclaration"}, {"full_name": "Basis.orientation_adjustToOrientation", "code": "@[simp]\ntheorem orientation_adjustToOrientation [Nontrivial R] [Nonempty \u03b9] (e : Basis \u03b9 R M)\n    (x : Orientation R M \u03b9) : (e.adjustToOrientation x).orientation = x", "start": [317, 1], "end": [325, 12], "kind": "commanddeclaration"}, {"full_name": "Basis.adjustToOrientation_apply_eq_or_eq_neg", "code": "theorem adjustToOrientation_apply_eq_or_eq_neg [Nontrivial R] [Nonempty \u03b9] (e : Basis \u03b9 R M)\n    (x : Orientation R M \u03b9) (i : \u03b9) :\n    e.adjustToOrientation x i = e i \u2228 e.adjustToOrientation x i = -e i", "start": [328, 1], "end": [336, 75], "kind": "commanddeclaration"}, {"full_name": "Basis.det_adjustToOrientation", "code": "theorem det_adjustToOrientation [Nontrivial R] [Nonempty \u03b9] (e : Basis \u03b9 R M)\n    (x : Orientation R M \u03b9) :\n    (e.adjustToOrientation x).det = e.det \u2228 (e.adjustToOrientation x).det = -e.det", "start": [339, 1], "end": [350, 9], "kind": "commanddeclaration"}, {"full_name": "Basis.abs_det_adjustToOrientation", "code": "@[simp]\ntheorem abs_det_adjustToOrientation [Nontrivial R] [Nonempty \u03b9] (e : Basis \u03b9 R M)\n    (x : Orientation R M \u03b9) (v : \u03b9 \u2192 M) : |(e.adjustToOrientation x).det v| = |e.det v|", "start": [353, 1], "end": [356, 59], "kind": "commanddeclaration"}, {"full_name": "Orientation.eq_or_eq_neg", "code": "theorem eq_or_eq_neg (x\u2081 x\u2082 : Orientation R M \u03b9) (h : Fintype.card \u03b9 = finrank R M) :\n    x\u2081 = x\u2082 \u2228 x\u2081 = -x\u2082", "start": [377, 1], "end": [387, 95], "kind": "commanddeclaration"}, {"full_name": "Orientation.ne_iff_eq_neg", "code": "theorem ne_iff_eq_neg (x\u2081 x\u2082 : Orientation R M \u03b9) (h : Fintype.card \u03b9 = finrank R M) :\n    x\u2081 \u2260 x\u2082 \u2194 x\u2081 = -x\u2082", "start": [390, 1], "end": [395, 48], "kind": "commanddeclaration"}, {"full_name": "Orientation.map_eq_det_inv_smul", "code": "theorem map_eq_det_inv_smul (x : Orientation R M \u03b9) (f : M \u2243\u2097[R] M)\n    (h : Fintype.card \u03b9 = finrank R M) : Orientation.map \u03b9 f x = (LinearEquiv.det f)\u207b\u00b9 \u2022 x", "start": [398, 1], "end": [403, 40], "kind": "commanddeclaration"}, {"full_name": "Orientation.map_eq_iff_det_pos", "code": "theorem map_eq_iff_det_pos (x : Orientation R M \u03b9) (f : M \u2243\u2097[R] M)\n    (h : Fintype.card \u03b9 = finrank R M) :\n    Orientation.map \u03b9 f x = x \u2194 0 < LinearMap.det (f : M \u2192\u2097[R] M)", "start": [406, 1], "end": [417, 94], "kind": "commanddeclaration"}, {"full_name": "Orientation.map_eq_neg_iff_det_neg", "code": "theorem map_eq_neg_iff_det_neg (x : Orientation R M \u03b9) (f : M \u2243\u2097[R] M)\n    (h : Fintype.card \u03b9 = finrank R M) :\n    Orientation.map \u03b9 f x = -x \u2194 LinearMap.det (f : M \u2192\u2097[R] M) < 0", "start": [420, 1], "end": [435, 93], "kind": "commanddeclaration"}, {"full_name": "Orientation.someBasis", "code": "def someBasis [Nonempty \u03b9] [DecidableEq \u03b9] (x : Orientation R M \u03b9)\n    (h : Fintype.card \u03b9 = finrank R M) : Basis \u03b9 R M :=\n  ((finBasis R M).reindex (Fintype.equivFinOfCardEq h).symm).adjustToOrientation x", "start": [438, 1], "end": [442, 83], "kind": "commanddeclaration"}, {"full_name": "Orientation.someBasis_orientation", "code": "@[simp]\ntheorem someBasis_orientation [Nonempty \u03b9] [DecidableEq \u03b9] (x : Orientation R M \u03b9)\n    (h : Fintype.card \u03b9 = finrank R M) : (x.someBasis h).orientation = x", "start": [445, 1], "end": [449, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Block.lean", "Mathlib/Analysis/InnerProductSpace/PiL2.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "gramSchmidt", "code": "noncomputable def gramSchmidt [IsWellOrder \u03b9 (\u00b7 < \u00b7)] (f : \u03b9 \u2192 E) (n : \u03b9) : E :=\n  f n - \u2211 i : Iio n, orthogonalProjection (\ud835\udd5c \u2219 gramSchmidt f i) (f n)\ntermination_by _ n => n\ndecreasing_by exact mem_Iio.1 i.2", "start": [52, 1], "end": [57, 34], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_def", "code": "theorem gramSchmidt_def (f : \u03b9 \u2192 E) (n : \u03b9) :\n    gramSchmidt \ud835\udd5c f n = f n - \u2211 i in Iio n, orthogonalProjection (\ud835\udd5c \u2219 gramSchmidt \ud835\udd5c f i) (f n)", "start": [60, 1], "end": [63, 49], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_def'", "code": "theorem gramSchmidt_def' (f : \u03b9 \u2192 E) (n : \u03b9) :\n    f n = gramSchmidt \ud835\udd5c f n + \u2211 i in Iio n, orthogonalProjection (\ud835\udd5c \u2219 gramSchmidt \ud835\udd5c f i) (f n)", "start": [66, 1], "end": [68, 39], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_def''", "code": "theorem gramSchmidt_def'' (f : \u03b9 \u2192 E) (n : \u03b9) :\n    f n = gramSchmidt \ud835\udd5c f n + \u2211 i in Iio n,\n      (\u27eagramSchmidt \ud835\udd5c f i, f n\u27eb / (\u2016gramSchmidt \ud835\udd5c f i\u2016 : \ud835\udd5c) ^ 2) \u2022 gramSchmidt \ud835\udd5c f i", "start": [71, 1], "end": [75, 57], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_zero", "code": "@[simp]\ntheorem gramSchmidt_zero {\u03b9 : Type*} [LinearOrder \u03b9] [LocallyFiniteOrder \u03b9] [OrderBot \u03b9]\n    [IsWellOrder \u03b9 (\u00b7 < \u00b7)] (f : \u03b9 \u2192 E) : gramSchmidt \ud835\udd5c f \u22a5 = f \u22a5", "start": [78, 1], "end": [81, 80], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_orthogonal", "code": "theorem gramSchmidt_orthogonal (f : \u03b9 \u2192 E) {a b : \u03b9} (h\u2080 : a \u2260 b) :\n    \u27eagramSchmidt \ud835\udd5c f a, gramSchmidt \ud835\udd5c f b\u27eb = 0", "start": [84, 1], "end": [111, 37], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_pairwise_orthogonal", "code": "theorem gramSchmidt_pairwise_orthogonal (f : \u03b9 \u2192 E) :\n    Pairwise fun a b => \u27eagramSchmidt \ud835\udd5c f a, gramSchmidt \ud835\udd5c f b\u27eb = 0", "start": [114, 1], "end": [117, 29], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_inv_triangular", "code": "theorem gramSchmidt_inv_triangular (v : \u03b9 \u2192 E) {i j : \u03b9} (hij : i < j) :\n    \u27eagramSchmidt \ud835\udd5c v j, v i\u27eb = 0", "start": [120, 1], "end": [131, 14], "kind": "commanddeclaration"}, {"full_name": "mem_span_gramSchmidt", "code": "theorem mem_span_gramSchmidt (f : \u03b9 \u2192 E) {i j : \u03b9} (hij : i \u2264 j) :\n    f i \u2208 span \ud835\udd5c (gramSchmidt \ud835\udd5c f '' Set.Iic j)", "start": [136, 1], "end": [142, 95], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_mem_span", "code": "theorem gramSchmidt_mem_span (f : \u03b9 \u2192 E) :\n    \u2200 {j i}, i \u2264 j \u2192 gramSchmidt \ud835\udd5c f i \u2208 span \ud835\udd5c (f '' Set.Iic j)", "start": [145, 1], "end": [156, 24], "kind": "commanddeclaration"}, {"full_name": "span_gramSchmidt_Iic", "code": "theorem span_gramSchmidt_Iic (f : \u03b9 \u2192 E) (c : \u03b9) :\n    span \ud835\udd5c (gramSchmidt \ud835\udd5c f '' Set.Iic c) = span \ud835\udd5c (f '' Set.Iic c)", "start": [159, 1], "end": [162, 61], "kind": "commanddeclaration"}, {"full_name": "span_gramSchmidt_Iio", "code": "theorem span_gramSchmidt_Iio (f : \u03b9 \u2192 E) (c : \u03b9) :\n    span \ud835\udd5c (gramSchmidt \ud835\udd5c f '' Set.Iio c) = span \ud835\udd5c (f '' Set.Iio c)", "start": [165, 1], "end": [170, 93], "kind": "commanddeclaration"}, {"full_name": "span_gramSchmidt", "code": "theorem span_gramSchmidt (f : \u03b9 \u2192 E) : span \ud835\udd5c (range (gramSchmidt \ud835\udd5c f)) = span \ud835\udd5c (range f)", "start": [173, 1], "end": [178, 78], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_of_orthogonal", "code": "theorem gramSchmidt_of_orthogonal {f : \u03b9 \u2192 E} (hf : Pairwise fun i j => \u27eaf i, f j\u27eb = 0) :\n    gramSchmidt \ud835\udd5c f = f", "start": [181, 1], "end": [199, 9], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_ne_zero_coe", "code": "theorem gramSchmidt_ne_zero_coe {f : \u03b9 \u2192 E} (n : \u03b9)\n    (h\u2080 : LinearIndependent \ud835\udd5c (f \u2218 ((\u2191) : Set.Iic n \u2192 \u03b9))) : gramSchmidt \ud835\udd5c f n \u2260 0", "start": [204, 1], "end": [224, 60], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_ne_zero", "code": "theorem gramSchmidt_ne_zero {f : \u03b9 \u2192 E} (n : \u03b9) (h\u2080 : LinearIndependent \ud835\udd5c f) :\n    gramSchmidt \ud835\udd5c f n \u2260 0", "start": [227, 1], "end": [231, 80], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_triangular", "code": "theorem gramSchmidt_triangular {i j : \u03b9} (hij : i < j) (b : Basis \u03b9 \ud835\udd5c E) :\n    b.repr (gramSchmidt \ud835\udd5c b i) j = 0", "start": [234, 1], "end": [242, 99], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_linearIndependent", "code": "theorem gramSchmidt_linearIndependent {f : \u03b9 \u2192 E} (h\u2080 : LinearIndependent \ud835\udd5c f) :\n    LinearIndependent \ud835\udd5c (gramSchmidt \ud835\udd5c f)", "start": [245, 1], "end": [249, 31], "kind": "commanddeclaration"}, {"full_name": "gramSchmidtBasis", "code": "noncomputable def gramSchmidtBasis (b : Basis \u03b9 \ud835\udd5c E) : Basis \u03b9 \ud835\udd5c E :=\n  Basis.mk (gramSchmidt_linearIndependent b.linearIndependent)\n    ((span_gramSchmidt \ud835\udd5c b).trans b.span_eq).ge", "start": [252, 1], "end": [255, 48], "kind": "commanddeclaration"}, {"full_name": "coe_gramSchmidtBasis", "code": "theorem coe_gramSchmidtBasis (b : Basis \u03b9 \ud835\udd5c E) : (gramSchmidtBasis b : \u03b9 \u2192 E) = gramSchmidt \ud835\udd5c b", "start": [258, 1], "end": [259, 19], "kind": "commanddeclaration"}, {"full_name": "gramSchmidtNormed", "code": "noncomputable def gramSchmidtNormed (f : \u03b9 \u2192 E) (n : \u03b9) : E :=\n  (\u2016gramSchmidt \ud835\udd5c f n\u2016 : \ud835\udd5c)\u207b\u00b9 \u2022 gramSchmidt \ud835\udd5c f n", "start": [264, 1], "end": [267, 50], "kind": "commanddeclaration"}, {"full_name": "gramSchmidtNormed_unit_length_coe", "code": "theorem gramSchmidtNormed_unit_length_coe {f : \u03b9 \u2192 E} (n : \u03b9)\n    (h\u2080 : LinearIndependent \ud835\udd5c (f \u2218 ((\u2191) : Set.Iic n \u2192 \u03b9))) : \u2016gramSchmidtNormed \ud835\udd5c f n\u2016 = 1", "start": [272, 1], "end": [275, 19], "kind": "commanddeclaration"}, {"full_name": "gramSchmidtNormed_unit_length", "code": "theorem gramSchmidtNormed_unit_length {f : \u03b9 \u2192 E} (n : \u03b9) (h\u2080 : LinearIndependent \ud835\udd5c f) :\n    \u2016gramSchmidtNormed \ud835\udd5c f n\u2016 = 1", "start": [278, 1], "end": [280, 90], "kind": "commanddeclaration"}, {"full_name": "gramSchmidtNormed_unit_length'", "code": "theorem gramSchmidtNormed_unit_length' {f : \u03b9 \u2192 E} {n : \u03b9} (hn : gramSchmidtNormed \ud835\udd5c f n \u2260 0) :\n    \u2016gramSchmidtNormed \ud835\udd5c f n\u2016 = 1", "start": [283, 1], "end": [287, 17], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_orthonormal", "code": "theorem gramSchmidt_orthonormal {f : \u03b9 \u2192 E} (h\u2080 : LinearIndependent \ud835\udd5c f) :\n    Orthonormal \ud835\udd5c (gramSchmidtNormed \ud835\udd5c f)", "start": [290, 1], "end": [302, 41], "kind": "commanddeclaration"}, {"full_name": "gramSchmidt_orthonormal'", "code": "theorem gramSchmidt_orthonormal' (f : \u03b9 \u2192 E) :\n    Orthonormal \ud835\udd5c fun i : { i | gramSchmidtNormed \ud835\udd5c f i \u2260 0 } => gramSchmidtNormed \ud835\udd5c f i", "start": [305, 1], "end": [313, 94], "kind": "commanddeclaration"}, {"full_name": "span_gramSchmidtNormed", "code": "theorem span_gramSchmidtNormed (f : \u03b9 \u2192 E) (s : Set \u03b9) :\n    span \ud835\udd5c (gramSchmidtNormed \ud835\udd5c f '' s) = span \ud835\udd5c (gramSchmidt \ud835\udd5c f '' s)", "start": [316, 1], "end": [326, 40], "kind": "commanddeclaration"}, {"full_name": "span_gramSchmidtNormed_range", "code": "theorem span_gramSchmidtNormed_range (f : \u03b9 \u2192 E) :\n    span \ud835\udd5c (range (gramSchmidtNormed \ud835\udd5c f)) = span \ud835\udd5c (range (gramSchmidt \ud835\udd5c f))", "start": [329, 1], "end": [331, 67], "kind": "commanddeclaration"}, {"full_name": "gramSchmidtOrthonormalBasis", "code": "noncomputable def gramSchmidtOrthonormalBasis : OrthonormalBasis \u03b9 \ud835\udd5c E :=\n  ((gramSchmidt_orthonormal' f).exists_orthonormalBasis_extension_of_card_eq\n    (v := gramSchmidtNormed \ud835\udd5c f) h).choose", "start": [338, 1], "end": [344, 43], "kind": "commanddeclaration"}, {"full_name": "gramSchmidtOrthonormalBasis_apply", "code": "theorem gramSchmidtOrthonormalBasis_apply {f : \u03b9 \u2192 E} {i : \u03b9} (hi : gramSchmidtNormed \ud835\udd5c f i \u2260 0) :\n    gramSchmidtOrthonormalBasis h f i = gramSchmidtNormed \ud835\udd5c f i", "start": [347, 1], "end": [350, 53], "kind": "commanddeclaration"}, {"full_name": "gramSchmidtOrthonormalBasis_apply_of_orthogonal", "code": "theorem gramSchmidtOrthonormalBasis_apply_of_orthogonal {f : \u03b9 \u2192 E}\n    (hf : Pairwise fun i j => \u27eaf i, f j\u27eb = 0) {i : \u03b9} (hi : f i \u2260 0) :\n    gramSchmidtOrthonormalBasis h f i = (\u2016f i\u2016\u207b\u00b9 : \ud835\udd5c) \u2022 f i", "start": [353, 1], "end": [359, 21], "kind": "commanddeclaration"}, {"full_name": "inner_gramSchmidtOrthonormalBasis_eq_zero", "code": "theorem inner_gramSchmidtOrthonormalBasis_eq_zero {f : \u03b9 \u2192 E} {i : \u03b9}\n    (hi : gramSchmidtNormed \ud835\udd5c f i = 0) (j : \u03b9) : \u27eagramSchmidtOrthonormalBasis h f i, f j\u27eb = 0", "start": [362, 1], "end": [377, 61], "kind": "commanddeclaration"}, {"full_name": "gramSchmidtOrthonormalBasis_inv_triangular", "code": "theorem gramSchmidtOrthonormalBasis_inv_triangular {i j : \u03b9} (hij : i < j) :\n    \u27eagramSchmidtOrthonormalBasis h f j, f i\u27eb = 0", "start": [380, 1], "end": [385, 42], "kind": "commanddeclaration"}, {"full_name": "gramSchmidtOrthonormalBasis_inv_triangular'", "code": "theorem gramSchmidtOrthonormalBasis_inv_triangular' {i j : \u03b9} (hij : i < j) :\n    (gramSchmidtOrthonormalBasis h f).repr (f i) j = 0", "start": [388, 1], "end": [390, 101], "kind": "commanddeclaration"}, {"full_name": "gramSchmidtOrthonormalBasis_inv_blockTriangular", "code": "theorem gramSchmidtOrthonormalBasis_inv_blockTriangular :\n    ((gramSchmidtOrthonormalBasis h f).toBasis.toMatrix f).BlockTriangular id", "start": [393, 1], "end": [398, 50], "kind": "commanddeclaration"}, {"full_name": "gramSchmidtOrthonormalBasis_det", "code": "theorem gramSchmidtOrthonormalBasis_det [DecidableEq \u03b9] :\n    (gramSchmidtOrthonormalBasis h f).toBasis.det f =\n      \u220f i, \u27eagramSchmidtOrthonormalBasis h f i, f i\u27eb", "start": [403, 1], "end": [407, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/DoldKan/Projections.lean", "imports": ["Mathlib/AlgebraicTopology/DoldKan/Faces.lean", "Mathlib/CategoryTheory/Idempotents/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicTopology.DoldKan.P", "code": "noncomputable def P : \u2115 \u2192 (K[X] \u27f6 K[X])\n  | 0 => \ud835\udfd9 _\n  | q + 1 => P q \u226b (\ud835\udfd9 _ + H\u03c3 q)", "start": [46, 1], "end": [50, 32], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.P_zero", "code": "lemma P_zero : (P 0 : K[X] \u27f6 K[X]) = \ud835\udfd9 _ := rfl", "start": [56, 1], "end": [56, 48], "kind": "mathlibtacticlemma"}, {"full_name": "AlgebraicTopology.DoldKan.P_succ", "code": "lemma P_succ (q : \u2115) : (P (q+1) : K[X] \u27f6 K[X]) = P q \u226b (\ud835\udfd9 _ + H\u03c3 q) := rfl", "start": [57, 1], "end": [57, 75], "kind": "mathlibtacticlemma"}, {"full_name": "AlgebraicTopology.DoldKan.P_f_0_eq", "code": "@[simp]\ntheorem P_f_0_eq (q : \u2115) : ((P q).f 0 : X _[0] \u27f6 X _[0]) = \ud835\udfd9 _", "start": [59, 1], "end": [65, 66], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Q", "code": "def Q (q : \u2115) : K[X] \u27f6 K[X] :=\n  \ud835\udfd9 _ - P q", "start": [69, 1], "end": [71, 12], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.P_add_Q", "code": "theorem P_add_Q (q : \u2115) : P q + Q q = \ud835\udfd9 K[X]", "start": [75, 1], "end": [77, 7], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.P_add_Q_f", "code": "theorem P_add_Q_f (q n : \u2115) : (P q).f n + (Q q).f n = \ud835\udfd9 (X _[n])", "start": [81, 1], "end": [82, 45], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Q_zero", "code": "@[simp]\ntheorem Q_zero : (Q 0 : K[X] \u27f6 _) = 0", "start": [86, 1], "end": [88, 13], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Q_succ", "code": "theorem Q_succ (q : \u2115) : (Q (q + 1) : K[X] \u27f6 _) = Q q - P q \u226b H\u03c3 q", "start": [92, 1], "end": [94, 7], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Q_f_0_eq", "code": "@[simp]\ntheorem Q_f_0_eq (q : \u2115) : ((Q q).f 0 : X _[0] \u27f6 X _[0]) = 0", "start": [98, 1], "end": [101, 93], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.HigherFacesVanish.of_P", "code": "theorem of_P : \u2200 q n : \u2115, HigherFacesVanish q ((P q).f (n + 1) : X _[n + 1] \u27f6 X _[n + 1])", "start": [107, 1], "end": [116, 31], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.HigherFacesVanish.comp_P_eq_self", "code": "@[reassoc]\ntheorem comp_P_eq_self {Y : C} {n q : \u2115} {\u03c6 : Y \u27f6 X _[n + 1]} (v : HigherFacesVanish q \u03c6) :\n    \u03c6 \u226b (P q).f (n + 1) = \u03c6", "start": [120, 1], "end": [137, 32], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.comp_P_eq_self_iff", "code": "theorem comp_P_eq_self_iff {Y : C} {n q : \u2115} {\u03c6 : Y \u27f6 X _[n + 1]} :\n    \u03c6 \u226b (P q).f (n + 1) = \u03c6 \u2194 HigherFacesVanish q \u03c6", "start": [143, 1], "end": [150, 43], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.P_f_idem", "code": "@[reassoc (attr := simp)]\ntheorem P_f_idem (q n : \u2115) : ((P q).f n : X _[n] \u27f6 _) \u226b (P q).f n = (P q).f n", "start": [154, 1], "end": [158, 54], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Q_f_idem", "code": "@[reassoc (attr := simp)]\ntheorem Q_f_idem (q n : \u2115) : ((Q q).f n : X _[n] \u27f6 _) \u226b (Q q).f n = (Q q).f n", "start": [162, 1], "end": [164, 39], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.P_idem", "code": "@[reassoc (attr := simp)]\ntheorem P_idem (q : \u2115) : (P q : K[X] \u27f6 K[X]) \u226b P q = P q", "start": [168, 1], "end": [171, 21], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Q_idem", "code": "@[reassoc (attr := simp)]\ntheorem Q_idem (q : \u2115) : (Q q : K[X] \u27f6 K[X]) \u226b Q q = Q q", "start": [175, 1], "end": [178, 21], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.natTransP", "code": "@[simps]\ndef natTransP (q : \u2115) : alternatingFaceMapComplex C \u27f6 alternatingFaceMapComplex C where\n  app X := P q\n  naturality _ _ f := by\n    induction' q with q hq\n    \u00b7 dsimp [alternatingFaceMapComplex]\n      simp only [P_zero, id_comp, comp_id]\n    \u00b7 simp only [P_succ, add_comp, comp_add, assoc, comp_id, hq, reassoc_of% hq]\n      erw [(natTransH\u03c3 q).naturality f]\n      rfl", "start": [182, 1], "end": [192, 10], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.P_f_naturality", "code": "@[reassoc (attr := simp)]\ntheorem P_f_naturality (q n : \u2115) {X Y : SimplicialObject C} (f : X \u27f6 Y) :\n    f.app (op [n]) \u226b (P q).f n = (P q).f n \u226b f.app (op [n])", "start": [196, 1], "end": [199, 62], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Q_f_naturality", "code": "@[reassoc (attr := simp)]\ntheorem Q_f_naturality (q n : \u2115) {X Y : SimplicialObject C} (f : X \u27f6 Y) :\n    f.app (op [n]) \u226b (Q q).f n = (Q q).f n \u226b f.app (op [n])", "start": [203, 1], "end": [209, 31], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.natTransQ", "code": "@[simps]\ndef natTransQ (q : \u2115) : alternatingFaceMapComplex C \u27f6 alternatingFaceMapComplex C where\n  app X := Q q", "start": [213, 1], "end": [216, 15], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.map_P", "code": "theorem map_P {D : Type*} [Category D] [Preadditive D] (G : C \u2964 D) [G.Additive]\n    (X : SimplicialObject C) (q n : \u2115) :\n    G.map ((P q : K[X] \u27f6 _).f n) = (P q : K[((whiskering C D).obj G).obj X] \u27f6 _).f n", "start": [220, 1], "end": [227, 62], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.map_Q", "code": "theorem map_Q {D : Type*} [Category D] [Preadditive D] (G : C \u2964 D) [G.Additive]\n    (X : SimplicialObject C) (q n : \u2115) :\n    G.map ((Q q : K[X] \u27f6 _).f n) = (Q q : K[((whiskering C D).obj G).obj X] \u27f6 _).f n", "start": [231, 1], "end": [236, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Idempotents/FunctorExtension.lean", "imports": ["Mathlib/CategoryTheory/Idempotents/Karoubi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Idempotents.natTrans_eq", "code": "theorem natTrans_eq {F G : Karoubi C \u2964 D} (\u03c6 : F \u27f6 G) (P : Karoubi C) :\n    \u03c6.app P = F.map (decompId_i P) \u226b \u03c6.app P.X \u226b G.map (decompId_p P)", "start": [42, 1], "end": [51, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.FunctorExtension\u2081.obj", "code": "@[simps]\ndef obj (F : C \u2964 Karoubi D) : Karoubi C \u2964 Karoubi D where\n  obj P :=\n    \u27e8(F.obj P.X).X, (F.map P.p).f, by simpa only [F.map_comp, hom_ext_iff] using F.congr_map P.idem\u27e9\n  map f := \u27e8(F.map f.f).f, by simpa only [F.map_comp, hom_ext_iff] using F.congr_map f.comm\u27e9", "start": [56, 1], "end": [62, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.FunctorExtension\u2081.map", "code": "@[simps]\ndef map {F G : C \u2964 Karoubi D} (\u03c6 : F \u27f6 G) : obj F \u27f6 obj G where\n  app P :=\n    { f := (F.map P.p).f \u226b (\u03c6.app P.X).f\n      comm := by\n        have h := \u03c6.naturality P.p\n        have h' := F.congr_map P.idem\n        simp only [hom_ext_iff, Karoubi.comp_f, F.map_comp] at h h'\n        simp only [obj_obj_p, assoc, \u2190 h]\n        slice_rhs 1 3 => rw [h', h'] }\n  naturality _ _ f := by\n    ext\n    dsimp [obj]\n    have h := \u03c6.naturality f.f\n    have h' := F.congr_map (comp_p f)\n    have h'' := F.congr_map (p_comp f)\n    simp only [hom_ext_iff, Functor.map_comp, comp_f] at h h' h'' \u22a2\n    slice_rhs 2 3 => rw [\u2190 h]\n    slice_lhs 1 2 => rw [h']\n    slice_rhs 1 2 => rw [h'']", "start": [65, 1], "end": [87, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.functorExtension\u2081", "code": "@[simps]\ndef functorExtension\u2081 : (C \u2964 Karoubi D) \u2964 Karoubi C \u2964 Karoubi D where\n  obj := FunctorExtension\u2081.obj\n  map := FunctorExtension\u2081.map\n  map_id F := by\n    ext P\n    exact comp_p (F.map P.p)\n  map_comp {F G H} \u03c6 \u03c6' := by\n    ext P\n    simp only [comp_f, FunctorExtension\u2081.map_app_f, NatTrans.comp_app, assoc]\n    have h := \u03c6.naturality P.p\n    have h' := F.congr_map P.idem\n    simp only [hom_ext_iff, comp_f, F.map_comp] at h h'\n    slice_rhs 2 3 => rw [\u2190 h]\n    slice_rhs 1 2 => rw [h']\n    simp only [assoc]", "start": [94, 1], "end": [110, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.functorExtension\u2081_comp_whiskeringLeft_toKaroubi", "code": "theorem functorExtension\u2081_comp_whiskeringLeft_toKaroubi :\n    functorExtension\u2081 C D \u22d9 (whiskeringLeft C (Karoubi C) (Karoubi D)).obj (toKaroubi C) =\n      \ud835\udfed _", "start": [113, 1], "end": [125, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.functorExtension\u2081_comp_whiskeringLeft_toKaroubi_iso", "code": "@[simps!]\ndef functorExtension\u2081_comp_whiskeringLeft_toKaroubi_iso :\n    functorExtension\u2081 C D \u22d9 (whiskeringLeft C (Karoubi C) (Karoubi D)).obj (toKaroubi C) \u2245 \ud835\udfed _ :=\n  eqToIso (functorExtension\u2081_comp_whiskeringLeft_toKaroubi C D)", "start": [128, 1], "end": [133, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.KaroubiUniversal\u2081.counitIso", "code": "@[simps!]\ndef KaroubiUniversal\u2081.counitIso :\n    (whiskeringLeft C (Karoubi C) (Karoubi D)).obj (toKaroubi C) \u22d9 functorExtension\u2081 C D \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents\n    (fun G =>\n      { hom :=\n          { app := fun P =>\n              { f := (G.map (decompId_p P)).f\n                comm := by\n                  simpa only [hom_ext_iff, G.map_comp, G.map_id] using\n                    G.congr_map\n                      (show P.decompId_p = (toKaroubi C).map P.p \u226b P.decompId_p \u226b \ud835\udfd9 _ by simp) }\n            naturality := fun P Q f => by\n              simpa only [hom_ext_iff, G.map_comp]\n                using (G.congr_map (decompId_p_naturality f)).symm }\n        inv :=\n          { app := fun P =>\n              { f := (G.map (decompId_i P)).f\n                comm := by\n                  simpa only [hom_ext_iff, G.map_comp, G.map_id] using\n                    G.congr_map\n                      (show P.decompId_i = \ud835\udfd9 _ \u226b P.decompId_i \u226b (toKaroubi C).map P.p by simp) }\n            naturality := fun P Q f => by\n              simpa only [hom_ext_iff, G.map_comp] using G.congr_map (decompId_i_naturality f) }\n        hom_inv_id := by\n          ext P\n          simpa only [hom_ext_iff, G.map_comp, G.map_id] using G.congr_map P.decomp_p.symm\n        inv_hom_id := by\n          ext P\n          simpa only [hom_ext_iff, G.map_comp, G.map_id] using G.congr_map P.decompId.symm })\n    (fun {X Y} \u03c6 => by\n      ext P\n      dsimp\n      rw [natTrans_eq \u03c6 P, P.decomp_p]\n      simp only [Functor.map_comp, comp_f, assoc]\n      rfl)", "start": [136, 1], "end": [172, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.karoubiUniversal\u2081", "code": "@[simps]\ndef karoubiUniversal\u2081 : C \u2964 Karoubi D \u224c Karoubi C \u2964 Karoubi D where\n  functor := functorExtension\u2081 C D\n  inverse := (whiskeringLeft C (Karoubi C) (Karoubi D)).obj (toKaroubi C)\n  unitIso := (functorExtension\u2081_comp_whiskeringLeft_toKaroubi_iso C D).symm\n  counitIso := KaroubiUniversal\u2081.counitIso C D\n  functor_unitIso_comp F := by\n    ext P\n    dsimp [FunctorExtension\u2081.map, KaroubiUniversal\u2081.counitIso]\n    simp only [eqToHom_app, Functor.id_obj, Functor.comp_obj, functorExtension\u2081_obj,\n      whiskeringLeft_obj_obj, eqToHom_f, FunctorExtension\u2081.obj_obj_X, toKaroubi_obj_X,\n      eqToHom_refl, comp_id, comp_p, \u2190comp_f, \u2190 F.map_comp, P.idem]", "start": [175, 1], "end": [187, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.functorExtension\u2081_comp", "code": "theorem functorExtension\u2081_comp (F : C \u2964 Karoubi D) (G : D \u2964 Karoubi E) :\n    (functorExtension\u2081 C E).obj (F \u22d9 (functorExtension\u2081 D E).obj G) =\n      (functorExtension\u2081 C D).obj F \u22d9 (functorExtension\u2081 D E).obj G", "start": [190, 1], "end": [198, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.functorExtension\u2082", "code": "@[simps!]\ndef functorExtension\u2082 : (C \u2964 D) \u2964 Karoubi C \u2964 Karoubi D :=\n  (whiskeringRight C D (Karoubi D)).obj (toKaroubi D) \u22d9 functorExtension\u2081 C D", "start": [201, 1], "end": [204, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.functorExtension\u2082_comp_whiskeringLeft_toKaroubi", "code": "theorem functorExtension\u2082_comp_whiskeringLeft_toKaroubi :\n    functorExtension\u2082 C D \u22d9 (whiskeringLeft C (Karoubi C) (Karoubi D)).obj (toKaroubi C) =\n      (whiskeringRight C D (Karoubi D)).obj (toKaroubi D)", "start": [207, 1], "end": [211, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.functorExtension\u2082CompWhiskeringLeftToKaroubiIso", "code": "@[simps!]\ndef functorExtension\u2082CompWhiskeringLeftToKaroubiIso :\n    functorExtension\u2082 C D \u22d9 (whiskeringLeft C (Karoubi C) (Karoubi D)).obj (toKaroubi C) \u2245\n      (whiskeringRight C D (Karoubi D)).obj (toKaroubi D) :=\n  eqToIso (functorExtension\u2082_comp_whiskeringLeft_toKaroubi C D)", "start": [214, 1], "end": [220, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.karoubiUniversal\u2082", "code": "@[simp]\nnoncomputable def karoubiUniversal\u2082 : C \u2964 D \u224c Karoubi C \u2964 Karoubi D :=\n  (Equivalence.congrRight (toKaroubi D).asEquivalence).trans (karoubiUniversal\u2081 C D)", "start": [230, 1], "end": [234, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.karoubiUniversal\u2082_functor_eq", "code": "theorem karoubiUniversal\u2082_functor_eq : (karoubiUniversal\u2082 C D).functor = functorExtension\u2082 C D", "start": [237, 1], "end": [238, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.functorExtension", "code": "@[simps!]\nnoncomputable def functorExtension : (C \u2964 D) \u2964 Karoubi C \u2964 D :=\n  functorExtension\u2082 C D \u22d9\n    (whiskeringRight (Karoubi C) (Karoubi D) D).obj (toKaroubiIsEquivalence D).inverse", "start": [245, 1], "end": [250, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.karoubiUniversal", "code": "@[simp]\nnoncomputable def karoubiUniversal : C \u2964 D \u224c Karoubi C \u2964 D :=\n  (karoubiUniversal\u2082 C D).trans (Equivalence.congrRight (toKaroubi D).asEquivalence.symm)", "start": [253, 1], "end": [256, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.karoubiUniversal_functor_eq", "code": "theorem karoubiUniversal_functor_eq : (karoubiUniversal C D).functor = functorExtension C D", "start": [259, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.isEquivalence_whiskeringLeft_obj_toKaroubi_aux", "code": "lemma isEquivalence_whiskeringLeft_obj_toKaroubi_aux :\n    ((whiskeringLeft C (Karoubi C) D).obj (toKaroubi C) \u22d9\n      (whiskeringRight C D (Karoubi D)).obj (toKaroubi D) \u22d9\n        (whiskeringRight C (Karoubi D) D).obj (Functor.inv (toKaroubi D))) =\n      (karoubiUniversal C D).inverse := by\n  rfl", "start": [268, 1], "end": [273, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Idempotents.whiskeringLeft_obj_preimage_app", "code": "theorem whiskeringLeft_obj_preimage_app {F G : Karoubi C \u2964 D}\n    (\u03c4 : toKaroubi _ \u22d9 F \u27f6 toKaroubi _ \u22d9 G) (P : Karoubi C) :\n    (((whiskeringLeft _ _ _).obj (toKaroubi _)).preimage \u03c4).app P =\n      F.map P.decompId_i \u226b \u03c4.app P.X \u226b G.map P.decompId_p", "start": [286, 1], "end": [294, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/SetLike/Fintype.lean", "imports": ["Mathlib/Data/Fintype/Powerset.lean", "Mathlib/Data/SetLike/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/RingTheory/Nakayama.lean", "imports": ["Mathlib/RingTheory/JacobsonIdeal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Submodule.eq_smul_of_le_smul_of_le_jacobson", "code": "theorem eq_smul_of_le_smul_of_le_jacobson {I J : Ideal R} {N : Submodule R M} (hN : N.FG)\n    (hIN : N \u2264 I \u2022 N) (hIjac : I \u2264 jacobson J) : N = J \u2022 N", "start": [49, 1], "end": [61, 60], "kind": "commanddeclaration"}, {"full_name": "Submodule.eq_bot_of_le_smul_of_le_jacobson_bot", "code": "theorem eq_bot_of_le_smul_of_le_jacobson_bot (I : Ideal R) (N : Submodule R M) (hN : N.FG)\n    (hIN : N \u2264 I \u2022 N) (hIjac : I \u2264 jacobson \u22a5) : N = \u22a5", "start": [64, 1], "end": [70, 74], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_sup_eq_smul_sup_of_le_smul_of_le_jacobson", "code": "theorem smul_sup_eq_smul_sup_of_le_smul_of_le_jacobson {I J : Ideal R} {N N' : Submodule R M}\n    (hN' : N'.FG) (hIJ : I \u2264 jacobson J) (hNN : N \u2294 N' \u2264 N \u2294 I \u2022 N') : N \u2294 I \u2022 N' = N \u2294 J \u2022 N'", "start": [73, 1], "end": [89, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_sup_le_of_le_smul_of_le_jacobson_bot", "code": "theorem smul_sup_le_of_le_smul_of_le_jacobson_bot {I : Ideal R} {N N' : Submodule R M} (hN' : N'.FG)\n    (hIJ : I \u2264 jacobson \u22a5) (hNN : N \u2294 N' \u2264 N \u2294 I \u2022 N') : I \u2022 N' \u2264 N", "start": [92, 1], "end": [99, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/Basic.lean", "imports": ["Mathlib/LinearAlgebra/Basic.lean", "Mathlib/Data/Bracket.lean", "Mathlib/Algebra/Module/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LieRing", "code": "class LieRing (L : Type v) extends AddCommGroup L, Bracket L L where\n  \n  protected add_lie : \u2200 x y z : L, \u2045x + y, z\u2046 = \u2045x, z\u2046 + \u2045y, z\u2046\n  \n  protected lie_add : \u2200 x y z : L, \u2045x, y + z\u2046 = \u2045x, y\u2046 + \u2045x, z\u2046\n  \n  protected lie_self : \u2200 x : L, \u2045x, x\u2046 = 0\n  \n  protected leibniz_lie : \u2200 x y z : L, \u2045x, \u2045y, z\u2046\u2046 = \u2045\u2045x, y\u2046, z\u2046 + \u2045y, \u2045x, z\u2046\u2046", "start": [55, 1], "end": [65, 79], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra", "code": "class LieAlgebra (R : Type u) (L : Type v) [CommRing R] [LieRing L] extends Module R L where\n  \n  protected lie_smul : \u2200 (t : R) (x y : L), \u2045x, t \u2022 y\u2046 = t \u2022 \u2045x, y\u2046", "start": [68, 1], "end": [75, 68], "kind": "commanddeclaration"}, {"full_name": "LieRingModule", "code": "class LieRingModule (L : Type v) (M : Type w) [LieRing L] [AddCommGroup M] extends Bracket L M where\n  \n  protected add_lie : \u2200 (x y : L) (m : M), \u2045x + y, m\u2046 = \u2045x, m\u2046 + \u2045y, m\u2046\n  \n  protected lie_add : \u2200 (x : L) (m n : M), \u2045x, m + n\u2046 = \u2045x, m\u2046 + \u2045x, n\u2046\n  \n  protected leibniz_lie : \u2200 (x y : L) (m : M), \u2045x, \u2045y, m\u2046\u2046 = \u2045\u2045x, y\u2046, m\u2046 + \u2045y, \u2045x, m\u2046\u2046", "start": [78, 1], "end": [87, 87], "kind": "commanddeclaration"}, {"full_name": "LieModule", "code": "class LieModule (R : Type u) (L : Type v) (M : Type w) [CommRing R] [LieRing L] [LieAlgebra R L]\n  [AddCommGroup M] [Module R M] [LieRingModule L M] : Prop where\n  \n  protected smul_lie : \u2200 (t : R) (x : L) (m : M), \u2045t \u2022 x, m\u2046 = t \u2022 \u2045x, m\u2046\n  \n  protected lie_smul : \u2200 (t : R) (x : L) (m : M), \u2045x, t \u2022 m\u2046 = t \u2022 \u2045x, m\u2046", "start": [90, 1], "end": [97, 74], "kind": "commanddeclaration"}, {"full_name": "add_lie", "code": "@[simp]\ntheorem add_lie : \u2045x + y, m\u2046 = \u2045x, m\u2046 + \u2045y, m\u2046", "start": [112, 1], "end": [114, 30], "kind": "commanddeclaration"}, {"full_name": "lie_add", "code": "@[simp]\ntheorem lie_add : \u2045x, m + n\u2046 = \u2045x, m\u2046 + \u2045x, n\u2046", "start": [117, 1], "end": [119, 30], "kind": "commanddeclaration"}, {"full_name": "smul_lie", "code": "@[simp]\ntheorem smul_lie : \u2045t \u2022 x, m\u2046 = t \u2022 \u2045x, m\u2046", "start": [122, 1], "end": [124, 27], "kind": "commanddeclaration"}, {"full_name": "lie_smul", "code": "@[simp]\ntheorem lie_smul : \u2045x, t \u2022 m\u2046 = t \u2022 \u2045x, m\u2046", "start": [127, 1], "end": [129, 27], "kind": "commanddeclaration"}, {"full_name": "leibniz_lie", "code": "theorem leibniz_lie : \u2045x, \u2045y, m\u2046\u2046 = \u2045\u2045x, y\u2046, m\u2046 + \u2045y, \u2045x, m\u2046\u2046", "start": [132, 1], "end": [133, 34], "kind": "commanddeclaration"}, {"full_name": "lie_zero", "code": "@[simp]\ntheorem lie_zero : \u2045x, 0\u2046 = (0 : M)", "start": [136, 1], "end": [138, 44], "kind": "commanddeclaration"}, {"full_name": "zero_lie", "code": "@[simp]\ntheorem zero_lie : \u2045(0 : L), m\u2046 = 0", "start": [141, 1], "end": [143, 77], "kind": "commanddeclaration"}, {"full_name": "lie_self", "code": "@[simp]\ntheorem lie_self : \u2045x, x\u2046 = 0", "start": [146, 1], "end": [148, 21], "kind": "commanddeclaration"}, {"full_name": "lieRingSelfModule", "code": "instance lieRingSelfModule : LieRingModule L L :=\n  { (inferInstance : LieRing L) with }", "start": [151, 1], "end": [152, 39], "kind": "commanddeclaration"}, {"full_name": "lie_skew", "code": "@[simp]\ntheorem lie_skew : -\u2045y, x\u2046 = \u2045x, y\u2046", "start": [155, 1], "end": [158, 41], "kind": "commanddeclaration"}, {"full_name": "lieAlgebraSelfModule", "code": "instance lieAlgebraSelfModule : LieModule R L L\n    where\n  smul_lie t x m := by rw [\u2190 lie_skew, \u2190 lie_skew x m, LieAlgebra.lie_smul, smul_neg]\n  lie_smul := by apply LieAlgebra.lie_smul", "start": [161, 1], "end": [165, 43], "kind": "commanddeclaration"}, {"full_name": "neg_lie", "code": "@[simp]\ntheorem neg_lie : \u2045-x, m\u2046 = -\u2045x, m\u2046", "start": [168, 1], "end": [171, 7], "kind": "commanddeclaration"}, {"full_name": "lie_neg", "code": "@[simp]\ntheorem lie_neg : \u2045x, -m\u2046 = -\u2045x, m\u2046", "start": [174, 1], "end": [177, 7], "kind": "commanddeclaration"}, {"full_name": "sub_lie", "code": "@[simp]\ntheorem sub_lie : \u2045x - y, m\u2046 = \u2045x, m\u2046 - \u2045y, m\u2046", "start": [180, 1], "end": [181, 75], "kind": "commanddeclaration"}, {"full_name": "lie_sub", "code": "@[simp]\ntheorem lie_sub : \u2045x, m - n\u2046 = \u2045x, m\u2046 - \u2045x, n\u2046", "start": [184, 1], "end": [185, 75], "kind": "commanddeclaration"}, {"full_name": "nsmul_lie", "code": "@[simp]\ntheorem nsmul_lie (n : \u2115) : \u2045n \u2022 x, m\u2046 = n \u2022 \u2045x, m\u2046", "start": [188, 1], "end": [192, 8], "kind": "commanddeclaration"}, {"full_name": "lie_nsmul", "code": "@[simp]\ntheorem lie_nsmul (n : \u2115) : \u2045x, n \u2022 m\u2046 = n \u2022 \u2045x, m\u2046", "start": [195, 1], "end": [199, 8], "kind": "commanddeclaration"}, {"full_name": "zsmul_lie", "code": "@[simp]\ntheorem zsmul_lie (a : \u2124) : \u2045a \u2022 x, m\u2046 = a \u2022 \u2045x, m\u2046", "start": [202, 1], "end": [206, 8], "kind": "commanddeclaration"}, {"full_name": "lie_zsmul", "code": "@[simp]\ntheorem lie_zsmul (a : \u2124) : \u2045x, a \u2022 m\u2046 = a \u2022 \u2045x, m\u2046", "start": [209, 1], "end": [213, 8], "kind": "commanddeclaration"}, {"full_name": "lie_lie", "code": "@[simp]\ntheorem lie_lie : \u2045\u2045x, y\u2046, m\u2046 = \u2045x, \u2045y, m\u2046\u2046 - \u2045y, \u2045x, m\u2046\u2046", "start": [216, 1], "end": [217, 97], "kind": "commanddeclaration"}, {"full_name": "lie_jacobi", "code": "theorem lie_jacobi : \u2045x, \u2045y, z\u2046\u2046 + \u2045y, \u2045z, x\u2046\u2046 + \u2045z, \u2045x, y\u2046\u2046 = 0", "start": [220, 1], "end": [222, 7], "kind": "commanddeclaration"}, {"full_name": "LieRing.instLieAlgebra", "code": "instance LieRing.instLieAlgebra : LieAlgebra \u2124 L where lie_smul n x y := lie_zsmul x y n", "start": [225, 1], "end": [225, 89], "kind": "commanddeclaration"}, {"full_name": "LinearMap.instLieRingModule", "code": "instance LinearMap.instLieRingModule : LieRingModule L (M \u2192\u2097[R] N) where\n  bracket x f :=\n    { toFun := fun m => \u2045x, f m\u2046 - f \u2045x, m\u2046\n      map_add' := fun m n => by\n        simp only [lie_add, LinearMap.map_add]\n        abel\n      map_smul' := fun t m => by\n        simp only [smul_sub, LinearMap.map_smul, lie_smul, RingHom.id_apply] }\n  add_lie x y f := by\n    ext n\n    simp only [add_lie, LinearMap.coe_mk, AddHom.coe_mk, LinearMap.add_apply, LinearMap.map_add]\n    abel\n  lie_add x f g := by\n    ext n\n    simp only [LinearMap.coe_mk, AddHom.coe_mk, lie_add, LinearMap.add_apply]\n    abel\n  leibniz_lie x y f := by\n    ext n\n    simp only [lie_lie, LinearMap.coe_mk, AddHom.coe_mk, LinearMap.map_sub, LinearMap.add_apply,\n      lie_sub]\n    abel", "start": [228, 1], "end": [248, 9], "kind": "commanddeclaration"}, {"full_name": "LieHom.lie_apply", "code": "@[simp]\ntheorem LieHom.lie_apply (f : M \u2192\u2097[R] N) (x : L) (m : M) : \u2045x, f\u2046 m = \u2045x, f m\u2046 - f \u2045x, m\u2046", "start": [250, 1], "end": [252, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.instLieModule", "code": "instance LinearMap.instLieModule : LieModule R L (M \u2192\u2097[R] N)\n    where\n  smul_lie t x f := by\n    ext n\n    simp only [smul_sub, smul_lie, LinearMap.smul_apply, LieHom.lie_apply, LinearMap.map_smul]\n  lie_smul t x f := by\n    ext n\n    simp only [smul_sub, LinearMap.smul_apply, LieHom.lie_apply, lie_smul]", "start": [255, 1], "end": [262, 75], "kind": "commanddeclaration"}, {"full_name": "Module.Dual.instLieRingModule", "code": "instance Module.Dual.instLieRingModule : LieRingModule L (M \u2192\u2097[R] R) where\n  bracket := fun x f \u21a6\n    { toFun := fun m \u21a6 - f \u2045x, m\u2046\n      map_add' := by simp [-neg_add_rev, neg_add]\n      map_smul' := by simp }\n  add_lie := fun x y m \u21a6 by ext n; simp [-neg_add_rev, neg_add]\n  lie_add := fun x m n \u21a6 by ext p; simp [-neg_add_rev, neg_add]\n  leibniz_lie := fun x m n \u21a6 by ext p; simp", "start": [264, 1], "end": [274, 44], "kind": "commanddeclaration"}, {"full_name": "Module.Dual.lie_apply", "code": "@[simp] lemma Module.Dual.lie_apply (f : M \u2192\u2097[R] R) : \u2045x, f\u2046 m = - f \u2045x, m\u2046 := rfl", "start": [276, 1], "end": [276, 83], "kind": "mathlibtacticlemma"}, {"full_name": "Module.Dual.instLieModule", "code": "instance Module.Dual.instLieModule : LieModule R L (M \u2192\u2097[R] R) where\n  smul_lie := fun t x m \u21a6 by ext n; simp\n  lie_smul := fun t x m \u21a6 by ext n; simp", "start": [278, 1], "end": [280, 41], "kind": "commanddeclaration"}, {"full_name": "LieHom", "code": "structure LieHom (R L L': Type*) [CommRing R] [LieRing L] [LieAlgebra R L]\n  [LieRing L'] [LieAlgebra R L'] extends L \u2192\u2097[R] L' where\n  \n  map_lie' : \u2200 {x y : L}, toFun \u2045x, y\u2046 = \u2045toFun x, toFun y\u2046", "start": [284, 1], "end": [288, 60], "kind": "commanddeclaration"}, {"full_name": "LieHom.coe_toLinearMap", "code": "@[simp, norm_cast]\ntheorem coe_toLinearMap (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) : \u21d1(f : L\u2081 \u2192\u2097[R] L\u2082) = f", "start": [318, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) : f.toFun = \u21d1f", "start": [323, 1], "end": [325, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.map_smul", "code": "@[simp]\ntheorem map_smul (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) (c : R) (x : L\u2081) : f (c \u2022 x) = c \u2022 f x", "start": [328, 1], "end": [330, 43], "kind": "commanddeclaration"}, {"full_name": "LieHom.map_add", "code": "@[simp]\ntheorem map_add (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) (x y : L\u2081) : f (x + y) = f x + f y", "start": [333, 1], "end": [335, 42], "kind": "commanddeclaration"}, {"full_name": "LieHom.map_sub", "code": "@[simp]\ntheorem map_sub (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) (x y : L\u2081) : f (x - y) = f x - f y", "start": [338, 1], "end": [340, 42], "kind": "commanddeclaration"}, {"full_name": "LieHom.map_neg", "code": "@[simp]\ntheorem map_neg (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) (x : L\u2081) : f (-x) = -f x", "start": [343, 1], "end": [345, 40], "kind": "commanddeclaration"}, {"full_name": "LieHom.map_lie", "code": "@[simp]\ntheorem map_lie (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) (x y : L\u2081) : f \u2045x, y\u2046 = \u2045f x, f y\u2046", "start": [348, 1], "end": [350, 20], "kind": "commanddeclaration"}, {"full_name": "LieHom.map_zero", "code": "@[simp]\ntheorem map_zero (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) : f 0 = 0", "start": [353, 1], "end": [355, 29], "kind": "commanddeclaration"}, {"full_name": "LieHom.id", "code": "def id : L\u2081 \u2192\u2097\u2045R\u2046 L\u2081 :=\n  { (LinearMap.id : L\u2081 \u2192\u2097[R] L\u2081) with map_lie' := rfl }", "start": [358, 1], "end": [360, 56], "kind": "commanddeclaration"}, {"full_name": "LieHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(id : L\u2081 \u2192\u2097\u2045R\u2046 L\u2081) = _root_.id", "start": [363, 1], "end": [365, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.id_apply", "code": "theorem id_apply (x : L\u2081) : (id : L\u2081 \u2192\u2097\u2045R\u2046 L\u2081) x = x", "start": [368, 1], "end": [369, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.coe_zero", "code": "@[norm_cast, simp]\ntheorem coe_zero : ((0 : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) : L\u2081 \u2192 L\u2082) = 0", "start": [376, 1], "end": [378, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.zero_apply", "code": "theorem zero_apply (x : L\u2081) : (0 : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) x = 0", "start": [381, 1], "end": [382, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.coe_one", "code": "@[simp]\ntheorem coe_one : ((1 : L\u2081 \u2192\u2097\u2045R\u2046 L\u2081) : L\u2081 \u2192 L\u2081) = _root_.id", "start": [389, 1], "end": [391, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.one_apply", "code": "theorem one_apply (x : L\u2081) : (1 : L\u2081 \u2192\u2097\u2045R\u2046 L\u2081) x = x", "start": [394, 1], "end": [395, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.coe_injective", "code": "theorem coe_injective : @Function.Injective (L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) (L\u2081 \u2192 L\u2082) (\u2191)", "start": [401, 1], "end": [403, 8], "kind": "commanddeclaration"}, {"full_name": "LieHom.ext", "code": "@[ext]\ntheorem ext {f g : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082} (h : \u2200 x, f x = g x) : f = g", "start": [406, 1], "end": [408, 28], "kind": "commanddeclaration"}, {"full_name": "LieHom.ext_iff", "code": "theorem ext_iff {f g : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082} : f = g \u2194 \u2200 x, f x = g x", "start": [411, 1], "end": [414, 14], "kind": "commanddeclaration"}, {"full_name": "LieHom.congr_fun", "code": "theorem congr_fun {f g : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082} (h : f = g) (x : L\u2081) : f x = g x", "start": [417, 1], "end": [418, 10], "kind": "commanddeclaration"}, {"full_name": "LieHom.mk_coe", "code": "@[simp]\ntheorem mk_coe (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) (h\u2081 h\u2082 h\u2083) : (\u27e8\u27e8\u27e8f, h\u2081\u27e9, h\u2082\u27e9, h\u2083\u27e9 : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) = f", "start": [421, 1], "end": [424, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : L\u2081 \u2192 L\u2082) (h\u2081 h\u2082 h\u2083) : ((\u27e8\u27e8\u27e8f, h\u2081\u27e9, h\u2082\u27e9, h\u2083\u27e9 : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) : L\u2081 \u2192 L\u2082) = f", "start": [427, 1], "end": [429, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.comp", "code": "def comp (f : L\u2082 \u2192\u2097\u2045R\u2046 L\u2083) (g : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) : L\u2081 \u2192\u2097\u2045R\u2046 L\u2083 :=\n  { LinearMap.comp f.toLinearMap g.toLinearMap with\n    map_lie' := by\n      intros x y\n      change f (g \u2045x, y\u2046) = \u2045f (g x), f (g y)\u2046\n      rw [map_lie, map_lie] }", "start": [432, 1], "end": [438, 30], "kind": "commanddeclaration"}, {"full_name": "LieHom.comp_apply", "code": "theorem comp_apply (f : L\u2082 \u2192\u2097\u2045R\u2046 L\u2083) (g : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) (x : L\u2081) : f.comp g x = f (g x)", "start": [441, 1], "end": [442, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.coe_comp", "code": "@[norm_cast, simp]\ntheorem coe_comp (f : L\u2082 \u2192\u2097\u2045R\u2046 L\u2083) (g : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) : (f.comp g : L\u2081 \u2192 L\u2083) = f \u2218 g", "start": [445, 1], "end": [447, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.coe_linearMap_comp", "code": "@[norm_cast, simp]\ntheorem coe_linearMap_comp (f : L\u2082 \u2192\u2097\u2045R\u2046 L\u2083) (g : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) :\n    (f.comp g : L\u2081 \u2192\u2097[R] L\u2083) = (f : L\u2082 \u2192\u2097[R] L\u2083).comp (g : L\u2081 \u2192\u2097[R] L\u2082)", "start": [450, 1], "end": [453, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) : f.comp (id : L\u2081 \u2192\u2097\u2045R\u2046 L\u2081) = f", "start": [456, 1], "end": [459, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) : (id : L\u2082 \u2192\u2097\u2045R\u2046 L\u2082).comp f = f", "start": [462, 1], "end": [465, 6], "kind": "commanddeclaration"}, {"full_name": "LieHom.inverse", "code": "def inverse (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) (g : L\u2082 \u2192 L\u2081) (h\u2081 : Function.LeftInverse g f)\n    (h\u2082 : Function.RightInverse g f) : L\u2082 \u2192\u2097\u2045R\u2046 L\u2081 :=\n  { LinearMap.inverse f.toLinearMap g h\u2081 h\u2082 with\n    map_lie' := by\n      intros x y\n      calc\n        g \u2045x, y\u2046 = g \u2045f (g x), f (g y)\u2046 := by conv_lhs => rw [\u2190 h\u2082 x, \u2190 h\u2082 y]\n        _ = g (f \u2045g x, g y\u2046) := by rw [map_lie]\n        _ = \u2045g x, g y\u2046 := h\u2081 _\n         }", "start": [468, 1], "end": [478, 11], "kind": "commanddeclaration"}, {"full_name": "LieRingModule.compLieHom", "code": "def LieRingModule.compLieHom : LieRingModule L\u2081 M where\n  bracket x m := \u2045f x, m\u2046\n  lie_add x := lie_add (f x)\n  add_lie x y m := by simp only [LieHom.map_add, add_lie]\n  leibniz_lie x y m := by simp only [lie_lie, sub_add_cancel, LieHom.map_lie]", "start": [493, 1], "end": [500, 78], "kind": "commanddeclaration"}, {"full_name": "LieRingModule.compLieHom_apply", "code": "theorem LieRingModule.compLieHom_apply (x : L\u2081) (m : M) :\n    haveI := LieRingModule.compLieHom M f\n    \u2045x, m\u2046 = \u2045f x, m\u2046", "start": [503, 1], "end": [506, 6], "kind": "commanddeclaration"}, {"full_name": "LieModule.compLieHom", "code": "theorem LieModule.compLieHom [Module R M] [LieModule R L\u2082 M] :\n    @LieModule R L\u2081 M _ _ _ _ _ (LieRingModule.compLieHom M f)", "start": [509, 1], "end": [516, 61], "kind": "commanddeclaration"}, {"full_name": "LieEquiv", "code": "structure LieEquiv (R : Type u) (L : Type v) (L' : Type w) [CommRing R] [LieRing L] [LieAlgebra R L]\n  [LieRing L'] [LieAlgebra R L'] extends L \u2192\u2097\u2045R\u2046 L' where\n  \n  invFun : L' \u2192 L\n  \n  left_inv : Function.LeftInverse invFun toLieHom.toFun\n  \n  right_inv : Function.RightInverse invFun toLieHom.toFun", "start": [521, 1], "end": [533, 58], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.toLinearEquiv", "code": "def toLinearEquiv (f : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) : L\u2081 \u2243\u2097[R] L\u2082 :=\n  { f.toLieHom, f with }", "start": [547, 1], "end": [549, 25], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.hasCoeToLieHom", "code": "instance hasCoeToLieHom : Coe (L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) (L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) :=\n  \u27e8toLieHom\u27e9", "start": [552, 1], "end": [553, 13], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.hasCoeToLinearEquiv", "code": "instance hasCoeToLinearEquiv : Coe (L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) (L\u2081 \u2243\u2097[R] L\u2082) :=\n  \u27e8toLinearEquiv\u27e9", "start": [556, 1], "end": [557, 18], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.coe_to_lieHom", "code": "theorem coe_to_lieHom (e : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) : \u21d1(e : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) = e", "start": [568, 1], "end": [569, 6], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.coe_to_linearEquiv", "code": "@[simp]\ntheorem coe_to_linearEquiv (e : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) : \u21d1(e : L\u2081 \u2243\u2097[R] L\u2082) = e", "start": [572, 1], "end": [574, 6], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.to_linearEquiv_mk", "code": "@[simp]\ntheorem to_linearEquiv_mk (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) (g h\u2081 h\u2082) :\n    (mk f g h\u2081 h\u2082 : L\u2081 \u2243\u2097[R] L\u2082) =\n      { f with\n        invFun := g\n        left_inv := h\u2081\n        right_inv := h\u2082 }", "start": [577, 1], "end": [584, 6], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.coe_linearEquiv_injective", "code": "theorem coe_linearEquiv_injective : Injective ((\u2191) : (L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) \u2192 L\u2081 \u2243\u2097[R] L\u2082)", "start": [587, 1], "end": [592, 20], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.coe_injective", "code": "theorem coe_injective : @Injective (L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) (L\u2081 \u2192 L\u2082) (\u2191)", "start": [595, 1], "end": [596, 59], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.ext", "code": "@[ext]\ntheorem ext {f g : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082} (h : \u2200 x, f x = g x) : f = g", "start": [599, 1], "end": [601, 28], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.one_apply", "code": "@[simp]\ntheorem one_apply (x : L\u2081) : (1 : L\u2081 \u2243\u2097\u2045R\u2046 L\u2081) x = x", "start": [607, 1], "end": [609, 6], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.refl", "code": "def refl : L\u2081 \u2243\u2097\u2045R\u2046 L\u2081 :=\n  1", "start": [615, 1], "end": [617, 4], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.refl_apply", "code": "@[simp]\ntheorem refl_apply (x : L\u2081) : (refl : L\u2081 \u2243\u2097\u2045R\u2046 L\u2081) x = x", "start": [620, 1], "end": [622, 6], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.symm", "code": "@[symm]\ndef symm (e : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) : L\u2082 \u2243\u2097\u2045R\u2046 L\u2081 :=\n  { LieHom.inverse e.toLieHom e.invFun e.left_inv e.right_inv, e.toLinearEquiv.symm with }", "start": [625, 1], "end": [628, 91], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.symm_symm", "code": "@[simp]\ntheorem symm_symm (e : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) : e.symm.symm = e", "start": [631, 1], "end": [634, 6], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (e : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) : \u2200 x, e (e.symm x) = x", "start": [637, 1], "end": [639, 35], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (e : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) : \u2200 x, e.symm (e x) = x", "start": [642, 1], "end": [644, 35], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.refl_symm", "code": "@[simp]\ntheorem refl_symm : (refl : L\u2081 \u2243\u2097\u2045R\u2046 L\u2081).symm = refl", "start": [647, 1], "end": [649, 6], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.trans", "code": "@[trans]\ndef trans (e\u2081 : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) (e\u2082 : L\u2082 \u2243\u2097\u2045R\u2046 L\u2083) : L\u2081 \u2243\u2097\u2045R\u2046 L\u2083 :=\n  { LieHom.comp e\u2082.toLieHom e\u2081.toLieHom, LinearEquiv.trans e\u2081.toLinearEquiv e\u2082.toLinearEquiv with }", "start": [652, 1], "end": [655, 100], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.self_trans_symm", "code": "@[simp]\ntheorem self_trans_symm (e : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) : e.trans e.symm = refl", "start": [658, 1], "end": [660, 25], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.symm_trans_self", "code": "@[simp]\ntheorem symm_trans_self (e : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) : e.symm.trans e = refl", "start": [663, 1], "end": [665, 25], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.trans_apply", "code": "@[simp]\ntheorem trans_apply (e\u2081 : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) (e\u2082 : L\u2082 \u2243\u2097\u2045R\u2046 L\u2083) (x : L\u2081) : (e\u2081.trans e\u2082) x = e\u2082 (e\u2081 x)", "start": [668, 1], "end": [670, 6], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.symm_trans", "code": "@[simp]\ntheorem symm_trans (e\u2081 : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) (e\u2082 : L\u2082 \u2243\u2097\u2045R\u2046 L\u2083) :\n    (e\u2081.trans e\u2082).symm = e\u2082.symm.trans e\u2081.symm", "start": [673, 1], "end": [676, 6], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.bijective", "code": "protected theorem bijective (e : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) : Function.Bijective ((e : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) : L\u2081 \u2192 L\u2082)", "start": [679, 1], "end": [680, 28], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.injective", "code": "protected theorem injective (e : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) : Function.Injective ((e : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) : L\u2081 \u2192 L\u2082)", "start": [683, 1], "end": [684, 28], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.surjective", "code": "protected theorem surjective (e : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) :\n    Function.Surjective ((e : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) : L\u2081 \u2192 L\u2082)", "start": [687, 1], "end": [689, 29], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.ofBijective", "code": "@[simps!]\nnoncomputable def ofBijective (f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) (h : Function.Bijective f) : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082 :=\n  { LinearEquiv.ofBijective (f : L\u2081 \u2192\u2097[R] L\u2082)\n      h with\n    toFun := f\n    map_lie' := by intros x y; exact f.map_lie x y }", "start": [692, 1], "end": [698, 53], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom", "code": "structure LieModuleHom extends M \u2192\u2097[R] N where\n  \n  map_lie' : \u2200 {x : L} {m : M}, toFun \u2045x, m\u2046 = \u2045x, toFun m\u2046", "start": [717, 1], "end": [722, 60], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.coe_toLinearMap", "code": "@[simp, norm_cast]\ntheorem coe_toLinearMap (f : M \u2192\u2097\u2045R,L\u2046 N) : ((f : M \u2192\u2097[R] N) : M \u2192 N) = f", "start": [742, 1], "end": [744, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.map_smul", "code": "@[simp]\ntheorem map_smul (f : M \u2192\u2097\u2045R,L\u2046 N) (c : R) (x : M) : f (c \u2022 x) = c \u2022 f x", "start": [747, 1], "end": [749, 41], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.map_add", "code": "@[simp]\ntheorem map_add (f : M \u2192\u2097\u2045R,L\u2046 N) (x y : M) : f (x + y) = f x + f y", "start": [752, 1], "end": [754, 40], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.map_sub", "code": "@[simp]\ntheorem map_sub (f : M \u2192\u2097\u2045R,L\u2046 N) (x y : M) : f (x - y) = f x - f y", "start": [757, 1], "end": [759, 40], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.map_neg", "code": "@[simp]\ntheorem map_neg (f : M \u2192\u2097\u2045R,L\u2046 N) (x : M) : f (-x) = -f x", "start": [762, 1], "end": [764, 38], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.map_lie", "code": "@[simp]\ntheorem map_lie (f : M \u2192\u2097\u2045R,L\u2046 N) (x : L) (m : M) : f \u2045x, m\u2046 = \u2045x, f m\u2046", "start": [767, 1], "end": [769, 26], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.map_lie\u2082", "code": "theorem map_lie\u2082 (f : M \u2192\u2097\u2045R,L\u2046 N \u2192\u2097[R] P) (x : L) (m : M) (n : N) :\n    \u2045x, f m n\u2046 = f \u2045x, m\u2046 n + f m \u2045x, n\u2046", "start": [772, 1], "end": [773, 101], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.map_zero", "code": "@[simp]\ntheorem map_zero (f : M \u2192\u2097\u2045R,L\u2046 N) : f 0 = 0", "start": [776, 1], "end": [778, 37], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.id", "code": "def id : M \u2192\u2097\u2045R,L\u2046 M :=\n  { (LinearMap.id : M \u2192\u2097[R] M) with map_lie' := rfl }", "start": [781, 1], "end": [783, 54], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.coe_id", "code": "@[simp]\ntheorem coe_id : ((id : M \u2192\u2097\u2045R,L\u2046 M) : M \u2192 M) = _root_.id", "start": [786, 1], "end": [788, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.id_apply", "code": "theorem id_apply (x : M) : (id : M \u2192\u2097\u2045R,L\u2046 M) x = x", "start": [791, 1], "end": [792, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.coe_zero", "code": "@[norm_cast, simp]\ntheorem coe_zero : \u21d1(0 : M \u2192\u2097\u2045R,L\u2046 N) = 0", "start": [799, 1], "end": [801, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.zero_apply", "code": "theorem zero_apply (m : M) : (0 : M \u2192\u2097\u2045R,L\u2046 N) m = 0", "start": [804, 1], "end": [805, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.coe_injective", "code": "theorem coe_injective : @Function.Injective (M \u2192\u2097\u2045R,L\u2046 N) (M \u2192 N) (\u2191)", "start": [815, 1], "end": [817, 8], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.ext", "code": "@[ext]\ntheorem ext {f g : M \u2192\u2097\u2045R,L\u2046 N} (h : \u2200 m, f m = g m) : f = g", "start": [820, 1], "end": [822, 28], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.ext_iff", "code": "theorem ext_iff {f g : M \u2192\u2097\u2045R,L\u2046 N} : f = g \u2194 \u2200 m, f m = g m", "start": [825, 1], "end": [828, 14], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.congr_fun", "code": "theorem congr_fun {f g : M \u2192\u2097\u2045R,L\u2046 N} (h : f = g) (x : M) : f x = g x", "start": [831, 1], "end": [832, 10], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.mk_coe", "code": "@[simp]\ntheorem mk_coe (f : M \u2192\u2097\u2045R,L\u2046 N) (h) : (\u27e8f, h\u27e9 : M \u2192\u2097\u2045R,L\u2046 N) = f", "start": [835, 1], "end": [837, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : M \u2192\u2097[R] N) (h) : ((\u27e8f, h\u27e9 : M \u2192\u2097\u2045R,L\u2046 N) : M \u2192 N) = f", "start": [840, 1], "end": [842, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.coe_linear_mk", "code": "@[norm_cast]\ntheorem coe_linear_mk (f : M \u2192\u2097[R] N) (h) : ((\u27e8f, h\u27e9 : M \u2192\u2097\u2045R,L\u2046 N) : M \u2192\u2097[R] N) = f", "start": [845, 1], "end": [847, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.comp", "code": "def comp (f : N \u2192\u2097\u2045R,L\u2046 P) (g : M \u2192\u2097\u2045R,L\u2046 N) : M \u2192\u2097\u2045R,L\u2046 P :=\n  { LinearMap.comp f.toLinearMap g.toLinearMap with\n    map_lie' := by\n      intros x m\n      change f (g \u2045x, m\u2046) = \u2045x, f (g m)\u2046\n      rw [map_lie, map_lie] }", "start": [850, 1], "end": [856, 30], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.comp_apply", "code": "theorem comp_apply (f : N \u2192\u2097\u2045R,L\u2046 P) (g : M \u2192\u2097\u2045R,L\u2046 N) (m : M) : f.comp g m = f (g m)", "start": [859, 1], "end": [860, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.coe_comp", "code": "@[norm_cast, simp]\ntheorem coe_comp (f : N \u2192\u2097\u2045R,L\u2046 P) (g : M \u2192\u2097\u2045R,L\u2046 N) : \u21d1(f.comp g) = f \u2218 g", "start": [863, 1], "end": [865, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.coe_linearMap_comp", "code": "@[norm_cast, simp]\ntheorem coe_linearMap_comp (f : N \u2192\u2097\u2045R,L\u2046 P) (g : M \u2192\u2097\u2045R,L\u2046 N) :\n    (f.comp g : M \u2192\u2097[R] P) = (f : N \u2192\u2097[R] P).comp (g : M \u2192\u2097[R] N)", "start": [868, 1], "end": [871, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.inverse", "code": "def inverse (f : M \u2192\u2097\u2045R,L\u2046 N) (g : N \u2192 M) (h\u2081 : Function.LeftInverse g f)\n    (h\u2082 : Function.RightInverse g f) : N \u2192\u2097\u2045R,L\u2046 M :=\n  { LinearMap.inverse f.toLinearMap g h\u2081 h\u2082 with\n    map_lie' := by\n      intros x n\n      calc\n        g \u2045x, n\u2046 = g \u2045x, f (g n)\u2046 := by rw [h\u2082]\n        _ = g (f \u2045x, g n\u2046) := by rw [map_lie]\n        _ = \u2045x, g n\u2046 := h\u2081 _\n         }", "start": [874, 1], "end": [884, 11], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.coe_add", "code": "@[norm_cast, simp]\ntheorem coe_add (f g : M \u2192\u2097\u2045R,L\u2046 N) : \u21d1(f + g) = f + g", "start": [895, 1], "end": [897, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.add_apply", "code": "theorem add_apply (f g : M \u2192\u2097\u2045R,L\u2046 N) (m : M) : (f + g) m = f m + g m", "start": [900, 1], "end": [901, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.coe_sub", "code": "@[norm_cast, simp]\ntheorem coe_sub (f g : M \u2192\u2097\u2045R,L\u2046 N) : \u21d1(f - g) = f - g", "start": [904, 1], "end": [906, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.sub_apply", "code": "theorem sub_apply (f g : M \u2192\u2097\u2045R,L\u2046 N) (m : M) : (f - g) m = f m - g m", "start": [909, 1], "end": [910, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.coe_neg", "code": "@[norm_cast, simp]\ntheorem coe_neg (f : M \u2192\u2097\u2045R,L\u2046 N) : \u21d1(-f) = -f", "start": [913, 1], "end": [915, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.neg_apply", "code": "theorem neg_apply (f : M \u2192\u2097\u2045R,L\u2046 N) (m : M) : (-f) m = -f m", "start": [918, 1], "end": [919, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.hasNsmul", "code": "instance hasNsmul : SMul \u2115 (M \u2192\u2097\u2045R,L\u2046 N) where\n  smul n f := { n \u2022 (f : M \u2192\u2097[R] N) with map_lie' := by simp }", "start": [922, 1], "end": [923, 63], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.coe_nsmul", "code": "@[norm_cast, simp]\ntheorem coe_nsmul (n : \u2115) (f : M \u2192\u2097\u2045R,L\u2046 N) : \u21d1(n \u2022 f) = n \u2022 (\u21d1f)", "start": [926, 1], "end": [928, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.nsmul_apply", "code": "theorem nsmul_apply (n : \u2115) (f : M \u2192\u2097\u2045R,L\u2046 N) (m : M) : (n \u2022 f) m = n \u2022 f m", "start": [931, 1], "end": [932, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.hasZsmul", "code": "instance hasZsmul : SMul \u2124 (M \u2192\u2097\u2045R,L\u2046 N) where\n  smul z f := { z \u2022 (f : M \u2192\u2097[R] N) with map_lie' := by simp }", "start": [935, 1], "end": [936, 63], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.coe_zsmul", "code": "@[norm_cast, simp]\ntheorem coe_zsmul (z : \u2124) (f : M \u2192\u2097\u2045R,L\u2046 N) : \u21d1(z \u2022 f) = z \u2022 (\u21d1f)", "start": [939, 1], "end": [941, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.zsmul_apply", "code": "theorem zsmul_apply (z : \u2124) (f : M \u2192\u2097\u2045R,L\u2046 N) (m : M) : (z \u2022 f) m = z \u2022 f m", "start": [944, 1], "end": [945, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.coe_smul", "code": "@[norm_cast, simp]\ntheorem coe_smul (t : R) (f : M \u2192\u2097\u2045R,L\u2046 N) : \u21d1(t \u2022 f) = t \u2022 (\u21d1f)", "start": [954, 1], "end": [956, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleHom.smul_apply", "code": "theorem smul_apply (t : R) (f : M \u2192\u2097\u2045R,L\u2046 N) (m : M) : (t \u2022 f) m = t \u2022 f m", "start": [959, 1], "end": [960, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv", "code": "structure LieModuleEquiv extends M \u2192\u2097\u2045R,L\u2046 N where\n  \n  invFun : N \u2192 M\n  \n  left_inv : Function.LeftInverse invFun toFun\n  \n  right_inv : Function.RightInverse invFun toFun", "start": [970, 1], "end": [980, 49], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.toLinearEquiv", "code": "def toLinearEquiv (e : M \u2243\u2097\u2045R,L\u2046 N) : M \u2243\u2097[R] N :=\n  { e with }", "start": [992, 1], "end": [994, 13], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.toEquiv", "code": "def toEquiv (e : M \u2243\u2097\u2045R,L\u2046 N) : M \u2243 N :=\n  { e with }", "start": [997, 1], "end": [999, 13], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.hasCoeToEquiv", "code": "instance hasCoeToEquiv : CoeOut (M \u2243\u2097\u2045R,L\u2046 N) (M \u2243 N) :=\n  \u27e8toEquiv\u27e9", "start": [1002, 1], "end": [1003, 12], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.hasCoeToLieModuleHom", "code": "instance hasCoeToLieModuleHom : Coe (M \u2243\u2097\u2045R,L\u2046 N) (M \u2192\u2097\u2045R,L\u2046 N) :=\n  \u27e8toLieModuleHom\u27e9", "start": [1006, 1], "end": [1007, 19], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.hasCoeToLinearEquiv", "code": "instance hasCoeToLinearEquiv : CoeOut (M \u2243\u2097\u2045R,L\u2046 N) (M \u2243\u2097[R] N) :=\n  \u27e8toLinearEquiv\u27e9", "start": [1010, 1], "end": [1011, 18], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.coe_coe", "code": "@[simp] lemma coe_coe (e : M \u2243\u2097\u2045R,L\u2046 N) : \u21d1(e : M \u2192\u2097\u2045R,L\u2046 N) = e := rfl", "start": [1022, 1], "end": [1022, 72], "kind": "mathlibtacticlemma"}, {"full_name": "LieModuleEquiv.injective", "code": "theorem injective (e : M \u2243\u2097\u2045R,L\u2046 N) : Function.Injective e", "start": [1024, 1], "end": [1025, 22], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.surjective", "code": "theorem surjective (e : M \u2243\u2097\u2045R,L\u2046 N) : Function.Surjective e", "start": [1028, 1], "end": [1029, 23], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.toEquiv_mk", "code": "@[simp]\ntheorem toEquiv_mk (f : M \u2192\u2097\u2045R,L\u2046 N) (g : N \u2192 M) (h\u2081 h\u2082) :\n    toEquiv (mk f g h\u2081 h\u2082 : M \u2243\u2097\u2045R,L\u2046 N) = Equiv.mk f g h\u2081 h\u2082", "start": [1031, 1], "end": [1034, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : M \u2192\u2097\u2045R,L\u2046 N) (invFun h\u2081 h\u2082) :\n    ((\u27e8f, invFun, h\u2081, h\u2082\u27e9 : M \u2243\u2097\u2045R,L\u2046 N) : M \u2192 N) = f", "start": [1036, 1], "end": [1039, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.coe_to_lieModuleHom", "code": "theorem coe_to_lieModuleHom (e : M \u2243\u2097\u2045R,L\u2046 N) : \u21d1(e : M \u2192\u2097\u2045R,L\u2046 N) = e", "start": [1042, 1], "end": [1043, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.coe_to_linearEquiv", "code": "@[simp]\ntheorem coe_to_linearEquiv (e : M \u2243\u2097\u2045R,L\u2046 N) : ((e : M \u2243\u2097[R] N) : M \u2192 N) = e", "start": [1046, 1], "end": [1048, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.toEquiv_injective", "code": "theorem toEquiv_injective : Function.Injective (toEquiv : (M \u2243\u2097\u2045R,L\u2046 N) \u2192 M \u2243 N)", "start": [1051, 1], "end": [1056, 20], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.ext", "code": "@[ext]\ntheorem ext (e\u2081 e\u2082 : M \u2243\u2097\u2045R,L\u2046 N) (h : \u2200 m, e\u2081 m = e\u2082 m) : e\u2081 = e\u2082", "start": [1059, 1], "end": [1061, 34], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.one_apply", "code": "@[simp]\ntheorem one_apply (m : M) : (1 : M \u2243\u2097\u2045R,L\u2046 M) m = m", "start": [1067, 1], "end": [1069, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.refl", "code": "@[refl]\ndef refl : M \u2243\u2097\u2045R,L\u2046 M :=\n  1", "start": [1075, 1], "end": [1078, 4], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.refl_apply", "code": "@[simp]\ntheorem refl_apply (m : M) : (refl : M \u2243\u2097\u2045R,L\u2046 M) m = m", "start": [1081, 1], "end": [1083, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.symm", "code": "@[symm]\ndef symm (e : M \u2243\u2097\u2045R,L\u2046 N) : N \u2243\u2097\u2045R,L\u2046 M :=\n  { LieModuleHom.inverse e.toLieModuleHom e.invFun e.left_inv e.right_inv,\n    (e : M \u2243\u2097[R] N).symm with }", "start": [1086, 1], "end": [1090, 32], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (e : M \u2243\u2097\u2045R,L\u2046 N) : \u2200 x, e (e.symm x) = x", "start": [1093, 1], "end": [1095, 35], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (e : M \u2243\u2097\u2045R,L\u2046 N) : \u2200 x, e.symm (e x) = x", "start": [1098, 1], "end": [1100, 35], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.apply_eq_iff_eq_symm_apply", "code": "theorem apply_eq_iff_eq_symm_apply {m : M} {n : N} (e : M \u2243\u2097\u2045R,L\u2046 N) :\n    e m = n \u2194 m = e.symm n", "start": [1103, 1], "end": [1105, 41], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.symm_symm", "code": "@[simp]\ntheorem symm_symm (e : M \u2243\u2097\u2045R,L\u2046 N) : e.symm.symm = e", "start": [1107, 1], "end": [1109, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.trans", "code": "@[trans]\ndef trans (e\u2081 : M \u2243\u2097\u2045R,L\u2046 N) (e\u2082 : N \u2243\u2097\u2045R,L\u2046 P) : M \u2243\u2097\u2045R,L\u2046 P :=\n  { LieModuleHom.comp e\u2082.toLieModuleHom e\u2081.toLieModuleHom,\n    LinearEquiv.trans e\u2081.toLinearEquiv e\u2082.toLinearEquiv with }", "start": [1112, 1], "end": [1116, 63], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.trans_apply", "code": "@[simp]\ntheorem trans_apply (e\u2081 : M \u2243\u2097\u2045R,L\u2046 N) (e\u2082 : N \u2243\u2097\u2045R,L\u2046 P) (m : M) : (e\u2081.trans e\u2082) m = e\u2082 (e\u2081 m)", "start": [1119, 1], "end": [1121, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.symm_trans", "code": "@[simp]\ntheorem symm_trans (e\u2081 : M \u2243\u2097\u2045R,L\u2046 N) (e\u2082 : N \u2243\u2097\u2045R,L\u2046 P) :\n    (e\u2081.trans e\u2082).symm = e\u2082.symm.trans e\u2081.symm", "start": [1124, 1], "end": [1127, 6], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.self_trans_symm", "code": "@[simp]\ntheorem self_trans_symm (e : M \u2243\u2097\u2045R,L\u2046 N) : e.trans e.symm = refl", "start": [1130, 1], "end": [1132, 29], "kind": "commanddeclaration"}, {"full_name": "LieModuleEquiv.symm_trans_self", "code": "@[simp]\ntheorem symm_trans_self (e : M \u2243\u2097\u2045R,L\u2046 N) : e.symm.trans e = refl", "start": [1135, 1], "end": [1137, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/ContinuousFunction/Polynomial.lean", "imports": ["Mathlib/Topology/Algebra/StarSubalgebra.lean", "Mathlib/Topology/UnitInterval.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Algebra/Polynomial.lean", "Mathlib/Topology/ContinuousFunction/Algebra.lean"], "premises": [{"full_name": "Polynomial.toContinuousMap", "code": "@[simps]\ndef toContinuousMap (p : R[X]) : C(R, R) :=\n  \u27e8fun x : R => p.eval x, by continuity\u27e9", "start": [38, 1], "end": [43, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toContinuousMapOn", "code": "@[simps]\ndef toContinuousMapOn (p : R[X]) (X : Set R) : C(X, R) :=\n  \u27e8fun x : X => p.toContinuousMap x, Continuous.comp (by continuity) (by continuity)\u27e9", "start": [46, 1], "end": [54, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_continuousMap_apply", "code": "@[simp]\ntheorem aeval_continuousMap_apply (g : R[X]) (f : C(\u03b1, R)) (x : \u03b1) :\n    ((Polynomial.aeval f) g) x = g.eval (f x)", "start": [65, 1], "end": [72, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toContinuousMapAlgHom", "code": "@[simps]\ndef toContinuousMapAlgHom : R[X] \u2192\u2090[R] C(R, R) where\n  toFun p := p.toContinuousMap\n  map_zero' := by\n    ext\n    simp\n  map_add' _ _ := by\n    ext\n    simp\n  map_one' := by\n    ext\n    simp\n  map_mul' _ _ := by\n    ext\n    simp\n  commutes' _ := by\n    ext\n    simp [Algebra.algebraMap_eq_smul_one]", "start": [81, 1], "end": [100, 42], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toContinuousMapOnAlgHom", "code": "@[simps]\ndef toContinuousMapOnAlgHom (X : Set R) : R[X] \u2192\u2090[R] C(X, R) where\n  toFun p := p.toContinuousMapOn X\n  map_zero' := by\n    ext\n    simp\n  map_add' _ _ := by\n    ext\n    simp\n  map_one' := by\n    ext\n    simp\n  map_mul' _ _ := by\n    ext\n    simp\n  commutes' _ := by\n    ext\n    simp [Algebra.algebraMap_eq_smul_one]", "start": [103, 1], "end": [122, 42], "kind": "commanddeclaration"}, {"full_name": "polynomialFunctions", "code": "noncomputable def polynomialFunctions (X : Set R) : Subalgebra R C(X, R) :=\n  (\u22a4 : Subalgebra R R[X]).map (Polynomial.toContinuousMapOnAlgHom X)", "start": [133, 1], "end": [139, 69], "kind": "commanddeclaration"}, {"full_name": "polynomialFunctions_coe", "code": "@[simp]\ntheorem polynomialFunctions_coe (X : Set R) :\n    (polynomialFunctions X : Set C(X, R)) = Set.range (Polynomial.toContinuousMapOnAlgHom X)", "start": [142, 1], "end": [146, 29], "kind": "commanddeclaration"}, {"full_name": "polynomialFunctions_separatesPoints", "code": "theorem polynomialFunctions_separatesPoints (X : Set R) : (polynomialFunctions X).SeparatesPoints", "start": [153, 1], "end": [158, 37], "kind": "commanddeclaration"}, {"full_name": "polynomialFunctions.comap_compRightAlgHom_iccHomeoI", "code": "theorem polynomialFunctions.comap_compRightAlgHom_iccHomeoI (a b : \u211d) (h : a < b) :\n    (polynomialFunctions I).comap (compRightAlgHom \u211d \u211d (iccHomeoI a b h).symm.toContinuousMap) =\n      polynomialFunctions (Set.Icc a b)", "start": [165, 1], "end": [205, 22], "kind": "commanddeclaration"}, {"full_name": "polynomialFunctions.eq_adjoin_X", "code": "theorem polynomialFunctions.eq_adjoin_X (s : Set R) :\n    polynomialFunctions s = Algebra.adjoin R {toContinuousMapOnAlgHom s X}", "start": [209, 1], "end": [221, 68], "kind": "commanddeclaration"}, {"full_name": "polynomialFunctions.le_equalizer", "code": "theorem polynomialFunctions.le_equalizer {A : Type*} [Semiring A] [Algebra R A] (s : Set R)\n    (\u03c6 \u03c8 : C(s, R) \u2192\u2090[R] A)\n    (h : \u03c6 (toContinuousMapOnAlgHom s X) = \u03c8 (toContinuousMapOnAlgHom s X)) :\n    polynomialFunctions s \u2264 \u03c6.equalizer \u03c8", "start": [223, 1], "end": [228, 82], "kind": "commanddeclaration"}, {"full_name": "polynomialFunctions.starClosure_eq_adjoin_X", "code": "theorem polynomialFunctions.starClosure_eq_adjoin_X [StarRing R] [ContinuousStar R] (s : Set R) :\n    (polynomialFunctions s).starClosure = adjoin R {toContinuousMapOnAlgHom s X}", "start": [232, 1], "end": [234, 71], "kind": "commanddeclaration"}, {"full_name": "polynomialFunctions.starClosure_le_equalizer", "code": "theorem polynomialFunctions.starClosure_le_equalizer {A : Type*} [StarRing R] [ContinuousStar R]\n    [Semiring A] [StarRing A] [Algebra R A] (s : Set R) (\u03c6 \u03c8 : C(s, R) \u2192\u22c6\u2090[R] A)\n    (h : \u03c6 (toContinuousMapOnAlgHom s X) = \u03c8 (toContinuousMapOnAlgHom s X)) :\n    (polynomialFunctions s).starClosure \u2264 StarAlgHom.equalizer \u03c6 \u03c8", "start": [236, 1], "end": [241, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Polynomial/Bernstein.lean", "imports": ["Mathlib/RingTheory/Polynomial/Pochhammer.lean", "Mathlib/Data/Polynomial/AlgebraMap.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Polynomial/Derivative.lean", "Mathlib/Data/MvPolynomial/PDeriv.lean", "Mathlib/LinearAlgebra/LinearIndependent.lean", "Mathlib/Data/Nat/Choose/Sum.lean"], "premises": [{"full_name": "bernsteinPolynomial", "code": "def bernsteinPolynomial (n \u03bd : \u2115) : R[X] :=\n  (choose n \u03bd : R[X]) * X ^ \u03bd * (1 - X) ^ (n - \u03bd)", "start": [47, 1], "end": [52, 50], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.eq_zero_of_lt", "code": "theorem eq_zero_of_lt {n \u03bd : \u2115} (h : n < \u03bd) : bernsteinPolynomial R n \u03bd = 0", "start": [61, 1], "end": [62, 57], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.map", "code": "@[simp]\ntheorem map (f : R \u2192+* S) (n \u03bd : \u2115) :\n    (bernsteinPolynomial R n \u03bd).map f = bernsteinPolynomial S n \u03bd", "start": [69, 1], "end": [71, 99], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.flip", "code": "theorem flip (n \u03bd : \u2115) (h : \u03bd \u2264 n) :\n    (bernsteinPolynomial R n \u03bd).comp (1 - X) = bernsteinPolynomial R n (n - \u03bd)", "start": [76, 1], "end": [78, 65], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.flip'", "code": "theorem flip' (n \u03bd : \u2115) (h : \u03bd \u2264 n) :\n    bernsteinPolynomial R n \u03bd = (bernsteinPolynomial R n (n - \u03bd)).comp (1 - X)", "start": [81, 1], "end": [83, 47], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.eval_at_0", "code": "theorem eval_at_0 (n \u03bd : \u2115) : (bernsteinPolynomial R n \u03bd).eval 0 = if \u03bd = 0 then 1 else 0", "start": [86, 1], "end": [90, 43], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.eval_at_1", "code": "theorem eval_at_1 (n \u03bd : \u2115) : (bernsteinPolynomial R n \u03bd).eval 1 = if \u03bd = n then 1 else 0", "start": [93, 1], "end": [99, 24], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.derivative_succ_aux", "code": "theorem derivative_succ_aux (n \u03bd : \u2115) :\n    Polynomial.derivative (bernsteinPolynomial R (n + 1) (\u03bd + 1)) =\n      (n + 1) * (bernsteinPolynomial R n \u03bd - bernsteinPolynomial R n (\u03bd + 1))", "start": [102, 1], "end": [131, 21], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.derivative_succ", "code": "theorem derivative_succ (n \u03bd : \u2115) : Polynomial.derivative (bernsteinPolynomial R n (\u03bd + 1)) =\n    n * (bernsteinPolynomial R (n - 1) \u03bd - bernsteinPolynomial R (n - 1) (\u03bd + 1))", "start": [134, 1], "end": [138, 50], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.derivative_zero", "code": "theorem derivative_zero (n : \u2115) :\n    Polynomial.derivative (bernsteinPolynomial R n 0) = -n * bernsteinPolynomial R (n - 1) 0", "start": [141, 1], "end": [143, 56], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.iterate_derivative_at_0_eq_zero_of_lt", "code": "theorem iterate_derivative_at_0_eq_zero_of_lt (n : \u2115) {\u03bd k : \u2115} :\n    k < \u03bd \u2192 (Polynomial.derivative^[k] (bernsteinPolynomial R n \u03bd)).eval 0 = 0", "start": [146, 1], "end": [161, 67], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.iterate_derivative_succ_at_0_eq_zero", "code": "@[simp]\ntheorem iterate_derivative_succ_at_0_eq_zero (n \u03bd : \u2115) :\n    (Polynomial.derivative^[\u03bd] (bernsteinPolynomial R n (\u03bd + 1))).eval 0 = 0", "start": [164, 1], "end": [167, 59], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.iterate_derivative_at_0", "code": "@[simp]\ntheorem iterate_derivative_at_0 (n \u03bd : \u2115) :\n    (Polynomial.derivative^[\u03bd] (bernsteinPolynomial R n \u03bd)).eval 0 =\n      (ascPochhammer R \u03bd).eval ((n - (\u03bd - 1) : \u2115) : R)", "start": [172, 1], "end": [193, 44], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.iterate_derivative_at_0_ne_zero", "code": "theorem iterate_derivative_at_0_ne_zero [CharZero R] (n \u03bd : \u2115) (h : \u03bd \u2264 n) :\n    (Polynomial.derivative^[\u03bd] (bernsteinPolynomial R n \u03bd)).eval 0 \u2260 0", "start": [196, 1], "end": [206, 71], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.iterate_derivative_at_1_eq_zero_of_lt", "code": "theorem iterate_derivative_at_1_eq_zero_of_lt (n : \u2115) {\u03bd k : \u2115} :\n    k < n - \u03bd \u2192 (Polynomial.derivative^[k] (bernsteinPolynomial R n \u03bd)).eval 1 = 0", "start": [215, 1], "end": [219, 75], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.iterate_derivative_at_1", "code": "@[simp]\ntheorem iterate_derivative_at_1 (n \u03bd : \u2115) (h : \u03bd \u2264 n) :\n    (Polynomial.derivative^[n - \u03bd] (bernsteinPolynomial R n \u03bd)).eval 1 =\n      (-1) ^ (n - \u03bd) * (ascPochhammer R (n - \u03bd)).eval (\u03bd + 1 : R)", "start": [222, 1], "end": [232, 82], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.iterate_derivative_at_1_ne_zero", "code": "theorem iterate_derivative_at_1_ne_zero [CharZero R] (n \u03bd : \u2115) (h : \u03bd \u2264 n) :\n    (Polynomial.derivative^[n - \u03bd] (bernsteinPolynomial R n \u03bd)).eval 1 \u2260 0", "start": [235, 1], "end": [239, 53], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.linearIndependent_aux", "code": "theorem linearIndependent_aux (n k : \u2115) (h : k \u2264 n + 1) :\n    LinearIndependent \u211a fun \u03bd : Fin k => bernsteinPolynomial \u211a n \u03bd", "start": [244, 1], "end": [275, 30], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.linearIndependent", "code": "theorem linearIndependent (n : \u2115) :\n    LinearIndependent \u211a fun \u03bd : Fin (n + 1) => bernsteinPolynomial \u211a n \u03bd", "start": [278, 1], "end": [287, 41], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.sum", "code": "theorem sum (n : \u2115) : (\u2211 \u03bd in Finset.range (n + 1), bernsteinPolynomial R n \u03bd) = 1", "start": [290, 1], "end": [295, 21], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.sum_smul", "code": "theorem sum_smul (n : \u2115) :\n    (\u2211 \u03bd in Finset.range (n + 1), \u03bd \u2022 bernsteinPolynomial R n \u03bd) = n \u2022 X", "start": [302, 1], "end": [336, 25], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.sum_mul_smul", "code": "theorem sum_mul_smul (n : \u2115) :\n    (\u2211 \u03bd in Finset.range (n + 1), (\u03bd * (\u03bd - 1)) \u2022 bernsteinPolynomial R n \u03bd) =\n      (n * (n - 1)) \u2022 X ^ 2", "start": [339, 1], "end": [379, 20], "kind": "commanddeclaration"}, {"full_name": "bernsteinPolynomial.variance", "code": "theorem variance (n : \u2115) :\n    (\u2211 \u03bd in Finset.range (n + 1), (n \u2022 Polynomial.X - (\u03bd : R[X])) ^ 2 * bernsteinPolynomial R n \u03bd) =\n      n \u2022 Polynomial.X * ((1 : R[X]) - Polynomial.X)", "start": [382, 1], "end": [411, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/Haar/NormedSpace.lean", "imports": ["Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean", "Mathlib/MeasureTheory/Integral/Bochner.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.Measure.MapContinuousLinearEquiv.isAddHaarMeasure", "code": "instance MapContinuousLinearEquiv.isAddHaarMeasure (e : G \u2243L[\ud835\udd5c] H) : IsAddHaarMeasure (\u03bc.map e) :=\n  e.toAddEquiv.isAddHaarMeasure_map _ e.continuous e.symm.continuous", "start": [43, 1], "end": [44, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.MapLinearEquiv.isAddHaarMeasure", "code": "instance MapLinearEquiv.isAddHaarMeasure (e : G \u2243\u2097[\ud835\udd5c] H) : IsAddHaarMeasure (\u03bc.map e) :=\n  MapContinuousLinearEquiv.isAddHaarMeasure _ e.toContinuousLinearEquiv", "start": [50, 1], "end": [51, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.integral_comp_smul", "code": "theorem integral_comp_smul (f : E \u2192 F) (R : \u211d) :\n    (\u222b x, f (R \u2022 x) \u2202\u03bc) = |(R ^ finrank \u211d E)\u207b\u00b9| \u2022 \u222b x, f x \u2202\u03bc", "start": [62, 1], "end": [82, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.integral_comp_smul_of_nonneg", "code": "theorem integral_comp_smul_of_nonneg (f : E \u2192 F) (R : \u211d) {hR : 0 \u2264 R} :\n    (\u222b x, f (R \u2022 x) \u2202\u03bc) = (R ^ finrank \u211d E)\u207b\u00b9 \u2022 \u222b x, f x \u2202\u03bc", "start": [85, 1], "end": [90, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.integral_comp_inv_smul", "code": "theorem integral_comp_inv_smul (f : E \u2192 F) (R : \u211d) :\n    (\u222b x, f (R\u207b\u00b9 \u2022 x) \u2202\u03bc) = |R ^ finrank \u211d E| \u2022 \u222b x, f x \u2202\u03bc", "start": [93, 1], "end": [98, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.integral_comp_inv_smul_of_nonneg", "code": "theorem integral_comp_inv_smul_of_nonneg (f : E \u2192 F) {R : \u211d} (hR : 0 \u2264 R) :\n    (\u222b x, f (R\u207b\u00b9 \u2022 x) \u2202\u03bc) = R ^ finrank \u211d E \u2022 \u222b x, f x \u2202\u03bc", "start": [101, 1], "end": [106, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.integral_comp_mul_left", "code": "theorem integral_comp_mul_left (g : \u211d \u2192 F) (a : \u211d) : (\u222b x : \u211d, g (a * x)) = |a\u207b\u00b9| \u2022 \u222b y : \u211d, g y", "start": [109, 1], "end": [110, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.integral_comp_inv_mul_left", "code": "theorem integral_comp_inv_mul_left (g : \u211d \u2192 F) (a : \u211d) :\n    (\u222b x : \u211d, g (a\u207b\u00b9 * x)) = |a| \u2022 \u222b y : \u211d, g y", "start": [113, 1], "end": [115, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.integral_comp_mul_right", "code": "theorem integral_comp_mul_right (g : \u211d \u2192 F) (a : \u211d) : (\u222b x : \u211d, g (x * a)) = |a\u207b\u00b9| \u2022 \u222b y : \u211d, g y", "start": [118, 1], "end": [119, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.integral_comp_inv_mul_right", "code": "theorem integral_comp_inv_mul_right (g : \u211d \u2192 F) (a : \u211d) :\n    (\u222b x : \u211d, g (x * a\u207b\u00b9)) = |a| \u2022 \u222b y : \u211d, g y", "start": [122, 1], "end": [124, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.integral_comp_div", "code": "theorem integral_comp_div (g : \u211d \u2192 F) (a : \u211d) : (\u222b x : \u211d, g (x / a)) = |a| \u2022 \u222b y : \u211d, g y", "start": [127, 1], "end": [128, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.integrable_comp_smul_iff", "code": "theorem integrable_comp_smul_iff {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [MeasurableSpace E] [BorelSpace E] [FiniteDimensional \u211d E] (\u03bc : Measure E) [IsAddHaarMeasure \u03bc]\n    (f : E \u2192 F) {R : \u211d} (hR : R \u2260 0) : Integrable (fun x => f (R \u2022 x)) \u03bc \u2194 Integrable f \u03bc", "start": [135, 1], "end": [149, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.comp_smul", "code": "theorem Integrable.comp_smul {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [MeasurableSpace E] [BorelSpace E] [FiniteDimensional \u211d E] {\u03bc : Measure E} [IsAddHaarMeasure \u03bc]\n    {f : E \u2192 F} (hf : Integrable f \u03bc) {R : \u211d} (hR : R \u2260 0) : Integrable (fun x => f (R \u2022 x)) \u03bc", "start": [152, 1], "end": [155, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.integrable_comp_mul_left_iff", "code": "theorem integrable_comp_mul_left_iff (g : \u211d \u2192 F) {R : \u211d} (hR : R \u2260 0) :\n    (Integrable fun x => g (R * x)) \u2194 Integrable g", "start": [158, 1], "end": [160, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.comp_mul_left'", "code": "theorem Integrable.comp_mul_left' {g : \u211d \u2192 F} (hg : Integrable g) {R : \u211d} (hR : R \u2260 0) :\n    Integrable fun x => g (R * x)", "start": [163, 1], "end": [165, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.integrable_comp_mul_right_iff", "code": "theorem integrable_comp_mul_right_iff (g : \u211d \u2192 F) {R : \u211d} (hR : R \u2260 0) :\n    (Integrable fun x => g (x * R)) \u2194 Integrable g", "start": [168, 1], "end": [170, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.comp_mul_right'", "code": "theorem Integrable.comp_mul_right' {g : \u211d \u2192 F} (hg : Integrable g) {R : \u211d} (hR : R \u2260 0) :\n    Integrable fun x => g (x * R)", "start": [173, 1], "end": [175, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.integrable_comp_div_iff", "code": "theorem integrable_comp_div_iff (g : \u211d \u2192 F) {R : \u211d} (hR : R \u2260 0) :\n    (Integrable fun x => g (x / R)) \u2194 Integrable g", "start": [178, 1], "end": [180, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.comp_div", "code": "theorem Integrable.comp_div {g : \u211d \u2192 F} (hg : Integrable g) {R : \u211d} (hR : R \u2260 0) :\n    Integrable fun x => g (x / R)", "start": [183, 1], "end": [185, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Integral/FundThmCalculus.lean", "imports": ["Mathlib/Analysis/Calculus/Deriv/Comp.lean", "Mathlib/Analysis/Calculus/Deriv/Slope.lean", "Mathlib/Analysis/Calculus/FDeriv/Measurable.lean", "Mathlib/Analysis/Calculus/Deriv/Add.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/MeasureTheory/Integral/IntervalIntegral.lean", "Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean", "Mathlib/Analysis/Calculus/Deriv/Mul.lean", "Mathlib/Analysis/NormedSpace/Dual.lean"], "premises": [{"full_name": "intervalIntegral.FTCFilter", "code": "class FTCFilter (a : outParam \u211d) (outer : Filter \u211d) (inner : outParam <| Filter \u211d) extends\n    TendstoIxxClass Ioc outer inner : Prop where\n  pure_le : pure a \u2264 outer\n  le_nhds : inner \u2264 \ud835\udcdd a\n  [meas_gen : IsMeasurablyGenerated inner]", "start": [195, 1], "end": [201, 43], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.FTCFilter.pure", "code": "instance pure (a : \u211d) : FTCFilter a (pure a) \u22a5 where\n  pure_le := le_rfl\n  le_nhds := bot_le", "start": [209, 1], "end": [211, 20], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.FTCFilter.nhdsWithinSingleton", "code": "instance nhdsWithinSingleton (a : \u211d) : FTCFilter a (\ud835\udcdd[{a}] a) \u22a5 := by\n  rw [nhdsWithin, principal_singleton, inf_eq_right.2 (pure_le_nhds a)]; infer_instance", "start": [214, 1], "end": [215, 88], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.FTCFilter.finiteAt_inner", "code": "theorem finiteAt_inner {a : \u211d} (l : Filter \u211d) {l'} [h : FTCFilter a l l'] {\u03bc : Measure \u211d}\n    [IsLocallyFiniteMeasure \u03bc] : \u03bc.FiniteAtFilter l'", "start": [218, 1], "end": [220, 44], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.FTCFilter.nhds", "code": "instance nhds (a : \u211d) : FTCFilter a (\ud835\udcdd a) (\ud835\udcdd a) where\n  pure_le := pure_le_nhds a\n  le_nhds := le_rfl", "start": [223, 1], "end": [225, 20], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.FTCFilter.nhdsUniv", "code": "instance nhdsUniv (a : \u211d) : FTCFilter a (\ud835\udcdd[univ] a) (\ud835\udcdd a) := by rw [nhdsWithin_univ]; infer_instance", "start": [228, 1], "end": [228, 101], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.FTCFilter.nhdsLeft", "code": "instance nhdsLeft (a : \u211d) : FTCFilter a (\ud835\udcdd[\u2264] a) (\ud835\udcdd[\u2264] a) where\n  pure_le := pure_le_nhdsWithin right_mem_Iic\n  le_nhds := inf_le_left", "start": [231, 1], "end": [233, 25], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.FTCFilter.nhdsRight", "code": "instance nhdsRight (a : \u211d) : FTCFilter a (\ud835\udcdd[\u2265] a) (\ud835\udcdd[>] a) where\n  pure_le := pure_le_nhdsWithin left_mem_Ici\n  le_nhds := inf_le_left", "start": [236, 1], "end": [238, 25], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.FTCFilter.nhdsIcc", "code": "instance nhdsIcc {x a b : \u211d} [h : Fact (x \u2208 Icc a b)] :\n    FTCFilter x (\ud835\udcdd[Icc a b] x) (\ud835\udcdd[Icc a b] x) where\n  pure_le := pure_le_nhdsWithin h.out\n  le_nhds := inf_le_left", "start": [241, 1], "end": [244, 25], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.FTCFilter.nhdsUIcc", "code": "instance nhdsUIcc {x a b : \u211d} [h : Fact (x \u2208 [[a, b]])] :\n    FTCFilter x (\ud835\udcdd[[[a, b]]] x) (\ud835\udcdd[[[a, b]]] x) :=\n  .nhdsIcc (h := h)", "start": [247, 1], "end": [249, 20], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.measure_integral_sub_linear_isLittleO_of_tendsto_ae'", "code": "theorem measure_integral_sub_linear_isLittleO_of_tendsto_ae' [IsMeasurablyGenerated l']\n    [TendstoIxxClass Ioc l l'] (hfm : StronglyMeasurableAtFilter f l' \u03bc)\n    (hf : Tendsto f (l' \u2293 \u03bc.ae) (\ud835\udcdd c)) (hl : \u03bc.FiniteAtFilter l') (hu : Tendsto u lt l)\n    (hv : Tendsto v lt l) :\n    (fun t => (\u222b x in u t..v t, f x \u2202\u03bc) - \u222b _ in u t..v t, c \u2202\u03bc) =o[lt] fun t =>\n      \u222b _ in u t..v t, (1 : \u211d) \u2202\u03bc", "start": [261, 1], "end": [287, 9], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.measure_integral_sub_linear_isLittleO_of_tendsto_ae_of_le'", "code": "theorem measure_integral_sub_linear_isLittleO_of_tendsto_ae_of_le' [IsMeasurablyGenerated l']\n    [TendstoIxxClass Ioc l l'] (hfm : StronglyMeasurableAtFilter f l' \u03bc)\n    (hf : Tendsto f (l' \u2293 \u03bc.ae) (\ud835\udcdd c)) (hl : \u03bc.FiniteAtFilter l') (hu : Tendsto u lt l)\n    (hv : Tendsto v lt l) (huv : u \u2264\u1da0[lt] v) :\n    (fun t => (\u222b x in u t..v t, f x \u2202\u03bc) - (\u03bc (Ioc (u t) (v t))).toReal \u2022 c) =o[lt] fun t =>\n      (\u03bc <| Ioc (u t) (v t)).toReal", "start": [290, 1], "end": [308, 57], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.measure_integral_sub_linear_isLittleO_of_tendsto_ae_of_ge'", "code": "theorem measure_integral_sub_linear_isLittleO_of_tendsto_ae_of_ge' [IsMeasurablyGenerated l']\n    [TendstoIxxClass Ioc l l'] (hfm : StronglyMeasurableAtFilter f l' \u03bc)\n    (hf : Tendsto f (l' \u2293 \u03bc.ae) (\ud835\udcdd c)) (hl : \u03bc.FiniteAtFilter l') (hu : Tendsto u lt l)\n    (hv : Tendsto v lt l) (huv : v \u2264\u1da0[lt] u) :\n    (fun t => (\u222b x in u t..v t, f x \u2202\u03bc) + (\u03bc (Ioc (v t) (u t))).toReal \u2022 c) =o[lt] fun t =>\n      (\u03bc <| Ioc (v t) (u t)).toReal", "start": [311, 1], "end": [329, 53], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.measure_integral_sub_linear_isLittleO_of_tendsto_ae", "code": "theorem measure_integral_sub_linear_isLittleO_of_tendsto_ae\n    (hfm : StronglyMeasurableAtFilter f l' \u03bc) (hf : Tendsto f (l' \u2293 \u03bc.ae) (\ud835\udcdd c))\n    (hu : Tendsto u lt l) (hv : Tendsto v lt l) :\n    (fun t => (\u222b x in u t..v t, f x \u2202\u03bc) - \u222b _ in u t..v t, c \u2202\u03bc) =o[lt] fun t =>\n      \u222b _ in u t..v t, (1 : \u211d) \u2202\u03bc", "start": [336, 1], "end": [353, 97], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.measure_integral_sub_linear_isLittleO_of_tendsto_ae_of_le", "code": "theorem measure_integral_sub_linear_isLittleO_of_tendsto_ae_of_le\n    (hfm : StronglyMeasurableAtFilter f l' \u03bc) (hf : Tendsto f (l' \u2293 \u03bc.ae) (\ud835\udcdd c))\n    (hu : Tendsto u lt l) (hv : Tendsto v lt l) (huv : u \u2264\u1da0[lt] v) :\n    (fun t => (\u222b x in u t..v t, f x \u2202\u03bc) - (\u03bc (Ioc (u t) (v t))).toReal \u2022 c) =o[lt] fun t =>\n      (\u03bc <| Ioc (u t) (v t)).toReal", "start": [356, 1], "end": [371, 11], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.measure_integral_sub_linear_isLittleO_of_tendsto_ae_of_ge", "code": "theorem measure_integral_sub_linear_isLittleO_of_tendsto_ae_of_ge\n    (hfm : StronglyMeasurableAtFilter f l' \u03bc) (hf : Tendsto f (l' \u2293 \u03bc.ae) (\ud835\udcdd c))\n    (hu : Tendsto u lt l) (hv : Tendsto v lt l) (huv : v \u2264\u1da0[lt] u) :\n    (fun t => (\u222b x in u t..v t, f x \u2202\u03bc) + (\u03bc (Ioc (v t) (u t))).toReal \u2022 c) =o[lt] fun t =>\n      (\u03bc <| Ioc (v t) (u t)).toReal", "start": [374, 1], "end": [389, 11], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae", "code": "theorem measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae\n    (hab : IntervalIntegrable f \u03bc a b) (hmeas_a : StronglyMeasurableAtFilter f la' \u03bc)\n    (hmeas_b : StronglyMeasurableAtFilter f lb' \u03bc) (ha_lim : Tendsto f (la' \u2293 \u03bc.ae) (\ud835\udcdd ca))\n    (hb_lim : Tendsto f (lb' \u2293 \u03bc.ae) (\ud835\udcdd cb)) (hua : Tendsto ua lt la) (hva : Tendsto va lt la)\n    (hub : Tendsto ub lt lb) (hvb : Tendsto vb lt lb) :\n    (fun t =>\n        ((\u222b x in va t..vb t, f x \u2202\u03bc) - \u222b x in ua t..ub t, f x \u2202\u03bc) -\n          ((\u222b _ in ub t..vb t, cb \u2202\u03bc) - \u222b _ in ua t..va t, ca \u2202\u03bc)) =o[lt]\n      fun t => \u2016\u222b _ in ua t..va t, (1 : \u211d) \u2202\u03bc\u2016 + \u2016\u222b _ in ub t..vb t, (1 : \u211d) \u2202\u03bc\u2016", "start": [396, 1], "end": [435, 64], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_right", "code": "theorem measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_right\n    (hab : IntervalIntegrable f \u03bc a b) (hmeas : StronglyMeasurableAtFilter f lb' \u03bc)\n    (hf : Tendsto f (lb' \u2293 \u03bc.ae) (\ud835\udcdd c)) (hu : Tendsto u lt lb) (hv : Tendsto v lt lb) :\n    (fun t => ((\u222b x in a..v t, f x \u2202\u03bc) - \u222b x in a..u t, f x \u2202\u03bc) - \u222b _ in u t..v t, c \u2202\u03bc) =o[lt]\n      fun t => \u222b _ in u t..v t, (1 : \u211d) \u2202\u03bc", "start": [438, 1], "end": [455, 75], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_left", "code": "theorem measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_left\n    (hab : IntervalIntegrable f \u03bc a b) (hmeas : StronglyMeasurableAtFilter f la' \u03bc)\n    (hf : Tendsto f (la' \u2293 \u03bc.ae) (\ud835\udcdd c)) (hu : Tendsto u lt la) (hv : Tendsto v lt la) :\n    (fun t => ((\u222b x in v t..b, f x \u2202\u03bc) - \u222b x in u t..b, f x \u2202\u03bc) + \u222b _ in u t..v t, c \u2202\u03bc) =o[lt]\n      fun t => \u222b _ in u t..v t, (1 : \u211d) \u2202\u03bc", "start": [458, 1], "end": [475, 72], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_sub_linear_isLittleO_of_tendsto_ae", "code": "theorem integral_sub_linear_isLittleO_of_tendsto_ae [FTCFilter a l l']\n    (hfm : StronglyMeasurableAtFilter f l') (hf : Tendsto f (l' \u2293 volume.ae) (\ud835\udcdd c)) {u v : \u03b9 \u2192 \u211d}\n    (hu : Tendsto u lt l) (hv : Tendsto v lt l) :\n    (fun t => (\u222b x in u t..v t, f x) - (v t - u t) \u2022 c) =o[lt] (v - u)", "start": [501, 1], "end": [510, 96], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae", "code": "theorem integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae\n    (hab : IntervalIntegrable f volume a b) (hmeas_a : StronglyMeasurableAtFilter f la')\n    (hmeas_b : StronglyMeasurableAtFilter f lb') (ha_lim : Tendsto f (la' \u2293 volume.ae) (\ud835\udcdd ca))\n    (hb_lim : Tendsto f (lb' \u2293 volume.ae) (\ud835\udcdd cb)) (hua : Tendsto ua lt la) (hva : Tendsto va lt la)\n    (hub : Tendsto ub lt lb) (hvb : Tendsto vb lt lb) :\n    (fun t =>\n        ((\u222b x in va t..vb t, f x) - \u222b x in ua t..ub t, f x) -\n          ((vb t - ub t) \u2022 cb - (va t - ua t) \u2022 ca)) =o[lt]\n      fun t => \u2016va t - ua t\u2016 + \u2016vb t - ub t\u2016", "start": [513, 1], "end": [534, 36], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_right", "code": "theorem integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_right\n    (hab : IntervalIntegrable f volume a b) (hmeas : StronglyMeasurableAtFilter f lb')\n    (hf : Tendsto f (lb' \u2293 volume.ae) (\ud835\udcdd c)) (hu : Tendsto u lt lb) (hv : Tendsto v lt lb) :\n    (fun t => ((\u222b x in a..v t, f x) - \u222b x in a..u t, f x) - (v t - u t) \u2022 c) =o[lt] (v - u)", "start": [537, 1], "end": [549, 94], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_left", "code": "theorem integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_left\n    (hab : IntervalIntegrable f volume a b) (hmeas : StronglyMeasurableAtFilter f la')\n    (hf : Tendsto f (la' \u2293 volume.ae) (\ud835\udcdd c)) (hu : Tendsto u lt la) (hv : Tendsto v lt la) :\n    (fun t => ((\u222b x in v t..b, f x) - \u222b x in u t..b, f x) + (v t - u t) \u2022 c) =o[lt] (v - u)", "start": [552, 1], "end": [564, 93], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasStrictFDerivAt_of_tendsto_ae", "code": "theorem integral_hasStrictFDerivAt_of_tendsto_ae (hf : IntervalIntegrable f volume a b)\n    (hmeas_a : StronglyMeasurableAtFilter f (\ud835\udcdd a)) (hmeas_b : StronglyMeasurableAtFilter f (\ud835\udcdd b))\n    (ha : Tendsto f (\ud835\udcdd a \u2293 volume.ae) (\ud835\udcdd ca)) (hb : Tendsto f (\ud835\udcdd b \u2293 volume.ae) (\ud835\udcdd cb)) :\n    HasStrictFDerivAt (fun p : \u211d \u00d7 \u211d => \u222b x in p.1..p.2, f x)\n      ((snd \u211d \u211d \u211d).smulRight cb - (fst \u211d \u211d \u211d).smulRight ca) (a, b)", "start": [599, 1], "end": [618, 66], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasStrictFDerivAt", "code": "theorem integral_hasStrictFDerivAt (hf : IntervalIntegrable f volume a b)\n    (hmeas_a : StronglyMeasurableAtFilter f (\ud835\udcdd a)) (hmeas_b : StronglyMeasurableAtFilter f (\ud835\udcdd b))\n    (ha : ContinuousAt f a) (hb : ContinuousAt f b) :\n    HasStrictFDerivAt (fun p : \u211d \u00d7 \u211d => \u222b x in p.1..p.2, f x)\n      ((snd \u211d \u211d \u211d).smulRight (f b) - (fst \u211d \u211d \u211d).smulRight (f a)) (a, b)", "start": [621, 1], "end": [632, 31], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasStrictDerivAt_of_tendsto_ae_right", "code": "theorem integral_hasStrictDerivAt_of_tendsto_ae_right (hf : IntervalIntegrable f volume a b)\n    (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd b)) (hb : Tendsto f (\ud835\udcdd b \u2293 volume.ae) (\ud835\udcdd c)) :\n    HasStrictDerivAt (fun u => \u222b x in a..u, f x) c b", "start": [635, 1], "end": [643, 21], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasStrictDerivAt_right", "code": "theorem integral_hasStrictDerivAt_right (hf : IntervalIntegrable f volume a b)\n    (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd b)) (hb : ContinuousAt f b) :\n    HasStrictDerivAt (fun u => \u222b x in a..u, f x) (f b) b", "start": [646, 1], "end": [653, 84], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasStrictDerivAt_of_tendsto_ae_left", "code": "theorem integral_hasStrictDerivAt_of_tendsto_ae_left (hf : IntervalIntegrable f volume a b)\n    (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd a)) (ha : Tendsto f (\ud835\udcdd a \u2293 volume.ae) (\ud835\udcdd c)) :\n    HasStrictDerivAt (fun u => \u222b x in u..b, f x) (-c) a", "start": [656, 1], "end": [664, 73], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasStrictDerivAt_left", "code": "theorem integral_hasStrictDerivAt_left (hf : IntervalIntegrable f volume a b)\n    (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd a)) (ha : ContinuousAt f a) :\n    HasStrictDerivAt (fun u => \u222b x in u..b, f x) (-f a) a", "start": [667, 1], "end": [674, 92], "kind": "commanddeclaration"}, {"full_name": "Continuous.integral_hasStrictDerivAt", "code": "theorem _root_.Continuous.integral_hasStrictDerivAt {f : \u211d \u2192 E} (hf : Continuous f) (a b : \u211d) :\n    HasStrictDerivAt (fun u => \u222b x : \u211d in a..u, f x) (f b) b", "start": [677, 1], "end": [684, 20], "kind": "commanddeclaration"}, {"full_name": "Continuous.deriv_integral", "code": "theorem _root_.Continuous.deriv_integral (f : \u211d \u2192 E) (hf : Continuous f) (a b : \u211d) :\n    deriv (fun u => \u222b x : \u211d in a..u, f x) b = f b", "start": [687, 1], "end": [692, 54], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasFDerivAt_of_tendsto_ae", "code": "theorem integral_hasFDerivAt_of_tendsto_ae (hf : IntervalIntegrable f volume a b)\n    (hmeas_a : StronglyMeasurableAtFilter f (\ud835\udcdd a)) (hmeas_b : StronglyMeasurableAtFilter f (\ud835\udcdd b))\n    (ha : Tendsto f (\ud835\udcdd a \u2293 volume.ae) (\ud835\udcdd ca)) (hb : Tendsto f (\ud835\udcdd b \u2293 volume.ae) (\ud835\udcdd cb)) :\n    HasFDerivAt (fun p : \u211d \u00d7 \u211d => \u222b x in p.1..p.2, f x)\n      ((snd \u211d \u211d \u211d).smulRight cb - (fst \u211d \u211d \u211d).smulRight ca) (a, b)", "start": [703, 1], "end": [711, 82], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasFDerivAt", "code": "theorem integral_hasFDerivAt (hf : IntervalIntegrable f volume a b)\n    (hmeas_a : StronglyMeasurableAtFilter f (\ud835\udcdd a)) (hmeas_b : StronglyMeasurableAtFilter f (\ud835\udcdd b))\n    (ha : ContinuousAt f a) (hb : ContinuousAt f b) :\n    HasFDerivAt (fun p : \u211d \u00d7 \u211d => \u222b x in p.1..p.2, f x)\n      ((snd \u211d \u211d \u211d).smulRight (f b) - (fst \u211d \u211d \u211d).smulRight (f a)) (a, b)", "start": [714, 1], "end": [722, 68], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.fderiv_integral_of_tendsto_ae", "code": "theorem fderiv_integral_of_tendsto_ae (hf : IntervalIntegrable f volume a b)\n    (hmeas_a : StronglyMeasurableAtFilter f (\ud835\udcdd a)) (hmeas_b : StronglyMeasurableAtFilter f (\ud835\udcdd b))\n    (ha : Tendsto f (\ud835\udcdd a \u2293 volume.ae) (\ud835\udcdd ca)) (hb : Tendsto f (\ud835\udcdd b \u2293 volume.ae) (\ud835\udcdd cb)) :\n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \u222b x in p.1..p.2, f x) (a, b) =\n      (snd \u211d \u211d \u211d).smulRight cb - (fst \u211d \u211d \u211d).smulRight ca", "start": [725, 1], "end": [733, 71], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.fderiv_integral", "code": "theorem fderiv_integral (hf : IntervalIntegrable f volume a b)\n    (hmeas_a : StronglyMeasurableAtFilter f (\ud835\udcdd a)) (hmeas_b : StronglyMeasurableAtFilter f (\ud835\udcdd b))\n    (ha : ContinuousAt f a) (hb : ContinuousAt f b) :\n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \u222b x in p.1..p.2, f x) (a, b) =\n      (snd \u211d \u211d \u211d).smulRight (f b) - (fst \u211d \u211d \u211d).smulRight (f a)", "start": [736, 1], "end": [744, 57], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasDerivAt_of_tendsto_ae_right", "code": "theorem integral_hasDerivAt_of_tendsto_ae_right (hf : IntervalIntegrable f volume a b)\n    (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd b)) (hb : Tendsto f (\ud835\udcdd b \u2293 volume.ae) (\ud835\udcdd c)) :\n    HasDerivAt (fun u => \u222b x in a..u, f x) c b", "start": [747, 1], "end": [752, 73], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasDerivAt_right", "code": "theorem integral_hasDerivAt_right (hf : IntervalIntegrable f volume a b)\n    (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd b)) (hb : ContinuousAt f b) :\n    HasDerivAt (fun u => \u222b x in a..u, f x) (f b) b", "start": [755, 1], "end": [760, 59], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.deriv_integral_of_tendsto_ae_right", "code": "theorem deriv_integral_of_tendsto_ae_right (hf : IntervalIntegrable f volume a b)\n    (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd b)) (hb : Tendsto f (\ud835\udcdd b \u2293 volume.ae) (\ud835\udcdd c)) :\n    deriv (fun u => \u222b x in a..u, f x) b = c", "start": [763, 1], "end": [768, 62], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.deriv_integral_right", "code": "theorem deriv_integral_right (hf : IntervalIntegrable f volume a b)\n    (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd b)) (hb : ContinuousAt f b) :\n    deriv (fun u => \u222b x in a..u, f x) b = f b", "start": [771, 1], "end": [776, 48], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasDerivAt_of_tendsto_ae_left", "code": "theorem integral_hasDerivAt_of_tendsto_ae_left (hf : IntervalIntegrable f volume a b)\n    (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd a)) (ha : Tendsto f (\ud835\udcdd a \u2293 volume.ae) (\ud835\udcdd c)) :\n    HasDerivAt (fun u => \u222b x in u..b, f x) (-c) a", "start": [779, 1], "end": [784, 72], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasDerivAt_left", "code": "theorem integral_hasDerivAt_left (hf : IntervalIntegrable f volume a b)\n    (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd a)) (ha : ContinuousAt f a) :\n    HasDerivAt (fun u => \u222b x in u..b, f x) (-f a) a", "start": [787, 1], "end": [792, 58], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.deriv_integral_of_tendsto_ae_left", "code": "theorem deriv_integral_of_tendsto_ae_left (hf : IntervalIntegrable f volume a b)\n    (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd a)) (hb : Tendsto f (\ud835\udcdd a \u2293 volume.ae) (\ud835\udcdd c)) :\n    deriv (fun u => \u222b x in u..b, f x) a = -c", "start": [795, 1], "end": [800, 61], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.deriv_integral_left", "code": "theorem deriv_integral_left (hf : IntervalIntegrable f volume a b)\n    (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd a)) (hb : ContinuousAt f a) :\n    deriv (fun u => \u222b x in u..b, f x) a = -f a", "start": [803, 1], "end": [808, 47], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasFDerivWithinAt_of_tendsto_ae", "code": "theorem integral_hasFDerivWithinAt_of_tendsto_ae (hf : IntervalIntegrable f volume a b)\n    {s t : Set \u211d} [FTCFilter a (\ud835\udcdd[s] a) la] [FTCFilter b (\ud835\udcdd[t] b) lb]\n    (hmeas_a : StronglyMeasurableAtFilter f la) (hmeas_b : StronglyMeasurableAtFilter f lb)\n    (ha : Tendsto f (la \u2293 volume.ae) (\ud835\udcdd ca)) (hb : Tendsto f (lb \u2293 volume.ae) (\ud835\udcdd cb)) :\n    HasFDerivWithinAt (fun p : \u211d \u00d7 \u211d => \u222b x in p.1..p.2, f x)\n      ((snd \u211d \u211d \u211d).smulRight cb - (fst \u211d \u211d \u211d).smulRight ca) (s \u00d7\u02e2 t) (a, b)", "start": [816, 1], "end": [841, 66], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasFDerivWithinAt", "code": "theorem integral_hasFDerivWithinAt (hf : IntervalIntegrable f volume a b)\n    (hmeas_a : StronglyMeasurableAtFilter f la) (hmeas_b : StronglyMeasurableAtFilter f lb)\n    {s t : Set \u211d} [FTCFilter a (\ud835\udcdd[s] a) la] [FTCFilter b (\ud835\udcdd[t] b) lb] (ha : Tendsto f la (\ud835\udcdd <| f a))\n    (hb : Tendsto f lb (\ud835\udcdd <| f b)) :\n    HasFDerivWithinAt (fun p : \u211d \u00d7 \u211d => \u222b x in p.1..p.2, f x)\n      ((snd \u211d \u211d \u211d).smulRight (f b) - (fst \u211d \u211d \u211d).smulRight (f a)) (s \u00d7\u02e2 t) (a, b)", "start": [844, 1], "end": [864, 31], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.fderivWithin_integral_of_tendsto_ae", "code": "theorem fderivWithin_integral_of_tendsto_ae (hf : IntervalIntegrable f volume a b)\n    (hmeas_a : StronglyMeasurableAtFilter f la) (hmeas_b : StronglyMeasurableAtFilter f lb)\n    {s t : Set \u211d} [FTCFilter a (\ud835\udcdd[s] a) la] [FTCFilter b (\ud835\udcdd[t] b) lb]\n    (ha : Tendsto f (la \u2293 volume.ae) (\ud835\udcdd ca)) (hb : Tendsto f (lb \u2293 volume.ae) (\ud835\udcdd cb))\n    (hs : UniqueDiffWithinAt \u211d s a := by uniqueDiffWithinAt_Ici_Iic_univ)\n    (ht : UniqueDiffWithinAt \u211d t b := by uniqueDiffWithinAt_Ici_Iic_univ) :\n    fderivWithin \u211d (fun p : \u211d \u00d7 \u211d => \u222b x in p.1..p.2, f x) (s \u00d7\u02e2 t) (a, b) =\n      (snd \u211d \u211d \u211d).smulRight cb - (fst \u211d \u211d \u211d).smulRight ca", "start": [874, 1], "end": [894, 97], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasDerivWithinAt_of_tendsto_ae_right", "code": "theorem integral_hasDerivWithinAt_of_tendsto_ae_right (hf : IntervalIntegrable f volume a b)\n    {s t : Set \u211d} [FTCFilter b (\ud835\udcdd[s] b) (\ud835\udcdd[t] b)] (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd[t] b))\n    (hb : Tendsto f (\ud835\udcdd[t] b \u2293 volume.ae) (\ud835\udcdd c)) :\n    HasDerivWithinAt (fun u => \u222b x in a..u, f x) c s b", "start": [897, 1], "end": [905, 65], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasDerivWithinAt_right", "code": "theorem integral_hasDerivWithinAt_right (hf : IntervalIntegrable f volume a b) {s t : Set \u211d}\n    [FTCFilter b (\ud835\udcdd[s] b) (\ud835\udcdd[t] b)] (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd[t] b))\n    (hb : ContinuousWithinAt f t b) : HasDerivWithinAt (fun u => \u222b x in a..u, f x) (f b) s b", "start": [908, 1], "end": [914, 84], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.derivWithin_integral_of_tendsto_ae_right", "code": "theorem derivWithin_integral_of_tendsto_ae_right (hf : IntervalIntegrable f volume a b)\n    {s t : Set \u211d} [FTCFilter b (\ud835\udcdd[s] b) (\ud835\udcdd[t] b)] (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd[t] b))\n    (hb : Tendsto f (\ud835\udcdd[t] b \u2293 volume.ae) (\ud835\udcdd c))\n    (hs : UniqueDiffWithinAt \u211d s b := by uniqueDiffWithinAt_Ici_Iic_univ) :\n    derivWithin (fun u => \u222b x in a..u, f x) s b = c", "start": [917, 1], "end": [925, 77], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.derivWithin_integral_right", "code": "theorem derivWithin_integral_right (hf : IntervalIntegrable f volume a b) {s t : Set \u211d}\n    [FTCFilter b (\ud835\udcdd[s] b) (\ud835\udcdd[t] b)] (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd[t] b))\n    (hb : ContinuousWithinAt f t b)\n    (hs : UniqueDiffWithinAt \u211d s b := by uniqueDiffWithinAt_Ici_Iic_univ) :\n    derivWithin (fun u => \u222b x in a..u, f x) s b = f b", "start": [928, 1], "end": [936, 63], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasDerivWithinAt_of_tendsto_ae_left", "code": "theorem integral_hasDerivWithinAt_of_tendsto_ae_left (hf : IntervalIntegrable f volume a b)\n    {s t : Set \u211d} [FTCFilter a (\ud835\udcdd[s] a) (\ud835\udcdd[t] a)] (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd[t] a))\n    (ha : Tendsto f (\ud835\udcdd[t] a \u2293 volume.ae) (\ud835\udcdd c)) :\n    HasDerivWithinAt (fun u => \u222b x in u..b, f x) (-c) s a", "start": [939, 1], "end": [947, 77], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_hasDerivWithinAt_left", "code": "theorem integral_hasDerivWithinAt_left (hf : IntervalIntegrable f volume a b) {s t : Set \u211d}\n    [FTCFilter a (\ud835\udcdd[s] a) (\ud835\udcdd[t] a)] (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd[t] a))\n    (ha : ContinuousWithinAt f t a) : HasDerivWithinAt (fun u => \u222b x in u..b, f x) (-f a) s a", "start": [950, 1], "end": [956, 83], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.derivWithin_integral_of_tendsto_ae_left", "code": "theorem derivWithin_integral_of_tendsto_ae_left (hf : IntervalIntegrable f volume a b) {s t : Set \u211d}\n    [FTCFilter a (\ud835\udcdd[s] a) (\ud835\udcdd[t] a)] (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd[t] a))\n    (ha : Tendsto f (\ud835\udcdd[t] a \u2293 volume.ae) (\ud835\udcdd c))\n    (hs : UniqueDiffWithinAt \u211d s a := by uniqueDiffWithinAt_Ici_Iic_univ) :\n    derivWithin (fun u => \u222b x in u..b, f x) s a = -c", "start": [959, 1], "end": [967, 76], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.derivWithin_integral_left", "code": "theorem derivWithin_integral_left (hf : IntervalIntegrable f volume a b) {s t : Set \u211d}\n    [FTCFilter a (\ud835\udcdd[s] a) (\ud835\udcdd[t] a)] (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd[t] a))\n    (ha : ContinuousWithinAt f t a)\n    (hs : UniqueDiffWithinAt \u211d s a := by uniqueDiffWithinAt_Ici_Iic_univ) :\n    derivWithin (fun u => \u222b x in u..b, f x) s a = -f a", "start": [970, 1], "end": [978, 62], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.differentiableOn_integral_of_continuous", "code": "theorem differentiableOn_integral_of_continuous {s : Set \u211d}\n    (hintg : \u2200 x \u2208 s, IntervalIntegrable f volume a x) (hcont : Continuous f) :\n    DifferentiableOn \u211d (fun u => \u222b x in a..u, f x) s", "start": [981, 1], "end": [986, 68], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.sub_le_integral_of_hasDeriv_right_of_le_Ico", "code": "theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a \u2264 b)\n    (hcont : ContinuousOn g (Icc a b)) (hderiv : \u2200 x \u2208 Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)\n    (\u03c6int : IntegrableOn \u03c6 (Icc a b)) (h\u03c6g : \u2200 x \u2208 Ico a b, g' x \u2264 \u03c6 x) :\n    g b - g a \u2264 \u222b y in a..b, \u03c6 y", "start": [1014, 1], "end": [1110, 75], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.sub_le_integral_of_hasDeriv_right_of_le", "code": "theorem sub_le_integral_of_hasDeriv_right_of_le (hab : a \u2264 b) (hcont : ContinuousOn g (Icc a b))\n    (hderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x) (\u03c6int : IntegrableOn \u03c6 (Icc a b))\n    (h\u03c6g : \u2200 x \u2208 Ioo a b, g' x \u2264 \u03c6 x) : g b - g a \u2264 \u222b y in a..b, \u03c6 y", "start": [1115, 1], "end": [1144, 35], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_le_sub_of_hasDeriv_right_of_le", "code": "theorem integral_le_sub_of_hasDeriv_right_of_le (hab : a \u2264 b) (hcont : ContinuousOn g (Icc a b))\n    (hderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x) (\u03c6int : IntegrableOn \u03c6 (Icc a b))\n    (h\u03c6g : \u2200 x \u2208 Ioo a b, \u03c6 x \u2264 g' x) : (\u222b y in a..b, \u03c6 y) \u2264 g b - g a", "start": [1147, 1], "end": [1155, 36], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_eq_sub_of_hasDeriv_right_of_le_real", "code": "theorem integral_eq_sub_of_hasDeriv_right_of_le_real (hab : a \u2264 b)\n    (hcont : ContinuousOn g (Icc a b)) (hderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x)\n    (g'int : IntegrableOn g' (Icc a b)) : \u222b y in a..b, g' y = g b - g a", "start": [1158, 1], "end": [1163, 87], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_eq_sub_of_hasDeriv_right_of_le", "code": "theorem integral_eq_sub_of_hasDeriv_right_of_le (hab : a \u2264 b) (hcont : ContinuousOn f (Icc a b))\n    (hderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt f (f' x) (Ioi x) x)\n    (f'int : IntervalIntegrable f' volume a b) : \u222b y in a..b, f' y = f b - f a", "start": [1168, 1], "end": [1178, 84], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_eq_sub_of_hasDeriv_right", "code": "theorem integral_eq_sub_of_hasDeriv_right (hcont : ContinuousOn f (uIcc a b))\n    (hderiv : \u2200 x \u2208 Ioo (min a b) (max a b), HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hint : IntervalIntegrable f' volume a b) : \u222b y in a..b, f' y = f b - f a", "start": [1181, 1], "end": [1191, 100], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le", "code": "theorem integral_eq_sub_of_hasDerivAt_of_le (hab : a \u2264 b) (hcont : ContinuousOn f (Icc a b))\n    (hderiv : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x) (hint : IntervalIntegrable f' volume a b) :\n    \u222b y in a..b, f' y = f b - f a", "start": [1194, 1], "end": [1201, 9], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_eq_sub_of_hasDerivAt", "code": "theorem integral_eq_sub_of_hasDerivAt (hderiv : \u2200 x \u2208 uIcc a b, HasDerivAt f (f' x) x)\n    (hint : IntervalIntegrable f' volume a b) : \u222b y in a..b, f' y = f b - f a", "start": [1204, 1], "end": [1209, 72], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_eq_sub_of_hasDerivAt_of_tendsto", "code": "theorem integral_eq_sub_of_hasDerivAt_of_tendsto (hab : a < b) {fa fb}\n    (hderiv : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x) (hint : IntervalIntegrable f' volume a b)\n    (ha : Tendsto f (\ud835\udcdd[>] a) (\ud835\udcdd fa)) (hb : Tendsto f (\ud835\udcdd[<] b) (\ud835\udcdd fb)) :\n    \u222b y in a..b, f' y = fb - fa", "start": [1212, 1], "end": [1230, 93], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_deriv_eq_sub", "code": "theorem integral_deriv_eq_sub (hderiv : \u2200 x \u2208 [[a, b]], DifferentiableAt \u211d f x)\n    (hint : IntervalIntegrable (deriv f) volume a b) : \u222b y in a..b, deriv f y = f b - f a", "start": [1233, 1], "end": [1237, 76], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_deriv_eq_sub'", "code": "theorem integral_deriv_eq_sub' (f) (hderiv : deriv f = f')\n    (hdiff : \u2200 x \u2208 uIcc a b, DifferentiableAt \u211d f x) (hcont : ContinuousOn f' (uIcc a b)) :\n    \u222b y in a..b, f' y = f b - f a", "start": [1240, 1], "end": [1245, 33], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integrableOn_deriv_right_of_nonneg", "code": "theorem integrableOn_deriv_right_of_nonneg (hcont : ContinuousOn g (Icc a b))\n    (hderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x)\n    (g'pos : \u2200 x \u2208 Ioo a b, 0 \u2264 g' x) : IntegrableOn g' (Ioc a b)", "start": [1253, 1], "end": [1285, 63], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integrableOn_deriv_of_nonneg", "code": "theorem integrableOn_deriv_of_nonneg (hcont : ContinuousOn g (Icc a b))\n    (hderiv : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x) (g'pos : \u2200 x \u2208 Ioo a b, 0 \u2264 g' x) :\n    IntegrableOn g' (Ioc a b)", "start": [1288, 1], "end": [1293, 94], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.intervalIntegrable_deriv_of_nonneg", "code": "theorem intervalIntegrable_deriv_of_nonneg (hcont : ContinuousOn g (uIcc a b))\n    (hderiv : \u2200 x \u2208 Ioo (min a b) (max a b), HasDerivAt g (g' x) x)\n    (hpos : \u2200 x \u2208 Ioo (min a b) (max a b), 0 \u2264 g' x) : IntervalIntegrable g' volume a b", "start": [1296, 1], "end": [1307, 57], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_deriv_mul_eq_sub", "code": "theorem integral_deriv_mul_eq_sub {u v u' v' : \u211d \u2192 A} (hu : \u2200 x \u2208 uIcc a b, HasDerivAt u (u' x) x)\n    (hv : \u2200 x \u2208 uIcc a b, HasDerivAt v (v' x) x) (hu' : IntervalIntegrable u' volume a b)\n    (hv' : IntervalIntegrable v' volume a b) :\n    \u222b x in a..b, u' x * v x + u x * v' x = u b * v b - u a * v a", "start": [1319, 1], "end": [1325, 58], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_mul_deriv_eq_deriv_mul", "code": "theorem integral_mul_deriv_eq_deriv_mul {u v u' v' : \u211d \u2192 A}\n    (hu : \u2200 x \u2208 uIcc a b, HasDerivAt u (u' x) x) (hv : \u2200 x \u2208 uIcc a b, HasDerivAt v (v' x) x)\n    (hu' : IntervalIntegrable u' volume a b) (hv' : IntervalIntegrable v' volume a b) :\n    \u222b x in a..b, u x * v' x = u b * v b - u a * v a - \u222b x in a..b, u' x * v x", "start": [1328, 1], "end": [1337, 60], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_comp_smul_deriv'''", "code": "theorem integral_comp_smul_deriv''' {f f' : \u211d \u2192 \u211d} {g : \u211d \u2192 E} (hf : ContinuousOn f [[a, b]])\n    (hff' : \u2200 x \u2208 Ioo (min a b) (max a b), HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hg_cont : ContinuousOn g (f '' Ioo (min a b) (max a b))) (hg1 : IntegrableOn g (f '' [[a, b]]))\n    (hg2 : IntegrableOn (fun x => f' x \u2022 (g \u2218 f) x) [[a, b]]) :\n    (\u222b x in a..b, f' x \u2022 (g \u2218 f) x) = \u222b u in f a..f b, g u", "start": [1349, 1], "end": [1392, 88], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_comp_smul_deriv''", "code": "theorem integral_comp_smul_deriv'' {f f' : \u211d \u2192 \u211d} {g : \u211d \u2192 E} (hf : ContinuousOn f [[a, b]])\n    (hff' : \u2200 x \u2208 Ioo (min a b) (max a b), HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hf' : ContinuousOn f' [[a, b]]) (hg : ContinuousOn g (f '' [[a, b]])) :\n    (\u222b x in a..b, f' x \u2022 (g \u2218 f) x) = \u222b u in f a..f b, g u", "start": [1395, 1], "end": [1407, 28], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_comp_smul_deriv'", "code": "theorem integral_comp_smul_deriv' {f f' : \u211d \u2192 \u211d} {g : \u211d \u2192 E}\n    (h : \u2200 x \u2208 uIcc a b, HasDerivAt f (f' x) x) (h' : ContinuousOn f' (uIcc a b))\n    (hg : ContinuousOn g (f '' [[a, b]])) :\n    (\u222b x in a..b, f' x \u2022 (g \u2218 f) x) = \u222b x in f a..f b, g x", "start": [1410, 1], "end": [1421, 73], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_comp_smul_deriv", "code": "theorem integral_comp_smul_deriv {f f' : \u211d \u2192 \u211d} {g : \u211d \u2192 E}\n    (h : \u2200 x \u2208 uIcc a b, HasDerivAt f (f' x) x) (h' : ContinuousOn f' (uIcc a b))\n    (hg : Continuous g) : (\u222b x in a..b, f' x \u2022 (g \u2218 f) x) = \u222b x in f a..f b, g x", "start": [1424, 1], "end": [1431, 49], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_deriv_comp_smul_deriv'", "code": "theorem integral_deriv_comp_smul_deriv' {f f' : \u211d \u2192 \u211d} {g g' : \u211d \u2192 E} (hf : ContinuousOn f [[a, b]])\n    (hff' : \u2200 x \u2208 Ioo (min a b) (max a b), HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hf' : ContinuousOn f' [[a, b]]) (hg : ContinuousOn g [[f a, f b]])\n    (hgg' : \u2200 x \u2208 Ioo (min (f a) (f b)) (max (f a) (f b)), HasDerivWithinAt g (g' x) (Ioi x) x)\n    (hg' : ContinuousOn g' (f '' [[a, b]])) :\n    (\u222b x in a..b, f' x \u2022 (g' \u2218 f) x) = (g \u2218 f) b - (g \u2218 f) a", "start": [1434, 1], "end": [1442, 43], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_deriv_comp_smul_deriv", "code": "theorem integral_deriv_comp_smul_deriv {f f' : \u211d \u2192 \u211d} {g g' : \u211d \u2192 E}\n    (hf : \u2200 x \u2208 uIcc a b, HasDerivAt f (f' x) x)\n    (hg : \u2200 x \u2208 uIcc a b, HasDerivAt g (g' (f x)) (f x)) (hf' : ContinuousOn f' (uIcc a b))\n    (hg' : Continuous g') : (\u222b x in a..b, f' x \u2022 (g' \u2218 f) x) = (g \u2218 f) b - (g \u2218 f) a", "start": [1445, 1], "end": [1450, 88], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_comp_mul_deriv'''", "code": "theorem integral_comp_mul_deriv''' {a b : \u211d} {f f' : \u211d \u2192 \u211d} {g : \u211d \u2192 \u211d}\n    (hf : ContinuousOn f [[a, b]])\n    (hff' : \u2200 x \u2208 Ioo (min a b) (max a b), HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hg_cont : ContinuousOn g (f '' Ioo (min a b) (max a b))) (hg1 : IntegrableOn g (f '' [[a, b]]))\n    (hg2 : IntegrableOn (fun x => (g \u2218 f) x * f' x) [[a, b]]) :\n    (\u222b x in a..b, (g \u2218 f) x * f' x) = \u222b u in f a..f b, g u", "start": [1457, 1], "end": [1469, 78], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_comp_mul_deriv''", "code": "theorem integral_comp_mul_deriv'' {f f' g : \u211d \u2192 \u211d} (hf : ContinuousOn f [[a, b]])\n    (hff' : \u2200 x \u2208 Ioo (min a b) (max a b), HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hf' : ContinuousOn f' [[a, b]]) (hg : ContinuousOn g (f '' [[a, b]])) :\n    (\u222b x in a..b, (g \u2218 f) x * f' x) = \u222b u in f a..f b, g u", "start": [1472, 1], "end": [1480, 67], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_comp_mul_deriv'", "code": "theorem integral_comp_mul_deriv' {f f' g : \u211d \u2192 \u211d} (h : \u2200 x \u2208 uIcc a b, HasDerivAt f (f' x) x)\n    (h' : ContinuousOn f' (uIcc a b)) (hg : ContinuousOn g (f '' [[a, b]])) :\n    (\u222b x in a..b, (g \u2218 f) x * f' x) = \u222b x in f a..f b, g x", "start": [1483, 1], "end": [1492, 59], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_comp_mul_deriv", "code": "theorem integral_comp_mul_deriv {f f' g : \u211d \u2192 \u211d} (h : \u2200 x \u2208 uIcc a b, HasDerivAt f (f' x) x)\n    (h' : ContinuousOn f' (uIcc a b)) (hg : Continuous g) :\n    (\u222b x in a..b, (g \u2218 f) x * f' x) = \u222b x in f a..f b, g x", "start": [1495, 1], "end": [1502, 48], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_deriv_comp_mul_deriv'", "code": "theorem integral_deriv_comp_mul_deriv' {f f' g g' : \u211d \u2192 \u211d} (hf : ContinuousOn f [[a, b]])\n    (hff' : \u2200 x \u2208 Ioo (min a b) (max a b), HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hf' : ContinuousOn f' [[a, b]]) (hg : ContinuousOn g [[f a, f b]])\n    (hgg' : \u2200 x \u2208 Ioo (min (f a) (f b)) (max (f a) (f b)), HasDerivWithinAt g (g' x) (Ioi x) x)\n    (hg' : ContinuousOn g' (f '' [[a, b]])) :\n    (\u222b x in a..b, (g' \u2218 f) x * f' x) = (g \u2218 f) b - (g \u2218 f) a", "start": [1505, 1], "end": [1511, 81], "kind": "commanddeclaration"}, {"full_name": "intervalIntegral.integral_deriv_comp_mul_deriv", "code": "theorem integral_deriv_comp_mul_deriv {f f' g g' : \u211d \u2192 \u211d}\n    (hf : \u2200 x \u2208 uIcc a b, HasDerivAt f (f' x) x)\n    (hg : \u2200 x \u2208 uIcc a b, HasDerivAt g (g' (f x)) (f x)) (hf' : ContinuousOn f' (uIcc a b))\n    (hg' : Continuous g') : (\u222b x in a..b, (g' \u2218 f) x * f' x) = (g \u2218 f) b - (g \u2218 f) a", "start": [1514, 1], "end": [1518, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/Jacobian.lean", "imports": ["Mathlib/MeasureTheory/Covering/BesicovitchVectorSpace.lean", "Mathlib/MeasureTheory/Constructions/Polish.lean", "Mathlib/Analysis/Calculus/Inverse.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean", "Mathlib/MeasureTheory/Constructions/BorelSpace/ContinuousLinearMap.lean", "Mathlib/Analysis/NormedSpace/Pointwise.lean"], "premises": [{"full_name": "exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt", "code": "theorem exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt [SecondCountableTopology F]\n    (f : E \u2192 F) (s : Set E) (f' : E \u2192 E \u2192L[\u211d] F) (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x)\n    (r : (E \u2192L[\u211d] F) \u2192 \u211d\u22650) (rpos : \u2200 A, r A \u2260 0) :\n    \u2203 (t : \u2115 \u2192 Set E) (A : \u2115 \u2192 E \u2192L[\u211d] F),\n      (\u2200 n, IsClosed (t n)) \u2227\n        (s \u2286 \u22c3 n, t n) \u2227\n          (\u2200 n, ApproximatesLinearOn f (A n) (s \u2229 t n) (r (A n))) \u2227\n            (s.Nonempty \u2192 \u2200 n, \u2203 y \u2208 s, A n = f' y)", "start": [109, 1], "end": [246, 101], "kind": "commanddeclaration"}, {"full_name": "exists_partition_approximatesLinearOn_of_hasFDerivWithinAt", "code": "theorem exists_partition_approximatesLinearOn_of_hasFDerivWithinAt [SecondCountableTopology F]\n    (f : E \u2192 F) (s : Set E) (f' : E \u2192 E \u2192L[\u211d] F) (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x)\n    (r : (E \u2192L[\u211d] F) \u2192 \u211d\u22650) (rpos : \u2200 A, r A \u2260 0) :\n    \u2203 (t : \u2115 \u2192 Set E) (A : \u2115 \u2192 E \u2192L[\u211d] F),\n      Pairwise (Disjoint on t) \u2227\n        (\u2200 n, MeasurableSet (t n)) \u2227\n          (s \u2286 \u22c3 n, t n) \u2227\n            (\u2200 n, ApproximatesLinearOn f (A n) (s \u2229 t n) (r (A n))) \u2227\n              (s.Nonempty \u2192 \u2200 n, \u2203 y \u2208 s, A n = f' y)", "start": [251, 1], "end": [269, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.addHaar_image_le_mul_of_det_lt", "code": "theorem addHaar_image_le_mul_of_det_lt (A : E \u2192L[\u211d] E) {m : \u211d\u22650}\n    (hm : ENNReal.ofReal |A.det| < m) :\n    \u2200\u1da0 \u03b4 in \ud835\udcdd[>] (0 : \u211d\u22650),\n      \u2200 (s : Set E) (f : E \u2192 E), ApproximatesLinearOn f A s \u03b4 \u2192 \u03bc (f '' s) \u2264 m * \u03bc s", "start": [283, 1], "end": [387, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mul_le_addHaar_image_of_lt_det", "code": "theorem mul_le_addHaar_image_of_lt_det (A : E \u2192L[\u211d] E) {m : \u211d\u22650}\n    (hm : (m : \u211d\u22650\u221e) < ENNReal.ofReal |A.det|) :\n    \u2200\u1da0 \u03b4 in \ud835\udcdd[>] (0 : \u211d\u22650),\n      \u2200 (s : Set E) (f : E \u2192 E), ApproximatesLinearOn f A s \u03b4 \u2192 (m : \u211d\u22650\u221e) * \u03bc s \u2264 \u03bc (f '' s)", "start": [390, 1], "end": [460, 51], "kind": "commanddeclaration"}, {"full_name": "ApproximatesLinearOn.norm_fderiv_sub_le", "code": "theorem _root_.ApproximatesLinearOn.norm_fderiv_sub_le {A : E \u2192L[\u211d] E} {\u03b4 : \u211d\u22650}\n    (hf : ApproximatesLinearOn f A s \u03b4) (hs : MeasurableSet s) (f' : E \u2192 E \u2192L[\u211d] E)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) : \u2200\u1d50 x \u2202\u03bc.restrict s, \u2016f' x - A\u2016\u208a \u2264 \u03b4", "start": [463, 1], "end": [550, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.addHaar_image_eq_zero_of_differentiableOn_of_addHaar_eq_zero", "code": "theorem addHaar_image_eq_zero_of_differentiableOn_of_addHaar_eq_zero (hf : DifferentiableOn \u211d f s)\n    (hs : \u03bc s = 0) : \u03bc (f '' s) = 0", "start": [563, 1], "end": [600, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux", "code": "theorem addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) (R : \u211d) (hs : s \u2286 closedBall 0 R) (\u03b5 : \u211d\u22650)\n    (\u03b5pos : 0 < \u03b5) (h'f' : \u2200 x \u2208 s, (f' x).det = 0) : \u03bc (f '' s) \u2264 \u03b5 * \u03bc (closedBall 0 R)", "start": [603, 1], "end": [654, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.addHaar_image_eq_zero_of_det_fderivWithin_eq_zero", "code": "theorem addHaar_image_eq_zero_of_det_fderivWithin_eq_zero\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) (h'f' : \u2200 x \u2208 s, (f' x).det = 0) :\n    \u03bc (f '' s) = 0", "start": [657, 1], "end": [686, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.aemeasurable_fderivWithin", "code": "theorem aemeasurable_fderivWithin (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) : AEMeasurable f' (\u03bc.restrict s)", "start": [698, 1], "end": [755, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.aemeasurable_ofReal_abs_det_fderivWithin", "code": "theorem aemeasurable_ofReal_abs_det_fderivWithin (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) :\n    AEMeasurable (fun x => ENNReal.ofReal |(f' x).det|) (\u03bc.restrict s)", "start": [758, 1], "end": [764, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.aemeasurable_toNNReal_abs_det_fderivWithin", "code": "theorem aemeasurable_toNNReal_abs_det_fderivWithin (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) :\n    AEMeasurable (fun x => |(f' x).det|.toNNReal) (\u03bc.restrict s)", "start": [767, 1], "end": [773, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measurable_image_of_fderivWithin", "code": "theorem measurable_image_of_fderivWithin (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) : MeasurableSet (f '' s)", "start": [776, 1], "end": [781, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measurableEmbedding_of_fderivWithin", "code": "theorem measurableEmbedding_of_fderivWithin (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) :\n    MeasurableEmbedding (s.restrict f)", "start": [784, 1], "end": [790, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.addHaar_image_le_lintegral_abs_det_fderiv_aux1", "code": "theorem addHaar_image_le_lintegral_abs_det_fderiv_aux1 (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) {\u03b5 : \u211d\u22650} (\u03b5pos : 0 < \u03b5) :\n    \u03bc (f '' s) \u2264 (\u222b\u207b x in s, ENNReal.ofReal |(f' x).det| \u2202\u03bc) + 2 * \u03b5 * \u03bc s", "start": [802, 1], "end": [882, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.addHaar_image_le_lintegral_abs_det_fderiv_aux2", "code": "theorem addHaar_image_le_lintegral_abs_det_fderiv_aux2 (hs : MeasurableSet s) (h's : \u03bc s \u2260 \u221e)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) :\n    \u03bc (f '' s) \u2264 \u222b\u207b x in s, ENNReal.ofReal |(f' x).det| \u2202\u03bc", "start": [885, 1], "end": [900, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.addHaar_image_le_lintegral_abs_det_fderiv", "code": "theorem addHaar_image_le_lintegral_abs_det_fderiv (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) :\n    \u03bc (f '' s) \u2264 \u222b\u207b x in s, ENNReal.ofReal |(f' x).det| \u2202\u03bc", "start": [903, 1], "end": [931, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_abs_det_fderiv_le_addHaar_image_aux1", "code": "theorem lintegral_abs_det_fderiv_le_addHaar_image_aux1 (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) {\u03b5 : \u211d\u22650} (\u03b5pos : 0 < \u03b5) :\n    (\u222b\u207b x in s, ENNReal.ofReal |(f' x).det| \u2202\u03bc) \u2264 \u03bc (f '' s) + 2 * \u03b5 * \u03bc s", "start": [934, 1], "end": [1036, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_abs_det_fderiv_le_addHaar_image_aux2", "code": "theorem lintegral_abs_det_fderiv_le_addHaar_image_aux2 (hs : MeasurableSet s) (h's : \u03bc s \u2260 \u221e)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) :\n    (\u222b\u207b x in s, ENNReal.ofReal |(f' x).det| \u2202\u03bc) \u2264 \u03bc (f '' s)", "start": [1039, 1], "end": [1054, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_abs_det_fderiv_le_addHaar_image", "code": "theorem lintegral_abs_det_fderiv_le_addHaar_image (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) :\n    (\u222b\u207b x in s, ENNReal.ofReal |(f' x).det| \u2202\u03bc) \u2264 \u03bc (f '' s)", "start": [1057, 1], "end": [1096, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_abs_det_fderiv_eq_addHaar_image", "code": "theorem lintegral_abs_det_fderiv_eq_addHaar_image (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) :\n    (\u222b\u207b x in s, ENNReal.ofReal |(f' x).det| \u2202\u03bc) = \u03bc (f '' s)", "start": [1100, 1], "end": [1108, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.map_withDensity_abs_det_fderiv_eq_addHaar", "code": "theorem map_withDensity_abs_det_fderiv_eq_addHaar (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) (h'f : Measurable f) :\n    Measure.map f ((\u03bc.restrict s).withDensity fun x => ENNReal.ofReal |(f' x).det|) =\n      \u03bc.restrict (f '' s)", "start": [1111, 1], "end": [1127, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.restrict_map_withDensity_abs_det_fderiv_eq_addHaar", "code": "theorem restrict_map_withDensity_abs_det_fderiv_eq_addHaar (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) :\n    Measure.map (s.restrict f) (comap (\u2191) (\u03bc.withDensity fun x => ENNReal.ofReal |(f' x).det|)) =\n      \u03bc.restrict (f '' s)", "start": [1130, 1], "end": [1160, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_image_eq_lintegral_abs_det_fderiv_mul", "code": "theorem lintegral_image_eq_lintegral_abs_det_fderiv_mul (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) (g : E \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b x in f '' s, g x \u2202\u03bc = \u222b\u207b x in s, ENNReal.ofReal |(f' x).det| * g (f x) \u2202\u03bc", "start": [1170, 1], "end": [1181, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.integrableOn_image_iff_integrableOn_abs_det_fderiv_smul", "code": "theorem integrableOn_image_iff_integrableOn_abs_det_fderiv_smul (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) (g : E \u2192 F) :\n    IntegrableOn g (f '' s) \u03bc \u2194 IntegrableOn (fun x => |(f' x).det| \u2022 g (f x)) s \u03bc", "start": [1184, 1], "end": [1201, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.integral_image_eq_integral_abs_det_fderiv_smul", "code": "theorem integral_image_eq_integral_abs_det_fderiv_smul (hs : MeasurableSet s)\n    (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) (g : E \u2192 F) :\n    \u222b x in f '' s, g x \u2202\u03bc = \u222b x in s, |(f' x).det| \u2022 g (f x) \u2202\u03bc", "start": [1204, 1], "end": [1218, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.det_one_smulRight", "code": "theorem det_one_smulRight {\ud835\udd5c : Type*} [NormedField \ud835\udd5c] (v : \ud835\udd5c) :\n    ((1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c).smulRight v).det = v", "start": [1222, 1], "end": [1230, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.integrableOn_image_iff_integrableOn_abs_deriv_smul", "code": "theorem integrableOn_image_iff_integrableOn_abs_deriv_smul {s : Set \u211d} {f : \u211d \u2192 \u211d} {f' : \u211d \u2192 \u211d}\n    (hs : MeasurableSet s) (hf' : \u2200 x \u2208 s, HasDerivWithinAt f (f' x) s x) (hf : InjOn f s)\n    (g : \u211d \u2192 F) : IntegrableOn g (f '' s) \u2194 IntegrableOn (fun x => |f' x| \u2022 g (f x)) s", "start": [1233, 1], "end": [1242, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.integral_image_eq_integral_abs_deriv_smul", "code": "theorem integral_image_eq_integral_abs_deriv_smul {s : Set \u211d} {f : \u211d \u2192 \u211d} {f' : \u211d \u2192 \u211d}\n    (hs : MeasurableSet s) (hf' : \u2200 x \u2208 s, HasDerivWithinAt f (f' x) s x)\n    (hf : InjOn f s) (g : \u211d \u2192 F) : \u222b x in f '' s, g x = \u222b x in s, |f' x| \u2022 g (f x)", "start": [1245, 1], "end": [1253, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.integral_target_eq_integral_abs_det_fderiv_smul", "code": "theorem integral_target_eq_integral_abs_det_fderiv_smul {f : LocalHomeomorph E E}\n    (hf' : \u2200 x \u2208 f.source, HasFDerivAt f (f' x) x) (g : E \u2192 F) :\n    \u222b x in f.target, g x \u2202\u03bc = \u222b x in f.source, |(f' x).det| \u2022 g (f x) \u2202\u03bc", "start": [1256, 1], "end": [1263, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/ComplexDeriv.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Trigonometric/Complex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.hasStrictDerivAt_tan", "code": "theorem hasStrictDerivAt_tan {x : \u2102} (h : cos x \u2260 0) : HasStrictDerivAt tan (1 / cos x ^ 2) x", "start": [27, 1], "end": [30, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.hasDerivAt_tan", "code": "theorem hasDerivAt_tan {x : \u2102} (h : cos x \u2260 0) : HasDerivAt tan (1 / cos x ^ 2) x", "start": [33, 1], "end": [34, 38], "kind": "commanddeclaration"}, {"full_name": "Complex.tendsto_abs_tan_of_cos_eq_zero", "code": "theorem tendsto_abs_tan_of_cos_eq_zero {x : \u2102} (hx : cos x = 0) :\n    Tendsto (fun x => abs (tan x)) (\ud835\udcdd[\u2260] x) atTop", "start": [39, 1], "end": [46, 59], "kind": "commanddeclaration"}, {"full_name": "Complex.tendsto_abs_tan_atTop", "code": "theorem tendsto_abs_tan_atTop (k : \u2124) :\n    Tendsto (fun x => abs (tan x)) (\ud835\udcdd[\u2260] ((2 * k + 1) * \u03c0 / 2 : \u2102)) atTop", "start": [49, 1], "end": [51, 63], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousAt_tan", "code": "@[simp]\ntheorem continuousAt_tan {x : \u2102} : ContinuousAt tan x \u2194 cos x \u2260 0", "start": [54, 1], "end": [58, 44], "kind": "commanddeclaration"}, {"full_name": "Complex.differentiableAt_tan", "code": "@[simp]\ntheorem differentiableAt_tan {x : \u2102} : DifferentiableAt \u2102 tan x \u2194 cos x \u2260 0", "start": [61, 1], "end": [63, 93], "kind": "commanddeclaration"}, {"full_name": "Complex.deriv_tan", "code": "@[simp]\ntheorem deriv_tan (x : \u2102) : deriv tan x = 1 / cos x ^ 2", "start": [66, 1], "end": [71, 32], "kind": "commanddeclaration"}, {"full_name": "Complex.contDiffAt_tan", "code": "@[simp]\ntheorem contDiffAt_tan {x : \u2102} {n : \u2115\u221e} : ContDiffAt \u2102 n tan x \u2194 cos x \u2260 0", "start": [74, 1], "end": [76, 100], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Arctan.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Trigonometric/Complex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.tan_add", "code": "theorem tan_add {x y : \u211d}\n    (h : ((\u2200 k : \u2124, x \u2260 (2 * k + 1) * \u03c0 / 2) \u2227 \u2200 l : \u2124, y \u2260 (2 * l + 1) * \u03c0 / 2) \u2228\n      (\u2203 k : \u2124, x = (2 * k + 1) * \u03c0 / 2) \u2227 \u2203 l : \u2124, y = (2 * l + 1) * \u03c0 / 2) :\n    tan (x + y) = (tan x + tan y) / (1 - tan x * tan y)", "start": [28, 1], "end": [34, 66], "kind": "commanddeclaration"}, {"full_name": "Real.tan_add'", "code": "theorem tan_add' {x y : \u211d}\n    (h : (\u2200 k : \u2124, x \u2260 (2 * k + 1) * \u03c0 / 2) \u2227 \u2200 l : \u2124, y \u2260 (2 * l + 1) * \u03c0 / 2) :\n    tan (x + y) = (tan x + tan y) / (1 - tan x * tan y)", "start": [37, 1], "end": [40, 21], "kind": "commanddeclaration"}, {"full_name": "Real.tan_two_mul", "code": "theorem tan_two_mul {x : \u211d} : tan (2 * x) = 2 * tan x / (1 - tan x ^ 2)", "start": [43, 1], "end": [45, 17], "kind": "commanddeclaration"}, {"full_name": "Real.tan_ne_zero_iff", "code": "theorem tan_ne_zero_iff {\u03b8 : \u211d} : tan \u03b8 \u2260 0 \u2194 \u2200 k : \u2124, \u03b8 \u2260 k * \u03c0 / 2", "start": [48, 1], "end": [49, 88], "kind": "commanddeclaration"}, {"full_name": "Real.tan_eq_zero_iff", "code": "theorem tan_eq_zero_iff {\u03b8 : \u211d} : tan \u03b8 = 0 \u2194 \u2203 k : \u2124, \u03b8 = k * \u03c0 / 2", "start": [52, 1], "end": [53, 56], "kind": "commanddeclaration"}, {"full_name": "Real.tan_int_mul_pi_div_two", "code": "theorem tan_int_mul_pi_div_two (n : \u2124) : tan (n * \u03c0 / 2) = 0", "start": [56, 1], "end": [57, 33], "kind": "commanddeclaration"}, {"full_name": "Real.continuousOn_tan", "code": "theorem continuousOn_tan : ContinuousOn tan {x | cos x \u2260 0}", "start": [60, 1], "end": [64, 58], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_tan", "code": "@[continuity]\ntheorem continuous_tan : Continuous fun x : {x | cos x \u2260 0} => tan x", "start": [67, 1], "end": [69, 58], "kind": "commanddeclaration"}, {"full_name": "Real.continuousOn_tan_Ioo", "code": "theorem continuousOn_tan_Ioo : ContinuousOn tan (Ioo (-(\u03c0 / 2)) (\u03c0 / 2))", "start": [72, 1], "end": [89, 24], "kind": "commanddeclaration"}, {"full_name": "Real.surjOn_tan", "code": "theorem surjOn_tan : SurjOn tan (Ioo (-(\u03c0 / 2)) (\u03c0 / 2)) univ", "start": [92, 1], "end": [96, 76], "kind": "commanddeclaration"}, {"full_name": "Real.tan_surjective", "code": "theorem tan_surjective : Function.Surjective tan", "start": [99, 1], "end": [99, 93], "kind": "commanddeclaration"}, {"full_name": "Real.image_tan_Ioo", "code": "theorem image_tan_Ioo : tan '' Ioo (-(\u03c0 / 2)) (\u03c0 / 2) = univ", "start": [102, 1], "end": [103, 31], "kind": "commanddeclaration"}, {"full_name": "Real.tanOrderIso", "code": "def tanOrderIso : Ioo (-(\u03c0 / 2)) (\u03c0 / 2) \u2243o \u211d :=\n  (strictMonoOn_tan.orderIso _ _).trans <|\n    (OrderIso.setCongr _ _ image_tan_Ioo).trans OrderIso.Set.univ", "start": [106, 1], "end": [109, 66], "kind": "commanddeclaration"}, {"full_name": "Real.arctan", "code": "noncomputable def arctan (x : \u211d) : \u211d :=\n  tanOrderIso.symm x", "start": [112, 1], "end": [116, 21], "kind": "commanddeclaration"}, {"full_name": "Real.tan_arctan", "code": "@[simp]\ntheorem tan_arctan (x : \u211d) : tan (arctan x) = x", "start": [119, 1], "end": [121, 33], "kind": "commanddeclaration"}, {"full_name": "Real.arctan_mem_Ioo", "code": "theorem arctan_mem_Ioo (x : \u211d) : arctan x \u2208 Ioo (-(\u03c0 / 2)) (\u03c0 / 2)", "start": [124, 1], "end": [125, 21], "kind": "commanddeclaration"}, {"full_name": "Real.range_arctan", "code": "@[simp]\ntheorem range_arctan : range arctan = Ioo (-(\u03c0 / 2)) (\u03c0 / 2)", "start": [128, 1], "end": [130, 66], "kind": "commanddeclaration"}, {"full_name": "Real.arctan_tan", "code": "theorem arctan_tan {x : \u211d} (hx\u2081 : -(\u03c0 / 2) < x) (hx\u2082 : x < \u03c0 / 2) : arctan (tan x) = x", "start": [133, 1], "end": [134, 66], "kind": "commanddeclaration"}, {"full_name": "Real.cos_arctan_pos", "code": "theorem cos_arctan_pos (x : \u211d) : 0 < cos (arctan x)", "start": [137, 1], "end": [138, 41], "kind": "commanddeclaration"}, {"full_name": "Real.cos_sq_arctan", "code": "theorem cos_sq_arctan (x : \u211d) : cos (arctan x) ^ 2 = 1 / (1 + x ^ 2)", "start": [141, 1], "end": [142, 81], "kind": "commanddeclaration"}, {"full_name": "Real.sin_arctan", "code": "theorem sin_arctan (x : \u211d) : sin (arctan x) = x / sqrt (1 + x ^ 2)", "start": [145, 1], "end": [146, 77], "kind": "commanddeclaration"}, {"full_name": "Real.cos_arctan", "code": "theorem cos_arctan (x : \u211d) : cos (arctan x) = 1 / sqrt (1 + x ^ 2)", "start": [149, 1], "end": [150, 82], "kind": "commanddeclaration"}, {"full_name": "Real.arctan_lt_pi_div_two", "code": "theorem arctan_lt_pi_div_two (x : \u211d) : arctan x < \u03c0 / 2", "start": [153, 1], "end": [154, 23], "kind": "commanddeclaration"}, {"full_name": "Real.neg_pi_div_two_lt_arctan", "code": "theorem neg_pi_div_two_lt_arctan (x : \u211d) : -(\u03c0 / 2) < arctan x", "start": [157, 1], "end": [158, 23], "kind": "commanddeclaration"}, {"full_name": "Real.arctan_eq_arcsin", "code": "theorem arctan_eq_arcsin (x : \u211d) : arctan x = arcsin (x / sqrt (1 + x ^ 2))", "start": [161, 1], "end": [162, 85], "kind": "commanddeclaration"}, {"full_name": "Real.arcsin_eq_arctan", "code": "theorem arcsin_eq_arctan {x : \u211d} (h : x \u2208 Ioo (-(1 : \u211d)) 1) :\n    arcsin x = arctan (x / sqrt (1 - x ^ 2))", "start": [165, 1], "end": [168, 95], "kind": "commanddeclaration"}, {"full_name": "Real.arctan_zero", "code": "@[simp]\ntheorem arctan_zero : arctan 0 = 0", "start": [171, 1], "end": [172, 65], "kind": "commanddeclaration"}, {"full_name": "Real.arctan_eq_of_tan_eq", "code": "theorem arctan_eq_of_tan_eq {x y : \u211d} (h : tan x = y) (hx : x \u2208 Ioo (-(\u03c0 / 2)) (\u03c0 / 2)) :\n    arctan y = x", "start": [175, 1], "end": [177, 58], "kind": "commanddeclaration"}, {"full_name": "Real.arctan_one", "code": "@[simp]\ntheorem arctan_one : arctan 1 = \u03c0 / 4", "start": [180, 1], "end": [182, 78], "kind": "commanddeclaration"}, {"full_name": "Real.arctan_neg", "code": "@[simp]\ntheorem arctan_neg (x : \u211d) : arctan (-x) = -arctan x", "start": [185, 1], "end": [186, 92], "kind": "commanddeclaration"}, {"full_name": "Real.arctan_eq_arccos", "code": "theorem arctan_eq_arccos {x : \u211d} (h : 0 \u2264 x) : arctan x = arccos (sqrt (1 + x ^ 2))\u207b\u00b9", "start": [189, 1], "end": [193, 23], "kind": "commanddeclaration"}, {"full_name": "Real.arccos_eq_arctan", "code": "theorem arccos_eq_arctan {x : \u211d} (h : 0 < x) : arccos x = arctan (sqrt (1 - x ^ 2) / x)", "start": [197, 1], "end": [202, 35], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_arctan", "code": "@[continuity]\ntheorem continuous_arctan : Continuous arctan", "start": [205, 1], "end": [207, 73], "kind": "commanddeclaration"}, {"full_name": "Real.continuousAt_arctan", "code": "theorem continuousAt_arctan {x : \u211d} : ContinuousAt arctan x", "start": [210, 1], "end": [211, 33], "kind": "commanddeclaration"}, {"full_name": "Real.tanLocalHomeomorph", "code": "def tanLocalHomeomorph : LocalHomeomorph \u211d \u211d where\n  toFun := tan\n  invFun := arctan\n  source := Ioo (-(\u03c0 / 2)) (\u03c0 / 2)\n  target := univ\n  map_source' := mapsTo_univ _ _\n  map_target' y _ := arctan_mem_Ioo y\n  left_inv' _ hx := arctan_tan hx.1 hx.2\n  right_inv' y _ := tan_arctan y\n  open_source := isOpen_Ioo\n  open_target := isOpen_univ\n  continuous_toFun := continuousOn_tan_Ioo\n  continuous_invFun := continuous_arctan.continuousOn", "start": [214, 1], "end": [227, 54], "kind": "commanddeclaration"}, {"full_name": "Real.coe_tanLocalHomeomorph", "code": "@[simp]\ntheorem coe_tanLocalHomeomorph : \u21d1tanLocalHomeomorph = tan", "start": [230, 1], "end": [232, 6], "kind": "commanddeclaration"}, {"full_name": "Real.coe_tanLocalHomeomorph_symm", "code": "@[simp]\ntheorem coe_tanLocalHomeomorph_symm : \u21d1tanLocalHomeomorph.symm = arctan", "start": [235, 1], "end": [237, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Complex/Arg.lean", "imports": ["Mathlib/Analysis/InnerProductSpace/Basic.lean", "Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.sameRay_iff", "code": "theorem sameRay_iff : SameRay \u211d x y \u2194 x = 0 \u2228 y = 0 \u2228 x.arg = y.arg", "start": [31, 1], "end": [38, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.sameRay_iff_arg_div_eq_zero", "code": "theorem sameRay_iff_arg_div_eq_zero : SameRay \u211d x y \u2194 arg (x / y) = 0", "start": [41, 1], "end": [45, 48], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_add_eq_iff", "code": "theorem abs_add_eq_iff : abs (x + y) = abs x + abs y \u2194 x = 0 \u2228 y = 0 \u2228 x.arg = y.arg", "start": [49, 1], "end": [50, 46], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_sub_eq_iff", "code": "theorem abs_sub_eq_iff : abs (x - y) = |abs x - abs y| \u2194 x = 0 \u2228 y = 0 \u2228 x.arg = y.arg", "start": [53, 1], "end": [54, 46], "kind": "commanddeclaration"}, {"full_name": "Complex.sameRay_of_arg_eq", "code": "theorem sameRay_of_arg_eq (h : x.arg = y.arg) : SameRay \u211d x y", "start": [57, 1], "end": [58, 40], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_add_eq", "code": "theorem abs_add_eq (h : x.arg = y.arg) : abs (x + y) = abs x + abs y", "start": [61, 1], "end": [62, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_sub_eq", "code": "theorem abs_sub_eq (h : x.arg = y.arg) : abs (x - y) = \u2016abs x - abs y\u2016", "start": [65, 1], "end": [66, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean", "imports": ["Mathlib/RingTheory/RootsOfUnity/Minpoly.lean", "Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.isRoot_of_unity_of_root_cyclotomic", "code": "theorem isRoot_of_unity_of_root_cyclotomic {\u03b6 : R} {i : \u2115} (hi : i \u2208 n.divisors)\n    (h : (cyclotomic i R).IsRoot \u03b6) : \u03b6 ^ n = 1", "start": [42, 1], "end": [51, 36], "kind": "commanddeclaration"}, {"full_name": "isRoot_of_unity_iff", "code": "theorem _root_.isRoot_of_unity_iff (h : 0 < n) (R : Type*) [CommRing R] [IsDomain R] {\u03b6 : R} :\n    \u03b6 ^ n = 1 \u2194 \u2203 i \u2208 n.divisors, (cyclotomic i R).IsRoot \u03b6", "start": [58, 1], "end": [61, 55], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.isRoot_cyclotomic", "code": "theorem _root_.IsPrimitiveRoot.isRoot_cyclotomic (hpos : 0 < n) {\u03bc : R} (h : IsPrimitiveRoot \u03bc n) :\n    IsRoot (cyclotomic n R) \u03bc", "start": [64, 1], "end": [69, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isRoot_cyclotomic_iff'", "code": "private theorem isRoot_cyclotomic_iff' {n : \u2115} {K : Type*} [Field K] {\u03bc : K} [NeZero (n : K)] :\n    IsRoot (cyclotomic n K) \u03bc \u2194 IsPrimitiveRoot \u03bc n", "start": [72, 1], "end": [103, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isRoot_cyclotomic_iff", "code": "theorem isRoot_cyclotomic_iff [NeZero (n : R)] {\u03bc : R} :\n    IsRoot (cyclotomic n R) \u03bc \u2194 IsPrimitiveRoot \u03bc n", "start": [105, 1], "end": [110, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_cyclotomic_nodup", "code": "theorem roots_cyclotomic_nodup [NeZero (n : R)] : (cyclotomic n R).roots.Nodup", "start": [113, 1], "end": [119, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cyclotomic.roots_to_finset_eq_primitiveRoots", "code": "theorem cyclotomic.roots_to_finset_eq_primitiveRoots [NeZero (n : R)] :\n    (\u27e8(cyclotomic n R).roots, roots_cyclotomic_nodup\u27e9 : Finset _) = primitiveRoots n R", "start": [122, 1], "end": [130, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cyclotomic.roots_eq_primitiveRoots_val", "code": "theorem cyclotomic.roots_eq_primitiveRoots_val [NeZero (n : R)] :\n    (cyclotomic n R).roots = (primitiveRoots n R).val", "start": [133, 1], "end": [135, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isRoot_cyclotomic_iff_charZero", "code": "theorem isRoot_cyclotomic_iff_charZero {n : \u2115} {R : Type*} [CommRing R] [IsDomain R] [CharZero R]\n    {\u03bc : R} (hn : 0 < n) : (Polynomial.cyclotomic n R).IsRoot \u03bc \u2194 IsPrimitiveRoot \u03bc n", "start": [138, 1], "end": [143, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cyclotomic_injective", "code": "theorem cyclotomic_injective [CharZero R] : Function.Injective fun n => cyclotomic n R", "start": [148, 1], "end": [169, 54], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.minpoly_dvd_cyclotomic", "code": "theorem _root_.IsPrimitiveRoot.minpoly_dvd_cyclotomic {n : \u2115} {K : Type*} [Field K] {\u03bc : K}\n    (h : IsPrimitiveRoot \u03bc n) (hpos : 0 < n) [CharZero K] : minpoly \u2124 \u03bc \u2223 cyclotomic n \u2124", "start": [172, 1], "end": [176, 82], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.minpoly_eq_cyclotomic_of_irreducible", "code": "theorem _root_.IsPrimitiveRoot.minpoly_eq_cyclotomic_of_irreducible {K : Type*} [Field K]\n    {R : Type*} [CommRing R] [IsDomain R] {\u03bc : R} {n : \u2115} [Algebra K R] (h\u03bc : IsPrimitiveRoot \u03bc n)\n    (h : Irreducible <| cyclotomic n K) [NeZero (n : K)] : cyclotomic n K = minpoly K \u03bc", "start": [183, 1], "end": [188, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cyclotomic_eq_minpoly", "code": "theorem cyclotomic_eq_minpoly {n : \u2115} {K : Type*} [Field K] {\u03bc : K} (h : IsPrimitiveRoot \u03bc n)\n    (hpos : 0 < n) [CharZero K] : cyclotomic n \u2124 = minpoly \u2124 \u03bc", "start": [191, 1], "end": [196, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cyclotomic_eq_minpoly_rat", "code": "theorem cyclotomic_eq_minpoly_rat {n : \u2115} {K : Type*} [Field K] {\u03bc : K} (h : IsPrimitiveRoot \u03bc n)\n    (hpos : 0 < n) [CharZero K] : cyclotomic n \u211a = minpoly \u211a \u03bc", "start": [199, 1], "end": [203, 100], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cyclotomic.irreducible", "code": "theorem cyclotomic.irreducible {n : \u2115} (hpos : 0 < n) : Irreducible (cyclotomic n \u2124)", "start": [206, 1], "end": [210, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cyclotomic.irreducible_rat", "code": "theorem cyclotomic.irreducible_rat {n : \u2115} (hpos : 0 < n) : Irreducible (cyclotomic n \u211a)", "start": [213, 1], "end": [217, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cyclotomic.isCoprime_rat", "code": "theorem cyclotomic.isCoprime_rat {n m : \u2115} (h : n \u2260 m) :\n    IsCoprime (cyclotomic n \u211a) (cyclotomic m \u211a)", "start": [220, 1], "end": [231, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/NumberField/Basic.lean", "imports": ["Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean", "Mathlib/Algebra/CharP/Algebra.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NumberField", "code": "class NumberField (K : Type*) [Field K] : Prop where\n  [to_charZero : CharZero K]\n  [to_finiteDimensional : FiniteDimensional \u211a K]", "start": [35, 1], "end": [39, 49], "kind": "commanddeclaration"}, {"full_name": "Int.not_isField", "code": "theorem Int.not_isField : \u00acIsField \u2124", "start": [46, 1], "end": [49, 81], "kind": "commanddeclaration"}, {"full_name": "NumberField.isAlgebraic", "code": "protected theorem isAlgebraic : Algebra.IsAlgebraic \u211a K", "start": [59, 1], "end": [60, 36], "kind": "commanddeclaration"}, {"full_name": "NumberField.ringOfIntegers", "code": "def ringOfIntegers :=\n  integralClosure \u2124 K", "start": [63, 1], "end": [66, 22], "kind": "commanddeclaration"}, {"full_name": "NumberField.mem_ringOfIntegers", "code": "theorem mem_ringOfIntegers (x : K) : x \u2208 \ud835\udcde K \u2194 IsIntegral \u2124 x", "start": [71, 1], "end": [72, 10], "kind": "commanddeclaration"}, {"full_name": "NumberField.isIntegral_of_mem_ringOfIntegers", "code": "theorem isIntegral_of_mem_ringOfIntegers {K : Type*} [Field K] {x : K} (hx : x \u2208 \ud835\udcde K) :\n    IsIntegral \u2124 (\u27e8x, hx\u27e9 : \ud835\udcde K)", "start": [75, 1], "end": [80, 46], "kind": "commanddeclaration"}, {"full_name": "NumberField.inst_ringOfIntegersAlgebra", "code": "instance inst_ringOfIntegersAlgebra [Algebra K L] : Algebra (\ud835\udcde K) (\ud835\udcde L) :=\n  RingHom.toAlgebra\n    { toFun := fun k => \u27e8algebraMap K L k, IsIntegral.algebraMap k.2\u27e9\n      map_zero' := Subtype.ext <| by simp only [Subtype.coe_mk, Subalgebra.coe_zero, map_zero]\n      map_one' := Subtype.ext <| by simp only [Subtype.coe_mk, Subalgebra.coe_one, map_one]\n      map_add' := fun x y =>\n        Subtype.ext <| by simp only [map_add, Subalgebra.coe_add, Subtype.coe_mk]\n      map_mul' := fun x y =>\n        Subtype.ext <| by simp only [Subalgebra.coe_mul, map_mul, Subtype.coe_mk] }", "start": [83, 1], "end": [92, 84], "kind": "commanddeclaration"}, {"full_name": "NumberField.RingOfIntegers.isIntegral_coe", "code": "theorem isIntegral_coe (x : \ud835\udcde K) : IsIntegral \u2124 (x : K)", "start": [111, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "NumberField.RingOfIntegers.map_mem", "code": "theorem map_mem {F L : Type*} [Field L] [CharZero K] [CharZero L] [AlgHomClass F \u211a K L] (f : F)\n    (x : \ud835\udcde K) : f x \u2208 \ud835\udcde L", "start": [115, 1], "end": [117, 88], "kind": "commanddeclaration"}, {"full_name": "NumberField.RingOfIntegers.equiv", "code": "protected noncomputable def equiv (R : Type*) [CommRing R] [Algebra R K]\n    [IsIntegralClosure R \u2124 K] : \ud835\udcde K \u2243+* R :=\n  (IsIntegralClosure.equiv \u2124 R K _).symm.toRingEquiv", "start": [120, 1], "end": [123, 53], "kind": "commanddeclaration"}, {"full_name": "NumberField.RingOfIntegers.not_isField", "code": "theorem not_isField : \u00acIsField (\ud835\udcde K)", "start": [134, 1], "end": [139, 84], "kind": "commanddeclaration"}, {"full_name": "NumberField.RingOfIntegers.basis", "code": "noncomputable def basis : Basis (Free.ChooseBasisIndex \u2124 (\ud835\udcde K)) \u2124 (\ud835\udcde K) :=\n  Free.chooseBasis \u2124 (\ud835\udcde K)", "start": [151, 1], "end": [153, 27], "kind": "commanddeclaration"}, {"full_name": "NumberField.integralBasis", "code": "noncomputable def integralBasis : Basis (Free.ChooseBasisIndex \u2124 (\ud835\udcde K)) \u211a K :=\n  Basis.localizationLocalization \u211a (nonZeroDivisors \u2124) K (RingOfIntegers.basis K)", "start": [158, 1], "end": [160, 82], "kind": "commanddeclaration"}, {"full_name": "NumberField.integralBasis_apply", "code": "@[simp]\ntheorem integralBasis_apply (i : Free.ChooseBasisIndex \u2124 (\ud835\udcde K)) :\n    integralBasis K i = algebraMap (\ud835\udcde K) K (RingOfIntegers.basis K i)", "start": [163, 1], "end": [166, 90], "kind": "commanddeclaration"}, {"full_name": "NumberField.mem_span_integralBasis", "code": "theorem mem_span_integralBasis {x : K} :\n    x \u2208 Submodule.span \u2124 (Set.range (integralBasis K)) \u2194 x \u2208 \ud835\udcde K", "start": [169, 1], "end": [172, 32], "kind": "commanddeclaration"}, {"full_name": "NumberField.RingOfIntegers.rank", "code": "theorem RingOfIntegers.rank : FiniteDimensional.finrank \u2124 (\ud835\udcde K) = FiniteDimensional.finrank \u211a K", "start": [174, 1], "end": [175, 37], "kind": "commanddeclaration"}, {"full_name": "Rat.numberField", "code": "instance numberField : NumberField \u211a where\n  to_charZero := inferInstance\n  to_finiteDimensional := by\n  convert (inferInstance : FiniteDimensional \u211a \u211a)", "start": [184, 1], "end": [191, 52], "kind": "commanddeclaration"}, {"full_name": "Rat.ringOfIntegersEquiv", "code": "noncomputable def ringOfIntegersEquiv : ringOfIntegers \u211a \u2243+* \u2124 :=\n  RingOfIntegers.equiv \u2124", "start": [194, 1], "end": [196, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/FDeriv/Analytic.lean", "imports": ["Mathlib/Analysis/Analytic/Basic.lean", "Mathlib/Analysis/Calculus/ContDiffDef.lean", "Mathlib/Analysis/Calculus/Deriv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HasFPowerSeriesAt.hasStrictFDerivAt", "code": "theorem HasFPowerSeriesAt.hasStrictFDerivAt (h : HasFPowerSeriesAt f p x) :\n    HasStrictFDerivAt f (continuousMultilinearCurryFin1 \ud835\udd5c E F (p 1)) x", "start": [36, 1], "end": [41, 38], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesAt.hasFDerivAt", "code": "theorem HasFPowerSeriesAt.hasFDerivAt (h : HasFPowerSeriesAt f p x) :\n    HasFDerivAt f (continuousMultilinearCurryFin1 \ud835\udd5c E F (p 1)) x", "start": [44, 1], "end": [46, 34], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesAt.differentiableAt", "code": "theorem HasFPowerSeriesAt.differentiableAt (h : HasFPowerSeriesAt f p x) : DifferentiableAt \ud835\udd5c f x", "start": [49, 1], "end": [50, 33], "kind": "commanddeclaration"}, {"full_name": "AnalyticAt.differentiableAt", "code": "theorem AnalyticAt.differentiableAt : AnalyticAt \ud835\udd5c f x \u2192 DifferentiableAt \ud835\udd5c f x", "start": [53, 1], "end": [54, 35], "kind": "commanddeclaration"}, {"full_name": "AnalyticAt.differentiableWithinAt", "code": "theorem AnalyticAt.differentiableWithinAt (h : AnalyticAt \ud835\udd5c f x) : DifferentiableWithinAt \ud835\udd5c f s x", "start": [57, 1], "end": [58, 44], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesAt.fderiv_eq", "code": "theorem HasFPowerSeriesAt.fderiv_eq (h : HasFPowerSeriesAt f p x) :\n    fderiv \ud835\udd5c f x = continuousMultilinearCurryFin1 \ud835\udd5c E F (p 1)", "start": [61, 1], "end": [63, 23], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesOnBall.differentiableOn", "code": "theorem HasFPowerSeriesOnBall.differentiableOn [CompleteSpace F]\n    (h : HasFPowerSeriesOnBall f p x r) : DifferentiableOn \ud835\udd5c f (EMetric.ball x r)", "start": [66, 1], "end": [68, 50], "kind": "commanddeclaration"}, {"full_name": "AnalyticOn.differentiableOn", "code": "theorem AnalyticOn.differentiableOn (h : AnalyticOn \ud835\udd5c f s) : DifferentiableOn \ud835\udd5c f s", "start": [71, 1], "end": [72, 34], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesOnBall.hasFDerivAt", "code": "theorem HasFPowerSeriesOnBall.hasFDerivAt [CompleteSpace F] (h : HasFPowerSeriesOnBall f p x r)\n    {y : E} (hy : (\u2016y\u2016\u208a : \u211d\u22650\u221e) < r) :\n    HasFDerivAt f (continuousMultilinearCurryFin1 \ud835\udd5c E F (p.changeOrigin y 1)) (x + y)", "start": [75, 1], "end": [78, 52], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesOnBall.fderiv_eq", "code": "theorem HasFPowerSeriesOnBall.fderiv_eq [CompleteSpace F] (h : HasFPowerSeriesOnBall f p x r)\n    {y : E} (hy : (\u2016y\u2016\u208a : \u211d\u22650\u221e) < r) :\n    fderiv \ud835\udd5c f (x + y) = continuousMultilinearCurryFin1 \ud835\udd5c E F (p.changeOrigin y 1)", "start": [81, 1], "end": [84, 28], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesOnBall.fderiv", "code": "theorem HasFPowerSeriesOnBall.fderiv [CompleteSpace F] (h : HasFPowerSeriesOnBall f p x r) :\n    HasFPowerSeriesOnBall (fderiv \ud835\udd5c f)\n      ((continuousMultilinearCurryFin1 \ud835\udd5c E F :\n            (E[\u00d71]\u2192L[\ud835\udd5c] F) \u2192L[\ud835\udd5c] E \u2192L[\ud835\udd5c] F).compFormalMultilinearSeries\n        (p.changeOriginSeries 1))\n      x r", "start": [87, 1], "end": [115, 8], "kind": "commanddeclaration"}, {"full_name": "AnalyticOn.fderiv", "code": "theorem AnalyticOn.fderiv [CompleteSpace F] (h : AnalyticOn \ud835\udd5c f s) :\n    AnalyticOn \ud835\udd5c (fderiv \ud835\udd5c f) s", "start": [118, 1], "end": [123, 29], "kind": "commanddeclaration"}, {"full_name": "AnalyticOn.iteratedFDeriv", "code": "theorem AnalyticOn.iteratedFDeriv [CompleteSpace F] (h : AnalyticOn \ud835\udd5c f s) (n : \u2115) :\n    AnalyticOn \ud835\udd5c (iteratedFDeriv \ud835\udd5c n f) s", "start": [126, 1], "end": [140, 8], "kind": "commanddeclaration"}, {"full_name": "AnalyticOn.contDiffOn", "code": "theorem AnalyticOn.contDiffOn [CompleteSpace F] (h : AnalyticOn \ud835\udd5c f s) {n : \u2115\u221e} :\n    ContDiffOn \ud835\udd5c n f s", "start": [143, 1], "end": [158, 53], "kind": "commanddeclaration"}, {"full_name": "AnalyticAt.contDiffAt", "code": "theorem AnalyticAt.contDiffAt [CompleteSpace F] (h : AnalyticAt \ud835\udd5c f x) {n : \u2115\u221e} :\n    ContDiffAt \ud835\udd5c n f x", "start": [161, 1], "end": [164, 36], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesAt.hasStrictDerivAt", "code": "protected theorem HasFPowerSeriesAt.hasStrictDerivAt (h : HasFPowerSeriesAt f p x) :\n    HasStrictDerivAt f (p 1 fun _ => 1) x", "start": [174, 1], "end": [176, 39], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesAt.hasDerivAt", "code": "protected theorem HasFPowerSeriesAt.hasDerivAt (h : HasFPowerSeriesAt f p x) :\n    HasDerivAt f (p 1 fun _ => 1) x", "start": [179, 1], "end": [181, 32], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesAt.deriv", "code": "protected theorem HasFPowerSeriesAt.deriv (h : HasFPowerSeriesAt f p x) :\n    deriv f x = p 1 fun _ => 1", "start": [184, 1], "end": [186, 21], "kind": "commanddeclaration"}, {"full_name": "AnalyticOn.deriv", "code": "theorem AnalyticOn.deriv [CompleteSpace F] (h : AnalyticOn \ud835\udd5c f s) : AnalyticOn \ud835\udd5c (deriv f) s", "start": [189, 1], "end": [191, 67], "kind": "commanddeclaration"}, {"full_name": "AnalyticOn.iterated_deriv", "code": "theorem AnalyticOn.iterated_deriv [CompleteSpace F] (h : AnalyticOn \ud835\udd5c f s) (n : \u2115) :\n    AnalyticOn \ud835\udd5c (_root_.deriv^[n] f) s", "start": [194, 1], "end": [199, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Analytic/Linear.lean", "imports": ["Mathlib/Analysis/Analytic/Composition.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousLinearMap.fpowerSeries_radius", "code": "@[simp]\ntheorem fpowerSeries_radius (f : E \u2192L[\ud835\udd5c] F) (x : E) : (f.fpowerSeries x).radius = \u221e", "start": [30, 1], "end": [32, 78], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.hasFPowerSeriesOnBall", "code": "protected theorem hasFPowerSeriesOnBall (f : E \u2192L[\ud835\udd5c] F) (x : E) :\n    HasFPowerSeriesOnBall f (f.fpowerSeries x) x \u221e", "start": [35, 1], "end": [40, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.hasFPowerSeriesAt", "code": "protected theorem hasFPowerSeriesAt (f : E \u2192L[\ud835\udd5c] F) (x : E) :\n    HasFPowerSeriesAt f (f.fpowerSeries x) x", "start": [43, 1], "end": [45, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.analyticAt", "code": "protected theorem analyticAt (f : E \u2192L[\ud835\udd5c] F) (x : E) : AnalyticAt \ud835\udd5c f x", "start": [48, 1], "end": [49, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.uncurryBilinear", "code": "def uncurryBilinear (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) : E \u00d7 F[\u00d72]\u2192L[\ud835\udd5c] G :=\n  @ContinuousLinearMap.uncurryLeft \ud835\udd5c 1 (fun _ => E \u00d7 F) G _ _ _ _ _ <|\n    (\u2191(continuousMultilinearCurryFin1 \ud835\udd5c (E \u00d7 F) G).symm : (E \u00d7 F \u2192L[\ud835\udd5c] G) \u2192L[\ud835\udd5c] _).comp <|\n      f.bilinearComp (fst _ _ _) (snd _ _ _)", "start": [52, 1], "end": [59, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.uncurryBilinear_apply", "code": "@[simp]\ntheorem uncurryBilinear_apply (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (m : Fin 2 \u2192 E \u00d7 F) :\n    f.uncurryBilinear m = f (m 0).1 (m 1).2", "start": [62, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.fpowerSeriesBilinear", "code": "def fpowerSeriesBilinear (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (x : E \u00d7 F) : FormalMultilinearSeries \ud835\udd5c (E \u00d7 F) G\n  | 0 => ContinuousMultilinearMap.curry0 \ud835\udd5c _ (f x.1 x.2)\n  | 1 => (continuousMultilinearCurryFin1 \ud835\udd5c (E \u00d7 F) G).symm (f.deriv\u2082 x)\n  | 2 => f.uncurryBilinear\n  | _ => 0", "start": [68, 1], "end": [73, 11], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.fpowerSeriesBilinear_apply_zero", "code": "theorem fpowerSeriesBilinear_apply_zero (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (x : E \u00d7 F) :\n    fpowerSeriesBilinear f x 0 = ContinuousMultilinearMap.curry0 \ud835\udd5c _ (f x.1 x.2)", "start": [76, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.fpowerSeriesBilinear_apply_one", "code": "theorem fpowerSeriesBilinear_apply_one (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (x : E \u00d7 F) :\n    fpowerSeriesBilinear f x 1 = (continuousMultilinearCurryFin1 \ud835\udd5c (E \u00d7 F) G).symm (f.deriv\u2082 x)", "start": [80, 1], "end": [82, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.fpowerSeriesBilinear_apply_two", "code": "theorem fpowerSeriesBilinear_apply_two (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (x : E \u00d7 F) :\n    fpowerSeriesBilinear f x 2 = f.uncurryBilinear", "start": [84, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.fpowerSeriesBilinear_apply_add_three", "code": "theorem fpowerSeriesBilinear_apply_add_three (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (x : E \u00d7 F) (n) :\n    fpowerSeriesBilinear f x (n + 3) = 0", "start": [88, 1], "end": [90, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.fpowerSeriesBilinear_radius", "code": "@[simp]\ntheorem fpowerSeriesBilinear_radius (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (x : E \u00d7 F) :\n    (f.fpowerSeriesBilinear x).radius = \u221e", "start": [100, 1], "end": [103, 86], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.hasFPowerSeriesOnBall_bilinear", "code": "protected theorem hasFPowerSeriesOnBall_bilinear (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (x : E \u00d7 F) :\n    HasFPowerSeriesOnBall (fun x : E \u00d7 F => f x.1 x.2) (f.fpowerSeriesBilinear x) x \u221e", "start": [106, 1], "end": [114, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.hasFPowerSeriesAt_bilinear", "code": "protected theorem hasFPowerSeriesAt_bilinear (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (x : E \u00d7 F) :\n    HasFPowerSeriesAt (fun x : E \u00d7 F => f x.1 x.2) (f.fpowerSeriesBilinear x) x", "start": [117, 1], "end": [119, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.analyticAt_bilinear", "code": "protected theorem analyticAt_bilinear (f : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) (x : E \u00d7 F) :\n    AnalyticAt \ud835\udd5c (fun x : E \u00d7 F => f x.1 x.2) x", "start": [122, 1], "end": [124, 46], "kind": "commanddeclaration"}, {"full_name": "analyticAt_id", "code": "lemma analyticAt_id (z : E) : AnalyticAt \ud835\udd5c (id : E \u2192 E) z :=\n  (ContinuousLinearMap.id \ud835\udd5c E).analyticAt z", "start": [131, 1], "end": [132, 44], "kind": "mathlibtacticlemma"}, {"full_name": "analyticAt_smul", "code": "lemma analyticAt_smul\n    {\ud835\udd5d : Type*} [NormedField \ud835\udd5d] [NormedAlgebra \ud835\udd5c \ud835\udd5d] [NormedSpace \ud835\udd5d E] [IsScalarTower \ud835\udd5c \ud835\udd5d E]\n    (z : \ud835\udd5d \u00d7 E) : AnalyticAt \ud835\udd5c (fun x : \ud835\udd5d \u00d7 E \u21a6 x.1 \u2022 x.2) z :=\n  (ContinuousLinearMap.lsmul \ud835\udd5c \ud835\udd5d).analyticAt_bilinear z", "start": [134, 1], "end": [142, 56], "kind": "mathlibtacticlemma"}, {"full_name": "analyticAt_mul", "code": "lemma analyticAt_mul {A : Type*} [NormedRing A] [NormedAlgebra \ud835\udd5c A] (z : A \u00d7 A) :\n    AnalyticAt \ud835\udd5c (fun x : A \u00d7 A \u21a6 x.1 * x.2) z :=\n  (ContinuousLinearMap.mul \ud835\udd5c A).analyticAt_bilinear z", "start": [144, 1], "end": [147, 54], "kind": "mathlibtacticlemma"}, {"full_name": "AnalyticAt.smul", "code": "lemma smul {\ud835\udd5d : Type*} [NontriviallyNormedField \ud835\udd5d] [NormedSpace \ud835\udd5d F] [NormedAlgebra \ud835\udd5c \ud835\udd5d]\n    [IsScalarTower \ud835\udd5c \ud835\udd5d F] {f : E \u2192 \ud835\udd5d} {g : E \u2192 F} {z : E}\n    (hf : AnalyticAt \ud835\udd5c f z) (hg : AnalyticAt \ud835\udd5c g z) :\n    AnalyticAt \ud835\udd5c (f \u2022 g) z :=\n  @AnalyticAt.comp \ud835\udd5c E (\ud835\udd5d \u00d7 F) F _ _ _ _ _ _ _\n    (fun x \u21a6 x.1 \u2022 x.2) (fun e \u21a6 (f e, g e)) z (analyticAt_smul _ _) (hf.prod hg)", "start": [152, 1], "end": [158, 82], "kind": "mathlibtacticlemma"}, {"full_name": "AnalyticAt.mul", "code": "lemma mul {A : Type*} [NormedRing A] [NormedAlgebra \ud835\udd5c A]\n    {f g : E \u2192 A} {z : E}\n    (hf : AnalyticAt \ud835\udd5c f z) (hg : AnalyticAt \ud835\udd5c g z) : AnalyticAt \ud835\udd5c (f * g) z :=\n  @AnalyticAt.comp \ud835\udd5c E (A \u00d7 A) A _ _ _ _ _ _ _\n    (fun x \u21a6 x.1 * x.2) (fun e \u21a6 (f e, g e)) z (analyticAt_mul _ (f z, g z)) (hf.prod hg)", "start": [160, 1], "end": [165, 90], "kind": "mathlibtacticlemma"}, {"full_name": "AnalyticAt.pow", "code": "lemma pow {A : Type*} [NormedRing A] [NormedAlgebra \ud835\udd5c A]\n    {f : E \u2192 A} {z : E} (hf : AnalyticAt \ud835\udd5c f z) (n : \u2115) :\n    AnalyticAt \ud835\udd5c (f ^ n) z := by\n  induction' n with m hm\n  \u00b7 rw [pow_zero]\n    exact (analyticAt_const : AnalyticAt \ud835\udd5c (fun _ \u21a6 (1 : A)) z)\n  \u00b7 exact pow_succ f m \u25b8 hf.mul hm", "start": [167, 1], "end": [174, 35], "kind": "mathlibtacticlemma"}, {"full_name": "analyticAt_inv", "code": "lemma analyticAt_inv {\ud835\udd5d : Type*} [NontriviallyNormedField \ud835\udd5d] [NormedAlgebra \ud835\udd5c \ud835\udd5d]\n    {z : \ud835\udd5d} (hz : z \u2260 0) : AnalyticAt \ud835\udd5c Inv.inv z := by\n  let f1 : \ud835\udd5d \u2192 \ud835\udd5d := fun a \u21a6 1 / z * a\n  let f2 : \ud835\udd5d \u2192 \ud835\udd5d := fun b \u21a6 (1 - b)\u207b\u00b9\n  let f3 : \ud835\udd5d \u2192 \ud835\udd5d := fun c \u21a6 1 - c / z\n  have feq : f1 \u2218 f2 \u2218 f3 = Inv.inv\n  \u00b7 ext1 x\n    dsimp only [Function.comp_apply]\n    field_simp\n  have f3val : f3 z = 0 := by simp only [div_self hz, sub_self]\n  have f3an : AnalyticAt \ud835\udd5c f3 z\n  \u00b7 apply analyticAt_const.sub\n    simpa only [div_eq_inv_mul] using analyticAt_const.mul (analyticAt_id \ud835\udd5c z)\n  exact feq \u25b8 (analyticAt_const.mul (analyticAt_id _ _)).comp\n    ((f3val.symm \u25b8 analyticAt_inv_one_sub \ud835\udd5d).comp f3an)", "start": [178, 1], "end": [194, 56], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Geometry/Manifold/ChartedSpace.lean", "imports": ["Mathlib/Topology/LocalHomeomorph.lean", "Mathlib/Init/Align.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "StructureGroupoid", "code": "structure StructureGroupoid (H : Type u) [TopologicalSpace H] where\n  members : Set (LocalHomeomorph H H)\n  trans' : \u2200 e e' : LocalHomeomorph H H, e \u2208 members \u2192 e' \u2208 members \u2192 e \u226b\u2095 e' \u2208 members\n  symm' : \u2200 e : LocalHomeomorph H H, e \u2208 members \u2192 e.symm \u2208 members\n  id_mem' : LocalHomeomorph.refl H \u2208 members\n  locality' : \u2200 e : LocalHomeomorph H H,\n    (\u2200 x \u2208 e.source, \u2203 s, IsOpen s \u2227 x \u2208 s \u2227 e.restr s \u2208 members) \u2192 e \u2208 members\n  eq_on_source' : \u2200 e e' : LocalHomeomorph H H, e \u2208 members \u2192 e' \u2248 e \u2192 e' \u2208 members", "start": [164, 1], "end": [173, 84], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.trans", "code": "theorem StructureGroupoid.trans (G : StructureGroupoid H) {e e' : LocalHomeomorph H H} (he : e \u2208 G)\n    (he' : e' \u2208 G) : e \u226b\u2095 e' \u2208 G", "start": [234, 1], "end": [236, 23], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.symm", "code": "theorem StructureGroupoid.symm (G : StructureGroupoid H) {e : LocalHomeomorph H H} (he : e \u2208 G) :\n    e.symm \u2208 G", "start": [239, 1], "end": [241, 15], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.id_mem", "code": "theorem StructureGroupoid.id_mem (G : StructureGroupoid H) : LocalHomeomorph.refl H \u2208 G", "start": [244, 1], "end": [245, 12], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.locality", "code": "theorem StructureGroupoid.locality (G : StructureGroupoid H) {e : LocalHomeomorph H H}\n    (h : \u2200 x \u2208 e.source, \u2203 s, IsOpen s \u2227 x \u2208 s \u2227 e.restr s \u2208 G) : e \u2208 G", "start": [248, 1], "end": [250, 18], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.eq_on_source", "code": "theorem StructureGroupoid.eq_on_source (G : StructureGroupoid H) {e e' : LocalHomeomorph H H}\n    (he : e \u2208 G) (h : e' \u2248 e) : e' \u2208 G", "start": [253, 1], "end": [255, 28], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.partialOrder", "code": "instance StructureGroupoid.partialOrder : PartialOrder (StructureGroupoid H) :=\n  PartialOrder.lift StructureGroupoid.members fun a b h \u21a6 by\n    cases a\n    cases b\n    dsimp at h\n    induction h\n    rfl", "start": [258, 1], "end": [265, 8], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.le_iff", "code": "theorem StructureGroupoid.le_iff {G\u2081 G\u2082 : StructureGroupoid H} : G\u2081 \u2264 G\u2082 \u2194 \u2200 e, e \u2208 G\u2081 \u2192 e \u2208 G\u2082", "start": [268, 1], "end": [269, 10], "kind": "commanddeclaration"}, {"full_name": "idGroupoid", "code": "def idGroupoid (H : Type u) [TopologicalSpace H] : StructureGroupoid H where\n  members := {LocalHomeomorph.refl H} \u222a { e : LocalHomeomorph H H | e.source = \u2205 }\n  trans' e e' he he' := by\n    cases' he with he he\n    \u00b7 simpa only [mem_singleton_iff.1 he, refl_trans]\n    \u00b7 have : (e \u226b\u2095 e').source \u2286 e.source := sep_subset _ _\n      rw [he] at this\n      have : e \u226b\u2095 e' \u2208 { e : LocalHomeomorph H H | e.source = \u2205 } := eq_bot_iff.2 this\n      exact (mem_union _ _ _).2 (Or.inr this)\n  symm' e he := by\n    cases' (mem_union _ _ _).1 he with E E\n    \u00b7 simp [mem_singleton_iff.mp E]\n    \u00b7 right\n      simpa only [e.toLocalEquiv.image_source_eq_target.symm, mfld_simps] using E\n  id_mem' := mem_union_left _ rfl\n  locality' e he := by\n    cases' e.source.eq_empty_or_nonempty with h h\n    \u00b7 right\n      exact h\n    \u00b7 left\n      rcases h with \u27e8x, hx\u27e9\n      rcases he x hx with \u27e8s, open_s, xs, hs\u27e9\n      have x's : x \u2208 (e.restr s).source := by\n        rw [restr_source, open_s.interior_eq]\n        exact \u27e8hx, xs\u27e9\n      cases' hs with hs hs\n      \u00b7 replace hs : LocalHomeomorph.restr e s = LocalHomeomorph.refl H\n        \u00b7 simpa only using hs\n        have : (e.restr s).source = univ := by\n          rw [hs]\n          simp\n        have : e.toLocalEquiv.source \u2229 interior s = univ := this\n        have : univ \u2286 interior s := by\n          rw [\u2190 this]\n          exact inter_subset_right _ _\n        have : s = univ := by rwa [open_s.interior_eq, univ_subset_iff] at this\n        simpa only [this, restr_univ] using hs\n      \u00b7 exfalso\n        rw [mem_setOf_eq] at hs\n        rwa [hs] at x's\n  eq_on_source' e e' he he'e := by\n    cases' he with he he\n    \u00b7 left\n      have : e = e' := by\n        refine' eq_of_eq_on_source_univ (Setoid.symm he'e) _ _ <;>\n          rw [Set.mem_singleton_iff.1 he] <;> rfl\n      rwa [\u2190 this]\n    \u00b7 right\n      have he : e.toLocalEquiv.source = \u2205 := he\n      rwa [Set.mem_setOf_eq, EqOnSource.source_eq he'e]", "start": [272, 1], "end": [323, 56], "kind": "commanddeclaration"}, {"full_name": "instStructureGroupoidOrderBot", "code": "instance instStructureGroupoidOrderBot : OrderBot (StructureGroupoid H) where\n  bot := idGroupoid H\n  bot_le := by\n    intro u f hf\n    have hf : f \u2208 {LocalHomeomorph.refl H} \u222a { e : LocalHomeomorph H H | e.source = \u2205 } := hf\n    simp only [singleton_union, mem_setOf_eq, mem_insert_iff] at hf\n    cases' hf with hf hf\n    \u00b7 rw [hf]\n      apply u.id_mem\n    \u00b7 apply u.locality\n      intro x hx\n      rw [hf, mem_empty_iff_false] at hx\n      exact hx.elim", "start": [326, 1], "end": [339, 20], "kind": "commanddeclaration"}, {"full_name": "Pregroupoid", "code": "structure Pregroupoid (H : Type*) [TopologicalSpace H] where\n  property : (H \u2192 H) \u2192 Set H \u2192 Prop\n  comp : \u2200 {f g u v}, property f u \u2192 property g v \u2192\n    IsOpen u \u2192 IsOpen v \u2192 IsOpen (u \u2229 f \u207b\u00b9' v) \u2192 property (g \u2218 f) (u \u2229 f \u207b\u00b9' v)\n  id_mem : property id univ\n  locality :\n    \u2200 {f u}, IsOpen u \u2192 (\u2200 x \u2208 u, \u2203 v, IsOpen v \u2227 x \u2208 v \u2227 property f (u \u2229 v)) \u2192 property f u\n  congr : \u2200 {f g : H \u2192 H} {u}, IsOpen u \u2192 (\u2200 x \u2208 u, g x = f x) \u2192 property f u \u2192 property g u", "start": [343, 1], "end": [354, 93], "kind": "commanddeclaration"}, {"full_name": "Pregroupoid.groupoid", "code": "def Pregroupoid.groupoid (PG : Pregroupoid H) : StructureGroupoid H where\n  members := { e : LocalHomeomorph H H | PG.property e e.source \u2227 PG.property e.symm e.target }\n  trans' e e' he he' := by\n    constructor\n    \u00b7 apply PG.comp he.1 he'.1 e.open_source e'.open_source\n      apply e.continuous_toFun.preimage_open_of_open e.open_source e'.open_source\n    \u00b7 apply PG.comp he'.2 he.2 e'.open_target e.open_target\n      apply e'.continuous_invFun.preimage_open_of_open e'.open_target e.open_target\n  symm' e he := \u27e8he.2, he.1\u27e9\n  id_mem' := \u27e8PG.id_mem, PG.id_mem\u27e9\n  locality' e he := by\n    constructor\n    \u00b7 refine' PG.locality e.open_source fun x xu \u21a6 _\n      rcases he x xu with \u27e8s, s_open, xs, hs\u27e9\n      refine' \u27e8s, s_open, xs, _\u27e9\n      convert hs.1 using 1\n      dsimp [LocalHomeomorph.restr]\n      rw [s_open.interior_eq]\n    \u00b7 refine' PG.locality e.open_target fun x xu \u21a6 _\n      rcases he (e.symm x) (e.map_target xu) with \u27e8s, s_open, xs, hs\u27e9\n      refine' \u27e8e.target \u2229 e.symm \u207b\u00b9' s, _, \u27e8xu, xs\u27e9, _\u27e9\n      \u00b7 exact ContinuousOn.preimage_open_of_open e.continuous_invFun e.open_target s_open\n      \u00b7 rw [\u2190 inter_assoc, inter_self]\n        convert hs.2 using 1\n        dsimp [LocalHomeomorph.restr]\n        rw [s_open.interior_eq]\n  eq_on_source' e e' he ee' := by\n    constructor\n    \u00b7 apply PG.congr e'.open_source ee'.2\n      simp only [ee'.1, he.1]\n    \u00b7 have A := EqOnSource.symm' ee'\n      apply PG.congr e'.symm.open_source A.2\n      rw [A.1, symm_toLocalEquiv, LocalEquiv.symm_source]\n      exact he.2", "start": [357, 1], "end": [396, 17], "kind": "commanddeclaration"}, {"full_name": "mem_groupoid_of_pregroupoid", "code": "theorem mem_groupoid_of_pregroupoid {PG : Pregroupoid H} {e : LocalHomeomorph H H} :\n    e \u2208 PG.groupoid \u2194 PG.property e e.source \u2227 PG.property e.symm e.target", "start": [399, 1], "end": [401, 10], "kind": "commanddeclaration"}, {"full_name": "groupoid_of_pregroupoid_le", "code": "theorem groupoid_of_pregroupoid_le (PG\u2081 PG\u2082 : Pregroupoid H)\n    (h : \u2200 f s, PG\u2081.property f s \u2192 PG\u2082.property f s) : PG\u2081.groupoid \u2264 PG\u2082.groupoid", "start": [404, 1], "end": [408, 33], "kind": "commanddeclaration"}, {"full_name": "mem_pregroupoid_of_eq_on_source", "code": "theorem mem_pregroupoid_of_eq_on_source (PG : Pregroupoid H) {e e' : LocalHomeomorph H H}\n    (he' : e \u2248 e') (he : PG.property e e.source) : PG.property e' e'.source", "start": [411, 1], "end": [414, 48], "kind": "commanddeclaration"}, {"full_name": "continuousPregroupoid", "code": "@[reducible]\ndef continuousPregroupoid (H : Type*) [TopologicalSpace H] : Pregroupoid H where\n  property _ _ := True\n  comp _ _ _ _ _ := trivial\n  id_mem := trivial\n  locality _ _ := trivial\n  congr _ _ _ := trivial", "start": [417, 1], "end": [424, 25], "kind": "commanddeclaration"}, {"full_name": "continuousGroupoid", "code": "def continuousGroupoid (H : Type*) [TopologicalSpace H] : StructureGroupoid H :=\n  Pregroupoid.groupoid (continuousPregroupoid H)", "start": [430, 1], "end": [432, 49], "kind": "commanddeclaration"}, {"full_name": "instStructureGroupoidOrderTop", "code": "instance instStructureGroupoidOrderTop : OrderTop (StructureGroupoid H) where\n  top := continuousGroupoid H\n  le_top _ _ _ := \u27e8trivial, trivial\u27e9", "start": [435, 1], "end": [438, 37], "kind": "commanddeclaration"}, {"full_name": "ClosedUnderRestriction", "code": "class ClosedUnderRestriction (G : StructureGroupoid H) : Prop where\n  closedUnderRestriction :\n    \u2200 {e : LocalHomeomorph H H}, e \u2208 G \u2192 \u2200 s : Set H, IsOpen s \u2192 e.restr s \u2208 G", "start": [457, 1], "end": [461, 79], "kind": "commanddeclaration"}, {"full_name": "closedUnderRestriction'", "code": "theorem closedUnderRestriction' {G : StructureGroupoid H} [ClosedUnderRestriction G]\n    {e : LocalHomeomorph H H} (he : e \u2208 G) {s : Set H} (hs : IsOpen s) : e.restr s \u2208 G", "start": [464, 1], "end": [466, 56], "kind": "commanddeclaration"}, {"full_name": "idRestrGroupoid", "code": "def idRestrGroupoid : StructureGroupoid H where\n  members := { e | \u2203 (s : Set H) (h : IsOpen s), e \u2248 LocalHomeomorph.ofSet s h }\n  trans' := by\n    rintro e e' \u27e8s, hs, hse\u27e9 \u27e8s', hs', hse'\u27e9\n    refine' \u27e8s \u2229 s', IsOpen.inter hs hs', _\u27e9\n    have := LocalHomeomorph.EqOnSource.trans' hse hse'\n    rwa [LocalHomeomorph.ofSet_trans_ofSet] at this\n  symm' := by\n    rintro e \u27e8s, hs, hse\u27e9\n    refine' \u27e8s, hs, _\u27e9\n    rw [\u2190 ofSet_symm]\n    exact LocalHomeomorph.EqOnSource.symm' hse\n  id_mem' := \u27e8univ, isOpen_univ, by simp only [mfld_simps, refl]\u27e9\n  locality' := by\n    intro e h\n    refine' \u27e8e.source, e.open_source, by simp only [mfld_simps], _\u27e9\n    intro x hx\n    rcases h x hx with \u27e8s, hs, hxs, s', hs', hes'\u27e9\n    have hes : x \u2208 (e.restr s).source := by\n      rw [e.restr_source]\n      refine' \u27e8hx, _\u27e9\n      rw [hs.interior_eq]\n      exact hxs\n    simpa only [mfld_simps] using LocalHomeomorph.EqOnSource.eqOn hes' hes\n  eq_on_source' := by\n    rintro e e' \u27e8s, hs, hse\u27e9 hee'\n    exact \u27e8s, hs, Setoid.trans hee' hse\u27e9", "start": [469, 1], "end": [497, 41], "kind": "commanddeclaration"}, {"full_name": "idRestrGroupoid_mem", "code": "theorem idRestrGroupoid_mem {s : Set H} (hs : IsOpen s) : ofSet s hs \u2208 @idRestrGroupoid H _", "start": [500, 1], "end": [501, 18], "kind": "commanddeclaration"}, {"full_name": "closedUnderRestriction_idRestrGroupoid", "code": "instance closedUnderRestriction_idRestrGroupoid : ClosedUnderRestriction (@idRestrGroupoid H _) :=\n  \u27e8by\n    rintro e \u27e8s', hs', he\u27e9 s hs\n    use s' \u2229 s, IsOpen.inter hs' hs\n    refine' Setoid.trans (LocalHomeomorph.EqOnSource.restr he s) _\n    exact \u27e8by simp only [hs.interior_eq, mfld_simps], by simp only [mfld_simps, eqOn_refl]\u27e9\u27e9", "start": [504, 1], "end": [510, 93], "kind": "commanddeclaration"}, {"full_name": "closedUnderRestriction_iff_id_le", "code": "theorem closedUnderRestriction_iff_id_le (G : StructureGroupoid H) :\n    ClosedUnderRestriction G \u2194 idRestrGroupoid \u2264 G", "start": [513, 1], "end": [537, 33], "kind": "commanddeclaration"}, {"full_name": "ChartedSpace", "code": "@[ext]\nclass ChartedSpace (H : Type*) [TopologicalSpace H] (M : Type*) [TopologicalSpace M] where\n  protected atlas : Set (LocalHomeomorph M H)\n  protected chartAt : M \u2192 LocalHomeomorph M H\n  protected mem_chart_source : \u2200 x, x \u2208 (chartAt x).source\n  protected chart_mem_atlas : \u2200 x, chartAt x \u2208 atlas", "start": [550, 1], "end": [564, 53], "kind": "commanddeclaration"}, {"full_name": "atlas", "code": "abbrev atlas (H : Type*) [TopologicalSpace H] (M : Type*) [TopologicalSpace M]\n    [ChartedSpace H M] : Set (LocalHomeomorph M H) :=\n  ChartedSpace.atlas", "start": [567, 1], "end": [569, 21], "kind": "commanddeclaration"}, {"full_name": "chartAt", "code": "abbrev chartAt (H : Type*) [TopologicalSpace H] {M : Type*} [TopologicalSpace M]\n    [ChartedSpace H M] (x : M) : LocalHomeomorph M H :=\n  ChartedSpace.chartAt x", "start": [571, 1], "end": [573, 25], "kind": "commanddeclaration"}, {"full_name": "mem_chart_source", "code": "@[simp, mfld_simps]\nlemma mem_chart_source (H : Type*) {M : Type*} [TopologicalSpace H] [TopologicalSpace M]\n    [ChartedSpace H M] (x : M) : x \u2208 (chartAt H x).source :=\n  ChartedSpace.mem_chart_source x", "start": [575, 1], "end": [578, 34], "kind": "mathlibtacticlemma"}, {"full_name": "chart_mem_atlas", "code": "@[simp, mfld_simps]\nlemma chart_mem_atlas (H : Type*) {M : Type*} [TopologicalSpace H] [TopologicalSpace M]\n    [ChartedSpace H M] (x : M) : chartAt H x \u2208 atlas H M :=\n  ChartedSpace.chart_mem_atlas x", "start": [580, 1], "end": [583, 33], "kind": "mathlibtacticlemma"}, {"full_name": "chartedSpaceSelf", "code": "instance chartedSpaceSelf (H : Type*) [TopologicalSpace H] : ChartedSpace H H where\n  atlas := {LocalHomeomorph.refl H}\n  chartAt _ := LocalHomeomorph.refl H\n  mem_chart_source x := mem_univ x\n  chart_mem_atlas _ := mem_singleton _", "start": [587, 1], "end": [592, 39], "kind": "commanddeclaration"}, {"full_name": "chartedSpaceSelf_atlas", "code": "@[simp, mfld_simps]\ntheorem chartedSpaceSelf_atlas {H : Type*} [TopologicalSpace H] {e : LocalHomeomorph H H} :\n    e \u2208 atlas H H \u2194 e = LocalHomeomorph.refl H", "start": [595, 1], "end": [600, 10], "kind": "commanddeclaration"}, {"full_name": "chartAt_self_eq", "code": "theorem chartAt_self_eq {H : Type*} [TopologicalSpace H] {x : H} :\n    chartAt H x = LocalHomeomorph.refl H", "start": [603, 1], "end": [605, 48], "kind": "commanddeclaration"}, {"full_name": "mem_chart_target", "code": "theorem mem_chart_target (x : M) : chartAt H x x \u2208 (chartAt H x).target", "start": [613, 1], "end": [614, 50], "kind": "commanddeclaration"}, {"full_name": "chart_source_mem_nhds", "code": "theorem chart_source_mem_nhds (x : M) : (chartAt H x).source \u2208 \ud835\udcdd x", "start": [617, 1], "end": [618, 61], "kind": "commanddeclaration"}, {"full_name": "chart_target_mem_nhds", "code": "theorem chart_target_mem_nhds (x : M) : (chartAt H x).target \u2208 \ud835\udcdd (chartAt H x x)", "start": [621, 1], "end": [622, 61], "kind": "commanddeclaration"}, {"full_name": "achart", "code": "def achart (x : M) : atlas H M :=\n  \u27e8chartAt H x, chart_mem_atlas H x\u27e9", "start": [625, 1], "end": [628, 37], "kind": "commanddeclaration"}, {"full_name": "achart_def", "code": "theorem achart_def (x : M) : achart H x = \u27e8chartAt H x, chart_mem_atlas H x\u27e9", "start": [631, 1], "end": [632, 6], "kind": "commanddeclaration"}, {"full_name": "coe_achart", "code": "@[simp, mfld_simps]\ntheorem coe_achart (x : M) : (achart H x : LocalHomeomorph M H) = chartAt H x", "start": [635, 1], "end": [637, 6], "kind": "commanddeclaration"}, {"full_name": "achart_val", "code": "@[simp, mfld_simps]\ntheorem achart_val (x : M) : (achart H x).1 = chartAt H x", "start": [640, 1], "end": [642, 6], "kind": "commanddeclaration"}, {"full_name": "mem_achart_source", "code": "theorem mem_achart_source (x : M) : x \u2208 (achart H x).1.source", "start": [645, 1], "end": [646, 23], "kind": "commanddeclaration"}, {"full_name": "ChartedSpace.secondCountable_of_countable_cover", "code": "theorem ChartedSpace.secondCountable_of_countable_cover [SecondCountableTopology H] {s : Set M}\n    (hs : \u22c3 (x) (_ : x \u2208 s), (chartAt H x).source = univ) (hsc : s.Countable) :\n    SecondCountableTopology M", "start": [651, 1], "end": [658, 100], "kind": "commanddeclaration"}, {"full_name": "ChartedSpace.secondCountable_of_sigma_compact", "code": "theorem ChartedSpace.secondCountable_of_sigma_compact [SecondCountableTopology H]\n    [SigmaCompactSpace M] : SecondCountableTopology M", "start": [663, 1], "end": [667, 66], "kind": "commanddeclaration"}, {"full_name": "ChartedSpace.locallyCompactSpace", "code": "theorem ChartedSpace.locallyCompactSpace [LocallyCompactSpace H] : LocallyCompactSpace M", "start": [670, 1], "end": [681, 75], "kind": "commanddeclaration"}, {"full_name": "ChartedSpace.locallyConnectedSpace", "code": "theorem ChartedSpace.locallyConnectedSpace [LocallyConnectedSpace H] : LocallyConnectedSpace M", "start": [684, 1], "end": [695, 80], "kind": "commanddeclaration"}, {"full_name": "ChartedSpace.comp", "code": "def ChartedSpace.comp (H : Type*) [TopologicalSpace H] (H' : Type*) [TopologicalSpace H']\n    (M : Type*) [TopologicalSpace M] [ChartedSpace H H'] [ChartedSpace H' M] :\n    ChartedSpace H M where\n  atlas := image2 LocalHomeomorph.trans (atlas H' M) (atlas H H')\n  chartAt p := (chartAt H' p).trans (chartAt H (chartAt H' p p))\n  mem_chart_source p := by simp only [mfld_simps]\n  chart_mem_atlas p := \u27e8chartAt _ p, chartAt _ _, chart_mem_atlas _ p, chart_mem_atlas _ _, rfl\u27e9", "start": [698, 1], "end": [706, 97], "kind": "commanddeclaration"}, {"full_name": "chartAt_comp", "code": "theorem chartAt_comp (H : Type*) [TopologicalSpace H] (H' : Type*) [TopologicalSpace H']\n    {M : Type*} [TopologicalSpace M] [ChartedSpace H H'] [ChartedSpace H' M] (x : M) :\n    (letI := ChartedSpace.comp H H' M; chartAt H x) = chartAt H' x \u226b\u2095 chartAt H (chartAt H' x x)", "start": [709, 1], "end": [712, 6], "kind": "commanddeclaration"}, {"full_name": "ModelProd", "code": "def ModelProd (H : Type*) (H' : Type*) :=\n  H \u00d7 H'", "start": [732, 1], "end": [735, 9], "kind": "commanddeclaration"}, {"full_name": "ModelPi", "code": "def ModelPi {\u03b9 : Type*} (H : \u03b9 \u2192 Type*) :=\n  \u2200 i, H i", "start": [738, 1], "end": [741, 11], "kind": "commanddeclaration"}, {"full_name": "modelProdInhabited", "code": "instance modelProdInhabited [Inhabited H] [Inhabited H'] : Inhabited (ModelProd H H') :=\n  instInhabitedProd", "start": [748, 1], "end": [749, 20], "kind": "commanddeclaration"}, {"full_name": "modelProd_range_prod_id", "code": "@[simp, mfld_simps, nolint simpNF]\ntheorem modelProd_range_prod_id {H : Type*} {H' : Type*} {\u03b1 : Type*} (f : H \u2192 \u03b1) :\n    (range fun p : ModelProd H H' \u21a6 (f p.1, p.2)) = range f \u00d7\u02e2 (univ : Set H')", "start": [758, 1], "end": [762, 6], "kind": "commanddeclaration"}, {"full_name": "modelPiInhabited", "code": "instance modelPiInhabited [\u2200 i, Inhabited (Hi i)] : Inhabited (ModelPi Hi) :=\n  \u27e8fun _ \u21a6 default\u27e9", "start": [772, 1], "end": [773, 20], "kind": "commanddeclaration"}, {"full_name": "prodChartedSpace", "code": "instance prodChartedSpace (H : Type*) [TopologicalSpace H] (M : Type*) [TopologicalSpace M]\n    [ChartedSpace H M] (H' : Type*) [TopologicalSpace H'] (M' : Type*) [TopologicalSpace M']\n    [ChartedSpace H' M'] : ChartedSpace (ModelProd H H') (M \u00d7 M') where\n  atlas := image2 LocalHomeomorph.prod (atlas H M) (atlas H' M')\n  chartAt x := (chartAt H x.1).prod (chartAt H' x.2)\n  mem_chart_source x := \u27e8mem_chart_source H x.1, mem_chart_source H' x.2\u27e9\n  chart_mem_atlas x := mem_image2_of_mem (chart_mem_atlas H x.1) (chart_mem_atlas H' x.2)", "start": [781, 1], "end": [789, 90], "kind": "commanddeclaration"}, {"full_name": "ModelProd.ext", "code": "@[ext]\ntheorem ModelProd.ext {x y : ModelProd \u03b1 \u03b2} (h\u2081 : x.1 = y.1) (h\u2082 : x.2 = y.2) : x = y", "start": [794, 1], "end": [796, 17], "kind": "commanddeclaration"}, {"full_name": "prodChartedSpace_chartAt", "code": "@[simp, mfld_simps]\ntheorem prodChartedSpace_chartAt :\n    chartAt (ModelProd H H') x = (chartAt H x.fst).prod (chartAt H' x.snd)", "start": [801, 1], "end": [804, 6], "kind": "commanddeclaration"}, {"full_name": "chartedSpaceSelf_prod", "code": "theorem chartedSpaceSelf_prod : prodChartedSpace H H H' H' = chartedSpaceSelf (H \u00d7 H')", "start": [807, 1], "end": [812, 8], "kind": "commanddeclaration"}, {"full_name": "piChartedSpace", "code": "instance piChartedSpace {\u03b9 : Type*} [Fintype \u03b9] (H : \u03b9 \u2192 Type*) [\u2200 i, TopologicalSpace (H i)]\n    (M : \u03b9 \u2192 Type*) [\u2200 i, TopologicalSpace (M i)] [\u2200 i, ChartedSpace (H i) (M i)] :\n    ChartedSpace (ModelPi H) (\u2200 i, M i) where\n  atlas := LocalHomeomorph.pi '' Set.pi univ fun _ \u21a6 atlas (H _) (M _)\n  chartAt f := LocalHomeomorph.pi fun i \u21a6 chartAt (H i) (f i)\n  mem_chart_source f i _ := mem_chart_source (H i) (f i)\n  chart_mem_atlas f := mem_image_of_mem _ fun i _ \u21a6 chart_mem_atlas (H i) (f i)", "start": [817, 1], "end": [825, 80], "kind": "commanddeclaration"}, {"full_name": "piChartedSpace_chartAt", "code": "@[simp, mfld_simps]\ntheorem piChartedSpace_chartAt {\u03b9 : Type*} [Fintype \u03b9] (H : \u03b9 \u2192 Type*)\n    [\u2200 i, TopologicalSpace (H i)] (M : \u03b9 \u2192 Type*) [\u2200 i, TopologicalSpace (M i)]\n    [\u2200 i, ChartedSpace (H i) (M i)] (f : \u2200 i, M i) :\n    chartAt (H := ModelPi H) f = LocalHomeomorph.pi fun i \u21a6 chartAt (H i) (f i)", "start": [828, 1], "end": [833, 6], "kind": "commanddeclaration"}, {"full_name": "ChartedSpaceCore", "code": "structure ChartedSpaceCore (H : Type*) [TopologicalSpace H] (M : Type*) where\n  atlas : Set (LocalEquiv M H)\n  chartAt : M \u2192 LocalEquiv M H\n  mem_chart_source : \u2200 x, x \u2208 (chartAt x).source\n  chart_mem_atlas : \u2200 x, chartAt x \u2208 atlas\n  open_source : \u2200 e e' : LocalEquiv M H, e \u2208 atlas \u2192 e' \u2208 atlas \u2192 IsOpen (e.symm.trans e').source\n  continuous_toFun : \u2200 e e' : LocalEquiv M H, e \u2208 atlas \u2192 e' \u2208 atlas \u2192\n    ContinuousOn (e.symm.trans e') (e.symm.trans e').source", "start": [841, 1], "end": [853, 60], "kind": "commanddeclaration"}, {"full_name": "ChartedSpaceCore.toTopologicalSpace", "code": "protected def toTopologicalSpace : TopologicalSpace M :=\n  TopologicalSpace.generateFrom <|\n    \u22c3 (e : LocalEquiv M H) (_ : e \u2208 c.atlas) (s : Set H) (_ : IsOpen s),\n      {e \u207b\u00b9' s \u2229 e.source}", "start": [860, 1], "end": [864, 27], "kind": "commanddeclaration"}, {"full_name": "ChartedSpaceCore.open_source'", "code": "theorem open_source' (he : e \u2208 c.atlas) : IsOpen[c.toTopologicalSpace] e.source", "start": [867, 1], "end": [871, 48], "kind": "commanddeclaration"}, {"full_name": "ChartedSpaceCore.open_target", "code": "theorem open_target (he : e \u2208 c.atlas) : IsOpen e.target", "start": [874, 1], "end": [878, 67], "kind": "commanddeclaration"}, {"full_name": "ChartedSpaceCore.localHomeomorph", "code": "protected def localHomeomorph (e : LocalEquiv M H) (he : e \u2208 c.atlas) :\n    @LocalHomeomorph M H c.toTopologicalSpace _ :=\n  { c.toTopologicalSpace, e with\n    open_source := by convert c.open_source' he\n    open_target := by convert c.open_target he\n    continuous_toFun := by\n      letI : TopologicalSpace M := c.toTopologicalSpace\n      rw [continuousOn_open_iff (c.open_source' he)]\n      intro s s_open\n      rw [inter_comm]\n      apply TopologicalSpace.GenerateOpen.basic\n      simp only [exists_prop, mem_iUnion, mem_singleton_iff]\n      exact \u27e8e, he, \u27e8s, s_open, rfl\u27e9\u27e9\n    continuous_invFun := by\n      letI : TopologicalSpace M := c.toTopologicalSpace\n      apply continuousOn_open_of_generateFrom\n      intro t ht\n      simp only [exists_prop, mem_iUnion, mem_singleton_iff] at ht\n      rcases ht with \u27e8e', e'_atlas, s, s_open, ts\u27e9\n      rw [ts]\n      let f := e.symm.trans e'\n      have : IsOpen (f \u207b\u00b9' s \u2229 f.source) := by\n        simpa [inter_comm] using (continuousOn_open_iff (c.open_source e e' he e'_atlas)).1\n          (c.continuous_toFun e e' he e'_atlas) s s_open\n      have A : e' \u2218 e.symm \u207b\u00b9' s \u2229 (e.target \u2229 e.symm \u207b\u00b9' e'.source) =\n          e.target \u2229 (e' \u2218 e.symm \u207b\u00b9' s \u2229 e.symm \u207b\u00b9' e'.source) := by\n        rw [\u2190 inter_assoc, \u2190 inter_assoc]\n        congr 1\n        exact inter_comm _ _\n      simpa [LocalEquiv.trans_source, preimage_inter, preimage_comp.symm, A] using this }", "start": [881, 1], "end": [913, 90], "kind": "commanddeclaration"}, {"full_name": "ChartedSpaceCore.toChartedSpace", "code": "def toChartedSpace : @ChartedSpace H _ M c.toTopologicalSpace :=\n  { c.toTopologicalSpace with\n    atlas := \u22c3 (e : LocalEquiv M H) (he : e \u2208 c.atlas), {c.localHomeomorph e he}\n    chartAt := fun x \u21a6 c.localHomeomorph (c.chartAt x) (c.chart_mem_atlas x)\n    mem_chart_source := fun x \u21a6 c.mem_chart_source x\n    chart_mem_atlas := fun x \u21a6 by\n      simp only [mem_iUnion, mem_singleton_iff]\n      exact \u27e8c.chartAt x, c.chart_mem_atlas x, rfl\u27e9}", "start": [916, 1], "end": [925, 53], "kind": "commanddeclaration"}, {"full_name": "HasGroupoid", "code": "class HasGroupoid {H : Type*} [TopologicalSpace H] (M : Type*) [TopologicalSpace M]\n    [ChartedSpace H M] (G : StructureGroupoid H) : Prop where\n  compatible : \u2200 {e e' : LocalHomeomorph M H}, e \u2208 atlas H M \u2192 e' \u2208 atlas H M \u2192 e.symm \u226b\u2095 e' \u2208 G", "start": [937, 1], "end": [941, 97], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.compatible", "code": "theorem StructureGroupoid.compatible {H : Type*} [TopologicalSpace H] (G : StructureGroupoid H)\n    {M : Type*} [TopologicalSpace M] [ChartedSpace H M] [HasGroupoid M G]\n    {e e' : LocalHomeomorph M H} (he : e \u2208 atlas H M) (he' : e' \u2208 atlas H M) : e.symm \u226b\u2095 e' \u2208 G", "start": [944, 1], "end": [950, 32], "kind": "commanddeclaration"}, {"full_name": "hasGroupoid_of_le", "code": "theorem hasGroupoid_of_le {G\u2081 G\u2082 : StructureGroupoid H} (h : HasGroupoid M G\u2081) (hle : G\u2081 \u2264 G\u2082) :\n    HasGroupoid M G\u2082", "start": [953, 1], "end": [955, 43], "kind": "commanddeclaration"}, {"full_name": "hasGroupoid_inf_iff", "code": "theorem hasGroupoid_inf_iff {G\u2081 G\u2082 : StructureGroupoid H} : HasGroupoid M (G\u2081 \u2293 G\u2082) \u2194\n    HasGroupoid M G\u2081 \u2227 HasGroupoid M G\u2082", "start": [958, 1], "end": [961, 94], "kind": "commanddeclaration"}, {"full_name": "hasGroupoid_of_pregroupoid", "code": "theorem hasGroupoid_of_pregroupoid (PG : Pregroupoid H) (h : \u2200 {e e' : LocalHomeomorph M H},\n    e \u2208 atlas H M \u2192 e' \u2208 atlas H M \u2192 PG.property (e.symm \u226b\u2095 e') (e.symm \u226b\u2095 e').source) :\n    HasGroupoid M PG.groupoid", "start": [963, 1], "end": [966, 70], "kind": "commanddeclaration"}, {"full_name": "hasGroupoid_model_space", "code": "instance hasGroupoid_model_space (H : Type*) [TopologicalSpace H] (G : StructureGroupoid H) :\n    HasGroupoid H G where\n  compatible {e e'} he he' := by\n    rw [chartedSpaceSelf_atlas] at he he'\n    simp [he, he', StructureGroupoid.id_mem]", "start": [969, 1], "end": [974, 45], "kind": "commanddeclaration"}, {"full_name": "hasGroupoid_continuousGroupoid", "code": "instance hasGroupoid_continuousGroupoid : HasGroupoid M (continuousGroupoid H) := by\n  refine' \u27e8fun _ _ \u21a6 _\u27e9\n  rw [continuousGroupoid, mem_groupoid_of_pregroupoid]\n  simp only [and_self_iff]", "start": [977, 1], "end": [981, 27], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.maximalAtlas", "code": "def StructureGroupoid.maximalAtlas : Set (LocalHomeomorph M H) :=\n  { e | \u2200 e' \u2208 atlas H M, e.symm \u226b\u2095 e' \u2208 G \u2227 e'.symm \u226b\u2095 e \u2208 G }", "start": [988, 1], "end": [992, 64], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.subset_maximalAtlas", "code": "theorem StructureGroupoid.subset_maximalAtlas [HasGroupoid M G] : atlas H M \u2286 G.maximalAtlas M", "start": [997, 1], "end": [999, 62], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.chart_mem_maximalAtlas", "code": "theorem StructureGroupoid.chart_mem_maximalAtlas [HasGroupoid M G] (x : M) :\n    chartAt H x \u2208 G.maximalAtlas M", "start": [1002, 1], "end": [1004, 46], "kind": "commanddeclaration"}, {"full_name": "mem_maximalAtlas_iff", "code": "theorem mem_maximalAtlas_iff {e : LocalHomeomorph M H} :\n    e \u2208 G.maximalAtlas M \u2194 \u2200 e' \u2208 atlas H M, e.symm \u226b\u2095 e' \u2208 G \u2227 e'.symm \u226b\u2095 e \u2208 G", "start": [1009, 1], "end": [1011, 10], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.compatible_of_mem_maximalAtlas", "code": "theorem StructureGroupoid.compatible_of_mem_maximalAtlas {e e' : LocalHomeomorph M H}\n    (he : e \u2208 G.maximalAtlas M) (he' : e' \u2208 G.maximalAtlas M) : e.symm \u226b\u2095 e' \u2208 G", "start": [1014, 1], "end": [1037, 41], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.id_mem_maximalAtlas", "code": "theorem StructureGroupoid.id_mem_maximalAtlas : LocalHomeomorph.refl H \u2208 G.maximalAtlas H", "start": [1042, 1], "end": [1044, 35], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.mem_maximalAtlas_of_mem_groupoid", "code": "theorem StructureGroupoid.mem_maximalAtlas_of_mem_groupoid {f : LocalHomeomorph H H} (hf : f \u2208 G) :\n    f \u2208 G.maximalAtlas H", "start": [1047, 1], "end": [1051, 69], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.singletonChartedSpace", "code": "def singletonChartedSpace (h : e.source = Set.univ) : ChartedSpace H \u03b1 where\n  atlas := {e}\n  chartAt _ := e\n  mem_chart_source _ := by rw [h]; apply mem_univ\n  chart_mem_atlas _ := by tauto", "start": [1064, 1], "end": [1072, 32], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.singletonChartedSpace_chartAt_eq", "code": "@[simp, mfld_simps]\ntheorem singletonChartedSpace_chartAt_eq (h : e.source = Set.univ) {x : \u03b1} :\n    @chartAt H _ \u03b1 _ (e.singletonChartedSpace h) x = e", "start": [1075, 1], "end": [1078, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.singletonChartedSpace_chartAt_source", "code": "theorem singletonChartedSpace_chartAt_source (h : e.source = Set.univ) {x : \u03b1} :\n    (@chartAt H _ \u03b1 _ (e.singletonChartedSpace h) x).source = Set.univ", "start": [1081, 1], "end": [1083, 4], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.singletonChartedSpace_mem_atlas_eq", "code": "theorem singletonChartedSpace_mem_atlas_eq (h : e.source = Set.univ) (e' : LocalHomeomorph \u03b1 H)\n    (h' : e' \u2208 (e.singletonChartedSpace h).atlas) : e' = e", "start": [1086, 1], "end": [1088, 5], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.singleton_hasGroupoid", "code": "theorem singleton_hasGroupoid (h : e.source = Set.univ) (G : StructureGroupoid H)\n    [ClosedUnderRestriction G] : @HasGroupoid _ _ _ _ (e.singletonChartedSpace h) G", "start": [1091, 1], "end": [1103, 72], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.singletonChartedSpace", "code": "def singletonChartedSpace {f : \u03b1 \u2192 H} (h : OpenEmbedding f) : ChartedSpace H \u03b1 :=\n  (h.toLocalHomeomorph f).singletonChartedSpace (toLocalHomeomorph_source _ _)", "start": [1112, 1], "end": [1115, 79], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.singletonChartedSpace_chartAt_eq", "code": "theorem singletonChartedSpace_chartAt_eq {f : \u03b1 \u2192 H} (h : OpenEmbedding f) {x : \u03b1} :\n    \u21d1(@chartAt H _ \u03b1 _ h.singletonChartedSpace x) = f", "start": [1118, 1], "end": [1120, 6], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.singleton_hasGroupoid", "code": "theorem singleton_hasGroupoid {f : \u03b1 \u2192 H} (h : OpenEmbedding f) (G : StructureGroupoid H)\n    [ClosedUnderRestriction G] : @HasGroupoid _ _ _ _ h.singletonChartedSpace G", "start": [1123, 1], "end": [1125, 81], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.instChartedSpace", "code": "protected instance instChartedSpace : ChartedSpace H s where\n  atlas := \u22c3 x : s, {@LocalHomeomorph.subtypeRestr _ _ _ _ (chartAt H x.1) s \u27e8x\u27e9}\n  chartAt x := @LocalHomeomorph.subtypeRestr _ _ _ _ (chartAt H x.1) s \u27e8x\u27e9\n  mem_chart_source x := \u27e8trivial, mem_chart_source H x.1\u27e9\n  chart_mem_atlas x := by\n    simp only [mem_iUnion, mem_singleton_iff]\n    use x", "start": [1140, 1], "end": [1147, 10], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.instHasGroupoid", "code": "protected instance instHasGroupoid [ClosedUnderRestriction G] : HasGroupoid s G where\n  compatible := by\n    rintro e e' \u27e8_, \u27e8x, hc\u27e9, he\u27e9 \u27e8_, \u27e8x', hc'\u27e9, he'\u27e9\n    haveI : Nonempty s := \u27e8x\u27e9\n    have asdf := he\n    rw [hc.symm, mem_singleton_iff] at he\n    rw [hc'.symm, mem_singleton_iff] at he'\n    rw [he, he']\n    refine' G.eq_on_source _ (subtypeRestr_symm_trans_subtypeRestr s (chartAt H x) (chartAt H x'))\n    apply closedUnderRestriction'\n    \u00b7 exact G.compatible (chart_mem_atlas _ _) (chart_mem_atlas _ _)\n    \u00b7 exact preimage_open_of_open_symm (chartAt _ _) s.2", "start": [1150, 1], "end": [1163, 57], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.chartAt_inclusion_symm_eventuallyEq", "code": "theorem chartAt_inclusion_symm_eventuallyEq {U V : Opens M} (hUV : U \u2264 V) {x : U} :\n    (chartAt H (Set.inclusion hUV x)).symm\n    =\u1da0[\ud835\udcdd (chartAt H (Set.inclusion hUV x) (Set.inclusion hUV x))]\n    Set.inclusion hUV \u2218 (chartAt H x).symm", "start": [1166, 1], "end": [1177, 82], "kind": "commanddeclaration"}, {"full_name": "Structomorph", "code": "structure Structomorph (G : StructureGroupoid H) (M : Type*) (M' : Type*) [TopologicalSpace M]\n  [TopologicalSpace M'] [ChartedSpace H M] [ChartedSpace H M'] extends Homeomorph M M' where\n  mem_groupoid : \u2200 c : LocalHomeomorph M H, \u2200 c' : LocalHomeomorph M' H, c \u2208 atlas H M \u2192\n    c' \u2208 atlas H M' \u2192 c.symm \u226b\u2095 toHomeomorph.toLocalHomeomorph \u226b\u2095 c' \u2208 G", "start": [1184, 1], "end": [1191, 73], "kind": "commanddeclaration"}, {"full_name": "Structomorph.refl", "code": "def Structomorph.refl (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [HasGroupoid M G] :\n    Structomorph G M M :=\n  { Homeomorph.refl M with\n    mem_groupoid := fun c c' hc hc' \u21a6 by\n      change LocalHomeomorph.symm c \u226b\u2095 LocalHomeomorph.refl M \u226b\u2095 c' \u2208 G\n      rw [LocalHomeomorph.refl_trans]\n      exact G.compatible hc hc' }", "start": [1197, 1], "end": [1204, 34], "kind": "commanddeclaration"}, {"full_name": "Structomorph.symm", "code": "def Structomorph.symm (e : Structomorph G M M') : Structomorph G M' M :=\n  { e.toHomeomorph.symm with\n    mem_groupoid := by\n      intro c c' hc hc'\n      have : (c'.symm \u226b\u2095 e.toHomeomorph.toLocalHomeomorph \u226b\u2095 c).symm \u2208 G :=\n        G.symm (e.mem_groupoid c' c hc' hc)\n      rwa [trans_symm_eq_symm_trans_symm, trans_symm_eq_symm_trans_symm, symm_symm, trans_assoc]\n        at this }", "start": [1207, 1], "end": [1215, 18], "kind": "commanddeclaration"}, {"full_name": "Structomorph.trans", "code": "def Structomorph.trans (e : Structomorph G M M') (e' : Structomorph G M' M'') :\n    Structomorph G M M'' :=\n  { Homeomorph.trans e.toHomeomorph e'.toHomeomorph with\n    mem_groupoid := by\n      \n      intro c c' hc hc'\n      refine' G.locality fun x hx \u21a6 _\n      let f\u2081 := e.toHomeomorph.toLocalHomeomorph\n      let f\u2082 := e'.toHomeomorph.toLocalHomeomorph\n      let f := (e.toHomeomorph.trans e'.toHomeomorph).toLocalHomeomorph\n      have feq : f = f\u2081 \u226b\u2095 f\u2082 := Homeomorph.trans_toLocalHomeomorph _ _\n      let y := (c.symm \u226b\u2095 f\u2081) x\n      let g := chartAt (H := H) y\n      have hg\u2081 := chart_mem_atlas (H := H) y\n      have hg\u2082 := mem_chart_source (H := H) y\n      let s := (c.symm \u226b\u2095 f\u2081).source \u2229 c.symm \u226b\u2095 f\u2081 \u207b\u00b9' g.source\n      have open_s : IsOpen s := by\n        apply (c.symm \u226b\u2095 f\u2081).continuous_toFun.preimage_open_of_open <;> apply open_source\n      have : x \u2208 s := by\n        constructor\n        \u00b7 simp only [trans_source, preimage_univ, inter_univ, Homeomorph.toLocalHomeomorph_source]\n          rw [trans_source] at hx\n          exact hx.1\n        \u00b7 exact hg\u2082\n      refine' \u27e8s, open_s, this, _\u27e9\n      let F\u2081 := (c.symm \u226b\u2095 f\u2081 \u226b\u2095 g) \u226b\u2095 g.symm \u226b\u2095 f\u2082 \u226b\u2095 c'\n      have A : F\u2081 \u2208 G := G.trans (e.mem_groupoid c g hc hg\u2081) (e'.mem_groupoid g c' hg\u2081 hc')\n      let F\u2082 := (c.symm \u226b\u2095 f \u226b\u2095 c').restr s\n      have : F\u2081 \u2248 F\u2082 := calc\n        F\u2081 \u2248 c.symm \u226b\u2095 f\u2081 \u226b\u2095 (g \u226b\u2095 g.symm) \u226b\u2095 f\u2082 \u226b\u2095 c' := by simp only [trans_assoc, _root_.refl]\n        _ \u2248 c.symm \u226b\u2095 f\u2081 \u226b\u2095 ofSet g.source g.open_source \u226b\u2095 f\u2082 \u226b\u2095 c' :=\n          EqOnSource.trans' (_root_.refl _) (EqOnSource.trans' (_root_.refl _)\n            (EqOnSource.trans' (trans_self_symm g) (_root_.refl _)))\n        _ \u2248 ((c.symm \u226b\u2095 f\u2081) \u226b\u2095 ofSet g.source g.open_source) \u226b\u2095 f\u2082 \u226b\u2095 c' :=\n          by simp only [trans_assoc, _root_.refl]\n        _ \u2248 (c.symm \u226b\u2095 f\u2081).restr s \u226b\u2095 f\u2082 \u226b\u2095 c' := by rw [trans_of_set']\n        _ \u2248 ((c.symm \u226b\u2095 f\u2081) \u226b\u2095 f\u2082 \u226b\u2095 c').restr s := by rw [restr_trans]\n        _ \u2248 (c.symm \u226b\u2095 (f\u2081 \u226b\u2095 f\u2082) \u226b\u2095 c').restr s :=\n          by simp only [EqOnSource.restr, trans_assoc, _root_.refl]\n        _ \u2248 F\u2082 := by simp only [feq, _root_.refl]\n      have : F\u2082 \u2208 G := G.eq_on_source A (Setoid.symm this)\n      exact this }", "start": [1218, 1], "end": [1264, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Seq/Computation.lean", "imports": ["Mathlib/Tactic/Common.lean", "Mathlib/Data/Stream/Init.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Computation", "code": "def Computation (\u03b1 : Type u) : Type u :=\n  { f : Stream' (Option \u03b1) // \u2200 \u2983n a\u2984, f n = some a \u2192 f (n + 1) = some a }", "start": [32, 1], "end": [36, 75], "kind": "commanddeclaration"}, {"full_name": "Computation.pure", "code": "def pure (a : \u03b1) : Computation \u03b1 :=\n  \u27e8Stream'.const (some a), fun _ _ => id\u27e9", "start": [44, 1], "end": [47, 42], "kind": "commanddeclaration"}, {"full_name": "Computation.think", "code": "def think (c : Computation \u03b1) : Computation \u03b1 :=\n  \u27e8Stream'.cons none c.1, fun n a h => by\n    cases' n with n\n    \u00b7 contradiction\n    \u00b7 exact c.2 h\u27e9", "start": [55, 1], "end": [61, 19], "kind": "commanddeclaration"}, {"full_name": "Computation.thinkN", "code": "def thinkN (c : Computation \u03b1) : \u2115 \u2192 Computation \u03b1\n  | 0 => c\n  | n + 1 => think (thinkN c n)", "start": [64, 1], "end": [68, 32], "kind": "commanddeclaration"}, {"full_name": "Computation.head", "code": "def head (c : Computation \u03b1) : Option \u03b1 :=\n  c.1.head", "start": [73, 1], "end": [76, 11], "kind": "commanddeclaration"}, {"full_name": "Computation.tail", "code": "def tail (c : Computation \u03b1) : Computation \u03b1 :=\n  \u27e8c.1.tail, fun _ _ h => c.2 h\u27e9", "start": [80, 1], "end": [83, 33], "kind": "commanddeclaration"}, {"full_name": "Computation.empty", "code": "def empty (\u03b1) : Computation \u03b1 :=\n  \u27e8Stream'.const none, fun _ _ => id\u27e9", "start": [86, 1], "end": [89, 38], "kind": "commanddeclaration"}, {"full_name": "Computation.runFor", "code": "def runFor : Computation \u03b1 \u2192 \u2115 \u2192 Option \u03b1 :=\n  Subtype.val", "start": [95, 1], "end": [98, 14], "kind": "commanddeclaration"}, {"full_name": "Computation.destruct", "code": "def destruct (c : Computation \u03b1) : Sum \u03b1 (Computation \u03b1) :=\n  match c.1 0 with\n  | none => Sum.inr (tail c)\n  | some a => Sum.inl a", "start": [101, 1], "end": [106, 24], "kind": "commanddeclaration"}, {"full_name": "Computation.run", "code": "unsafe def run : Computation \u03b1 \u2192 \u03b1\n  | c =>\n    match destruct c with\n    | Sum.inl a => a\n    | Sum.inr ca => run ca", "start": [109, 1], "end": [115, 27], "kind": "commanddeclaration"}, {"full_name": "Computation.destruct_eq_pure", "code": "theorem destruct_eq_pure {s : Computation \u03b1} {a : \u03b1} : destruct s = Sum.inl a \u2192 s = pure a", "start": [118, 1], "end": [127, 19], "kind": "commanddeclaration"}, {"full_name": "Computation.destruct_eq_think", "code": "theorem destruct_eq_think {s : Computation \u03b1} {s'} : destruct s = Sum.inr s' \u2192 s = think s'", "start": [130, 1], "end": [140, 18], "kind": "commanddeclaration"}, {"full_name": "Computation.destruct_pure", "code": "@[simp]\ntheorem destruct_pure (a : \u03b1) : destruct (pure a) = Sum.inl a", "start": [143, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "Computation.destruct_think", "code": "@[simp]\ntheorem destruct_think : \u2200 s : Computation \u03b1, destruct (think s) = Sum.inr s", "start": [148, 1], "end": [150, 18], "kind": "commanddeclaration"}, {"full_name": "Computation.destruct_empty", "code": "@[simp]\ntheorem destruct_empty : destruct (empty \u03b1) = Sum.inr (empty \u03b1)", "start": [153, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "Computation.head_pure", "code": "@[simp]\ntheorem head_pure (a : \u03b1) : head (pure a) = some a", "start": [158, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "Computation.head_think", "code": "@[simp]\ntheorem head_think (s : Computation \u03b1) : head (think s) = none", "start": [163, 1], "end": [165, 6], "kind": "commanddeclaration"}, {"full_name": "Computation.head_empty", "code": "@[simp]\ntheorem head_empty : head (empty \u03b1) = none", "start": [168, 1], "end": [170, 6], "kind": "commanddeclaration"}, {"full_name": "Computation.tail_pure", "code": "@[simp]\ntheorem tail_pure (a : \u03b1) : tail (pure a) = pure a", "start": [173, 1], "end": [175, 6], "kind": "commanddeclaration"}, {"full_name": "Computation.tail_think", "code": "@[simp]\ntheorem tail_think (s : Computation \u03b1) : tail (think s) = s", "start": [178, 1], "end": [180, 60], "kind": "commanddeclaration"}, {"full_name": "Computation.tail_empty", "code": "@[simp]\ntheorem tail_empty : tail (empty \u03b1) = empty \u03b1", "start": [183, 1], "end": [185, 6], "kind": "commanddeclaration"}, {"full_name": "Computation.think_empty", "code": "theorem think_empty : empty \u03b1 = think (empty \u03b1)", "start": [188, 1], "end": [189, 35], "kind": "commanddeclaration"}, {"full_name": "Computation.recOn", "code": "def recOn {C : Computation \u03b1 \u2192 Sort v} (s : Computation \u03b1) (h1 : \u2200 a, C (pure a))\n    (h2 : \u2200 s, C (think s)) : C s :=\n  match H : destruct s with\n  | Sum.inl v => by\n    rw [destruct_eq_pure H]\n    apply h1\n  | Sum.inr v => match v with\n    | \u27e8a, s'\u27e9 => by\n      rw [destruct_eq_think H]\n      apply h2", "start": [192, 1], "end": [202, 15], "kind": "commanddeclaration"}, {"full_name": "Computation.Corec.f", "code": "def Corec.f (f : \u03b2 \u2192 Sum \u03b1 \u03b2) : Sum \u03b1 \u03b2 \u2192 Option \u03b1 \u00d7 Sum \u03b1 \u03b2\n  | Sum.inl a => (some a, Sum.inl a)\n  | Sum.inr b =>\n    (match f b with\n      | Sum.inl a => some a\n      | Sum.inr _ => none,\n      f b)", "start": [205, 1], "end": [212, 11], "kind": "commanddeclaration"}, {"full_name": "Computation.corec", "code": "def corec (f : \u03b2 \u2192 Sum \u03b1 \u03b2) (b : \u03b2) : Computation \u03b1 := by\n  refine' \u27e8Stream'.corec' (Corec.f f) (Sum.inr b), fun n a' h => _\u27e9\n  rw [Stream'.corec'_eq]\n  change Stream'.corec' (Corec.f f) (Corec.f f (Sum.inr b)).2 n = some a'\n  revert h; generalize Sum.inr b = o; revert o\n  induction' n with n IH <;> intro o\n  \u00b7 change (Corec.f f o).1 = some a' \u2192 (Corec.f f (Corec.f f o).2).1 = some a'\n    cases' o with _ b <;> intro h\n    \u00b7 exact h\n    unfold Corec.f at *; split <;> simp_all\n  \u00b7 rw [Stream'.corec'_eq (Corec.f f) (Corec.f f o).2, Stream'.corec'_eq (Corec.f f) o]\n    exact IH (Corec.f f o).2", "start": [216, 1], "end": [230, 29], "kind": "commanddeclaration"}, {"full_name": "Computation.lmap", "code": "def lmap (f : \u03b1 \u2192 \u03b2) : Sum \u03b1 \u03b3 \u2192 Sum \u03b2 \u03b3\n  | Sum.inl a => Sum.inl (f a)\n  | Sum.inr b => Sum.inr b", "start": [233, 1], "end": [236, 27], "kind": "commanddeclaration"}, {"full_name": "Computation.rmap", "code": "def rmap (f : \u03b2 \u2192 \u03b3) : Sum \u03b1 \u03b2 \u2192 Sum \u03b1 \u03b3\n  | Sum.inl a => Sum.inl a\n  | Sum.inr b => Sum.inr (f b)", "start": [239, 1], "end": [242, 31], "kind": "commanddeclaration"}, {"full_name": "Computation.corec_eq", "code": "@[simp]\ntheorem corec_eq (f : \u03b2 \u2192 Sum \u03b1 \u03b2) (b : \u03b2) : destruct (corec f b) = rmap (corec f) (f b)", "start": [252, 1], "end": [267, 26], "kind": "commanddeclaration"}, {"full_name": "Computation.BisimO", "code": "def BisimO : Sum \u03b1 (Computation \u03b1) \u2192 Sum \u03b1 (Computation \u03b1) \u2192 Prop\n  | Sum.inl a, Sum.inl a' => a = a'\n  | Sum.inr s, Sum.inr s' => R s s'\n  | _, _ => False", "start": [278, 1], "end": [282, 18], "kind": "commanddeclaration"}, {"full_name": "Computation.IsBisimulation", "code": "def IsBisimulation :=\n  \u2200 \u2983s\u2081 s\u2082\u2984, s\u2081 ~ s\u2082 \u2192 BisimO R (destruct s\u2081) (destruct s\u2082)", "start": [287, 1], "end": [289, 60], "kind": "commanddeclaration"}, {"full_name": "Computation.eq_of_bisim", "code": "theorem eq_of_bisim (bisim : IsBisimulation R) {s\u2081 s\u2082} (r : s\u2081 ~ s\u2082) : s\u2081 = s\u2082", "start": [293, 1], "end": [315, 32], "kind": "commanddeclaration"}, {"full_name": "Computation.Mem", "code": "protected def Mem (a : \u03b1) (s : Computation \u03b1) :=\n  some a \u2208 s.1", "start": [322, 1], "end": [324, 15], "kind": "commanddeclaration"}, {"full_name": "Computation.le_stable", "code": "theorem le_stable (s : Computation \u03b1) {a m n} (h : m \u2264 n) : s.1 m = some a \u2192 s.1 n = some a", "start": [330, 1], "end": [333, 36], "kind": "commanddeclaration"}, {"full_name": "Computation.mem_unique", "code": "theorem mem_unique {s : Computation \u03b1} {a b : \u03b1} : a \u2208 s \u2192 b \u2208 s \u2192 a = b", "start": [336, 1], "end": [339, 98], "kind": "commanddeclaration"}, {"full_name": "Computation.Mem.left_unique", "code": "theorem Mem.left_unique : Relator.LeftUnique ((\u00b7 \u2208 \u00b7) : \u03b1 \u2192 Computation \u03b1 \u2192 Prop)", "start": [342, 1], "end": [343, 13], "kind": "commanddeclaration"}, {"full_name": "Computation.Terminates", "code": "class Terminates (s : Computation \u03b1) : Prop where\n  \n  term : \u2203 a, a \u2208 s", "start": [346, 1], "end": [349, 20], "kind": "commanddeclaration"}, {"full_name": "Computation.terminates_iff", "code": "theorem terminates_iff (s : Computation \u03b1) : Terminates s \u2194 \u2203 a, a \u2208 s", "start": [352, 1], "end": [353, 32], "kind": "commanddeclaration"}, {"full_name": "Computation.terminates_of_mem", "code": "theorem terminates_of_mem {s : Computation \u03b1} {a : \u03b1} (h : a \u2208 s) : Terminates s", "start": [356, 1], "end": [357, 11], "kind": "commanddeclaration"}, {"full_name": "Computation.terminates_def", "code": "theorem terminates_def (s : Computation \u03b1) : Terminates s \u2194 \u2203 n, (s.1 n).isSome", "start": [360, 1], "end": [366, 76], "kind": "commanddeclaration"}, {"full_name": "Computation.ret_mem", "code": "theorem ret_mem (a : \u03b1) : a \u2208 pure a", "start": [369, 1], "end": [370, 21], "kind": "commanddeclaration"}, {"full_name": "Computation.eq_of_pure_mem", "code": "theorem eq_of_pure_mem {a a' : \u03b1} (h : a' \u2208 pure a) : a' = a", "start": [373, 1], "end": [374, 27], "kind": "commanddeclaration"}, {"full_name": "Computation.ret_terminates", "code": "instance ret_terminates (a : \u03b1) : Terminates (pure a) :=\n  terminates_of_mem (ret_mem _)", "start": [377, 1], "end": [378, 32], "kind": "commanddeclaration"}, {"full_name": "Computation.think_mem", "code": "theorem think_mem {s : Computation \u03b1} {a} : a \u2208 s \u2192 a \u2208 think s", "start": [381, 1], "end": [382, 25], "kind": "commanddeclaration"}, {"full_name": "Computation.think_terminates", "code": "instance think_terminates (s : Computation \u03b1) : \u2200 [Terminates s], Terminates (think s)\n  | \u27e8\u27e8a, n, h\u27e9\u27e9 => \u27e8\u27e8a, n + 1, h\u27e9\u27e9", "start": [385, 1], "end": [386, 35], "kind": "commanddeclaration"}, {"full_name": "Computation.of_think_mem", "code": "theorem of_think_mem {s : Computation \u03b1} {a} : a \u2208 think s \u2192 a \u2208 s", "start": [389, 1], "end": [393, 20], "kind": "commanddeclaration"}, {"full_name": "Computation.of_think_terminates", "code": "theorem of_think_terminates {s : Computation \u03b1} : Terminates (think s) \u2192 Terminates s", "start": [396, 1], "end": [397, 38], "kind": "commanddeclaration"}, {"full_name": "Computation.not_mem_empty", "code": "theorem not_mem_empty (a : \u03b1) : a \u2209 empty \u03b1", "start": [400, 1], "end": [400, 78], "kind": "commanddeclaration"}, {"full_name": "Computation.not_terminates_empty", "code": "theorem not_terminates_empty : \u00acTerminates (empty \u03b1)", "start": [403, 1], "end": [403, 90], "kind": "commanddeclaration"}, {"full_name": "Computation.eq_empty_of_not_terminates", "code": "theorem eq_empty_of_not_terminates {s} (H : \u00acTerminates s) : s = empty \u03b1", "start": [406, 1], "end": [409, 45], "kind": "commanddeclaration"}, {"full_name": "Computation.thinkN_mem", "code": "theorem thinkN_mem {s : Computation \u03b1} {a} : \u2200 n, a \u2208 thinkN s n \u2194 a \u2208 s", "start": [412, 1], "end": [414, 64], "kind": "commanddeclaration"}, {"full_name": "Computation.thinkN_terminates", "code": "instance thinkN_terminates (s : Computation \u03b1) : \u2200 [Terminates s] (n), Terminates (thinkN s n)\n  | \u27e8\u27e8a, h\u27e9\u27e9, n => \u27e8\u27e8a, (thinkN_mem n).2 h\u27e9\u27e9", "start": [418, 1], "end": [419, 45], "kind": "commanddeclaration"}, {"full_name": "Computation.of_thinkN_terminates", "code": "theorem of_thinkN_terminates (s : Computation \u03b1) (n) : Terminates (thinkN s n) \u2192 Terminates s", "start": [423, 1], "end": [424, 42], "kind": "commanddeclaration"}, {"full_name": "Computation.Promises", "code": "def Promises (s : Computation \u03b1) (a : \u03b1) : Prop :=\n  \u2200 \u2983a'\u2984, a' \u2208 s \u2192 a = a'", "start": [428, 1], "end": [431, 26], "kind": "commanddeclaration"}, {"full_name": "Computation.mem_promises", "code": "theorem mem_promises {s : Computation \u03b1} {a : \u03b1} : a \u2208 s \u2192 s ~> a", "start": [439, 1], "end": [439, 93], "kind": "commanddeclaration"}, {"full_name": "Computation.empty_promises", "code": "theorem empty_promises (a : \u03b1) : empty \u03b1 ~> a", "start": [442, 1], "end": [442, 87], "kind": "commanddeclaration"}, {"full_name": "Computation.length", "code": "def length : \u2115 :=\n  Nat.find ((terminates_def _).1 h)", "start": [449, 1], "end": [451, 36], "kind": "commanddeclaration"}, {"full_name": "Computation.get", "code": "def get : \u03b1 :=\n  Option.get _ (Nat.find_spec <| (terminates_def _).1 h)", "start": [454, 1], "end": [456, 57], "kind": "commanddeclaration"}, {"full_name": "Computation.get_mem", "code": "theorem get_mem : get s \u2208 s", "start": [459, 1], "end": [460, 60], "kind": "commanddeclaration"}, {"full_name": "Computation.get_eq_of_mem", "code": "theorem get_eq_of_mem {a} : a \u2208 s \u2192 get s = a", "start": [463, 1], "end": [464, 25], "kind": "commanddeclaration"}, {"full_name": "Computation.mem_of_get_eq", "code": "theorem mem_of_get_eq {a} : get s = a \u2192 a \u2208 s", "start": [467, 1], "end": [467, 85], "kind": "commanddeclaration"}, {"full_name": "Computation.get_think", "code": "@[simp]\ntheorem get_think : get (think s) = get s", "start": [470, 1], "end": [474, 15], "kind": "commanddeclaration"}, {"full_name": "Computation.get_thinkN", "code": "@[simp]\ntheorem get_thinkN (n) : get (thinkN s n) = get s", "start": [477, 1], "end": [479, 50], "kind": "commanddeclaration"}, {"full_name": "Computation.get_promises", "code": "theorem get_promises : s ~> get s", "start": [483, 1], "end": [483, 62], "kind": "commanddeclaration"}, {"full_name": "Computation.mem_of_promises", "code": "theorem mem_of_promises {a} (p : s ~> a) : a \u2208 s", "start": [486, 1], "end": [490, 10], "kind": "commanddeclaration"}, {"full_name": "Computation.get_eq_of_promises", "code": "theorem get_eq_of_promises {a} : s ~> a \u2192 get s = a", "start": [493, 1], "end": [494, 38], "kind": "commanddeclaration"}, {"full_name": "Computation.Results", "code": "def Results (s : Computation \u03b1) (a : \u03b1) (n : \u2115) :=\n  \u2203 h : a \u2208 s, @length _ s (terminates_of_mem h) = n", "start": [499, 1], "end": [502, 53], "kind": "commanddeclaration"}, {"full_name": "Computation.results_of_terminates", "code": "theorem results_of_terminates (s : Computation \u03b1) [_T : Terminates s] :\n    Results s (get s) (length s)", "start": [505, 1], "end": [507, 19], "kind": "commanddeclaration"}, {"full_name": "Computation.results_of_terminates'", "code": "theorem results_of_terminates' (s : Computation \u03b1) [T : Terminates s] {a} (h : a \u2208 s) :\n    Results s a (length s)", "start": [510, 1], "end": [511, 87], "kind": "commanddeclaration"}, {"full_name": "Computation.Results.mem", "code": "theorem Results.mem {s : Computation \u03b1} {a n} : Results s a n \u2192 a \u2208 s", "start": [514, 1], "end": [515, 16], "kind": "commanddeclaration"}, {"full_name": "Computation.Results.terminates", "code": "theorem Results.terminates {s : Computation \u03b1} {a n} (h : Results s a n) : Terminates s", "start": [518, 1], "end": [519, 26], "kind": "commanddeclaration"}, {"full_name": "Computation.Results.length", "code": "theorem Results.length {s : Computation \u03b1} {a n} [_T : Terminates s] : Results s a n \u2192 length s = n", "start": [522, 1], "end": [523, 16], "kind": "commanddeclaration"}, {"full_name": "Computation.Results.val_unique", "code": "theorem Results.val_unique {s : Computation \u03b1} {a b m n} (h1 : Results s a m) (h2 : Results s b n) :\n    a = b", "start": [526, 1], "end": [528, 27], "kind": "commanddeclaration"}, {"full_name": "Computation.Results.len_unique", "code": "theorem Results.len_unique {s : Computation \u03b1} {a b m n} (h1 : Results s a m) (h2 : Results s b n) :\n    m = n", "start": [531, 1], "end": [532, 92], "kind": "commanddeclaration"}, {"full_name": "Computation.exists_results_of_mem", "code": "theorem exists_results_of_mem {s : Computation \u03b1} {a} (h : a \u2208 s) : \u2203 n, Results s a n", "start": [535, 1], "end": [537, 34], "kind": "commanddeclaration"}, {"full_name": "Computation.get_pure", "code": "@[simp]\ntheorem get_pure (a : \u03b1) : get (pure a) = a", "start": [540, 1], "end": [542, 27], "kind": "commanddeclaration"}, {"full_name": "Computation.length_pure", "code": "@[simp]\ntheorem length_pure (a : \u03b1) : length (pure a) = 0", "start": [545, 1], "end": [548, 78], "kind": "commanddeclaration"}, {"full_name": "Computation.results_pure", "code": "theorem results_pure (a : \u03b1) : Results (pure a) a 0", "start": [551, 1], "end": [552, 29], "kind": "commanddeclaration"}, {"full_name": "Computation.length_think", "code": "@[simp]\ntheorem length_think (s : Computation \u03b1) [h : Terminates s] : length (think s) = length s + 1", "start": [555, 1], "end": [565, 17], "kind": "commanddeclaration"}, {"full_name": "Computation.results_think", "code": "theorem results_think {s : Computation \u03b1} {a n} (h : Results s a n) : Results (think s) a (n + 1)", "start": [568, 1], "end": [570, 52], "kind": "commanddeclaration"}, {"full_name": "Computation.of_results_think", "code": "theorem of_results_think {s : Computation \u03b1} {a n} (h : Results (think s) a n) :\n    \u2203 m, Results s a m \u2227 n = m + 1", "start": [573, 1], "end": [577, 61], "kind": "commanddeclaration"}, {"full_name": "Computation.results_think_iff", "code": "@[simp]\ntheorem results_think_iff {s : Computation \u03b1} {a n} : Results (think s) a (n + 1) \u2194 Results s a n", "start": [580, 1], "end": [584, 79], "kind": "commanddeclaration"}, {"full_name": "Computation.results_thinkN", "code": "theorem results_thinkN {s : Computation \u03b1} {a m} :\n    \u2200 n, Results s a m \u2192 Results (thinkN s n) a (m + n)", "start": [587, 1], "end": [590, 51], "kind": "commanddeclaration"}, {"full_name": "Computation.results_thinkN_pure", "code": "theorem results_thinkN_pure (a : \u03b1) (n) : Results (thinkN (pure a) n) a n", "start": [594, 1], "end": [595, 72], "kind": "commanddeclaration"}, {"full_name": "Computation.length_thinkN", "code": "@[simp]\ntheorem length_thinkN (s : Computation \u03b1) [_h : Terminates s] (n) :\n    length (thinkN s n) = length s + n", "start": [599, 1], "end": [602, 54], "kind": "commanddeclaration"}, {"full_name": "Computation.eq_thinkN", "code": "theorem eq_thinkN {s : Computation \u03b1} {a n} (h : Results s a n) : s = thinkN (pure a) n", "start": [606, 1], "end": [617, 8], "kind": "commanddeclaration"}, {"full_name": "Computation.eq_thinkN'", "code": "theorem eq_thinkN' (s : Computation \u03b1) [_h : Terminates s] :\n    s = thinkN (pure (get s)) (length s)", "start": [621, 1], "end": [623, 38], "kind": "commanddeclaration"}, {"full_name": "Computation.memRecOn", "code": "def memRecOn {C : Computation \u03b1 \u2192 Sort v} {a s} (M : a \u2208 s) (h1 : C (pure a))\n    (h2 : \u2200 s, C s \u2192 C (think s)) : C s := by\n  haveI T := terminates_of_mem M\n  rw [eq_thinkN' s, get_eq_of_mem s M]\n  generalize length s = n\n  induction' n with n IH; exacts [h1, h2 _ IH]", "start": [627, 1], "end": [633, 47], "kind": "commanddeclaration"}, {"full_name": "Computation.terminatesRecOn", "code": "def terminatesRecOn\n    {C : Computation \u03b1 \u2192 Sort v}\n    (s) [Terminates s]\n    (h1 : \u2200 a, C (pure a))\n    (h2 : \u2200 s, C s \u2192 C (think s)) : C s :=\n  memRecOn (get_mem s) (h1 _) h2", "start": [636, 1], "end": [642, 33], "kind": "commanddeclaration"}, {"full_name": "Computation.map", "code": "def map (f : \u03b1 \u2192 \u03b2) : Computation \u03b1 \u2192 Computation \u03b2\n  | \u27e8s, al\u27e9 =>\n    \u27e8s.map fun o => Option.casesOn o none (some \u2218 f), fun n b => by\n      dsimp [Stream'.map, Stream'.get]\n      induction' e : s n with a <;> intro h\n      \u00b7 contradiction\n      \u00b7 rw [al e]; exact h\u27e9", "start": [645, 1], "end": [652, 28], "kind": "commanddeclaration"}, {"full_name": "Computation.Bind.g", "code": "def Bind.g : Sum \u03b2 (Computation \u03b2) \u2192 Sum \u03b2 (Sum (Computation \u03b1) (Computation \u03b2))\n  | Sum.inl b => Sum.inl b\n  | Sum.inr cb' => Sum.inr <| Sum.inr cb'", "start": [655, 1], "end": [658, 42], "kind": "commanddeclaration"}, {"full_name": "Computation.Bind.f", "code": "def Bind.f (f : \u03b1 \u2192 Computation \u03b2) :\n    Sum (Computation \u03b1) (Computation \u03b2) \u2192 Sum \u03b2 (Sum (Computation \u03b1) (Computation \u03b2))\n  | Sum.inl ca =>\n    match destruct ca with\n    | Sum.inl a => Bind.g <| destruct (f a)\n    | Sum.inr ca' => Sum.inr <| Sum.inl ca'\n  | Sum.inr cb => Bind.g <| destruct cb", "start": [662, 1], "end": [669, 40], "kind": "commanddeclaration"}, {"full_name": "Computation.bind", "code": "def bind (c : Computation \u03b1) (f : \u03b1 \u2192 Computation \u03b2) : Computation \u03b2 :=\n  corec (Bind.f f) (Sum.inl c)", "start": [673, 1], "end": [675, 31], "kind": "commanddeclaration"}, {"full_name": "Computation.has_bind_eq_bind", "code": "theorem has_bind_eq_bind {\u03b2} (c : Computation \u03b1) (f : \u03b1 \u2192 Computation \u03b2) : c >>= f = bind c f", "start": [681, 1], "end": [682, 6], "kind": "commanddeclaration"}, {"full_name": "Computation.join", "code": "def join (c : Computation (Computation \u03b1)) : Computation \u03b1 :=\n  c >>= id", "start": [685, 1], "end": [687, 11], "kind": "commanddeclaration"}, {"full_name": "Computation.map_pure", "code": "@[simp]\ntheorem map_pure (f : \u03b1 \u2192 \u03b2) (a) : map f (pure a) = pure (f a)", "start": [690, 1], "end": [692, 6], "kind": "commanddeclaration"}, {"full_name": "Computation.map_think", "code": "@[simp]\ntheorem map_think (f : \u03b1 \u2192 \u03b2) : \u2200 s, map f (think s) = think (map f s)", "start": [695, 1], "end": [697, 78], "kind": "commanddeclaration"}, {"full_name": "Computation.destruct_map", "code": "@[simp]\ntheorem destruct_map (f : \u03b1 \u2192 \u03b2) (s) : destruct (map f s) = lmap f (rmap (map f) (destruct s))", "start": [700, 1], "end": [702, 35], "kind": "commanddeclaration"}, {"full_name": "Computation.map_id", "code": "@[simp]\ntheorem map_id : \u2200 s : Computation \u03b1, map id s = s", "start": [705, 1], "end": [711, 32], "kind": "commanddeclaration"}, {"full_name": "Computation.map_comp", "code": "theorem map_comp (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) : \u2200 s : Computation \u03b1, map (g \u2218 f) s = map g (map f s)", "start": [714, 1], "end": [718, 19], "kind": "commanddeclaration"}, {"full_name": "Computation.ret_bind", "code": "@[simp]\ntheorem ret_bind (a) (f : \u03b1 \u2192 Computation \u03b2) : bind (pure a) f = f a", "start": [721, 1], "end": [733, 9], "kind": "commanddeclaration"}, {"full_name": "Computation.think_bind", "code": "@[simp]\ntheorem think_bind (c) (f : \u03b1 \u2192 Computation \u03b2) : bind (think c) f = think (bind c f)", "start": [736, 1], "end": [738, 46], "kind": "commanddeclaration"}, {"full_name": "Computation.bind_pure", "code": "@[simp]\ntheorem bind_pure (f : \u03b1 \u2192 \u03b2) (s) : bind s (pure \u2218 f) = map f s", "start": [741, 1], "end": [750, 31], "kind": "commanddeclaration"}, {"full_name": "Computation.bind_pure'", "code": "@[simp]\ntheorem bind_pure' (s : Computation \u03b1) : bind s pure = s", "start": [754, 1], "end": [762, 31], "kind": "commanddeclaration"}, {"full_name": "Computation.bind_assoc", "code": "@[simp]\ntheorem bind_assoc (s : Computation \u03b1) (f : \u03b1 \u2192 Computation \u03b2) (g : \u03b2 \u2192 Computation \u03b3) :\n    bind (bind s f) g = bind s fun x : \u03b1 => bind (f x) g", "start": [765, 1], "end": [780, 31], "kind": "commanddeclaration"}, {"full_name": "Computation.results_bind", "code": "theorem results_bind {s : Computation \u03b1} {f : \u03b1 \u2192 Computation \u03b2} {a b m n} (h1 : Results s a m)\n    (h2 : Results (f a) b n) : Results (bind s f) b (n + m)", "start": [783, 1], "end": [796, 32], "kind": "commanddeclaration"}, {"full_name": "Computation.mem_bind", "code": "theorem mem_bind {s : Computation \u03b1} {f : \u03b1 \u2192 Computation \u03b2} {a b} (h1 : a \u2208 s) (h2 : b \u2208 f a) :\n    b \u2208 bind s f", "start": [799, 1], "end": [803, 27], "kind": "commanddeclaration"}, {"full_name": "Computation.terminates_bind", "code": "instance terminates_bind (s : Computation \u03b1) (f : \u03b1 \u2192 Computation \u03b2) [Terminates s]\n    [Terminates (f (get s))] : Terminates (bind s f) :=\n  terminates_of_mem (mem_bind (get_mem s) (get_mem (f (get s))))", "start": [806, 1], "end": [808, 65], "kind": "commanddeclaration"}, {"full_name": "Computation.get_bind", "code": "@[simp]\ntheorem get_bind (s : Computation \u03b1) (f : \u03b1 \u2192 Computation \u03b2) [Terminates s]\n    [Terminates (f (get s))] : get (bind s f) = get (f (get s))", "start": [811, 1], "end": [814, 63], "kind": "commanddeclaration"}, {"full_name": "Computation.length_bind", "code": "@[simp]\ntheorem length_bind (s : Computation \u03b1) (f : \u03b1 \u2192 Computation \u03b2) [_T1 : Terminates s]\n    [_T2 : Terminates (f (get s))] : length (bind s f) = length (f (get s)) + length s", "start": [817, 1], "end": [821, 69], "kind": "commanddeclaration"}, {"full_name": "Computation.of_results_bind", "code": "theorem of_results_bind {s : Computation \u03b1} {f : \u03b1 \u2192 Computation \u03b2} {b k} :\n    Results (bind s f) b k \u2192 \u2203 a m n, Results s a m \u2227 Results (f a) b n \u2227 k = n + m", "start": [824, 1], "end": [836, 53], "kind": "commanddeclaration"}, {"full_name": "Computation.exists_of_mem_bind", "code": "theorem exists_of_mem_bind {s : Computation \u03b1} {f : \u03b1 \u2192 Computation \u03b2} {b} (h : b \u2208 bind s f) :\n    \u2203 a \u2208 s, b \u2208 f a", "start": [839, 1], "end": [843, 22], "kind": "commanddeclaration"}, {"full_name": "Computation.bind_promises", "code": "theorem bind_promises {s : Computation \u03b1} {f : \u03b1 \u2192 Computation \u03b2} {a b} (h1 : s ~> a)\n    (h2 : f a ~> b) : bind s f ~> b", "start": [846, 1], "end": [849, 37], "kind": "commanddeclaration"}, {"full_name": "Computation.monad", "code": "instance monad : Monad Computation where\n  map := @map\n  pure := @pure\n  bind := @bind", "start": [852, 1], "end": [855, 16], "kind": "commanddeclaration"}, {"full_name": "Computation.has_map_eq_map", "code": "theorem has_map_eq_map {\u03b2} (f : \u03b1 \u2192 \u03b2) (c : Computation \u03b1) : f <$> c = map f c", "start": [863, 1], "end": [864, 6], "kind": "commanddeclaration"}, {"full_name": "Computation.pure_def", "code": "@[simp]\ntheorem pure_def (a) : (return a : Computation \u03b1) = pure a", "start": [867, 1], "end": [869, 6], "kind": "commanddeclaration"}, {"full_name": "Computation.map_pure'", "code": "@[simp]\ntheorem map_pure' {\u03b1 \u03b2} : \u2200 (f : \u03b1 \u2192 \u03b2) (a), f <$> pure a = pure (f a)", "start": [872, 1], "end": [874, 11], "kind": "commanddeclaration"}, {"full_name": "Computation.map_think'", "code": "@[simp]\ntheorem map_think' {\u03b1 \u03b2} : \u2200 (f : \u03b1 \u2192 \u03b2) (s), f <$> think s = think (f <$> s)", "start": [877, 1], "end": [879, 12], "kind": "commanddeclaration"}, {"full_name": "Computation.mem_map", "code": "theorem mem_map (f : \u03b1 \u2192 \u03b2) {a} {s : Computation \u03b1} (m : a \u2208 s) : f a \u2208 map f s", "start": [882, 1], "end": [883, 52], "kind": "commanddeclaration"}, {"full_name": "Computation.exists_of_mem_map", "code": "theorem exists_of_mem_map {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {s : Computation \u03b1} (h : b \u2208 map f s) :\n    \u2203 a, a \u2208 s \u2227 f a = b", "start": [886, 1], "end": [890, 43], "kind": "commanddeclaration"}, {"full_name": "Computation.terminates_map", "code": "instance terminates_map (f : \u03b1 \u2192 \u03b2) (s : Computation \u03b1) [Terminates s] : Terminates (map f s) := by\n  rw [\u2190 bind_pure]; exact terminates_of_mem (mem_bind (get_mem s) (get_mem (f (get s))))", "start": [893, 1], "end": [894, 89], "kind": "commanddeclaration"}, {"full_name": "Computation.terminates_map_iff", "code": "theorem terminates_map_iff (f : \u03b1 \u2192 \u03b2) (s : Computation \u03b1) : Terminates (map f s) \u2194 Terminates s", "start": [897, 1], "end": [901, 41], "kind": "commanddeclaration"}, {"full_name": "Computation.orElse", "code": "def orElse (c\u2081 : Computation \u03b1) (c\u2082 : Unit \u2192 Computation \u03b1) : Computation \u03b1 :=\n  @Computation.corec \u03b1 (Computation \u03b1 \u00d7 Computation \u03b1)\n    (fun \u27e8c\u2081, c\u2082\u27e9 =>\n      match destruct c\u2081 with\n      | Sum.inl a => Sum.inl a\n      | Sum.inr c\u2081' =>\n        match destruct c\u2082 with\n        | Sum.inl a => Sum.inl a\n        | Sum.inr c\u2082' => Sum.inr (c\u2081', c\u2082'))\n    (c\u2081, c\u2082 ())", "start": [905, 1], "end": [916, 16], "kind": "commanddeclaration"}, {"full_name": "Computation.instAlternativeComputation", "code": "instance instAlternativeComputation : Alternative Computation :=\n  { Computation.monad with\n    orElse := @orElse\n    failure := @empty }", "start": [919, 1], "end": [922, 24], "kind": "commanddeclaration"}, {"full_name": "Computation.ret_orElse", "code": "@[simp]\ntheorem ret_orElse (a : \u03b1) (c\u2082 : Computation \u03b1) : (pure a <|> c\u2082) = pure a", "start": [925, 1], "end": [930, 18], "kind": "commanddeclaration"}, {"full_name": "Computation.orElse_pure", "code": "@[simp]\ntheorem orElse_pure (c\u2081 : Computation \u03b1) (a : \u03b1) : (think c\u2081 <|> pure a) = pure a", "start": [934, 1], "end": [939, 18], "kind": "commanddeclaration"}, {"full_name": "Computation.orElse_think", "code": "@[simp]\ntheorem orElse_think (c\u2081 c\u2082 : Computation \u03b1) : (think c\u2081 <|> think c\u2082) = think (c\u2081 <|> c\u2082)", "start": [943, 1], "end": [948, 18], "kind": "commanddeclaration"}, {"full_name": "Computation.empty_orElse", "code": "@[simp]\ntheorem empty_orElse (c) : (empty \u03b1 <|> c) = c", "start": [951, 1], "end": [956, 21], "kind": "commanddeclaration"}, {"full_name": "Computation.orElse_empty", "code": "@[simp]\ntheorem orElse_empty (c : Computation \u03b1) : (c <|> empty \u03b1) = c", "start": [959, 1], "end": [964, 21], "kind": "commanddeclaration"}, {"full_name": "Computation.Equiv", "code": "def Equiv (c\u2081 c\u2082 : Computation \u03b1) : Prop :=\n  \u2200 a, a \u2208 c\u2081 \u2194 a \u2208 c\u2082", "start": [967, 1], "end": [970, 23], "kind": "commanddeclaration"}, {"full_name": "Computation.Equiv.refl", "code": "@[refl]\ntheorem Equiv.refl (s : Computation \u03b1) : s ~ s", "start": [977, 1], "end": [978, 67], "kind": "commanddeclaration"}, {"full_name": "Computation.Equiv.symm", "code": "@[symm]\ntheorem Equiv.symm {s t : Computation \u03b1} : s ~ t \u2192 t ~ s", "start": [981, 1], "end": [982, 82], "kind": "commanddeclaration"}, {"full_name": "Computation.Equiv.trans", "code": "@[trans]\ntheorem Equiv.trans {s t u : Computation \u03b1} : s ~ t \u2192 t ~ u \u2192 s ~ u", "start": [985, 1], "end": [987, 22], "kind": "commanddeclaration"}, {"full_name": "Computation.Equiv.equivalence", "code": "theorem Equiv.equivalence : Equivalence (@Equiv \u03b1)", "start": [990, 1], "end": [991, 49], "kind": "commanddeclaration"}, {"full_name": "Computation.equiv_of_mem", "code": "theorem equiv_of_mem {s t : Computation \u03b1} {a} (h1 : a \u2208 s) (h2 : a \u2208 t) : s ~ t", "start": [994, 1], "end": [995, 95], "kind": "commanddeclaration"}, {"full_name": "Computation.terminates_congr", "code": "theorem terminates_congr {c\u2081 c\u2082 : Computation \u03b1} (h : c\u2081 ~ c\u2082) : Terminates c\u2081 \u2194 Terminates c\u2082", "start": [998, 1], "end": [999, 45], "kind": "commanddeclaration"}, {"full_name": "Computation.promises_congr", "code": "theorem promises_congr {c\u2081 c\u2082 : Computation \u03b1} (h : c\u2081 ~ c\u2082) (a) : c\u2081 ~> a \u2194 c\u2082 ~> a", "start": [1002, 1], "end": [1003, 51], "kind": "commanddeclaration"}, {"full_name": "Computation.get_equiv", "code": "theorem get_equiv {c\u2081 c\u2082 : Computation \u03b1} (h : c\u2081 ~ c\u2082) [Terminates c\u2081] [Terminates c\u2082] :\n    get c\u2081 = get c\u2082", "start": [1006, 1], "end": [1008, 42], "kind": "commanddeclaration"}, {"full_name": "Computation.think_equiv", "code": "theorem think_equiv (s : Computation \u03b1) : think s ~ s", "start": [1011, 1], "end": [1011, 92], "kind": "commanddeclaration"}, {"full_name": "Computation.thinkN_equiv", "code": "theorem thinkN_equiv (s : Computation \u03b1) (n) : thinkN s n ~ s", "start": [1014, 1], "end": [1014, 87], "kind": "commanddeclaration"}, {"full_name": "Computation.bind_congr", "code": "theorem bind_congr {s1 s2 : Computation \u03b1} {f1 f2 : \u03b1 \u2192 Computation \u03b2} (h1 : s1 ~ s2)\n    (h2 : \u2200 a, f1 a ~ f2 a) : bind s1 f1 ~ bind s2 f2", "start": [1018, 1], "end": [1025, 44], "kind": "commanddeclaration"}, {"full_name": "Computation.equiv_pure_of_mem", "code": "theorem equiv_pure_of_mem {s : Computation \u03b1} {a} (h : a \u2208 s) : s ~ pure a", "start": [1028, 1], "end": [1029, 29], "kind": "commanddeclaration"}, {"full_name": "Computation.LiftRel", "code": "def LiftRel (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (ca : Computation \u03b1) (cb : Computation \u03b2) : Prop :=\n  (\u2200 {a}, a \u2208 ca \u2192 \u2203 b, b \u2208 cb \u2227 R a b) \u2227 \u2200 {b}, b \u2208 cb \u2192 \u2203 a, a \u2208 ca \u2227 R a b", "start": [1032, 1], "end": [1037, 78], "kind": "commanddeclaration"}, {"full_name": "Computation.LiftRel.swap", "code": "theorem LiftRel.swap (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (ca : Computation \u03b1) (cb : Computation \u03b2) :\n    LiftRel (swap R) cb ca \u2194 LiftRel R ca cb", "start": [1040, 1], "end": [1042, 16], "kind": "commanddeclaration"}, {"full_name": "Computation.lift_eq_iff_equiv", "code": "theorem lift_eq_iff_equiv (c\u2081 c\u2082 : Computation \u03b1) : LiftRel (\u00b7 = \u00b7) c\u2081 c\u2082 \u2194 c\u2081 ~ c\u2082", "start": [1045, 1], "end": [1049, 87], "kind": "commanddeclaration"}, {"full_name": "Computation.LiftRel.refl", "code": "theorem LiftRel.refl (R : \u03b1 \u2192 \u03b1 \u2192 Prop) (H : Reflexive R) : Reflexive (LiftRel R)", "start": [1052, 1], "end": [1053, 59], "kind": "commanddeclaration"}, {"full_name": "Computation.LiftRel.symm", "code": "theorem LiftRel.symm (R : \u03b1 \u2192 \u03b1 \u2192 Prop) (H : Symmetric R) : Symmetric (LiftRel R)", "start": [1056, 1], "end": [1063, 19], "kind": "commanddeclaration"}, {"full_name": "Computation.LiftRel.trans", "code": "theorem LiftRel.trans (R : \u03b1 \u2192 \u03b1 \u2192 Prop) (H : Transitive R) : Transitive (LiftRel R)", "start": [1066, 1], "end": [1075, 22], "kind": "commanddeclaration"}, {"full_name": "Computation.LiftRel.equiv", "code": "theorem LiftRel.equiv (R : \u03b1 \u2192 \u03b1 \u2192 Prop) : Equivalence R \u2192 Equivalence (LiftRel R)", "start": [1078, 1], "end": [1080, 41], "kind": "commanddeclaration"}, {"full_name": "Computation.LiftRel.imp", "code": "theorem LiftRel.imp {R S : \u03b1 \u2192 \u03b2 \u2192 Prop} (H : \u2200 {a b}, R a b \u2192 S a b) (s t) :\n    LiftRel R s t \u2192 LiftRel S s t", "start": [1087, 1], "end": [1095, 21], "kind": "commanddeclaration"}, {"full_name": "Computation.terminates_of_liftRel", "code": "theorem terminates_of_liftRel {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {s t} :\n    LiftRel R s t \u2192 (Terminates s \u2194 Terminates t)", "start": [1098, 1], "end": [1106, 17], "kind": "commanddeclaration"}, {"full_name": "Computation.rel_of_liftRel", "code": "theorem rel_of_liftRel {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {ca cb} :\n    LiftRel R ca cb \u2192 \u2200 {a b}, a \u2208 ca \u2192 b \u2208 cb \u2192 R a b", "start": [1109, 1], "end": [1113, 38], "kind": "commanddeclaration"}, {"full_name": "Computation.liftRel_of_mem", "code": "theorem liftRel_of_mem {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {a b ca cb} (ma : a \u2208 ca) (mb : b \u2208 cb) (ab : R a b) :\n    LiftRel R ca cb", "start": [1116, 1], "end": [1119, 47], "kind": "commanddeclaration"}, {"full_name": "Computation.exists_of_liftRel_left", "code": "theorem exists_of_liftRel_left {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {ca cb} (H : LiftRel R ca cb) {a} (h : a \u2208 ca) :\n    \u2203 b, b \u2208 cb \u2227 R a b", "start": [1122, 1], "end": [1124, 11], "kind": "commanddeclaration"}, {"full_name": "Computation.exists_of_liftRel_right", "code": "theorem exists_of_liftRel_right {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {ca cb} (H : LiftRel R ca cb) {b} (h : b \u2208 cb) :\n    \u2203 a, a \u2208 ca \u2227 R a b", "start": [1127, 1], "end": [1129, 12], "kind": "commanddeclaration"}, {"full_name": "Computation.liftRel_def", "code": "theorem liftRel_def {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {ca cb} :\n    LiftRel R ca cb \u2194 (Terminates ca \u2194 Terminates cb) \u2227 \u2200 {a b}, a \u2208 ca \u2192 b \u2208 cb \u2192 R a b", "start": [1132, 1], "end": [1144, 25], "kind": "commanddeclaration"}, {"full_name": "Computation.liftRel_bind", "code": "theorem liftRel_bind {\u03b4} (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (S : \u03b3 \u2192 \u03b4 \u2192 Prop) {s1 : Computation \u03b1}\n    {s2 : Computation \u03b2} {f1 : \u03b1 \u2192 Computation \u03b3} {f2 : \u03b2 \u2192 Computation \u03b4} (h1 : LiftRel R s1 s2)\n    (h2 : \u2200 {a b}, R a b \u2192 LiftRel S (f1 a) (f2 b)) : LiftRel S (bind s1 f1) (bind s2 f2)", "start": [1147, 1], "end": [1162, 29], "kind": "commanddeclaration"}, {"full_name": "Computation.liftRel_pure_left", "code": "@[simp]\ntheorem liftRel_pure_left (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (a : \u03b1) (cb : Computation \u03b2) :\n    LiftRel R (pure a) cb \u2194 \u2203 b, b \u2208 cb \u2227 R a b", "start": [1165, 1], "end": [1170, 60], "kind": "commanddeclaration"}, {"full_name": "Computation.liftRel_pure_right", "code": "@[simp]\ntheorem liftRel_pure_right (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (ca : Computation \u03b1) (b : \u03b2) :\n    LiftRel R ca (pure b) \u2194 \u2203 a, a \u2208 ca \u2227 R a b", "start": [1173, 1], "end": [1175, 91], "kind": "commanddeclaration"}, {"full_name": "Computation.liftRel_pure", "code": "@[simp, nolint simpNF]\ntheorem liftRel_pure (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (a : \u03b1) (b : \u03b2) :\n    LiftRel R (pure a) (pure b) \u2194 R a b", "start": [1180, 1], "end": [1184, 97], "kind": "commanddeclaration"}, {"full_name": "Computation.liftRel_think_left", "code": "@[simp]\ntheorem liftRel_think_left (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (ca : Computation \u03b1) (cb : Computation \u03b2) :\n    LiftRel R (think ca) cb \u2194 LiftRel R ca cb", "start": [1187, 1], "end": [1192, 94], "kind": "commanddeclaration"}, {"full_name": "Computation.liftRel_think_right", "code": "@[simp]\ntheorem liftRel_think_right (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (ca : Computation \u03b1) (cb : Computation \u03b2) :\n    LiftRel R ca (think cb) \u2194 LiftRel R ca cb", "start": [1195, 1], "end": [1198, 68], "kind": "commanddeclaration"}, {"full_name": "Computation.liftRel_mem_cases", "code": "theorem liftRel_mem_cases {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {ca cb} (Ha : \u2200 a \u2208 ca, LiftRel R ca cb)\n    (Hb : \u2200 b \u2208 cb, LiftRel R ca cb) : LiftRel R ca cb", "start": [1201, 1], "end": [1203, 70], "kind": "commanddeclaration"}, {"full_name": "Computation.liftRel_congr", "code": "theorem liftRel_congr {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {ca ca' : Computation \u03b1} {cb cb' : Computation \u03b2}\n    (ha : ca ~ ca') (hb : cb ~ cb') : LiftRel R ca cb \u2194 LiftRel R ca' cb'", "start": [1206, 1], "end": [1210, 96], "kind": "commanddeclaration"}, {"full_name": "Computation.liftRel_map", "code": "theorem liftRel_map {\u03b4} (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (S : \u03b3 \u2192 \u03b4 \u2192 Prop) {s1 : Computation \u03b1}\n    {s2 : Computation \u03b2} {f1 : \u03b1 \u2192 \u03b3} {f2 : \u03b2 \u2192 \u03b4} (h1 : LiftRel R s1 s2)\n    (h2 : \u2200 {a b}, R a b \u2192 S (f1 a) (f2 b)) : LiftRel S (map f1 s1) (map f2 s2)", "start": [1213, 1], "end": [1222, 53], "kind": "commanddeclaration"}, {"full_name": "Computation.map_congr", "code": "theorem map_congr {s1 s2 : Computation \u03b1} {f : \u03b1 \u2192 \u03b2}\n    (h1 : s1 ~ s2) : map f s1 ~ map f s2", "start": [1226, 1], "end": [1229, 81], "kind": "commanddeclaration"}, {"full_name": "Computation.LiftRelAux", "code": "def LiftRelAux (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (C : Computation \u03b1 \u2192 Computation \u03b2 \u2192 Prop) :\n    Sum \u03b1 (Computation \u03b1) \u2192 Sum \u03b2 (Computation \u03b2) \u2192 Prop\n  | Sum.inl a, Sum.inl b => R a b\n  | Sum.inl a, Sum.inr cb => \u2203 b, b \u2208 cb \u2227 R a b\n  | Sum.inr ca, Sum.inl b => \u2203 a, a \u2208 ca \u2227 R a b\n  | Sum.inr ca, Sum.inr cb => C ca cb", "start": [1232, 1], "end": [1238, 38], "kind": "commanddeclaration"}, {"full_name": "Computation.liftRelAux_inl_inl", "code": "@[simp] lemma liftRelAux_inl_inl : LiftRelAux R C (Sum.inl a) (Sum.inl b) = R a b := rfl", "start": [1243, 1], "end": [1243, 89], "kind": "mathlibtacticlemma"}, {"full_name": "Computation.liftRelAux_inl_inr", "code": "@[simp] lemma liftRelAux_inl_inr {cb} :\n    LiftRelAux R C (Sum.inl a) (Sum.inr cb) = \u2203 b, b \u2208 cb \u2227 R a b :=\n  rfl", "start": [1244, 1], "end": [1246, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Computation.liftRelAux_inr_inl", "code": "@[simp] lemma liftRelAux_inr_inl {ca} :\n    LiftRelAux R C (Sum.inr ca) (Sum.inl b) = \u2203 a, a \u2208 ca \u2227 R a b :=\n  rfl", "start": [1247, 1], "end": [1249, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Computation.liftRelAux_inr_inr", "code": "@[simp] lemma liftRelAux_inr_inr {ca cb} :\n    LiftRelAux R C (Sum.inr ca) (Sum.inr cb) = C ca cb :=\n  rfl", "start": [1250, 1], "end": [1252, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Computation.LiftRelAux.ret_left", "code": "@[simp]\ntheorem LiftRelAux.ret_left (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (C : Computation \u03b1 \u2192 Computation \u03b2 \u2192 Prop) (a cb) :\n    LiftRelAux R C (Sum.inl a) (destruct cb) \u2194 \u2203 b, b \u2208 cb \u2227 R a b", "start": [1254, 1], "end": [1263, 90], "kind": "commanddeclaration"}, {"full_name": "Computation.LiftRelAux.swap", "code": "theorem LiftRelAux.swap (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (C) (a b) :\n    LiftRelAux (swap R) (swap C) b a = LiftRelAux R C a b", "start": [1266, 1], "end": [1268, 71], "kind": "commanddeclaration"}, {"full_name": "Computation.LiftRelAux.ret_right", "code": "@[simp]\ntheorem LiftRelAux.ret_right (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (C : Computation \u03b1 \u2192 Computation \u03b2 \u2192 Prop) (b ca) :\n    LiftRelAux R C (destruct ca) (Sum.inl b) \u2194 \u2203 a, a \u2208 ca \u2227 R a b", "start": [1271, 1], "end": [1274, 46], "kind": "commanddeclaration"}, {"full_name": "Computation.LiftRelRec.lem", "code": "theorem LiftRelRec.lem {R : \u03b1 \u2192 \u03b2 \u2192 Prop} (C : Computation \u03b1 \u2192 Computation \u03b2 \u2192 Prop)\n    (H : \u2200 {ca cb}, C ca cb \u2192 LiftRelAux R C (destruct ca) (destruct cb)) (ca cb) (Hc : C ca cb) (a)\n    (ha : a \u2208 ca) : LiftRel R ca cb", "start": [1277, 1], "end": [1288, 17], "kind": "commanddeclaration"}, {"full_name": "Computation.liftRel_rec", "code": "theorem liftRel_rec {R : \u03b1 \u2192 \u03b2 \u2192 Prop} (C : Computation \u03b1 \u2192 Computation \u03b2 \u2192 Prop)\n    (H : \u2200 {ca cb}, C ca cb \u2192 LiftRelAux R C (destruct ca) (destruct cb)) (ca cb) (Hc : C ca cb) :\n    LiftRel R ca cb", "start": [1291, 1], "end": [1297, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/LazyList.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LazyList", "code": "inductive LazyList (\u03b1 : Type u) : Type u\n  | nil : LazyList \u03b1\n  | cons (hd : \u03b1) (tl : Thunk <| LazyList \u03b1) : LazyList \u03b1", "start": [23, 1], "end": [28, 58], "kind": "commanddeclaration"}, {"full_name": "LazyList.singleton", "code": "def singleton : \u03b1 \u2192 LazyList \u03b1\n  | a => cons a <| Thunk.pure nil", "start": [38, 1], "end": [40, 34], "kind": "commanddeclaration"}, {"full_name": "LazyList.ofList", "code": "def ofList : List \u03b1 \u2192 LazyList \u03b1\n  | [] => nil\n  | h :: t => cons h (ofList t)", "start": [43, 1], "end": [46, 32], "kind": "commanddeclaration"}, {"full_name": "LazyList.toList", "code": "def toList : LazyList \u03b1 \u2192 List \u03b1\n  | nil => []\n  | cons h t => h :: toList (t.get)", "start": [49, 1], "end": [55, 36], "kind": "commanddeclaration"}, {"full_name": "LazyList.headI", "code": "def headI [Inhabited \u03b1] : LazyList \u03b1 \u2192 \u03b1\n  | nil => default\n  | cons h _ => h", "start": [58, 1], "end": [63, 18], "kind": "commanddeclaration"}, {"full_name": "LazyList.tail", "code": "def tail : LazyList \u03b1 \u2192 LazyList \u03b1\n  | nil => nil\n  | cons _ t => t.get", "start": [66, 1], "end": [70, 22], "kind": "commanddeclaration"}, {"full_name": "LazyList.append", "code": "def append : LazyList \u03b1 \u2192 Thunk (LazyList \u03b1) \u2192 LazyList \u03b1\n  | nil, l => l.get\n  | cons h t, l => cons h (@append (t.get) l)", "start": [73, 1], "end": [76, 46], "kind": "commanddeclaration"}, {"full_name": "LazyList.map", "code": "def map (f : \u03b1 \u2192 \u03b2) : LazyList \u03b1 \u2192 LazyList \u03b2\n  | nil => nil\n  | cons h t => cons (f h) (map f t.get)", "start": [79, 1], "end": [82, 41], "kind": "commanddeclaration"}, {"full_name": "LazyList.map\u2082", "code": "def map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b4) : LazyList \u03b1 \u2192 LazyList \u03b2 \u2192 LazyList \u03b4\n  | nil, _ => nil\n  | _, nil => nil\n  | cons h\u2081 t\u2081, cons h\u2082 t\u2082 => cons (f h\u2081 h\u2082) (map\u2082 f t\u2081.get t\u2082.get)", "start": [85, 1], "end": [91, 68], "kind": "commanddeclaration"}, {"full_name": "LazyList.zip", "code": "def zip : LazyList \u03b1 \u2192 LazyList \u03b2 \u2192 LazyList (\u03b1 \u00d7 \u03b2) :=\n  map\u2082 Prod.mk", "start": [94, 1], "end": [96, 15], "kind": "commanddeclaration"}, {"full_name": "LazyList.join", "code": "def join : LazyList (LazyList \u03b1) \u2192 LazyList \u03b1\n  | nil => nil\n  | cons h t => append h (join (t.get))", "start": [99, 1], "end": [102, 40], "kind": "commanddeclaration"}, {"full_name": "LazyList.for", "code": "def \u00abfor\u00bb (l : LazyList \u03b1) (f : \u03b1 \u2192 \u03b2) : LazyList \u03b2 :=\n  map f l", "start": [105, 1], "end": [109, 10], "kind": "commanddeclaration"}, {"full_name": "LazyList.approx", "code": "def approx : Nat \u2192 LazyList \u03b1 \u2192 List \u03b1\n  | 0, _ => []\n  | _, nil => []\n  | a + 1, cons h t => h :: approx a (t.get)", "start": [112, 1], "end": [116, 45], "kind": "commanddeclaration"}, {"full_name": "LazyList.filter", "code": "def filter (p : \u03b1 \u2192 Prop) [DecidablePred p] : LazyList \u03b1 \u2192 LazyList \u03b1\n  | nil => nil\n  | cons h t => if p h then cons h (filter p t.get) else filter p (t.get)", "start": [119, 1], "end": [125, 74], "kind": "commanddeclaration"}, {"full_name": "LazyList.nth", "code": "def nth : LazyList \u03b1 \u2192 Nat \u2192 Option \u03b1\n  | nil, _ => none\n  | cons a _, 0 => some a\n  | cons _ l, n + 1 => nth (l.get) n", "start": [128, 1], "end": [132, 37], "kind": "commanddeclaration"}, {"full_name": "LazyList.iterates", "code": "unsafe def iterates (f : \u03b1 \u2192 \u03b1) : \u03b1 \u2192 LazyList \u03b1\n  | x => cons x (iterates f (f x))", "start": [135, 1], "end": [139, 35], "kind": "commanddeclaration"}, {"full_name": "LazyList.iota", "code": "unsafe def iota (i : Nat) : LazyList Nat :=\n  iterates Nat.succ i", "start": [142, 1], "end": [144, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Sym/Sym2/Init.lean", "imports": ["lake-packages/aesop/Aesop.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/CategoryTheory/Monad/Basic.lean", "imports": ["Mathlib/CategoryTheory/Functor/ReflectsIso.lean", "Mathlib/CategoryTheory/Functor/Category.lean", "Mathlib/CategoryTheory/Functor/FullyFaithful.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Monad", "code": "structure Monad extends C \u2964 C where\n  \u03b7' : \ud835\udfed _ \u27f6 toFunctor\n  \u03bc' : toFunctor \u22d9 toFunctor \u27f6 toFunctor\n  assoc' : \u2200 X, toFunctor.map (NatTrans.app \u03bc' X) \u226b \u03bc'.app _ = \u03bc'.app _ \u226b \u03bc'.app _ := by aesop_cat\n  left_unit' : \u2200 X : C, \u03b7'.app (toFunctor.obj X) \u226b \u03bc'.app _ = \ud835\udfd9 _ := by aesop_cat\n  right_unit' : \u2200 X : C, toFunctor.map (\u03b7'.app X) \u226b \u03bc'.app _ = \ud835\udfd9 _ := by aesop_cat", "start": [34, 1], "end": [45, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comonad", "code": "structure Comonad extends C \u2964 C where\n  \u03b5' : toFunctor \u27f6 \ud835\udfed _\n  \u03b4' : toFunctor \u27f6 toFunctor \u22d9 toFunctor\n  coassoc' : \u2200 X, NatTrans.app \u03b4' _ \u226b toFunctor.map (\u03b4'.app X) = \u03b4'.app _ \u226b \u03b4'.app _ := by\n    aesop_cat\n  left_counit' : \u2200 X : C, \u03b4'.app X \u226b \u03b5'.app (toFunctor.obj X) = \ud835\udfd9 _ := by aesop_cat\n  right_counit' : \u2200 X : C, \u03b4'.app X \u226b toFunctor.map (\u03b5'.app X) = \ud835\udfd9 _ := by aesop_cat", "start": [48, 1], "end": [60, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coeMonad", "code": "instance coeMonad : Coe (Monad C) (C \u2964 C) :=\n  \u27e8fun T => T.toFunctor\u27e9", "start": [66, 1], "end": [67, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coeComonad", "code": "instance coeComonad : Coe (Comonad C) (C \u2964 C) :=\n  \u27e8fun G => G.toFunctor\u27e9", "start": [70, 1], "end": [71, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.\u03b7", "code": "def Monad.\u03b7 : \ud835\udfed _ \u27f6 (T : C \u2964 C) :=\n  T.\u03b7'", "start": [85, 1], "end": [87, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.\u03bc", "code": "def Monad.\u03bc : (T : C \u2964 C) \u22d9 (T : C \u2964 C) \u27f6 T :=\n  T.\u03bc'", "start": [90, 1], "end": [92, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comonad.\u03b5", "code": "def Comonad.\u03b5 : (G : C \u2964 C) \u27f6 \ud835\udfed _ :=\n  G.\u03b5'", "start": [95, 1], "end": [97, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comonad.\u03b4", "code": "def Comonad.\u03b4 : (G : C \u2964 C) \u27f6 (G : C \u2964 C) \u22d9 G :=\n  G.\u03b4'", "start": [100, 1], "end": [102, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.Simps.coe", "code": "def Monad.Simps.coe :=\n  (T : C \u2964 C)", "start": [105, 1], "end": [107, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.Simps.\u03b7", "code": "def Monad.Simps.\u03b7 : \ud835\udfed _ \u27f6 (T : C \u2964 C) :=\n  T.\u03b7", "start": [110, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.Simps.\u03bc", "code": "def Monad.Simps.\u03bc : (T : C \u2964 C) \u22d9 (T : C \u2964 C) \u27f6 (T : C \u2964 C) :=\n  T.\u03bc", "start": [115, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comonad.Simps.coe", "code": "def Comonad.Simps.coe :=\n  (G : C \u2964 C)", "start": [120, 1], "end": [122, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comonad.Simps.\u03b5", "code": "def Comonad.Simps.\u03b5 : (G : C \u2964 C) \u27f6 \ud835\udfed _ :=\n  G.\u03b5", "start": [125, 1], "end": [127, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comonad.Simps.\u03b4", "code": "def Comonad.Simps.\u03b4 : (G : C \u2964 C) \u27f6 (G : C \u2964 C) \u22d9 (G : C \u2964 C) :=\n  G.\u03b4", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.assoc", "code": "@[reassoc]\ntheorem Monad.assoc (T : Monad C) (X : C) :\n    (T : C \u2964 C).map (T.\u03bc.app X) \u226b T.\u03bc.app _ = T.\u03bc.app _ \u226b T.\u03bc.app _", "start": [142, 1], "end": [145, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.left_unit", "code": "@[reassoc (attr := simp)]\ntheorem Monad.left_unit (T : Monad C) (X : C) :\n    T.\u03b7.app ((T : C \u2964 C).obj X) \u226b T.\u03bc.app X = \ud835\udfd9 ((T : C \u2964 C).obj X)", "start": [148, 1], "end": [151, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.right_unit", "code": "@[reassoc (attr := simp)]\ntheorem Monad.right_unit (T : Monad C) (X : C) :\n    (T : C \u2964 C).map (T.\u03b7.app X) \u226b T.\u03bc.app X = \ud835\udfd9 ((T : C \u2964 C).obj X)", "start": [154, 1], "end": [157, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comonad.coassoc", "code": "@[reassoc (attr := simp)]\ntheorem Comonad.coassoc (G : Comonad C) (X : C) :\n    G.\u03b4.app _ \u226b (G : C \u2964 C).map (G.\u03b4.app X) = G.\u03b4.app _ \u226b G.\u03b4.app _", "start": [160, 1], "end": [163, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comonad.left_counit", "code": "@[reassoc (attr := simp)]\ntheorem Comonad.left_counit (G : Comonad C) (X : C) :\n    G.\u03b4.app X \u226b G.\u03b5.app ((G : C \u2964 C).obj X) = \ud835\udfd9 ((G : C \u2964 C).obj X)", "start": [166, 1], "end": [169, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comonad.right_counit", "code": "@[reassoc (attr := simp)]\ntheorem Comonad.right_counit (G : Comonad C) (X : C) :\n    G.\u03b4.app X \u226b (G : C \u2964 C).map (G.\u03b5.app X) = \ud835\udfd9 ((G : C \u2964 C).obj X)", "start": [172, 1], "end": [175, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonadHom", "code": "@[ext]\nstructure MonadHom (T\u2081 T\u2082 : Monad C) extends NatTrans (T\u2081 : C \u2964 C) T\u2082 where\n  app_\u03b7 : \u2200 X, T\u2081.\u03b7.app X \u226b app X = T\u2082.\u03b7.app X := by aesop_cat\n  app_\u03bc : \u2200 X, T\u2081.\u03bc.app X \u226b app X = (T\u2081.map (app X) \u226b app _) \u226b T\u2082.\u03bc.app X := by\n    aesop_cat", "start": [178, 1], "end": [183, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ComonadHom", "code": "@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C \u2964 C) N where\n  app_\u03b5 : \u2200 X, app X \u226b N.\u03b5.app X = M.\u03b5.app X := by aesop_cat\n  app_\u03b4 : \u2200 X, app X \u226b N.\u03b4.app X = M.\u03b4.app X \u226b app _ \u226b N.map (app X) := by aesop_cat", "start": [188, 1], "end": [192, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonadHom.ext'", "code": "@[ext]\nlemma MonadHom.ext' {T\u2081 T\u2082 : Monad C} (f g : T\u2081 \u27f6 T\u2082) (h : f.app = g.app) : f = g :=\n  MonadHom.ext f g h", "start": [207, 1], "end": [209, 21], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ComonadHom.ext'", "code": "@[ext]\nlemma ComonadHom.ext' {T\u2081 T\u2082 : Comonad C} (f g : T\u2081 \u27f6 T\u2082) (h : f.app = g.app) : f = g :=\n  ComonadHom.ext f g h", "start": [212, 1], "end": [214, 23], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.MonadHom.id_toNatTrans", "code": "@[simp]\ntheorem MonadHom.id_toNatTrans (T : Monad C) : (\ud835\udfd9 T : T \u27f6 T).toNatTrans = \ud835\udfd9 (T : C \u2964 C)", "start": [241, 1], "end": [243, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonadHom.comp_toNatTrans", "code": "@[simp]\ntheorem MonadHom.comp_toNatTrans {T\u2081 T\u2082 T\u2083 : Monad C} (f : T\u2081 \u27f6 T\u2082) (g : T\u2082 \u27f6 T\u2083) :\n    (f \u226b g).toNatTrans = ((f.toNatTrans : _ \u27f6 (T\u2082 : C \u2964 C)) \u226b g.toNatTrans : (T\u2081 : C \u2964 C) \u27f6 T\u2083)", "start": [246, 1], "end": [249, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ComonadHom.id_toNatTrans", "code": "@[simp]\ntheorem ComonadHom.id_toNatTrans (T : Comonad C) : (\ud835\udfd9 T : T \u27f6 T).toNatTrans = \ud835\udfd9 (T : C \u2964 C)", "start": [255, 1], "end": [257, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.comp_toNatTrans", "code": "@[simp]\ntheorem comp_toNatTrans {T\u2081 T\u2082 T\u2083 : Comonad C} (f : T\u2081 \u27f6 T\u2082) (g : T\u2082 \u27f6 T\u2083) :\n    (f \u226b g).toNatTrans = ((f.toNatTrans : _ \u27f6 (T\u2082 : C \u2964 C)) \u226b g.toNatTrans : (T\u2081 : C \u2964 C) \u27f6 T\u2083)", "start": [260, 1], "end": [263, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonadIso.mk", "code": "@[simps]\ndef MonadIso.mk {M N : Monad C} (f : (M : C \u2964 C) \u2245 N)\n    (f_\u03b7 : \u2200 (X : C), M.\u03b7.app X \u226b f.hom.app X = N.\u03b7.app X := by aesop_cat)\n    (f_\u03bc : \u2200 (X : C), M.\u03bc.app X \u226b f.hom.app X =\n    (M.map (f.hom.app X) \u226b f.hom.app (N.obj X)) \u226b N.\u03bc.app X := by aesop_cat) : M \u2245 N where\n  hom :=\n    { toNatTrans := f.hom\n      app_\u03b7 := f_\u03b7\n      app_\u03bc := f_\u03bc }\n  inv :=\n    { toNatTrans := f.inv\n      app_\u03b7 := fun X => by simp [\u2190 f_\u03b7]\n      app_\u03bc := fun X => by\n        rw [\u2190 NatIso.cancel_natIso_hom_right f]\n        simp only [NatTrans.naturality, Iso.inv_hom_id_app, assoc, comp_id, f_\u03bc,\n          NatTrans.naturality_assoc, Iso.inv_hom_id_app_assoc, \u2190 Functor.map_comp_assoc]\n        simp }", "start": [266, 1], "end": [284, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ComonadIso.mk", "code": "@[simps]\ndef ComonadIso.mk {M N : Comonad C} (f : (M : C \u2964 C) \u2245 N)\n    (f_\u03b5 : \u2200 (X : C), f.hom.app X \u226b N.\u03b5.app X = M.\u03b5.app X := by aesop_cat)\n    (f_\u03b4 : \u2200 (X : C), f.hom.app X \u226b N.\u03b4.app X =\n    M.\u03b4.app X \u226b f.hom.app (M.obj X) \u226b N.map (f.hom.app X) := by aesop_cat) : M \u2245 N where\n  hom :=\n    { toNatTrans := f.hom\n      app_\u03b5 := f_\u03b5\n      app_\u03b4 := f_\u03b4 }\n  inv :=\n    { toNatTrans := f.inv\n      app_\u03b5 := fun X => by simp [\u2190 f_\u03b5]\n      app_\u03b4 := fun X => by\n        rw [\u2190 NatIso.cancel_natIso_hom_left f]\n        simp only [reassoc_of% (f_\u03b4 X), Iso.hom_inv_id_app_assoc, NatTrans.naturality_assoc]\n        rw [\u2190 Functor.map_comp, Iso.hom_inv_id_app, Functor.map_id]\n        apply (comp_id _).symm }", "start": [287, 1], "end": [305, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monadToFunctor", "code": "@[simps!]\ndef monadToFunctor : Monad C \u2964 C \u2964 C where\n  obj T := T\n  map f := f.toNatTrans", "start": [310, 1], "end": [315, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monadToFunctor_mapIso_monad_iso_mk", "code": "theorem monadToFunctor_mapIso_monad_iso_mk {M N : Monad C} (f : (M : C \u2964 C) \u2245 N) (f_\u03b7 f_\u03bc) :\n    (monadToFunctor _).mapIso (MonadIso.mk f f_\u03b7 f_\u03bc) = f", "start": [320, 1], "end": [323, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.comonadToFunctor", "code": "@[simps!]\ndef comonadToFunctor : Comonad C \u2964 C \u2964 C where\n  obj G := G\n  map f := f.toNatTrans", "start": [329, 1], "end": [334, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.comonadToFunctor_mapIso_comonad_iso_mk", "code": "theorem comonadToFunctor_mapIso_comonad_iso_mk {M N : Comonad C} (f : (M : C \u2964 C) \u2245 N) (f_\u03b5 f_\u03b4) :\n    (comonadToFunctor _).mapIso (ComonadIso.mk f f_\u03b5 f_\u03b4) = f", "start": [339, 1], "end": [342, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonadIso.toNatIso", "code": "@[simps!]\ndef MonadIso.toNatIso {M N : Monad C} (h : M \u2245 N) : (M : C \u2964 C) \u2245 N :=\n  (monadToFunctor C).mapIso h", "start": [350, 1], "end": [357, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ComonadIso.toNatIso", "code": "@[simps!]\ndef ComonadIso.toNatIso {M N : Comonad C} (h : M \u2245 N) : (M : C \u2964 C) \u2245 N :=\n  (comonadToFunctor C).mapIso h", "start": [360, 1], "end": [364, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.id", "code": "@[simps!]\ndef id : Monad C where\n  toFunctor := \ud835\udfed C\n  \u03b7' := \ud835\udfd9 (\ud835\udfed C)\n  \u03bc' := \ud835\udfd9 (\ud835\udfed C)", "start": [371, 1], "end": [376, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comonad.id", "code": "@[simps!]\ndef id : Comonad C where\n  toFunctor := \ud835\udfed _\n  \u03b5' := \ud835\udfd9 (\ud835\udfed C)\n  \u03b4' := \ud835\udfd9 (\ud835\udfed C)", "start": [386, 1], "end": [391, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Opposites.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/FiniteProducts.lean", "Mathlib/CategoryTheory/Limits/Filtered.lean", "Mathlib/CategoryTheory/DiscreteCategory.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean"], "premises": [{"full_name": "CategoryTheory.Limits.isLimitCoconeOp", "code": "@[simps]\ndef isLimitCoconeOp (F : J \u2964 C) {c : Cocone F} (hc : IsColimit c) : IsLimit c.op\n    where\n  lift s := (hc.desc s.unop).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsColimit.fac] using w (op j)", "start": [38, 1], "end": [46, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitConeOp", "code": "@[simps]\ndef isColimitConeOp (F : J \u2964 C) {c : Cone F} (hc : IsLimit c) : IsColimit c.op\n    where\n  desc s := (hc.lift s.unop).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsLimit.fac] using w (op j)", "start": [49, 1], "end": [57, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitConeLeftOpOfCocone", "code": "@[simps]\ndef isLimitConeLeftOpOfCocone (F : J \u2964 C\u1d52\u1d56) {c : Cocone F} (hc : IsColimit c) :\n    IsLimit (coneLeftOpOfCocone c)\n    where\n  lift s := (hc.desc (coconeOfConeLeftOp s)).unop\n  fac s j :=\n    Quiver.Hom.op_inj <| by\n      simp only [coneLeftOpOfCocone_\u03c0_app, op_comp, Quiver.Hom.op_unop, IsColimit.fac,\n        coconeOfConeLeftOp_\u03b9_app, op_unop]\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsColimit.fac, coconeOfConeLeftOp_\u03b9_app] using w (op j)", "start": [60, 1], "end": [72, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitCoconeLeftOpOfCone", "code": "@[simps]\ndef isColimitCoconeLeftOpOfCone (F : J \u2964 C\u1d52\u1d56) {c : Cone F} (hc : IsLimit c) :\n    IsColimit (coconeLeftOpOfCone c)\n    where\n  desc s := (hc.lift (coneOfCoconeLeftOp s)).unop\n  fac s j :=\n    Quiver.Hom.op_inj <| by\n      simp only [coconeLeftOpOfCone_\u03b9_app, op_comp, Quiver.Hom.op_unop, IsLimit.fac,\n        coneOfCoconeLeftOp_\u03c0_app, op_unop]\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsLimit.fac, coneOfCoconeLeftOp_\u03c0_app] using w (op j)", "start": [75, 1], "end": [87, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitConeRightOpOfCocone", "code": "@[simps]\ndef isLimitConeRightOpOfCocone (F : J\u1d52\u1d56 \u2964 C) {c : Cocone F} (hc : IsColimit c) :\n    IsLimit (coneRightOpOfCocone c)\n    where\n  lift s := (hc.desc (coconeOfConeRightOp s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsColimit.fac] using w (unop j)", "start": [90, 1], "end": [99, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitCoconeRightOpOfCone", "code": "@[simps]\ndef isColimitCoconeRightOpOfCone (F : J\u1d52\u1d56 \u2964 C) {c : Cone F} (hc : IsLimit c) :\n    IsColimit (coconeRightOpOfCone c)\n    where\n  desc s := (hc.lift (coneOfCoconeRightOp s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsLimit.fac] using w (unop j)", "start": [102, 1], "end": [111, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitConeUnopOfCocone", "code": "@[simps]\ndef isLimitConeUnopOfCocone (F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56) {c : Cocone F} (hc : IsColimit c) :\n    IsLimit (coneUnopOfCocone c)\n    where\n  lift s := (hc.desc (coconeOfConeUnop s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsColimit.fac] using w (unop j)", "start": [114, 1], "end": [123, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitCoconeUnopOfCone", "code": "@[simps]\ndef isColimitCoconeUnopOfCone (F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56) {c : Cone F} (hc : IsLimit c) :\n    IsColimit (coconeUnopOfCone c)\n    where\n  desc s := (hc.lift (coneOfCoconeUnop s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsLimit.fac] using w (unop j)", "start": [126, 1], "end": [135, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitCoconeUnop", "code": "@[simps]\ndef isLimitCoconeUnop (F : J \u2964 C) {c : Cocone F.op} (hc : IsColimit c) : IsLimit c.unop\n    where\n  lift s := (hc.desc s.op).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsColimit.fac] using w (unop j)", "start": [138, 1], "end": [146, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitConeUnop", "code": "@[simps]\ndef isColimitConeUnop (F : J \u2964 C) {c : Cone F.op} (hc : IsLimit c) : IsColimit c.unop\n    where\n  desc s := (hc.lift s.op).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsLimit.fac] using w (unop j)", "start": [149, 1], "end": [157, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitConeOfCoconeLeftOp", "code": "@[simps]\ndef isLimitConeOfCoconeLeftOp (F : J \u2964 C\u1d52\u1d56) {c : Cocone F.leftOp} (hc : IsColimit c) :\n    IsLimit (coneOfCoconeLeftOp c)\n    where\n  lift s := (hc.desc (coconeLeftOpOfCone s)).op\n  fac s j :=\n    Quiver.Hom.unop_inj <| by\n      simp only [coneOfCoconeLeftOp_\u03c0_app, unop_comp, Quiver.Hom.unop_op, IsColimit.fac,\n        coconeLeftOpOfCone_\u03b9_app, unop_op]\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsColimit.fac, coneOfCoconeLeftOp_\u03c0_app] using w (unop j)", "start": [160, 1], "end": [172, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitCoconeOfConeLeftOp", "code": "@[simps]\ndef isColimitCoconeOfConeLeftOp (F : J \u2964 C\u1d52\u1d56) {c : Cone F.leftOp} (hc : IsLimit c) :\n    IsColimit (coconeOfConeLeftOp c)\n    where\n  desc s := (hc.lift (coneLeftOpOfCocone s)).op\n  fac s j :=\n    Quiver.Hom.unop_inj <| by\n      simp only [coconeOfConeLeftOp_\u03b9_app, unop_comp, Quiver.Hom.unop_op, IsLimit.fac,\n        coneLeftOpOfCocone_\u03c0_app, unop_op]\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsLimit.fac, coconeOfConeLeftOp_\u03b9_app] using w (unop j)", "start": [175, 1], "end": [187, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitConeOfCoconeRightOp", "code": "@[simps]\ndef isLimitConeOfCoconeRightOp (F : J\u1d52\u1d56 \u2964 C) {c : Cocone F.rightOp} (hc : IsColimit c) :\n    IsLimit (coneOfCoconeRightOp c)\n    where\n  lift s := (hc.desc (coconeRightOpOfCone s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsColimit.fac] using w (op j)", "start": [190, 1], "end": [199, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitCoconeOfConeRightOp", "code": "@[simps]\ndef isColimitCoconeOfConeRightOp (F : J\u1d52\u1d56 \u2964 C) {c : Cone F.rightOp} (hc : IsLimit c) :\n    IsColimit (coconeOfConeRightOp c)\n    where\n  desc s := (hc.lift (coneRightOpOfCocone s)).unop\n  fac s j := Quiver.Hom.op_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.op_inj (hc.hom_ext fun j => Quiver.Hom.unop_inj _)\n    simpa only [Quiver.Hom.op_unop, IsLimit.fac] using w (op j)", "start": [202, 1], "end": [211, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitConeOfCoconeUnop", "code": "@[simps]\ndef isLimitConeOfCoconeUnop (F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56) {c : Cocone F.unop} (hc : IsColimit c) :\n    IsLimit (coneOfCoconeUnop c)\n    where\n  lift s := (hc.desc (coconeUnopOfCone s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsColimit.fac] using w (op j)", "start": [214, 1], "end": [223, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitConeOfCoconeUnop", "code": "@[simps]\ndef isColimitConeOfCoconeUnop (F : J\u1d52\u1d56 \u2964 C\u1d52\u1d56) {c : Cone F.unop} (hc : IsLimit c) :\n    IsColimit (coconeOfConeUnop c)\n    where\n  desc s := (hc.lift (coneUnopOfCocone s)).op\n  fac s j := Quiver.Hom.unop_inj (by simp)\n  uniq s m w := by\n    refine' Quiver.Hom.unop_inj (hc.hom_ext fun j => Quiver.Hom.op_inj _)\n    simpa only [Quiver.Hom.unop_op, IsLimit.fac] using w (op j)", "start": [226, 1], "end": [235, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimit_of_hasColimit_leftOp", "code": "theorem hasLimit_of_hasColimit_leftOp (F : J \u2964 C\u1d52\u1d56) [HasColimit F.leftOp] : HasLimit F", "start": [238, 1], "end": [243, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimit_of_hasColimit_op", "code": "theorem hasLimit_of_hasColimit_op (F : J \u2964 C) [HasColimit F.op] : HasLimit F", "start": [246, 1], "end": [249, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimit_op_of_hasColimit", "code": "theorem hasLimit_op_of_hasColimit (F : J \u2964 C) [HasColimit F] : HasLimit F.op", "start": [251, 1], "end": [254, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitsOfShape_op_of_hasColimitsOfShape", "code": "theorem hasLimitsOfShape_op_of_hasColimitsOfShape [HasColimitsOfShape J\u1d52\u1d56 C] :\n    HasLimitsOfShape J C\u1d52\u1d56", "start": [257, 1], "end": [261, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitsOfShape_of_hasColimitsOfShape_op", "code": "theorem hasLimitsOfShape_of_hasColimitsOfShape_op [HasColimitsOfShape J\u1d52\u1d56 C\u1d52\u1d56] :\n    HasLimitsOfShape J C", "start": [264, 1], "end": [266, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimits_op_of_hasColimits", "code": "instance hasLimits_op_of_hasColimits [HasColimits C] : HasLimits C\u1d52\u1d56 :=\n  \u27e8fun _ => inferInstance\u27e9", "start": [271, 1], "end": [274, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimits_of_hasColimits_op", "code": "theorem hasLimits_of_hasColimits_op [HasColimits C\u1d52\u1d56] : HasLimits C", "start": [277, 1], "end": [278, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.has_cofiltered_limits_op_of_has_filtered_colimits", "code": "instance has_cofiltered_limits_op_of_has_filtered_colimits [HasFilteredColimitsOfSize.{v\u2082, u\u2082} C] :\n    HasCofilteredLimitsOfSize.{v\u2082, u\u2082} C\u1d52\u1d56 where\n  HasLimitsOfShape _ _ _ := hasLimitsOfShape_op_of_hasColimitsOfShape", "start": [281, 1], "end": [283, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.has_cofiltered_limits_of_has_filtered_colimits_op", "code": "theorem has_cofiltered_limits_of_has_filtered_colimits_op [HasFilteredColimitsOfSize.{v\u2082, u\u2082} C\u1d52\u1d56] :\n    HasCofilteredLimitsOfSize.{v\u2082, u\u2082} C", "start": [286, 1], "end": [288, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimit_of_hasLimit_leftOp", "code": "theorem hasColimit_of_hasLimit_leftOp (F : J \u2964 C\u1d52\u1d56) [HasLimit F.leftOp] : HasColimit F", "start": [291, 1], "end": [296, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimit_of_hasLimit_op", "code": "theorem hasColimit_of_hasLimit_op (F : J \u2964 C) [HasLimit F.op] : HasColimit F", "start": [299, 1], "end": [302, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimit_op_of_hasLimit", "code": "theorem hasColimit_op_of_hasLimit (F : J \u2964 C) [HasLimit F] : HasColimit F.op", "start": [305, 1], "end": [308, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimitsOfShape_op_of_hasLimitsOfShape", "code": "instance hasColimitsOfShape_op_of_hasLimitsOfShape [HasLimitsOfShape J\u1d52\u1d56 C] :\n    HasColimitsOfShape J C\u1d52\u1d56 where has_colimit F := hasColimit_of_hasLimit_leftOp F", "start": [310, 1], "end": [313, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimitsOfShape_of_hasLimitsOfShape_op", "code": "theorem hasColimitsOfShape_of_hasLimitsOfShape_op [HasLimitsOfShape J\u1d52\u1d56 C\u1d52\u1d56] :\n    HasColimitsOfShape J C", "start": [316, 1], "end": [318, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimits_op_of_hasLimits", "code": "instance hasColimits_op_of_hasLimits [HasLimits C] : HasColimits C\u1d52\u1d56 :=\n  \u27e8fun _ => inferInstance\u27e9", "start": [321, 1], "end": [324, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimits_of_hasLimits_op", "code": "theorem hasColimits_of_hasLimits_op [HasLimits C\u1d52\u1d56] : HasColimits C", "start": [327, 1], "end": [328, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.has_filtered_colimits_op_of_has_cofiltered_limits", "code": "instance has_filtered_colimits_op_of_has_cofiltered_limits [HasCofilteredLimitsOfSize.{v\u2082, u\u2082} C] :\n    HasFilteredColimitsOfSize.{v\u2082, u\u2082} C\u1d52\u1d56 where HasColimitsOfShape _ _ _ := inferInstance", "start": [331, 1], "end": [332, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.has_filtered_colimits_of_has_cofiltered_limits_op", "code": "theorem has_filtered_colimits_of_has_cofiltered_limits_op [HasCofilteredLimitsOfSize.{v\u2082, u\u2082} C\u1d52\u1d56] :\n    HasFilteredColimitsOfSize.{v\u2082, u\u2082} C", "start": [335, 1], "end": [337, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoproductsOfShape_opposite", "code": "instance hasCoproductsOfShape_opposite [HasProductsOfShape X C] : HasCoproductsOfShape X C\u1d52\u1d56 := by\n  haveI : HasLimitsOfShape (Discrete X)\u1d52\u1d56 C :=\n    hasLimitsOfShape_of_equivalence (Discrete.opposite X).symm\n  infer_instance", "start": [342, 1], "end": [347, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoproductsOfShape_of_opposite", "code": "theorem hasCoproductsOfShape_of_opposite [HasProductsOfShape X C\u1d52\u1d56] : HasCoproductsOfShape X C", "start": [350, 1], "end": [353, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasProductsOfShape_opposite", "code": "instance hasProductsOfShape_opposite [HasCoproductsOfShape X C] : HasProductsOfShape X C\u1d52\u1d56 := by\n  haveI : HasColimitsOfShape (Discrete X)\u1d52\u1d56 C :=\n    hasColimitsOfShape_of_equivalence (Discrete.opposite X).symm\n  infer_instance", "start": [356, 1], "end": [361, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasProductsOfShape_of_opposite", "code": "theorem hasProductsOfShape_of_opposite [HasCoproductsOfShape X C\u1d52\u1d56] : HasProductsOfShape X C", "start": [364, 1], "end": [367, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasProducts_opposite", "code": "instance hasProducts_opposite [HasCoproducts.{v\u2082} C] : HasProducts.{v\u2082} C\u1d52\u1d56 := fun _ =>\n  inferInstance", "start": [370, 1], "end": [371, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasProducts_of_opposite", "code": "theorem hasProducts_of_opposite [HasCoproducts.{v\u2082} C\u1d52\u1d56] : HasProducts.{v\u2082} C", "start": [374, 1], "end": [375, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoproducts_opposite", "code": "instance hasCoproducts_opposite [HasProducts.{v\u2082} C] : HasCoproducts.{v\u2082} C\u1d52\u1d56 := fun _ =>\n  inferInstance", "start": [378, 1], "end": [379, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoproducts_of_opposite", "code": "theorem hasCoproducts_of_opposite [HasProducts.{v\u2082} C\u1d52\u1d56] : HasCoproducts.{v\u2082} C", "start": [382, 1], "end": [383, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteCoproducts_opposite", "code": "instance hasFiniteCoproducts_opposite [HasFiniteProducts C] : HasFiniteCoproducts C\u1d52\u1d56 where\n  out _ := Limits.hasCoproductsOfShape_opposite _", "start": [386, 1], "end": [387, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteCoproducts_of_opposite", "code": "theorem hasFiniteCoproducts_of_opposite [HasFiniteProducts C\u1d52\u1d56] : HasFiniteCoproducts C", "start": [390, 1], "end": [391, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteProducts_opposite", "code": "instance hasFiniteProducts_opposite [HasFiniteCoproducts C] : HasFiniteProducts C\u1d52\u1d56 where\n  out _ := inferInstance", "start": [394, 1], "end": [395, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteProducts_of_opposite", "code": "theorem hasFiniteProducts_of_opposite [HasFiniteCoproducts C\u1d52\u1d56] : HasFiniteProducts C", "start": [398, 1], "end": [399, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.opCoproductIsoProduct", "code": "@[simp]\nnoncomputable\ndef opCoproductIsoProduct : op (\u2210 Z) \u2245 \u220f (fun z => op (Z z)) :=\n  IsLimit.conePointUniqueUpToIso (isLimitCoconeOp _ (coproductIsCoproduct fun b \u21a6 Z b))\n    (limit.isLimit _) \u226a\u226b (IsLimit.conePointsIsoOfEquivalence\n    (productIsProduct (fun z \u21a6 op (Z z))) (limit.isLimit _) (Discrete.opposite \u03b1).symm\n    (Discrete.natIsoFunctor \u226a\u226b Discrete.natIso (fun _ \u21a6 by rfl))).symm", "start": [416, 1], "end": [423, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.opCoproductIsoProduct_inv_comp_\u03b9", "code": "lemma opCoproductIsoProduct_inv_comp_\u03b9 (b : \u03b1) :\n    (opCoproductIsoProduct Z).inv \u226b (Sigma.\u03b9 (fun a => Z a) b).op =\n    Pi.\u03c0 (fun a => op (Z a)) b := by\n  dsimp only [opCoproductIsoProduct]\n  simp only [Iso.trans_inv]\n  have := IsLimit.conePointUniqueUpToIso_inv_comp\n    (isLimitCoconeOp _ (coproductIsCoproduct fun b \u21a6 Z b)) (limit.isLimit _) (op \u27e8b\u27e9)\n  dsimp at this\n  rw [Category.assoc, this]\n  simp only [limit.cone_x, Fan.mk_pt, Equivalence.symm_functor, Discrete.natIsoFunctor,\n    Functor.comp_obj, Functor.op_obj, Iso.symm_inv, IsLimit.conePointsIsoOfEquivalence_hom,\n    Equivalence.symm_inverse, Cones.equivalenceOfReindexing_functor, Iso.trans_hom, Iso.symm_hom,\n    isoWhiskerLeft_inv, Iso.trans_inv, whiskerLeft_comp, Cones.whiskering_obj, limit.isLimit_lift,\n    limit.lift_\u03c0, Cones.postcompose_obj_pt, Cone.whisker_pt, Cones.postcompose_obj_\u03c0,\n    Cone.whisker_\u03c0, Category.assoc, NatTrans.comp_app, Functor.const_obj_obj, unop_op,\n    Discrete.functor_obj, whiskerLeft_app, Fan.mk_\u03c0_app, Discrete.opposite_functor_obj_as,\n    Discrete.natIso_inv_app, Iso.refl_inv, Equivalence.invFunIdAssoc_hom_app, Functor.id_obj,\n    Functor.op_map, Discrete.functor_map_id, op_id]\n  simp only [Discrete.functor, Function.comp_apply, id_eq, Discrete.opposite, Equivalence.mk,\n    id_obj, comp_obj, leftOp_obj, unop_op, op_obj, Category.comp_id]", "start": [425, 1], "end": [444, 69], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.desc_op_comp_opCoproductIsoProduct_hom", "code": "lemma desc_op_comp_opCoproductIsoProduct_hom {X : C} (\u03c0 : (a : \u03b1) \u2192 Z a \u27f6 X) :\n    (Sigma.desc \u03c0).op \u226b (opCoproductIsoProduct Z).hom = Pi.lift (fun a => Quiver.Hom.op (\u03c0 a)) := by\n  rw [\u2190 Iso.eq_comp_inv (opCoproductIsoProduct Z)]\n  congr\n  refine' Sigma.hom_ext (f := Z) _ _ (fun a => _)\n  rw [\u2190 Category.assoc, colimit.\u03b9_desc, \u2190 Quiver.Hom.unop_op (Sigma.\u03b9 Z a), \u2190 unop_comp,\n    opCoproductIsoProduct_inv_comp_\u03b9, \u2190 unop_comp]\n  simp only [Cofan.mk_pt, Cofan.mk_\u03b9_app, Pi.lift, Pi.\u03c0, limit.lift_\u03c0, Fan.mk_pt, Fan.mk_\u03c0_app,\n    Quiver.Hom.unop_op]", "start": [446, 1], "end": [454, 24], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.opProductIsoCoproduct", "code": "@[simp]\nnoncomputable\ndef opProductIsoCoproduct : op (\u220f Z) \u2245 \u2210  (fun z => op (Z z)) :=\n  IsColimit.coconePointUniqueUpToIso (isColimitConeOp _ (productIsProduct fun b \u21a6 Z b))\n    (colimit.isColimit _) \u226a\u226b (IsColimit.coconePointsIsoOfEquivalence\n    (coproductIsCoproduct (fun z \u21a6 op (Z z))) (colimit.isColimit _) (Discrete.opposite \u03b1).symm\n    (Discrete.natIsoFunctor \u226a\u226b Discrete.natIso (fun _ \u21a6 by rfl))).symm", "start": [472, 1], "end": [479, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.\u03c0_comp_opProductIsoCoproduct", "code": "lemma \u03c0_comp_opProductIsoCoproduct (b : \u03b1) : (Pi.\u03c0 Z b).op \u226b (opProductIsoCoproduct Z).hom =\n    Sigma.\u03b9 (fun a => op (Z a)) b := by\n  dsimp only [opProductIsoCoproduct]\n  simp only [Iso.trans_hom]\n  have := IsColimit.comp_coconePointUniqueUpToIso_hom\n    (isColimitConeOp _ (productIsProduct Z)) (colimit.isColimit _) (op \u27e8b\u27e9)\n  dsimp at this\n  rw [\u2190 Category.assoc, this]\n  simp only [colimit.cocone_x, Cofan.mk_pt, Equivalence.symm_functor, Discrete.natIsoFunctor,\n    comp_obj, op_obj, Iso.symm_hom, IsColimit.coconePointsIsoOfEquivalence_inv,\n    Equivalence.symm_inverse, Cocones.equivalenceOfReindexing_functor_obj, Iso.trans_inv,\n    Iso.symm_inv, isoWhiskerLeft_hom, Iso.trans_hom, whiskerLeft_comp, colimit.isColimit_desc,\n    colimit.\u03b9_desc, Cocones.precompose_obj_pt, Cocone.whisker_pt, Cocones.precompose_obj_\u03b9,\n    Cocone.whisker_\u03b9, Category.assoc, NatTrans.comp_app, unop_op, Discrete.functor_obj,\n    const_obj_obj, Equivalence.invFunIdAssoc_inv_app, id_obj, op_map, Discrete.functor_map_id,\n    op_id, whiskerLeft_app, Discrete.natIso_hom_app, Iso.refl_hom, Cofan.mk_\u03b9_app,\n    Discrete.opposite_functor_obj_as, Category.id_comp]\n  simp only [Discrete.functor, Function.comp_apply, id_eq, Discrete.opposite, Equivalence.mk,\n    id_obj, comp_obj, leftOp_obj, unop_op, Category.id_comp]", "start": [481, 1], "end": [499, 61], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.opProductIsoCoproduct_inv_comp_\u03c0_op", "code": "lemma opProductIsoCoproduct_inv_comp_\u03c0_op {X : C} (\u03c0 : (a : \u03b1) \u2192 X \u27f6 Z a) :\n    (opProductIsoCoproduct Z).inv \u226b (Pi.lift \u03c0).op = Sigma.desc (fun a => Quiver.Hom.op (\u03c0 a)) := by\n  rw [Iso.inv_comp_eq (opProductIsoCoproduct Z)]\n  congr\n  refine' Pi.hom_ext (f := Z) _ _ (fun a => _)\n  rw [Category.assoc, limit.lift_\u03c0, \u2190 Quiver.Hom.unop_op (Pi.\u03c0 Z a), \u2190 unop_comp,\n    \u03c0_comp_opProductIsoCoproduct, \u2190 unop_comp]\n  simp only [Fan.mk_pt, Fan.mk_\u03c0_app, colimit.\u03b9_desc, Cofan.mk_pt, Cofan.mk_\u03b9_app,\n    Quiver.Hom.unop_op]", "start": [501, 1], "end": [509, 24], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.hasEqualizers_opposite", "code": "instance hasEqualizers_opposite [HasCoequalizers C] : HasEqualizers C\u1d52\u1d56 := by\n  haveI : HasColimitsOfShape WalkingParallelPair\u1d52\u1d56 C :=\n    hasColimitsOfShape_of_equivalence walkingParallelPairOpEquiv\n  infer_instance", "start": [513, 1], "end": [516, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoequalizers_opposite", "code": "instance hasCoequalizers_opposite [HasEqualizers C] : HasCoequalizers C\u1d52\u1d56 := by\n  haveI : HasLimitsOfShape WalkingParallelPair\u1d52\u1d56 C :=\n    hasLimitsOfShape_of_equivalence walkingParallelPairOpEquiv\n  infer_instance", "start": [519, 1], "end": [522, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteColimits_opposite", "code": "instance hasFiniteColimits_opposite [HasFiniteLimits C] : HasFiniteColimits C\u1d52\u1d56 :=\n  \u27e8fun _ _ _ => inferInstance\u27e9", "start": [525, 1], "end": [526, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasFiniteLimits_opposite", "code": "instance hasFiniteLimits_opposite [HasFiniteColimits C] : HasFiniteLimits C\u1d52\u1d56 :=\n  \u27e8fun _ _ _ => inferInstance\u27e9", "start": [529, 1], "end": [530, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPullbacks_opposite", "code": "instance hasPullbacks_opposite [HasPushouts C] : HasPullbacks C\u1d52\u1d56 := by\n  haveI : HasColimitsOfShape WalkingCospan\u1d52\u1d56 C :=\n    hasColimitsOfShape_of_equivalence walkingCospanOpEquiv.symm\n  apply hasLimitsOfShape_op_of_hasColimitsOfShape", "start": [533, 1], "end": [536, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasPushouts_opposite", "code": "instance hasPushouts_opposite [HasPullbacks C] : HasPushouts C\u1d52\u1d56 := by\n  haveI : HasLimitsOfShape WalkingSpan\u1d52\u1d56 C :=\n    hasLimitsOfShape_of_equivalence walkingSpanOpEquiv.symm\n  infer_instance", "start": [539, 1], "end": [542, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.spanOp", "code": "@[simps!]\ndef spanOp {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    span f.op g.op \u2245 walkingCospanOpEquiv.inverse \u22d9 (cospan f g).op :=\n  NatIso.ofComponents (by rintro (_ | _ | _) <;> rfl)\n    (by rintro (_ | _ | _) (_ | _ | _) f <;> cases f <;> aesop_cat)", "start": [545, 1], "end": [550, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.opCospan", "code": "@[simps!]\ndef opCospan {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (cospan f g).op \u2245 walkingCospanOpEquiv.functor \u22d9 span f.op g.op :=\n  calc\n    (cospan f g).op \u2245 \ud835\udfed _ \u22d9 (cospan f g).op := by rfl\n    _ \u2245 (walkingCospanOpEquiv.functor \u22d9 walkingCospanOpEquiv.inverse) \u22d9 (cospan f g).op :=\n      (isoWhiskerRight walkingCospanOpEquiv.unitIso _)\n    _ \u2245 walkingCospanOpEquiv.functor \u22d9 walkingCospanOpEquiv.inverse \u22d9 (cospan f g).op :=\n      (Functor.associator _ _ _)\n    _ \u2245 walkingCospanOpEquiv.functor \u22d9 span f.op g.op := isoWhiskerLeft _ (spanOp f g).symm", "start": [553, 1], "end": [563, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.cospanOp", "code": "@[simps!]\ndef cospanOp {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) :\n    cospan f.op g.op \u2245 walkingSpanOpEquiv.inverse \u22d9 (span f g).op :=\n  NatIso.ofComponents (by rintro (_ | _ | _) <;> rfl)\n    (by rintro (_ | _ | _) (_ | _ | _) f <;> cases f <;> aesop_cat)", "start": [566, 1], "end": [571, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.opSpan", "code": "@[simps!]\ndef opSpan {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) :\n    (span f g).op \u2245 walkingSpanOpEquiv.functor \u22d9 cospan f.op g.op :=\n  calc\n    (span f g).op \u2245 \ud835\udfed _ \u22d9 (span f g).op := by rfl\n    _ \u2245 (walkingSpanOpEquiv.functor \u22d9 walkingSpanOpEquiv.inverse) \u22d9 (span f g).op :=\n      (isoWhiskerRight walkingSpanOpEquiv.unitIso _)\n    _ \u2245 walkingSpanOpEquiv.functor \u22d9 walkingSpanOpEquiv.inverse \u22d9 (span f g).op :=\n      (Functor.associator _ _ _)\n    _ \u2245 walkingSpanOpEquiv.functor \u22d9 cospan f.op g.op := isoWhiskerLeft _ (cospanOp f g).symm", "start": [574, 1], "end": [584, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.unop", "code": "@[simps!]\ndef unop {X Y Z : C\u1d52\u1d56} {f : X \u27f6 Y} {g : X \u27f6 Z} (c : PushoutCocone f g) :\n    PullbackCone f.unop g.unop :=\n  Cocone.unop\n    ((Cocones.precompose (opCospan f.unop g.unop).hom).obj\n      (Cocone.whisker walkingCospanOpEquiv.functor c))", "start": [590, 1], "end": [596, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.unop_fst", "code": "theorem unop_fst {X Y Z : C\u1d52\u1d56} {f : X \u27f6 Y} {g : X \u27f6 Z} (c : PushoutCocone f g) :\n    c.unop.fst = c.inl.unop", "start": [600, 1], "end": [601, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.unop_snd", "code": "theorem unop_snd {X Y Z : C\u1d52\u1d56} {f : X \u27f6 Y} {g : X \u27f6 Z} (c : PushoutCocone f g) :\n    c.unop.snd = c.inr.unop", "start": [605, 1], "end": [606, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.op", "code": "@[simps!]\ndef op {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} (c : PushoutCocone f g) : PullbackCone f.op g.op :=\n  (Cones.postcompose (cospanOp f g).symm.hom).obj\n    (Cone.whisker walkingSpanOpEquiv.inverse (Cocone.op c))", "start": [610, 1], "end": [614, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.op_fst", "code": "theorem op_fst {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} (c : PushoutCocone f g) : c.op.fst = c.inl.op", "start": [618, 1], "end": [619, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.op_snd", "code": "theorem op_snd {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} (c : PushoutCocone f g) : c.op.snd = c.inr.op", "start": [623, 1], "end": [624, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.unop", "code": "@[simps!]\ndef unop {X Y Z : C\u1d52\u1d56} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) :\n    PushoutCocone f.unop g.unop :=\n  Cone.unop\n    ((Cones.postcompose (opSpan f.unop g.unop).symm.hom).obj\n      (Cone.whisker walkingSpanOpEquiv.functor c))", "start": [632, 1], "end": [638, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.unop_inl", "code": "theorem unop_inl {X Y Z : C\u1d52\u1d56} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) :\n    c.unop.inl = c.fst.unop", "start": [642, 1], "end": [643, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.unop_inr", "code": "theorem unop_inr {X Y Z : C\u1d52\u1d56} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) :\n    c.unop.inr = c.snd.unop", "start": [647, 1], "end": [648, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.op", "code": "@[simps!]\ndef op {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) : PushoutCocone f.op g.op :=\n  (Cocones.precompose (spanOp f g).hom).obj\n    (Cocone.whisker walkingCospanOpEquiv.inverse (Cone.op c))", "start": [651, 1], "end": [655, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.op_inl", "code": "theorem op_inl {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) : c.op.inl = c.fst.op", "start": [659, 1], "end": [660, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.op_inr", "code": "theorem op_inr {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) : c.op.inr = c.snd.op", "start": [664, 1], "end": [665, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.opUnop", "code": "def opUnop {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) : c.op.unop \u2245 c :=\n  PullbackCone.ext (Iso.refl _) (by simp) (by simp)", "start": [668, 1], "end": [670, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.unopOp", "code": "def unopOp {X Y Z : C\u1d52\u1d56} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) : c.unop.op \u2245 c :=\n  PullbackCone.ext (Iso.refl _) (by simp) (by simp)", "start": [673, 1], "end": [675, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.opUnop", "code": "def opUnop {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} (c : PushoutCocone f g) : c.op.unop \u2245 c :=\n  PushoutCocone.ext (Iso.refl _) (by simp) (by simp)", "start": [682, 1], "end": [684, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.unopOp", "code": "def unopOp {X Y Z : C\u1d52\u1d56} {f : X \u27f6 Y} {g : X \u27f6 Z} (c : PushoutCocone f g) : c.unop.op \u2245 c :=\n  PushoutCocone.ext (Iso.refl _) (by simp) (by simp)", "start": [687, 1], "end": [689, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.isColimitEquivIsLimitOp", "code": "def isColimitEquivIsLimitOp {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} (c : PushoutCocone f g) :\n    IsColimit c \u2243 IsLimit c.op := by\n  apply equivOfSubsingletonOfSubsingleton\n  \u00b7 intro h\n    exact (IsLimit.postcomposeHomEquiv _ _).invFun\n      ((IsLimit.whiskerEquivalenceEquiv walkingSpanOpEquiv.symm).toFun (isLimitCoconeOp _ h))\n  \u00b7 intro h\n    exact (IsColimit.equivIsoColimit c.opUnop).toFun\n      (isColimitConeUnop _ ((IsLimit.postcomposeHomEquiv _ _).invFun\n        ((IsLimit.whiskerEquivalenceEquiv _).toFun h)))", "start": [692, 1], "end": [703, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PushoutCocone.isColimitEquivIsLimitUnop", "code": "def isColimitEquivIsLimitUnop {X Y Z : C\u1d52\u1d56} {f : X \u27f6 Y} {g : X \u27f6 Z} (c : PushoutCocone f g) :\n    IsColimit c \u2243 IsLimit c.unop := by\n  apply equivOfSubsingletonOfSubsingleton\n  \u00b7 intro h\n    exact isLimitCoconeUnop _ ((IsColimit.precomposeHomEquiv _ _).invFun\n      ((IsColimit.whiskerEquivalenceEquiv _).toFun h))\n  \u00b7 intro h\n    exact (IsColimit.equivIsoColimit c.unopOp).toFun\n      ((IsColimit.precomposeHomEquiv _ _).invFun\n      ((IsColimit.whiskerEquivalenceEquiv walkingCospanOpEquiv.symm).toFun (isColimitConeOp _ h)))", "start": [706, 1], "end": [717, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.isLimitEquivIsColimitOp", "code": "def isLimitEquivIsColimitOp {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) :\n    IsLimit c \u2243 IsColimit c.op :=\n  (IsLimit.equivIsoLimit c.opUnop).symm.trans c.op.isColimitEquivIsLimitUnop.symm", "start": [724, 1], "end": [728, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PullbackCone.isLimitEquivIsColimitUnop", "code": "def isLimitEquivIsColimitUnop {X Y Z : C\u1d52\u1d56} {f : X \u27f6 Z} {g : Y \u27f6 Z} (c : PullbackCone f g) :\n    IsLimit c \u2243 IsColimit c.unop :=\n  (IsLimit.equivIsoLimit c.unopOp).symm.trans c.unop.isColimitEquivIsLimitOp.symm", "start": [731, 1], "end": [735, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackIsoUnopPushout", "code": "noncomputable def pullbackIsoUnopPushout {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) [h : HasPullback f g]\n    [HasPushout f.op g.op] : pullback f g \u2245 unop (pushout f.op g.op) :=\n  IsLimit.conePointUniqueUpToIso (@limit.isLimit _ _ _ _ _ h)\n    ((PushoutCocone.isColimitEquivIsLimitUnop _) (colimit.isColimit (span f.op g.op)))", "start": [744, 1], "end": [749, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackIsoUnopPushout_inv_fst", "code": "@[reassoc (attr := simp)]\ntheorem pullbackIsoUnopPushout_inv_fst {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) [HasPullback f g]\n    [HasPushout f.op g.op] :\n    (pullbackIsoUnopPushout f g).inv \u226b pullback.fst = (pushout.inl : _ \u27f6 pushout f.op g.op).unop", "start": [752, 1], "end": [756, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackIsoUnopPushout_inv_snd", "code": "@[reassoc (attr := simp)]\ntheorem pullbackIsoUnopPushout_inv_snd {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) [HasPullback f g]\n    [HasPushout f.op g.op] :\n    (pullbackIsoUnopPushout f g).inv \u226b pullback.snd = (pushout.inr : _ \u27f6 pushout f.op g.op).unop", "start": [759, 1], "end": [763, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackIsoUnopPushout_hom_inl", "code": "@[reassoc (attr := simp)]\ntheorem pullbackIsoUnopPushout_hom_inl {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) [HasPullback f g]\n    [HasPushout f.op g.op] :\n    pushout.inl \u226b (pullbackIsoUnopPushout f g).hom.op = pullback.fst.op", "start": [766, 1], "end": [772, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pullbackIsoUnopPushout_hom_inr", "code": "@[reassoc (attr := simp)]\ntheorem pullbackIsoUnopPushout_hom_inr {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) [HasPullback f g]\n    [HasPushout f.op g.op] : pushout.inr \u226b (pullbackIsoUnopPushout f g).hom.op =\n    pullback.snd.op", "start": [775, 1], "end": [781, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutIsoUnopPullback", "code": "noncomputable def pushoutIsoUnopPullback {X Y Z : C} (f : X \u27f6 Z) (g : X \u27f6 Y) [h : HasPushout f g]\n    [HasPullback f.op g.op] : pushout f g \u2245 unop (pullback f.op g.op) :=\n  IsColimit.coconePointUniqueUpToIso (@colimit.isColimit _ _ _ _ _ h)\n    ((PullbackCone.isLimitEquivIsColimitUnop _) (limit.isLimit (cospan f.op g.op)))", "start": [788, 1], "end": [793, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutIsoUnopPullback_inl_hom", "code": "@[reassoc (attr := simp)]\ntheorem pushoutIsoUnopPullback_inl_hom {X Y Z : C} (f : X \u27f6 Z) (g : X \u27f6 Y) [HasPushout f g]\n    [HasPullback f.op g.op] :\n    pushout.inl \u226b (pushoutIsoUnopPullback f g).hom =\n      (pullback.fst : pullback f.op g.op \u27f6 _).unop", "start": [796, 1], "end": [801, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutIsoUnopPullback_inr_hom", "code": "@[reassoc (attr := simp)]\ntheorem pushoutIsoUnopPullback_inr_hom {X Y Z : C} (f : X \u27f6 Z) (g : X \u27f6 Y) [HasPushout f g]\n    [HasPullback f.op g.op] :\n    pushout.inr \u226b (pushoutIsoUnopPullback f g).hom =\n      (pullback.snd : pullback f.op g.op \u27f6 _).unop", "start": [804, 1], "end": [809, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutIsoUnopPullback_inv_fst", "code": "@[simp]\ntheorem pushoutIsoUnopPullback_inv_fst {X Y Z : C} (f : X \u27f6 Z) (g : X \u27f6 Y) [HasPushout f g]\n    [HasPullback f.op g.op] :\n    (pushoutIsoUnopPullback f g).inv.op \u226b pullback.fst = pushout.inl.op", "start": [812, 1], "end": [818, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.pushoutIsoUnopPullback_inv_snd", "code": "@[simp]\ntheorem pushoutIsoUnopPullback_inv_snd {X Y Z : C} (f : X \u27f6 Z) (g : X \u27f6 Y) [HasPushout f g]\n    [HasPullback f.op g.op] :\n    (pushoutIsoUnopPullback f g).inv.op \u226b pullback.snd = pushout.inr.op", "start": [821, 1], "end": [827, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.IsColimit.of\u03c0Op", "code": "def CokernelCofork.IsColimit.of\u03c0Op {X Y Q : C} (p : Y \u27f6 Q) {f : X \u27f6 Y}\n    (w : f \u226b p = 0) (h : IsColimit (CokernelCofork.of\u03c0 p w)) :\n    IsLimit (KernelFork.of\u03b9 p.op (show p.op \u226b f.op = 0 by rw [\u2190 op_comp, w, op_zero])) :=\n  KernelFork.IsLimit.of\u03b9 _ _\n    (fun x hx => (h.desc (CokernelCofork.of\u03c0 x.unop (Quiver.Hom.op_inj hx))).op)\n    (fun x hx => Quiver.Hom.unop_inj (Cofork.IsColimit.\u03c0_desc h))\n    (fun x hx b hb => Quiver.Hom.unop_inj (Cofork.IsColimit.hom_ext h\n      (by simpa only [Quiver.Hom.unop_op, Cofork.IsColimit.\u03c0_desc] using Quiver.Hom.op_inj hb)))", "start": [836, 1], "end": [844, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.IsColimit.of\u03c0Unop", "code": "def CokernelCofork.IsColimit.of\u03c0Unop {X Y Q : C\u1d52\u1d56} (p : Y \u27f6 Q) {f : X \u27f6 Y}\n    (w : f \u226b p = 0) (h : IsColimit (CokernelCofork.of\u03c0 p w)) :\n    IsLimit (KernelFork.of\u03b9 p.unop (show p.unop \u226b f.unop = 0 by rw [\u2190 unop_comp, w, unop_zero])) :=\n  KernelFork.IsLimit.of\u03b9 _ _\n    (fun x hx => (h.desc (CokernelCofork.of\u03c0 x.op (Quiver.Hom.unop_inj hx))).unop)\n    (fun x hx => Quiver.Hom.op_inj (Cofork.IsColimit.\u03c0_desc h))\n    (fun x hx b hb => Quiver.Hom.op_inj (Cofork.IsColimit.hom_ext h\n      (by simpa only [Quiver.Hom.op_unop, Cofork.IsColimit.\u03c0_desc] using Quiver.Hom.unop_inj hb)))", "start": [846, 1], "end": [855, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.KernelFork.IsLimit.of\u03b9Op", "code": "def KernelFork.IsLimit.of\u03b9Op {K X Y : C} (i : K \u27f6 X) {f : X \u27f6 Y}\n    (w : i \u226b f = 0) (h : IsLimit (KernelFork.of\u03b9 i w)) :\n    IsColimit (CokernelCofork.of\u03c0 i.op\n      (show f.op \u226b i.op = 0 by rw [\u2190 op_comp, w, op_zero])) :=\n  CokernelCofork.IsColimit.of\u03c0 _ _\n    (fun x hx => (h.lift (KernelFork.of\u03b9 x.unop (Quiver.Hom.op_inj hx))).op)\n    (fun x hx => Quiver.Hom.unop_inj (Fork.IsLimit.lift_\u03b9 h))\n    (fun x hx b hb => Quiver.Hom.unop_inj (Fork.IsLimit.hom_ext h (by\n      simpa only [Quiver.Hom.unop_op, Fork.IsLimit.lift_\u03b9] using Quiver.Hom.op_inj hb)))", "start": [857, 1], "end": [866, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.KernelFork.IsLimit.of\u03b9Unop", "code": "def KernelFork.IsLimit.of\u03b9Unop {K X Y : C\u1d52\u1d56} (i : K \u27f6 X) {f : X \u27f6 Y}\n    (w : i \u226b f = 0) (h : IsLimit (KernelFork.of\u03b9 i w)) :\n    IsColimit (CokernelCofork.of\u03c0 i.unop\n      (show f.unop \u226b i.unop = 0 by rw [\u2190 unop_comp, w, unop_zero])) :=\n  CokernelCofork.IsColimit.of\u03c0 _ _\n    (fun x hx => (h.lift (KernelFork.of\u03b9 x.op (Quiver.Hom.unop_inj hx))).unop)\n    (fun x hx => Quiver.Hom.op_inj (Fork.IsLimit.lift_\u03b9 h))\n    (fun x hx b hb => Quiver.Hom.op_inj (Fork.IsLimit.hom_ext h (by\n      simpa only [Quiver.Hom.op_unop, Fork.IsLimit.lift_\u03b9] using Quiver.Hom.unop_inj hb)))", "start": [868, 1], "end": [878, 91], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Kernels.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Zero.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.KernelFork.map_condition", "code": "@[reassoc (attr := simp)]\nlemma map_condition : G.map c.\u03b9 \u226b G.map f = 0 := by\n  rw [\u2190 G.map_comp, c.condition, G.map_zero]", "start": [39, 1], "end": [41, 45], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.KernelFork.map", "code": "def map : KernelFork (G.map f) :=\n  KernelFork.of\u03b9 (G.map c.\u03b9) (c.map_condition G)", "start": [43, 1], "end": [46, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.KernelFork.map_\u03b9", "code": "@[simp]\nlemma map_\u03b9 : (c.map G).\u03b9 = G.map c.\u03b9 := rfl", "start": [48, 1], "end": [49, 45], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.KernelFork.isLimitMapConeEquiv", "code": "def isLimitMapConeEquiv :\n    IsLimit (G.mapCone c) \u2243 IsLimit (c.map G) := by\n  refine' (IsLimit.postcomposeHomEquiv _ _).symm.trans (IsLimit.equivIsoLimit _)\n  refine' parallelPair.ext (Iso.refl _) (Iso.refl _) _ _ <;> simp\n  exact Cones.ext (Iso.refl _) (by rintro (_|_) <;> aesop_cat)", "start": [51, 1], "end": [57, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.KernelFork.mapIsLimit", "code": "def mapIsLimit (hc : IsLimit c) (G : C \u2964 D)\n    [Functor.PreservesZeroMorphisms G] [PreservesLimit (parallelPair f 0) G] :\n    IsLimit (c.map G) :=\n  c.isLimitMapConeEquiv G (isLimitOfPreserves G hc)", "start": [59, 1], "end": [64, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitMapConeForkEquiv'", "code": "def isLimitMapConeForkEquiv' :\n    IsLimit (G.mapCone (KernelFork.of\u03b9 h w)) \u2243\n      IsLimit\n        (KernelFork.of\u03b9 (G.map h) (by simp only [\u2190 G.map_comp, w, Functor.map_zero]) :\n          Fork (G.map f) 0) :=\n  KernelFork.isLimitMapConeEquiv _ _", "start": [73, 1], "end": [85, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitForkMapOfIsLimit'", "code": "def isLimitForkMapOfIsLimit' [PreservesLimit (parallelPair f 0) G]\n    (l : IsLimit (KernelFork.of\u03b9 h w)) :\n    IsLimit\n      (KernelFork.of\u03b9 (G.map h) (by simp only [\u2190 G.map_comp, w, Functor.map_zero]) :\n        Fork (G.map f) 0) :=\n  isLimitMapConeForkEquiv' G w (PreservesLimit.preserves l)", "start": [88, 1], "end": [98, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isLimitOfHasKernelOfPreservesLimit", "code": "def isLimitOfHasKernelOfPreservesLimit [PreservesLimit (parallelPair f 0) G] :\n    IsLimit\n      (Fork.of\u03b9 (G.map (kernel.\u03b9 f))\n          (by simp only [\u2190 G.map_comp, kernel.condition, comp_zero, Functor.map_zero]) :\n        Fork (G.map f) 0) :=\n  isLimitForkMapOfIsLimit' G (kernel.condition f) (kernelIsKernel f)", "start": [103, 1], "end": [111, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesKernel.ofIsoComparison", "code": "def PreservesKernel.ofIsoComparison [i : IsIso (kernelComparison f G)] :\n    PreservesLimit (parallelPair f 0) G := by\n  apply preservesLimitOfPreservesLimitCone (kernelIsKernel f)\n  apply (isLimitMapConeForkEquiv' G (kernel.condition f)).symm _\n  exact @IsLimit.ofPointIso _ _ _ _ _ _ _ (kernelIsKernel (G.map f)) i", "start": [119, 1], "end": [126, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesKernel.iso", "code": "def PreservesKernel.iso : G.obj (kernel f) \u2245 kernel (G.map f) :=\n  IsLimit.conePointUniqueUpToIso (isLimitOfHasKernelOfPreservesLimit G f) (limit.isLimit _)", "start": [131, 1], "end": [135, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesKernel.iso_hom", "code": "@[simp]\ntheorem PreservesKernel.iso_hom : (PreservesKernel.iso G f).hom = kernelComparison f G", "start": [138, 1], "end": [141, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.kernel_map_comp_preserves_kernel_iso_inv", "code": "@[reassoc]\ntheorem kernel_map_comp_preserves_kernel_iso_inv {X' Y' : C} (g : X' \u27f6 Y') [HasKernel g]\n    [HasKernel (G.map g)] [PreservesLimit (parallelPair g 0) G] (p : X \u27f6 X') (q : Y \u27f6 Y')\n    (hpq : f \u226b q = p \u226b g) :\n    kernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [\u2190 G.map_comp, hpq, G.map_comp]) \u226b\n        (PreservesKernel.iso G _).inv =\n      (PreservesKernel.iso G _).inv \u226b G.map (kernel.map f g p q hpq)", "start": [148, 1], "end": [156, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.map_condition", "code": "@[reassoc (attr := simp)]\nlemma map_condition : G.map f \u226b G.map c.\u03c0 = 0 := by\n  rw [\u2190 G.map_comp, c.condition, G.map_zero]", "start": [166, 1], "end": [168, 45], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.map", "code": "def map : CokernelCofork (G.map f) :=\n  CokernelCofork.of\u03c0 (G.map c.\u03c0) (c.map_condition G)", "start": [170, 1], "end": [173, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.map_\u03c0", "code": "@[simp]\nlemma map_\u03c0 : (c.map G).\u03c0 = G.map c.\u03c0 := rfl", "start": [175, 1], "end": [176, 45], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.isColimitMapCoconeEquiv", "code": "def isColimitMapCoconeEquiv :\n    IsColimit (G.mapCocone c) \u2243 IsColimit (c.map G) := by\n  refine' (IsColimit.precomposeHomEquiv _ _).symm.trans (IsColimit.equivIsoColimit _)\n  refine' parallelPair.ext (Iso.refl _) (Iso.refl _) _ _ <;> simp\n  exact Cocones.ext (Iso.refl _) (by rintro (_|_) <;> aesop_cat)", "start": [178, 1], "end": [184, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CokernelCofork.mapIsColimit", "code": "def mapIsColimit  (hc : IsColimit c) (G : C \u2964 D)\n    [Functor.PreservesZeroMorphisms G] [PreservesColimit (parallelPair f 0) G] :\n    IsColimit (c.map G) :=\n  c.isColimitMapCoconeEquiv G (isColimitOfPreserves G hc)", "start": [186, 1], "end": [191, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitMapCoconeCoforkEquiv'", "code": "def isColimitMapCoconeCoforkEquiv' :\n    IsColimit (G.mapCocone (CokernelCofork.of\u03c0 h w)) \u2243\n      IsColimit\n        (CokernelCofork.of\u03c0 (G.map h) (by simp only [\u2190 G.map_comp, w, Functor.map_zero]) :\n          Cofork (G.map f) 0) :=\n  CokernelCofork.isColimitMapCoconeEquiv _ _", "start": [200, 1], "end": [212, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitCoforkMapOfIsColimit'", "code": "def isColimitCoforkMapOfIsColimit' [PreservesColimit (parallelPair f 0) G]\n    (l : IsColimit (CokernelCofork.of\u03c0 h w)) :\n    IsColimit\n      (CokernelCofork.of\u03c0 (G.map h) (by simp only [\u2190 G.map_comp, w, Functor.map_zero]) :\n        Cofork (G.map f) 0) :=\n  isColimitMapCoconeCoforkEquiv' G w (PreservesColimit.preserves l)", "start": [215, 1], "end": [225, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.isColimitOfHasCokernelOfPreservesColimit", "code": "def isColimitOfHasCokernelOfPreservesColimit [PreservesColimit (parallelPair f 0) G] :\n    IsColimit\n      (Cofork.of\u03c0 (G.map (cokernel.\u03c0 f))\n          (by simp only [\u2190 G.map_comp, cokernel.condition, zero_comp, Functor.map_zero]) :\n        Cofork (G.map f) 0) :=\n  isColimitCoforkMapOfIsColimit' G (cokernel.condition f) (cokernelIsCokernel f)", "start": [230, 1], "end": [239, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesCokernel.ofIsoComparison", "code": "def PreservesCokernel.ofIsoComparison [i : IsIso (cokernelComparison f G)] :\n    PreservesColimit (parallelPair f 0) G := by\n  apply preservesColimitOfPreservesColimitCocone (cokernelIsCokernel f)\n  apply (isColimitMapCoconeCoforkEquiv' G (cokernel.condition f)).symm _\n  exact @IsColimit.ofPointIso _ _ _ _ _ _ _ (cokernelIsCokernel (G.map f)) i", "start": [247, 1], "end": [254, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesCokernel.iso", "code": "def PreservesCokernel.iso : G.obj (cokernel f) \u2245 cokernel (G.map f) :=\n  IsColimit.coconePointUniqueUpToIso (isColimitOfHasCokernelOfPreservesColimit G f)\n    (colimit.isColimit _)", "start": [259, 1], "end": [264, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.PreservesCokernel.iso_inv", "code": "@[simp]\ntheorem PreservesCokernel.iso_inv : (PreservesCokernel.iso G f).inv = cokernelComparison f G", "start": [267, 1], "end": [270, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preserves_cokernel_iso_comp_cokernel_map", "code": "@[reassoc]\ntheorem preserves_cokernel_iso_comp_cokernel_map {X' Y' : C} (g : X' \u27f6 Y') [HasCokernel g]\n    [HasCokernel (G.map g)] [PreservesColimit (parallelPair g 0) G] (p : X \u27f6 X') (q : Y \u27f6 Y')\n    (hpq : f \u226b q = p \u226b g) :\n    (PreservesCokernel.iso G _).hom \u226b\n        cokernel.map (G.map f) (G.map g) (G.map p) (G.map q)\n          (by rw [\u2190 G.map_comp, hpq, G.map_comp]) =\n      G.map (cokernel.map f g p q hpq) \u226b (PreservesCokernel.iso G _).hom", "start": [277, 1], "end": [286, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesKernelZero", "code": "noncomputable instance preservesKernelZero :\n    PreservesLimit (parallelPair (0 : X \u27f6 Y) 0) G where\n  preserves {c} hc := by\n    have := KernelFork.IsLimit.isIso_\u03b9 c hc rfl\n    refine' (KernelFork.isLimitMapConeEquiv c G).symm _\n    refine' IsLimit.ofIsoLimit (KernelFork.IsLimit.ofId _ (G.map_zero _ _)) _\n    exact (Fork.ext (G.mapIso (asIso (Fork.\u03b9 c))).symm (by simp))", "start": [293, 1], "end": [299, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesCokernelZero", "code": "noncomputable instance preservesCokernelZero :\n    PreservesColimit (parallelPair (0 : X \u27f6 Y) 0) G where\n  preserves {c} hc := by\n    have := CokernelCofork.IsColimit.isIso_\u03c0 c hc rfl\n    refine' (CokernelCofork.isColimitMapCoconeEquiv c G).symm _\n    refine' IsColimit.ofIsoColimit (CokernelCofork.IsColimit.ofId _ (G.map_zero _ _)) _\n    exact (Cofork.ext (G.mapIso (asIso (Cofork.\u03c0 c))) (by simp))", "start": [301, 1], "end": [307, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesKernelZero'", "code": "noncomputable def preservesKernelZero' (f : X \u27f6 Y) (hf : f = 0) :\n    PreservesLimit (parallelPair f 0) G := by\n  rw [hf]\n  infer_instance", "start": [311, 1], "end": [315, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.preservesCokernelZero'", "code": "noncomputable def preservesCokernelZero' (f : X \u27f6 Y) (hf : f = 0) :\n    PreservesColimit (parallelPair f 0) G := by\n  rw [hf]\n  infer_instance", "start": [317, 1], "end": [321, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/CategoryTheory/Coherence.lean", "imports": ["Mathlib/Tactic/CategoryTheory/BicategoryCoherence.lean", "Mathlib/CategoryTheory/Monoidal/Free/Coherence.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.Coherence.LiftObj", "code": "class LiftObj (X : C) where\n  protected lift : FreeMonoidalCategory C", "start": [47, 1], "end": [50, 42], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.LiftObj_unit", "code": "instance LiftObj_unit : LiftObj (\ud835\udfd9_ C) := \u27e8Unit\u27e9", "start": [52, 1], "end": [52, 49], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.LiftObj_tensor", "code": "instance LiftObj_tensor (X Y : C) [LiftObj X] [LiftObj Y] : LiftObj (X \u2297 Y) where\n  lift := LiftObj.lift X \u2297 LiftObj.lift Y", "start": [54, 1], "end": [55, 42], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.LiftObj_of", "code": "instance (priority := 100) LiftObj_of (X : C) : LiftObj X := \u27e8of X\u27e9", "start": [57, 1], "end": [57, 68], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.LiftHom", "code": "class LiftHom {X Y : C} [LiftObj X] [LiftObj Y] (f : X \u27f6 Y) where\n  protected lift : LiftObj.lift X \u27f6 LiftObj.lift Y", "start": [59, 1], "end": [62, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.LiftHom_id", "code": "instance LiftHom_id (X : C) [LiftObj X] : LiftHom (\ud835\udfd9 X) := \u27e8\ud835\udfd9 _\u27e9", "start": [64, 1], "end": [64, 65], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.LiftHom_left_unitor_hom", "code": "instance LiftHom_left_unitor_hom (X : C) [LiftObj X] : LiftHom (\u03bb_ X).hom where\n  lift := (\u03bb_ (LiftObj.lift X)).hom", "start": [66, 1], "end": [67, 36], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.LiftHom_left_unitor_inv", "code": "instance LiftHom_left_unitor_inv (X : C) [LiftObj X] : LiftHom (\u03bb_ X).inv where\n  lift := (\u03bb_ (LiftObj.lift X)).inv", "start": [69, 1], "end": [70, 36], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.LiftHom_right_unitor_hom", "code": "instance LiftHom_right_unitor_hom (X : C) [LiftObj X] : LiftHom (\u03c1_ X).hom where\n  lift := (\u03c1_ (LiftObj.lift X)).hom", "start": [72, 1], "end": [73, 36], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.LiftHom_right_unitor_inv", "code": "instance LiftHom_right_unitor_inv (X : C) [LiftObj X] : LiftHom (\u03c1_ X).inv where\n  lift := (\u03c1_ (LiftObj.lift X)).inv", "start": [75, 1], "end": [76, 36], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.LiftHom_associator_hom", "code": "instance LiftHom_associator_hom (X Y Z : C) [LiftObj X] [LiftObj Y] [LiftObj Z] :\n    LiftHom (\u03b1_ X Y Z).hom where\n  lift := (\u03b1_ (LiftObj.lift X) (LiftObj.lift Y) (LiftObj.lift Z)).hom", "start": [78, 1], "end": [80, 70], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.LiftHom_associator_inv", "code": "instance LiftHom_associator_inv (X Y Z : C) [LiftObj X] [LiftObj Y] [LiftObj Z] :\n    LiftHom (\u03b1_ X Y Z).inv where\n  lift := (\u03b1_ (LiftObj.lift X) (LiftObj.lift Y) (LiftObj.lift Z)).inv", "start": [82, 1], "end": [84, 70], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.LiftHom_comp", "code": "instance LiftHom_comp {X Y Z : C} [LiftObj X] [LiftObj Y] [LiftObj Z] (f : X \u27f6 Y) (g : Y \u27f6 Z)\n    [LiftHom f] [LiftHom g] : LiftHom (f \u226b g) where\n  lift := LiftHom.lift f \u226b LiftHom.lift g", "start": [86, 1], "end": [88, 42], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.LiftHom_tensor", "code": "instance LiftHom_tensor {W X Y Z : C} [LiftObj W] [LiftObj X] [LiftObj Y] [LiftObj Z]\n    (f : W \u27f6 X) (g : Y \u27f6 Z) [LiftHom f] [LiftHom g] : LiftHom (f \u2297 g) where\n  lift := LiftHom.lift f \u2297 LiftHom.lift g", "start": [90, 1], "end": [92, 42], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.MonoidalCoherence", "code": "class MonoidalCoherence (X Y : C) [LiftObj X] [LiftObj Y] where\n  hom : X \u27f6 Y\n  [isIso : IsIso hom]", "start": [94, 1], "end": [101, 22], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.MonoidalCoherence.refl", "code": "@[simps]\ninstance refl (X : C) [LiftObj X] : MonoidalCoherence X X := \u27e8\ud835\udfd9 _\u27e9", "start": [107, 1], "end": [108, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.MonoidalCoherence.tensor", "code": "@[simps]\ninstance tensor (X Y Z : C) [LiftObj X] [LiftObj Y] [LiftObj Z] [MonoidalCoherence Y Z] :\n    MonoidalCoherence (X \u2297 Y) (X \u2297 Z) :=\n  \u27e8\ud835\udfd9 X \u2297 MonoidalCoherence.hom\u27e9", "start": [110, 1], "end": [113, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.MonoidalCoherence.tensor_right", "code": "@[simps]\ninstance tensor_right (X Y : C) [LiftObj X] [LiftObj Y] [MonoidalCoherence (\ud835\udfd9_ C) Y] :\n    MonoidalCoherence X (X \u2297 Y) :=\n  \u27e8(\u03c1_ X).inv \u226b (\ud835\udfd9 X \u2297 MonoidalCoherence.hom)\u27e9", "start": [115, 1], "end": [118, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.MonoidalCoherence.tensor_right'", "code": "@[simps]\ninstance tensor_right' (X Y : C) [LiftObj X] [LiftObj Y] [MonoidalCoherence Y (\ud835\udfd9_ C)] :\n    MonoidalCoherence (X \u2297 Y) X :=\n  \u27e8(\ud835\udfd9 X \u2297 MonoidalCoherence.hom) \u226b (\u03c1_ X).hom\u27e9", "start": [120, 1], "end": [123, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.MonoidalCoherence.left", "code": "@[simps]\ninstance left (X Y : C) [LiftObj X] [LiftObj Y] [MonoidalCoherence X Y] :\n    MonoidalCoherence (\ud835\udfd9_ C \u2297 X) Y :=\n  \u27e8(\u03bb_ X).hom \u226b MonoidalCoherence.hom\u27e9", "start": [125, 1], "end": [128, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.MonoidalCoherence.left'", "code": "@[simps]\ninstance left' (X Y : C) [LiftObj X] [LiftObj Y] [MonoidalCoherence X Y] :\n    MonoidalCoherence X (\ud835\udfd9_ C \u2297 Y) :=\n  \u27e8MonoidalCoherence.hom \u226b (\u03bb_ Y).inv\u27e9", "start": [130, 1], "end": [133, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.MonoidalCoherence.right", "code": "@[simps]\ninstance right (X Y : C) [LiftObj X] [LiftObj Y] [MonoidalCoherence X Y] :\n    MonoidalCoherence (X \u2297 \ud835\udfd9_ C) Y :=\n  \u27e8(\u03c1_ X).hom \u226b MonoidalCoherence.hom\u27e9", "start": [135, 1], "end": [138, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.MonoidalCoherence.right'", "code": "@[simps]\ninstance right' (X Y : C) [LiftObj X] [LiftObj Y] [MonoidalCoherence X Y] :\n    MonoidalCoherence X (Y \u2297 \ud835\udfd9_ C) :=\n  \u27e8MonoidalCoherence.hom \u226b (\u03c1_ Y).inv\u27e9", "start": [140, 1], "end": [143, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.MonoidalCoherence.assoc", "code": "@[simps]\ninstance assoc (X Y Z W : C) [LiftObj W] [LiftObj X] [LiftObj Y] [LiftObj Z]\n    [MonoidalCoherence (X \u2297 (Y \u2297 Z)) W] : MonoidalCoherence ((X \u2297 Y) \u2297 Z) W :=\n  \u27e8(\u03b1_ X Y Z).hom \u226b MonoidalCoherence.hom\u27e9", "start": [145, 1], "end": [148, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.MonoidalCoherence.assoc'", "code": "@[simps]\ninstance assoc' (W X Y Z : C) [LiftObj W] [LiftObj X] [LiftObj Y] [LiftObj Z]\n    [MonoidalCoherence W (X \u2297 (Y \u2297 Z))] : MonoidalCoherence W ((X \u2297 Y) \u2297 Z) :=\n  \u27e8MonoidalCoherence.hom \u226b (\u03b1_ X Y Z).inv\u27e9", "start": [150, 1], "end": [153, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.monoidalIso", "code": "def monoidalIso (X Y : C) [LiftObj X] [LiftObj Y] [MonoidalCoherence X Y] : X \u2245 Y :=\n  asIso MonoidalCoherence.hom", "start": [157, 1], "end": [160, 30], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.monoidalComp", "code": "def monoidalComp {W X Y Z : C} [LiftObj X] [LiftObj Y]\n    [MonoidalCoherence X Y] (f : W \u27f6 X) (g : Y \u27f6 Z) : W \u27f6 Z :=\n  f \u226b MonoidalCoherence.hom \u226b g", "start": [169, 1], "end": [173, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.monoidalIsoComp", "code": "noncomputable def monoidalIsoComp {W X Y Z : C} [LiftObj X] [LiftObj Y]\n    [MonoidalCoherence X Y] (f : W \u2245 X) (g : Y \u2245 Z) : W \u2245 Z :=\n  f \u226a\u226b asIso MonoidalCoherence.hom \u226a\u226b g", "start": [179, 1], "end": [183, 40], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.monoidalComp_refl", "code": "@[simp] lemma monoidalComp_refl {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    f \u2297\u226b g = f \u226b g := by\n  simp [monoidalComp]", "start": [195, 1], "end": [197, 22], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Coherence.exception", "code": "def exception (g : MVarId) (msg : MessageData) : MetaM \u03b1 := throwTacticEx `monoidal_coherence g msg", "start": [207, 1], "end": [208, 100], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.exception'", "code": "def exception' (msg : MessageData) : TacticM Unit := do\n  try\n    liftMetaTactic (exception (msg := msg))\n  catch _ =>\n    throwError msg", "start": [210, 1], "end": [216, 19], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.mkProjectMapExpr", "code": "def mkProjectMapExpr (e : Expr) : TermElabM Expr := do\n  Term.elabTerm\n    (\u2190 ``(FreeMonoidalCategory.projectMap _root_.id _ _ (LiftHom.lift $(\u2190 Term.exprToSyntax e))))\n    none", "start": [218, 1], "end": [224, 9], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.monoidal_coherence", "code": "def monoidal_coherence (g : MVarId) : TermElabM Unit := g.withContext do\n  withOptions (fun opts => synthInstance.maxSize.set opts\n    (max 256 (synthInstance.maxSize.get opts))) do\n  let (ty, _) \u2190 dsimp (\u2190 g.getType) (\u2190 Simp.Context.ofNames [] true)\n  let some (_, lhs, rhs) := (\u2190 whnfR ty).eq? | exception g \"Not an equation of morphisms.\"\n  let projectMap_lhs \u2190 mkProjectMapExpr lhs\n  let projectMap_rhs \u2190 mkProjectMapExpr rhs\n  let g\u2081 \u2190 g.change (\u2190 mkEq projectMap_lhs projectMap_rhs)\n  let [g\u2082] \u2190 g\u2081.applyConst ``congrArg\n    | exception g \"congrArg failed in coherence\"\n  let [] \u2190 g\u2082.applyConst ``Subsingleton.elim\n    | exception g \"This shouldn't happen; Subsingleton.elim does not create goals.\"", "start": [226, 1], "end": [241, 84], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.assoc_liftHom", "code": "@[nolint unusedArguments]\nlemma assoc_liftHom {W X Y Z : C} [LiftObj W] [LiftObj X] [LiftObj Y]\n    (f : W \u27f6 X) (g : X \u27f6 Y) (h : Y \u27f6 Z) [LiftHom f] [LiftHom g] :\n    f \u226b (g \u226b h) = (f \u226b g) \u226b h :=\n  (Category.assoc _ _ _).symm", "start": [267, 1], "end": [279, 30], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Coherence.insert_id_lhs", "code": "lemma insert_id_lhs {C : Type*} [Category C] {X Y : C} (f g : X \u27f6 Y) (w : f \u226b \ud835\udfd9 _ = g) :\n    f = g := by\n  simpa using w", "start": [298, 1], "end": [300, 16], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Coherence.insert_id_rhs", "code": "lemma insert_id_rhs {C : Type*} [Category C] {X Y : C} (f g : X \u27f6 Y) (w : f = g \u226b \ud835\udfd9 _) :\n    f = g := by\n  simpa using w", "start": [302, 1], "end": [304, 16], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Coherence.insertTrailingIds", "code": "def insertTrailingIds (g : MVarId) : MetaM MVarId := do\n  let some (_, lhs, rhs) := (\u2190 withReducible g.getType').eq? | exception g \"Not an equality.\"\n  let mut g := g\n  if !(lhs.isAppOf ``CategoryStruct.comp) then\n    let [g'] \u2190 g.applyConst ``insert_id_lhs | exception g \"failed to apply insert_id_lhs\"\n    g := g'\n  if !(rhs.isAppOf ``CategoryStruct.comp) then\n    let [g'] \u2190 g.applyConst ``insert_id_rhs | exception g \"failed to apply insert_id_rhs\"\n    g := g'\n  return g", "start": [306, 1], "end": [316, 11], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Coherence.coherence_loop", "code": "def coherence_loop (maxSteps := 37) : TacticM Unit :=\n  match maxSteps with\n  | 0 => exception' \"`coherence` tactic reached iteration limit\"\n  | maxSteps' + 1 => do\n    evalTactic (\u2190 `(tactic| pure_coherence)) <|> do\n    evalTactic (\u2190 `(tactic| liftable_prefixes)) <|>\n      exception' (\"Something went wrong in the `coherence` tactic: \" ++\n        \"is the target an equation in a monoidal category?\")\n    liftMetaTactic MVarId.congrCore\n    evalTactic (\u2190 `(tactic| { pure_coherence })) <|>\n      exception' \"`coherence` tactic failed, subgoal not true in the free monoidal category\"\n    evalTactic (\u2190 `(tactic| rfl)) <|> do\n      liftMetaTactic' insertTrailingIds\n      liftMetaTactic MVarId.congrCore\n      evalTactic (\u2190 `(tactic| rfl)) <|>\n        exception' \"`coherence` tactic failed, non-structural morphisms don't match\"\n      coherence_loop maxSteps'", "start": [318, 1], "end": [349, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Linear/LinearFunctor.lean", "imports": ["Mathlib/CategoryTheory/Preadditive/AdditiveFunctor.lean", "Mathlib/CategoryTheory/Linear/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.Linear", "code": "class Functor.Linear {C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]\n  [Linear R C] [Linear R D] (F : C \u2964 D) [F.Additive] : Prop where\n  \n  map_smul : \u2200 {X Y : C} (f : X \u27f6 Y) (r : R), F.map (r \u2022 f) = r \u2022 F.map f := by aesop_cat", "start": [30, 1], "end": [34, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_smul", "code": "@[simp]\ntheorem map_smul {X Y : C} (r : R) (f : X \u27f6 Y) : F.map (r \u2022 f) = r \u2022 F.map f", "start": [47, 1], "end": [49, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapLinearMap", "code": "@[simps]\ndef mapLinearMap {X Y : C} : (X \u27f6 Y) \u2192\u2097[R] F.obj X \u27f6 F.obj Y :=\n  { F.mapAddHom with map_smul' := fun r f => F.map_smul r f }", "start": [59, 1], "end": [62, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.coe_mapLinearMap", "code": "theorem coe_mapLinearMap {X Y : C} : \u21d1(F.mapLinearMap R : (X \u27f6 Y) \u2192\u2097[R] _) = F.map", "start": [65, 1], "end": [65, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.inducedFunctorLinear", "code": "instance inducedFunctorLinear : Functor.Linear R (inducedFunctor F) where", "start": [75, 1], "end": [75, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.fullSubcategoryInclusionLinear", "code": "instance fullSubcategoryInclusionLinear {C : Type*} [Category C] [Preadditive C]\n    [CategoryTheory.Linear R C] (Z : C \u2192 Prop) : (fullSubcategoryInclusion Z).Linear R where", "start": [80, 1], "end": [81, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.natLinear", "code": "instance natLinear : F.Linear \u2115 where\n  map_smul := F.mapAddHom.map_nsmul", "start": [89, 1], "end": [90, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.intLinear", "code": "instance intLinear : F.Linear \u2124 where\n  map_smul f r := F.mapAddHom.map_zsmul f r", "start": [93, 1], "end": [94, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.ratLinear", "code": "instance ratLinear : F.Linear \u211a where\n  map_smul f r := F.mapAddHom.toRatLinearMap.map_smul r f", "start": [99, 1], "end": [100, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.inverseLinear", "code": "instance inverseLinear (e : C \u224c D) [e.functor.Additive] [e.functor.Linear R] :\n  e.inverse.Linear R where\n    map_smul r f := by\n      apply e.functor.map_injective\n      simp", "start": [112, 1], "end": [116, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Preadditive.lean", "imports": ["Mathlib/CategoryTheory/Preadditive/AdditiveFunctor.lean", "Mathlib/CategoryTheory/Monoidal/Functor.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.MonoidalPreadditive", "code": "class MonoidalPreadditive : Prop where\n  \n  tensor_zero : \u2200 {W X Y Z : C} (f : W \u27f6 X), f \u2297 (0 : Y \u27f6 Z) = 0 := by aesop_cat\n  \n  zero_tensor : \u2200 {W X Y Z : C} (f : Y \u27f6 Z), (0 : W \u27f6 X) \u2297 f = 0 := by aesop_cat\n  \n  tensor_add : \u2200 {W X Y Z : C} (f : W \u27f6 X) (g h : Y \u27f6 Z), f \u2297 (g + h) = f \u2297 g + f \u2297 h := by\n    aesop_cat\n  \n  add_tensor : \u2200 {W X Y Z : C} (f g : W \u27f6 X) (h : Y \u27f6 Z), (f + g) \u2297 h = f \u2297 h + g \u2297 h := by\n    aesop_cat", "start": [31, 1], "end": [46, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.tensorLeft_additive", "code": "instance tensorLeft_additive (X : C) : (tensorLeft X).Additive where", "start": [56, 1], "end": [56, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.tensorRight_additive", "code": "instance tensorRight_additive (X : C) : (tensorRight X).Additive where", "start": [59, 1], "end": [59, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.tensoringLeft_additive", "code": "instance tensoringLeft_additive (X : C) : ((tensoringLeft C).obj X).Additive where", "start": [62, 1], "end": [62, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.tensoringRight_additive", "code": "instance tensoringRight_additive (X : C) : ((tensoringRight C).obj X).Additive where", "start": [65, 1], "end": [65, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalPreadditive_of_faithful", "code": "theorem monoidalPreadditive_of_faithful {D} [Category D] [Preadditive D] [MonoidalCategory D]\n    (F : MonoidalFunctor D C) [Faithful F.toFunctor] [F.toFunctor.Additive] :\n    MonoidalPreadditive D", "start": [68, 1], "end": [90, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.tensor_sum", "code": "theorem tensor_sum {P Q R S : C} {J : Type*} (s : Finset J) (f : P \u27f6 Q) (g : J \u2192 (R \u27f6 S)) :\n    (f \u2297 \u2211 j in s, g j) = \u2211 j in s, f \u2297 g j", "start": [95, 1], "end": [102, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum_tensor", "code": "theorem sum_tensor {P Q R S : C} {J : Type*} (s : Finset J) (f : P \u27f6 Q) (g : J \u2192 (R \u27f6 S)) :\n    (\u2211 j in s, g j) \u2297 f = \u2211 j in s, g j \u2297 f", "start": [105, 1], "end": [112, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.leftDistributor", "code": "def leftDistributor {J : Type} [Fintype J] (X : C) (f : J \u2192 C) : X \u2297 \u2a01 f \u2245 \u2a01 fun j => X \u2297 f j :=\n  (tensorLeft X).mapBiproduct f", "start": [136, 1], "end": [138, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.leftDistributor_hom", "code": "theorem leftDistributor_hom {J : Type} [Fintype J] (X : C) (f : J \u2192 C) :\n    (leftDistributor X f).hom =\n      \u2211 j : J, (\ud835\udfd9 X \u2297 biproduct.\u03c0 f j) \u226b biproduct.\u03b9 (fun j => X \u2297 f j) j", "start": [141, 1], "end": [148, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.leftDistributor_inv", "code": "theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J \u2192 C) :\n    (leftDistributor X f).inv = \u2211 j : J, biproduct.\u03c0 _ j \u226b (\ud835\udfd9 X \u2297 biproduct.\u03b9 f j)", "start": [151, 1], "end": [157, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.leftDistributor_hom_comp_biproduct_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem leftDistributor_hom_comp_biproduct_\u03c0 {J : Type} [Fintype J] (X : C) (f : J \u2192 C) (j : J) :\n    (leftDistributor X f).hom \u226b biproduct.\u03c0 _ j = \ud835\udfd9 X \u2297 biproduct.\u03c0 _ j", "start": [160, 1], "end": [163, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.biproduct_\u03b9_comp_leftDistributor_hom", "code": "@[reassoc (attr := simp)]\ntheorem biproduct_\u03b9_comp_leftDistributor_hom {J : Type} [Fintype J] (X : C) (f : J \u2192 C) (j : J) :\n    (\ud835\udfd9 X \u2297 biproduct.\u03b9 _ j) \u226b (leftDistributor X f).hom = biproduct.\u03b9 (fun j => X \u2297 f j) j", "start": [165, 1], "end": [169, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.leftDistributor_inv_comp_biproduct_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem leftDistributor_inv_comp_biproduct_\u03c0 {J : Type} [Fintype J] (X : C) (f : J \u2192 C) (j : J) :\n    (leftDistributor X f).inv \u226b (\ud835\udfd9 X \u2297 biproduct.\u03c0 _ j) = biproduct.\u03c0 _ j", "start": [171, 1], "end": [175, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.biproduct_\u03b9_comp_leftDistributor_inv", "code": "@[reassoc (attr := simp)]\ntheorem biproduct_\u03b9_comp_leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J \u2192 C) (j : J) :\n    biproduct.\u03b9 _ j \u226b (leftDistributor X f).inv = \ud835\udfd9 X \u2297 biproduct.\u03b9 _ j", "start": [177, 1], "end": [180, 101], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.leftDistributor_assoc", "code": "theorem leftDistributor_assoc {J : Type} [Fintype J] (X Y : C) (f : J \u2192 C) :\n    (asIso (\ud835\udfd9 X) \u2297 leftDistributor Y f) \u226a\u226b leftDistributor X _ =\n      (\u03b1_ X Y (\u2a01 f)).symm \u226a\u226b leftDistributor (X \u2297 Y) f \u226a\u226b biproduct.mapIso fun j => \u03b1_ X Y _", "start": [182, 1], "end": [194, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rightDistributor", "code": "def rightDistributor {J : Type} [Fintype J] (f : J \u2192 C) (X : C) : (\u2a01 f) \u2297 X \u2245 \u2a01 fun j => f j \u2297 X :=\n  (tensorRight X).mapBiproduct f", "start": [197, 1], "end": [199, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rightDistributor_hom", "code": "theorem rightDistributor_hom {J : Type} [Fintype J] (f : J \u2192 C) (X : C) :\n    (rightDistributor f X).hom =\n      \u2211 j : J, (biproduct.\u03c0 f j \u2297 \ud835\udfd9 X) \u226b biproduct.\u03b9 (fun j => f j \u2297 X) j", "start": [202, 1], "end": [209, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rightDistributor_inv", "code": "theorem rightDistributor_inv {J : Type} [Fintype J] (f : J \u2192 C) (X : C) :\n    (rightDistributor f X).inv = \u2211 j : J, biproduct.\u03c0 _ j \u226b (biproduct.\u03b9 f j \u2297 \ud835\udfd9 X)", "start": [212, 1], "end": [217, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rightDistributor_hom_comp_biproduct_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem rightDistributor_hom_comp_biproduct_\u03c0 {J : Type} [Fintype J] (f : J \u2192 C) (X : C) (j : J) :\n    (rightDistributor f X).hom \u226b biproduct.\u03c0 _ j = biproduct.\u03c0 _ j \u2297 \ud835\udfd9 X", "start": [220, 1], "end": [223, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.biproduct_\u03b9_comp_rightDistributor_hom", "code": "@[reassoc (attr := simp)]\ntheorem biproduct_\u03b9_comp_rightDistributor_hom {J : Type} [Fintype J] (f : J \u2192 C) (X : C) (j : J) :\n    (biproduct.\u03b9 _ j \u2297 \ud835\udfd9 X) \u226b (rightDistributor f X).hom = biproduct.\u03b9 (fun j => f j \u2297 X) j", "start": [225, 1], "end": [229, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rightDistributor_inv_comp_biproduct_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem rightDistributor_inv_comp_biproduct_\u03c0 {J : Type} [Fintype J] (f : J \u2192 C) (X : C) (j : J) :\n    (rightDistributor f X).inv \u226b (biproduct.\u03c0 _ j \u2297 \ud835\udfd9 X) = biproduct.\u03c0 _ j", "start": [231, 1], "end": [235, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.biproduct_\u03b9_comp_rightDistributor_inv", "code": "@[reassoc (attr := simp)]\ntheorem biproduct_\u03b9_comp_rightDistributor_inv {J : Type} [Fintype J] (f : J \u2192 C) (X : C) (j : J) :\n    biproduct.\u03b9 _ j \u226b (rightDistributor f X).inv = biproduct.\u03b9 _ j \u2297 \ud835\udfd9 X", "start": [237, 1], "end": [241, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rightDistributor_assoc", "code": "theorem rightDistributor_assoc {J : Type} [Fintype J] (f : J \u2192 C) (X Y : C) :\n    (rightDistributor f X \u2297 asIso (\ud835\udfd9 Y)) \u226a\u226b rightDistributor _ Y =\n      \u03b1_ (\u2a01 f) X Y \u226a\u226b rightDistributor f (X \u2297 Y) \u226a\u226b biproduct.mapIso fun j => (\u03b1_ _ X Y).symm", "start": [243, 1], "end": [256, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.leftDistributor_rightDistributor_assoc", "code": "theorem leftDistributor_rightDistributor_assoc {J : Type _} [Fintype J]\n    (X : C) (f : J \u2192 C) (Y : C) :\n    (leftDistributor X f \u2297 asIso (\ud835\udfd9 Y)) \u226a\u226b rightDistributor _ Y =\n      \u03b1_ X (\u2a01 f) Y \u226a\u226b\n        (asIso (\ud835\udfd9 X) \u2297 rightDistributor _ Y) \u226a\u226b\n          leftDistributor X _ \u226a\u226b biproduct.mapIso fun j => (\u03b1_ _ _ _).symm", "start": [259, 1], "end": [277, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.leftDistributor_ext_left", "code": "@[ext]\ntheorem leftDistributor_ext_left {J : Type} [Fintype J] {X Y : C} {f : J \u2192 C} {g h : X \u2297 \u2a01 f \u27f6 Y}\n    (w : \u2200 j, (\ud835\udfd9 X \u2297 biproduct.\u03b9 f j) \u226b g = (\ud835\udfd9 X \u2297 biproduct.\u03b9 f j) \u226b h) : g = h", "start": [280, 1], "end": [289, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.leftDistributor_ext_right", "code": "@[ext]\ntheorem leftDistributor_ext_right {J : Type} [Fintype J] {X Y : C} {f : J \u2192 C} {g h : X \u27f6 Y \u2297 \u2a01 f}\n    (w : \u2200 j, g \u226b (\ud835\udfd9 Y \u2297 biproduct.\u03c0 f j) = h \u226b (\ud835\udfd9 Y \u2297 biproduct.\u03c0 f j)) : g = h", "start": [291, 1], "end": [301, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.leftDistributor_ext\u2082_left", "code": "@[ext]\ntheorem leftDistributor_ext\u2082_left {J : Type} [Fintype J]\n    {X Y Z : C} {f : J \u2192 C} {g h : X \u2297 (Y \u2297 \u2a01 f) \u27f6 Z}\n    (w : \u2200 j, (\ud835\udfd9 X \u2297 (\ud835\udfd9 Y \u2297 biproduct.\u03b9 f j)) \u226b g = (\ud835\udfd9 X \u2297 (\ud835\udfd9 Y \u2297 biproduct.\u03b9 f j)) \u226b h) :\n    g = h", "start": [305, 1], "end": [312, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.leftDistributor_ext\u2082_right", "code": "@[ext]\ntheorem leftDistributor_ext\u2082_right {J : Type} [Fintype J]\n    {X Y Z : C} {f : J \u2192 C} {g h : X \u27f6 Y \u2297 (Z \u2297 \u2a01 f)}\n    (w : \u2200 j, g \u226b (\ud835\udfd9 Y \u2297 (\ud835\udfd9 Z \u2297 biproduct.\u03c0 f j)) = h \u226b (\ud835\udfd9 Y \u2297 (\ud835\udfd9 Z \u2297 biproduct.\u03c0 f j))) :\n    g = h", "start": [314, 1], "end": [321, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rightDistributor_ext_left", "code": "@[ext]\ntheorem rightDistributor_ext_left {J : Type} [Fintype J]\n    {f : J \u2192 C} {X Y : C} {g h : (\u2a01 f) \u2297 X \u27f6 Y}\n    (w : \u2200 j, (biproduct.\u03b9 f j \u2297 \ud835\udfd9 X) \u226b g = (biproduct.\u03b9 f j \u2297 \ud835\udfd9 X) \u226b h) : g = h", "start": [323, 1], "end": [333, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rightDistributor_ext_right", "code": "@[ext]\ntheorem rightDistributor_ext_right {J : Type} [Fintype J]\n    {f : J \u2192 C} {X Y : C} {g h : X \u27f6 (\u2a01 f) \u2297 Y}\n    (w : \u2200 j, g \u226b (biproduct.\u03c0 f j \u2297 \ud835\udfd9 Y) = h \u226b (biproduct.\u03c0 f j \u2297 \ud835\udfd9 Y)) : g = h", "start": [335, 1], "end": [346, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rightDistributor_ext\u2082_left", "code": "@[ext]\ntheorem rightDistributor_ext\u2082_left {J : Type} [Fintype J]\n    {f : J \u2192 C} {X Y Z : C} {g h : ((\u2a01 f) \u2297 X) \u2297 Y \u27f6 Z}\n    (w : \u2200 j, ((biproduct.\u03b9 f j \u2297 \ud835\udfd9 X) \u2297 \ud835\udfd9 Y) \u226b g = ((biproduct.\u03b9 f j \u2297 \ud835\udfd9 X) \u2297 \ud835\udfd9 Y) \u226b h) :\n    g = h", "start": [348, 1], "end": [355, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rightDistributor_ext\u2082_right", "code": "@[ext]\ntheorem rightDistributor_ext\u2082_right {J : Type} [Fintype J]\n    {f : J \u2192 C} {X Y Z : C} {g h : X \u27f6 ((\u2a01 f) \u2297 Y) \u2297 Z}\n    (w : \u2200 j, g \u226b ((biproduct.\u03c0 f j \u2297 \ud835\udfd9 Y) \u2297 \ud835\udfd9 Z) = h \u226b ((biproduct.\u03c0 f j \u2297 \ud835\udfd9 Y) \u2297 \ud835\udfd9 Z)) :\n    g = h", "start": [357, 1], "end": [364, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Preadditive/Yoneda/Basic.lean", "imports": ["Mathlib/Algebra/Category/GroupCat/Preadditive.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Category/ModuleCat/Basic.lean", "Mathlib/CategoryTheory/Preadditive/Opposite.lean", "Mathlib/CategoryTheory/Limits/Yoneda.lean"], "premises": [{"full_name": "CategoryTheory.preadditiveYonedaObj", "code": "@[simps]\ndef preadditiveYonedaObj (Y : C) : C\u1d52\u1d56 \u2964 ModuleCat.{v} (End Y) where\n  obj X := ModuleCat.of _ (X.unop \u27f6 Y)\n  map f := ModuleCat.ofHom\n    { toFun := fun g => f.unop \u226b g\n      map_add' := fun g g' => comp_add _ _ _ _ _ _\n      map_smul' := fun r g => Eq.symm <| Category.assoc _ _ _ }", "start": [39, 1], "end": [48, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preadditiveYoneda", "code": "@[simps]\ndef preadditiveYoneda : C \u2964 C\u1d52\u1d56 \u2964 AddCommGroupCat.{v} where\n  obj Y := preadditiveYonedaObj Y \u22d9 forget\u2082 _ _\n  map f :=\n    { app := fun X =>\n        { toFun := fun g => g \u226b f\n          map_zero' := Limits.zero_comp\n          map_add' := fun g g' => add_comp _ _ _ _ _ _ }\n      naturality := fun X X' g => AddCommGroupCat.ext fun x => Category.assoc _ _ _ }\n  map_id _ := by ext; dsimp; simp\n  map_comp f g := by ext; dsimp; simp", "start": [51, 1], "end": [65, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preadditiveCoyonedaObj", "code": "@[simps]\ndef preadditiveCoyonedaObj (X : C\u1d52\u1d56) : C \u2964 ModuleCat.{v} (End X) where\n  obj Y := ModuleCat.of _ (unop X \u27f6 Y)\n  map f := ModuleCat.ofHom\n    { toFun := fun g => g \u226b f\n      map_add' := fun g g' => add_comp _ _ _ _ _ _\n      map_smul' := fun r g => Category.assoc _ _ _ }", "start": [68, 1], "end": [77, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preadditiveCoyoneda", "code": "@[simps]\ndef preadditiveCoyoneda : C\u1d52\u1d56 \u2964 C \u2964 AddCommGroupCat.{v} where\n  obj X := preadditiveCoyonedaObj X \u22d9 forget\u2082 _ _\n  map f :=\n    { app := fun Y =>\n        { toFun := fun g => f.unop \u226b g\n          map_zero' := Limits.comp_zero\n          map_add' := fun g g' => comp_add _ _ _ _ _ _ }\n      naturality := fun Y Y' g =>\n        AddCommGroupCat.ext fun x => Eq.symm <| Category.assoc _ _ _ }\n  map_id _ := by ext; dsimp; simp\n  map_comp f g := by ext; dsimp; simp", "start": [80, 1], "end": [95, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.additive_yonedaObj", "code": "instance additive_yonedaObj (X : C) : Functor.Additive (preadditiveYonedaObj X) where", "start": [102, 1], "end": [102, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.additive_yonedaObj'", "code": "instance additive_yonedaObj' (X : C) : Functor.Additive (preadditiveYoneda.obj X) where", "start": [105, 1], "end": [105, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.additive_coyonedaObj", "code": "instance additive_coyonedaObj (X : C\u1d52\u1d56) : Functor.Additive (preadditiveCoyonedaObj X) where", "start": [108, 1], "end": [108, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.additive_coyonedaObj'", "code": "instance additive_coyonedaObj' (X : C\u1d52\u1d56) : Functor.Additive (preadditiveCoyoneda.obj X) where", "start": [111, 1], "end": [111, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskering_preadditiveYoneda", "code": "@[simp]\ntheorem whiskering_preadditiveYoneda :\n    preadditiveYoneda \u22d9\n        (whiskeringRight C\u1d52\u1d56 AddCommGroupCat (Type v)).obj (forget AddCommGroupCat) =\n      yoneda", "start": [114, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskering_preadditiveCoyoneda", "code": "@[simp]\ntheorem whiskering_preadditiveCoyoneda :\n    preadditiveCoyoneda \u22d9\n        (whiskeringRight C AddCommGroupCat (Type v)).obj (forget AddCommGroupCat) =\n      coyoneda", "start": [125, 1], "end": [133, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.full_preadditiveYoneda", "code": "instance full_preadditiveYoneda : Full (preadditiveYoneda : C \u2964 C\u1d52\u1d56 \u2964 AddCommGroupCat) :=\n  let _ : Full (preadditiveYoneda \u22d9\n      (whiskeringRight C\u1d52\u1d56 AddCommGroupCat (Type v)).obj (forget AddCommGroupCat)) :=\n    Yoneda.yonedaFull\n  Full.ofCompFaithful preadditiveYoneda\n    ((whiskeringRight C\u1d52\u1d56 AddCommGroupCat (Type v)).obj (forget AddCommGroupCat))", "start": [136, 1], "end": [141, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.full_preadditiveCoyoneda", "code": "instance full_preadditiveCoyoneda : Full (preadditiveCoyoneda : C\u1d52\u1d56 \u2964 C \u2964 AddCommGroupCat) :=\n  let _ : Full (preadditiveCoyoneda \u22d9\n      (whiskeringRight C AddCommGroupCat (Type v)).obj (forget AddCommGroupCat)) :=\n    Coyoneda.coyonedaFull\n  Full.ofCompFaithful preadditiveCoyoneda\n    ((whiskeringRight C AddCommGroupCat (Type v)).obj (forget AddCommGroupCat))", "start": [144, 1], "end": [149, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.faithful_preadditiveYoneda", "code": "instance faithful_preadditiveYoneda : Faithful (preadditiveYoneda : C \u2964 C\u1d52\u1d56 \u2964 AddCommGroupCat) :=\n  Faithful.of_comp_eq whiskering_preadditiveYoneda", "start": [152, 1], "end": [153, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.faithful_preadditiveCoyoneda", "code": "instance faithful_preadditiveCoyoneda :\n    Faithful (preadditiveCoyoneda : C\u1d52\u1d56 \u2964 C \u2964 AddCommGroupCat) :=\n  Faithful.of_comp_eq whiskering_preadditiveCoyoneda", "start": [156, 1], "end": [158, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/WittVector/StructurePolynomial.lean", "imports": ["Mathlib/FieldTheory/Finite/Polynomial.lean", "Mathlib/NumberTheory/Basic.lean", "Mathlib/RingTheory/WittVector/WittPolynomial.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "wittStructureRat", "code": "noncomputable def wittStructureRat (\u03a6 : MvPolynomial idx \u211a) (n : \u2115) : MvPolynomial (idx \u00d7 \u2115) \u211a :=\n  bind\u2081 (fun k => bind\u2081 (fun i => rename (Prod.mk i) (W_ \u211a k)) \u03a6) (xInTermsOfW p \u211a n)", "start": [118, 1], "end": [137, 86], "kind": "commanddeclaration"}, {"full_name": "wittStructureRat_prop", "code": "theorem wittStructureRat_prop (\u03a6 : MvPolynomial idx \u211a) (n : \u2115) :\n    bind\u2081 (wittStructureRat p \u03a6) (W_ \u211a n) = bind\u2081 (fun i => rename (Prod.mk i) (W_ \u211a n)) \u03a6", "start": [140, 1], "end": [148, 65], "kind": "commanddeclaration"}, {"full_name": "wittStructureRat_existsUnique", "code": "theorem wittStructureRat_existsUnique (\u03a6 : MvPolynomial idx \u211a) :\n    \u2203! \u03c6 : \u2115 \u2192 MvPolynomial (idx \u00d7 \u2115) \u211a,\n      \u2200 n : \u2115, bind\u2081 \u03c6 (W_ \u211a n) = bind\u2081 (fun i => rename (Prod.mk i) (W_ \u211a n)) \u03a6", "start": [151, 1], "end": [161, 62], "kind": "commanddeclaration"}, {"full_name": "wittStructureRat_rec_aux", "code": "theorem wittStructureRat_rec_aux (\u03a6 : MvPolynomial idx \u211a) (n : \u2115) :\n    wittStructureRat p \u03a6 n * C ((p : \u211a) ^ n) =\n      bind\u2081 (fun b => rename (fun i => (b, i)) (W_ \u211a n)) \u03a6 -\n        \u2211 i in range n, C ((p : \u211a) ^ i) * wittStructureRat p \u03a6 i ^ p ^ (n - i)", "start": [164, 1], "end": [175, 6], "kind": "commanddeclaration"}, {"full_name": "wittStructureRat_rec", "code": "theorem wittStructureRat_rec (\u03a6 : MvPolynomial idx \u211a) (n : \u2115) :\n    wittStructureRat p \u03a6 n =\n      C (1 / (p : \u211a) ^ n) *\n        (bind\u2081 (fun b => rename (fun i => (b, i)) (W_ \u211a n)) \u03a6 -\n          \u2211 i in range n, C ((p : \u211a) ^ i) * wittStructureRat p \u03a6 i ^ p ^ (n - i))", "start": [178, 1], "end": [188, 56], "kind": "commanddeclaration"}, {"full_name": "wittStructureInt", "code": "noncomputable def wittStructureInt (\u03a6 : MvPolynomial idx \u2124) (n : \u2115) : MvPolynomial (idx \u00d7 \u2115) \u2124 :=\n  Finsupp.mapRange Rat.num (Rat.coe_int_num 0) (wittStructureRat p (map (Int.castRingHom \u211a) \u03a6) n)", "start": [191, 1], "end": [204, 98], "kind": "commanddeclaration"}, {"full_name": "bind\u2081_rename_expand_wittPolynomial", "code": "theorem bind\u2081_rename_expand_wittPolynomial (\u03a6 : MvPolynomial idx \u2124) (n : \u2115)\n    (IH :\n      \u2200 m : \u2115,\n        m < n + 1 \u2192\n          map (Int.castRingHom \u211a) (wittStructureInt p \u03a6 m) =\n            wittStructureRat p (map (Int.castRingHom \u211a) \u03a6) m) :\n    bind\u2081 (fun b => rename (fun i => (b, i)) (expand p (W_ \u2124 n))) \u03a6 =\n      bind\u2081 (fun i => expand p (wittStructureInt p \u03a6 i)) (W_ \u2124 n)", "start": [209, 1], "end": [226, 22], "kind": "commanddeclaration"}, {"full_name": "C_p_pow_dvd_bind\u2081_rename_wittPolynomial_sub_sum", "code": "theorem C_p_pow_dvd_bind\u2081_rename_wittPolynomial_sub_sum (\u03a6 : MvPolynomial idx \u2124) (n : \u2115)\n    (IH :\n      \u2200 m : \u2115,\n        m < n \u2192\n          map (Int.castRingHom \u211a) (wittStructureInt p \u03a6 m) =\n            wittStructureRat p (map (Int.castRingHom \u211a) \u03a6) m) :\n    (C (p ^ n : \u2124) : MvPolynomial (idx \u00d7 \u2115) \u2124) \u2223\n      bind\u2081 (fun b : idx => rename (fun i => (b, i)) (wittPolynomial p \u2124 n)) \u03a6 -\n        \u2211 i in range n, C ((p : \u2124) ^ i) * wittStructureInt p \u03a6 i ^ p ^ (n - i)", "start": [229, 1], "end": [269, 30], "kind": "commanddeclaration"}, {"full_name": "map_wittStructureInt", "code": "@[simp]\ntheorem map_wittStructureInt (\u03a6 : MvPolynomial idx \u2124) (n : \u2115) :\n    map (Int.castRingHom \u211a) (wittStructureInt p \u03a6 n) =\n      wittStructureRat p (map (Int.castRingHom \u211a) \u03a6) n", "start": [275, 1], "end": [300, 63], "kind": "commanddeclaration"}, {"full_name": "wittStructureInt_prop", "code": "theorem wittStructureInt_prop (\u03a6 : MvPolynomial idx \u2124) (n) :\n    bind\u2081 (wittStructureInt p \u03a6) (wittPolynomial p \u2124 n) =\n      bind\u2081 (fun i => rename (Prod.mk i) (W_ \u2124 n)) \u03a6", "start": [303, 1], "end": [309, 48], "kind": "commanddeclaration"}, {"full_name": "eq_wittStructureInt", "code": "theorem eq_wittStructureInt (\u03a6 : MvPolynomial idx \u2124) (\u03c6 : \u2115 \u2192 MvPolynomial (idx \u00d7 \u2115) \u2124)\n    (h : \u2200 n, bind\u2081 \u03c6 (wittPolynomial p \u2124 n) = bind\u2081 (fun i => rename (Prod.mk i) (W_ \u2124 n)) \u03a6) :\n    \u03c6 = wittStructureInt p \u03a6", "start": [312, 1], "end": [327, 41], "kind": "commanddeclaration"}, {"full_name": "wittStructureInt_existsUnique", "code": "theorem wittStructureInt_existsUnique (\u03a6 : MvPolynomial idx \u2124) :\n    \u2203! \u03c6 : \u2115 \u2192 MvPolynomial (idx \u00d7 \u2115) \u2124,\n      \u2200 n : \u2115,\n        bind\u2081 \u03c6 (wittPolynomial p \u2124 n) = bind\u2081 (fun i : idx => rename (Prod.mk i) (W_ \u2124 n)) \u03a6", "start": [330, 1], "end": [334, 77], "kind": "commanddeclaration"}, {"full_name": "witt_structure_prop", "code": "theorem witt_structure_prop (\u03a6 : MvPolynomial idx \u2124) (n) :\n    aeval (fun i => map (Int.castRingHom R) (wittStructureInt p \u03a6 i)) (wittPolynomial p \u2124 n) =\n      aeval (fun i => rename (Prod.mk i) (W n)) \u03a6", "start": [337, 1], "end": [344, 47], "kind": "commanddeclaration"}, {"full_name": "wittStructureInt_rename", "code": "theorem wittStructureInt_rename {\u03c3 : Type*} (\u03a6 : MvPolynomial idx \u2124) (f : idx \u2192 \u03c3) (n : \u2115) :\n    wittStructureInt p (rename f \u03a6) n = rename (Prod.map f id) (wittStructureInt p \u03a6 n)", "start": [347, 1], "end": [352, 6], "kind": "commanddeclaration"}, {"full_name": "constantCoeff_wittStructureRat_zero", "code": "@[simp]\ntheorem constantCoeff_wittStructureRat_zero (\u03a6 : MvPolynomial idx \u211a) :\n    constantCoeff (wittStructureRat p \u03a6 0) = constantCoeff \u03a6", "start": [355, 1], "end": [360, 22], "kind": "commanddeclaration"}, {"full_name": "constantCoeff_wittStructureRat", "code": "theorem constantCoeff_wittStructureRat (\u03a6 : MvPolynomial idx \u211a) (h : constantCoeff \u03a6 = 0) (n : \u2115) :\n    constantCoeff (wittStructureRat p \u03a6 n) = 0", "start": [363, 1], "end": [367, 31], "kind": "commanddeclaration"}, {"full_name": "constantCoeff_wittStructureInt_zero", "code": "@[simp]\ntheorem constantCoeff_wittStructureInt_zero (\u03a6 : MvPolynomial idx \u2124) :\n    constantCoeff (wittStructureInt p \u03a6 0) = constantCoeff \u03a6", "start": [370, 1], "end": [376, 23], "kind": "commanddeclaration"}, {"full_name": "constantCoeff_wittStructureInt", "code": "theorem constantCoeff_wittStructureInt (\u03a6 : MvPolynomial idx \u2124) (h : constantCoeff \u03a6 = 0) (n : \u2115) :\n    constantCoeff (wittStructureInt p \u03a6 n) = 0", "start": [379, 1], "end": [384, 46], "kind": "commanddeclaration"}, {"full_name": "wittStructureRat_vars", "code": "theorem wittStructureRat_vars [Fintype idx] (\u03a6 : MvPolynomial idx \u211a) (n : \u2115) :\n    (wittStructureRat p \u03a6 n).vars \u2286 Finset.univ \u00d7\u02e2 Finset.range (n + 1)", "start": [391, 1], "end": [402, 29], "kind": "commanddeclaration"}, {"full_name": "wittStructureInt_vars", "code": "theorem wittStructureInt_vars [Fintype idx] (\u03a6 : MvPolynomial idx \u2124) (n : \u2115) :\n    (wittStructureInt p \u03a6 n).vars \u2286 Finset.univ \u00d7\u02e2 Finset.range (n + 1)", "start": [407, 1], "end": [411, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/ConditionalExpectation/Indicator.lean", "imports": ["Mathlib/MeasureTheory/Function/ConditionalExpectation/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.condexp_ae_eq_restrict_zero", "code": "theorem condexp_ae_eq_restrict_zero (hs : MeasurableSet[m] s) (hf : f =\u1d50[\u03bc.restrict s] 0) :\n    \u03bc[f|m] =\u1d50[\u03bc.restrict s] 0", "start": [38, 1], "end": [59, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_indicator_aux", "code": "theorem condexp_indicator_aux (hs : MeasurableSet[m] s) (hf : f =\u1d50[\u03bc.restrict s\u1d9c] 0) :\n    \u03bc[s.indicator f|m] =\u1d50[\u03bc] s.indicator (\u03bc[f|m])", "start": [62, 1], "end": [70, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_indicator", "code": "theorem condexp_indicator (hf_int : Integrable f \u03bc) (hs : MeasurableSet[m] s) :\n    \u03bc[s.indicator f|m] =\u1d50[\u03bc] s.indicator (\u03bc[f|m])", "start": [73, 1], "end": [112, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_restrict_ae_eq_restrict", "code": "theorem condexp_restrict_ae_eq_restrict (hm : m \u2264 m0) [SigmaFinite (\u03bc.trim hm)]\n    (hs_m : MeasurableSet[m] s) (hf_int : Integrable f \u03bc) :\n    (\u03bc.restrict s)[f|m] =\u1d50[\u03bc.restrict s] \u03bc[f|m]", "start": [115, 1], "end": [140, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.condexp_ae_eq_restrict_of_measurableSpace_eq_on", "code": "theorem condexp_ae_eq_restrict_of_measurableSpace_eq_on {m m\u2082 m0 : MeasurableSpace \u03b1}\n    {\u03bc : Measure \u03b1} (hm : m \u2264 m0) (hm\u2082 : m\u2082 \u2264 m0) [SigmaFinite (\u03bc.trim hm)]\n    [SigmaFinite (\u03bc.trim hm\u2082)] (hs_m : MeasurableSet[m] s)\n    (hs : \u2200 t, MeasurableSet[m] (s \u2229 t) \u2194 MeasurableSet[m\u2082] (s \u2229 t)) :\n    \u03bc[f|m] =\u1d50[\u03bc.restrict s] \u03bc[f|m\u2082]", "start": [143, 1], "end": [183, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/UniformIntegrable.lean", "imports": ["Mathlib/MeasureTheory/Function/L1Space.lean", "Mathlib/MeasureTheory/Function/ConvergenceInMeasure.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.UnifIntegrable", "code": "def UnifIntegrable {_ : MeasurableSpace \u03b1} (f : \u03b9 \u2192 \u03b1 \u2192 \u03b2) (p : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : Prop :=\n  \u2200 \u2983\u03b5 : \u211d\u2984 (_ : 0 < \u03b5), \u2203 (\u03b4 : \u211d) (_ : 0 < \u03b4), \u2200 i s,\n    MeasurableSet s \u2192 \u03bc s \u2264 ENNReal.ofReal \u03b4 \u2192 snorm (s.indicator (f i)) p \u03bc \u2264 ENNReal.ofReal \u03b5", "start": [58, 1], "end": [67, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.UniformIntegrable", "code": "def UniformIntegrable {_ : MeasurableSpace \u03b1} (f : \u03b9 \u2192 \u03b1 \u2192 \u03b2) (p : \u211d\u22650\u221e) (\u03bc : Measure \u03b1) : Prop :=\n  (\u2200 i, AEStronglyMeasurable (f i) \u03bc) \u2227 UnifIntegrable f p \u03bc \u2227 \u2203 C : \u211d\u22650, \u2200 i, snorm (f i) p \u03bc \u2264 C", "start": [70, 1], "end": [73, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.UniformIntegrable.aeStronglyMeasurable", "code": "protected theorem aeStronglyMeasurable {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {p : \u211d\u22650\u221e} (hf : UniformIntegrable f p \u03bc)\n    (i : \u03b9) : AEStronglyMeasurable (f i) \u03bc", "start": [78, 1], "end": [80, 9], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.UniformIntegrable.unifIntegrable", "code": "protected theorem unifIntegrable {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {p : \u211d\u22650\u221e} (hf : UniformIntegrable f p \u03bc) :\n    UnifIntegrable f p \u03bc", "start": [83, 1], "end": [85, 9], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.UniformIntegrable.mem\u2112p", "code": "protected theorem mem\u2112p {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {p : \u211d\u22650\u221e} (hf : UniformIntegrable f p \u03bc) (i : \u03b9) :\n    Mem\u2112p (f i) p \u03bc", "start": [88, 1], "end": [92, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.UnifIntegrable.add", "code": "protected theorem add (hf : UnifIntegrable f p \u03bc) (hg : UnifIntegrable g p \u03bc) (hp : 1 \u2264 p)\n    (hf_meas : \u2200 i, AEStronglyMeasurable (f i) \u03bc) (hg_meas : \u2200 i, AEStronglyMeasurable (g i) \u03bc) :\n    UnifIntegrable (f + g) p \u03bc", "start": [108, 1], "end": [122, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.UnifIntegrable.neg", "code": "protected theorem neg (hf : UnifIntegrable f p \u03bc) : UnifIntegrable (-f) p \u03bc", "start": [125, 1], "end": [127, 11], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.UnifIntegrable.sub", "code": "protected theorem sub (hf : UnifIntegrable f p \u03bc) (hg : UnifIntegrable g p \u03bc) (hp : 1 \u2264 p)\n    (hf_meas : \u2200 i, AEStronglyMeasurable (f i) \u03bc) (hg_meas : \u2200 i, AEStronglyMeasurable (g i) \u03bc) :\n    UnifIntegrable (f - g) p \u03bc", "start": [130, 1], "end": [134, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.UnifIntegrable.ae_eq", "code": "protected theorem ae_eq (hf : UnifIntegrable f p \u03bc) (hfg : \u2200 n, f n =\u1d50[\u03bc] g n) :\n    UnifIntegrable g p \u03bc", "start": [137, 1], "end": [143, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.unifIntegrable_zero_meas", "code": "theorem unifIntegrable_zero_meas [MeasurableSpace \u03b1] {p : \u211d\u22650\u221e} {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2} :\n    UnifIntegrable f p (0 : Measure \u03b1)", "start": [148, 1], "end": [150, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.unifIntegrable_congr_ae", "code": "theorem unifIntegrable_congr_ae {p : \u211d\u22650\u221e} {f g : \u03b9 \u2192 \u03b1 \u2192 \u03b2} (hfg : \u2200 n, f n =\u1d50[\u03bc] g n) :\n    UnifIntegrable f p \u03bc \u2194 UnifIntegrable g p \u03bc", "start": [153, 1], "end": [155, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_indicator_ge", "code": "theorem tendsto_indicator_ge (f : \u03b1 \u2192 \u03b2) (x : \u03b1) :\n    Tendsto (fun M : \u2115 => { x | (M : \u211d) \u2264 \u2016f x\u2016\u208a }.indicator f x) atTop (\ud835\udcdd 0)", "start": [158, 1], "end": [165, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.integral_indicator_norm_ge_le", "code": "theorem Mem\u2112p.integral_indicator_norm_ge_le (hf : Mem\u2112p f 1 \u03bc) (hmeas : StronglyMeasurable f)\n    {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) :\n    \u2203 M : \u211d, (\u222b\u207b x, \u2016{ x | M \u2264 \u2016f x\u2016\u208a }.indicator f x\u2016\u208a \u2202\u03bc) \u2264 ENNReal.ofReal \u03b5", "start": [174, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.integral_indicator_norm_ge_nonneg_le_of_meas", "code": "theorem Mem\u2112p.integral_indicator_norm_ge_nonneg_le_of_meas (hf : Mem\u2112p f 1 \u03bc)\n    (hmeas : StronglyMeasurable f) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) :\n    \u2203 M : \u211d, 0 \u2264 M \u2227 (\u222b\u207b x, \u2016{ x | M \u2264 \u2016f x\u2016\u208a }.indicator f x\u2016\u208a \u2202\u03bc) \u2264 ENNReal.ofReal \u03b5", "start": [211, 1], "end": [217, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.integral_indicator_norm_ge_nonneg_le", "code": "theorem Mem\u2112p.integral_indicator_norm_ge_nonneg_le (hf : Mem\u2112p f 1 \u03bc) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) :\n    \u2203 M : \u211d, 0 \u2264 M \u2227 (\u222b\u207b x, \u2016{ x | M \u2264 \u2016f x\u2016\u208a }.indicator f x\u2016\u208a \u2202\u03bc) \u2264 ENNReal.ofReal \u03b5", "start": [220, 1], "end": [228, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.snormEssSup_indicator_norm_ge_eq_zero", "code": "theorem Mem\u2112p.snormEssSup_indicator_norm_ge_eq_zero (hf : Mem\u2112p f \u221e \u03bc)\n    (hmeas : StronglyMeasurable f) :\n    \u2203 M : \u211d, snormEssSup ({ x | M \u2264 \u2016f x\u2016\u208a }.indicator f) \u03bc = 0", "start": [231, 1], "end": [254, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.snorm_indicator_norm_ge_le", "code": "theorem Mem\u2112p.snorm_indicator_norm_ge_le (hf : Mem\u2112p f p \u03bc) (hmeas : StronglyMeasurable f) {\u03b5 : \u211d}\n    (h\u03b5 : 0 < \u03b5) : \u2203 M : \u211d, snorm ({ x | M \u2264 \u2016f x\u2016\u208a }.indicator f) p \u03bc \u2264 ENNReal.ofReal \u03b5", "start": [259, 1], "end": [293, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.snorm_indicator_norm_ge_pos_le", "code": "theorem Mem\u2112p.snorm_indicator_norm_ge_pos_le (hf : Mem\u2112p f p \u03bc) (hmeas : StronglyMeasurable f)\n    {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) :\n    \u2203 M : \u211d, 0 < M \u2227 snorm ({ x | M \u2264 \u2016f x\u2016\u208a }.indicator f) p \u03bc \u2264 ENNReal.ofReal \u03b5", "start": [296, 1], "end": [306, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_indicator_le_of_bound", "code": "theorem snorm_indicator_le_of_bound {f : \u03b1 \u2192 \u03b2} (hp_top : p \u2260 \u221e) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) {M : \u211d}\n    (hf : \u2200 x, \u2016f x\u2016 < M) :\n    \u2203 (\u03b4 : \u211d) (h\u03b4 : 0 < \u03b4), \u2200 s,\n      MeasurableSet s \u2192 \u03bc s \u2264 ENNReal.ofReal \u03b4 \u2192 snorm (s.indicator f) p \u03bc \u2264 ENNReal.ofReal \u03b5", "start": [311, 1], "end": [337, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.snorm_indicator_le'", "code": "theorem Mem\u2112p.snorm_indicator_le' (hp_one : 1 \u2264 p) (hp_top : p \u2260 \u221e) (hf : Mem\u2112p f p \u03bc)\n    (hmeas : StronglyMeasurable f) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) :\n    \u2203 (\u03b4 : \u211d) (h\u03b4 : 0 < \u03b4), \u2200 s, MeasurableSet s \u2192 \u03bc s \u2264 ENNReal.ofReal \u03b4 \u2192\n      snorm (s.indicator f) p \u03bc \u2264 2 * ENNReal.ofReal \u03b5", "start": [344, 1], "end": [372, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.snorm_indicator_le_of_meas", "code": "theorem Mem\u2112p.snorm_indicator_le_of_meas (hp_one : 1 \u2264 p) (hp_top : p \u2260 \u221e) (hf : Mem\u2112p f p \u03bc)\n    (hmeas : StronglyMeasurable f) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) :\n    \u2203 (\u03b4 : \u211d) (h\u03b4 : 0 < \u03b4), \u2200 s, MeasurableSet s \u2192 \u03bc s \u2264 ENNReal.ofReal \u03b4 \u2192\n      snorm (s.indicator f) p \u03bc \u2264 ENNReal.ofReal \u03b5", "start": [375, 1], "end": [385, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.snorm_indicator_le", "code": "theorem Mem\u2112p.snorm_indicator_le (hp_one : 1 \u2264 p) (hp_top : p \u2260 \u221e) (hf : Mem\u2112p f p \u03bc) {\u03b5 : \u211d}\n    (h\u03b5 : 0 < \u03b5) :\n    \u2203 (\u03b4 : \u211d) (h\u03b4 : 0 < \u03b4), \u2200 s, MeasurableSet s \u2192 \u03bc s \u2264 ENNReal.ofReal \u03b4 \u2192\n      snorm (s.indicator f) p \u03bc \u2264 ENNReal.ofReal \u03b5", "start": [388, 1], "end": [398, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.unifIntegrable_const", "code": "theorem unifIntegrable_const {g : \u03b1 \u2192 \u03b2} (hp : 1 \u2264 p) (hp_ne_top : p \u2260 \u221e) (hg : Mem\u2112p g p \u03bc) :\n    UnifIntegrable (fun _ : \u03b9 => g) p \u03bc", "start": [401, 1], "end": [406, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.unifIntegrable_subsingleton", "code": "theorem unifIntegrable_subsingleton [Subsingleton \u03b9] (hp_one : 1 \u2264 p) (hp_top : p \u2260 \u221e)\n    {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2} (hf : \u2200 i, Mem\u2112p (f i) p \u03bc) : UnifIntegrable f p \u03bc", "start": [409, 1], "end": [418, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.unifIntegrable_fin", "code": "theorem unifIntegrable_fin (hp_one : 1 \u2264 p) (hp_top : p \u2260 \u221e) {n : \u2115} {f : Fin n \u2192 \u03b1 \u2192 \u03b2}\n    (hf : \u2200 i, Mem\u2112p (f i) p \u03bc) : UnifIntegrable f p \u03bc", "start": [421, 1], "end": [446, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.unifIntegrable_finite", "code": "theorem unifIntegrable_finite [Finite \u03b9] (hp_one : 1 \u2264 p) (hp_top : p \u2260 \u221e) {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2}\n    (hf : \u2200 i, Mem\u2112p (f i) p \u03bc) : UnifIntegrable f p \u03bc", "start": [449, 1], "end": [460, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.snorm_sub_le_of_dist_bdd", "code": "theorem snorm_sub_le_of_dist_bdd {p : \u211d\u22650\u221e} (hp' : p \u2260 \u221e) {s : Set \u03b1} (hs : MeasurableSet[m] s)\n    {f g : \u03b1 \u2192 \u03b2} {c : \u211d} (hc : 0 \u2264 c) (hf : \u2200 x \u2208 s, dist (f x) (g x) \u2264 c) :\n    snorm (s.indicator (f - g)) p \u03bc \u2264 ENNReal.ofReal c * \u03bc s ^ (1 / p.toReal)", "start": [465, 1], "end": [480, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_Lp_of_tendsto_ae_of_meas", "code": "theorem tendsto_Lp_of_tendsto_ae_of_meas [IsFiniteMeasure \u03bc] (hp : 1 \u2264 p) (hp' : p \u2260 \u221e)\n    {f : \u2115 \u2192 \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b2} (hf : \u2200 n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g)\n    (hg' : Mem\u2112p g p \u03bc) (hui : UnifIntegrable f p \u03bc)\n    (hfg : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (g x))) :\n    Tendsto (fun n => snorm (f n - g) p \u03bc) atTop (\ud835\udcdd 0)", "start": [483, 1], "end": [550, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_Lp_of_tendsto_ae", "code": "theorem tendsto_Lp_of_tendsto_ae [IsFiniteMeasure \u03bc] (hp : 1 \u2264 p) (hp' : p \u2260 \u221e) {f : \u2115 \u2192 \u03b1 \u2192 \u03b2}\n    {g : \u03b1 \u2192 \u03b2} (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc) (hg : Mem\u2112p g p \u03bc)\n    (hui : UnifIntegrable f p \u03bc) (hfg : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (g x))) :\n    Tendsto (fun n => snorm (f n - g) p \u03bc) atTop (\ud835\udcdd 0)", "start": [554, 1], "end": [571, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.unifIntegrable_of_tendsto_Lp_zero", "code": "theorem unifIntegrable_of_tendsto_Lp_zero (hp : 1 \u2264 p) (hp' : p \u2260 \u221e) (hf : \u2200 n, Mem\u2112p (f n) p \u03bc)\n    (hf_tendsto : Tendsto (fun n => snorm (f n) p \u03bc) atTop (\ud835\udcdd 0)) : UnifIntegrable f p \u03bc", "start": [577, 1], "end": [588, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.unifIntegrable_of_tendsto_Lp", "code": "theorem unifIntegrable_of_tendsto_Lp (hp : 1 \u2264 p) (hp' : p \u2260 \u221e) (hf : \u2200 n, Mem\u2112p (f n) p \u03bc)\n    (hg : Mem\u2112p g p \u03bc) (hfg : Tendsto (fun n => snorm (f n - g) p \u03bc) atTop (\ud835\udcdd 0)) :\n    UnifIntegrable f p \u03bc", "start": [592, 1], "end": [601, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_Lp_of_tendstoInMeasure", "code": "theorem tendsto_Lp_of_tendstoInMeasure [IsFiniteMeasure \u03bc] (hp : 1 \u2264 p) (hp' : p \u2260 \u221e)\n    (hf : \u2200 n, AEStronglyMeasurable (f n) \u03bc) (hg : Mem\u2112p g p \u03bc) (hui : UnifIntegrable f p \u03bc)\n    (hfg : TendstoInMeasure \u03bc f atTop g) : Tendsto (fun n => snorm (f n - g) p \u03bc) atTop (\ud835\udcdd 0)", "start": [605, 1], "end": [617, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendstoInMeasure_iff_tendsto_Lp", "code": "theorem tendstoInMeasure_iff_tendsto_Lp [IsFiniteMeasure \u03bc] (hp : 1 \u2264 p) (hp' : p \u2260 \u221e)\n    (hf : \u2200 n, Mem\u2112p (f n) p \u03bc) (hg : Mem\u2112p g p \u03bc) :\n    TendstoInMeasure \u03bc f atTop g \u2227 UnifIntegrable f p \u03bc \u2194\n      Tendsto (fun n => snorm (f n - g) p \u03bc) atTop (\ud835\udcdd 0)", "start": [621, 1], "end": [630, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.unifIntegrable_of'", "code": "theorem unifIntegrable_of' (hp : 1 \u2264 p) (hp' : p \u2260 \u221e) {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2}\n    (hf : \u2200 i, StronglyMeasurable (f i))\n    (h : \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 C : \u211d\u22650, 0 < C \u2227\n      \u2200 i, snorm ({ x | C \u2264 \u2016f i x\u2016\u208a }.indicator (f i)) p \u03bc \u2264 ENNReal.ofReal \u03b5) :\n    UnifIntegrable f p \u03bc", "start": [634, 1], "end": [697, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.unifIntegrable_of", "code": "theorem unifIntegrable_of (hp : 1 \u2264 p) (hp' : p \u2260 \u221e) {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2}\n    (hf : \u2200 i, AEStronglyMeasurable (f i) \u03bc)\n    (h : \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 C : \u211d\u22650,\n      \u2200 i, snorm ({ x | C \u2264 \u2016f i x\u2016\u208a }.indicator (f i)) p \u03bc \u2264 ENNReal.ofReal \u03b5) :\n    UnifIntegrable f p \u03bc", "start": [700, 1], "end": [722, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.uniformIntegrable_zero_meas", "code": "theorem uniformIntegrable_zero_meas [MeasurableSpace \u03b1] : UniformIntegrable f p (0 : Measure \u03b1)", "start": [742, 1], "end": [744, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.UniformIntegrable.ae_eq", "code": "theorem UniformIntegrable.ae_eq {g : \u03b9 \u2192 \u03b1 \u2192 \u03b2} (hf : UniformIntegrable f p \u03bc)\n    (hfg : \u2200 n, f n =\u1d50[\u03bc] g n) : UniformIntegrable g p \u03bc", "start": [747, 1], "end": [752, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.uniformIntegrable_congr_ae", "code": "theorem uniformIntegrable_congr_ae {g : \u03b9 \u2192 \u03b1 \u2192 \u03b2} (hfg : \u2200 n, f n =\u1d50[\u03bc] g n) :\n    UniformIntegrable f p \u03bc \u2194 UniformIntegrable g p \u03bc", "start": [755, 1], "end": [757, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.uniformIntegrable_finite", "code": "theorem uniformIntegrable_finite [Finite \u03b9] (hp_one : 1 \u2264 p) (hp_top : p \u2260 \u221e)\n    (hf : \u2200 i, Mem\u2112p (f i) p \u03bc) : UniformIntegrable f p \u03bc", "start": [760, 1], "end": [776, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.uniformIntegrable_subsingleton", "code": "theorem uniformIntegrable_subsingleton [Subsingleton \u03b9] (hp_one : 1 \u2264 p) (hp_top : p \u2260 \u221e)\n    (hf : \u2200 i, Mem\u2112p (f i) p \u03bc) : UniformIntegrable f p \u03bc", "start": [779, 1], "end": [782, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.uniformIntegrable_const", "code": "theorem uniformIntegrable_const {g : \u03b1 \u2192 \u03b2} (hp : 1 \u2264 p) (hp_ne_top : p \u2260 \u221e) (hg : Mem\u2112p g p \u03bc) :\n    UniformIntegrable (fun _ : \u03b9 => g) p \u03bc", "start": [785, 1], "end": [789, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.uniformIntegrable_of'", "code": "theorem uniformIntegrable_of' [IsFiniteMeasure \u03bc] (hp : 1 \u2264 p) (hp' : p \u2260 \u221e)\n    (hf : \u2200 i, StronglyMeasurable (f i))\n    (h : \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 C : \u211d\u22650,\n      \u2200 i, snorm ({ x | C \u2264 \u2016f i x\u2016\u208a }.indicator (f i)) p \u03bc \u2264 ENNReal.ofReal \u03b5) :\n    UniformIntegrable f p \u03bc", "start": [792, 1], "end": [831, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.uniformIntegrable_of", "code": "theorem uniformIntegrable_of [IsFiniteMeasure \u03bc] (hp : 1 \u2264 p) (hp' : p \u2260 \u221e)\n    (hf : \u2200 i, AEStronglyMeasurable (f i) \u03bc)\n    (h : \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 C : \u211d\u22650,\n      \u2200 i, snorm ({ x | C \u2264 \u2016f i x\u2016\u208a }.indicator (f i)) p \u03bc \u2264 ENNReal.ofReal \u03b5) :\n    UniformIntegrable f p \u03bc", "start": [834, 1], "end": [852, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.UniformIntegrable.spec'", "code": "theorem UniformIntegrable.spec' (hp : p \u2260 0) (hp' : p \u2260 \u221e) (hf : \u2200 i, StronglyMeasurable (f i))\n    (hfu : UniformIntegrable f p \u03bc) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) :\n    \u2203 C : \u211d\u22650, \u2200 i, snorm ({ x | C \u2264 \u2016f i x\u2016\u208a }.indicator (f i)) p \u03bc \u2264 ENNReal.ofReal \u03b5", "start": [855, 1], "end": [889, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.UniformIntegrable.spec", "code": "theorem UniformIntegrable.spec (hp : p \u2260 0) (hp' : p \u2260 \u221e) (hfu : UniformIntegrable f p \u03bc) {\u03b5 : \u211d}\n    (h\u03b5 : 0 < \u03b5) :\n    \u2203 C : \u211d\u22650, \u2200 i, snorm ({ x | C \u2264 \u2016f i x\u2016\u208a }.indicator (f i)) p \u03bc \u2264 ENNReal.ofReal \u03b5", "start": [892, 1], "end": [905, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.uniformIntegrable_iff", "code": "theorem uniformIntegrable_iff [IsFiniteMeasure \u03bc] (hp : 1 \u2264 p) (hp' : p \u2260 \u221e) :\n    UniformIntegrable f p \u03bc \u2194\n      (\u2200 i, AEStronglyMeasurable (f i) \u03bc) \u2227\n        \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 C : \u211d\u22650,\n          \u2200 i, snorm ({ x | C \u2264 \u2016f i x\u2016\u208a }.indicator (f i)) p \u03bc \u2264 ENNReal.ofReal \u03b5", "start": [908, 1], "end": [916, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.uniformIntegrable_average", "code": "theorem uniformIntegrable_average\n    {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    (hp : 1 \u2264 p) {f : \u2115 \u2192 \u03b1 \u2192 E} (hf : UniformIntegrable f p \u03bc) :\n    UniformIntegrable (fun (n : \u2115) => (n : \u211d)\u207b\u00b9 \u2022 (\u2211 i in Finset.range n, f i)) p \u03bc", "start": [919, 1], "end": [959, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.uniformIntegrable_average_real", "code": "theorem uniformIntegrable_average_real (hp : 1 \u2264 p) {f : \u2115 \u2192 \u03b1 \u2192 \u211d} (hf : UniformIntegrable f p \u03bc) :\n    UniformIntegrable (fun n => (\u2211 i in Finset.range n, f i) / (n : \u03b1 \u2192 \u211d)) p \u03bc", "start": [961, 1], "end": [966, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean", "imports": ["Mathlib/MeasureTheory/Decomposition/Lebesgue.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.Measure.withDensity_rnDeriv_eq", "code": "theorem withDensity_rnDeriv_eq (\u03bc \u03bd : Measure \u03b1) [HaveLebesgueDecomposition \u03bc \u03bd] (h : \u03bc \u226a \u03bd) :\n    \u03bd.withDensity (rnDeriv \u03bc \u03bd) = \u03bc", "start": [46, 1], "end": [59, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.absolutelyContinuous_iff_withDensity_rnDeriv_eq", "code": "theorem absolutelyContinuous_iff_withDensity_rnDeriv_eq {\u03bc \u03bd : Measure \u03b1}\n    [HaveLebesgueDecomposition \u03bc \u03bd] : \u03bc \u226a \u03bd \u2194 \u03bd.withDensity (rnDeriv \u03bc \u03bd) = \u03bc", "start": [62, 1], "end": [67, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.withDensity_rnDeriv_toReal_eq", "code": "theorem withDensity_rnDeriv_toReal_eq {\u03bc \u03bd : Measure \u03b1} [IsFiniteMeasure \u03bc]\n    [HaveLebesgueDecomposition \u03bc \u03bd] (h : \u03bc \u226a \u03bd) {i : Set \u03b1} (hi : MeasurableSet i) :\n    (\u222b x in i, (\u03bc.rnDeriv \u03bd x).toReal \u2202\u03bd) = (\u03bc i).toReal", "start": [70, 1], "end": [78, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SignedMeasure.withDensity\u1d65_rnDeriv_eq", "code": "theorem withDensity\u1d65_rnDeriv_eq (s : SignedMeasure \u03b1) (\u03bc : Measure \u03b1) [SigmaFinite \u03bc]\n    (h : s \u226a\u1d65 \u03bc.toENNRealVectorMeasure) : \u03bc.withDensity\u1d65 (s.rnDeriv \u03bc) = s", "start": [87, 1], "end": [105, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.SignedMeasure.absolutelyContinuous_iff_withDensity\u1d65_rnDeriv_eq", "code": "theorem absolutelyContinuous_iff_withDensity\u1d65_rnDeriv_eq (s : SignedMeasure \u03b1) (\u03bc : Measure \u03b1)\n    [SigmaFinite \u03bc] : s \u226a\u1d65 \u03bc.toENNRealVectorMeasure \u2194 \u03bc.withDensity\u1d65 (s.rnDeriv \u03bc) = s", "start": [108, 1], "end": [111, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/TopCat/Limits/Products.lean", "imports": ["Mathlib/Topology/Category/TopCat/EpiMono.lean", "Mathlib/Topology/Category/TopCat/Limits/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopCat.pi\u03c0", "code": "abbrev pi\u03c0 {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCatMax.{v, u}) (i : \u03b9) : TopCat.of (\u2200 i, \u03b1 i) \u27f6 \u03b1 i :=\n  \u27e8fun f => f i, continuous_apply i\u27e9", "start": [32, 1], "end": [34, 37], "kind": "commanddeclaration"}, {"full_name": "TopCat.piFan", "code": "@[simps! pt \u03c0_app]\ndef piFan {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCatMax.{v, u}) : Fan \u03b1 :=\n  Fan.mk (TopCat.of (\u2200 i, \u03b1 i)) (pi\u03c0.{v,u} \u03b1)", "start": [37, 1], "end": [40, 46], "kind": "commanddeclaration"}, {"full_name": "TopCat.piFanIsLimit", "code": "def piFanIsLimit {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCatMax.{v, u}) : IsLimit (piFan \u03b1) where\n  lift S :=\n    { toFun := fun s i => S.\u03c0.app \u27e8i\u27e9 s\n      continuous_toFun := continuous_pi (fun i => (S.\u03c0.app \u27e8i\u27e9).2) }\n  uniq := by\n    intro S m h\n    apply ContinuousMap.ext; intro x\n    funext i\n    dsimp\n    rw [ContinuousMap.coe_mk, \u2190 h \u27e8i\u27e9]\n    rfl\n  fac s j := rfl", "start": [43, 1], "end": [55, 17], "kind": "commanddeclaration"}, {"full_name": "TopCat.piIsoPi", "code": "def piIsoPi {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCatMax.{v, u}) : \u220f \u03b1 \u2245 TopCat.of (\u2200 i, \u03b1 i) :=\n  (limit.isLimit _).conePointUniqueUpToIso (piFanIsLimit \u03b1)", "start": [58, 1], "end": [62, 60], "kind": "commanddeclaration"}, {"full_name": "TopCat.piIsoPi_inv_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem piIsoPi_inv_\u03c0 {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCatMax.{v, u}) (i : \u03b9) :\n    (piIsoPi \u03b1).inv \u226b Pi.\u03c0 \u03b1 i = pi\u03c0 \u03b1 i", "start": [65, 1], "end": [67, 62], "kind": "commanddeclaration"}, {"full_name": "TopCat.piIsoPi_inv_\u03c0_apply", "code": "@[simp]\ntheorem piIsoPi_inv_\u03c0_apply {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCatMax.{v, u}) (i : \u03b9) (x : \u2200 i, \u03b1 i) :\n    (Pi.\u03c0 \u03b1 i : _) ((piIsoPi \u03b1).inv x) = x i", "start": [70, 1], "end": [73, 51], "kind": "commanddeclaration"}, {"full_name": "TopCat.piIsoPi_hom_apply", "code": "@[simp]\ntheorem piIsoPi_hom_apply {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCatMax.{v, u}) (i : \u03b9)\n    (x : (\u220f \u03b1 : TopCatMax.{v, u})) : (piIsoPi \u03b1).hom x i = (Pi.\u03c0 \u03b1 i : _) x", "start": [77, 1], "end": [82, 42], "kind": "commanddeclaration"}, {"full_name": "TopCat.sigma\u03b9", "code": "abbrev sigma\u03b9 {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCatMax.{v,u}) (i : \u03b9) : \u03b1 i \u27f6 TopCat.of (\u03a3i, \u03b1 i) := by\n  refine ContinuousMap.mk ?_ ?_\n  \u00b7 dsimp\n    apply Sigma.mk i\n  \u00b7 dsimp; continuity", "start": [86, 1], "end": [91, 22], "kind": "commanddeclaration"}, {"full_name": "TopCat.sigmaCofan", "code": "@[simps! pt \u03b9_app]\ndef sigmaCofan {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCatMax.{v, u}) : Cofan \u03b1 :=\n  Cofan.mk (TopCat.of (\u03a3i, \u03b1 i)) (sigma\u03b9 \u03b1)", "start": [94, 1], "end": [97, 44], "kind": "commanddeclaration"}, {"full_name": "TopCat.sigmaCofanIsColimit", "code": "def sigmaCofanIsColimit {\u03b9 : Type v} (\u03b2 : \u03b9 \u2192 TopCatMax.{v, u}) : IsColimit (sigmaCofan \u03b2) where\n  desc S :=\n    { toFun := fun (s : of (\u03a3 i, \u03b2 i)) => S.\u03b9.app \u27e8s.1\u27e9 s.2\n      continuous_toFun := continuous_sigma fun i => (S.\u03b9.app \u27e8i\u27e9).continuous_toFun }\n  uniq := by\n    intro S m h\n    ext \u27e8i, x\u27e9\n    simp only [comp_app,hom_apply,\u2190 h \u27e8i\u27e9]\n    congr\n  fac s j := by\n    cases j\n    aesop_cat", "start": [100, 1], "end": [112, 14], "kind": "commanddeclaration"}, {"full_name": "TopCat.sigmaIsoSigma", "code": "def sigmaIsoSigma {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCatMax.{v, u}) : \u2210 \u03b1 \u2245 TopCat.of (\u03a3i, \u03b1 i) :=\n  (colimit.isColimit _).coconePointUniqueUpToIso (sigmaCofanIsColimit \u03b1)", "start": [115, 1], "end": [118, 73], "kind": "commanddeclaration"}, {"full_name": "TopCat.sigmaIsoSigma_hom_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem sigmaIsoSigma_hom_\u03b9 {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCatMax.{v, u}) (i : \u03b9) :\n    Sigma.\u03b9 \u03b1 i \u226b (sigmaIsoSigma \u03b1).hom = sigma\u03b9 \u03b1 i", "start": [121, 1], "end": [123, 80], "kind": "commanddeclaration"}, {"full_name": "TopCat.sigmaIsoSigma_hom_\u03b9_apply", "code": "@[simp]\ntheorem sigmaIsoSigma_hom_\u03b9_apply {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCatMax.{v, u}) (i : \u03b9) (x : \u03b1 i) :\n    (sigmaIsoSigma \u03b1).hom ((Sigma.\u03b9 \u03b1 i : _) x) = Sigma.mk i x", "start": [126, 1], "end": [129, 57], "kind": "commanddeclaration"}, {"full_name": "TopCat.sigmaIsoSigma_inv_apply", "code": "@[simp]\ntheorem sigmaIsoSigma_inv_apply {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCatMax.{v, u}) (i : \u03b9) (x : \u03b1 i) :\n    (sigmaIsoSigma \u03b1).inv \u27e8i, x\u27e9 = (Sigma.\u03b9 \u03b1 i : _) x", "start": [132, 1], "end": [136, 22], "kind": "commanddeclaration"}, {"full_name": "TopCat.induced_of_isLimit", "code": "theorem induced_of_isLimit {F : J \u2964 TopCatMax.{v, u}} (C : Cone F) (hC : IsLimit C) :\n    C.pt.str = \u2a05 j, (F.obj j).str.induced (C.\u03c0.app j)", "start": [140, 1], "end": [146, 6], "kind": "commanddeclaration"}, {"full_name": "TopCat.limit_topology", "code": "theorem limit_topology (F : J \u2964 TopCatMax.{v, u}) :\n    (limit F).str = \u2a05 j, (F.obj j).str.induced (limit.\u03c0 F j)", "start": [149, 1], "end": [151, 41], "kind": "commanddeclaration"}, {"full_name": "TopCat.prodFst", "code": "abbrev prodFst {X Y : TopCat.{u}} : TopCat.of (X \u00d7 Y) \u27f6 X :=\n  \u27e8Prod.fst, by continuity\u27e9", "start": [157, 1], "end": [159, 28], "kind": "commanddeclaration"}, {"full_name": "TopCat.prodSnd", "code": "abbrev prodSnd {X Y : TopCat.{u}} : TopCat.of (X \u00d7 Y) \u27f6 Y :=\n  \u27e8Prod.snd, by continuity\u27e9", "start": [162, 1], "end": [164, 28], "kind": "commanddeclaration"}, {"full_name": "TopCat.prodBinaryFan", "code": "def prodBinaryFan (X Y : TopCat.{u}) : BinaryFan X Y :=\n  BinaryFan.mk prodFst prodSnd", "start": [167, 1], "end": [169, 31], "kind": "commanddeclaration"}, {"full_name": "TopCat.prodBinaryFanIsLimit", "code": "def prodBinaryFanIsLimit (X Y : TopCat.{u}) : IsLimit (prodBinaryFan X Y) where\n  lift := fun S : BinaryFan X Y => {\n    toFun := fun s => (S.fst s, S.snd s)\n    continuous_toFun := (Continuous.prod_mk)\n      (BinaryFan.fst S).continuous_toFun (BinaryFan.snd S).continuous_toFun }\n  fac := by\n    rintro S (_ | _) <;> {dsimp; ext; rfl}\n  uniq := by\n    intro S m h\n    refine' ContinuousMap.ext (fun (x : \u21a5(S.pt)) => Prod.ext _ _)\n    \u00b7 specialize h \u27e8WalkingPair.left\u27e9\n      apply_fun fun e => e x at h\n      exact h\n    \u00b7 specialize h \u27e8WalkingPair.right\u27e9\n      apply_fun fun e => e x at h\n      exact h", "start": [172, 1], "end": [191, 14], "kind": "commanddeclaration"}, {"full_name": "TopCat.prodIsoProd", "code": "def prodIsoProd (X Y : TopCat.{u}) : X \u2a2f Y \u2245 TopCat.of (X \u00d7 Y) :=\n  (limit.isLimit _).conePointUniqueUpToIso (prodBinaryFanIsLimit X Y)", "start": [194, 1], "end": [198, 70], "kind": "commanddeclaration"}, {"full_name": "TopCat.prodIsoProd_hom_fst", "code": "@[reassoc (attr := simp)]\ntheorem prodIsoProd_hom_fst (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).hom \u226b prodFst = Limits.prod.fst", "start": [201, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "TopCat.prodIsoProd_hom_snd", "code": "@[reassoc (attr := simp)]\ntheorem prodIsoProd_hom_snd (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).hom \u226b prodSnd = Limits.prod.snd", "start": [208, 1], "end": [212, 6], "kind": "commanddeclaration"}, {"full_name": "TopCat.prodIsoProd_hom_apply", "code": "@[simp]\ntheorem prodIsoProd_hom_apply {X Y : TopCat.{u}} (x : \u2191 (X \u2a2f Y)) :\n    (prodIsoProd X Y).hom x = ((Limits.prod.fst : X \u2a2f Y \u27f6 _) x,\n    (Limits.prod.snd : X \u2a2f Y \u27f6 _) x)", "start": [216, 1], "end": [223, 65], "kind": "commanddeclaration"}, {"full_name": "TopCat.prodIsoProd_inv_fst", "code": "@[reassoc (attr := simp), elementwise]\ntheorem prodIsoProd_inv_fst (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).inv \u226b Limits.prod.fst = prodFst", "start": [226, 1], "end": [228, 83], "kind": "commanddeclaration"}, {"full_name": "TopCat.prodIsoProd_inv_snd", "code": "@[reassoc (attr := simp), elementwise]\ntheorem prodIsoProd_inv_snd (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).inv \u226b Limits.prod.snd = prodSnd", "start": [231, 1], "end": [233, 83], "kind": "commanddeclaration"}, {"full_name": "TopCat.prod_topology", "code": "theorem prod_topology {X Y : TopCat.{u}} :\n    (X \u2a2f Y).str =\n      induced (Limits.prod.fst : X \u2a2f Y \u27f6 _) X.str \u2293\n        induced (Limits.prod.snd : X \u2a2f Y \u27f6 _) Y.str", "start": [236, 1], "end": [244, 6], "kind": "commanddeclaration"}, {"full_name": "TopCat.range_prod_map", "code": "theorem range_prod_map {W X Y Z : TopCat.{u}} (f : W \u27f6 Y) (g : X \u27f6 Z) :\n    Set.range (Limits.prod.map f g) =\n      (Limits.prod.fst : Y \u2a2f Z \u27f6 _) \u207b\u00b9' Set.range f \u2229\n        (Limits.prod.snd : Y \u2a2f Z \u27f6 _) \u207b\u00b9' Set.range g", "start": [247, 1], "end": [268, 16], "kind": "commanddeclaration"}, {"full_name": "TopCat.inducing_prod_map", "code": "theorem inducing_prod_map {W X Y Z : TopCat.{u}} {f : W \u27f6 X} {g : Y \u27f6 Z} (hf : Inducing f)\n    (hg : Inducing g) : Inducing (Limits.prod.map f g)", "start": [271, 1], "end": [277, 98], "kind": "commanddeclaration"}, {"full_name": "TopCat.embedding_prod_map", "code": "theorem embedding_prod_map {W X Y Z : TopCat.{u}} {f : W \u27f6 X} {g : Y \u27f6 Z} (hf : Embedding f)\n    (hg : Embedding g) : Embedding (Limits.prod.map f g)", "start": [280, 1], "end": [285, 58], "kind": "commanddeclaration"}, {"full_name": "TopCat.binaryCofan", "code": "protected def binaryCofan (X Y : TopCat.{u}) : BinaryCofan X Y :=\n  BinaryCofan.mk (\u27e8Sum.inl, by continuity\u27e9 : X \u27f6 TopCat.of (Sum X Y)) \u27e8Sum.inr, by continuity\u27e9", "start": [290, 1], "end": [292, 95], "kind": "commanddeclaration"}, {"full_name": "TopCat.binaryCofanIsColimit", "code": "def binaryCofanIsColimit (X Y : TopCat.{u}) : IsColimit (TopCat.binaryCofan X Y) := by\n  refine' Limits.BinaryCofan.isColimitMk (fun s =>\n    {toFun := Sum.elim s.inl s.inr, continuous_toFun := _ }) _ _ _\n  \u00b7 apply\n      Continuous.sum_elim (BinaryCofan.inl s).continuous_toFun (BinaryCofan.inr s).continuous_toFun\n  \u00b7 intro s\n    ext\n    rfl\n  \u00b7 intro s\n    ext\n    rfl\n  \u00b7 intro s m h\u2081 h\u2082\n    ext (x | x)\n    exacts [(ConcreteCategory.congr_hom h\u2081 x : _), (ConcreteCategory.congr_hom h\u2082 x : _)]", "start": [295, 1], "end": [309, 90], "kind": "commanddeclaration"}, {"full_name": "TopCat.binaryCofan_isColimit_iff", "code": "theorem binaryCofan_isColimit_iff {X Y : TopCat} (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) \u2194\n      OpenEmbedding c.inl \u2227 OpenEmbedding c.inr \u2227 IsCompl (Set.range c.inl) (Set.range c.inr)", "start": [312, 1], "end": [388, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/LocalizedModule.lean", "imports": ["Mathlib/RingTheory/Localization/Module.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Localization/Basic.lean", "Mathlib/GroupTheory/MonoidLocalization.lean", "Mathlib/Algebra/Algebra/RestrictScalars.lean", "Mathlib/RingTheory/IsTensorProduct.lean"], "premises": [{"full_name": "LocalizedModule.r", "code": "def r (a b : M \u00d7 S) : Prop :=\n  \u2203 u : S, u \u2022 b.2 \u2022 a.1 = u \u2022 a.2 \u2022 b.1", "start": [52, 1], "end": [56, 41], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.r.isEquiv", "code": "theorem r.isEquiv : IsEquiv _ (r S M)", "start": [59, 1], "end": [68, 60], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.r.setoid", "code": "instance r.setoid : Setoid (M \u00d7 S) where\n  r := r S M\n  iseqv := \u27e8(r.isEquiv S M).refl, (r.isEquiv S M).symm _ _, (r.isEquiv S M).trans _ _ _\u27e9", "start": [71, 1], "end": [73, 89], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule", "code": "def _root_.LocalizedModule : Type max u v :=\n  Quotient (r.setoid S M)", "start": [81, 1], "end": [86, 26], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.mk", "code": "def mk (m : M) (s : S) : LocalizedModule S M :=\n  Quotient.mk' \u27e8m, s\u27e9", "start": [93, 1], "end": [95, 22], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.mk_eq", "code": "theorem mk_eq {m m' : M} {s s' : S} : mk m s = mk m' s' \u2194 \u2203 u : S, u \u2022 s' \u2022 m = u \u2022 s \u2022 m'", "start": [98, 1], "end": [99, 15], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.induction_on", "code": "@[elab_as_elim]\ntheorem induction_on {\u03b2 : LocalizedModule S M \u2192 Prop} (h : \u2200 (m : M) (s : S), \u03b2 (mk m s)) :\n    \u2200 x : LocalizedModule S M, \u03b2 x", "start": [102, 1], "end": [106, 14], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.induction_on\u2082", "code": "@[elab_as_elim]\ntheorem induction_on\u2082 {\u03b2 : LocalizedModule S M \u2192 LocalizedModule S M \u2192 Prop}\n    (h : \u2200 (m m' : M) (s s' : S), \u03b2 (mk m s) (mk m' s')) : \u2200 x y, \u03b2 x y", "start": [109, 1], "end": [113, 20], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.liftOn", "code": "def liftOn {\u03b1 : Type*} (x : LocalizedModule S M) (f : M \u00d7 S \u2192 \u03b1)\n    (wd : \u2200 (p p' : M \u00d7 S), p \u2248 p' \u2192 f p = f p') : \u03b1 :=\n  Quotient.liftOn x f wd", "start": [116, 1], "end": [121, 25], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.liftOn_mk", "code": "theorem liftOn_mk {\u03b1 : Type*} {f : M \u00d7 S \u2192 \u03b1} (wd : \u2200 (p p' : M \u00d7 S), p \u2248 p' \u2192 f p = f p')\n    (m : M) (s : S) : liftOn (mk m s) f wd = f \u27e8m, s\u27e9", "start": [124, 1], "end": [125, 99], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.liftOn\u2082", "code": "def liftOn\u2082 {\u03b1 : Type*} (x y : LocalizedModule S M) (f : M \u00d7 S \u2192 M \u00d7 S \u2192 \u03b1)\n    (wd : \u2200 (p q p' q' : M \u00d7 S), p \u2248 p' \u2192 q \u2248 q' \u2192 f p q = f p' q') : \u03b1 :=\n  Quotient.liftOn\u2082 x y f wd", "start": [128, 1], "end": [133, 28], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.liftOn\u2082_mk", "code": "theorem liftOn\u2082_mk {\u03b1 : Type*} (f : M \u00d7 S \u2192 M \u00d7 S \u2192 \u03b1)\n    (wd : \u2200 (p q p' q' : M \u00d7 S), p \u2248 p' \u2192 q \u2248 q' \u2192 f p q = f p' q') (m m' : M)\n    (s s' : S) : liftOn\u2082 (mk m s) (mk m' s') f wd = f \u27e8m, s\u27e9 \u27e8m', s'\u27e9", "start": [136, 1], "end": [139, 39], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.zero_mk", "code": "@[simp]\ntheorem zero_mk (s : S) : mk (0 : M) s = 0", "start": [145, 1], "end": [147, 66], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.mk_add_mk", "code": "theorem mk_add_mk {m1 m2 : M} {s1 s2 : S} :\n    mk m1 s1 + mk m2 s2 = mk (s2 \u2022 m1 + s1 \u2022 m2) (s1 * s2)", "start": [163, 1], "end": [165, 24], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.add_assoc'", "code": "private theorem add_assoc' (x y z : LocalizedModule S M) : x + y + z = x + (y + z)", "start": [168, 1], "end": [179, 96], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.add_comm'", "code": "private theorem add_comm' (x y : LocalizedModule S M) : x + y = y + x", "start": [181, 1], "end": [183, 8], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.zero_add'", "code": "private theorem zero_add' (x : LocalizedModule S M) : 0 + x = x", "start": [185, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.add_zero'", "code": "private theorem add_zero' (x : LocalizedModule S M) : x + 0 = x", "start": [192, 1], "end": [197, 6], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.hasNatSMul", "code": "instance hasNatSMul : SMul \u2115 (LocalizedModule S M) where smul n := nsmulRec n", "start": [199, 1], "end": [199, 78], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.nsmul_zero'", "code": "private theorem nsmul_zero' (x : LocalizedModule S M) : (0 : \u2115) \u2022 x = 0", "start": [202, 1], "end": [203, 50], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.nsmul_succ'", "code": "private theorem nsmul_succ' (n : \u2115) (x : LocalizedModule S M) : n.succ \u2022 x = x + n \u2022 x", "start": [205, 1], "end": [206, 50], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.mk_neg", "code": "theorem mk_neg {M : Type*} [AddCommGroup M] [Module R M] {m : M} {s : S} : mk (-m) s = -mk m s", "start": [236, 1], "end": [237, 6], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.mk_mul_mk", "code": "theorem mk_mul_mk {A : Type*} [Semiring A] [Algebra R A] {a\u2081 a\u2082 : A} {s\u2081 s\u2082 : S} :\n    mk a\u2081 s\u2081 * mk a\u2082 s\u2082 = mk (a\u2081 * a\u2082) (s\u2081 * s\u2082)", "start": [307, 1], "end": [309, 6], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.mk_smul_mk", "code": "theorem mk_smul_mk (r : R) (m : M) (s t : S) :\n    Localization.mk r s \u2022 mk m t = mk (r \u2022 m) (s * t)", "start": [335, 1], "end": [338, 41], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.one_smul'", "code": "private theorem one_smul' (m : LocalizedModule S M) : (1 : Localization S) \u2022 m = m", "start": [341, 1], "end": [343, 60], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.mul_smul'", "code": "private theorem mul_smul' (x y : Localization S) (m : LocalizedModule S M) :\n    (x * y) \u2022 m = x \u2022 y \u2022 m", "start": [345, 1], "end": [351, 84], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.smul_add'", "code": "private theorem smul_add' (x : Localization S) (y z : LocalizedModule S M) :\n    x \u2022 (y + z) = x \u2022 y + x \u2022 z", "start": [353, 1], "end": [362, 10], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.smul_zero'", "code": "private theorem smul_zero' (x : Localization S) : x \u2022 (0 : LocalizedModule S M) = 0", "start": [364, 1], "end": [367, 60], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.add_smul'", "code": "private theorem add_smul' (x y : Localization S) (z : LocalizedModule S M) :\n    (x + y) \u2022 z = x \u2022 z + y \u2022 z", "start": [369, 1], "end": [381, 10], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.zero_smul'", "code": "private theorem zero_smul' (x : LocalizedModule S M) : (0 : Localization S) \u2022 x = 0", "start": [383, 1], "end": [385, 64], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.isModule", "code": "instance isModule : Module (Localization S) (LocalizedModule S M) where\n  smul := (\u00b7 \u2022 \u00b7)\n  one_smul := one_smul'\n  mul_smul := mul_smul'\n  smul_add := smul_add'\n  smul_zero := smul_zero'\n  add_smul := add_smul'\n  zero_smul := zero_smul'", "start": [387, 1], "end": [394, 26], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.mk_cancel_common_left", "code": "@[simp]\ntheorem mk_cancel_common_left (s' s : S) (m : M) : mk (s' \u2022 m) (s' * s) = mk m s", "start": [397, 1], "end": [402, 22], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.mk_cancel", "code": "@[simp]\ntheorem mk_cancel (s : S) (m : M) : mk (s \u2022 m) s = mk m 1", "start": [405, 1], "end": [407, 25], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.mk_cancel_common_right", "code": "@[simp]\ntheorem mk_cancel_common_right (s s' : S) (m : M) : mk (s' \u2022 m) (s * s') = mk m s", "start": [410, 1], "end": [412, 36], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.isModule'", "code": "instance isModule' : Module R (LocalizedModule S M) :=\n  { Module.compHom (LocalizedModule S M) <| algebraMap R (Localization S) with }", "start": [415, 1], "end": [416, 81], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.smul'_mk", "code": "theorem smul'_mk (r : R) (s : S) (m : M) : r \u2022 mk m s = mk (r \u2022 m) s", "start": [419, 1], "end": [420, 36], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.algebraMap_mk", "code": "theorem algebraMap_mk {A : Type*} [Semiring A] [Algebra R A] (a : R) (s : S) :\n    algebraMap _ _ (Localization.mk a s) = mk (algebraMap R A a) s", "start": [441, 1], "end": [445, 59], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.algebra'", "code": "instance algebra' {A : Type*} [Semiring A] [Algebra R A] : Algebra R (LocalizedModule S A) :=\n  { (algebraMap (Localization S) (LocalizedModule S A)).comp (algebraMap R <| Localization S),\n    show Module R (LocalizedModule S A) by infer_instance with\n    commutes' := by\n      intro r x\n      obtain \u27e8\u27e8a, s\u27e9, rfl : mk a s = x\u27e9 := Quotient.exists_rep x\n      dsimp\n      rw [\u2190 Localization.mk_one_eq_algebraMap, algebraMap_mk, mk_mul_mk, mk_mul_mk, mul_comm,\n        Algebra.commutes]\n    smul_def' := by\n      intro r x\n      obtain \u27e8\u27e8a, s\u27e9, rfl : mk a s = x\u27e9 := Quotient.exists_rep x\n      dsimp\n      rw [\u2190 Localization.mk_one_eq_algebraMap, algebraMap_mk, mk_mul_mk, smul'_mk,\n        Algebra.smul_def, one_mul] }", "start": [451, 1], "end": [465, 37], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.mkLinearMap", "code": "@[simps]\ndef mkLinearMap : M \u2192\u2097[R] LocalizedModule S M where\n  toFun m := mk m 1\n  map_add' x y := by simp [mk_add_mk]\n  map_smul' r x := (smul'_mk _ _ _).symm", "start": [472, 1], "end": [478, 41], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.divBy", "code": "@[simps]\ndef divBy (s : S) : LocalizedModule S M \u2192\u2097[R] LocalizedModule S M where\n  toFun p :=\n    p.liftOn (fun p => mk p.1 (s * p.2)) fun \u27e8a, b\u27e9 \u27e8a', b'\u27e9 \u27e8c, eq1\u27e9 =>\n      mk_eq.mpr \u27e8c, by rw [mul_smul, mul_smul, smul_comm c, eq1, smul_comm s]\u27e9\n  map_add' x y :=\n    x.induction_on\u2082\n      (by\n        intro m\u2081 m\u2082 t\u2081 t\u2082\n        simp only [mk_add_mk, LocalizedModule.liftOn_mk, mul_smul, \u2190 smul_add, mul_assoc,\n          mk_cancel_common_left s]\n        rw [show s * (t\u2081 * t\u2082) = t\u2081 * (s * t\u2082) by\n            ext\n            simp only [Submonoid.coe_mul]\n            ring])\n      y\n  map_smul' r x :=\n    x.inductionOn <| by\n      intro\n      dsimp only\n      change liftOn (mk _ _) _ _ = r \u2022 (liftOn (mk _ _) _ _)\n      simp [LocalizedModule.liftOn_mk, smul'_mk]", "start": [483, 1], "end": [506, 49], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.divBy_mul_by", "code": "theorem divBy_mul_by (s : S) (p : LocalizedModule S M) :\n    divBy s (algebraMap R (Module.End R (LocalizedModule S M)) s p) = p", "start": [509, 1], "end": [518, 38], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.mul_by_divBy", "code": "theorem mul_by_divBy (s : S) (p : LocalizedModule S M) :\n    algebraMap R (Module.End R (LocalizedModule S M)) s (divBy s p) = p", "start": [521, 1], "end": [529, 38], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule", "code": "class IsLocalizedModule : Prop where\n  map_units : \u2200 x : S, IsUnit (algebraMap R (Module.End R M') x)\n  surj' : \u2200 y : M', \u2203 x : M \u00d7 S, x.2 \u2022 y = f x.1\n  eq_iff_exists' : \u2200 {x\u2081 x\u2082}, f x\u2081 = f x\u2082 \u2194 \u2203 c : S, c \u2022 x\u2082 = c \u2022 x\u2081", "start": [546, 1], "end": [553, 69], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.surj", "code": "lemma IsLocalizedModule.surj [IsLocalizedModule S f] (y : M') : \u2203 x : M \u00d7 S, x.2 \u2022 y = f x.1 :=\n  surj' y", "start": [560, 1], "end": [561, 10], "kind": "mathlibtacticlemma"}, {"full_name": "IsLocalizedModule.eq_iff_exists", "code": "lemma IsLocalizedModule.eq_iff_exists [IsLocalizedModule S f] {x\u2081 x\u2082} :\n    f x\u2081 = f x\u2082 \u2194 \u2203 c : S, c \u2022 x\u2082 = c \u2022 x\u2081 :=\neq_iff_exists'", "start": [564, 1], "end": [566, 15], "kind": "mathlibtacticlemma"}, {"full_name": "LocalizedModule.lift'", "code": "noncomputable def lift' (g : M \u2192\u2097[R] M'')\n    (h : \u2200 x : S, IsUnit (algebraMap R (Module.End R M'') x)) : LocalizedModule S M \u2192 M'' :=\n  fun m =>\n  m.liftOn (fun p => (h p.2).unit\u207b\u00b9.val <| g p.1) fun \u27e8m, s\u27e9 \u27e8m', s'\u27e9 \u27e8c, eq1\u27e9 => by\n    dsimp only\n    simp only [Submonoid.smul_def] at eq1\n    rw [Module.End_algebraMap_isUnit_inv_apply_eq_iff, \u2190 map_smul, eq_comm,\n      Module.End_algebraMap_isUnit_inv_apply_eq_iff]\n    have : c \u2022 s \u2022 g m' = c \u2022 s' \u2022 g m := by\n      simp only [Submonoid.smul_def, \u2190 g.map_smul, eq1]\n    have : Function.Injective (h c).unit.inv := by\n      rw [Function.injective_iff_hasLeftInverse]\n      refine' \u27e8(h c).unit, _\u27e9\n      intro x\n      change ((h c).unit.1 * (h c).unit.inv) x = x\n      simp only [Units.inv_eq_val_inv, IsUnit.mul_val_inv, LinearMap.one_apply]\n    apply_fun (h c).unit.inv\n    erw [Units.inv_eq_val_inv, Module.End_algebraMap_isUnit_inv_apply_eq_iff, \u2190\n      (h c).unit\u207b\u00b9.val.map_smul]\n    symm\n    rw [Module.End_algebraMap_isUnit_inv_apply_eq_iff, \u2190 g.map_smul, \u2190 g.map_smul, \u2190 g.map_smul, \u2190\n      g.map_smul, eq1]", "start": [570, 1], "end": [596, 23], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.lift'_mk", "code": "theorem lift'_mk (g : M \u2192\u2097[R] M'') (h : \u2200 x : S, IsUnit ((algebraMap R (Module.End R M'')) x))\n    (m : M) (s : S) :\n    LocalizedModule.lift' S g h (LocalizedModule.mk m s) = (h s).unit\u207b\u00b9.val (g m)", "start": [599, 1], "end": [602, 6], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.lift'_add", "code": "theorem lift'_add (g : M \u2192\u2097[R] M'') (h : \u2200 x : S, IsUnit ((algebraMap R (Module.End R M'')) x))\n    (x y) :\n    LocalizedModule.lift' S g h (x + y) =\n      LocalizedModule.lift' S g h x + LocalizedModule.lift' S g h y", "start": [605, 1], "end": [622, 8], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.lift'_smul", "code": "theorem lift'_smul (g : M \u2192\u2097[R] M'') (h : \u2200 x : S, IsUnit ((algebraMap R (Module.End R M'')) x))\n    (r : R) (m) : r \u2022 LocalizedModule.lift' S g h m = LocalizedModule.lift' S g h (r \u2022 m)", "start": [625, 1], "end": [632, 38], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.lift", "code": "noncomputable def lift (g : M \u2192\u2097[R] M'')\n    (h : \u2200 x : S, IsUnit ((algebraMap R (Module.End R M'')) x)) : LocalizedModule S M \u2192\u2097[R] M''\n    where\n  toFun := LocalizedModule.lift' S g h\n  map_add' := LocalizedModule.lift'_add S g h\n  map_smul' r x := by rw [LocalizedModule.lift'_smul, RingHom.id_apply]", "start": [635, 1], "end": [644, 72], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.lift_mk", "code": "theorem lift_mk\n    (g : M \u2192\u2097[R] M'') (h : \u2200 x : S, IsUnit (algebraMap R (Module.End R M'') x)) (m : M) (s : S) :\n    LocalizedModule.lift S g h (LocalizedModule.mk m s) = (h s).unit\u207b\u00b9.val (g m)", "start": [647, 1], "end": [654, 6], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.lift_comp", "code": "theorem lift_comp (g : M \u2192\u2097[R] M'') (h : \u2200 x : S, IsUnit ((algebraMap R (Module.End R M'')) x)) :\n    (lift S g h).comp (mkLinearMap S M) = g", "start": [657, 1], "end": [664, 64], "kind": "commanddeclaration"}, {"full_name": "LocalizedModule.lift_unique", "code": "theorem lift_unique (g : M \u2192\u2097[R] M'') (h : \u2200 x : S, IsUnit ((algebraMap R (Module.End R M'')) x))\n    (l : LocalizedModule S M \u2192\u2097[R] M'') (hl : l.comp (LocalizedModule.mkLinearMap S M) = g) :\n    LocalizedModule.lift S g h = l", "start": [667, 1], "end": [680, 59], "kind": "commanddeclaration"}, {"full_name": "localizedModuleIsLocalizedModule", "code": "instance localizedModuleIsLocalizedModule : IsLocalizedModule S (LocalizedModule.mkLinearMap S M)\n    where\n  map_units s :=\n    \u27e8\u27e8algebraMap R (Module.End R (LocalizedModule S M)) s, LocalizedModule.divBy s,\n        FunLike.ext _ _ <| LocalizedModule.mul_by_divBy s,\n        FunLike.ext _ _ <| LocalizedModule.divBy_mul_by s\u27e9,\n      FunLike.ext _ _ fun p =>\n        p.inductionOn <| by\n          intros\n          rfl\u27e9\n  surj' p :=\n    p.inductionOn\n      (by\n        intro \u27e8m, t\u27e9\n        refine' \u27e8\u27e8m, t\u27e9, _\u27e9\n        erw [LocalizedModule.smul'_mk, LocalizedModule.mkLinearMap_apply, Submonoid.coe_subtype,\n          LocalizedModule.mk_cancel t])\n  eq_iff_exists' :=\n    { mp := fun eq1 => by simpa only [eq_comm, one_smul] using LocalizedModule.mk_eq.mp eq1\n      mpr := fun \u27e8c, eq1\u27e9 =>\n        LocalizedModule.mk_eq.mpr \u27e8c, by simpa only [eq_comm, one_smul] using eq1\u27e9 }", "start": [685, 1], "end": [705, 85], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.fromLocalizedModule'", "code": "noncomputable def fromLocalizedModule' : LocalizedModule S M \u2192 M' := fun p =>\n  p.liftOn (fun x => (IsLocalizedModule.map_units f x.2).unit\u207b\u00b9.val (f x.1))\n    (by\n      rintro \u27e8a, b\u27e9 \u27e8a', b'\u27e9 \u27e8c, eq1\u27e9\n      dsimp\n      erw [Module.End_algebraMap_isUnit_inv_apply_eq_iff, \u2190map_smul, \u2190map_smul,\n        Module.End_algebraMap_isUnit_inv_apply_eq_iff', \u2190map_smul]\n      exact (IsLocalizedModule.eq_iff_exists S f).mpr \u27e8c, eq1\u27e9)", "start": [712, 1], "end": [723, 64], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.fromLocalizedModule'_mk", "code": "@[simp]\ntheorem fromLocalizedModule'_mk (m : M) (s : S) :\n    fromLocalizedModule' S f (LocalizedModule.mk m s) =\n      (IsLocalizedModule.map_units f s).unit\u207b\u00b9.val (f m)", "start": [726, 1], "end": [730, 6], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.fromLocalizedModule'_add", "code": "theorem fromLocalizedModule'_add (x y : LocalizedModule S M) :\n    fromLocalizedModule' S f (x + y) = fromLocalizedModule' S f x + fromLocalizedModule' S f y", "start": [733, 1], "end": [748, 8], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.fromLocalizedModule'_smul", "code": "theorem fromLocalizedModule'_smul (r : R) (x : LocalizedModule S M) :\n    r \u2022 fromLocalizedModule' S f x = fromLocalizedModule' S f (r \u2022 x)", "start": [751, 1], "end": [759, 6], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.fromLocalizedModule", "code": "noncomputable def fromLocalizedModule : LocalizedModule S M \u2192\u2097[R] M' where\n  toFun := fromLocalizedModule' S f\n  map_add' := fromLocalizedModule'_add S f\n  map_smul' r x := by rw [fromLocalizedModule'_smul, RingHom.id_apply]", "start": [762, 1], "end": [768, 71], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.fromLocalizedModule_mk", "code": "theorem fromLocalizedModule_mk (m : M) (s : S) :\n    fromLocalizedModule S f (LocalizedModule.mk m s) =\n      (IsLocalizedModule.map_units f s).unit\u207b\u00b9.val (f m)", "start": [771, 1], "end": [774, 6], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.fromLocalizedModule.inj", "code": "theorem fromLocalizedModule.inj : Function.Injective <| fromLocalizedModule S f", "start": [777, 1], "end": [786, 29], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.fromLocalizedModule.surj", "code": "theorem fromLocalizedModule.surj : Function.Surjective <| fromLocalizedModule S f", "start": [789, 1], "end": [793, 27], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.fromLocalizedModule.bij", "code": "theorem fromLocalizedModule.bij : Function.Bijective <| fromLocalizedModule S f", "start": [796, 1], "end": [797, 62], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.iso", "code": "@[simps!]\nnoncomputable def iso : LocalizedModule S M \u2243\u2097[R] M' :=\n  { fromLocalizedModule S f,\n    Equiv.ofBijective (fromLocalizedModule S f) <| fromLocalizedModule.bij _ _ with }", "start": [800, 1], "end": [807, 86], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.iso_apply_mk", "code": "theorem iso_apply_mk (m : M) (s : S) :\n    iso S f (LocalizedModule.mk m s) = (IsLocalizedModule.map_units f s).unit\u207b\u00b9.val (f m)", "start": [810, 1], "end": [812, 6], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.iso_symm_apply_aux", "code": "theorem iso_symm_apply_aux (m : M') :\n    (iso S f).symm m =\n      LocalizedModule.mk (IsLocalizedModule.surj S f m).choose.1\n        (IsLocalizedModule.surj S f m).choose.2", "start": [815, 1], "end": [823, 78], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.iso_symm_apply'", "code": "theorem iso_symm_apply' (m : M') (a : M) (b : S) (eq1 : b \u2022 m = f a) :\n    (iso S f).symm m = LocalizedModule.mk a b", "start": [827, 1], "end": [833, 43], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.iso_symm_comp", "code": "theorem iso_symm_comp : (iso S f).symm.toLinearMap.comp f = LocalizedModule.mkLinearMap S M", "start": [836, 1], "end": [838, 72], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.lift", "code": "noncomputable def lift (g : M \u2192\u2097[R] M'')\n    (h : \u2200 x : S, IsUnit ((algebraMap R (Module.End R M'')) x)) : M' \u2192\u2097[R] M'' :=\n  (LocalizedModule.lift S g h).comp (iso S f).symm.toLinearMap", "start": [841, 1], "end": [847, 63], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.lift_comp", "code": "theorem lift_comp (g : M \u2192\u2097[R] M'') (h : \u2200 x : S, IsUnit ((algebraMap R (Module.End R M'')) x)) :\n    (lift S f g h).comp f = g", "start": [850, 1], "end": [853, 76], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.lift_unique", "code": "theorem lift_unique (g : M \u2192\u2097[R] M'') (h : \u2200 x : S, IsUnit ((algebraMap R (Module.End R M'')) x))\n    (l : M' \u2192\u2097[R] M'') (hl : l.comp f = g) : lift S f g h = l", "start": [856, 1], "end": [868, 16], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.is_universal", "code": "theorem is_universal :\n    \u2200 (g : M \u2192\u2097[R] M'') (_ : \u2200 x : S, IsUnit ((algebraMap R (Module.End R M'')) x)),\n      \u2203! l : M' \u2192\u2097[R] M'', l.comp f = g", "start": [871, 1], "end": [888, 92], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.ringHom_ext", "code": "theorem ringHom_ext (map_unit : \u2200 x : S, IsUnit ((algebraMap R (Module.End R M'')) x))\n    \u2983j k : M' \u2192\u2097[R] M''\u2984 (h : j.comp f = k.comp f) : j = k", "start": [891, 1], "end": [894, 6], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.linearEquiv", "code": "noncomputable def linearEquiv [IsLocalizedModule S g] : M' \u2243\u2097[R] M'' :=\n  (iso S f).symm.trans (iso S g)", "start": [897, 1], "end": [901, 33], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.smul_injective", "code": "theorem smul_injective (s : S) : Function.Injective fun m : M' => s \u2022 m", "start": [906, 1], "end": [907, 77], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.smul_inj", "code": "theorem smul_inj (s : S) (m\u2081 m\u2082 : M') : s \u2022 m\u2081 = s \u2022 m\u2082 \u2194 m\u2081 = m\u2082", "start": [910, 1], "end": [911, 30], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'", "code": "noncomputable def mk' (m : M) (s : S) : M' :=\n  fromLocalizedModule S f (LocalizedModule.mk m s)", "start": [914, 1], "end": [916, 51], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_smul", "code": "theorem mk'_smul (r : R) (m : M) (s : S) : mk' f (r \u2022 m) s = r \u2022 mk' f m s", "start": [919, 1], "end": [921, 54], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_add_mk'", "code": "theorem mk'_add_mk' (m\u2081 m\u2082 : M) (s\u2081 s\u2082 : S) :\n    mk' f m\u2081 s\u2081 + mk' f m\u2082 s\u2082 = mk' f (s\u2082 \u2022 m\u2081 + s\u2081 \u2022 m\u2082) (s\u2081 * s\u2082)", "start": [924, 1], "end": [927, 44], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_zero", "code": "@[simp]\ntheorem mk'_zero (s : S) : mk' f 0 s = 0", "start": [930, 1], "end": [931, 95], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_one", "code": "@[simp]\ntheorem mk'_one (m : M) : mk' f m (1 : S) = f m", "start": [936, 1], "end": [940, 14], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_cancel", "code": "@[simp]\ntheorem mk'_cancel (m : M) (s : S) : mk' f (s \u2022 m) s = f m", "start": [945, 1], "end": [949, 91], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_cancel'", "code": "@[simp]\ntheorem mk'_cancel' (m : M) (s : S) : s \u2022 mk' f m s = f m", "start": [952, 1], "end": [954, 72], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_cancel_left", "code": "@[simp]\ntheorem mk'_cancel_left (m : M) (s\u2081 s\u2082 : S) : mk' f (s\u2081 \u2022 m) (s\u2081 * s\u2082) = mk' f m s\u2082", "start": [957, 1], "end": [960, 45], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_cancel_right", "code": "@[simp]\ntheorem mk'_cancel_right (m : M) (s\u2081 s\u2082 : S) : mk' f (s\u2082 \u2022 m) (s\u2081 * s\u2082) = mk' f m s\u2081", "start": [963, 1], "end": [966, 46], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_add", "code": "theorem mk'_add (m\u2081 m\u2082 : M) (s : S) : mk' f (m\u2081 + m\u2082) s = mk' f m\u2081 s + mk' f m\u2082 s", "start": [969, 1], "end": [970, 48], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_eq_mk'_iff", "code": "theorem mk'_eq_mk'_iff (m\u2081 m\u2082 : M) (s\u2081 s\u2082 : S) :\n    mk' f m\u2081 s\u2081 = mk' f m\u2082 s\u2082 \u2194 \u2203 s : S, s \u2022 s\u2081 \u2022 m\u2082 = s \u2022 s\u2082 \u2022 m\u2081", "start": [973, 1], "end": [977, 20], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_neg", "code": "theorem mk'_neg {M M' : Type*} [AddCommGroup M] [AddCommGroup M'] [Module R M] [Module R M']\n    (f : M \u2192\u2097[R] M') [IsLocalizedModule S f] (m : M) (s : S) : mk' f (-m) s = -mk' f m s", "start": [980, 1], "end": [983, 39], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_sub", "code": "theorem mk'_sub {M M' : Type*} [AddCommGroup M] [AddCommGroup M'] [Module R M] [Module R M']\n    (f : M \u2192\u2097[R] M') [IsLocalizedModule S f] (m\u2081 m\u2082 : M) (s : S) :\n    mk' f (m\u2081 - m\u2082) s = mk' f m\u2081 s - mk' f m\u2082 s", "start": [986, 1], "end": [989, 56], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_sub_mk'", "code": "theorem mk'_sub_mk' {M M' : Type*} [AddCommGroup M] [AddCommGroup M'] [Module R M] [Module R M']\n    (f : M \u2192\u2097[R] M') [IsLocalizedModule S f] (m\u2081 m\u2082 : M) (s\u2081 s\u2082 : S) :\n    mk' f m\u2081 s\u2081 - mk' f m\u2082 s\u2082 = mk' f (s\u2082 \u2022 m\u2081 - s\u2081 \u2022 m\u2082) (s\u2081 * s\u2082)", "start": [992, 1], "end": [995, 74], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_mul_mk'_of_map_mul", "code": "theorem mk'_mul_mk'_of_map_mul {M M' : Type*} [Semiring M] [Semiring M'] [Module R M]\n    [Algebra R M'] (f : M \u2192\u2097[R] M') (hf : \u2200 m\u2081 m\u2082, f (m\u2081 * m\u2082) = f m\u2081 * f m\u2082)\n    [IsLocalizedModule S f] (m\u2081 m\u2082 : M) (s\u2081 s\u2082 : S) :\n    mk' f m\u2081 s\u2081 * mk' f m\u2082 s\u2082 = mk' f (m\u2081 * m\u2082) (s\u2081 * s\u2082)", "start": [998, 1], "end": [1006, 62], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_mul_mk'", "code": "theorem mk'_mul_mk' {M M' : Type*} [Semiring M] [Semiring M'] [Algebra R M] [Algebra R M']\n    (f : M \u2192\u2090[R] M') [IsLocalizedModule S f.toLinearMap] (m\u2081 m\u2082 : M) (s\u2081 s\u2082 : S) :\n    mk' f.toLinearMap m\u2081 s\u2081 * mk' f.toLinearMap m\u2082 s\u2082 = mk' f.toLinearMap (m\u2081 * m\u2082) (s\u2081 * s\u2082)", "start": [1009, 1], "end": [1012, 61], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_eq_iff", "code": "theorem mk'_eq_iff {m : M} {s : S} {m' : M'} : mk' f m s = m' \u2194 f m = s \u2022 m'", "start": [1017, 1], "end": [1020, 88], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_eq_zero", "code": "@[simp]\ntheorem mk'_eq_zero {m : M} (s : S) : mk' f m s = 0 \u2194 f m = 0", "start": [1023, 1], "end": [1024, 95], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_eq_zero'", "code": "theorem mk'_eq_zero' {m : M} (s : S) : mk' f m s = 0 \u2194 \u2203 s' : S, s' \u2022 m = 0", "start": [1029, 1], "end": [1030, 79], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk_eq_mk'", "code": "theorem mk_eq_mk' (s : S) (m : M) :\n    LocalizedModule.mk m s = mk' (LocalizedModule.mkLinearMap S M) m s", "start": [1033, 1], "end": [1036, 66], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.eq_zero_iff", "code": "theorem eq_zero_iff {m : M} : f m = 0 \u2194 \u2203 s' : S, s' \u2022 m = 0", "start": [1041, 1], "end": [1042, 54], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mk'_surjective", "code": "theorem mk'_surjective : Function.Surjective (Function.uncurry <| mk' f : M \u00d7 S \u2192 M')", "start": [1045, 1], "end": [1048, 40], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.mkOfAlgebra", "code": "theorem mkOfAlgebra {R S S' : Type*} [CommRing R] [CommRing S] [CommRing S'] [Algebra R S]\n    [Algebra R S'] (M : Submonoid R) (f : S \u2192\u2090[R] S') (h\u2081 : \u2200 x \u2208 M, IsUnit (algebraMap R S' x))\n    (h\u2082 : \u2200 y, \u2203 x : S \u00d7 M, x.2 \u2022 y = f x.1) (h\u2083 : \u2200 x, f x = 0 \u2192 \u2203 m : M, m \u2022 x = 0) :\n    IsLocalizedModule M f.toLinearMap", "start": [1053, 1], "end": [1077, 36], "kind": "commanddeclaration"}, {"full_name": "IsLocalizedModule.isBaseChange", "code": "theorem isBaseChange : IsBaseChange A f", "start": [1086, 1], "end": [1106, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/StructureSheaf.lean", "imports": ["Mathlib/Algebra/Category/Ring/Limits.lean", "Mathlib/RingTheory/Localization/AtPrime.lean", "Mathlib/Algebra/Category/Ring/Colimits.lean", "Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean", "Mathlib/Topology/Sheaves/LocalPredicate.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Subring/Basic.lean"], "premises": [{"full_name": "AlgebraicGeometry.PrimeSpectrum.Top", "code": "def PrimeSpectrum.Top : TopCat :=\n  TopCat.of (PrimeSpectrum R)", "start": [66, 1], "end": [69, 30], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.Localizations", "code": "def Localizations (P : PrimeSpectrum.Top R) : Type u :=\n  Localization.AtPrime P.asIdeal", "start": [75, 1], "end": [78, 33], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.commRingLocalizations", "code": "instance commRingLocalizations (P : PrimeSpectrum.Top R) : CommRing <| Localizations R P :=\n  inferInstanceAs <| CommRing <| Localization.AtPrime P.asIdeal", "start": [82, 1], "end": [83, 64], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.localRingLocalizations", "code": "instance localRingLocalizations (P : PrimeSpectrum.Top R) : LocalRing <| Localizations R P :=\n  inferInstanceAs <| LocalRing <| Localization.AtPrime P.asIdeal", "start": [86, 1], "end": [87, 65], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.IsFraction", "code": "def IsFraction {U : Opens (PrimeSpectrum.Top R)} (f : \u2200 x : U, Localizations R x) : Prop :=\n  \u2203 r s : R, \u2200 x : U, \u00acs \u2208 x.1.asIdeal \u2227 f x * algebraMap _ _ s = algebraMap _ _ r", "start": [101, 1], "end": [105, 83], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.IsFraction.eq_mk'", "code": "theorem IsFraction.eq_mk' {U : Opens (PrimeSpectrum.Top R)} {f : \u2200 x : U, Localizations R x}\n    (hf : IsFraction f) :\n    \u2203 r s : R,\n      \u2200 x : U,\n        \u2203 hs : s \u2209 x.1.asIdeal,\n          f x =\n            IsLocalization.mk' (Localization.AtPrime _) r\n              (\u27e8s, hs\u27e9 : (x : PrimeSpectrum.Top R).asIdeal.primeCompl)", "start": [108, 1], "end": [118, 21], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.isFractionPrelocal", "code": "def isFractionPrelocal : PrelocalPredicate (Localizations R) where\n  pred {U} f := IsFraction f\n  res := by rintro V U i f \u27e8r, s, w\u27e9; exact \u27e8r, s, fun x => w (i x)\u27e9", "start": [123, 1], "end": [128, 69], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.isLocallyFraction", "code": "def isLocallyFraction : LocalPredicate (Localizations R) :=\n  (isFractionPrelocal R).sheafify", "start": [131, 1], "end": [150, 34], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.isLocallyFraction_pred", "code": "@[simp]\ntheorem isLocallyFraction_pred {U : Opens (PrimeSpectrum.Top R)} (f : \u2200 x : U, Localizations R x) :\n    (isLocallyFraction R).pred f =\n      \u2200 x : U,\n        \u2203 (V : _) (_ : x.1 \u2208 V) (i : V \u27f6 U),\n          \u2203 r s : R,\n            \u2200 y : V, \u00acs \u2208 y.1.asIdeal \u2227 f (i y : U) * algebraMap _ _ s = algebraMap _ _ r", "start": [153, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.sectionsSubring", "code": "def sectionsSubring (U : (Opens (PrimeSpectrum.Top R))\u1d52\u1d56) :\n    Subring (\u2200 x : U.unop, Localizations R x) where\n  carrier := { f | (isLocallyFraction R).pred f }\n  zero_mem' := by\n    refine' fun x => \u27e8unop U, x.2, \ud835\udfd9 _, 0, 1, fun y => \u27e8_, _\u27e9\u27e9\n    \u00b7 rw [\u2190 Ideal.ne_top_iff_one]; exact y.1.IsPrime.1\n    \u00b7 simp\n  one_mem' := by\n    refine' fun x => \u27e8unop U, x.2, \ud835\udfd9 _, 1, 1, fun y => \u27e8_, _\u27e9\u27e9\n    \u00b7 rw [\u2190 Ideal.ne_top_iff_one]; exact y.1.IsPrime.1\n    \u00b7 simp\n  add_mem' := by\n    intro a b ha hb x\n    rcases ha x with \u27e8Va, ma, ia, ra, sa, wa\u27e9\n    rcases hb x with \u27e8Vb, mb, ib, rb, sb, wb\u27e9\n    refine' \u27e8Va \u2293 Vb, \u27e8ma, mb\u27e9, Opens.infLELeft _ _ \u226b ia, ra * sb + rb * sa, sa * sb, _\u27e9\n    intro y\n    rcases wa (Opens.infLELeft _ _ y) with \u27e8nma, wa\u27e9\n    rcases wb (Opens.infLERight _ _ y) with \u27e8nmb, wb\u27e9\n    fconstructor\n    \u00b7 intro H; cases y.1.IsPrime.mem_or_mem H <;> contradiction\n    \u00b7 simp only [add_mul, RingHom.map_add, Pi.add_apply, RingHom.map_mul]\n      erw [\u2190 wa, \u2190 wb]\n      simp only [mul_assoc]\n      congr 2\n      rw [mul_comm]\n  neg_mem' := by\n    intro a ha x\n    rcases ha x with \u27e8V, m, i, r, s, w\u27e9\n    refine' \u27e8V, m, i, -r, s, _\u27e9\n    intro y\n    rcases w y with \u27e8nm, w\u27e9\n    fconstructor\n    \u00b7 exact nm\n    \u00b7 simp only [RingHom.map_neg, Pi.neg_apply]\n      erw [\u2190 w]\n      simp only [neg_mul]\n  mul_mem' := by\n    intro a b ha hb x\n    rcases ha x with \u27e8Va, ma, ia, ra, sa, wa\u27e9\n    rcases hb x with \u27e8Vb, mb, ib, rb, sb, wb\u27e9\n    refine' \u27e8Va \u2293 Vb, \u27e8ma, mb\u27e9, Opens.infLELeft _ _ \u226b ia, ra * rb, sa * sb, _\u27e9\n    intro y\n    rcases wa (Opens.infLELeft _ _ y) with \u27e8nma, wa\u27e9\n    rcases wb (Opens.infLERight _ _ y) with \u27e8nmb, wb\u27e9\n    fconstructor\n    \u00b7 intro H; cases y.1.IsPrime.mem_or_mem H <;> contradiction\n    \u00b7 simp only [Pi.mul_apply, RingHom.map_mul]\n      erw [\u2190 wa, \u2190 wb]\n      simp only [mul_left_comm, mul_assoc, mul_comm]", "start": [163, 1], "end": [214, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.structureSheafInType", "code": "def structureSheafInType : Sheaf (Type u) (PrimeSpectrum.Top R) :=\n  subsheafToTypes (isLocallyFraction R)", "start": [221, 1], "end": [225, 40], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.commRingStructureSheafInTypeObj", "code": "instance commRingStructureSheafInTypeObj (U : (Opens (PrimeSpectrum.Top R))\u1d52\u1d56) :\n    CommRing ((structureSheafInType R).1.obj U) :=\n  (sectionsSubring R U).toCommRing", "start": [228, 1], "end": [230, 35], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.structurePresheafInCommRing", "code": "@[simps]\ndef structurePresheafInCommRing : Presheaf CommRingCat (PrimeSpectrum.Top R) where\n  obj U := CommRingCat.of ((structureSheafInType R).1.obj U)\n  map {U V} i :=\n    { toFun := (structureSheafInType R).1.map i\n      map_zero' := rfl\n      map_add' := fun x y => rfl\n      map_one' := rfl\n      map_mul' := fun x y => rfl }", "start": [235, 1], "end": [246, 35], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.structurePresheafCompForget", "code": "def structurePresheafCompForget :\n    structurePresheafInCommRing R \u22d9 forget CommRingCat \u2245 (structureSheafInType R).1 :=\n  NatIso.ofComponents fun U => Iso.refl _", "start": [253, 1], "end": [258, 42], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Spec.structureSheaf", "code": "def Spec.structureSheaf : Sheaf CommRingCat (PrimeSpectrum.Top R) :=\n  \u27e8structurePresheafInCommRing R,\n    (isSheaf_iff_isSheaf_comp\n          _ _).mpr\n      (isSheaf_of_iso (structurePresheafCompForget R).symm (structureSheafInType R).cond)\u27e9", "start": [264, 1], "end": [273, 91], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.res_apply", "code": "@[simp]\ntheorem res_apply (U V : Opens (PrimeSpectrum.Top R)) (i : V \u27f6 U)\n    (s : (structureSheaf R).1.obj (op U)) (x : V) :\n    ((structureSheaf R).1.map i.op s).1 x = (s.1 (i x) : _)", "start": [281, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.const", "code": "def const (f g : R) (U : Opens (PrimeSpectrum.Top R))\n    (hu : \u2200 x \u2208 U, g \u2208 (x : PrimeSpectrum.Top R).asIdeal.primeCompl) :\n    (structureSheaf R).1.obj (op U) :=\n  \u27e8fun x => IsLocalization.mk' _ f \u27e8g, hu x x.2\u27e9, fun x =>\n    \u27e8U, x.2, \ud835\udfd9 _, f, g, fun y => \u27e8hu y y.2, IsLocalization.mk'_spec _ _ _\u27e9\u27e9\u27e9", "start": [312, 1], "end": [318, 77], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.const_apply", "code": "@[simp]\ntheorem const_apply (f g : R) (U : Opens (PrimeSpectrum.Top R))\n    (hu : \u2200 x \u2208 U, g \u2208 (x : PrimeSpectrum.Top R).asIdeal.primeCompl) (x : U) :\n    (const R f g U hu).1 x = IsLocalization.mk' _ f \u27e8g, hu x x.2\u27e9", "start": [321, 1], "end": [325, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.const_apply'", "code": "theorem const_apply' (f g : R) (U : Opens (PrimeSpectrum.Top R))\n    (hu : \u2200 x \u2208 U, g \u2208 (x : PrimeSpectrum.Top R).asIdeal.primeCompl) (x : U)\n    (hx : g \u2208 (x : PrimeSpectrum.Top R).asIdeal.primeCompl) :\n    (const R f g U hu).1 x = IsLocalization.mk' _ f \u27e8g, hx\u27e9", "start": [328, 1], "end": [332, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.exists_const", "code": "theorem exists_const (U) (s : (structureSheaf R).1.obj (op U)) (x : PrimeSpectrum.Top R)\n    (hx : x \u2208 U) :\n    \u2203 (V : Opens (PrimeSpectrum.Top R)) (_ : x \u2208 V) (i : V \u27f6 U) (f g : R) (hg : _),\n      const R f g V hg = (structureSheaf R).1.map i.op s", "start": [335, 1], "end": [341, 94], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.res_const", "code": "@[simp]\ntheorem res_const (f g : R) (U hu V hv i) :\n    (structureSheaf R).1.map i (const R f g U hu) = const R f g V hv", "start": [344, 1], "end": [347, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.res_const'", "code": "theorem res_const' (f g : R) (V hv) :\n    (structureSheaf R).1.map (homOfLE hv).op (const R f g (PrimeSpectrum.basicOpen g) fun _ => id) =\n      const R f g V hv", "start": [350, 1], "end": [353, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.const_zero", "code": "theorem const_zero (f : R) (U hu) : const R 0 f U hu = 0", "start": [356, 1], "end": [358, 70], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.const_self", "code": "theorem const_self (f : R) (U hu) : const R f f U hu = 1", "start": [361, 1], "end": [362, 60], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.const_one", "code": "theorem const_one (U) : (const R 1 1 U fun _ _ => Submonoid.one_mem _) = 1", "start": [365, 1], "end": [366, 21], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.const_add", "code": "theorem const_add (f\u2081 f\u2082 g\u2081 g\u2082 : R) (U hu\u2081 hu\u2082) :\n    const R f\u2081 g\u2081 U hu\u2081 + const R f\u2082 g\u2082 U hu\u2082 =\n      const R (f\u2081 * g\u2082 + f\u2082 * g\u2081) (g\u2081 * g\u2082) U fun x hx =>\n        Submonoid.mul_mem _ (hu\u2081 x hx) (hu\u2082 x hx)", "start": [369, 1], "end": [374, 36], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.const_mul", "code": "theorem const_mul (f\u2081 f\u2082 g\u2081 g\u2082 : R) (U hu\u2081 hu\u2082) :\n    const R f\u2081 g\u2081 U hu\u2081 * const R f\u2082 g\u2082 U hu\u2082 =\n      const R (f\u2081 * f\u2082) (g\u2081 * g\u2082) U fun x hx => Submonoid.mul_mem _ (hu\u2081 x hx) (hu\u2082 x hx)", "start": [377, 1], "end": [382, 91], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.const_ext", "code": "theorem const_ext {f\u2081 f\u2082 g\u2081 g\u2082 : R} {U hu\u2081 hu\u2082} (h : f\u2081 * g\u2082 = f\u2082 * g\u2081) :\n    const R f\u2081 g\u2081 U hu\u2081 = const R f\u2082 g\u2082 U hu\u2082", "start": [385, 1], "end": [389, 100], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.const_congr", "code": "theorem const_congr {f\u2081 f\u2082 g\u2081 g\u2082 : R} {U hu} (hf : f\u2081 = f\u2082) (hg : g\u2081 = g\u2082) :\n    const R f\u2081 g\u2081 U hu = const R f\u2082 g\u2082 U (hg \u25b8 hu)", "start": [392, 1], "end": [393, 75], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.const_mul_rev", "code": "theorem const_mul_rev (f g : R) (U hu\u2081 hu\u2082) : const R f g U hu\u2081 * const R g f U hu\u2082 = 1", "start": [396, 1], "end": [397, 63], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.const_mul_cancel", "code": "theorem const_mul_cancel (f g\u2081 g\u2082 : R) (U hu\u2081 hu\u2082) :\n    const R f g\u2081 U hu\u2081 * const R g\u2081 g\u2082 U hu\u2082 = const R f g\u2082 U hu\u2082", "start": [400, 1], "end": [402, 44], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.const_mul_cancel'", "code": "theorem const_mul_cancel' (f g\u2081 g\u2082 : R) (U hu\u2081 hu\u2082) :\n    const R g\u2081 g\u2082 U hu\u2082 * const R f g\u2081 U hu\u2081 = const R f g\u2082 U hu\u2082", "start": [405, 1], "end": [407, 34], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.toOpen", "code": "def toOpen (U : Opens (PrimeSpectrum.Top R)) : CommRingCat.of R \u27f6 (structureSheaf R).1.obj (op U)\n    where\n  toFun f :=\n    \u27e8fun x => algebraMap R _ f, fun x =>\n      \u27e8U, x.2, \ud835\udfd9 _, f, 1, fun y =>\n        \u27e8(Ideal.ne_top_iff_one _).1 y.1.2.1, by rw [RingHom.map_one, mul_one]\u27e9\u27e9\u27e9\n  map_one' := Subtype.eq <| funext fun x => RingHom.map_one _\n  map_mul' f g := Subtype.eq <| funext fun x => RingHom.map_mul _ _ _\n  map_zero' := Subtype.eq <| funext fun x => RingHom.map_zero _\n  map_add' f g := Subtype.eq <| funext fun x => RingHom.map_add _ _ _", "start": [410, 1], "end": [421, 70], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.toOpen_res", "code": "@[simp]\ntheorem toOpen_res (U V : Opens (PrimeSpectrum.Top R)) (i : V \u27f6 U) :\n    toOpen R U \u226b (structureSheaf R).1.map i.op = toOpen R V", "start": [424, 1], "end": [427, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.toOpen_apply", "code": "@[simp]\ntheorem toOpen_apply (U : Opens (PrimeSpectrum.Top R)) (f : R) (x : U) :\n    (toOpen R U f).1 x = algebraMap _ _ f", "start": [430, 1], "end": [433, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.toOpen_eq_const", "code": "theorem toOpen_eq_const (U : Opens (PrimeSpectrum.Top R)) (f : R) :\n    toOpen R U f = const R f 1 U fun x _ => (Ideal.ne_top_iff_one _).1 x.2.1", "start": [436, 1], "end": [438, 70], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.toStalk", "code": "def toStalk (x : PrimeSpectrum.Top R) : CommRingCat.of R \u27f6 (structureSheaf R).presheaf.stalk x :=\n  (toOpen R \u22a4 \u226b (structureSheaf R).presheaf.germ \u27e8x, by trivial\u27e9)", "start": [441, 1], "end": [444, 66], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.toOpen_germ", "code": "@[simp]\ntheorem toOpen_germ (U : Opens (PrimeSpectrum.Top R)) (x : U) :\n    toOpen R U \u226b (structureSheaf R).presheaf.germ x = toStalk R x", "start": [447, 1], "end": [450, 91], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.germ_toOpen", "code": "@[simp]\ntheorem germ_toOpen (U : Opens (PrimeSpectrum.Top R)) (x : U) (f : R) :\n    (structureSheaf R).presheaf.germ x (toOpen R U f) = toStalk R x f", "start": [453, 1], "end": [455, 100], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.germ_to_top", "code": "theorem germ_to_top (x : PrimeSpectrum.Top R) (f : R) :\n    (structureSheaf R).presheaf.germ (\u27e8x, trivial\u27e9 : (\u22a4 : Opens (PrimeSpectrum.Top R)))\n        (toOpen R \u22a4 f) =\n      toStalk R x f", "start": [458, 1], "end": [462, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.isUnit_to_basicOpen_self", "code": "theorem isUnit_to_basicOpen_self (f : R) : IsUnit (toOpen R (PrimeSpectrum.basicOpen f) f)", "start": [465, 1], "end": [467, 40], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.isUnit_toStalk", "code": "theorem isUnit_toStalk (x : PrimeSpectrum.Top R) (f : x.asIdeal.primeCompl) :\n    IsUnit (toStalk R x (f : R))", "start": [470, 1], "end": [473, 60], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.localizationToStalk", "code": "def localizationToStalk (x : PrimeSpectrum.Top R) :\n    CommRingCat.of (Localization.AtPrime x.asIdeal) \u27f6 (structureSheaf R).presheaf.stalk x :=\n  show Localization.AtPrime x.asIdeal \u2192+* _ from IsLocalization.lift (isUnit_toStalk R x)", "start": [476, 1], "end": [480, 90], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.localizationToStalk_of", "code": "@[simp]\ntheorem localizationToStalk_of (x : PrimeSpectrum.Top R) (f : R) :\n    localizationToStalk R x (algebraMap _ (Localization _) f) = toStalk R x f", "start": [483, 1], "end": [486, 29], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.localizationToStalk_mk'", "code": "@[simp]\ntheorem localizationToStalk_mk' (x : PrimeSpectrum.Top R) (f : R) (s : x.asIdeal.primeCompl) :\n    localizationToStalk R x (IsLocalization.mk' (Localization.AtPrime x.asIdeal) f s) =\n      (structureSheaf R).presheaf.germ (\u27e8x, s.2\u27e9 : PrimeSpectrum.basicOpen (s : R))\n        (const R f s (PrimeSpectrum.basicOpen s) fun _ => id)", "start": [489, 1], "end": [497, 42], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.openToLocalization", "code": "def openToLocalization (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R) (hx : x \u2208 U) :\n    (structureSheaf R).1.obj (op U) \u27f6 CommRingCat.of (Localization.AtPrime x.asIdeal) where\n  toFun s := (s.1 \u27e8x, hx\u27e9 : _)\n  map_one' := rfl\n  map_mul' _ _ := rfl\n  map_zero' := rfl\n  map_add' _ _ := rfl", "start": [500, 1], "end": [509, 22], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.coe_openToLocalization", "code": "@[simp]\ntheorem coe_openToLocalization (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R)\n    (hx : x \u2208 U) :\n    (openToLocalization R U x hx :\n        (structureSheaf R).1.obj (op U) \u2192 Localization.AtPrime x.asIdeal) =\n      fun s => (s.1 \u27e8x, hx\u27e9 : _)", "start": [512, 1], "end": [518, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.openToLocalization_apply", "code": "theorem openToLocalization_apply (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R)\n    (hx : x \u2208 U) (s : (structureSheaf R).1.obj (op U)) :\n    openToLocalization R U x hx s = (s.1 \u27e8x, hx\u27e9 : _)", "start": [521, 1], "end": [524, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom", "code": "def stalkToFiberRingHom (x : PrimeSpectrum.Top R) :\n    (structureSheaf R).presheaf.stalk x \u27f6 CommRingCat.of (Localization.AtPrime x.asIdeal) :=\n  Limits.colimit.desc ((OpenNhds.inclusion x).op \u22d9 (structureSheaf R).1)\n    { pt := _\n      \u03b9 := { app := fun U =>\n        openToLocalization R ((OpenNhds.inclusion _).obj (unop U)) x (unop U).2 } }", "start": [527, 1], "end": [535, 84], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.germ_comp_stalkToFiberRingHom", "code": "@[simp]\ntheorem germ_comp_stalkToFiberRingHom (U : Opens (PrimeSpectrum.Top R)) (x : U) :\n    (structureSheaf R).presheaf.germ x \u226b stalkToFiberRingHom R x = openToLocalization R U x x.2", "start": [538, 1], "end": [541, 28], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom_germ'", "code": "@[simp]\ntheorem stalkToFiberRingHom_germ' (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R)\n    (hx : x \u2208 U) (s : (structureSheaf R).1.obj (op U)) :\n    stalkToFiberRingHom R x ((structureSheaf R).presheaf.germ \u27e8x, hx\u27e9 s) = (s.1 \u27e8x, hx\u27e9 : _)", "start": [544, 1], "end": [548, 70], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom_germ", "code": "@[simp]\ntheorem stalkToFiberRingHom_germ (U : Opens (PrimeSpectrum.Top R)) (x : U)\n    (s : (structureSheaf R).1.obj (op U)) :\n    stalkToFiberRingHom R x ((structureSheaf R).presheaf.germ x s) = s.1 x", "start": [551, 1], "end": [555, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.toStalk_comp_stalkToFiberRingHom", "code": "@[simp]\ntheorem toStalk_comp_stalkToFiberRingHom (x : PrimeSpectrum.Top R) :\n    toStalk R x \u226b stalkToFiberRingHom R x = algebraMap R (Localization.AtPrime x.asIdeal)", "start": [558, 1], "end": [562, 68], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom_toStalk", "code": "@[simp]\ntheorem stalkToFiberRingHom_toStalk (x : PrimeSpectrum.Top R) (f : R) :\n    stalkToFiberRingHom R x (toStalk R x f) = algebraMap R (Localization.AtPrime x.asIdeal) f", "start": [565, 1], "end": [569, 61], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.stalkIso", "code": "@[simps]\ndef stalkIso (x : PrimeSpectrum.Top R) :\n    (structureSheaf R).presheaf.stalk x \u2245 CommRingCat.of (Localization.AtPrime x.asIdeal) where\n  hom := stalkToFiberRingHom R x\n  inv := localizationToStalk R x\n  hom_inv_id := by\n    ext U hxU s\n    simp only [FunctorToTypes.map_comp_apply, CommRingCat.forget_map,\n      CommRingCat.coe_of, Category.comp_id]\n    rw [comp_apply, comp_apply, stalkToFiberRingHom_germ']\n    obtain \u27e8V, hxV, iVU, f, g, (hg : V \u2264 PrimeSpectrum.basicOpen _), hs\u27e9 :=\n      exists_const _ _ s x hxU\n    erw [\u2190 res_apply R U V iVU s \u27e8x, hxV\u27e9, \u2190 hs, const_apply, localizationToStalk_mk']\n    refine' (structureSheaf R).presheaf.germ_ext V hxV (homOfLE hg) iVU _\n    dsimp\n    erw [\u2190 hs, res_const']\n  inv_hom_id :=\n    @IsLocalization.ringHom_ext R _ x.asIdeal.primeCompl (Localization.AtPrime x.asIdeal) _ _\n      (Localization.AtPrime x.asIdeal) _ _\n      (RingHom.comp (stalkToFiberRingHom R x) (localizationToStalk R x))\n      (RingHom.id (Localization.AtPrime _)) <| by\n        ext f\n        rw [RingHom.comp_apply, RingHom.comp_apply]; erw [localizationToStalk_of,\n          stalkToFiberRingHom_toStalk]; rw [RingHom.comp_apply, RingHom.id_apply]", "start": [572, 1], "end": [598, 82], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom_localizationToStalk", "code": "@[simp, reassoc]\ntheorem stalkToFiberRingHom_localizationToStalk (x : PrimeSpectrum.Top R) :\n    stalkToFiberRingHom R x \u226b localizationToStalk R x = \ud835\udfd9 _", "start": [607, 1], "end": [610, 28], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.localizationToStalk_stalkToFiberRingHom", "code": "@[simp, reassoc]\ntheorem localizationToStalk_stalkToFiberRingHom (x : PrimeSpectrum.Top R) :\n    localizationToStalk R x \u226b stalkToFiberRingHom R x = \ud835\udfd9 _", "start": [613, 1], "end": [616, 28], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.toBasicOpen", "code": "def toBasicOpen (f : R) :\n    Localization.Away f \u2192+* (structureSheaf R).1.obj (op <| PrimeSpectrum.basicOpen f) :=\n  IsLocalization.Away.lift f (isUnit_to_basicOpen_self R f)", "start": [619, 1], "end": [623, 60], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.toBasicOpen_mk'", "code": "@[simp]\ntheorem toBasicOpen_mk' (s f : R) (g : Submonoid.powers s) :\n    toBasicOpen R s (IsLocalization.mk' (Localization.Away s) f g) =\n      const R f g (PrimeSpectrum.basicOpen s) fun x hx => Submonoid.powers_subset hx g.2", "start": [626, 1], "end": [632, 67], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.localization_toBasicOpen", "code": "@[simp]\ntheorem localization_toBasicOpen (f : R) :\n    RingHom.comp (toBasicOpen R f) (algebraMap R (Localization.Away f)) =\n    toOpen R (PrimeSpectrum.basicOpen f)", "start": [635, 1], "end": [640, 91], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.toBasicOpen_to_map", "code": "@[simp]\ntheorem toBasicOpen_to_map (s f : R) :\n    toBasicOpen R s (algebraMap R (Localization.Away s) f) =\n      const R f 1 (PrimeSpectrum.basicOpen s) fun _ _ => Submonoid.one_mem _", "start": [643, 1], "end": [647, 62], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.toBasicOpen_injective", "code": "theorem toBasicOpen_injective (f : R) : Function.Injective (toBasicOpen R f)", "start": [651, 1], "end": [680, 23], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.locally_const_basicOpen", "code": "theorem locally_const_basicOpen (U : Opens (PrimeSpectrum.Top R))\n    (s : (structureSheaf R).1.obj (op U)) (x : U) :\n    \u2203 (f g : R) (i : PrimeSpectrum.basicOpen g \u27f6 U), x.1 \u2208 PrimeSpectrum.basicOpen g \u2227\n      (const R f g (PrimeSpectrum.basicOpen g) fun y hy => hy) =\n      (structureSheaf R).1.map i.op s", "start": [687, 1], "end": [724, 27], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.normalize_finite_fraction_representation", "code": "theorem normalize_finite_fraction_representation (U : Opens (PrimeSpectrum.Top R))\n    (s : (structureSheaf R).1.obj (op U)) {\u03b9 : Type*} (t : Finset \u03b9) (a h : \u03b9 \u2192 R)\n    (iDh : \u2200 i : \u03b9, PrimeSpectrum.basicOpen (h i) \u27f6 U)\n    (h_cover : U \u2264 \u2a06 i \u2208 t, PrimeSpectrum.basicOpen (h i))\n    (hs :\n      \u2200 i : \u03b9,\n        (const R (a i) (h i) (PrimeSpectrum.basicOpen (h i)) fun y hy => hy) =\n          (structureSheaf R).1.map (iDh i).op s) :\n    \u2203 (a' h' : \u03b9 \u2192 R) (iDh' : \u2200 i : \u03b9, PrimeSpectrum.basicOpen (h' i) \u27f6 U),\n      (U \u2264 \u2a06 i \u2208 t, PrimeSpectrum.basicOpen (h' i)) \u2227\n        (\u2200 (i) (_ : i \u2208 t) (j) (_ : j \u2208 t), a' i * h' j = h' i * a' j) \u2227\n          \u2200 i \u2208 t,\n            (structureSheaf R).1.map (iDh' i).op s =\n              const R (a' i) (h' i) (PrimeSpectrum.basicOpen (h' i)) fun y hy => hy", "start": [732, 1], "end": [816, 7], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.toBasicOpen_surjective", "code": "theorem toBasicOpen_surjective (f : R) : Function.Surjective (toBasicOpen R f)", "start": [828, 1], "end": [914, 7], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.isIso_toBasicOpen", "code": "instance isIso_toBasicOpen (f : R) :\n    IsIso (show CommRingCat.of (Localization.Away f) \u27f6 _ from toBasicOpen R f) :=\n  haveI : IsIso ((forget CommRingCat).map\n      (show CommRingCat.of (Localization.Away f) \u27f6 _ from toBasicOpen R f)) :=\n    (isIso_iff_bijective _).mpr \u27e8toBasicOpen_injective R f, toBasicOpen_surjective R f\u27e9\n  isIso_of_reflects_iso _ (forget CommRingCat)", "start": [917, 1], "end": [922, 47], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.basicOpenIso", "code": "def basicOpenIso (f : R) :\n    (structureSheaf R).1.obj (op (PrimeSpectrum.basicOpen f)) \u2245\n    CommRingCat.of (Localization.Away f) :=\n  (asIso (show CommRingCat.of (Localization.Away f) \u27f6 _ from toBasicOpen R f)).symm", "start": [925, 1], "end": [930, 84], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.stalkAlgebra", "code": "instance stalkAlgebra (p : PrimeSpectrum R) : Algebra R ((structureSheaf R).presheaf.stalk p) :=\n  (toStalk R p).toAlgebra", "start": [933, 1], "end": [934, 26], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.stalkAlgebra_map", "code": "@[simp]\ntheorem stalkAlgebra_map (p : PrimeSpectrum R) (r : R) :\n    algebraMap R ((structureSheaf R).presheaf.stalk p) r = toStalk R p r", "start": [937, 1], "end": [940, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.IsLocalization.to_stalk", "code": "instance IsLocalization.to_stalk (p : PrimeSpectrum R) :\n    IsLocalization.AtPrime ((structureSheaf R).presheaf.stalk p) p.asIdeal := by\n  convert (IsLocalization.isLocalization_iff_of_ringEquiv (S := Localization.AtPrime p.asIdeal) _\n          (stalkIso R p).symm.commRingCatIsoToRingEquiv).mp\n      Localization.isLocalization\n  apply Algebra.algebra_ext\n  intro\n  rw [stalkAlgebra_map]\n  congr 1\n  change toStalk R p = _ \u226b (stalkIso R p).inv\n  erw [Iso.eq_comp_inv]\n  exact toStalk_comp_stalkToFiberRingHom R p", "start": [943, 1], "end": [955, 45], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.openAlgebra", "code": "instance openAlgebra (U : (Opens (PrimeSpectrum R))\u1d52\u1d56) : Algebra R ((structureSheaf R).val.obj U) :=\n  (toOpen R (unop U)).toAlgebra", "start": [958, 1], "end": [959, 32], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.openAlgebra_map", "code": "@[simp]\ntheorem openAlgebra_map (U : (Opens (PrimeSpectrum R))\u1d52\u1d56) (r : R) :\n    algebraMap R ((structureSheaf R).val.obj U) r = toOpen R (unop U) r", "start": [962, 1], "end": [965, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.IsLocalization.to_basicOpen", "code": "instance IsLocalization.to_basicOpen (r : R) :\n    IsLocalization.Away r ((structureSheaf R).val.obj (op <| PrimeSpectrum.basicOpen r)) := by\n  convert (IsLocalization.isLocalization_iff_of_ringEquiv (S := Localization.Away r) _\n      (basicOpenIso R r).symm.commRingCatIsoToRingEquiv).mp\n      Localization.isLocalization\n  apply Algebra.algebra_ext\n  intro x\n  congr 1\n  exact (localization_toBasicOpen R r).symm", "start": [968, 1], "end": [977, 44], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.to_basicOpen_epi", "code": "instance to_basicOpen_epi (r : R) : Epi (toOpen R (PrimeSpectrum.basicOpen r)) :=\n  \u27e8fun {S} f g h => by\n    refine' IsLocalization.ringHom_ext (R := R)\n      (S := (structureSheaf R).val.obj (op <| PrimeSpectrum.basicOpen r)) _ _\n    exact h\u27e9", "start": [980, 1], "end": [984, 13], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.to_global_factors", "code": "@[elementwise]\ntheorem to_global_factors :\n    toOpen R \u22a4 =\n      CommRingCat.ofHom (algebraMap R (Localization.Away (1 : R))) \u226b\n        toBasicOpen R (1 : R) \u226b\n        (structureSheaf R).1.map (eqToHom PrimeSpectrum.basicOpen_one.symm).op", "start": [987, 1], "end": [998, 46], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.isIso_to_global", "code": "instance isIso_to_global : IsIso (toOpen R \u22a4) := by\n  let hom := CommRingCat.ofHom (algebraMap R (Localization.Away (1 : R)))\n  haveI : IsIso hom :=\n    IsIso.of_iso (IsLocalization.atOne R (Localization.Away (1 : R))).toRingEquiv.toCommRingCatIso\n  rw [to_global_factors R]\n  infer_instance", "start": [1001, 1], "end": [1006, 17], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.globalSectionsIso", "code": "@[simps!]\ndef globalSectionsIso : CommRingCat.of R \u2245 (structureSheaf R).1.obj (op \u22a4) :=\n  asIso (toOpen R \u22a4)", "start": [1009, 1], "end": [1013, 21], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.globalSectionsIso_hom", "code": "@[simp]\ntheorem globalSectionsIso_hom (R : CommRingCat) : (globalSectionsIso R).hom = toOpen R \u22a4", "start": [1019, 1], "end": [1021, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.toStalk_stalkSpecializes", "code": "@[simp, reassoc, elementwise]\ntheorem toStalk_stalkSpecializes {R : Type*} [CommRing R] {x y : PrimeSpectrum R} (h : x \u2933 y) :\n    toStalk R y \u226b (structureSheaf R).presheaf.stalkSpecializes h = toStalk R x", "start": [1024, 1], "end": [1027, 39], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.localizationToStalk_stalkSpecializes", "code": "@[simp, reassoc, elementwise]\ntheorem localizationToStalk_stalkSpecializes {R : Type*} [CommRing R] {x y : PrimeSpectrum R}\n    (h : x \u2933 y) :\n    StructureSheaf.localizationToStalk R y \u226b (structureSheaf R).presheaf.stalkSpecializes h =\n      CommRingCat.ofHom (PrimeSpectrum.localizationMapOfSpecializes h) \u226b\n        StructureSheaf.localizationToStalk R x", "start": [1030, 1], "end": [1041, 35], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.stalkSpecializes_stalk_to_fiber", "code": "@[simp, reassoc, elementwise]\ntheorem stalkSpecializes_stalk_to_fiber {R : Type*} [CommRing R] {x y : PrimeSpectrum R}\n    (h : x \u2933 y) :\n    (structureSheaf R).presheaf.stalkSpecializes h \u226b StructureSheaf.stalkToFiberRingHom R x =\n      StructureSheaf.stalkToFiberRingHom R y \u226b\n      (show CommRingCat.of (Localization.AtPrime y.asIdeal) \u27f6\n        CommRingCat.of (Localization.AtPrime x.asIdeal)\n        from PrimeSpectrum.localizationMapOfSpecializes h)", "start": [1045, 1], "end": [1058, 47], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.comapFun", "code": "def comapFun (f : R \u2192+* S) (U : Opens (PrimeSpectrum.Top R)) (V : Opens (PrimeSpectrum.Top S))\n    (hUV : V.1 \u2286 PrimeSpectrum.comap f \u207b\u00b9' U.1) (s : \u2200 x : U, Localizations R x) (y : V) :\n    Localizations S y :=\n  Localization.localRingHom (PrimeSpectrum.comap f y.1).asIdeal _ f rfl\n    (s \u27e8PrimeSpectrum.comap f y.1, hUV y.2\u27e9 : _)", "start": [1065, 1], "end": [1080, 49], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.comapFunIsLocallyFraction", "code": "theorem comapFunIsLocallyFraction (f : R \u2192+* S) (U : Opens (PrimeSpectrum.Top R))\n    (V : Opens (PrimeSpectrum.Top S)) (hUV : V.1 \u2286 PrimeSpectrum.comap f \u207b\u00b9' U.1)\n    (s : \u2200 x : U, Localizations R x) (hs : (isLocallyFraction R).toPrelocalPredicate.pred s) :\n    (isLocallyFraction S).toPrelocalPredicate.pred (comapFun f U V hUV s)", "start": [1083, 1], "end": [1100, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.comap", "code": "def comap (f : R \u2192+* S) (U : Opens (PrimeSpectrum.Top R)) (V : Opens (PrimeSpectrum.Top S))\n    (hUV : V.1 \u2286 PrimeSpectrum.comap f \u207b\u00b9' U.1) :\n    (structureSheaf R).1.obj (op U) \u2192+* (structureSheaf S).1.obj (op V) where\n  toFun s := \u27e8comapFun f U V hUV s.1, comapFunIsLocallyFraction f U V hUV s.1 s.2\u27e9\n  map_one' :=\n    Subtype.ext <|\n      funext fun p => by\n        dsimp\n        rw [comapFun, (sectionsSubring R (op U)).coe_one, Pi.one_apply, RingHom.map_one]\n        rfl\n  map_zero' :=\n    Subtype.ext <|\n      funext fun p => by\n        dsimp\n        rw [comapFun, (sectionsSubring R (op U)).coe_zero, Pi.zero_apply, RingHom.map_zero]\n        rfl\n  map_add' s t :=\n    Subtype.ext <|\n      funext fun p => by\n        dsimp\n        rw [comapFun, (sectionsSubring R (op U)).coe_add, Pi.add_apply, RingHom.map_add]\n        rfl\n  map_mul' s t :=\n    Subtype.ext <|\n      funext fun p => by\n        dsimp\n        rw [comapFun, (sectionsSubring R (op U)).coe_mul, Pi.mul_apply, RingHom.map_mul]\n        rfl", "start": [1103, 1], "end": [1137, 12], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.comap_apply", "code": "@[simp]\ntheorem comap_apply (f : R \u2192+* S) (U : Opens (PrimeSpectrum.Top R))\n    (V : Opens (PrimeSpectrum.Top S)) (hUV : V.1 \u2286 PrimeSpectrum.comap f \u207b\u00b9' U.1)\n    (s : (structureSheaf R).1.obj (op U)) (p : V) :\n    (comap f U V hUV s).1 p =\n      Localization.localRingHom (PrimeSpectrum.comap f p.1).asIdeal _ f rfl\n        (s.1 \u27e8PrimeSpectrum.comap f p.1, hUV p.2\u27e9 : _)", "start": [1140, 1], "end": [1147, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.comap_const", "code": "theorem comap_const (f : R \u2192+* S) (U : Opens (PrimeSpectrum.Top R))\n    (V : Opens (PrimeSpectrum.Top S)) (hUV : V.1 \u2286 PrimeSpectrum.comap f \u207b\u00b9' U.1) (a b : R)\n    (hb : \u2200 x : PrimeSpectrum R, x \u2208 U \u2192 b \u2208 x.asIdeal.primeCompl) :\n    comap f U V hUV (const R a b U hb) =\n      const S (f a) (f b) V fun p hpV => hb (PrimeSpectrum.comap f p) (hUV hpV)", "start": [1150, 1], "end": [1159, 10], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.comap_id_eq_map", "code": "theorem comap_id_eq_map (U V : Opens (PrimeSpectrum.Top R)) (iVU : V \u27f6 U) :\n    (comap (RingHom.id R) U V fun p hpV => leOfHom iVU <| hpV) =\n      (structureSheaf R).1.map iVU.op", "start": [1162, 1], "end": [1184, 79], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.comap_id", "code": "theorem comap_id (U V : Opens (PrimeSpectrum.Top R)) (hUV : U = V) :\n    (comap (RingHom.id R) U V fun p hpV => by rwa [hUV, PrimeSpectrum.comap_id]) =\n      eqToHom (show (structureSheaf R).1.obj (op U) = _ by rw [hUV])", "start": [1187, 1], "end": [1195, 75], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.comap_id'", "code": "@[simp]\ntheorem comap_id' (U : Opens (PrimeSpectrum.Top R)) :\n    (comap (RingHom.id R) U U fun p hpU => by rwa [PrimeSpectrum.comap_id]) = RingHom.id _", "start": [1198, 1], "end": [1201, 29], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.comap_comp", "code": "theorem comap_comp (f : R \u2192+* S) (g : S \u2192+* P) (U : Opens (PrimeSpectrum.Top R))\n    (V : Opens (PrimeSpectrum.Top S)) (W : Opens (PrimeSpectrum.Top P))\n    (hUV : \u2200 p \u2208 V, PrimeSpectrum.comap f p \u2208 U) (hVW : \u2200 p \u2208 W, PrimeSpectrum.comap g p \u2208 V) :\n    (comap (g.comp f) U W fun p hpW => hUV (PrimeSpectrum.comap g p) (hVW p hpW)) =\n      (comap g V W hVW).comp (comap f U V hUV)", "start": [1204, 1], "end": [1216, 12], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.StructureSheaf.toOpen_comp_comap", "code": "@[elementwise, reassoc]\ntheorem toOpen_comp_comap (f : R \u2192+* S) (U : Opens (PrimeSpectrum.Top R)) :\n    (toOpen R U \u226b comap f U (Opens.comap (PrimeSpectrum.comap f) U) fun _ => id) =\n      CommRingCat.ofHom f \u226b toOpen S _", "start": [1219, 1], "end": [1223, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/RingedSpace/LocallyRingedSpace.lean", "imports": ["Mathlib/Geometry/RingedSpace/Basic.lean", "Mathlib/Geometry/RingedSpace/Stalks.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicGeometry.LocallyRingedSpace", "code": "structure LocallyRingedSpace extends SheafedSpace CommRingCat where\n  \n  localRing : \u2200 x, LocalRing (presheaf.stalk x)", "start": [31, 1], "end": [38, 48], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.toRingedSpace", "code": "def toRingedSpace : RingedSpace :=\n  X.toSheafedSpace", "start": [48, 1], "end": [52, 19], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.toTopCat", "code": "def toTopCat : TopCat :=\n  X.1.carrier", "start": [56, 1], "end": [58, 14], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.\ud835\udcaa", "code": "def \ud835\udcaa : Sheaf CommRingCat X.toTopCat :=\n  X.sheaf", "start": [70, 1], "end": [72, 10], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.Hom", "code": "@[ext]\nstructure Hom (X Y : LocallyRingedSpace) : Type _ where\n  \n  val : X.toSheafedSpace \u27f6 Y.toSheafedSpace\n  \n  prop : \u2200 x, IsLocalRingHom (PresheafedSpace.stalkMap val x)", "start": [76, 1], "end": [83, 62], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.Hom.ext'", "code": "@[ext] lemma Hom.ext' (X Y : LocallyRingedSpace) {f g : X \u27f6 Y} (h : f.val = g.val) : f = g :=\nHom.ext _ _ h", "start": [90, 1], "end": [91, 14], "kind": "mathlibtacticlemma"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.stalk", "code": "noncomputable def stalk (X : LocallyRingedSpace) (x : X) : CommRingCat :=\n  X.presheaf.stalk x", "start": [95, 1], "end": [98, 21], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.stalkLocal", "code": "instance stalkLocal (x : X) : LocalRing <| X.stalk x := X.localRing x", "start": [104, 1], "end": [104, 70], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.stalkMap", "code": "noncomputable def stalkMap {X Y : LocallyRingedSpace} (f : X \u27f6 Y) (x : X) :\n    Y.stalk (f.1.1 x) \u27f6 X.stalk x :=\n  PresheafedSpace.stalkMap f.1 x", "start": [106, 1], "end": [111, 33], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.id", "code": "@[simps]\ndef id (X : LocallyRingedSpace) : Hom X X :=\n  \u27e8\ud835\udfd9 _, fun x => by erw [PresheafedSpace.stalkMap.id]; apply isLocalRingHom_id\u27e9", "start": [122, 1], "end": [125, 80], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.comp", "code": "def comp {X Y Z : LocallyRingedSpace} (f : Hom X Y) (g : Hom Y Z) : Hom X Z :=\n  \u27e8f.val \u226b g.val, fun x => by\n    erw [PresheafedSpace.stalkMap.comp]\n    exact @isLocalRingHom_comp _ _ _ _ _ _ _ _ (f.2 _) (g.2 _)\u27e9", "start": [132, 1], "end": [136, 64], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.forgetToSheafedSpace", "code": "@[simps]\ndef forgetToSheafedSpace : LocallyRingedSpace \u2964 SheafedSpace CommRingCat where\n  obj X := X.toSheafedSpace\n  map {X Y} f := f.1", "start": [149, 1], "end": [153, 21], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.forgetToTop", "code": "@[simps!]\ndef forgetToTop : LocallyRingedSpace \u2964 TopCat :=\n  forgetToSheafedSpace \u22d9 SheafedSpace.forget _", "start": [160, 1], "end": [163, 47], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.comp_val", "code": "@[simp]\ntheorem comp_val {X Y Z : LocallyRingedSpace} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    (f \u226b g).val = f.val \u226b g.val", "start": [167, 1], "end": [170, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.comp_val_c", "code": "@[simp]\ntheorem comp_val_c {X Y Z : LocallyRingedSpace} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    (f.1 \u226b g.1).c = g.val.c \u226b (Presheaf.pushforward _ g.val.base).map f.val.c", "start": [176, 1], "end": [179, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.comp_val_c_app", "code": "theorem comp_val_c_app {X Y Z : LocallyRingedSpace} (f : X \u27f6 Y) (g : Y \u27f6 Z) (U : (Opens Z)\u1d52\u1d56) :\n    (f \u226b g).val.c.app U = g.val.c.app U \u226b f.val.c.app (op <| (Opens.map g.val.base).obj U.unop)", "start": [183, 1], "end": [185, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.homOfSheafedSpaceHomOfIsIso", "code": "@[simps]\ndef homOfSheafedSpaceHomOfIsIso {X Y : LocallyRingedSpace} (f : X.toSheafedSpace \u27f6 Y.toSheafedSpace)\n    [IsIso f] : X \u27f6 Y :=\n  Hom.mk f fun x =>\n    show IsLocalRingHom (PresheafedSpace.stalkMap (SheafedSpace.forgetToPresheafedSpace.map f) x) by\n      infer_instance", "start": [189, 1], "end": [202, 21], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.isoOfSheafedSpaceIso", "code": "def isoOfSheafedSpaceIso {X Y : LocallyRingedSpace} (f : X.toSheafedSpace \u2245 Y.toSheafedSpace) :\n    X \u2245 Y where\n  hom := homOfSheafedSpaceHomOfIsIso f.hom\n  inv := homOfSheafedSpaceHomOfIsIso f.inv\n  hom_inv_id := Hom.ext _ _ f.hom_inv_id\n  inv_hom_id := Hom.ext _ _ f.inv_hom_id", "start": [206, 1], "end": [218, 41], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.is_sheafedSpace_iso", "code": "instance is_sheafedSpace_iso {X Y : LocallyRingedSpace} (f : X \u27f6 Y) [IsIso f] : IsIso f.1 :=\n  LocallyRingedSpace.forgetToSheafedSpace.map_isIso f", "start": [227, 1], "end": [228, 54], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.restrict", "code": "@[simps!]\ndef restrict {U : TopCat} (X : LocallyRingedSpace) {f : U \u27f6 X.toTopCat} (h : OpenEmbedding f) :\n    LocallyRingedSpace where\n  localRing := by\n    intro x\n    apply @RingEquiv.localRing _ _ _ (X.localRing (f x))\n    exact (X.restrictStalkIso h x).symm.commRingCatIsoToRingEquiv\n  toSheafedSpace := X.toSheafedSpace.restrict h", "start": [232, 1], "end": [242, 48], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.ofRestrict", "code": "def ofRestrict {U : TopCat} (X : LocallyRingedSpace) {f : U \u27f6 X.toTopCat} (h : OpenEmbedding f) :\n    X.restrict h \u27f6 X :=\n  \u27e8X.toPresheafedSpace.ofRestrict h, fun _ => inferInstance\u27e9", "start": [246, 1], "end": [249, 61], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.restrictTopIso", "code": "def restrictTopIso (X : LocallyRingedSpace) : X.restrict (Opens.openEmbedding \u22a4) \u2245 X :=\n  @isoOfSheafedSpaceIso (X.restrict (Opens.openEmbedding \u22a4)) X X.toSheafedSpace.restrictTopIso", "start": [253, 1], "end": [256, 95], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.\u0393", "code": "def \u0393 : LocallyRingedSpace\u1d52\u1d56 \u2964 CommRingCat :=\n  forgetToSheafedSpace.op \u22d9 SheafedSpace.\u0393", "start": [260, 1], "end": [263, 43], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.\u0393_def", "code": "theorem \u0393_def : \u0393 = forgetToSheafedSpace.op \u22d9 SheafedSpace.\u0393", "start": [267, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.\u0393_obj", "code": "@[simp]\ntheorem \u0393_obj (X : LocallyRingedSpace\u1d52\u1d56) : \u0393.obj X = X.unop.presheaf.obj (op \u22a4)", "start": [272, 1], "end": [274, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.\u0393_obj_op", "code": "theorem \u0393_obj_op (X : LocallyRingedSpace) : \u0393.obj (op X) = X.presheaf.obj (op \u22a4)", "start": [278, 1], "end": [279, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.\u0393_map", "code": "@[simp]\ntheorem \u0393_map {X Y : LocallyRingedSpace\u1d52\u1d56} (f : X \u27f6 Y) : \u0393.map f = f.unop.1.c.app (op \u22a4)", "start": [283, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.\u0393_map_op", "code": "theorem \u0393_map_op {X Y : LocallyRingedSpace} (f : X \u27f6 Y) : \u0393.map f.op = f.1.c.app (op \u22a4)", "start": [289, 1], "end": [290, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.preimage_basicOpen", "code": "theorem preimage_basicOpen {X Y : LocallyRingedSpace} (f : X \u27f6 Y) {U : Opens Y}\n    (s : Y.presheaf.obj (op U)) :\n    (Opens.map f.1.base).obj (Y.toRingedSpace.basicOpen s) =\n      @RingedSpace.basicOpen X.toRingedSpace ((Opens.map f.1.base).obj U) (f.1.c.app _ s)", "start": [294, 1], "end": [307, 68], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.basicOpen_zero", "code": "@[simp]\ntheorem basicOpen_zero (X : LocallyRingedSpace) (U : Opens X.carrier) :\n    X.toRingedSpace.basicOpen (0 : X.presheaf.obj <| op U) = \u22a5", "start": [312, 1], "end": [322, 20], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.LocallyRingedSpace.component_nontrivial", "code": "instance component_nontrivial (X : LocallyRingedSpace) (U : Opens X.carrier) [hU : Nonempty U] :\n    Nontrivial (X.presheaf.obj <| op U) :=\n  (X.presheaf.germ hU.some).domain_nontrivial", "start": [326, 1], "end": [328, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Localization/LocalizationLocalization.lean", "imports": ["Mathlib/RingTheory/Localization/AtPrime.lean", "Mathlib/RingTheory/Localization/Basic.lean", "Mathlib/RingTheory/Localization/FractionRing.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsLocalization.localizationLocalizationSubmodule", "code": "@[nolint unusedArguments]\ndef localizationLocalizationSubmodule : Submonoid R :=\n  (N \u2294 M.map (algebraMap R S)).comap (algebraMap R S)", "start": [42, 1], "end": [47, 54], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mem_localizationLocalizationSubmodule", "code": "@[simp]\ntheorem mem_localizationLocalizationSubmodule {x : R} :\n    x \u2208 localizationLocalizationSubmodule M N \u2194\n      \u2203 (y : N) (z : M), algebraMap R S x = y * algebraMap R S z", "start": [52, 1], "end": [61, 51], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.localization_localization_map_units", "code": "theorem localization_localization_map_units [IsLocalization N T]\n    (y : localizationLocalizationSubmodule M N) : IsUnit (algebraMap R T y)", "start": [66, 1], "end": [70, 93], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.localization_localization_surj", "code": "theorem localization_localization_surj [IsLocalization N T] (x : T) :\n    \u2203 y : R \u00d7 localizationLocalizationSubmodule M N,\n        x * algebraMap R T y.2 = algebraMap R T y.1", "start": [73, 1], "end": [89, 9], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.localization_localization_eq_iff_exists", "code": "theorem localization_localization_eq_iff_exists [IsLocalization N T] (x y : R) :\n    algebraMap R T x = algebraMap R T y \u2194\n      \u2203 c : localizationLocalizationSubmodule M N, \u2191c * x = \u2191c * y", "start": [92, 1], "end": [116, 27], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.localization_localization_isLocalization", "code": "theorem localization_localization_isLocalization [IsLocalization N T] :\n    IsLocalization (localizationLocalizationSubmodule M N) T", "start": [119, 1], "end": [126, 74], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.localization_localization_isLocalization_of_has_all_units", "code": "theorem localization_localization_isLocalization_of_has_all_units [IsLocalization N T]\n    (H : \u2200 x : S, IsUnit x \u2192 x \u2208 N) : IsLocalization (N.comap (algebraMap R S)) T", "start": [129, 1], "end": [141, 49], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.isLocalization_isLocalization_atPrime_isLocalization", "code": "theorem isLocalization_isLocalization_atPrime_isLocalization (p : Ideal S) [Hp : p.IsPrime]\n    [IsLocalization.AtPrime T p] : IsLocalization.AtPrime T (p.comap (algebraMap R S))", "start": [144, 1], "end": [152, 52], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.localization_localization_atPrime_is_localization", "code": "instance localization_localization_atPrime_is_localization (p : Ideal (Localization M))\n    [p.IsPrime] : IsLocalization.AtPrime (Localization.AtPrime p) (p.comap (algebraMap R _)) :=\n  isLocalization_isLocalization_atPrime_isLocalization M _ _", "start": [162, 1], "end": [164, 61], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.localizationLocalizationAtPrimeIsoLocalization", "code": "noncomputable def localizationLocalizationAtPrimeIsoLocalization (p : Ideal (Localization M))\n    [p.IsPrime] :\n    Localization.AtPrime (p.comap (algebraMap R (Localization M))) \u2243\u2090[R] Localization.AtPrime p :=\n  IsLocalization.algEquiv (p.comap (algebraMap R (Localization M))).primeCompl _ _", "start": [167, 1], "end": [173, 83], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.localizationAlgebraOfSubmonoidLe", "code": "noncomputable def localizationAlgebraOfSubmonoidLe (M N : Submonoid R) (h : M \u2264 N)\n    [IsLocalization M S] [IsLocalization N T] : Algebra S T :=\n  (@IsLocalization.lift R _ M S _ _ T _ _ (algebraMap R T)\n    (fun y => map_units T \u27e8\u2191y, h y.prop\u27e9)).toAlgebra", "start": [180, 1], "end": [185, 53], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.localization_isScalarTower_of_submonoid_le", "code": "theorem localization_isScalarTower_of_submonoid_le (M N : Submonoid R) (h : M \u2264 N)\n    [IsLocalization M S] [IsLocalization N T] :\n    @IsScalarTower R S T _ (localizationAlgebraOfSubmonoidLe S T M N h).toSMul _", "start": [188, 1], "end": [194, 68], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.isLocalization_of_submonoid_le", "code": "theorem isLocalization_of_submonoid_le (M N : Submonoid R) (h : M \u2264 N) [IsLocalization M S]\n    [IsLocalization N T] [Algebra S T] [IsScalarTower R S T] :\n    IsLocalization (N.map (algebraMap R S)) T", "start": [205, 1], "end": [242, 84], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.isLocalization_of_is_exists_mul_mem", "code": "theorem isLocalization_of_is_exists_mul_mem (M N : Submonoid R) [IsLocalization M S] (h : M \u2264 N)\n    (h' : \u2200 x : N, \u2203 m : R, m * x \u2208 M) : IsLocalization N S", "start": [245, 1], "end": [263, 28], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.isFractionRing_of_isLocalization", "code": "theorem isFractionRing_of_isLocalization (S T : Type*) [CommRing S] [CommRing T] [Algebra R S]\n    [Algebra R T] [Algebra S T] [IsScalarTower R S T] [IsLocalization M S] [IsFractionRing R T]\n    (hM : M \u2264 nonZeroDivisors R) : IsFractionRing S T", "start": [274, 1], "end": [290, 16], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.isFractionRing_of_isDomain_of_isLocalization", "code": "theorem isFractionRing_of_isDomain_of_isLocalization [IsDomain R] (S T : Type*) [CommRing S]\n    [CommRing T] [Algebra R S] [Algebra R T] [Algebra S T] [IsScalarTower R S T]\n    [IsLocalization M S] [IsFractionRing R T] : IsFractionRing S T", "start": [293, 1], "end": [304, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Bundle.lean", "imports": ["Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Bundle.TotalSpace", "code": "@[ext]\nstructure TotalSpace (F : Type*) (E : B \u2192 Type*) where\n  \n  proj : B\n  snd : E proj", "start": [48, 1], "end": [56, 15], "kind": "commanddeclaration"}, {"full_name": "Bundle.TotalSpace.mk'", "code": "abbrev TotalSpace.mk' (F : Type*) (x : B) (y : E x) : TotalSpace F E := \u27e8x, y\u27e9", "start": [67, 1], "end": [67, 79], "kind": "commanddeclaration"}, {"full_name": "Bundle.TotalSpace.mk_cast", "code": "theorem TotalSpace.mk_cast {x x' : B} (h : x = x') (b : E x) :\n    .mk' F x' (cast (congr_arg E h) b) = TotalSpace.mk x b", "start": [69, 1], "end": [70, 78], "kind": "commanddeclaration"}, {"full_name": "Bundle.TotalSpace.mk_inj", "code": "@[simp 1001, mfld_simps 1001]\ntheorem TotalSpace.mk_inj {b : B} {y y' : E b} : mk' F b y = mk' F b y' \u2194 y = y'", "start": [73, 1], "end": [75, 28], "kind": "commanddeclaration"}, {"full_name": "Bundle.TotalSpace.mk_injective", "code": "theorem TotalSpace.mk_injective (b : B) : Injective (mk b : E b \u2192 TotalSpace F E)", "start": [77, 1], "end": [78, 11], "kind": "commanddeclaration"}, {"full_name": "Bundle.TotalSpace.eta", "code": "theorem TotalSpace.eta (z : TotalSpace F E) : TotalSpace.mk z.proj z.2 = z", "start": [87, 1], "end": [87, 82], "kind": "commanddeclaration"}, {"full_name": "Bundle.TotalSpace.exists", "code": "@[simp]\ntheorem TotalSpace.exists {p : TotalSpace F E \u2192 Prop} : (\u2203 x, p x) \u2194 \u2203 b y, p \u27e8b, y\u27e9", "start": [90, 1], "end": [92, 62], "kind": "commanddeclaration"}, {"full_name": "Bundle.TotalSpace.range_mk", "code": "@[simp]\ntheorem TotalSpace.range_mk (b : B) : range ((\u2191) : E b \u2192 TotalSpace F E) = \u03c0 F E \u207b\u00b9' {b}", "start": [94, 1], "end": [100, 19], "kind": "commanddeclaration"}, {"full_name": "Bundle.Trivial", "code": "@[reducible, nolint unusedArguments]\ndef Trivial (B : Type*) (F : Type*) : B \u2192 Type _ := fun _ => F", "start": [105, 1], "end": [107, 63], "kind": "commanddeclaration"}, {"full_name": "Bundle.TotalSpace.trivialSnd", "code": "def TotalSpace.trivialSnd (B : Type*) (F : Type*) : TotalSpace F (Bundle.Trivial B F) \u2192 F :=\n  TotalSpace.snd", "start": [110, 1], "end": [112, 17], "kind": "commanddeclaration"}, {"full_name": "Bundle.TotalSpace.toProd", "code": "@[simps (config := { attrs := [`simp, `mfld_simps] })]\ndef TotalSpace.toProd (B F : Type*) : (TotalSpace F fun _ : B => F) \u2243 B \u00d7 F where\n  toFun x := (x.1, x.2)\n  invFun x := \u27e8x.1, x.2\u27e9\n  left_inv := fun \u27e8_, _\u27e9 => rfl\n  right_inv := fun \u27e8_, _\u27e9 => rfl", "start": [115, 1], "end": [121, 33], "kind": "commanddeclaration"}, {"full_name": "Bundle.Pullback", "code": "def Pullback (f : B' \u2192 B) (E : B \u2192 Type*) : B' \u2192 Type _ := fun x => E (f x)", "start": [128, 1], "end": [130, 76], "kind": "commanddeclaration"}, {"full_name": "Bundle.pullbackTotalSpaceEmbedding", "code": "@[simp]\ndef pullbackTotalSpaceEmbedding (f : B' \u2192 B) : TotalSpace F (f *\u1d56 E) \u2192 B' \u00d7 TotalSpace F E :=\n  fun z => (z.proj, TotalSpace.mk (f z.proj) z.2)", "start": [139, 1], "end": [142, 50], "kind": "commanddeclaration"}, {"full_name": "Bundle.Pullback.lift", "code": "@[simps (config := { isSimp := true, attrs := [`mfld_simps] })]\ndef Pullback.lift (f : B' \u2192 B) : TotalSpace F (f *\u1d56 E) \u2192 TotalSpace F E := fun z => \u27e8f z.proj, z.2\u27e9", "start": [145, 1], "end": [147, 100], "kind": "commanddeclaration"}, {"full_name": "Bundle.Pullback.lift_mk", "code": "@[simp, mfld_simps]\ntheorem Pullback.lift_mk (f : B' \u2192 B) (x : B') (y : E (f x)) :\n    Pullback.lift f (.mk' F x y) = \u27e8f x, y\u27e9", "start": [150, 1], "end": [153, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/BoxIntegral/Basic.lean", "imports": ["Mathlib/Analysis/BoxIntegral/Partition/Measure.lean", "Mathlib/Analysis/BoxIntegral/Partition/Filter.lean", "Mathlib/Topology/UniformSpace/Compact.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "BoxIntegral.integralSum", "code": "def integralSum (f : \u211d\u207f \u2192 E) (vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F) (\u03c0 : TaggedPrepartition I) : F :=\n  \u2211 J in \u03c0.boxes, vol J (f (\u03c0.tag J))", "start": [76, 1], "end": [79, 38], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integralSum_biUnionTagged", "code": "theorem integralSum_biUnionTagged (f : \u211d\u207f \u2192 E) (vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F) (\u03c0 : Prepartition I)\n    (\u03c0i : \u2200 J, TaggedPrepartition J) :\n    integralSum f vol (\u03c0.biUnionTagged \u03c0i) = \u2211 J in \u03c0.boxes, integralSum f vol (\u03c0i J)", "start": [82, 1], "end": [86, 34], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integralSum_biUnion_partition", "code": "theorem integralSum_biUnion_partition (f : \u211d\u207f \u2192 E) (vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F)\n    (\u03c0 : TaggedPrepartition I) (\u03c0i : \u2200 J, Prepartition J) (h\u03c0i : \u2200 J \u2208 \u03c0, (\u03c0i J).IsPartition) :\n    integralSum f vol (\u03c0.biUnionPrepartition \u03c0i) = integralSum f vol \u03c0", "start": [89, 1], "end": [99, 26], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integralSum_inf_partition", "code": "theorem integralSum_inf_partition (f : \u211d\u207f \u2192 E) (vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F) (\u03c0 : TaggedPrepartition I)\n    {\u03c0' : Prepartition I} (h : \u03c0'.IsPartition) :\n    integralSum f vol (\u03c0.infPrepartition \u03c0') = integralSum f vol \u03c0", "start": [102, 1], "end": [105, 96], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integralSum_fiberwise", "code": "theorem integralSum_fiberwise {\u03b1} (g : Box \u03b9 \u2192 \u03b1) (f : \u211d\u207f \u2192 E) (vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F)\n    (\u03c0 : TaggedPrepartition I) :\n    (\u2211 y in \u03c0.boxes.image g, integralSum f vol (\u03c0.filter (g \u00b7 = y))) = integralSum f vol \u03c0", "start": [108, 1], "end": [111, 50], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integralSum_sub_partitions", "code": "theorem integralSum_sub_partitions (f : \u211d\u207f \u2192 E) (vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F)\n    {\u03c0\u2081 \u03c0\u2082 : TaggedPrepartition I} (h\u2081 : \u03c0\u2081.IsPartition) (h\u2082 : \u03c0\u2082.IsPartition) :\n    integralSum f vol \u03c0\u2081 - integralSum f vol \u03c0\u2082 =\n      \u2211 J in (\u03c0\u2081.toPrepartition \u2293 \u03c0\u2082.toPrepartition).boxes,\n        (vol J (f <| (\u03c0\u2081.infPrepartition \u03c0\u2082.toPrepartition).tag J) -\n          vol J (f <| (\u03c0\u2082.infPrepartition \u03c0\u2081.toPrepartition).tag J))", "start": [114, 1], "end": [122, 55], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integralSum_disjUnion", "code": "@[simp]\ntheorem integralSum_disjUnion (f : \u211d\u207f \u2192 E) (vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F) {\u03c0\u2081 \u03c0\u2082 : TaggedPrepartition I}\n    (h : Disjoint \u03c0\u2081.iUnion \u03c0\u2082.iUnion) :\n    integralSum f vol (\u03c0\u2081.disjUnion \u03c0\u2082 h) = integralSum f vol \u03c0\u2081 + integralSum f vol \u03c0\u2082", "start": [125, 1], "end": [132, 41], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integralSum_add", "code": "@[simp]\ntheorem integralSum_add (f g : \u211d\u207f \u2192 E) (vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F) (\u03c0 : TaggedPrepartition I) :\n    integralSum (f + g) vol \u03c0 = integralSum f vol \u03c0 + integralSum g vol \u03c0", "start": [135, 1], "end": [138, 81], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integralSum_neg", "code": "@[simp]\ntheorem integralSum_neg (f : \u211d\u207f \u2192 E) (vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F) (\u03c0 : TaggedPrepartition I) :\n    integralSum (-f) vol \u03c0 = -integralSum f vol \u03c0", "start": [141, 1], "end": [144, 81], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integralSum_smul", "code": "@[simp]\ntheorem integralSum_smul (c : \u211d) (f : \u211d\u207f \u2192 E) (vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F) (\u03c0 : TaggedPrepartition I) :\n    integralSum (c \u2022 f) vol \u03c0 = c \u2022 integralSum f vol \u03c0", "start": [147, 1], "end": [150, 88], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral", "code": "def HasIntegral (I : Box \u03b9) (l : IntegrationParams) (f : \u211d\u207f \u2192 E) (vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F) (y : F) :\n    Prop :=\n  Tendsto (integralSum f vol) (l.toFilteriUnion I \u22a4) (\ud835\udcdd y)", "start": [160, 1], "end": [165, 59], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable", "code": "def Integrable (I : Box \u03b9) (l : IntegrationParams) (f : \u211d\u207f \u2192 E) (vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F) :=\n  \u2203 y, HasIntegral I l f vol y", "start": [168, 1], "end": [171, 31], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integral", "code": "def integral (I : Box \u03b9) (l : IntegrationParams) (f : \u211d\u207f \u2192 E) (vol : \u03b9 \u2192\u1d47\u1d43 E \u2192L[\u211d] F) :=\n  if h : Integrable I l f vol then h.choose else 0", "start": [174, 1], "end": [177, 51], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral.tendsto", "code": "theorem HasIntegral.tendsto (h : HasIntegral I l f vol y) :\n    Tendsto (integralSum f vol) (l.toFilteriUnion I \u22a4) (\ud835\udcdd y)", "start": [185, 1], "end": [189, 4], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.hasIntegral_iff", "code": "theorem hasIntegral_iff : HasIntegral I l f vol y \u2194\n    \u2200 \u03b5 > (0 : \u211d), \u2203 r : \u211d\u22650 \u2192 \u211d\u207f \u2192 Ioi (0 : \u211d), (\u2200 c, l.RCond (r c)) \u2227\n      \u2200 c \u03c0, l.MemBaseSet I c (r c) \u03c0 \u2192 IsPartition \u03c0 \u2192 dist (integralSum f vol \u03c0) y \u2264 \u03b5", "start": [192, 1], "end": [197, 51], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral.of_mul", "code": "theorem HasIntegral.of_mul (a : \u211d)\n    (h : \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 r : \u211d\u22650 \u2192 \u211d\u207f \u2192 Ioi (0 : \u211d), (\u2200 c, l.RCond (r c)) \u2227 \u2200 c \u03c0,\n      l.MemBaseSet I c (r c) \u03c0 \u2192 IsPartition \u03c0 \u2192 dist (integralSum f vol \u03c0) y \u2264 a * \u03b5) :\n    HasIntegral I l f vol y", "start": [200, 1], "end": [209, 62], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integrable_iff_cauchy", "code": "theorem integrable_iff_cauchy [CompleteSpace F] :\n    Integrable I l f vol \u2194 Cauchy ((l.toFilteriUnion I \u22a4).map (integralSum f vol))", "start": [212, 1], "end": [214, 37], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integrable_iff_cauchy_basis", "code": "theorem integrable_iff_cauchy_basis [CompleteSpace F] : Integrable I l f vol \u2194\n    \u2200 \u03b5 > (0 : \u211d), \u2203 r : \u211d\u22650 \u2192 \u211d\u207f \u2192 Ioi (0 : \u211d), (\u2200 c, l.RCond (r c)) \u2227\n      \u2200 c\u2081 c\u2082 \u03c0\u2081 \u03c0\u2082, l.MemBaseSet I c\u2081 (r c\u2081) \u03c0\u2081 \u2192 \u03c0\u2081.IsPartition \u2192 l.MemBaseSet I c\u2082 (r c\u2082) \u03c0\u2082 \u2192\n        \u03c0\u2082.IsPartition \u2192 dist (integralSum f vol \u03c0\u2081) (integralSum f vol \u03c0\u2082) \u2264 \u03b5", "start": [217, 1], "end": [231, 72], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral.mono", "code": "theorem HasIntegral.mono {l\u2081 l\u2082 : IntegrationParams} (h : HasIntegral I l\u2081 f vol y) (hl : l\u2082 \u2264 l\u2081) :\n    HasIntegral I l\u2082 f vol y", "start": [234, 1], "end": [236, 62], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.hasIntegral", "code": "protected theorem Integrable.hasIntegral (h : Integrable I l f vol) :\n    HasIntegral I l f vol (integral I l f vol)", "start": [239, 1], "end": [242, 32], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.mono", "code": "theorem Integrable.mono {l'} (h : Integrable I l f vol) (hle : l' \u2264 l) : Integrable I l' f vol", "start": [245, 1], "end": [246, 30], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral.unique", "code": "theorem HasIntegral.unique (h : HasIntegral I l f vol y) (h' : HasIntegral I l f vol y') : y = y'", "start": [249, 1], "end": [250, 27], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral.integrable", "code": "theorem HasIntegral.integrable (h : HasIntegral I l f vol y) : Integrable I l f vol", "start": [253, 1], "end": [254, 9], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral.integral_eq", "code": "theorem HasIntegral.integral_eq (h : HasIntegral I l f vol y) : integral I l f vol = y", "start": [257, 1], "end": [258, 36], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral.add", "code": "nonrec theorem HasIntegral.add (h : HasIntegral I l f vol y) (h' : HasIntegral I l g vol y') :\n    HasIntegral I l (f + g) vol (y + y')", "start": [261, 1], "end": [263, 61], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.add", "code": "theorem Integrable.add (hf : Integrable I l f vol) (hg : Integrable I l g vol) :\n    Integrable I l (f + g) vol", "start": [266, 1], "end": [268, 49], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integral_add", "code": "theorem integral_add (hf : Integrable I l f vol) (hg : Integrable I l g vol) :\n    integral I l (f + g) vol = integral I l f vol + integral I l g vol", "start": [271, 1], "end": [273, 50], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral.neg", "code": "nonrec theorem HasIntegral.neg (hf : HasIntegral I l f vol y) : HasIntegral I l (-f) vol (-y)", "start": [276, 1], "end": [277, 59], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.neg", "code": "theorem Integrable.neg (hf : Integrable I l f vol) : Integrable I l (-f) vol", "start": [280, 1], "end": [281, 32], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.of_neg", "code": "theorem Integrable.of_neg (hf : Integrable I l (-f) vol) : Integrable I l f vol", "start": [284, 1], "end": [285, 21], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integrable_neg", "code": "@[simp]\ntheorem integrable_neg : Integrable I l (-f) vol \u2194 Integrable I l f vol", "start": [288, 1], "end": [290, 38], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integral_neg", "code": "@[simp]\ntheorem integral_neg : integral I l (-f) vol = -integral I l f vol", "start": [293, 1], "end": [296, 89], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral.sub", "code": "theorem HasIntegral.sub (h : HasIntegral I l f vol y) (h' : HasIntegral I l g vol y') :\n    HasIntegral I l (f - g) vol (y - y')", "start": [299, 1], "end": [300, 94], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.sub", "code": "theorem Integrable.sub (hf : Integrable I l f vol) (hg : Integrable I l g vol) :\n    Integrable I l (f - g) vol", "start": [303, 1], "end": [305, 49], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integral_sub", "code": "theorem integral_sub (hf : Integrable I l f vol) (hg : Integrable I l g vol) :\n    integral I l (f - g) vol = integral I l f vol - integral I l g vol", "start": [308, 1], "end": [310, 50], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.hasIntegral_const", "code": "theorem hasIntegral_const (c : E) : HasIntegral I l (fun _ => c) vol (vol I c)", "start": [313, 1], "end": [315, 92], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integral_const", "code": "@[simp]\ntheorem integral_const (c : E) : integral I l (fun _ => c) vol = vol I c", "start": [318, 1], "end": [320, 36], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integrable_const", "code": "theorem integrable_const (c : E) : Integrable I l (fun _ => c) vol", "start": [323, 1], "end": [324, 27], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.hasIntegral_zero", "code": "theorem hasIntegral_zero : HasIntegral I l (fun _ => (0 : E)) vol 0", "start": [327, 1], "end": [328, 66], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integrable_zero", "code": "theorem integrable_zero : Integrable I l (fun _ => (0 : E)) vol", "start": [331, 1], "end": [332, 24], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integral_zero", "code": "theorem integral_zero : integral I l (fun _ => (0 : E)) vol = 0", "start": [335, 1], "end": [336, 31], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral.sum", "code": "theorem HasIntegral.sum {\u03b1 : Type*} {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u207f \u2192 E} {g : \u03b1 \u2192 F}\n    (h : \u2200 i \u2208 s, HasIntegral I l (f i) vol (g i)) :\n    HasIntegral I l (fun x => \u2211 i in s, f i x) vol (\u2211 i in s, g i)", "start": [339, 1], "end": [344, 26], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral.smul", "code": "theorem HasIntegral.smul (hf : HasIntegral I l f vol y) (c : \u211d) :\n    HasIntegral I l (c \u2022 f) vol (c \u2022 y)", "start": [347, 1], "end": [350, 53], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.smul", "code": "theorem Integrable.smul (hf : Integrable I l f vol) (c : \u211d) : Integrable I l (c \u2022 f) vol", "start": [353, 1], "end": [354, 37], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.of_smul", "code": "theorem Integrable.of_smul {c : \u211d} (hf : Integrable I l (c \u2022 f) vol) (hc : c \u2260 0) :\n    Integrable I l f vol", "start": [357, 1], "end": [359, 46], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integral_smul", "code": "@[simp]\ntheorem integral_smul (c : \u211d) : integral I l (fun x => c \u2022 f x) vol = c \u2022 integral I l f vol", "start": [362, 1], "end": [368, 65], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integral_nonneg", "code": "theorem integral_nonneg {g : \u211d\u207f \u2192 \u211d} (hg : \u2200 x \u2208 Box.Icc I, 0 \u2264 g x) (\u03bc : Measure \u211d\u207f)\n    [IsLocallyFiniteMeasure \u03bc] : 0 \u2264 integral I l g \u03bc.toBoxAdditive.toSMul", "start": [373, 1], "end": [380, 31], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.norm_integral_le_of_norm_le", "code": "theorem norm_integral_le_of_norm_le {g : \u211d\u207f \u2192 \u211d} (hle : \u2200 x \u2208 Box.Icc I, \u2016f x\u2016 \u2264 g x)\n    (\u03bc : Measure \u211d\u207f) [IsLocallyFiniteMeasure \u03bc] (hg : Integrable I l g \u03bc.toBoxAdditive.toSMul) :\n    \u2016(integral I l f \u03bc.toBoxAdditive.toSMul : E)\u2016 \u2264 integral I l g \u03bc.toBoxAdditive.toSMul", "start": [383, 1], "end": [395, 75], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.norm_integral_le_of_le_const", "code": "theorem norm_integral_le_of_le_const {c : \u211d} (hc : \u2200 x \u2208 Box.Icc I, \u2016f x\u2016 \u2264 c) (\u03bc : Measure \u211d\u207f)\n    [IsLocallyFiniteMeasure \u03bc] : \u2016(integral I l f \u03bc.toBoxAdditive.toSMul : E)\u2016 \u2264 (\u03bc I).toReal * c", "start": [398, 1], "end": [400, 93], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.convergenceR", "code": "def convergenceR (h : Integrable I l f vol) (\u03b5 : \u211d) : \u211d\u22650 \u2192 \u211d\u207f \u2192 Ioi (0 : \u211d) :=\n  if h\u03b5 : 0 < \u03b5 then (hasIntegral_iff.1 h.hasIntegral \u03b5 h\u03b5).choose\n  else fun _ _ => \u27e81, Set.mem_Ioi.2 zero_lt_one\u27e9", "start": [433, 1], "end": [442, 49], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.convergenceR_cond", "code": "theorem convergenceR_cond (h : Integrable I l f vol) (\u03b5 : \u211d) (c : \u211d\u22650) :\n    l.RCond (h.convergenceR \u03b5 c)", "start": [447, 1], "end": [450, 82], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.dist_integralSum_integral_le_of_memBaseSet", "code": "theorem dist_integralSum_integral_le_of_memBaseSet (h : Integrable I l f vol) (h\u2080 : 0 < \u03b5)\n    (h\u03c0 : l.MemBaseSet I c (h.convergenceR \u03b5 c) \u03c0) (h\u03c0p : \u03c0.IsPartition) :\n    dist (integralSum f vol \u03c0) (integral I l f vol) \u2264 \u03b5", "start": [453, 1], "end": [457, 72], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.dist_integralSum_le_of_memBaseSet", "code": "theorem dist_integralSum_le_of_memBaseSet (h : Integrable I l f vol) (hpos\u2081 : 0 < \u03b5\u2081)\n    (hpos\u2082 : 0 < \u03b5\u2082) (h\u2081 : l.MemBaseSet I c\u2081 (h.convergenceR \u03b5\u2081 c\u2081) \u03c0\u2081)\n    (h\u2082 : l.MemBaseSet I c\u2082 (h.convergenceR \u03b5\u2082 c\u2082) \u03c0\u2082) (HU : \u03c0\u2081.iUnion = \u03c0\u2082.iUnion) :\n    dist (integralSum f vol \u03c0\u2081) (integralSum f vol \u03c0\u2082) \u2264 \u03b5\u2081 + \u03b5\u2082", "start": [460, 1], "end": [495, 93], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.tendsto_integralSum_toFilter_prod_self_inf_iUnion_eq_uniformity", "code": "theorem tendsto_integralSum_toFilter_prod_self_inf_iUnion_eq_uniformity (h : Integrable I l f vol) :\n    Tendsto (fun \u03c0 : TaggedPrepartition I \u00d7 TaggedPrepartition I =>\n      (integralSum f vol \u03c0.1, integralSum f vol \u03c0.2))\n        ((l.toFilter I \u00d7\u02e2 l.toFilter I) \u2293 \ud835\udcdf {\u03c0 | \u03c0.1.iUnion = \u03c0.2.iUnion}) (\ud835\udce4 F)", "start": [498, 1], "end": [510, 83], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.cauchy_map_integralSum_toFilteriUnion", "code": "theorem cauchy_map_integralSum_toFilteriUnion (h : Integrable I l f vol) (\u03c0\u2080 : Prepartition I) :\n    Cauchy ((l.toFilteriUnion I \u03c0\u2080).map (integralSum f vol))", "start": [513, 1], "end": [521, 74], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.to_subbox_aux", "code": "theorem to_subbox_aux (h : Integrable I l f vol) (hJ : J \u2264 I) :\n    \u2203 y : F, HasIntegral J l f vol y \u2227\n      Tendsto (integralSum f vol) (l.toFilteriUnion I (Prepartition.single I J hJ)) (\ud835\udcdd y)", "start": [526, 1], "end": [531, 61], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.to_subbox", "code": "theorem to_subbox (h : Integrable I l f vol) (hJ : J \u2264 I) : Integrable J l f vol", "start": [534, 1], "end": [536, 45], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.tendsto_integralSum_toFilteriUnion_single", "code": "theorem tendsto_integralSum_toFilteriUnion_single (h : Integrable I l f vol) (hJ : J \u2264 I) :\n    Tendsto (integralSum f vol) (l.toFilteriUnion I (Prepartition.single I J hJ))\n      (\ud835\udcdd <| integral J l f vol)", "start": [539, 1], "end": [545, 27], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.dist_integralSum_sum_integral_le_of_memBaseSet_of_iUnion_eq", "code": "theorem dist_integralSum_sum_integral_le_of_memBaseSet_of_iUnion_eq (h : Integrable I l f vol)\n    (h0 : 0 < \u03b5) (h\u03c0 : l.MemBaseSet I c (h.convergenceR \u03b5 c) \u03c0) {\u03c0\u2080 : Prepartition I}\n    (hU : \u03c0.iUnion = \u03c0\u2080.iUnion) :\n    dist (integralSum f vol \u03c0) (\u2211 J in \u03c0\u2080.boxes, integral J l f vol) \u2264 \u03b5", "start": [548, 1], "end": [606, 37], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.dist_integralSum_sum_integral_le_of_memBaseSet", "code": "theorem dist_integralSum_sum_integral_le_of_memBaseSet (h : Integrable I l f vol) (h0 : 0 < \u03b5)\n    (h\u03c0 : l.MemBaseSet I c (h.convergenceR \u03b5 c) \u03c0) :\n    dist (integralSum f vol \u03c0) (\u2211 J in \u03c0.boxes, integral J l f vol) \u2264 \u03b5", "start": [609, 1], "end": [625, 74], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.tendsto_integralSum_sum_integral", "code": "theorem tendsto_integralSum_sum_integral (h : Integrable I l f vol) (\u03c0\u2080 : Prepartition I) :\n    Tendsto (integralSum f vol) (l.toFilteriUnion I \u03c0\u2080)\n      (\ud835\udcdd <| \u2211 J in \u03c0\u2080.boxes, integral J l f vol)", "start": [628, 1], "end": [637, 79], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.sum_integral_congr", "code": "theorem sum_integral_congr (h : Integrable I l f vol) {\u03c0\u2081 \u03c0\u2082 : Prepartition I}\n    (hU : \u03c0\u2081.iUnion = \u03c0\u2082.iUnion) :\n    \u2211 J in \u03c0\u2081.boxes, integral J l f vol = \u2211 J in \u03c0\u2082.boxes, integral J l f vol", "start": [640, 1], "end": [650, 46], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.Integrable.toBoxAdditive", "code": "@[simps]\ndef toBoxAdditive (h : Integrable I l f vol) : \u03b9 \u2192\u1d47\u1d43[I] F where\n  toFun J := integral J l f vol\n  sum_partition_boxes' J hJ \u03c0 h\u03c0 := by\n    replace h\u03c0 := h\u03c0.iUnion_eq; rw [\u2190 Prepartition.iUnion_top] at h\u03c0\n    rw [(h.to_subbox (WithTop.coe_le_coe.1 hJ)).sum_integral_congr h\u03c0, Prepartition.top_boxes,\n      sum_singleton]", "start": [653, 1], "end": [664, 21], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.integrable_of_continuousOn", "code": "theorem integrable_of_continuousOn [CompleteSpace E] {I : Box \u03b9} {f : \u211d\u207f \u2192 E}\n    (hc : ContinuousOn f (Box.Icc I)) (\u03bc : Measure \u211d\u207f) [IsLocallyFiniteMeasure \u03bc] :\n    Integrable.{u, v, v} I l f \u03bc.toBoxAdditive.toSMul", "start": [678, 1], "end": [710, 14], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral.of_bRiemann_eq_false_of_forall_isLittleO", "code": "theorem HasIntegral.of_bRiemann_eq_false_of_forall_isLittleO (hl : l.bRiemann = false)\n    (B : \u03b9 \u2192\u1d47\u1d43[I] \u211d) (hB0 : \u2200 J, 0 \u2264 B J) (g : \u03b9 \u2192\u1d47\u1d43[I] F) (s : Set \u211d\u207f) (hs : s.Countable)\n    (hlH : s.Nonempty \u2192 l.bHenstock = true)\n    (H\u2081 : \u2200 (c : \u211d\u22650), \u2200 x \u2208 Box.Icc I \u2229 s, \u2200 \u03b5 > (0 : \u211d),\n      \u2203 \u03b4 > 0, \u2200 J \u2264 I, Box.Icc J \u2286 Metric.closedBall x \u03b4 \u2192 x \u2208 Box.Icc J \u2192\n        (l.bDistortion \u2192 J.distortion \u2264 c) \u2192 dist (vol J (f x)) (g J) \u2264 \u03b5)\n    (H\u2082 : \u2200 (c : \u211d\u22650), \u2200 x \u2208 Box.Icc I \\ s, \u2200 \u03b5 > (0 : \u211d),\n      \u2203 \u03b4 > 0, \u2200 J \u2264 I, Box.Icc J \u2286 Metric.closedBall x \u03b4 \u2192 (l.bHenstock \u2192 x \u2208 Box.Icc J) \u2192\n        (l.bDistortion \u2192 J.distortion \u2264 c) \u2192 dist (vol J (f x)) (g J) \u2264 \u03b5 * B J) :\n    HasIntegral I l f vol (g I)", "start": [717, 1], "end": [790, 24], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral.of_le_Henstock_of_forall_isLittleO", "code": "theorem HasIntegral.of_le_Henstock_of_forall_isLittleO (hl : l \u2264 Henstock) (B : \u03b9 \u2192\u1d47\u1d43[I] \u211d)\n    (hB0 : \u2200 J, 0 \u2264 B J) (g : \u03b9 \u2192\u1d47\u1d43[I] F) (s : Set \u211d\u207f) (hs : s.Countable)\n    (H\u2081 : \u2200 (c : \u211d\u22650), \u2200 x \u2208 Box.Icc I \u2229 s, \u2200 \u03b5 > (0 : \u211d),\n      \u2203 \u03b4 > 0, \u2200 J \u2264 I, Box.Icc J \u2286 Metric.closedBall x \u03b4 \u2192 x \u2208 Box.Icc J \u2192\n        (l.bDistortion \u2192 J.distortion \u2264 c) \u2192 dist (vol J (f x)) (g J) \u2264 \u03b5)\n    (H\u2082 : \u2200 (c : \u211d\u22650), \u2200 x \u2208 Box.Icc I \\ s, \u2200 \u03b5 > (0 : \u211d),\n      \u2203 \u03b4 > 0, \u2200 J \u2264 I, Box.Icc J \u2286 Metric.closedBall x \u03b4 \u2192 x \u2208 Box.Icc J \u2192\n        (l.bDistortion \u2192 J.distortion \u2264 c) \u2192 dist (vol J (f x)) (g J) \u2264 \u03b5 * B J) :\n    HasIntegral I l f vol (g I)", "start": [794, 1], "end": [824, 64], "kind": "commanddeclaration"}, {"full_name": "BoxIntegral.HasIntegral.mcShane_of_forall_isLittleO", "code": "theorem HasIntegral.mcShane_of_forall_isLittleO (B : \u03b9 \u2192\u1d47\u1d43[I] \u211d) (hB0 : \u2200 J, 0 \u2264 B J)\n    (g : \u03b9 \u2192\u1d47\u1d43[I] F) (H : \u2200 (c : \u211d\u22650), \u2200 x \u2208 Box.Icc I, \u2200 \u03b5 > (0 : \u211d), \u2203 \u03b4 > 0, \u2200 J \u2264 I,\n      Box.Icc J \u2286 Metric.closedBall x \u03b4 \u2192 dist (vol J (f x)) (g J) \u2264 \u03b5 * B J) :\n    HasIntegral I McShane f vol (g I)", "start": [828, 1], "end": [846, 95], "kind": "commanddeclaration"}]}
